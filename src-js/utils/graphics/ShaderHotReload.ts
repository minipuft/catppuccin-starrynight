/**
 * ShaderHotReload - Development-time shader hot-reloading system
 * 
 * Enables real-time shader editing by watching for file changes and
 * automatically recompiling and updating WebGL programs without
 * requiring page refresh.
 * 
 * @architecture Year3000System
 * @performance Development-only feature, disabled in production
 * @security File watching requires local development environment
 */

export interface ShaderSource {
  vertex: string;
  fragment: string;
  uniforms?: Record<string, any>;
}

export interface ShaderProgram {
  program: WebGLProgram;
  uniforms: Record<string, WebGLUniformLocation | null>;
  attributes: Record<string, number>;
}

export interface HotReloadConfig {
  enabled: boolean;
  watchInterval: number; // ms
  autoRecompile: boolean;
  preserveUniforms: boolean;
  debugLogging: boolean;
}

/**
 * Hot-reload manager for WebGL shaders during development
 */
export class ShaderHotReload {
  private gl: WebGL2RenderingContext;
  private config: HotReloadConfig;
  private watchedShaders: Map<string, {
    source: ShaderSource;
    program: ShaderProgram | null;
    lastModified: number;
    callbacks: ((program: ShaderProgram | null) => void)[];
    uniformValues: Record<string, any>;
  }> = new Map();
  
  private watchInterval: number | null = null;
  private isWatching = false;
  
  constructor(\n    gl: WebGL2RenderingContext,\n    config: Partial<HotReloadConfig> = {}\n  ) {\n    this.gl = gl;\n    \n    this.config = {\n      enabled: process.env.NODE_ENV === 'development',\n      watchInterval: 1000, // Check for changes every second\n      autoRecompile: true,\n      preserveUniforms: true,\n      debugLogging: true,\n      ...config\n    };\n    \n    if (!this.config.enabled) {\n      console.log('[ShaderHotReload] Disabled (not in development mode)');\n      return;\n    }\n    \n    if (this.config.debugLogging) {\n      console.log('[ShaderHotReload] Initialized', this.config);\n    }\n  }\n  \n  /**\n   * Register a shader for hot-reloading\n   * \n   * @param shaderId - Unique identifier for this shader\n   * @param vertexSource - Vertex shader source code\n   * @param fragmentSource - Fragment shader source code\n   * @param callback - Function called when shader is recompiled\n   * @returns Initial compiled shader program\n   */\n  registerShader(\n    shaderId: string,\n    vertexSource: string,\n    fragmentSource: string,\n    callback: (program: ShaderProgram | null) => void\n  ): ShaderProgram | null {\n    if (!this.config.enabled) {\n      // In production, just compile once and return\n      const program = this.compileShaderProgram(vertexSource, fragmentSource);\n      if (program) {\n        callback(program);\n      }\n      return program;\n    }\n    \n    const source: ShaderSource = {\n      vertex: vertexSource,\n      fragment: fragmentSource\n    };\n    \n    // Compile initial program\n    const program = this.compileShaderProgram(vertexSource, fragmentSource);\n    \n    // Register for watching\n    this.watchedShaders.set(shaderId, {\n      source,\n      program,\n      lastModified: Date.now(),\n      callbacks: [callback],\n      uniformValues: {}\n    });\n    \n    // Start watching if not already\n    if (!this.isWatching) {\n      this.startWatching();\n    }\n    \n    if (this.config.debugLogging) {\n      console.log(`[ShaderHotReload] Registered shader: ${shaderId}`);\n    }\n    \n    // Call initial callback\n    if (program) {\n      callback(program);\n    }\n    \n    return program;\n  }\n  \n  /**\n   * Update shader source and trigger recompilation\n   * Simulates file change in development environment\n   * \n   * @param shaderId - Shader identifier\n   * @param vertexSource - New vertex shader source (optional)\n   * @param fragmentSource - New fragment shader source (optional)\n   */\n  updateShaderSource(\n    shaderId: string,\n    vertexSource?: string,\n    fragmentSource?: string\n  ): void {\n    if (!this.config.enabled) return;\n    \n    const watched = this.watchedShaders.get(shaderId);\n    if (!watched) {\n      console.warn(`[ShaderHotReload] Shader not registered: ${shaderId}`);\n      return;\n    }\n    \n    // Update source\n    if (vertexSource !== undefined) {\n      watched.source.vertex = vertexSource;\n    }\n    if (fragmentSource !== undefined) {\n      watched.source.fragment = fragmentSource;\n    }\n    \n    watched.lastModified = Date.now();\n    \n    if (this.config.autoRecompile) {\n      this.recompileShader(shaderId);\n    }\n    \n    if (this.config.debugLogging) {\n      console.log(`[ShaderHotReload] Updated shader source: ${shaderId}`);\n    }\n  }\n  \n  /**\n   * Store uniform values for preservation across recompiles\n   * \n   * @param shaderId - Shader identifier\n   * @param uniforms - Current uniform values\n   */\n  preserveUniforms(shaderId: string, uniforms: Record<string, any>): void {\n    if (!this.config.enabled || !this.config.preserveUniforms) return;\n    \n    const watched = this.watchedShaders.get(shaderId);\n    if (watched) {\n      watched.uniformValues = { ...uniforms };\n    }\n  }\n  \n  /**\n   * Get preserved uniform values for a shader\n   * \n   * @param shaderId - Shader identifier\n   * @returns Preserved uniform values\n   */\n  getPreservedUniforms(shaderId: string): Record<string, any> {\n    if (!this.config.enabled) return {};\n    \n    const watched = this.watchedShaders.get(shaderId);\n    return watched ? { ...watched.uniformValues } : {};\n  }\n  \n  /**\n   * Manually trigger recompilation of a shader\n   * \n   * @param shaderId - Shader identifier\n   */\n  recompileShader(shaderId: string): void {\n    if (!this.config.enabled) return;\n    \n    const watched = this.watchedShaders.get(shaderId);\n    if (!watched) return;\n    \n    if (this.config.debugLogging) {\n      console.log(`[ShaderHotReload] Recompiling shader: ${shaderId}`);\n    }\n    \n    // Preserve current uniform values\n    const preservedUniforms = { ...watched.uniformValues };\n    \n    // Clean up old program\n    if (watched.program) {\n      this.gl.deleteProgram(watched.program.program);\n    }\n    \n    // Compile new program\n    const newProgram = this.compileShaderProgram(\n      watched.source.vertex,\n      watched.source.fragment\n    );\n    \n    watched.program = newProgram;\n    \n    // Notify all callbacks\n    watched.callbacks.forEach(callback => {\n      try {\n        callback(newProgram);\n      } catch (error) {\n        console.error(`[ShaderHotReload] Callback error for ${shaderId}:`, error);\n      }\n    });\n    \n    // Restore preserved uniform values if requested\n    if (this.config.preserveUniforms && newProgram) {\n      watched.uniformValues = preservedUniforms;\n    }\n    \n    if (this.config.debugLogging) {\n      if (newProgram) {\n        console.log(`[ShaderHotReload] Successfully recompiled: ${shaderId}`);\n      } else {\n        console.error(`[ShaderHotReload] Failed to recompile: ${shaderId}`);\n      }\n    }\n  }\n  \n  /**\n   * Add callback for shader recompilation\n   * \n   * @param shaderId - Shader identifier\n   * @param callback - Function to call when shader is recompiled\n   */\n  addRecompileCallback(\n    shaderId: string,\n    callback: (program: ShaderProgram | null) => void\n  ): void {\n    const watched = this.watchedShaders.get(shaderId);\n    if (watched) {\n      watched.callbacks.push(callback);\n    }\n  }\n  \n  /**\n   * Start watching for shader changes\n   */\n  startWatching(): void {\n    if (!this.config.enabled || this.isWatching) return;\n    \n    this.isWatching = true;\n    \n    // In a real development environment, this would watch actual files\n    // For now, we'll create a polling system that can be triggered manually\n    this.watchInterval = window.setInterval(() => {\n      // Check if any shaders have been marked for recompilation\n      // This is a placeholder - in a real implementation, you'd watch the filesystem\n      this.checkForShaderChanges();\n    }, this.config.watchInterval);\n    \n    if (this.config.debugLogging) {\n      console.log('[ShaderHotReload] Started watching for shader changes');\n    }\n  }\n  \n  /**\n   * Stop watching for shader changes\n   */\n  stopWatching(): void {\n    if (this.watchInterval) {\n      clearInterval(this.watchInterval);\n      this.watchInterval = null;\n    }\n    \n    this.isWatching = false;\n    \n    if (this.config.debugLogging) {\n      console.log('[ShaderHotReload] Stopped watching for shader changes');\n    }\n  }\n  \n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    this.stopWatching();\n    \n    // Clean up all shader programs\n    for (const [shaderId, watched] of this.watchedShaders) {\n      if (watched.program) {\n        this.gl.deleteProgram(watched.program.program);\n      }\n    }\n    \n    this.watchedShaders.clear();\n    \n    if (this.config.debugLogging) {\n      console.log('[ShaderHotReload] Destroyed');\n    }\n  }\n  \n  /**\n   * Get list of registered shaders\n   */\n  getRegisteredShaders(): string[] {\n    return Array.from(this.watchedShaders.keys());\n  }\n  \n  /**\n   * Get shader info for debugging\n   */\n  getShaderInfo(shaderId: string): {\n    hasProgram: boolean;\n    lastModified: number;\n    callbackCount: number;\n    preservedUniformCount: number;\n  } | null {\n    const watched = this.watchedShaders.get(shaderId);\n    if (!watched) return null;\n    \n    return {\n      hasProgram: watched.program !== null,\n      lastModified: watched.lastModified,\n      callbackCount: watched.callbacks.length,\n      preservedUniformCount: Object.keys(watched.uniformValues).length\n    };\n  }\n  \n  // ========================================================================\n  // PRIVATE METHODS\n  // ========================================================================\n  \n  private compileShaderProgram(\n    vertexSource: string,\n    fragmentSource: string\n  ): ShaderProgram | null {\n    const vertexShader = this.compileShader(this.gl.VERTEX_SHADER, vertexSource);\n    if (!vertexShader) return null;\n    \n    const fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, fragmentSource);\n    if (!fragmentShader) {\n      this.gl.deleteShader(vertexShader);\n      return null;\n    }\n    \n    const program = this.gl.createProgram();\n    if (!program) {\n      this.gl.deleteShader(vertexShader);\n      this.gl.deleteShader(fragmentShader);\n      return null;\n    }\n    \n    this.gl.attachShader(program, vertexShader);\n    this.gl.attachShader(program, fragmentShader);\n    this.gl.linkProgram(program);\n    \n    // Clean up shaders (they're linked into the program now)\n    this.gl.deleteShader(vertexShader);\n    this.gl.deleteShader(fragmentShader);\n    \n    if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {\n      const error = this.gl.getProgramInfoLog(program);\n      console.error('[ShaderHotReload] Program linking failed:', error);\n      this.gl.deleteProgram(program);\n      return null;\n    }\n    \n    // Extract uniform and attribute locations\n    const uniforms: Record<string, WebGLUniformLocation | null> = {};\n    const attributes: Record<string, number> = {};\n    \n    const numUniforms = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);\n    for (let i = 0; i < numUniforms; i++) {\n      const uniformInfo = this.gl.getActiveUniform(program, i);\n      if (uniformInfo) {\n        uniforms[uniformInfo.name] = this.gl.getUniformLocation(program, uniformInfo.name);\n      }\n    }\n    \n    const numAttributes = this.gl.getProgramParameter(program, this.gl.ACTIVE_ATTRIBUTES);\n    for (let i = 0; i < numAttributes; i++) {\n      const attributeInfo = this.gl.getActiveAttrib(program, i);\n      if (attributeInfo) {\n        attributes[attributeInfo.name] = this.gl.getAttribLocation(program, attributeInfo.name);\n      }\n    }\n    \n    return {\n      program,\n      uniforms,\n      attributes\n    };\n  }\n  \n  private compileShader(type: number, source: string): WebGLShader | null {\n    const shader = this.gl.createShader(type);\n    if (!shader) return null;\n    \n    this.gl.shaderSource(shader, source);\n    this.gl.compileShader(shader);\n    \n    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n      const error = this.gl.getShaderInfoLog(shader);\n      const shaderType = type === this.gl.VERTEX_SHADER ? 'vertex' : 'fragment';\n      console.error(`[ShaderHotReload] ${shaderType} shader compilation failed:`, error);\n      console.error('Shader source:', source);\n      this.gl.deleteShader(shader);\n      return null;\n    }\n    \n    return shader;\n  }\n  \n  private checkForShaderChanges(): void {\n    // Placeholder for file system watching\n    // In a real implementation, this would check file modification times\n    // or use a file watcher API\n    \n    // For development purposes, you can manually trigger recompilation\n    // by calling updateShaderSource() or recompileShader()\n  }\n}\n\n// ============================================================================\n// DEVELOPMENT UTILITIES\n// ============================================================================\n\n/**\n * Load shader source from external files (development utility)\n * In production, shaders should be bundled with the application\n */\nexport async function loadShaderFromFile(path: string): Promise<string> {\n  if (process.env.NODE_ENV !== 'development') {\n    throw new Error('loadShaderFromFile is only available in development mode');\n  }\n  \n  try {\n    const response = await fetch(path);\n    if (!response.ok) {\n      throw new Error(`Failed to load shader: ${response.statusText}`);\n    }\n    return await response.text();\n  } catch (error) {\n    console.error(`[ShaderHotReload] Failed to load shader from ${path}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Global shader hot-reload instance for debugging\n */\nexport let globalShaderHotReload: ShaderHotReload | null = null;\n\n/**\n * Initialize global shader hot-reload for debugging\n */\nexport function initGlobalShaderHotReload(gl: WebGL2RenderingContext): void {\n  if (process.env.NODE_ENV === 'development') {\n    globalShaderHotReload = new ShaderHotReload(gl, {\n      debugLogging: true\n    });\n    \n    // Expose to global scope for debugging\n    if (typeof window !== 'undefined') {\n      (window as any).shaderHotReload = globalShaderHotReload;\n    }\n  }\n}