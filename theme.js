"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src-js/config/coreTheme.ts
  var CATPPUCCIN_FLAVORS, ACCENT_COLORS, CORE_THEME_VALIDATORS;
  var init_coreTheme = __esm({
    "src-js/config/coreTheme.ts"() {
      "use strict";
      CATPPUCCIN_FLAVORS = {
        latte: {
          name: "Latte",
          base: "#eff1f5",
          text: "#4c4f69",
          isDark: false
        },
        frappe: {
          name: "Frapp\xE9",
          base: "#303446",
          text: "#c6d0f5",
          isDark: true
        },
        macchiato: {
          name: "Macchiato",
          base: "#24273a",
          text: "#cad3f5",
          isDark: true
        },
        mocha: {
          name: "Mocha",
          base: "#1e1e2e",
          text: "#cdd6f4",
          isDark: true
        }
      };
      ACCENT_COLORS = [
        "rosewater",
        "flamingo",
        "pink",
        "mauve",
        "red",
        "maroon",
        "peach",
        "yellow",
        "green",
        "teal",
        "sky",
        "sapphire",
        "blue",
        "lavender",
        "text",
        "none"
      ];
      CORE_THEME_VALIDATORS = {
        flavor: /* @__PURE__ */ __name((value) => typeof value === "string" && value in CATPPUCCIN_FLAVORS, "flavor"),
        accentColor: /* @__PURE__ */ __name((value) => typeof value === "string" && ACCENT_COLORS.includes(value), "accentColor"),
        brightnessMode: /* @__PURE__ */ __name((value) => typeof value === "string" && ["bright", "balanced", "dark"].includes(value), "brightnessMode"),
        paletteSystem: /* @__PURE__ */ __name((value) => typeof value === "string" && ["catppuccin", "year3000"].includes(value), "paletteSystem"),
        gradientIntensity: /* @__PURE__ */ __name((value) => typeof value === "string" && ["disabled", "minimal", "balanced", "intense"].includes(value), "gradientIntensity"),
        glassmorphismLevel: /* @__PURE__ */ __name((value) => typeof value === "string" && ["disabled", "minimal", "moderate", "intense"].includes(value), "glassmorphismLevel"),
        webglEnabled: /* @__PURE__ */ __name((value) => typeof value === "boolean" || typeof value === "string" && ["true", "false"].includes(value), "webglEnabled"),
        animationQuality: /* @__PURE__ */ __name((value) => typeof value === "string" && ["auto", "low", "high"].includes(value), "animationQuality"),
        webglQuality: /* @__PURE__ */ __name((value) => typeof value === "string" && ["low", "medium", "high"].includes(value), "webglQuality")
      };
    }
  });

  // src-js/config/harmonicModes.ts
  var HARMONIC_MODES, MUSIC_VISUAL_SYNC, ENHANCED_BPM_CONFIG;
  var init_harmonicModes = __esm({
    "src-js/config/harmonicModes.ts"() {
      "use strict";
      HARMONIC_MODES = {
        "analogous-flow": {
          rule: "analogous",
          angle: 30,
          description: "Flowing cinematic gradients with adjacent hues"
        },
        "triadic-trinity": {
          rule: "triadic",
          angle: 120,
          description: "Dramatic three-color gradient dynamics"
        },
        "complementary-yin-yang": {
          rule: "complementary",
          angle: 180,
          description: "Electric contrast gradients with opposing forces"
        },
        "tetradic-cosmic-cross": {
          rule: "tetradic",
          angle: 90,
          description: "Complex four-color gradient matrix"
        },
        "split-complementary-aurora": {
          rule: "split-complementary",
          angle: 150,
          description: "Aurora-like gradient flows with polar contrasts"
        },
        "monochromatic-meditation": {
          rule: "monochromatic",
          angle: 0,
          description: "Intense single-hue gradient depth"
        }
      };
      MUSIC_VISUAL_SYNC = {
        energyScaling: {
          low: 0.8,
          // Enhanced low energy for subtle gradients
          medium: 1.2,
          // Increased medium energy for dynamic gradients  
          high: 1.8
          // Maximum high energy for intense gradient flows
        },
        valenceScaling: {
          sad: 1,
          // Enhanced sad scaling for dramatic gradients
          neutral: 1.2,
          // Increased neutral for balanced gradients
          happy: 1.6
          // Maximum happy scaling for vibrant gradients
        },
        danceabilityEffects: {
          enable: true,
          animationSpeedMultiplier: 1.5,
          blurVariation: 0.3
        }
      };
      ENHANCED_BPM_CONFIG = {
        enable: true,
        useSmartCalculation: true,
        useRealisticData: true,
        // Tempo-based danceability estimation ranges
        danceabilityEstimation: {
          highDance: { min: 120, max: 140, value: 0.8 },
          // House/Dance music
          mediumDance: { min: 100, max: 160, value: 0.6 },
          // Pop/Electronic
          lowMediumDance: { min: 80, max: 180, value: 0.4 },
          // General music
          lowDance: { value: 0.2 }
          // Very slow/fast
        },
        // Energy estimation from tempo + loudness  
        energyEstimation: {
          tempoWeight: 0.6,
          loudnessWeight: 0.4,
          tempoRange: { min: 60, max: 180 },
          loudnessRange: { min: -60, max: 0 }
        },
        // Enhanced BPM calculation parameters
        danceabilityThresholds: {
          high: 0.7,
          // High danceability - use full tempo
          low: 0.3
          // Low danceability - may reduce tempo
        },
        energyMultiplierRange: {
          min: 0.8,
          // Minimum energy multiplier
          max: 1.4
          // Maximum energy multiplier  
        },
        tempoMultipliers: {
          highDance: 1,
          // Full tempo for danceable tracks
          mediumDance: 0.75,
          // Moderate reduction
          lowDance: 0.5
          // Significant reduction for smooth visuals
        },
        // Fallback values when audio data is unavailable
        fallbacks: {
          tempo: 120,
          loudness: -10,
          danceability: 0.5,
          energy: 0.5,
          key: 0,
          timeSignature: 4
        }
      };
    }
  });

  // src-js/config/artisticProfiles.ts
  var ARTISTIC_MODE_PROFILES;
  var init_artisticProfiles = __esm({
    "src-js/config/artisticProfiles.ts"() {
      "use strict";
      ARTISTIC_MODE_PROFILES = {
        "corporate-safe": {
          displayName: "Corporate Safe",
          description: "Subtle gradient elegance with professional restraint and refined color transitions",
          philosophy: "Gentle gradient flows that maintain workspace harmony while providing sophisticated visual depth",
          multipliers: {
            opacity: 0.2,
            saturation: 1.15,
            // Enhanced for subtle gradient definition
            brightness: 1.08,
            // Improved brightness for gentle luminance
            contrast: 1.05,
            // Slight contrast improvement for definition
            musicEnergyBoost: 0.4,
            // Year 3000 Kinetic Parameters
            kineticIntensity: 0.3,
            temporalPlayFactor: 0.2,
            aestheticGravityStrength: 0.2,
            emergentChoreography: false,
            visualIntensityBase: 0.9
          },
          features: {
            rippleEffects: false,
            temporalEcho: false,
            particleStreams: false,
            predictiveHighlights: true,
            // Subtle only
            glassEffects: true,
            // Minimal
            beatSync: false,
            colorHarmony: false,
            aestheticGravity: false
            // Disabled for professional environments
          },
          performance: {
            maxParticles: 0,
            animationThrottle: 32,
            // 30fps for efficiency
            enableGPUAcceleration: false,
            reducedMotion: true
          }
        },
        "artist-vision": {
          displayName: "Artist Vision",
          description: "Cinematic gradient expression with vibrant, flowing color transitions",
          philosophy: "Dramatic gradient harmonies that create depth and emotional resonance through bold color interactions",
          multipliers: {
            opacity: 0.35,
            saturation: 1.45,
            // Enhanced for vibrant gradients
            brightness: 1.25,
            // Increased luminance for gradient depth
            contrast: 1.3,
            // Higher contrast for dramatic effects
            musicEnergyBoost: 1.2,
            // Year 3000 Kinetic Parameters
            kineticIntensity: 0.8,
            temporalPlayFactor: 0.7,
            aestheticGravityStrength: 0.6,
            emergentChoreography: true,
            visualIntensityBase: 1.2
          },
          features: {
            rippleEffects: true,
            // Moderate intensity
            temporalEcho: true,
            // Subtle trails
            particleStreams: true,
            // Music-responsive
            predictiveHighlights: true,
            glassEffects: true,
            beatSync: true,
            // Musical harmony
            colorHarmony: true,
            // Respectful blending
            aestheticGravity: true
            // Balanced gravitational effects
          },
          performance: {
            maxParticles: 20,
            animationThrottle: 16,
            // 60fps
            enableGPUAcceleration: true,
            reducedMotion: false
          }
        },
        "cosmic-maximum": {
          displayName: "Cosmic Maximum",
          description: "Ultra-intense cinematic gradients with maximum color saturation and fluid dynamics",
          philosophy: "Maximum gradient intensity through electric color combinations that create immersive visual landscapes",
          multipliers: {
            opacity: 0.55,
            saturation: 1.65,
            // Maximum saturation for electric gradients
            brightness: 1.35,
            // Enhanced brightness for luminous effects
            contrast: 1.5,
            // Maximum contrast for dramatic depth
            musicEnergyBoost: 2.5,
            // Year 3000 Kinetic Parameters
            kineticIntensity: 2,
            temporalPlayFactor: 3,
            aestheticGravityStrength: 2,
            emergentChoreography: true,
            visualIntensityBase: 1.8
          },
          features: {
            rippleEffects: true,
            // Full intensity
            temporalEcho: true,
            // Visible trails
            particleStreams: true,
            // Attention flow
            predictiveHighlights: true,
            // Advanced prediction
            glassEffects: true,
            // Intense
            beatSync: true,
            // Full synchronization
            colorHarmony: true,
            // Dynamic evolution
            aestheticGravity: true
            // Visual magnetism
          },
          performance: {
            maxParticles: 50,
            animationThrottle: 30,
            // 30fps for smoothness
            enableGPUAcceleration: true,
            reducedMotion: false
          }
        }
      };
    }
  });

  // src-js/config/performanceProfiles.ts
  var PERFORMANCE_PROFILES, DEFAULT_LOGGING_CONFIG;
  var init_performanceProfiles = __esm({
    "src-js/config/performanceProfiles.ts"() {
      "use strict";
      PERFORMANCE_PROFILES = {
        low: {
          maxParticles: 15,
          animationThrottle: 32,
          // ~30fps
          enableGPUAcceleration: false,
          enableAdvancedShaders: false,
          textureResolution: 0.5
        },
        balanced: {
          maxParticles: 40,
          animationThrottle: 16,
          // ~60fps
          enableGPUAcceleration: true,
          enableAdvancedShaders: false,
          textureResolution: 1
        },
        high: {
          maxParticles: 75,
          animationThrottle: 16,
          // ~60fps
          enableGPUAcceleration: true,
          enableAdvancedShaders: true,
          textureResolution: 1
        },
        ultra: {
          maxParticles: 150,
          animationThrottle: 8,
          // ~120fps
          enableGPUAcceleration: true,
          enableAdvancedShaders: true,
          textureResolution: 2
          // High-res textures
        }
      };
      DEFAULT_LOGGING_CONFIG = {
        level: "info",
        performance: {
          enableFrameBudgetWarnings: true,
          throttleWarnings: true,
          throttleInterval: 5e3,
          // ms between repeated warnings
          enableAdaptiveDegradation: true
        }
      };
    }
  });

  // src-js/config/settingKeys.ts
  var HARMONIC_INTENSITY_KEY, HARMONIC_EVOLUTION_KEY, GLASS_LEVEL_KEY;
  var init_settingKeys = __esm({
    "src-js/config/settingKeys.ts"() {
      "use strict";
      HARMONIC_INTENSITY_KEY = "sn-harmonic-intensity";
      HARMONIC_EVOLUTION_KEY = "sn-harmonic-evolution";
      GLASS_LEVEL_KEY = "sn-glassmorphism-level";
    }
  });

  // src-js/config/settingsSchema.ts
  function validateSetting(key, value) {
    const metadata = SETTINGS_METADATA[key];
    return metadata.validator(value);
  }
  function parseSetting(key, value) {
    const metadata = SETTINGS_METADATA[key];
    if (metadata.parser) {
      return metadata.parser(value);
    }
    if (metadata.validator(value)) {
      return value;
    }
    return null;
  }
  function serializeSetting(key, value) {
    const metadata = SETTINGS_METADATA[key];
    if (metadata.serializer) {
      return metadata.serializer(value);
    }
    return String(value);
  }
  function getDefaultValue(key) {
    return SETTINGS_METADATA[key].defaultValue;
  }
  function getAllSettingKeys() {
    return Object.keys(SETTINGS_METADATA);
  }
  function isValidSettingKey(key) {
    return key in SETTINGS_METADATA;
  }
  var SETTINGS_METADATA;
  var init_settingsSchema = __esm({
    "src-js/config/settingsSchema.ts"() {
      "use strict";
      init_harmonicModes();
      init_artisticProfiles();
      init_coreTheme();
      SETTINGS_METADATA = {
        // === CORE THEME SETTINGS ===
        "catppuccin-flavor": {
          defaultValue: "mocha",
          validator: CORE_THEME_VALIDATORS.flavor,
          description: "Catppuccin color theme variant",
          category: "core"
        },
        "catppuccin-accentColor": {
          defaultValue: "mauve",
          validator: CORE_THEME_VALIDATORS.accentColor,
          description: "Primary accent color for UI elements",
          category: "core"
        },
        "sn-brightness-mode": {
          defaultValue: "bright",
          validator: CORE_THEME_VALIDATORS.brightnessMode,
          description: "Overall theme brightness level",
          category: "core"
        },
        // === ADVANCED SYSTEMS ===
        "sn-palette-system": {
          defaultValue: "catppuccin",
          validator: CORE_THEME_VALIDATORS.paletteSystem,
          description: "Color palette system (Catppuccin or Year 3000)",
          category: "advanced"
        },
        "sn-artistic-mode": {
          defaultValue: "artist-vision",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && value in ARTISTIC_MODE_PROFILES, "validator"),
          description: "Visual intensity and behavior preset",
          category: "advanced"
        },
        "sn-current-harmonic-mode": {
          defaultValue: "analogous-flow",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && value in HARMONIC_MODES, "validator"),
          description: "Color harmony rule for music synchronization",
          category: "advanced"
        },
        "sn-harmonic-intensity": {
          defaultValue: 0.7,
          validator: /* @__PURE__ */ __name((value) => typeof value === "number" && value >= 0 && value <= 1, "validator"),
          parser: /* @__PURE__ */ __name((value) => {
            const parsed = parseFloat(value);
            return !isNaN(parsed) && parsed >= 0 && parsed <= 1 ? parsed : null;
          }, "parser"),
          serializer: /* @__PURE__ */ __name((value) => value.toString(), "serializer"),
          description: "Intensity of color harmony effects (0-1)",
          category: "advanced"
        },
        "sn-harmonic-evolution": {
          defaultValue: true,
          validator: /* @__PURE__ */ __name((value) => typeof value === "boolean", "validator"),
          parser: /* @__PURE__ */ __name((value) => {
            if (value === "true") return true;
            if (value === "false") return false;
            return null;
          }, "parser"),
          serializer: /* @__PURE__ */ __name((value) => value.toString(), "serializer"),
          description: "Enable dynamic color harmony evolution",
          category: "advanced"
        },
        // === VISUAL CONTROLS ===
        "sn-gradient-intensity": {
          defaultValue: "balanced",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && ["disabled", "minimal", "balanced", "intense"].includes(value), "validator"),
          description: "Master control for all gradient background effects",
          category: "visual"
        },
        "sn-glassmorphism-level": {
          defaultValue: "balanced",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && ["disabled", "minimal", "balanced", "intense"].includes(value), "validator"),
          description: "Glass-like transparency effects intensity",
          category: "visual"
        },
        // === PERFORMANCE SETTINGS ===
        "sn-webgl-enabled": {
          defaultValue: true,
          validator: /* @__PURE__ */ __name((value) => typeof value === "boolean", "validator"),
          parser: /* @__PURE__ */ __name((value) => {
            if (value === "true") return true;
            if (value === "false") return false;
            return null;
          }, "parser"),
          serializer: /* @__PURE__ */ __name((value) => value.toString(), "serializer"),
          description: "Enable WebGL-accelerated visual effects",
          category: "performance"
        },
        "sn-animation-quality": {
          defaultValue: "auto",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && ["auto", "low", "high"].includes(value), "validator"),
          description: "Animation performance vs quality balance",
          category: "performance"
        },
        "sn-webgl-quality": {
          defaultValue: "medium",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && ["low", "medium", "high"].includes(value), "validator"),
          description: "WebGL rendering quality level",
          category: "performance"
        }
      };
      __name(validateSetting, "validateSetting");
      __name(parseSetting, "parseSetting");
      __name(serializeSetting, "serializeSetting");
      __name(getDefaultValue, "getDefaultValue");
      __name(getAllSettingKeys, "getAllSettingKeys");
      __name(isValidSettingKey, "isValidSettingKey");
    }
  });

  // src-js/config/typedSettingsManager.ts
  var _TypedSettingsManager, TypedSettingsManager;
  var init_typedSettingsManager = __esm({
    "src-js/config/typedSettingsManager.ts"() {
      "use strict";
      init_settingsSchema();
      _TypedSettingsManager = class _TypedSettingsManager {
        constructor(storage) {
          this.changeListeners = /* @__PURE__ */ new Set();
          this.cache = /* @__PURE__ */ new Map();
          this.storage = storage;
        }
        /**
         * Get a setting value with full type safety
         * Automatically parses and validates the stored value
         */
        get(key) {
          if (this.cache.has(key)) {
            return this.cache.get(key);
          }
          const metadata = SETTINGS_METADATA[key];
          const rawValue = this.storage.get(key);
          if (rawValue === null || rawValue === void 0) {
            const defaultValue = metadata.defaultValue;
            this.cache.set(key, defaultValue);
            return defaultValue;
          }
          const parsedValue = parseSetting(key, rawValue);
          if (parsedValue === null) {
            console.warn(`[TypedSettingsManager] Invalid stored value for ${key}: "${rawValue}", using default`);
            const defaultValue = metadata.defaultValue;
            this.cache.set(key, defaultValue);
            return defaultValue;
          }
          this.cache.set(key, parsedValue);
          return parsedValue;
        }
        /**
         * Set a setting value with type safety and validation
         * Automatically serializes and validates the value
         */
        set(key, value) {
          if (!validateSetting(key, value)) {
            console.error(`[TypedSettingsManager] Invalid value for ${key}:`, value);
            return false;
          }
          const oldValue = this.cache.get(key) ?? this.get(key);
          const serializedValue = serializeSetting(key, value);
          const success = this.storage.set(key, serializedValue);
          if (success) {
            this.cache.set(key, value);
            const changeEvent = {
              settingKey: key,
              oldValue,
              newValue: value,
              timestamp: Date.now()
            };
            this.notifyChangeListeners(changeEvent);
          }
          return success;
        }
        /**
         * Get multiple settings at once
         */
        getMultiple(keys) {
          const result = {};
          for (const key of keys) {
            result[key] = this.get(key);
          }
          return result;
        }
        /**
         * Set multiple settings at once
         */
        setMultiple(settings2) {
          const results = {};
          for (const [key, value] of Object.entries(settings2)) {
            if (isValidSettingKey(key)) {
              results[key] = this.set(key, value);
            }
          }
          return results;
        }
        /**
         * Get all settings with their current values
         */
        getAllSettings() {
          const result = {};
          for (const key of getAllSettingKeys()) {
            result[key] = this.get(key);
          }
          return result;
        }
        /**
         * Reset a setting to its default value
         */
        reset(key) {
          const defaultValue = getDefaultValue(key);
          return this.set(key, defaultValue);
        }
        /**
         * Reset all settings to their default values
         */
        resetAll() {
          const results = {};
          for (const key of getAllSettingKeys()) {
            results[key] = this.reset(key);
          }
          return results;
        }
        /**
         * Check if a setting exists in storage (has been set by user)
         */
        exists(key) {
          return this.storage.get(key) !== null;
        }
        /**
         * Remove a setting from storage (will fall back to default)
         */
        remove(key) {
          const success = this.storage.remove(key);
          if (success) {
            this.cache.delete(key);
          }
          return success;
        }
        /**
         * Clear the internal cache (forces re-reading from storage)
         */
        clearCache() {
          this.cache.clear();
        }
        /**
         * Add a change listener
         */
        onChange(listener) {
          this.changeListeners.add(listener);
        }
        /**
         * Remove a change listener
         */
        offChange(listener) {
          this.changeListeners.delete(listener);
        }
        /**
         * Notify all change listeners
         */
        notifyChangeListeners(event) {
          for (const listener of this.changeListeners) {
            try {
              listener(event);
            } catch (error) {
              console.error("[TypedSettingsManager] Error in change listener:", error);
            }
          }
        }
        /**
         * Validate all stored settings and report issues
         */
        validateAllSettings() {
          const result = {
            valid: 0,
            invalid: [],
            missing: []
          };
          for (const key of getAllSettingKeys()) {
            const rawValue = this.storage.get(key);
            if (rawValue === null) {
              result.missing.push({
                key,
                usingDefault: getDefaultValue(key)
              });
              continue;
            }
            const parsedValue = parseSetting(key, rawValue);
            if (parsedValue === null) {
              result.invalid.push({
                key,
                value: rawValue,
                error: "Failed to parse or validate value"
              });
            } else {
              result.valid++;
            }
          }
          return result;
        }
        /**
         * Export settings as a JSON object
         */
        export() {
          return this.getAllSettings();
        }
        /**
         * Import settings from a JSON object
         */
        import(settings2) {
          const result = {
            imported: 0,
            failed: []
          };
          for (const [key, value] of Object.entries(settings2)) {
            if (!isValidSettingKey(key)) {
              result.failed.push({ key, error: "Unknown setting key" });
              continue;
            }
            if (!validateSetting(key, value)) {
              result.failed.push({ key, error: "Invalid value for setting" });
              continue;
            }
            if (this.set(key, value)) {
              result.imported++;
            } else {
              result.failed.push({ key, error: "Failed to store setting" });
            }
          }
          return result;
        }
      };
      __name(_TypedSettingsManager, "TypedSettingsManager");
      TypedSettingsManager = _TypedSettingsManager;
    }
  });

  // src-js/config/storage/spicetifyStorage.ts
  function createSpicetifyStorage() {
    return new SpicetifyStorageAdapter();
  }
  var _SpicetifyStorageAdapter, SpicetifyStorageAdapter;
  var init_spicetifyStorage = __esm({
    "src-js/config/storage/spicetifyStorage.ts"() {
      "use strict";
      _SpicetifyStorageAdapter = class _SpicetifyStorageAdapter {
        constructor() {
          this._available = null;
        }
        /**
         * Check if Spicetify.LocalStorage is available
         */
        isAvailable() {
          if (this._available !== null) {
            return this._available;
          }
          try {
            this._available = typeof Spicetify !== "undefined" && typeof Spicetify.LocalStorage?.get === "function" && typeof Spicetify.LocalStorage?.set === "function";
            if (this._available) {
              Spicetify.LocalStorage.get("__test__");
            }
            return this._available;
          } catch (error) {
            console.warn("[SpicetifyStorageAdapter] Spicetify.LocalStorage not available:", error);
            this._available = false;
            return false;
          }
        }
        /**
         * Get value from Spicetify.LocalStorage
         */
        get(key) {
          if (!this.isAvailable()) {
            console.warn(`[SpicetifyStorageAdapter] Cannot get ${key}: Spicetify not available`);
            return null;
          }
          try {
            return Spicetify.LocalStorage.get(key);
          } catch (error) {
            console.error(`[SpicetifyStorageAdapter] Error reading key ${key}:`, error);
            return null;
          }
        }
        /**
         * Set value in Spicetify.LocalStorage
         */
        set(key, value) {
          if (!this.isAvailable()) {
            console.warn(`[SpicetifyStorageAdapter] Cannot set ${key}: Spicetify not available`);
            return false;
          }
          try {
            Spicetify.LocalStorage.set(key, value);
            return true;
          } catch (error) {
            console.error(`[SpicetifyStorageAdapter] Error setting key ${key}:`, error);
            return false;
          }
        }
        /**
         * Remove value from Spicetify.LocalStorage
         */
        remove(key) {
          if (!this.isAvailable()) {
            console.warn(`[SpicetifyStorageAdapter] Cannot remove ${key}: Spicetify not available`);
            return false;
          }
          try {
            if (typeof Spicetify.LocalStorage.remove === "function") {
              Spicetify.LocalStorage.remove(key);
            } else {
              Spicetify.LocalStorage.set(key, null);
            }
            return true;
          } catch (error) {
            console.error(`[SpicetifyStorageAdapter] Error removing key ${key}:`, error);
            return false;
          }
        }
        /**
         * Check storage health and connectivity
         */
        healthCheck() {
          const result = {
            available: false,
            readable: false,
            writable: false,
            issues: []
          };
          result.available = this.isAvailable();
          if (!result.available) {
            result.issues.push("Spicetify.LocalStorage not available");
            return result;
          }
          try {
            this.get("__health_check_read__");
            result.readable = true;
          } catch (error) {
            result.issues.push(`Read test failed: ${error}`);
          }
          try {
            const testKey = "__health_check_write__";
            const testValue = "test_" + Date.now();
            const writeSuccess = this.set(testKey, testValue);
            if (writeSuccess) {
              const readValue = this.get(testKey);
              if (readValue === testValue) {
                result.writable = true;
                this.remove(testKey);
              } else {
                result.issues.push("Write-read consistency test failed");
              }
            } else {
              result.issues.push("Write operation failed");
            }
          } catch (error) {
            result.issues.push(`Write test failed: ${error}`);
          }
          return result;
        }
        /**
         * Get diagnostic information
         */
        getDiagnostics() {
          const apiMethods = [];
          if (typeof Spicetify !== "undefined" && Spicetify.LocalStorage) {
            apiMethods.push(...Object.getOwnPropertyNames(Spicetify.LocalStorage));
          }
          return {
            spicetifyVersion: typeof Spicetify !== "undefined" ? Spicetify.version : void 0,
            apiMethods,
            testResults: this.healthCheck()
          };
        }
      };
      __name(_SpicetifyStorageAdapter, "SpicetifyStorageAdapter");
      SpicetifyStorageAdapter = _SpicetifyStorageAdapter;
      __name(createSpicetifyStorage, "createSpicetifyStorage");
    }
  });

  // src-js/config/storage/browserStorage.ts
  function createBrowserStorage(prefix) {
    return new BrowserStorageAdapter(prefix);
  }
  var _BrowserStorageAdapter, BrowserStorageAdapter;
  var init_browserStorage = __esm({
    "src-js/config/storage/browserStorage.ts"() {
      "use strict";
      _BrowserStorageAdapter = class _BrowserStorageAdapter {
        constructor(prefix = "sn-") {
          this.prefix = prefix;
        }
        /**
         * Get prefixed key for storage
         */
        getPrefixedKey(key) {
          return key.startsWith(this.prefix) ? key : `${this.prefix}${key}`;
        }
        /**
         * Check if localStorage is available
         */
        isAvailable() {
          try {
            return typeof localStorage !== "undefined" && localStorage !== null;
          } catch (error) {
            return false;
          }
        }
        /**
         * Get value from localStorage
         */
        get(key) {
          if (!this.isAvailable()) {
            console.warn(`[BrowserStorageAdapter] localStorage not available for key: ${key}`);
            return null;
          }
          try {
            return localStorage.getItem(this.getPrefixedKey(key));
          } catch (error) {
            console.error(`[BrowserStorageAdapter] Error reading key ${key}:`, error);
            return null;
          }
        }
        /**
         * Set value in localStorage
         */
        set(key, value) {
          if (!this.isAvailable()) {
            console.warn(`[BrowserStorageAdapter] localStorage not available for key: ${key}`);
            return false;
          }
          try {
            localStorage.setItem(this.getPrefixedKey(key), value);
            return true;
          } catch (error) {
            console.error(`[BrowserStorageAdapter] Error setting key ${key}:`, error);
            return false;
          }
        }
        /**
         * Remove value from localStorage
         */
        remove(key) {
          if (!this.isAvailable()) {
            console.warn(`[BrowserStorageAdapter] localStorage not available for key: ${key}`);
            return false;
          }
          try {
            localStorage.removeItem(this.getPrefixedKey(key));
            return true;
          } catch (error) {
            console.error(`[BrowserStorageAdapter] Error removing key ${key}:`, error);
            return false;
          }
        }
        /**
         * Get all keys with the configured prefix
         */
        getAllKeys() {
          if (!this.isAvailable()) {
            return [];
          }
          const keys = [];
          try {
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith(this.prefix)) {
                keys.push(key.substring(this.prefix.length));
              }
            }
          } catch (error) {
            console.error("[BrowserStorageAdapter] Error enumerating keys:", error);
          }
          return keys;
        }
        /**
         * Clear all keys with the configured prefix
         */
        clear() {
          if (!this.isAvailable()) {
            return false;
          }
          try {
            const keys = this.getAllKeys();
            for (const key of keys) {
              localStorage.removeItem(this.getPrefixedKey(key));
            }
            return true;
          } catch (error) {
            console.error("[BrowserStorageAdapter] Error clearing storage:", error);
            return false;
          }
        }
        /**
         * Get storage usage statistics
         */
        getUsageStats() {
          const stats = {
            totalKeys: 0,
            totalSize: 0,
            avgKeySize: 0
          };
          if (!this.isAvailable()) {
            return stats;
          }
          try {
            const keys = this.getAllKeys();
            stats.totalKeys = keys.length;
            for (const key of keys) {
              const value = this.get(key);
              if (value !== null) {
                stats.totalSize += key.length + value.length;
              }
            }
            stats.avgKeySize = stats.totalKeys > 0 ? stats.totalSize / stats.totalKeys : 0;
            if (typeof navigator !== "undefined" && "storage" in navigator && "estimate" in navigator.storage) {
              navigator.storage.estimate().then((estimate) => {
                if (estimate.quota !== void 0) {
                  stats.availableQuota = estimate.quota;
                }
              }).catch(() => {
              });
            }
          } catch (error) {
            console.error("[BrowserStorageAdapter] Error calculating usage stats:", error);
          }
          return stats;
        }
      };
      __name(_BrowserStorageAdapter, "BrowserStorageAdapter");
      BrowserStorageAdapter = _BrowserStorageAdapter;
      __name(createBrowserStorage, "createBrowserStorage");
    }
  });

  // src-js/config/settingsProvider.ts
  function getSettingsProvider() {
    if (!globalProvider) {
      globalProvider = new SettingsProvider();
    }
    return globalProvider;
  }
  function getSettings() {
    return getSettingsProvider().getSettings();
  }
  var _SettingsProvider, SettingsProvider, globalProvider, settings;
  var init_settingsProvider = __esm({
    "src-js/config/settingsProvider.ts"() {
      "use strict";
      init_typedSettingsManager();
      init_spicetifyStorage();
      init_browserStorage();
      _SettingsProvider = class _SettingsProvider {
        constructor(customStorage) {
          this.storageAdapter = customStorage || this.detectBestStorage();
          this.settingsManager = new TypedSettingsManager(this.storageAdapter);
        }
        /**
         * Detect and return the best available storage adapter
         */
        detectBestStorage() {
          const spicetifyAdapter = createSpicetifyStorage();
          const spicetifyHealth = spicetifyAdapter.healthCheck();
          if (spicetifyHealth.available && spicetifyHealth.readable && spicetifyHealth.writable) {
            console.log("[SettingsProvider] Using Spicetify storage adapter");
            return spicetifyAdapter;
          }
          const browserAdapter = createBrowserStorage();
          console.log("[SettingsProvider] Using browser storage adapter (localStorage)");
          return browserAdapter;
        }
        /**
         * Get the typed settings manager
         */
        getSettings() {
          return this.settingsManager;
        }
        /**
         * Get the underlying storage adapter
         */
        getStorage() {
          return this.storageAdapter;
        }
        /**
         * Get provider diagnostic information
         */
        getDiagnostics() {
          const storageType = this.storageAdapter instanceof SpicetifyStorageAdapter ? "spicetify" : this.storageAdapter instanceof BrowserStorageAdapter ? "browser" : "unknown";
          let storageHealth = null;
          if (this.storageAdapter instanceof SpicetifyStorageAdapter) {
            storageHealth = this.storageAdapter.healthCheck();
          }
          return {
            storageType,
            storageHealth,
            settingsValidation: this.settingsManager.validateAllSettings(),
            totalSettings: Object.keys(this.settingsManager.getAllSettings()).length
          };
        }
        /**
         * Migration helper: copy settings from legacy storage
         */
        async migrateFromLegacyStorage(legacySettings) {
          console.log("[SettingsProvider] Starting legacy settings migration...");
          const result = this.settingsManager.import(legacySettings);
          if (result.imported > 0) {
            console.log(`[SettingsProvider] Successfully migrated ${result.imported} settings`);
          }
          if (result.failed.length > 0) {
            console.warn(`[SettingsProvider] Failed to migrate ${result.failed.length} settings:`, result.failed);
          }
          return {
            migrated: result.imported,
            failed: result.failed
          };
        }
        /**
         * Health check for the entire settings system
         */
        healthCheck() {
          const diagnostics = this.getDiagnostics();
          const validation = diagnostics.settingsValidation;
          const result = {
            overall: "healthy",
            storage: {
              type: diagnostics.storageType,
              available: true,
              issues: []
            },
            settings: {
              valid: validation.valid,
              invalid: validation.invalid.length,
              missing: validation.missing.length
            },
            recommendations: []
          };
          if (diagnostics.storageHealth) {
            result.storage.available = diagnostics.storageHealth.available;
            if (diagnostics.storageHealth.issues) {
              result.storage.issues = diagnostics.storageHealth.issues;
            }
          }
          if (!result.storage.available || result.storage.issues.length > 0) {
            result.overall = "unhealthy";
            result.recommendations.push("Storage system needs attention");
          } else if (result.settings.invalid > 0) {
            result.overall = "degraded";
            result.recommendations.push("Some settings have invalid values");
          } else if (result.settings.missing > 5) {
            result.overall = "degraded";
            result.recommendations.push("Many settings are using defaults");
          }
          if (result.settings.invalid > 0) {
            result.recommendations.push("Run settings validation and repair");
          }
          if (diagnostics.storageType === "browser") {
            result.recommendations.push("Consider using in Spicetify environment for better integration");
          }
          return result;
        }
      };
      __name(_SettingsProvider, "SettingsProvider");
      SettingsProvider = _SettingsProvider;
      globalProvider = null;
      __name(getSettingsProvider, "getSettingsProvider");
      __name(getSettings, "getSettings");
      settings = {
        get: /* @__PURE__ */ __name((key) => getSettings().get(key), "get"),
        set: /* @__PURE__ */ __name((key, value) => getSettings().set(key, value), "set"),
        reset: /* @__PURE__ */ __name((key) => getSettings().reset(key), "reset"),
        onChange: /* @__PURE__ */ __name((listener) => getSettings().onChange(listener), "onChange"),
        export: /* @__PURE__ */ __name(() => getSettings().export(), "export"),
        import: /* @__PURE__ */ __name((settings2) => getSettings().import(settings2), "import")
      };
    }
  });

  // src-js/config/index.ts
  var init_config = __esm({
    "src-js/config/index.ts"() {
      "use strict";
      init_coreTheme();
      init_harmonicModes();
      init_artisticProfiles();
      init_performanceProfiles();
      init_settingKeys();
      init_typedSettingsManager();
      init_settingsSchema();
      init_settingsProvider();
      init_spicetifyStorage();
      init_browserStorage();
      init_config();
    }
  });

  // src-js/config/globalConfig.ts
  var HARMONIC_MODES2, ARTISTIC_MODE_PROFILES2, YEAR3000_CONFIG;
  var init_globalConfig = __esm({
    "src-js/config/globalConfig.ts"() {
      "use strict";
      init_config();
      init_harmonicModes();
      init_artisticProfiles();
      init_performanceProfiles();
      HARMONIC_MODES2 = HARMONIC_MODES;
      ARTISTIC_MODE_PROFILES2 = ARTISTIC_MODE_PROFILES;
      YEAR3000_CONFIG = {
        enableDebug: true,
        enableContextualIntelligence: true,
        paletteSystem: "catppuccin",
        // Default to maintain compatibility
        performanceProfiles: PERFORMANCE_PROFILES,
        // Enhanced logging configuration
        logging: DEFAULT_LOGGING_CONFIG,
        healthCheckInterval: 1e4,
        visual: {
          lightweightParticleSystem: { mode: "artist-vision" },
          dimensionalNexusSystem: { mode: "artist-vision" },
          dataGlyphSystem: { mode: "artist-vision" },
          beatSyncVisualSystem: { mode: "artist-vision" },
          behavioralPredictionEngine: { mode: "artist-vision" },
          predictiveMaterializationSystem: { mode: "artist-vision" },
          sidebarConsciousnessSystem: { mode: "artist-vision" }
        },
        enableColorExtraction: true,
        enableMusicAnalysis: true,
        enableCosmicSync: true,
        // NEW: Music-driven visual intensity
        musicModulationIntensity: 0.4,
        // Increased for dynamic gradient responsiveness
        // Active artistic mode for UX / visual presets
        artisticMode: "artist-vision",
        // "corporate-safe" | "artist-vision" | "cosmic-maximum"
        // Context-bound method references for external calling
        boundGetCurrentMultipliers: null,
        boundGetCurrentFeatures: null,
        boundGetCurrentPerformanceSettings: null,
        // Pending artistic mode for deferred application
        _pendingArtisticMode: null,
        // Initialize bound methods to preserve context
        init() {
          this.boundGetCurrentMultipliers = this.getCurrentMultipliers.bind(this);
          this.boundGetCurrentFeatures = this.getCurrentFeatures.bind(this);
          this.boundGetCurrentPerformanceSettings = this.getCurrentPerformanceSettings.bind(this);
          const needsPreferenceLoad = !this.artisticMode || !this.paletteSystem;
          if (needsPreferenceLoad) {
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] Loading preferences (current: artistic=${this.artisticMode}, palette=${this.paletteSystem})`
              );
            }
            this.loadArtisticPreference();
          } else if (this.enableDebug) {
            console.log(
              `\u{1F3A8} [YEAR3000_CONFIG] Skipping preference load (current: artistic=${this.artisticMode}, palette=${this.paletteSystem})`
            );
          }
          if (this._pendingArtisticMode && this.isFullyInitialized()) {
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] Applying pending artistic mode: ${this._pendingArtisticMode}`
              );
            }
            this.setArtisticMode(this._pendingArtisticMode);
            this._pendingArtisticMode = null;
          }
          if (this.enableDebug) {
            console.log(
              "\u{1F527} [YEAR3000_CONFIG] Initialized with context-bound methods"
            );
          }
          return this;
        },
        currentHarmonicMode: "analogous-flow",
        harmonicBaseColor: null,
        harmonicIntensity: 0.85,
        // Enhanced for cinematic gradient harmonies
        harmonicEvolution: true,
        // Music sync configuration imported from modular harmonic modes
        musicVisualSync: {
          ...MUSIC_VISUAL_SYNC,
          enhancedBPM: ENHANCED_BPM_CONFIG
        },
        // Enhanced: Get current mode profile with full Year3000 parameters
        getCurrentModeProfile() {
          const mode = this.artisticMode || "artist-vision";
          return ARTISTIC_MODE_PROFILES2[mode] || ARTISTIC_MODE_PROFILES2["artist-vision"];
        },
        // Enhanced: Get current multipliers from active mode profile
        getCurrentMultipliers() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[YEAR3000_CONFIG] getCurrentModeProfile method not available, using fallback multipliers"
              );
              return this["artisticMultipliers"];
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.multipliers) {
              console.warn(
                "[YEAR3000_CONFIG] Invalid profile or missing multipliers, using fallback"
              );
              return this["artisticMultipliers"];
            }
            return currentProfile.multipliers;
          } catch (error) {
            console.error("[YEAR3000_CONFIG] Error in getCurrentMultipliers:", error);
            return this["artisticMultipliers"];
          }
        },
        // Enhanced: Get current features from active mode profile
        getCurrentFeatures() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[YEAR3000_CONFIG] getCurrentModeProfile method not available, using fallback features"
              );
              return {
                enableAdvancedEffects: true,
                enableHarmony: true,
                beatSync: true,
                colorHarmony: true
              };
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.features) {
              console.warn(
                "[YEAR3000_CONFIG] Invalid profile or missing features, using fallback"
              );
              return {
                enableAdvancedEffects: true,
                enableHarmony: true,
                beatSync: true,
                colorHarmony: true
              };
            }
            return currentProfile.features;
          } catch (error) {
            console.error("[YEAR3000_CONFIG] Error in getCurrentFeatures:", error);
            return {
              enableAdvancedEffects: true,
              enableHarmony: true,
              beatSync: true,
              colorHarmony: true
            };
          }
        },
        // Enhanced: Get current performance settings from active mode profile
        getCurrentPerformanceSettings() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[YEAR3000_CONFIG] getCurrentModeProfile method not available, using fallback performance settings"
              );
              return {
                maxParticles: 20,
                animationThrottle: 16,
                enableGPUAcceleration: true,
                reducedMotion: false
              };
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.performance) {
              console.warn(
                "[YEAR3000_CONFIG] Invalid profile or missing performance settings, using fallback"
              );
              return {
                maxParticles: 20,
                animationThrottle: 16,
                enableGPUAcceleration: true,
                reducedMotion: false
              };
            }
            return currentProfile.performance;
          } catch (error) {
            console.error(
              "[YEAR3000_CONFIG] Error in getCurrentPerformanceSettings:",
              error
            );
            return {
              maxParticles: 20,
              animationThrottle: 16,
              enableGPUAcceleration: true,
              reducedMotion: false
            };
          }
        },
        // Check if YEAR3000_CONFIG is fully initialized with all required methods
        isFullyInitialized() {
          const requiredMethods = [
            "setArtisticMode",
            "getCurrentModeProfile",
            "getCurrentMultipliers",
            "getCurrentFeatures",
            "getCurrentPerformanceSettings"
          ];
          return requiredMethods.every(
            (method) => typeof this[method] === "function"
          );
        },
        // Safe setArtisticMode wrapper that validates state
        safeSetArtisticMode(mode) {
          if (!this.isFullyInitialized()) {
            console.warn(
              "[YEAR3000_CONFIG] Not fully initialized, deferring artistic mode change"
            );
            this._pendingArtisticMode = mode;
            return false;
          }
          return this.setArtisticMode(mode);
        },
        setArtisticMode(mode) {
          const validModes = Object.keys(ARTISTIC_MODE_PROFILES2);
          if (validModes.includes(mode)) {
            const previousMode = this.artisticMode;
            this.artisticMode = mode;
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] Artistic mode changed: ${previousMode} \u2192 ${mode}`
              );
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] New profile:`,
                this.getCurrentModeProfile()
              );
            }
            if (typeof document !== "undefined") {
              document.dispatchEvent(
                new CustomEvent("year3000ArtisticModeChanged", {
                  detail: {
                    previousMode,
                    newMode: mode,
                    profile: this.getCurrentModeProfile()
                  }
                })
              );
            }
            if (typeof globalThis.year3000System !== "undefined" && globalThis.year3000System.setGradientParameters) {
              globalThis.year3000System.setGradientParameters(
                document.documentElement
              );
            }
            return true;
          }
          console.warn(
            `[YEAR3000_CONFIG] Invalid artistic mode: ${mode}. Valid modes:`,
            validModes
          );
          return false;
        },
        // ===========================================
        //  LOGGING & PERFORMANCE CONFIGURATION HELPERS
        // ===========================================
        // Set logging level for all Year 3000 systems
        setLoggingLevel(level) {
          const validLevels = ["off", "error", "warn", "info", "debug", "verbose"];
          if (validLevels.includes(level)) {
            this.logging.level = level;
            if (level !== "off") {
              console.log(`\u{1F527} [YEAR3000_CONFIG] Logging level set to: ${level}`);
            }
            return true;
          }
          console.warn(
            `[YEAR3000_CONFIG] Invalid logging level: ${level}. Valid levels:`,
            validLevels
          );
          return false;
        },
        // Disable performance warnings (useful for production or when performance is acceptable)
        disablePerformanceWarnings() {
          this.logging.performance.enableFrameBudgetWarnings = false;
          console.log("\u{1F527} [YEAR3000_CONFIG] Performance warnings disabled");
        },
        // Enable performance warnings
        enablePerformanceWarnings() {
          this.logging.performance.enableFrameBudgetWarnings = true;
          console.log("\u{1F527} [YEAR3000_CONFIG] Performance warnings enabled");
        },
        // Set performance warning throttle interval (ms)
        setPerformanceWarningThrottle(intervalMs) {
          if (typeof intervalMs === "number" && intervalMs >= 0) {
            this.logging.performance.throttleInterval = intervalMs;
            this.logging.performance.throttleWarnings = intervalMs > 0;
            console.log(
              `\u{1F527} [YEAR3000_CONFIG] Performance warning throttle set to: ${intervalMs}ms`
            );
            return true;
          }
          console.warn(
            "[YEAR3000_CONFIG] Invalid throttle interval. Must be a non-negative number."
          );
          return false;
        },
        // Quick setup for different environments
        setupForProduction() {
          this.setLoggingLevel("warn");
          this.disablePerformanceWarnings();
          this.logging.performance.enableAdaptiveDegradation = true;
          console.log("\u{1F527} [YEAR3000_CONFIG] Configured for production environment");
        },
        setupForDevelopment() {
          this.setLoggingLevel("debug");
          this.enablePerformanceWarnings();
          this.setPerformanceWarningThrottle(2e3);
          this.logging.performance.enableAdaptiveDegradation = true;
          console.log("\u{1F527} [YEAR3000_CONFIG] Configured for development environment");
        },
        setupForDebugging() {
          this.setLoggingLevel("verbose");
          this.enablePerformanceWarnings();
          this.setPerformanceWarningThrottle(500);
          this.logging.performance.enableAdaptiveDegradation = false;
          console.log("\u{1F527} [YEAR3000_CONFIG] Configured for debugging environment");
        },
        // Validate configuration health and functionality
        validateConfigHealth() {
          const healthReport = {
            overallStatus: "healthy",
            issues: [],
            dynamicChecks: {}
          };
          const configKeys = Object.keys(this).filter(
            (k) => typeof k === "string"
          );
          const functionProperties = configKeys.filter(
            (key) => typeof this[key] === "function"
          );
          for (const key of functionProperties) {
            if (!this.hasOwnProperty(key)) {
              healthReport.issues.push({
                key: String(key),
                severity: "warning",
                message: `Method ${key} is not an own property, may indicate prototype chain issues.`
              });
            }
          }
          const checkProfile = /* @__PURE__ */ __name((mode) => {
            if (!ARTISTIC_MODE_PROFILES2[mode]) {
              healthReport.issues.push({
                key: `artisticMode:${mode}`,
                severity: "critical",
                message: `Artistic mode profile for '${mode}' is missing.`
              });
              return;
            }
            healthReport.dynamicChecks[`${mode}Profile`] = "ok";
          }, "checkProfile");
          checkProfile(this.artisticMode);
          checkProfile("artist-vision");
          checkProfile("corporate-safe");
          if (healthReport.issues.length > 0) {
            healthReport.overallStatus = healthReport.issues.some(
              (i) => i.severity === "critical"
            ) ? "critical" : "unhealthy";
          }
          if (this.enableDebug) {
            console.log("[YEAR3000_CONFIG] Health Check Report:", healthReport);
          }
          return healthReport;
        },
        loadArtisticPreference() {
          try {
            const saved = settings.get("sn-artistic-mode");
            const validModes = Object.keys(ARTISTIC_MODE_PROFILES2);
            if (saved && validModes.includes(String(saved)) && this.artisticMode !== saved) {
              this.artisticMode = String(saved);
              if (this.enableDebug) {
                console.log(`\u{1F3A8} [YEAR3000_CONFIG] Updated artistic mode from storage: ${saved}`);
              }
            } else if (!saved && this.artisticMode !== "artist-vision") {
              this.artisticMode = "artist-vision";
              if (this.enableDebug) {
                console.log(`\u{1F3A8} [YEAR3000_CONFIG] Reset artistic mode to default: artist-vision`);
              }
            }
            const savedPalette = settings.get("sn-palette-system");
            const validPaletteSystems = ["catppuccin", "year3000"];
            if (savedPalette && validPaletteSystems.includes(String(savedPalette)) && this.paletteSystem !== savedPalette) {
              this.paletteSystem = String(savedPalette);
              if (this.enableDebug) {
                console.log(`\u{1F3A8} [YEAR3000_CONFIG] Updated palette system from storage: ${savedPalette}`);
              }
            } else if (!savedPalette && this.paletteSystem !== "catppuccin") {
              this.paletteSystem = "catppuccin";
              if (this.enableDebug) {
                console.log(`\u{1F3A8} [YEAR3000_CONFIG] Reset palette system to default: catppuccin`);
              }
            }
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] Current artistic preference: ${this.artisticMode}`
              );
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] Current palette system: ${this.paletteSystem}`
              );
            }
          } catch (error) {
            if (this.enableDebug) {
              console.warn(`\u{1F3A8} [YEAR3000_CONFIG] Failed to load preferences:`, error);
            }
            this.artisticMode = "artist-vision";
            this.paletteSystem = "catppuccin";
          }
        }
      };
      if (typeof YEAR3000_CONFIG.init === "function") {
        YEAR3000_CONFIG.init();
      }
    }
  });

  // src-js/debug/UnifiedDebugManager.ts
  var _UnifiedDebugManager, UnifiedDebugManager, Y3KDebug, UnifiedDebugManager_default;
  var init_UnifiedDebugManager = __esm({
    "src-js/debug/UnifiedDebugManager.ts"() {
      "use strict";
      init_globalConfig();
      _UnifiedDebugManager = class _UnifiedDebugManager {
        constructor(config = {}) {
          this.registeredSystems = /* @__PURE__ */ new Map();
          this.reportHistory = [];
          this.monitoring = false;
          this.monitoringInterval = null;
          this.performanceMetrics = /* @__PURE__ */ new Map();
          this.config = {
            enableConsoleReporting: YEAR3000_CONFIG.enableDebug,
            reportingInterval: 3e4,
            // 30 seconds
            enablePerformanceTracking: true,
            enableSystemHealthMonitoring: true,
            maxHistoryEntries: 50,
            verboseLogging: YEAR3000_CONFIG.enableDebug,
            ...config
          };
          if (this.config.enableConsoleReporting) {
            console.log("\u{1F527} [UnifiedDebugManager] Debug system initialized");
          }
        }
        static getInstance(config) {
          if (!_UnifiedDebugManager.instance) {
            _UnifiedDebugManager.instance = new _UnifiedDebugManager(config);
          }
          return _UnifiedDebugManager.instance;
        }
        // =========================================================================
        // SYSTEM REGISTRATION & MANAGEMENT
        // =========================================================================
        /**
         * Register a system for debug monitoring
         */
        registerSystem(name, system, type = "unified") {
          const debugInfo = {
            name,
            type,
            initialized: system.initialized || false,
            healthy: true,
            lastUpdate: Date.now(),
            issues: [],
            metrics: {}
          };
          this.registeredSystems.set(name, debugInfo);
          if (this.config.verboseLogging) {
            console.log(
              `\u{1F527} [UnifiedDebugManager] Registered system: ${name} (${type})`
            );
          }
          if (this.registeredSystems.size === 1 && !this.monitoring) {
            this.startMonitoring();
          }
        }
        /**
         * Unregister a system from debug monitoring
         */
        unregisterSystem(name) {
          this.registeredSystems.delete(name);
          this.performanceMetrics.delete(name);
          if (this.config.verboseLogging) {
            console.log(`\u{1F527} [UnifiedDebugManager] Unregistered system: ${name}`);
          }
          if (this.registeredSystems.size === 0) {
            this.stopMonitoring();
          }
        }
        /**
         * Update system debug information
         */
        updateSystem(name, updates) {
          const system = this.registeredSystems.get(name);
          if (!system) return;
          Object.assign(system, updates, { lastUpdate: Date.now() });
          this.registeredSystems.set(name, system);
        }
        /**
         * Record performance metric for a system
         */
        recordMetric(systemName, metricName, value) {
          if (!this.config.enablePerformanceTracking) return;
          const system = this.registeredSystems.get(systemName);
          if (system) {
            system.metrics[metricName] = value;
            system.lastUpdate = Date.now();
          }
          const key = `${systemName}_${metricName}`;
          const history = this.performanceMetrics.get(key) || [];
          history.push(value);
          if (history.length > 100) {
            history.splice(0, history.length - 100);
          }
          this.performanceMetrics.set(key, history);
        }
        /**
         * Record system issue
         */
        recordIssue(systemName, issue) {
          const system = this.registeredSystems.get(systemName);
          if (system) {
            system.issues.push(issue);
            system.healthy = false;
            system.lastUpdate = Date.now();
            if (this.config.verboseLogging) {
              console.warn(`\u26A0\uFE0F [${systemName}] ${issue}`);
            }
          }
        }
        // =========================================================================
        // SYSTEM HEALTH CHECKING
        // =========================================================================
        /**
         * Perform health check on all registered systems
         */
        async performHealthCheck() {
          const timestamp = Date.now();
          const systemDetails = [];
          let healthySystems = 0;
          let totalIssues = 0;
          let totalFrameTime = 0;
          let totalMemory = 0;
          let frameTimeCount = 0;
          for (const [name, system] of this.registeredSystems) {
            try {
              let actualSystem = null;
              let dynamicInitializedStatus = system.initialized;
              const year3000System2 = globalThis.year3000System;
              if (year3000System2) {
                if (year3000System2.facadeCoordinator) {
                  try {
                    actualSystem = year3000System2.facadeCoordinator.getCachedNonVisualSystem?.(
                      name
                    ) || await year3000System2.facadeCoordinator.getNonVisualSystem?.(
                      name
                    );
                  } catch (e) {
                  }
                  if (!actualSystem) {
                    try {
                      actualSystem = year3000System2.facadeCoordinator.getVisualSystem?.(name);
                    } catch (e) {
                    }
                  }
                }
                if (!actualSystem) {
                  const camelCaseName = name.charAt(0).toLowerCase() + name.slice(1);
                  actualSystem = year3000System2[camelCaseName] || year3000System2[name];
                }
              }
              if (!actualSystem) {
                actualSystem = globalThis[name];
              }
              if (actualSystem) {
                if (typeof actualSystem.initialized === "boolean") {
                  dynamicInitializedStatus = actualSystem.initialized;
                } else if (typeof actualSystem.isInitialized === "function") {
                  try {
                    dynamicInitializedStatus = await actualSystem.isInitialized();
                  } catch (e) {
                  }
                } else if (typeof actualSystem.getInitializationStatus === "function") {
                  try {
                    const status = await actualSystem.getInitializationStatus();
                    dynamicInitializedStatus = status?.initialized ?? status?.ready ?? false;
                  } catch (e) {
                  }
                }
              }
              const oldStatus = system.initialized;
              system.initialized = dynamicInitializedStatus;
              system.lastUpdate = timestamp;
              if (this.config.verboseLogging && oldStatus !== dynamicInitializedStatus) {
                console.log(
                  `\u{1F527} [UnifiedDebugManager] ${name} initialization status updated: ${oldStatus} \u2192 ${dynamicInitializedStatus}`
                );
              }
              if (actualSystem && typeof actualSystem.healthCheck === "function") {
                const healthResult = await actualSystem.healthCheck();
                system.healthy = healthResult.healthy ?? healthResult.ok;
                if (!healthResult.ok) {
                  system.issues = [healthResult.details || "Health check failed"];
                } else {
                  system.issues = [];
                }
              } else {
                system.healthy = dynamicInitializedStatus;
                if (!dynamicInitializedStatus) {
                  system.issues = ["System not initialized"];
                } else {
                  system.issues = [];
                }
              }
              if (system.frameTime) {
                totalFrameTime += system.frameTime;
                frameTimeCount++;
              }
              if (system.memoryUsage) {
                totalMemory += system.memoryUsage;
              }
              if (system.healthy) {
                healthySystems++;
              } else {
                totalIssues += system.issues.length;
              }
              systemDetails.push({ ...system });
            } catch (error) {
              system.healthy = false;
              system.issues = [`Health check error: ${error}`];
              totalIssues++;
              if (this.config.verboseLogging) {
                console.error(`\u274C [${name}] Health check failed:`, error);
              }
            }
          }
          const healthPercentage = this.registeredSystems.size > 0 ? healthySystems / this.registeredSystems.size : 1;
          let overallHealth;
          if (healthPercentage >= 0.9) overallHealth = "excellent";
          else if (healthPercentage >= 0.7) overallHealth = "good";
          else if (healthPercentage >= 0.5) overallHealth = "degraded";
          else overallHealth = "critical";
          if (this.config.verboseLogging) {
            console.log(
              "\u{1F527} [UnifiedDebugManager] System initialization status for recommendations:"
            );
            for (const system of systemDetails) {
              console.log(
                `   ${system.name}: ${system.initialized ? "\u2705" : "\u274C"} initialized`
              );
            }
          }
          const recommendations = this.generateRecommendations(
            systemDetails,
            overallHealth
          );
          const report = {
            timestamp,
            overallHealth,
            systemCount: this.registeredSystems.size,
            healthySystems,
            totalIssues,
            systemDetails,
            performance: {
              avgFrameTime: frameTimeCount > 0 ? totalFrameTime / frameTimeCount : 0,
              totalMemoryMB: totalMemory,
              cpuUsageEstimate: this.estimateCPUUsage()
            },
            recommendations
          };
          this.reportHistory.push(report);
          if (this.reportHistory.length > this.config.maxHistoryEntries) {
            this.reportHistory.splice(
              0,
              this.reportHistory.length - this.config.maxHistoryEntries
            );
          }
          return report;
        }
        /**
         * Generate actionable recommendations based on system state
         */
        generateRecommendations(systems, overallHealth) {
          const recommendations = [];
          if (overallHealth === "critical") {
            recommendations.push(
              "\u{1F6A8} Critical: Multiple systems failing - check console for errors"
            );
          }
          const uninitializedSystems = systems.filter((s) => !s.initialized);
          if (uninitializedSystems.length > 0) {
            recommendations.push(
              `\u26A0\uFE0F ${uninitializedSystems.length} systems not initialized: ${uninitializedSystems.map((s) => s.name).join(", ")}`
            );
          }
          const highFrameTimes = systems.filter(
            (s) => s.frameTime && s.frameTime > 16.67
          );
          if (highFrameTimes.length > 0) {
            recommendations.push(
              `\u{1F40C} Performance: ${highFrameTimes.length} systems exceeding 16.67ms frame time`
            );
          }
          const memoryIssues = systems.filter(
            (s) => s.memoryUsage && s.memoryUsage > 50
          );
          if (memoryIssues.length > 0) {
            recommendations.push(
              `\u{1F4BE} Memory: ${memoryIssues.length} systems using >50MB`
            );
          }
          if (recommendations.length === 0) {
            recommendations.push("\u2705 All systems operating within normal parameters");
          }
          return recommendations;
        }
        /**
         * Estimate CPU usage based on frame times and system activity
         */
        estimateCPUUsage() {
          let totalFrameTime = 0;
          let count = 0;
          for (const system of this.registeredSystems.values()) {
            if (system.frameTime) {
              totalFrameTime += system.frameTime;
              count++;
            }
          }
          if (count === 0) return 0;
          const avgFrameTime = totalFrameTime / count;
          return Math.min(100, avgFrameTime / 16.67 * 5);
        }
        // =========================================================================
        // MONITORING & REPORTING
        // =========================================================================
        /**
         * Start automatic monitoring
         */
        startMonitoring() {
          if (this.monitoring) return;
          this.monitoring = true;
          this.monitoringInterval = window.setInterval(() => {
            this.performHealthCheck().then((report) => {
              if (this.config.enableConsoleReporting) {
                this.logHealthReport(report);
              }
            });
          }, this.config.reportingInterval);
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Monitoring started");
          }
        }
        /**
         * Stop automatic monitoring
         */
        stopMonitoring() {
          if (!this.monitoring) return;
          this.monitoring = false;
          if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
          }
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Monitoring stopped");
          }
        }
        /**
         * Log health report to console in a readable format
         */
        logHealthReport(report) {
          if (!report) {
            this.performHealthCheck().then((r) => this.logHealthReport(r));
            return;
          }
          const statusEmoji = {
            excellent: "\u{1F31F}",
            good: "\u2705",
            degraded: "\u26A0\uFE0F",
            critical: "\u{1F6A8}"
          }[report.overallHealth];
          console.group(
            `${statusEmoji} Year 3000 System Health Report - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}`
          );
          console.log(
            `\u{1F4CA} Overall: ${report.overallHealth.toUpperCase()} (${report.healthySystems}/${report.systemCount} healthy)`
          );
          if (report.totalIssues > 0) {
            console.log(`\u{1F6A8} Issues: ${report.totalIssues} total`);
          }
          console.log(
            `\u26A1 Performance: ${report.performance.avgFrameTime.toFixed(
              2
            )}ms avg frame, ${report.performance.totalMemoryMB.toFixed(
              1
            )}MB memory, ~${report.performance.cpuUsageEstimate.toFixed(1)}% CPU`
          );
          if (report.systemDetails.length > 0) {
            console.group("\u{1F527} System Details");
            report.systemDetails.forEach((system) => {
              const emoji = system.healthy ? "\u2705" : "\u274C";
              const frameInfo = system.frameTime ? ` (${system.frameTime.toFixed(2)}ms)` : "";
              console.log(`${emoji} ${system.name} [${system.type}]${frameInfo}`);
              if (system.issues.length > 0) {
                system.issues.forEach((issue) => {
                  console.log(`    \u26A0\uFE0F ${issue}`);
                });
              }
            });
            console.groupEnd();
          }
          if (report.recommendations.length > 0) {
            console.group("\u{1F4A1} Recommendations");
            report.recommendations.forEach((rec) => console.log(`  ${rec}`));
            console.groupEnd();
          }
          console.groupEnd();
        }
        // =========================================================================
        // PUBLIC API & UTILITIES
        // =========================================================================
        /**
         * Get the latest debug report
         */
        getLatestReport() {
          return this.reportHistory[this.reportHistory.length - 1] || null;
        }
        /**
         * Get all report history
         */
        getReportHistory() {
          return [...this.reportHistory];
        }
        /**
         * Get system information
         */
        getSystemInfo(name) {
          return this.registeredSystems.get(name) || null;
        }
        /**
         * Get all registered systems
         */
        getAllSystems() {
          return Array.from(this.registeredSystems.values());
        }
        /**
         * Manual health check trigger
         */
        async checkHealth() {
          const report = await this.performHealthCheck();
          this.logHealthReport(report);
        }
        /**
         * Update debug configuration
         */
        updateConfig(config) {
          this.config = { ...this.config, ...config };
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Configuration updated:", config);
          }
        }
        /**
         * Clear all data and reset
         */
        reset() {
          this.stopMonitoring();
          this.registeredSystems.clear();
          this.reportHistory = [];
          this.performanceMetrics.clear();
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] System reset");
          }
        }
        /**
         * Destroy the debug manager
         */
        destroy() {
          this.reset();
          _UnifiedDebugManager.instance = null;
        }
      };
      __name(_UnifiedDebugManager, "UnifiedDebugManager");
      UnifiedDebugManager = _UnifiedDebugManager;
      Y3KDebug = {
        debug: {
          log: /* @__PURE__ */ __name((component, message, ...args) => {
            if (YEAR3000_CONFIG?.enableDebug) {
              console.log(`[${component}] ${message}`, ...args);
            }
          }, "log"),
          error: /* @__PURE__ */ __name((component, message, error) => {
            console.error(`[${component}] ${message}`, error);
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordIssue(
              component,
              `${message}${error ? `: ${error}` : ""}`
            );
          }, "error"),
          warn: /* @__PURE__ */ __name((component, message, ...args) => {
            console.warn(`[${component}] ${message}`, ...args);
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordIssue(component, message);
          }, "warn"),
          metric: /* @__PURE__ */ __name((system, metric, value) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordMetric(system, metric, value);
          }, "metric"),
          register: /* @__PURE__ */ __name((name, system, type) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.registerSystem(name, system, type);
          }, "register"),
          unregister: /* @__PURE__ */ __name((name) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.unregisterSystem(name);
          }, "unregister"),
          checkHealth: /* @__PURE__ */ __name(() => {
            const debugManager = UnifiedDebugManager.getInstance();
            return debugManager.checkHealth();
          }, "checkHealth"),
          getReport: /* @__PURE__ */ __name(() => {
            const debugManager = UnifiedDebugManager.getInstance();
            return debugManager.getLatestReport();
          }, "getReport")
        }
      };
      if (typeof window !== "undefined") {
        window.UnifiedDebugManager = UnifiedDebugManager;
        window.Y3K = Y3KDebug;
        console.log("\u{1F527} [UnifiedDebugManager] Global debug interface available:");
        console.log("  Y3K.debug.checkHealth() - Check system health");
        console.log("  Y3K.debug.getReport() - Get latest debug report");
        console.log("  UnifiedDebugManager.getInstance() - Get debug manager");
      }
      UnifiedDebugManager_default = UnifiedDebugManager;
    }
  });

  // src-js/audio/GenreGradientEvolution.ts
  var _GenreGradientEvolution, GenreGradientEvolution;
  var init_GenreGradientEvolution = __esm({
    "src-js/audio/GenreGradientEvolution.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _GenreGradientEvolution = class _GenreGradientEvolution {
        constructor(cssConsciousnessController, musicSyncService = null, emotionalGradientMapper = null, settingsManager2 = null) {
          this.musicSyncService = null;
          this.emotionalGradientMapper = null;
          this.settingsManager = null;
          this.currentGenre = "unknown";
          this.genreConfidence = 0;
          this.genreHistory = [];
          this.maxHistorySize = 30;
          this.genreAnalysisBuffer = [];
          this.bufferSize = 10;
          // Analyze 10 music data samples for genre detection
          this.isActive = false;
          this.boundSpectralHandler = null;
          this.boundEmotionalHandler = null;
          // Genre characteristic profiles
          this.genreProfiles = {
            electronic: {
              bassEmphasis: 0.8,
              midFrequencyPattern: 0.6,
              trebleSharpness: 0.9,
              dynamicRange: 0.7,
              rhythmComplexity: 0.6,
              syncopation: 0.4,
              grooveWeight: 0.7,
              tempoVariability: 0.3,
              harmonicComplexity: 0.5,
              dissonanceTolerance: 0.6,
              modalInfluence: 0.4,
              microtonal: 0.2,
              compression: 0.8,
              saturation: 0.6,
              stereoWidth: 0.8,
              artificialProcessing: 0.9,
              organicness: 0.2,
              accessibility: 0.6,
              experimentalFactor: 0.7,
              emotionalRange: 0.6
            },
            rock: {
              bassEmphasis: 0.7,
              midFrequencyPattern: 0.8,
              trebleSharpness: 0.7,
              dynamicRange: 0.8,
              rhythmComplexity: 0.6,
              syncopation: 0.3,
              grooveWeight: 0.8,
              tempoVariability: 0.4,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.3,
              microtonal: 0.1,
              compression: 0.6,
              saturation: 0.7,
              stereoWidth: 0.7,
              artificialProcessing: 0.4,
              organicness: 0.6,
              accessibility: 0.8,
              experimentalFactor: 0.4,
              emotionalRange: 0.8
            },
            classical: {
              bassEmphasis: 0.5,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.6,
              dynamicRange: 0.9,
              rhythmComplexity: 0.8,
              syncopation: 0.2,
              grooveWeight: 0.4,
              tempoVariability: 0.7,
              harmonicComplexity: 0.9,
              dissonanceTolerance: 0.4,
              modalInfluence: 0.6,
              microtonal: 0.3,
              compression: 0.3,
              saturation: 0.2,
              stereoWidth: 0.8,
              artificialProcessing: 0.1,
              organicness: 0.9,
              accessibility: 0.4,
              experimentalFactor: 0.6,
              emotionalRange: 0.9
            },
            jazz: {
              bassEmphasis: 0.6,
              midFrequencyPattern: 0.8,
              trebleSharpness: 0.5,
              dynamicRange: 0.8,
              rhythmComplexity: 0.9,
              syncopation: 0.8,
              grooveWeight: 0.9,
              tempoVariability: 0.6,
              harmonicComplexity: 0.9,
              dissonanceTolerance: 0.7,
              modalInfluence: 0.8,
              microtonal: 0.4,
              compression: 0.4,
              saturation: 0.3,
              stereoWidth: 0.7,
              artificialProcessing: 0.2,
              organicness: 0.8,
              accessibility: 0.5,
              experimentalFactor: 0.8,
              emotionalRange: 0.8
            },
            "hip-hop": {
              bassEmphasis: 0.9,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.8,
              dynamicRange: 0.6,
              rhythmComplexity: 0.7,
              syncopation: 0.6,
              grooveWeight: 0.9,
              tempoVariability: 0.3,
              harmonicComplexity: 0.4,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.3,
              microtonal: 0.1,
              compression: 0.8,
              saturation: 0.6,
              stereoWidth: 0.6,
              artificialProcessing: 0.7,
              organicness: 0.4,
              accessibility: 0.8,
              experimentalFactor: 0.5,
              emotionalRange: 0.7
            },
            ambient: {
              bassEmphasis: 0.4,
              midFrequencyPattern: 0.5,
              trebleSharpness: 0.3,
              dynamicRange: 0.9,
              rhythmComplexity: 0.2,
              syncopation: 0.1,
              grooveWeight: 0.2,
              tempoVariability: 0.8,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.6,
              modalInfluence: 0.7,
              microtonal: 0.5,
              compression: 0.5,
              saturation: 0.4,
              stereoWidth: 0.9,
              artificialProcessing: 0.6,
              organicness: 0.7,
              accessibility: 0.3,
              experimentalFactor: 0.8,
              emotionalRange: 0.6
            },
            pop: {
              bassEmphasis: 0.6,
              midFrequencyPattern: 0.8,
              trebleSharpness: 0.7,
              dynamicRange: 0.6,
              rhythmComplexity: 0.4,
              syncopation: 0.3,
              grooveWeight: 0.7,
              tempoVariability: 0.2,
              harmonicComplexity: 0.5,
              dissonanceTolerance: 0.3,
              modalInfluence: 0.2,
              microtonal: 0.1,
              compression: 0.8,
              saturation: 0.5,
              stereoWidth: 0.6,
              artificialProcessing: 0.5,
              organicness: 0.5,
              accessibility: 0.9,
              experimentalFactor: 0.2,
              emotionalRange: 0.7
            },
            metal: {
              bassEmphasis: 0.8,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.9,
              dynamicRange: 0.7,
              rhythmComplexity: 0.7,
              syncopation: 0.4,
              grooveWeight: 0.8,
              tempoVariability: 0.3,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.8,
              modalInfluence: 0.5,
              microtonal: 0.2,
              compression: 0.7,
              saturation: 0.9,
              stereoWidth: 0.7,
              artificialProcessing: 0.6,
              organicness: 0.4,
              accessibility: 0.6,
              experimentalFactor: 0.5,
              emotionalRange: 0.8
            },
            folk: {
              bassEmphasis: 0.4,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.5,
              dynamicRange: 0.7,
              rhythmComplexity: 0.4,
              syncopation: 0.2,
              grooveWeight: 0.6,
              tempoVariability: 0.5,
              harmonicComplexity: 0.5,
              dissonanceTolerance: 0.3,
              modalInfluence: 0.6,
              microtonal: 0.2,
              compression: 0.3,
              saturation: 0.2,
              stereoWidth: 0.5,
              artificialProcessing: 0.1,
              organicness: 0.9,
              accessibility: 0.7,
              experimentalFactor: 0.3,
              emotionalRange: 0.7
            },
            funk: {
              bassEmphasis: 0.9,
              midFrequencyPattern: 0.8,
              trebleSharpness: 0.6,
              dynamicRange: 0.7,
              rhythmComplexity: 0.8,
              syncopation: 0.9,
              grooveWeight: 1,
              tempoVariability: 0.4,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.4,
              microtonal: 0.2,
              compression: 0.6,
              saturation: 0.5,
              stereoWidth: 0.6,
              artificialProcessing: 0.3,
              organicness: 0.7,
              accessibility: 0.7,
              experimentalFactor: 0.4,
              emotionalRange: 0.6
            },
            indie: {
              bassEmphasis: 0.5,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.6,
              dynamicRange: 0.7,
              rhythmComplexity: 0.6,
              syncopation: 0.4,
              grooveWeight: 0.6,
              tempoVariability: 0.5,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.5,
              microtonal: 0.3,
              compression: 0.5,
              saturation: 0.4,
              stereoWidth: 0.7,
              artificialProcessing: 0.3,
              organicness: 0.7,
              accessibility: 0.6,
              experimentalFactor: 0.6,
              emotionalRange: 0.7
            },
            reggae: {
              bassEmphasis: 0.8,
              midFrequencyPattern: 0.6,
              trebleSharpness: 0.5,
              dynamicRange: 0.6,
              rhythmComplexity: 0.5,
              syncopation: 0.7,
              grooveWeight: 0.8,
              tempoVariability: 0.3,
              harmonicComplexity: 0.4,
              dissonanceTolerance: 0.3,
              modalInfluence: 0.4,
              microtonal: 0.2,
              compression: 0.6,
              saturation: 0.4,
              stereoWidth: 0.6,
              artificialProcessing: 0.3,
              organicness: 0.6,
              accessibility: 0.7,
              experimentalFactor: 0.3,
              emotionalRange: 0.6
            },
            blues: {
              bassEmphasis: 0.6,
              midFrequencyPattern: 0.8,
              trebleSharpness: 0.6,
              dynamicRange: 0.8,
              rhythmComplexity: 0.5,
              syncopation: 0.4,
              grooveWeight: 0.8,
              tempoVariability: 0.6,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.4,
              modalInfluence: 0.7,
              microtonal: 0.3,
              compression: 0.4,
              saturation: 0.5,
              stereoWidth: 0.5,
              artificialProcessing: 0.2,
              organicness: 0.8,
              accessibility: 0.7,
              experimentalFactor: 0.4,
              emotionalRange: 0.8
            },
            country: {
              bassEmphasis: 0.5,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.6,
              dynamicRange: 0.7,
              rhythmComplexity: 0.4,
              syncopation: 0.3,
              grooveWeight: 0.6,
              tempoVariability: 0.4,
              harmonicComplexity: 0.4,
              dissonanceTolerance: 0.2,
              modalInfluence: 0.3,
              microtonal: 0.1,
              compression: 0.5,
              saturation: 0.3,
              stereoWidth: 0.6,
              artificialProcessing: 0.2,
              organicness: 0.8,
              accessibility: 0.8,
              experimentalFactor: 0.2,
              emotionalRange: 0.7
            },
            techno: {
              bassEmphasis: 0.9,
              midFrequencyPattern: 0.5,
              trebleSharpness: 0.8,
              dynamicRange: 0.5,
              rhythmComplexity: 0.6,
              syncopation: 0.3,
              grooveWeight: 0.8,
              tempoVariability: 0.2,
              harmonicComplexity: 0.4,
              dissonanceTolerance: 0.6,
              modalInfluence: 0.3,
              microtonal: 0.3,
              compression: 0.9,
              saturation: 0.7,
              stereoWidth: 0.8,
              artificialProcessing: 1,
              organicness: 0.1,
              accessibility: 0.5,
              experimentalFactor: 0.6,
              emotionalRange: 0.5
            },
            house: {
              bassEmphasis: 0.8,
              midFrequencyPattern: 0.6,
              trebleSharpness: 0.7,
              dynamicRange: 0.6,
              rhythmComplexity: 0.5,
              syncopation: 0.4,
              grooveWeight: 0.9,
              tempoVariability: 0.2,
              harmonicComplexity: 0.5,
              dissonanceTolerance: 0.4,
              modalInfluence: 0.3,
              microtonal: 0.2,
              compression: 0.8,
              saturation: 0.6,
              stereoWidth: 0.7,
              artificialProcessing: 0.8,
              organicness: 0.3,
              accessibility: 0.8,
              experimentalFactor: 0.4,
              emotionalRange: 0.6
            },
            trance: {
              bassEmphasis: 0.7,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.8,
              dynamicRange: 0.8,
              rhythmComplexity: 0.5,
              syncopation: 0.2,
              grooveWeight: 0.7,
              tempoVariability: 0.3,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.4,
              microtonal: 0.3,
              compression: 0.7,
              saturation: 0.5,
              stereoWidth: 0.9,
              artificialProcessing: 0.8,
              organicness: 0.2,
              accessibility: 0.6,
              experimentalFactor: 0.5,
              emotionalRange: 0.8
            },
            dubstep: {
              bassEmphasis: 1,
              midFrequencyPattern: 0.5,
              trebleSharpness: 0.9,
              dynamicRange: 0.9,
              rhythmComplexity: 0.7,
              syncopation: 0.6,
              grooveWeight: 0.8,
              tempoVariability: 0.4,
              harmonicComplexity: 0.4,
              dissonanceTolerance: 0.8,
              modalInfluence: 0.3,
              microtonal: 0.4,
              compression: 0.8,
              saturation: 0.8,
              stereoWidth: 0.8,
              artificialProcessing: 0.9,
              organicness: 0.1,
              accessibility: 0.4,
              experimentalFactor: 0.7,
              emotionalRange: 0.6
            },
            unknown: {
              bassEmphasis: 0.5,
              midFrequencyPattern: 0.5,
              trebleSharpness: 0.5,
              dynamicRange: 0.5,
              rhythmComplexity: 0.5,
              syncopation: 0.5,
              grooveWeight: 0.5,
              tempoVariability: 0.5,
              harmonicComplexity: 0.5,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.5,
              microtonal: 0.5,
              compression: 0.5,
              saturation: 0.5,
              stereoWidth: 0.5,
              artificialProcessing: 0.5,
              organicness: 0.5,
              accessibility: 0.5,
              experimentalFactor: 0.5,
              emotionalRange: 0.5
            }
          };
          // Genre visual style profiles
          this.genreVisualStyles = {
            electronic: {
              primaryHueRange: [180, 270],
              saturationProfile: [0.8, 0.3],
              brightnessProfile: [1.1, 0.4],
              contrastLevel: 0.8,
              gradientComplexity: 0.8,
              shapeGeometry: "geometric",
              edgeSharpness: 0.9,
              symmetryLevel: 0.7,
              animationStyle: "rhythmic",
              pulseBehavior: "steady",
              flowDirection: "linear",
              transitionCharacter: "mechanical",
              layerBlending: "contrasting",
              depthIllusion: 0.6,
              particleInfluence: 0.8,
              nebulaCharacter: "structured",
              memoryInfluence: 0.3,
              adaptationSpeed: 0.8,
              stabilityPreference: 0.6,
              emergencePattern: "sudden"
            },
            rock: {
              primaryHueRange: [330, 30],
              saturationProfile: [1.2, 0.5],
              brightnessProfile: [1.2, 0.3],
              contrastLevel: 0.9,
              gradientComplexity: 0.7,
              shapeGeometry: "hybrid",
              edgeSharpness: 0.7,
              symmetryLevel: 0.5,
              animationStyle: "rhythmic",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "sharp",
              layerBlending: "harmonious",
              depthIllusion: 0.7,
              particleInfluence: 0.6,
              nebulaCharacter: "dense",
              memoryInfluence: 0.4,
              adaptationSpeed: 0.7,
              stabilityPreference: 0.7,
              emergencePattern: "gradual"
            },
            classical: {
              primaryHueRange: [45, 135],
              saturationProfile: [0.6, 0.4],
              brightnessProfile: [1, 0.5],
              contrastLevel: 0.6,
              gradientComplexity: 0.9,
              shapeGeometry: "organic",
              edgeSharpness: 0.3,
              symmetryLevel: 0.8,
              animationStyle: "smooth",
              pulseBehavior: "subtle",
              flowDirection: "spiral",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.9,
              particleInfluence: 0.4,
              nebulaCharacter: "ethereal",
              memoryInfluence: 0.8,
              adaptationSpeed: 0.3,
              stabilityPreference: 0.9,
              emergencePattern: "progressive"
            },
            jazz: {
              primaryHueRange: [30, 90],
              saturationProfile: [0.7, 0.6],
              brightnessProfile: [0.9, 0.6],
              contrastLevel: 0.7,
              gradientComplexity: 0.8,
              shapeGeometry: "abstract",
              edgeSharpness: 0.5,
              symmetryLevel: 0.3,
              animationStyle: "chaotic",
              pulseBehavior: "syncopated",
              flowDirection: "random",
              transitionCharacter: "organic",
              layerBlending: "complementary",
              depthIllusion: 0.8,
              particleInfluence: 0.7,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.6,
              adaptationSpeed: 0.6,
              stabilityPreference: 0.4,
              emergencePattern: "cyclical"
            },
            "hip-hop": {
              primaryHueRange: [270, 330],
              saturationProfile: [1, 0.4],
              brightnessProfile: [1.1, 0.3],
              contrastLevel: 0.8,
              gradientComplexity: 0.6,
              shapeGeometry: "geometric",
              edgeSharpness: 0.8,
              symmetryLevel: 0.6,
              animationStyle: "rhythmic",
              pulseBehavior: "syncopated",
              flowDirection: "linear",
              transitionCharacter: "sharp",
              layerBlending: "contrasting",
              depthIllusion: 0.5,
              particleInfluence: 0.9,
              nebulaCharacter: "structured",
              memoryInfluence: 0.2,
              adaptationSpeed: 0.9,
              stabilityPreference: 0.5,
              emergencePattern: "sudden"
            },
            ambient: {
              primaryHueRange: [180, 240],
              saturationProfile: [0.4, 0.3],
              brightnessProfile: [0.8, 0.4],
              contrastLevel: 0.3,
              gradientComplexity: 0.9,
              shapeGeometry: "organic",
              edgeSharpness: 0.2,
              symmetryLevel: 0.4,
              animationStyle: "minimal",
              pulseBehavior: "subtle",
              flowDirection: "spiral",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.9,
              particleInfluence: 0.3,
              nebulaCharacter: "ethereal",
              memoryInfluence: 0.9,
              adaptationSpeed: 0.1,
              stabilityPreference: 0.9,
              emergencePattern: "gradual"
            },
            pop: {
              primaryHueRange: [300, 60],
              saturationProfile: [1.1, 0.3],
              brightnessProfile: [1.2, 0.2],
              contrastLevel: 0.7,
              gradientComplexity: 0.6,
              shapeGeometry: "hybrid",
              edgeSharpness: 0.6,
              symmetryLevel: 0.7,
              animationStyle: "rhythmic",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.6,
              particleInfluence: 0.5,
              nebulaCharacter: "dense",
              memoryInfluence: 0.5,
              adaptationSpeed: 0.7,
              stabilityPreference: 0.8,
              emergencePattern: "gradual"
            },
            metal: {
              primaryHueRange: [0, 30],
              saturationProfile: [0.9, 0.4],
              brightnessProfile: [0.7, 0.4],
              contrastLevel: 1,
              gradientComplexity: 0.7,
              shapeGeometry: "geometric",
              edgeSharpness: 0.9,
              symmetryLevel: 0.6,
              animationStyle: "chaotic",
              pulseBehavior: "irregular",
              flowDirection: "radial",
              transitionCharacter: "sharp",
              layerBlending: "clashing",
              depthIllusion: 0.8,
              particleInfluence: 0.7,
              nebulaCharacter: "dense",
              memoryInfluence: 0.3,
              adaptationSpeed: 0.8,
              stabilityPreference: 0.3,
              emergencePattern: "sudden"
            },
            folk: {
              primaryHueRange: [60, 120],
              saturationProfile: [0.6, 0.3],
              brightnessProfile: [0.9, 0.3],
              contrastLevel: 0.5,
              gradientComplexity: 0.5,
              shapeGeometry: "organic",
              edgeSharpness: 0.3,
              symmetryLevel: 0.5,
              animationStyle: "smooth",
              pulseBehavior: "subtle",
              flowDirection: "spiral",
              transitionCharacter: "organic",
              layerBlending: "harmonious",
              depthIllusion: 0.6,
              particleInfluence: 0.3,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.7,
              adaptationSpeed: 0.4,
              stabilityPreference: 0.8,
              emergencePattern: "progressive"
            },
            funk: {
              primaryHueRange: [30, 90],
              saturationProfile: [1, 0.5],
              brightnessProfile: [1, 0.4],
              contrastLevel: 0.8,
              gradientComplexity: 0.7,
              shapeGeometry: "abstract",
              edgeSharpness: 0.6,
              symmetryLevel: 0.4,
              animationStyle: "rhythmic",
              pulseBehavior: "syncopated",
              flowDirection: "random",
              transitionCharacter: "organic",
              layerBlending: "complementary",
              depthIllusion: 0.7,
              particleInfluence: 0.8,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.4,
              adaptationSpeed: 0.8,
              stabilityPreference: 0.5,
              emergencePattern: "cyclical"
            },
            indie: {
              primaryHueRange: [120, 240],
              saturationProfile: [0.7, 0.4],
              brightnessProfile: [0.9, 0.4],
              contrastLevel: 0.6,
              gradientComplexity: 0.7,
              shapeGeometry: "hybrid",
              edgeSharpness: 0.4,
              symmetryLevel: 0.5,
              animationStyle: "smooth",
              pulseBehavior: "steady",
              flowDirection: "spiral",
              transitionCharacter: "fluid",
              layerBlending: "complementary",
              depthIllusion: 0.7,
              particleInfluence: 0.5,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.6,
              adaptationSpeed: 0.5,
              stabilityPreference: 0.7,
              emergencePattern: "progressive"
            },
            reggae: {
              primaryHueRange: [90, 150],
              saturationProfile: [0.8, 0.3],
              brightnessProfile: [1, 0.3],
              contrastLevel: 0.6,
              gradientComplexity: 0.5,
              shapeGeometry: "organic",
              edgeSharpness: 0.4,
              symmetryLevel: 0.6,
              animationStyle: "rhythmic",
              pulseBehavior: "syncopated",
              flowDirection: "linear",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.5,
              particleInfluence: 0.4,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.6,
              adaptationSpeed: 0.5,
              stabilityPreference: 0.7,
              emergencePattern: "cyclical"
            },
            blues: {
              primaryHueRange: [200, 260],
              saturationProfile: [0.6, 0.4],
              brightnessProfile: [0.8, 0.4],
              contrastLevel: 0.6,
              gradientComplexity: 0.6,
              shapeGeometry: "organic",
              edgeSharpness: 0.4,
              symmetryLevel: 0.4,
              animationStyle: "smooth",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.7,
              particleInfluence: 0.4,
              nebulaCharacter: "ethereal",
              memoryInfluence: 0.7,
              adaptationSpeed: 0.4,
              stabilityPreference: 0.8,
              emergencePattern: "progressive"
            },
            country: {
              primaryHueRange: [30, 90],
              saturationProfile: [0.7, 0.3],
              brightnessProfile: [1, 0.3],
              contrastLevel: 0.5,
              gradientComplexity: 0.5,
              shapeGeometry: "organic",
              edgeSharpness: 0.3,
              symmetryLevel: 0.6,
              animationStyle: "smooth",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "organic",
              layerBlending: "harmonious",
              depthIllusion: 0.5,
              particleInfluence: 0.3,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.7,
              adaptationSpeed: 0.4,
              stabilityPreference: 0.8,
              emergencePattern: "gradual"
            },
            techno: {
              primaryHueRange: [240, 300],
              saturationProfile: [1, 0.4],
              brightnessProfile: [1.1, 0.3],
              contrastLevel: 0.9,
              gradientComplexity: 0.6,
              shapeGeometry: "geometric",
              edgeSharpness: 1,
              symmetryLevel: 0.8,
              animationStyle: "rhythmic",
              pulseBehavior: "steady",
              flowDirection: "linear",
              transitionCharacter: "mechanical",
              layerBlending: "contrasting",
              depthIllusion: 0.5,
              particleInfluence: 0.9,
              nebulaCharacter: "structured",
              memoryInfluence: 0.2,
              adaptationSpeed: 0.9,
              stabilityPreference: 0.4,
              emergencePattern: "sudden"
            },
            house: {
              primaryHueRange: [300, 360],
              saturationProfile: [0.9, 0.3],
              brightnessProfile: [1.1, 0.3],
              contrastLevel: 0.7,
              gradientComplexity: 0.6,
              shapeGeometry: "hybrid",
              edgeSharpness: 0.7,
              symmetryLevel: 0.7,
              animationStyle: "rhythmic",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.6,
              particleInfluence: 0.7,
              nebulaCharacter: "dense",
              memoryInfluence: 0.4,
              adaptationSpeed: 0.7,
              stabilityPreference: 0.6,
              emergencePattern: "gradual"
            },
            trance: {
              primaryHueRange: [180, 270],
              saturationProfile: [0.8, 0.5],
              brightnessProfile: [1, 0.5],
              contrastLevel: 0.7,
              gradientComplexity: 0.8,
              shapeGeometry: "abstract",
              edgeSharpness: 0.5,
              symmetryLevel: 0.6,
              animationStyle: "smooth",
              pulseBehavior: "steady",
              flowDirection: "spiral",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.8,
              particleInfluence: 0.6,
              nebulaCharacter: "ethereal",
              memoryInfluence: 0.6,
              adaptationSpeed: 0.5,
              stabilityPreference: 0.7,
              emergencePattern: "progressive"
            },
            dubstep: {
              primaryHueRange: [120, 180],
              saturationProfile: [1.2, 0.6],
              brightnessProfile: [1.1, 0.6],
              contrastLevel: 1,
              gradientComplexity: 0.8,
              shapeGeometry: "geometric",
              edgeSharpness: 0.9,
              symmetryLevel: 0.5,
              animationStyle: "chaotic",
              pulseBehavior: "irregular",
              flowDirection: "random",
              transitionCharacter: "sharp",
              layerBlending: "clashing",
              depthIllusion: 0.7,
              particleInfluence: 1,
              nebulaCharacter: "structured",
              memoryInfluence: 0.2,
              adaptationSpeed: 1,
              stabilityPreference: 0.2,
              emergencePattern: "sudden"
            },
            unknown: {
              primaryHueRange: [0, 360],
              saturationProfile: [0.7, 0.3],
              brightnessProfile: [1, 0.3],
              contrastLevel: 0.6,
              gradientComplexity: 0.6,
              shapeGeometry: "hybrid",
              edgeSharpness: 0.5,
              symmetryLevel: 0.5,
              animationStyle: "smooth",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.6,
              particleInfluence: 0.5,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.5,
              adaptationSpeed: 0.5,
              stabilityPreference: 0.6,
              emergencePattern: "gradual"
            }
          };
          this.cssConsciousnessController = cssConsciousnessController;
          this.musicSyncService = musicSyncService;
          this.emotionalGradientMapper = emotionalGradientMapper;
          this.settingsManager = settingsManager2;
          this.boundSpectralHandler = this.handleSpectralData.bind(this);
          this.boundEmotionalHandler = this.handleEmotionalData.bind(this);
        }
        async initialize() {
          if (this.boundSpectralHandler) {
            document.addEventListener(
              "music-sync:spectral-data",
              this.boundSpectralHandler
            );
          }
          if (this.boundEmotionalHandler) {
            document.addEventListener(
              "emotional-gradient:profile-updated",
              this.boundEmotionalHandler
            );
          }
          this.isActive = true;
          Y3KDebug?.debug?.log(
            "GenreGradientEvolution",
            "Genre-responsive gradient evolution system initialized"
          );
        }
        handleSpectralData(event) {
          if (!this.isActive) return;
          const customEvent = event;
          const musicData = customEvent.detail;
          if (!musicData) return;
          this.genreAnalysisBuffer.push(musicData);
          if (this.genreAnalysisBuffer.length > this.bufferSize) {
            this.genreAnalysisBuffer.shift();
          }
          if (this.genreAnalysisBuffer.length >= this.bufferSize) {
            this.analyzeGenre();
          }
        }
        handleEmotionalData(event) {
          if (!this.isActive) return;
          this.updateVisualEvolution();
        }
        analyzeGenre() {
          if (this.genreAnalysisBuffer.length === 0) return;
          const avgMusicData = this.calculateAverageMusicData();
          const genreScores = {};
          for (const genre of Object.keys(this.genreProfiles)) {
            genreScores[genre] = this.calculateGenreSimilarity(
              avgMusicData,
              this.genreProfiles[genre]
            );
          }
          const sortedGenres = Object.entries(genreScores).sort(
            ([, a], [, b]) => b - a
          );
          const bestMatch = sortedGenres[0];
          if (bestMatch) {
            const [bestGenre, bestScore] = bestMatch;
            this.updateGenreDetection(bestGenre, bestScore);
          }
        }
        calculateAverageMusicData() {
          const sum = this.genreAnalysisBuffer.reduce(
            (acc, data) => ({
              energy: (acc.energy || 0) + (data.energy || 0),
              valence: (acc.valence || 0) + (data.valence || 0),
              danceability: (acc.danceability || 0) + (data.danceability || 0),
              tempo: (acc.tempo || 0) + (data.tempo || 0),
              loudness: (acc.loudness || 0) + (data.loudness || 0),
              acousticness: (acc.acousticness || 0) + (data.acousticness || 0),
              instrumentalness: (acc.instrumentalness || 0) + (data.instrumentalness || 0),
              speechiness: (acc.speechiness || 0) + (data.speechiness || 0),
              mode: data.mode !== void 0 ? data.mode : acc.mode || 0,
              key: (acc.key || 0) + (data.key || 0),
              genre: data.genre || acc.genre || "unknown"
            }),
            {
              energy: 0,
              valence: 0,
              danceability: 0,
              tempo: 0,
              loudness: 0,
              acousticness: 0,
              instrumentalness: 0,
              speechiness: 0,
              mode: 0,
              key: 0,
              genre: "unknown"
            }
          );
          const count = this.genreAnalysisBuffer.length;
          return {
            energy: (sum.energy || 0) / count,
            valence: (sum.valence || 0) / count,
            danceability: (sum.danceability || 0) / count,
            tempo: (sum.tempo || 0) / count,
            loudness: (sum.loudness || 0) / count,
            acousticness: (sum.acousticness || 0) / count,
            instrumentalness: (sum.instrumentalness || 0) / count,
            speechiness: (sum.speechiness || 0) / count,
            mode: sum.mode || 0,
            key: (sum.key || 0) / count,
            genre: sum.genre || "unknown"
          };
        }
        calculateGenreSimilarity(musicData, genreProfile) {
          const weights = {
            energy: 0.25,
            // Energy level matches genre energy patterns
            valence: 0.2,
            // Emotional positivity/negativity 
            danceability: 0.2,
            // Rhythmic groove matching
            acousticness: 0.15,
            // Organic vs synthetic nature
            tempo: 0.1,
            // Tempo characteristics
            speechiness: 0.05,
            // Vocal content
            instrumentalness: 0.05
            // Instrumental vs vocal content
          };
          const energySimilarity = 1 - Math.abs(
            (musicData.energy || 0.5) - (genreProfile.dynamicRange * 0.5 + genreProfile.rhythmComplexity * 0.5)
          );
          const valenceSimilarity = 1 - Math.abs(
            (musicData.valence || 0.5) - (genreProfile.accessibility * 0.6 + genreProfile.emotionalRange * 0.4)
          );
          const danceabilitySimilarity = 1 - Math.abs(
            (musicData.danceability || 0.5) - (genreProfile.grooveWeight * 0.7 + (1 - genreProfile.syncopation) * 0.3)
          );
          const acousticnessSimilarity = 1 - Math.abs(
            (musicData.acousticness || 0.5) - (genreProfile.organicness * 0.8 + (1 - genreProfile.artificialProcessing) * 0.2)
          );
          const expectedTempo = 60 + genreProfile.rhythmComplexity * 80 + genreProfile.grooveWeight * 60;
          const tempoSimilarity = 1 - Math.min(1, Math.abs((musicData.tempo || 120) - expectedTempo) / 100);
          const speechinessSimilarity = 1 - Math.abs(
            (musicData.speechiness || 0.1) - (genreProfile.artificialProcessing * 0.3 + genreProfile.accessibility * 0.1)
          );
          const instrumentalnessSimilarity = 1 - Math.abs(
            (musicData.instrumentalness || 0.5) - (genreProfile.experimentalFactor * 0.6 + genreProfile.harmonicComplexity * 0.4)
          );
          return energySimilarity * weights.energy + valenceSimilarity * weights.valence + danceabilitySimilarity * weights.danceability + acousticnessSimilarity * weights.acousticness + tempoSimilarity * weights.tempo + speechinessSimilarity * weights.speechiness + instrumentalnessSimilarity * weights.instrumentalness;
        }
        updateGenreDetection(detectedGenre, score) {
          const timestamp = performance.now();
          this.genreHistory.push({
            genre: detectedGenre,
            confidence: score,
            timestamp
          });
          if (this.genreHistory.length > this.maxHistorySize) {
            this.genreHistory.shift();
          }
          const recentHistory = this.genreHistory.slice(-10);
          const genreConsensus = this.calculateGenreConsensus(recentHistory);
          if (genreConsensus.confidence > 0.6 && (genreConsensus.genre !== this.currentGenre || genreConsensus.confidence > this.genreConfidence)) {
            this.currentGenre = genreConsensus.genre;
            this.genreConfidence = genreConsensus.confidence;
            Y3KDebug?.debug?.log(
              "GenreGradientEvolution",
              `Genre detected: ${this.currentGenre} (confidence: ${this.genreConfidence.toFixed(2)})`
            );
            this.updateVisualEvolution();
            document.dispatchEvent(
              new CustomEvent("genre-gradient:genre-detected", {
                detail: {
                  genre: this.currentGenre,
                  confidence: this.genreConfidence
                }
              })
            );
          }
        }
        calculateGenreConsensus(history) {
          const genreWeights = {};
          history.forEach((entry, index) => {
            const timeWeight = (index + 1) / history.length;
            const totalWeight = entry.confidence * timeWeight;
            genreWeights[entry.genre] = (genreWeights[entry.genre] || 0) + totalWeight;
          });
          let bestGenre = "unknown";
          let bestScore = 0;
          for (const [genre, weight] of Object.entries(genreWeights)) {
            if (weight !== void 0 && weight > bestScore) {
              bestScore = weight;
              bestGenre = genre;
            }
          }
          return { genre: bestGenre, confidence: bestScore / history.length };
        }
        updateVisualEvolution() {
          if (this.currentGenre === "unknown") return;
          const genreStyle = this.genreVisualStyles[this.currentGenre];
          const emotionalProfile = this.emotionalGradientMapper?.getCurrentEmotionalProfile() || null;
          this.applyGenreVisualStyle(genreStyle, emotionalProfile);
        }
        applyGenreVisualStyle(style, emotionalProfile) {
          const hueRange = style.primaryHueRange[1] - style.primaryHueRange[0];
          const baseHue = style.primaryHueRange[0] + hueRange * 0.5;
          const emotionalHueShift = emotionalProfile ? (emotionalProfile.valence - 0.5) * hueRange * 0.3 : 0;
          this.cssConsciousnessController.setProperty(
            "--sn-genre-base-hue",
            `${baseHue + emotionalHueShift}deg`
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-hue-range",
            `${hueRange}deg`
          );
          const emotionalSatBoost = emotionalProfile ? emotionalProfile.arousal * 0.3 : 0;
          const emotionalBrightBoost = emotionalProfile ? emotionalProfile.energy * 0.2 : 0;
          this.cssConsciousnessController.setProperty(
            "--sn-genre-saturation-base",
            (style.saturationProfile[0] + emotionalSatBoost).toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-saturation-variation",
            style.saturationProfile[1].toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-brightness-base",
            (style.brightnessProfile[0] + emotionalBrightBoost).toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-brightness-variation",
            style.brightnessProfile[1].toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-contrast-level",
            style.contrastLevel.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-edge-sharpness",
            style.edgeSharpness.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-gradient-complexity",
            style.gradientComplexity.toString()
          );
          const emotionalSpeedMod = emotionalProfile ? 0.5 + emotionalProfile.energy : 1;
          this.cssConsciousnessController.setProperty(
            "--sn-genre-animation-speed",
            emotionalSpeedMod.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-pulse-intensity",
            style.depthIllusion.toString()
          );
          const layerHarmony = this.mapLayerBlending(style.layerBlending);
          this.cssConsciousnessController.setProperty(
            "--sn-genre-layer-harmony",
            layerHarmony.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-depth-illusion",
            style.depthIllusion.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-particle-influence",
            style.particleInfluence.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-memory-influence",
            style.memoryInfluence.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-adaptation-speed",
            style.adaptationSpeed.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-stability-preference",
            style.stabilityPreference.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn-current-genre",
            this.currentGenre
          );
          this.cssConsciousnessController.setProperty(
            "--sn-genre-confidence",
            this.genreConfidence.toString()
          );
          this.updateGenreGradientCoordination(style, emotionalProfile);
        }
        /**
         * Coordinate genre-specific modifications with the consolidated --sn-bg-gradient-* system
         */
        updateGenreGradientCoordination(style, emotionalProfile) {
          const rootStyle = getComputedStyle(document.documentElement);
          const currentPrimary = rootStyle.getPropertyValue("--sn-bg-gradient-primary").trim();
          const currentSecondary = rootStyle.getPropertyValue("--sn-bg-gradient-secondary").trim();
          const currentAccent = rootStyle.getPropertyValue("--sn-bg-gradient-accent").trim();
          if (currentPrimary || currentSecondary || currentAccent) {
            const emotionalSpeedMod = emotionalProfile ? 0.5 + emotionalProfile.energy : 1;
            const genreAngle = this.calculateGenreAngle(style);
            this.cssConsciousnessController.setProperty(
              "--sn-bg-gradient-angle",
              `${genreAngle}deg`
            );
            const genreOpacity = this.calculateGenreOpacity(style, emotionalProfile);
            this.cssConsciousnessController.setProperty(
              "--sn-bg-gradient-opacity",
              genreOpacity.toString()
            );
            const genreBlur = Math.max(60, 120 * (1 - style.edgeSharpness));
            this.cssConsciousnessController.setProperty(
              "--sn-bg-gradient-blur",
              `${genreBlur}px`
            );
            const emotionalSatBoost = emotionalProfile ? emotionalProfile.arousal * 0.3 : 0;
            const emotionalBrightBoost = emotionalProfile ? emotionalProfile.energy * 0.2 : 0;
            this.cssConsciousnessController.setProperty(
              "--sn-bg-gradient-saturation",
              (style.saturationProfile[0] + emotionalSatBoost).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-bg-gradient-brightness",
              (style.brightnessProfile[0] + emotionalBrightBoost).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-bg-gradient-contrast",
              style.contrastLevel.toString()
            );
            Y3KDebug?.debug?.log(
              "GenreGradientEvolution",
              `Coordinated genre "${this.currentGenre}" modifications with gradient system: angle=${genreAngle}\xB0, opacity=${genreOpacity}`
            );
          }
        }
        /**
         * Calculate gradient angle based on genre characteristics
         */
        calculateGenreAngle(style) {
          const genreAngles = {
            electronic: 135,
            // Digital diagonal flow
            rock: 45,
            // Bold upward energy
            classical: 90,
            // Elegant vertical flow
            jazz: 120,
            // Complex angular flow
            "hip-hop": 0,
            // Horizontal urban flow
            ambient: 180,
            // Ethereal downward flow
            pop: 315,
            // Catchy diagonal up-right
            metal: 225,
            // Aggressive diagonal down
            folk: 60,
            // Natural organic angle
            funk: 30,
            // Groovy slight angle
            indie: 150,
            // Alternative angle
            reggae: 210,
            // Laid-back flow
            blues: 270,
            // Deep downward emotion
            country: 45,
            // Simple upward angle
            techno: 135,
            // Digital diagonal
            house: 315,
            // Dance energy up-right
            trance: 90,
            // Uplifting vertical
            dubstep: 180,
            // Heavy downward
            unknown: 45
            // Default diagonal
          };
          return genreAngles[this.currentGenre] || 45;
        }
        /**
         * Calculate gradient opacity based on genre and emotional characteristics
         */
        calculateGenreOpacity(style, emotionalProfile) {
          let baseOpacity = 0.8;
          switch (this.currentGenre) {
            case "ambient":
            case "classical":
              baseOpacity = 0.6;
              break;
            case "metal":
            case "rock":
            case "dubstep":
              baseOpacity = 0.9;
              break;
            case "jazz":
            case "blues":
              baseOpacity = 0.75;
              break;
            default:
              baseOpacity = 0.8;
          }
          if (emotionalProfile) {
            baseOpacity *= 0.7 + emotionalProfile.energy * 0.3;
          }
          return Math.max(0.3, Math.min(1, baseOpacity));
        }
        mapLayerBlending(blending) {
          switch (blending) {
            case "harmonious":
              return 0.9;
            case "complementary":
              return 0.7;
            case "contrasting":
              return 0.5;
            case "clashing":
              return 0.3;
            default:
              return 0.7;
          }
        }
        getCurrentGenre() {
          return this.currentGenre;
        }
        getGenreConfidence() {
          return this.genreConfidence;
        }
        getGenreHistory() {
          return [...this.genreHistory];
        }
        setGenreOverride(genre, duration = 1e4) {
          this.currentGenre = genre;
          this.genreConfidence = 1;
          this.updateVisualEvolution();
          Y3KDebug?.debug?.log(
            "GenreGradientEvolution",
            `Genre override: ${genre} for ${duration}ms`
          );
          setTimeout(() => {
            this.genreConfidence = 0;
            Y3KDebug?.debug?.log(
              "GenreGradientEvolution",
              "Genre override expired, returning to automatic detection"
            );
          }, duration);
        }
        getGenreCharacteristics(genre) {
          return this.genreProfiles[genre || this.currentGenre];
        }
        getGenreVisualStyle(genre) {
          return this.genreVisualStyles[genre || this.currentGenre];
        }
        destroy() {
          this.isActive = false;
          if (this.boundSpectralHandler) {
            document.removeEventListener(
              "music-sync:data-updated",
              this.boundSpectralHandler
            );
          }
          if (this.boundEmotionalHandler) {
            document.removeEventListener(
              "emotional-gradient:profile-updated",
              this.boundEmotionalHandler
            );
          }
          this.genreAnalysisBuffer = [];
          this.genreHistory = [];
          Y3KDebug?.debug?.log(
            "GenreGradientEvolution",
            "Genre evolution system destroyed"
          );
        }
      };
      __name(_GenreGradientEvolution, "GenreGradientEvolution");
      GenreGradientEvolution = _GenreGradientEvolution;
    }
  });

  // src-js/core/events/UnifiedEventBus.ts
  var _UnifiedEventBus, UnifiedEventBus, unifiedEventBus;
  var init_UnifiedEventBus = __esm({
    "src-js/core/events/UnifiedEventBus.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _UnifiedEventBus = class _UnifiedEventBus {
        constructor() {
          // Event subscriptions registry
          this.subscriptions = /* @__PURE__ */ new Map();
          // Event metrics and monitoring
          this.eventMetrics = {
            totalEvents: 0,
            totalSubscriptions: 0,
            activeSubscriptions: 0,
            eventsPerSecond: 0,
            topEvents: [],
            memoryUsage: 0
          };
          // Performance monitoring
          this.eventQueue = [];
          this.processingQueue = false;
          this.maxQueueSize = 1e3;
          // Cleanup management
          this.subscriptionCleanupInterval = null;
          this.metricsUpdateInterval = null;
          this.startMetricsMonitoring();
          this.startSubscriptionCleanup();
          Y3KDebug?.debug?.log("UnifiedEventBus", "Unified event bus initialized");
        }
        /**
         * Get singleton instance
         */
        static getInstance() {
          if (!_UnifiedEventBus.instance) {
            _UnifiedEventBus.instance = new _UnifiedEventBus();
          }
          return _UnifiedEventBus.instance;
        }
        /**
         * Subscribe to an event with type safety
         */
        subscribe(eventName, handler, subscriberName = "anonymous", options = {}) {
          const subscriptionId = this.generateSubscriptionId();
          if (!this.subscriptions.has(eventName)) {
            this.subscriptions.set(eventName, /* @__PURE__ */ new Map());
          }
          const subscription = {
            id: subscriptionId,
            eventName,
            handler,
            subscriberName,
            once: options.once || false,
            createdAt: Date.now(),
            triggerCount: 0
          };
          this.subscriptions.get(eventName).set(subscriptionId, subscription);
          this.eventMetrics.totalSubscriptions++;
          this.eventMetrics.activeSubscriptions++;
          Y3KDebug?.debug?.log(
            "UnifiedEventBus",
            `Subscription added: ${subscriberName} -> ${eventName}`,
            {
              subscriptionId,
              totalSubscriptions: this.eventMetrics.activeSubscriptions
            }
          );
          return subscriptionId;
        }
        /**
         * Subscribe to an event only once
         */
        once(eventName, handler, subscriberName = "anonymous") {
          return this.subscribe(eventName, handler, subscriberName, { once: true });
        }
        /**
         * Unsubscribe from an event
         */
        unsubscribe(subscriptionId) {
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            if (subscriptionMap.has(subscriptionId)) {
              const subscription = subscriptionMap.get(subscriptionId);
              subscriptionMap.delete(subscriptionId);
              if (subscriptionMap.size === 0) {
                this.subscriptions.delete(eventName);
              }
              this.eventMetrics.activeSubscriptions--;
              Y3KDebug?.debug?.log(
                "UnifiedEventBus",
                `Subscription removed: ${subscription.subscriberName} -> ${eventName}`,
                {
                  subscriptionId,
                  remainingSubscriptions: this.eventMetrics.activeSubscriptions
                }
              );
              return true;
            }
          }
          return false;
        }
        /**
         * Unsubscribe all events for a specific subscriber
         */
        unsubscribeAll(subscriberName) {
          let removedCount = 0;
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            const toRemove = Array.from(subscriptionMap.values()).filter(
              (sub) => sub.subscriberName === subscriberName
            );
            for (const subscription of toRemove) {
              subscriptionMap.delete(subscription.id);
              removedCount++;
              this.eventMetrics.activeSubscriptions--;
            }
            if (subscriptionMap.size === 0) {
              this.subscriptions.delete(eventName);
            }
          }
          if (removedCount > 0) {
            Y3KDebug?.debug?.log(
              "UnifiedEventBus",
              `Removed ${removedCount} subscriptions for: ${subscriberName}`
            );
          }
          return removedCount;
        }
        /**
         * Emit an event with type safety
         */
        async emit(eventName, data) {
          const timestamp = Date.now();
          if (this.processingQueue || this.eventQueue.length > 0) {
            if (this.eventQueue.length >= this.maxQueueSize) {
              Y3KDebug?.debug?.warn(
                "UnifiedEventBus",
                `Event queue full, dropping event: ${eventName}`
              );
              return;
            }
            this.eventQueue.push({ eventName, data, timestamp });
            this.processEventQueue();
            return;
          }
          await this.processEvent(eventName, data, timestamp);
        }
        /**
         * Emit an event synchronously (use sparingly)
         */
        emitSync(eventName, data) {
          const timestamp = Date.now();
          this.processEventSync(eventName, data, timestamp);
        }
        /**
         * Process a single event
         */
        async processEvent(eventName, data, timestamp) {
          const subscriptionMap = this.subscriptions.get(eventName);
          if (!subscriptionMap || subscriptionMap.size === 0) {
            return;
          }
          this.eventMetrics.totalEvents++;
          const handlers = [];
          const toRemove = [];
          for (const [subscriptionId, subscription] of subscriptionMap.entries()) {
            handlers.push({ subscription, handler: subscription.handler });
            if (subscription.once) {
              toRemove.push(subscriptionId);
            }
            subscription.lastTriggered = timestamp;
            subscription.triggerCount++;
          }
          const promises = handlers.map(async ({ subscription, handler }) => {
            try {
              await handler(data);
            } catch (error) {
              Y3KDebug?.debug?.error(
                "UnifiedEventBus",
                `Handler error in ${subscription.subscriberName} for ${eventName}:`,
                error
              );
              this.emitSync("system:error", {
                systemName: subscription.subscriberName,
                error: error instanceof Error ? error.message : "Unknown error",
                severity: "error",
                timestamp: Date.now()
              });
            }
          });
          await Promise.all(promises);
          for (const subscriptionId of toRemove) {
            subscriptionMap.delete(subscriptionId);
            this.eventMetrics.activeSubscriptions--;
          }
          if (subscriptionMap.size === 0) {
            this.subscriptions.delete(eventName);
          }
          Y3KDebug?.debug?.log("UnifiedEventBus", `Event processed: ${eventName}`, {
            handlerCount: handlers.length,
            processingTime: Date.now() - timestamp
          });
        }
        /**
         * Process event synchronously
         */
        processEventSync(eventName, data, timestamp) {
          const subscriptionMap = this.subscriptions.get(eventName);
          if (!subscriptionMap || subscriptionMap.size === 0) {
            return;
          }
          this.eventMetrics.totalEvents++;
          const toRemove = [];
          for (const [subscriptionId, subscription] of subscriptionMap.entries()) {
            try {
              subscription.handler(data);
              subscription.lastTriggered = timestamp;
              subscription.triggerCount++;
              if (subscription.once) {
                toRemove.push(subscriptionId);
              }
            } catch (error) {
              Y3KDebug?.debug?.error(
                "UnifiedEventBus",
                `Sync handler error in ${subscription.subscriberName} for ${eventName}:`,
                error
              );
            }
          }
          for (const subscriptionId of toRemove) {
            subscriptionMap.delete(subscriptionId);
            this.eventMetrics.activeSubscriptions--;
          }
          if (subscriptionMap.size === 0) {
            this.subscriptions.delete(eventName);
          }
        }
        /**
         * Process queued events
         */
        async processEventQueue() {
          if (this.processingQueue) return;
          this.processingQueue = true;
          while (this.eventQueue.length > 0) {
            const queueItem = this.eventQueue.shift();
            await this.processEvent(
              queueItem.eventName,
              queueItem.data,
              queueItem.timestamp
            );
          }
          this.processingQueue = false;
        }
        /**
         * Get current event metrics
         */
        getMetrics() {
          return { ...this.eventMetrics };
        }
        /**
         * Get all active subscriptions for debugging
         */
        getActiveSubscriptions() {
          const subscriptions = [];
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            for (const [subscriptionId, subscription] of subscriptionMap.entries()) {
              subscriptions.push({
                eventName,
                subscriberName: subscription.subscriberName,
                subscriptionId,
                createdAt: subscription.createdAt,
                triggerCount: subscription.triggerCount
              });
            }
          }
          return subscriptions.sort((a, b) => b.createdAt - a.createdAt);
        }
        /**
         * Start metrics monitoring
         */
        startMetricsMonitoring() {
          this.metricsUpdateInterval = window.setInterval(() => {
            this.updateMetrics();
          }, 5e3);
        }
        /**
         * Start subscription cleanup for abandoned subscriptions
         */
        startSubscriptionCleanup() {
          this.subscriptionCleanupInterval = window.setInterval(() => {
            this.cleanupAbandonedSubscriptions();
          }, 6e4);
        }
        /**
         * Update performance metrics
         */
        updateMetrics() {
          const now = Date.now();
          const recentEvents = this.eventMetrics.totalEvents;
          const eventCounts = /* @__PURE__ */ new Map();
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            let totalTriggers = 0;
            for (const subscription of subscriptionMap.values()) {
              totalTriggers += subscription.triggerCount;
            }
            eventCounts.set(eventName, totalTriggers);
          }
          this.eventMetrics.topEvents = Array.from(eventCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 10).map(([eventName, count]) => ({ eventName, count }));
          this.eventMetrics.memoryUsage = this.eventMetrics.activeSubscriptions * 256;
        }
        /**
         * Clean up abandoned subscriptions
         */
        cleanupAbandonedSubscriptions() {
          const cutoffTime = Date.now() - 3e5;
          let cleanedCount = 0;
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            const toCleanup = Array.from(subscriptionMap.values()).filter(
              (sub) => !sub.lastTriggered && sub.createdAt < cutoffTime
            );
            for (const subscription of toCleanup) {
              subscriptionMap.delete(subscription.id);
              cleanedCount++;
              this.eventMetrics.activeSubscriptions--;
            }
            if (subscriptionMap.size === 0) {
              this.subscriptions.delete(eventName);
            }
          }
          if (cleanedCount > 0) {
            Y3KDebug?.debug?.log(
              "UnifiedEventBus",
              `Cleaned up ${cleanedCount} abandoned subscriptions`
            );
          }
        }
        /**
         * Generate unique subscription ID
         */
        generateSubscriptionId() {
          return `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }
        /**
         * Destroy the event bus and clean up all resources
         */
        destroy() {
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          if (this.subscriptionCleanupInterval) {
            clearInterval(this.subscriptionCleanupInterval);
            this.subscriptionCleanupInterval = null;
          }
          this.subscriptions.clear();
          this.eventQueue = [];
          this.eventMetrics = {
            totalEvents: 0,
            totalSubscriptions: 0,
            activeSubscriptions: 0,
            eventsPerSecond: 0,
            topEvents: [],
            memoryUsage: 0
          };
          Y3KDebug?.debug?.log("UnifiedEventBus", "Unified event bus destroyed");
          _UnifiedEventBus.instance = null;
        }
      };
      __name(_UnifiedEventBus, "UnifiedEventBus");
      _UnifiedEventBus.instance = null;
      UnifiedEventBus = _UnifiedEventBus;
      unifiedEventBus = UnifiedEventBus.getInstance();
    }
  });

  // src-js/utils/core/MusicalLerpOrchestrator.ts
  var MusicalLerpOrchestrator_exports = {};
  __export(MusicalLerpOrchestrator_exports, {
    MusicalLerpOrchestrator: () => MusicalLerpOrchestrator,
    musicalLerpOrchestrator: () => musicalLerpOrchestrator
  });
  var _MusicalLerpOrchestrator, MusicalLerpOrchestrator, musicalLerpOrchestrator;
  var init_MusicalLerpOrchestrator = __esm({
    "src-js/utils/core/MusicalLerpOrchestrator.ts"() {
      "use strict";
      _MusicalLerpOrchestrator = class _MusicalLerpOrchestrator {
        constructor(enableDebug = false) {
          // Base half-life values for different animation types
          this.baseHalfLifeValues = {
            pulse: 0.08,
            // Beat-synchronized effects
            flow: 0.15,
            // Continuous movement (parallax, gradients)
            emotional: 0.25,
            // Color and emotional transitions
            organic: 0.12,
            // Particle and breathing effects
            crystalline: 0.06
            // Precise, geometric animations
          };
          // Beat phase timing configuration (as percentage of beat interval)
          this.beatPhaseConfig = {
            attack: { start: 0, end: 0.15, baseMultiplier: 0.3 },
            // 0-15% of beat
            sustain: { start: 0.15, end: 0.5, baseMultiplier: 1 },
            // 15-50% of beat
            decay: { start: 0.5, end: 0.85, baseMultiplier: 1.4 },
            // 50-85% of beat
            rest: { start: 0.85, end: 1, baseMultiplier: 0.8 }
            // 85-100% of beat
          };
          // Musical modulation ranges for consciousness calculation
          this.modulationConfig = {
            tempo: {
              reference: 120,
              // Reference BPM (120)
              minFactor: 0.6,
              // Minimum tempo influence
              maxFactor: 1.8,
              // Maximum tempo influence
              curve: 0.3
              // Exponential curve factor
            },
            energy: {
              attackRange: 0.7,
              // Energy influence on attack speed
              decayRange: 0.5,
              // Energy influence on decay sustain
              baseline: 1
              // Baseline multiplier
            },
            danceability: {
              fluidityMin: 0.5,
              // Minimum fluidity factor
              fluidityMax: 1,
              // Maximum fluidity factor
              organicThreshold: 0.6
              // Threshold for organic behavior
            },
            temperature: {
              neutral: 4e3,
              // Neutral temperature (4000K)
              range: 16e3,
              // Temperature range for calculation
              warmthInfluence: 0.3,
              // Warm temperature flow influence
              coolPrecision: 0.4
              // Cool temperature precision influence
            }
          };
          this.debugMode = false;
          this.debugMode = enableDebug;
        }
        /**
         * Calculate music-aware LERP parameters for consciousness smoothing
         */
        calculateMusicalLerp(musicContext, animationType = "flow", baseHalfLife) {
          return this.calculateMusicalLerpWithPerformance(
            musicContext,
            animationType,
            baseHalfLife,
            null
            // No performance context
          );
        }
        /**
         * Calculate performance-aware musical LERP parameters for consciousness smoothing
         */
        calculateMusicalLerpWithPerformance(musicContext, animationType = "flow", baseHalfLife, performanceContext, performanceParams) {
          const startTime = performance.now();
          const baseHalf = baseHalfLife || this.baseHalfLifeValues[animationType];
          const usePerformanceOptimizations = performanceParams && performanceContext;
          let performanceOptimized = false;
          let tempoFactor = 1;
          let energyFactor = 1;
          let danceabilityFactor = 1;
          let temperatureFactor = 1;
          let beatPhaseFactor = 1;
          if (usePerformanceOptimizations && performanceParams) {
            performanceOptimized = true;
            if (!performanceParams.useSimplifiedCalculations) {
              tempoFactor = this.calculateTempoFactor(musicContext.tempo);
              if (performanceParams.enableEnergyModulation) {
                energyFactor = this.calculateEnergyFactor(musicContext.energy);
              }
              danceabilityFactor = this.calculateDanceabilityFactor(musicContext.danceability);
              if (performanceParams.enableTemperatureMapping) {
                temperatureFactor = this.calculateTemperatureFactor(musicContext.emotionalTemperature);
              }
              if (performanceParams.enableBeatPhase) {
                beatPhaseFactor = this.calculateBeatPhaseFactor(
                  musicContext.beatPhase,
                  musicContext.timeSinceLastBeat,
                  musicContext.beatInterval
                );
              }
            } else {
              tempoFactor = Math.max(0.7, Math.min(1.5, musicContext.tempo / 120));
              if (performanceParams.enableEnergyModulation) {
                energyFactor = 1 + musicContext.energy * 0.2;
              }
              danceabilityFactor = 0.8 + musicContext.danceability * 0.4;
            }
          } else {
            tempoFactor = this.calculateTempoFactor(musicContext.tempo);
            energyFactor = this.calculateEnergyFactor(musicContext.energy);
            danceabilityFactor = this.calculateDanceabilityFactor(musicContext.danceability);
            temperatureFactor = this.calculateTemperatureFactor(musicContext.emotionalTemperature);
            beatPhaseFactor = this.calculateBeatPhaseFactor(
              musicContext.beatPhase,
              musicContext.timeSinceLastBeat,
              musicContext.beatInterval
            );
          }
          let combinedFactor = tempoFactor * energyFactor * danceabilityFactor * temperatureFactor * beatPhaseFactor;
          if (performanceParams?.performanceMultiplier) {
            combinedFactor *= performanceParams.performanceMultiplier;
          }
          if (performanceParams?.complexityReduction && performanceParams.complexityReduction > 0) {
            const neutralFactor = 1;
            const reducedVariation = 1 - performanceParams.complexityReduction;
            combinedFactor = neutralFactor + (combinedFactor - neutralFactor) * reducedVariation;
          }
          const finalHalfLife = baseHalf * combinedFactor;
          let attackMultiplier;
          let decayMultiplier;
          if (usePerformanceOptimizations && performanceParams?.useSimplifiedCalculations) {
            attackMultiplier = musicContext.energy < 0.5 ? 1.2 : 0.8;
            decayMultiplier = musicContext.valence > 0.5 ? 1.3 : 1;
          } else {
            attackMultiplier = this.calculateAttackMultiplier(musicContext.energy, musicContext.beatPhase);
            decayMultiplier = this.calculateDecayMultiplier(musicContext.energy, musicContext.valence);
          }
          const fluidityFactor = this.calculateFluidityFactor(musicContext.danceability, musicContext.emotionalTemperature);
          const consciousnessLevel = this.calculateConsciousnessLevel(musicContext);
          const result = {
            halfLife: Math.max(0.01, Math.min(2, finalHalfLife)),
            // Clamp to reasonable bounds
            attackMultiplier,
            decayMultiplier,
            fluidityFactor,
            consciousnessLevel,
            performanceOptimized
          };
          if (this.debugMode) {
            result.debugInfo = {
              tempoFactor,
              energyFactor,
              danceabilityFactor,
              temperatureFactor,
              beatPhaseFactor
            };
            if (performanceParams?.performanceMultiplier !== void 0) {
              result.debugInfo.performanceMultiplier = performanceParams.performanceMultiplier;
            }
            if (performanceParams?.complexityReduction !== void 0) {
              result.debugInfo.complexityReduction = performanceParams.complexityReduction;
            }
            const processingTime = performance.now() - startTime;
            if (processingTime > 0.5) {
              console.log(`\u{1F3B5} [MusicalLerpOrchestrator] Calculation time: ${processingTime.toFixed(3)}ms (performance-optimized: ${performanceOptimized})`);
            }
          }
          return result;
        }
        /**
         * Calculate tempo influence on LERP responsiveness
         * Faster tempo = snappier response, slower tempo = flowing movement
         */
        calculateTempoFactor(tempo) {
          const { reference, minFactor, maxFactor, curve } = this.modulationConfig.tempo;
          const normalizedTempo = tempo / reference;
          const factor = Math.pow(normalizedTempo, curve);
          return Math.max(minFactor, Math.min(maxFactor, factor));
        }
        /**
         * Calculate energy influence on attack and decay characteristics
         * High energy = aggressive smoothing, low energy = gentle smoothing
         */
        calculateEnergyFactor(energy) {
          const { baseline } = this.modulationConfig.energy;
          return baseline + energy * 0.3;
        }
        /**
         * Calculate danceability influence on organic fluidity
         * High danceability = organic fluid transitions, low = structured
         */
        calculateDanceabilityFactor(danceability) {
          const { fluidityMin, fluidityMax } = this.modulationConfig.danceability;
          return fluidityMin + danceability * (fluidityMax - fluidityMin);
        }
        /**
         * Calculate emotional temperature influence on movement style
         * Warm temperatures = flowing, cool temperatures = crystalline precise
         */
        calculateTemperatureFactor(emotionalTemperature) {
          const { neutral, range, warmthInfluence } = this.modulationConfig.temperature;
          const temperatureRange = (emotionalTemperature - neutral) / range;
          return 1 + temperatureRange * warmthInfluence;
        }
        /**
         * Calculate beat phase influence for rhythmic consciousness
         * Different smoothing based on beat timing phases
         */
        calculateBeatPhaseFactor(beatPhase, timeSinceLastBeat, beatInterval) {
          const phaseConfig = this.beatPhaseConfig[beatPhase];
          const beatPosition = Math.min(1, timeSinceLastBeat / beatInterval);
          let phaseFactor = phaseConfig.baseMultiplier;
          if (beatPhase === "attack" && beatPosition > 0.1) {
            const transitionFactor = (0.15 - beatPosition) / 0.05;
            phaseFactor = phaseConfig.baseMultiplier + (1 - phaseConfig.baseMultiplier) * (1 - transitionFactor);
          }
          return phaseFactor;
        }
        /**
         * Calculate attack multiplier based on energy and beat phase
         */
        calculateAttackMultiplier(energy, beatPhase) {
          const { attackRange, baseline } = this.modulationConfig.energy;
          let baseAttack = baseline - energy * attackRange;
          if (beatPhase === "attack") {
            baseAttack *= 0.5;
          }
          return Math.max(0.1, baseAttack);
        }
        /**
         * Calculate decay multiplier based on energy and emotional valence
         */
        calculateDecayMultiplier(energy, valence) {
          const { decayRange, baseline } = this.modulationConfig.energy;
          let baseDecay = baseline + energy * decayRange;
          baseDecay += valence * 0.3;
          return Math.max(0.8, Math.min(2, baseDecay));
        }
        /**
         * Calculate fluidity factor for organic movement quality
         */
        calculateFluidityFactor(danceability, emotionalTemperature) {
          const { fluidityMin, fluidityMax, organicThreshold } = this.modulationConfig.danceability;
          const { neutral, range } = this.modulationConfig.temperature;
          let fluidity = fluidityMin + danceability * (fluidityMax - fluidityMin);
          const temperatureNorm = (emotionalTemperature - neutral) / range;
          fluidity += temperatureNorm * 0.2;
          return Math.max(0.3, Math.min(1.2, fluidity));
        }
        /**
         * Calculate overall consciousness level for system-wide awareness
         */
        calculateConsciousnessLevel(musicContext) {
          const { energy, valence, danceability, beatConfidence } = musicContext;
          const energyContribution = energy * 0.3;
          const valenceContribution = valence * 0.2;
          const danceabilityContribution = danceability * 0.25;
          const confidenceContribution = beatConfidence * 0.25;
          return Math.max(0.1, Math.min(
            1,
            energyContribution + valenceContribution + danceabilityContribution + confidenceContribution
          ));
        }
        /**
         * Get current beat phase based on timing
         */
        getCurrentBeatPhase(timeSinceLastBeat, beatInterval) {
          const beatPosition = Math.min(1, timeSinceLastBeat / beatInterval);
          if (beatPosition <= 0.15) return "attack";
          if (beatPosition <= 0.5) return "sustain";
          if (beatPosition <= 0.85) return "decay";
          return "rest";
        }
        /**
         * Create musical context from MusicSyncService data
         */
        createMusicalContext(musicSyncService, lastBeatTime = 0) {
          const musicState = musicSyncService.getCurrentMusicState();
          if (!musicState) return null;
          const { emotion, beat, intensity } = musicState;
          const now = Date.now();
          const timeSinceLastBeat = now - lastBeatTime;
          const beatInterval = beat?.tempo ? 6e4 / beat.tempo : 500;
          return {
            tempo: beat?.tempo || 120,
            energy: beat?.energy || intensity || 0.5,
            valence: emotion?.valence || 0.5,
            danceability: emotion?.danceability || 0.5,
            emotionalTemperature: emotion?.temperature || 4e3,
            beatPhase: this.getCurrentBeatPhase(timeSinceLastBeat, beatInterval),
            beatConfidence: beat?.confidence || 0.5,
            beatInterval,
            timeSinceLastBeat
          };
        }
        /**
         * Enable or disable debug mode
         */
        setDebugMode(enabled) {
          this.debugMode = enabled;
        }
        /**
         * Get current configuration for inspection
         */
        getConfiguration() {
          return {
            baseHalfLifeValues: { ...this.baseHalfLifeValues },
            beatPhaseConfig: { ...this.beatPhaseConfig },
            modulationConfig: { ...this.modulationConfig }
          };
        }
      };
      __name(_MusicalLerpOrchestrator, "MusicalLerpOrchestrator");
      MusicalLerpOrchestrator = _MusicalLerpOrchestrator;
      musicalLerpOrchestrator = new MusicalLerpOrchestrator(false);
    }
  });

  // src-js/utils/core/Year3000Utilities.ts
  var Year3000Utilities_exports = {};
  __export(Year3000Utilities_exports, {
    adjustColor: () => adjustColor,
    bpmToAnimationFrameRate: () => bpmToAnimationFrameRate,
    bpmToInterval: () => bpmToInterval,
    calculateBreathingScale: () => calculateBreathingScale,
    calculateContrastRatio: () => calculateContrastRatio,
    calculateNavigationScale: () => calculateNavigationScale,
    calculateOklabDerivedProperties: () => calculateOklabDerivedProperties,
    calculateRhythmPhase: () => calculateRhythmPhase,
    colorDifference: () => colorDifference,
    debounce: () => debounce,
    easeBeatAnimation: () => easeBeatAnimation,
    findRequiredLuminance: () => findRequiredLuminance,
    generateHarmonicOklabColors: () => generateHarmonicOklabColors,
    getBeatPhase: () => getBeatPhase,
    getCanonicalAccent: () => getCanonicalAccent,
    getHealthMonitor: () => getHealthMonitor,
    getNextBeatTime: () => getNextBeatTime,
    getRootStyle: () => getRootStyle,
    hexToRgb: () => hexToRgb,
    hslToRgb: () => hslToRgb,
    intervalToBpm: () => intervalToBpm,
    isOnBeat: () => isOnBeat,
    isValidHexColor: () => isValidHexColor,
    lerp: () => lerp,
    lerpSmooth: () => lerpSmooth,
    lerpSmoothMusical: () => lerpSmoothMusical,
    lerpSmoothMusicalPerformance: () => lerpSmoothMusicalPerformance,
    lerpSmoothSimpleMusical: () => lerpSmoothSimpleMusical,
    oklabToRgb: () => oklabToRgb,
    processOklabColor: () => processOklabColor,
    rgbToHex: () => rgbToHex,
    rgbToHsl: () => rgbToHsl,
    rgbToOklab: () => rgbToOklab,
    sanitizeColorMap: () => sanitizeColorMap,
    sleep: () => sleep,
    throttle: () => throttle
  });
  function getRootStyle() {
    return document.documentElement;
  }
  function throttle(func, limit) {
    let inThrottle;
    return /* @__PURE__ */ __name(function throttled(...args) {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    }, "throttled");
  }
  function debounce(func, delay) {
    let timeoutId;
    return /* @__PURE__ */ __name(function debounced(...args) {
      clearTimeout(timeoutId);
      timeoutId = window.setTimeout(() => func(...args), delay);
    }, "debounced");
  }
  function isValidHexColor(value) {
    if (typeof value !== "string") {
      return false;
    }
    const trimmed = value.trim();
    const withHash = trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
    const hexPattern = /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$/;
    return hexPattern.test(withHash);
  }
  function hexToRgb(hex) {
    if (typeof hex !== "string") {
      return { r: 0, g: 0, b: 0 };
    }
    if (!isValidHexColor(hex)) {
      return { r: 0, g: 0, b: 0 };
    }
    const sanitizedHex = hex.trim();
    let processedHex = sanitizedHex.startsWith("#") ? sanitizedHex : `#${sanitizedHex}`;
    processedHex = processedHex.replace(/##+/g, "#");
    if (processedHex.length === 4) {
      processedHex = `#${processedHex[1]}${processedHex[1]}${processedHex[2]}${processedHex[2]}${processedHex[3]}${processedHex[3]}`;
    }
    const result = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(processedHex);
    if (result) {
      try {
        const rgb = {
          r: parseInt(result[1] || "0", 16),
          g: parseInt(result[2] || "0", 16),
          b: parseInt(result[3] || "0", 16)
        };
        return rgb;
      } catch (e) {
        return { r: 0, g: 0, b: 0 };
      }
    } else {
      return { r: 0, g: 0, b: 0 };
    }
  }
  function sanitizeColorMap(input) {
    console.log("\u{1F3A8} [Year3000Utilities] sanitizeColorMap input:", {
      input,
      inputKeys: input ? Object.keys(input) : [],
      inputEntries: input ? Object.entries(input) : []
    });
    const validHex = /^#?[0-9a-fA-F]{3}(?:[0-9a-fA-F]{3})?$/;
    const sanitized = {};
    if (!input || typeof input !== "object") {
      console.warn("\u{1F3A8} [Year3000Utilities] sanitizeColorMap: Invalid input type");
      return sanitized;
    }
    const droppedEntries = [];
    Object.entries(input).forEach(([key, value]) => {
      if (typeof value !== "string") {
        droppedEntries.push([key, value]);
        console.warn(`\u{1F3A8} [Year3000Utilities] Dropped non-string color: ${key} = ${value} (type: ${typeof value})`);
        return;
      }
      const trimmed = value.trim();
      if (!trimmed || trimmed === "undefined") {
        droppedEntries.push([key, value]);
        console.warn(`\u{1F3A8} [Year3000Utilities] Dropped empty/undefined color: ${key} = "${value}"`);
        return;
      }
      if (!validHex.test(trimmed)) {
        droppedEntries.push([key, value]);
        console.warn(`\u{1F3A8} [Year3000Utilities] Dropped invalid hex color: ${key} = "${value}"`);
        return;
      }
      const normalised = trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
      sanitized[key] = normalised;
    });
    console.log("\u{1F3A8} [Year3000Utilities] sanitizeColorMap output:", {
      sanitized,
      sanitizedKeys: Object.keys(sanitized),
      sanitizedEntries: Object.entries(sanitized),
      droppedCount: droppedEntries.length,
      droppedEntries
    });
    if (YEAR3000_CONFIG?.enableDebug && Object.keys(input).length !== Object.keys(sanitized).length) {
      console.warn(
        `[StarryNight sanitizeColorMap] Dropped ${Object.keys(input).length - Object.keys(sanitized).length} invalid colour entries.`
      );
    }
    return sanitized;
  }
  function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h = 0, s = 0, l = (max + min) / 2;
    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }
    return { h: h * 360, s: s * 100, l: l * 100 };
  }
  function hslToRgb(h, s, l) {
    h /= 360;
    s /= 100;
    l /= 100;
    const hue2rgb = /* @__PURE__ */ __name((p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }, "hue2rgb");
    let r_val, g_val, b_val;
    if (s === 0) {
      r_val = g_val = b_val = l;
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r_val = hue2rgb(p, q, h + 1 / 3);
      g_val = hue2rgb(p, q, h);
      b_val = hue2rgb(p, q, h - 1 / 3);
    }
    return {
      r: Math.round(r_val * 255),
      g: Math.round(g_val * 255),
      b: Math.round(b_val * 255)
    };
  }
  function rgbToHex(r, g, b) {
    const normalize = /* @__PURE__ */ __name((c) => {
      if (!Number.isFinite(c)) return 0;
      const scaled = c <= 1 ? c * 255 : c;
      return Math.min(255, Math.max(0, Math.round(scaled)));
    }, "normalize");
    const [nr, ng, nb] = [normalize(r), normalize(g), normalize(b)];
    return "#" + [nr, ng, nb].map((channel) => channel.toString(16).padStart(2, "0")).join("");
  }
  function calculateContrastRatio(color1, color22) {
    const getLuminance = /* @__PURE__ */ __name((rgb) => {
      const [r_val = 0, g_val = 0, b_val = 0] = [rgb.r, rgb.g, rgb.b].map((c) => {
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * r_val + 0.7152 * g_val + 0.0722 * b_val;
    }, "getLuminance");
    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color22);
    if (!rgb1 || !rgb2) return 1;
    const lum1 = getLuminance(rgb1);
    const lum2 = getLuminance(rgb2);
    const brightest = Math.max(lum1, lum2);
    const darkest = Math.min(lum1, lum2);
    return (brightest + 0.05) / (darkest + 0.05);
  }
  function lerpSmooth(current, target, deltaTime, halfLife) {
    const EPSILON = 1e-5;
    if (halfLife <= EPSILON || deltaTime <= 0) {
      if (YEAR3000_CONFIG?.enableDebug) {
        if (halfLife <= EPSILON) {
        }
      }
      return target;
    }
    const result = target + (current - target) * Math.pow(2, -deltaTime / halfLife);
    return result;
  }
  function lerpSmoothMusical(current, target, deltaTime, musicContext, animationType = "flow", baseHalfLife) {
    const { musicalLerpOrchestrator: musicalLerpOrchestrator2 } = (init_MusicalLerpOrchestrator(), __toCommonJS(MusicalLerpOrchestrator_exports));
    const musicalParams = musicalLerpOrchestrator2.calculateMusicalLerp(
      musicContext,
      animationType,
      baseHalfLife
    );
    return lerpSmooth(current, target, deltaTime, musicalParams.halfLife);
  }
  function lerpSmoothMusicalPerformance(current, target, deltaTime, musicContext, performanceCoordinator, animationType = "flow", baseHalfLife) {
    if (!performanceCoordinator?.calculatePerformanceAwareMusicalLerp) {
      return lerpSmoothMusical(current, target, deltaTime, musicContext, animationType, baseHalfLife);
    }
    return performanceCoordinator.calculatePerformanceAwareMusicalLerp(
      current,
      target,
      deltaTime,
      musicContext,
      animationType,
      baseHalfLife
    );
  }
  function lerpSmoothSimpleMusical(current, target, deltaTime, tempo = 120, energy = 0.5, baseHalfLife = 0.15) {
    const tempoFactor = Math.pow(tempo / 120, 0.3);
    const energyFactor = 1 + energy * 0.3;
    const musicalHalfLife = baseHalfLife / tempoFactor * energyFactor;
    return lerpSmooth(current, target, deltaTime, musicalHalfLife);
  }
  function bpmToInterval(bpm) {
    if (!bpm || bpm <= 0) return 500;
    return 6e4 / bpm;
  }
  function intervalToBpm(intervalMs) {
    if (!intervalMs || intervalMs <= 0) return 120;
    return 6e4 / intervalMs;
  }
  function bpmToAnimationFrameRate(bpm, framesPerBeat = 4) {
    const beatInterval = bpmToInterval(bpm);
    return beatInterval / framesPerBeat;
  }
  function isOnBeat(currentTime, trackStartTime, bpm, tolerance = 50) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatPosition = timeSinceStart % beatInterval;
    return beatPosition <= tolerance || beatPosition >= beatInterval - tolerance;
  }
  function getBeatPhase(currentTime, trackStartTime, bpm) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatPosition = timeSinceStart % beatInterval;
    return beatPosition / beatInterval;
  }
  function getNextBeatTime(currentTime, trackStartTime, bpm) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatsElapsed = Math.floor(timeSinceStart / beatInterval);
    return trackStartTime + (beatsElapsed + 1) * beatInterval;
  }
  function easeBeatAnimation(beatPhase, easingType = "ease-out") {
    switch (easingType) {
      case "ease-in":
        return beatPhase * beatPhase;
      case "linear":
        return beatPhase;
      case "ease-out":
      default:
        return beatPhase * (2 - beatPhase);
    }
  }
  function calculateRhythmPhase(currentTime, animationSpeedFactor = 1) {
    const speed = 1e-3 * animationSpeedFactor;
    return currentTime * speed % (2 * Math.PI);
  }
  function calculateBreathingScale(rhythmPhase, processedEnergy = 0.5) {
    const baseScale = 1;
    const pulseAmount = 0.02 * processedEnergy;
    const breath = Math.sin(rhythmPhase) * pulseAmount;
    return baseScale + breath;
  }
  function calculateNavigationScale(visualIntensity = 0.5, moodIdentifier = "neutral") {
    const baseScale = 1;
    const moodFactor = moodIdentifier === "energetic" ? 1.2 : moodIdentifier === "calm" ? 0.8 : 1;
    return baseScale + 0.05 * visualIntensity * moodFactor;
  }
  function rgbToOklab(r_srgb, g_srgb, b_srgb) {
    const r = r_srgb / 255;
    const g = g_srgb / 255;
    const b = b_srgb / 255;
    const l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l_ = Math.cbrt(l);
    const m_ = Math.cbrt(m);
    const s_ = Math.cbrt(s);
    return {
      L: 0.2104542553 * l_ + 0.793617785 * m_ - 0.0040720468 * s_,
      a: 1.9779984951 * l_ - 2.428592205 * m_ + 0.4505937099 * s_,
      b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.808675766 * s_
    };
  }
  function oklabToRgb(L, a, b_oklab) {
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b_oklab;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b_oklab;
    const s_ = L - 0.0894841775 * a - 1.291485548 * b_oklab;
    const l = l_ * l_ * l_;
    const m = m_ * m_ * m_;
    const s = s_ * s_ * s_;
    let r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
    let g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
    let b = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s;
    r = Math.round(Math.max(0, Math.min(1, r)) * 255);
    g = Math.round(Math.max(0, Math.min(1, g)) * 255);
    b = Math.round(Math.max(0, Math.min(1, b)) * 255);
    return { r, g, b };
  }
  function processOklabColor(oklabColor, context = {}) {
    const { L, a, b } = oklabColor;
    const C = Math.sqrt(a * a + b * b);
    let h_rad = Math.atan2(b, a);
    if (h_rad < 0) {
      h_rad += 2 * Math.PI;
    }
    const h = h_rad * (180 / Math.PI);
    const {
      energy = 0.5,
      valence = 0.5,
      artisticMode = "artist-vision"
    } = context;
    const multipliers = YEAR3000_CONFIG.getCurrentMultipliers();
    let adjusted_L = L * (1 + (valence - 0.5) * 0.1);
    let adjusted_C = C * (1 + (energy - 0.5) * 0.2) * (multipliers?.saturation || 1);
    adjusted_L = Math.max(
      0,
      Math.min(1, adjusted_L * (multipliers?.brightness || 1))
    );
    return {
      L: adjusted_L,
      C: adjusted_C,
      h: C > 1e-3 ? h : null
      // Hue is meaningless if chroma is near zero
    };
  }
  function calculateOklabDerivedProperties(oklabColor) {
    const { L, C, h } = processOklabColor(oklabColor);
    const isWarm = h !== null ? h >= 0 && h < 90 || h >= 270 && h <= 360 : false;
    const isCool = h !== null ? h >= 90 && h < 270 : false;
    let mood = "neutral";
    if (L > 0.7 && C > 0.1) mood = "bright";
    else if (L < 0.4) mood = "dark";
    else if (isWarm && C > 0.1) mood = "warm";
    else if (isCool && C > 0.1) mood = "cool";
    return {
      lightness: L,
      chroma: C,
      hue: h,
      isWarm,
      isCool,
      mood
    };
  }
  function generateHarmonicOklabColors(baseOklabColor, rule = "analogous", angle = 30) {
    const baseLCH = processOklabColor(baseOklabColor);
    if (baseLCH.h === null) {
      return [baseOklabColor];
    }
    const getOklabFromLCH = /* @__PURE__ */ __name((l_val, c_val, h_deg_val) => {
      const h_rad = h_deg_val * (Math.PI / 180);
      const a_val = c_val * Math.cos(h_rad);
      const b_val = c_val * Math.sin(h_rad);
      return { L: l_val, a: a_val, b: b_val };
    }, "getOklabFromLCH");
    const colors = [baseOklabColor];
    const { L, C, h } = baseLCH;
    switch (rule) {
      case "complementary":
        colors.push(getOklabFromLCH(L, C, (h + 180) % 360));
        break;
      case "analogous":
        colors.push(getOklabFromLCH(L, C, (h + angle) % 360));
        colors.push(getOklabFromLCH(L, C, (h - angle + 360) % 360));
        break;
      case "triadic":
        colors.push(getOklabFromLCH(L, C, (h + 120) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 240) % 360));
        break;
      case "tetradic":
        colors.push(getOklabFromLCH(L, C, (h + 90) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 180) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 270) % 360));
        break;
      case "split-complementary":
        colors.push(getOklabFromLCH(L, C, (h + 180 - angle) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 180 + angle) % 360));
        break;
      case "monochromatic":
        colors.push({
          L: Math.max(0, L - 0.2),
          a: baseOklabColor.a,
          b: baseOklabColor.b
        });
        colors.push({
          L: Math.min(1, L + 0.2),
          a: baseOklabColor.a,
          b: baseOklabColor.b
        });
        break;
    }
    return colors;
  }
  function lerp(start, end, amt) {
    return (1 - amt) * start + amt * end;
  }
  function colorDifference(rgb1, rgb2) {
    const lab1 = rgbToOklab(rgb1.r, rgb1.g, rgb1.b);
    const lab2 = rgbToOklab(rgb2.r, rgb2.g, rgb2.b);
    const deltaL = lab1.L - lab2.L;
    const deltaA = lab1.a - lab2.a;
    const deltaB = lab1.b - lab2.b;
    return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
  }
  function getHealthMonitor() {
    return healthMonitorInstance;
  }
  function findRequiredLuminance(color1, color22, ratio) {
    const getLuminance = /* @__PURE__ */ __name((rgb) => {
      const [r_val = 0, g_val = 0, b_val = 0] = [rgb.r, rgb.g, rgb.b].map((c) => {
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * r_val + 0.7152 * g_val + 0.0722 * b_val;
    }, "getLuminance");
    const lum2 = getLuminance(color22);
    let targetLuminance;
    targetLuminance = ratio * (lum2 + 0.05) - 0.05;
    const hsl = rgbToHsl(color1.r, color1.g, color1.b);
    const currentLuminance = getLuminance(color1);
    const luminanceRatio = targetLuminance / currentLuminance;
    return hsl.l;
  }
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function adjustColor(rgb, {
    brightness = 1,
    saturation = 1,
    hue = 0
  }) {
    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
    hsl.h = (hsl.h + hue) % 360;
    hsl.s = Math.max(0, Math.min(100, hsl.s * saturation));
    hsl.l = Math.max(0, Math.min(100, hsl.l * brightness));
    return hslToRgb(hsl.h, hsl.s, hsl.l);
  }
  function getCanonicalAccent() {
    const root = getRootStyle();
    const styles = getComputedStyle(root);
    let hex = styles.getPropertyValue("--sn-accent-hex").trim();
    let rgb = styles.getPropertyValue("--sn-accent-rgb").trim();
    if (!hex && rgb) {
      const [rStr = "0", gStr = "0", bStr = "0"] = rgb.split(/\s*,\s*/);
      const r = parseInt(rStr, 10) || 0;
      const g = parseInt(gStr, 10) || 0;
      const b = parseInt(bStr, 10) || 0;
      hex = rgbToHex(r, g, b);
    }
    if (!rgb && hex) {
      const rgbObj = hexToRgb(hex);
      if (rgbObj) {
        rgb = `${rgbObj.r},${rgbObj.g},${rgbObj.b}`;
      }
    }
    return { hex, rgb };
  }
  var _HealthMonitor, HealthMonitor, healthMonitorInstance;
  var init_Year3000Utilities = __esm({
    "src-js/utils/core/Year3000Utilities.ts"() {
      "use strict";
      init_globalConfig();
      __name(getRootStyle, "getRootStyle");
      __name(throttle, "throttle");
      __name(debounce, "debounce");
      __name(isValidHexColor, "isValidHexColor");
      __name(hexToRgb, "hexToRgb");
      __name(sanitizeColorMap, "sanitizeColorMap");
      __name(rgbToHsl, "rgbToHsl");
      __name(hslToRgb, "hslToRgb");
      __name(rgbToHex, "rgbToHex");
      __name(calculateContrastRatio, "calculateContrastRatio");
      __name(lerpSmooth, "lerpSmooth");
      __name(lerpSmoothMusical, "lerpSmoothMusical");
      __name(lerpSmoothMusicalPerformance, "lerpSmoothMusicalPerformance");
      __name(lerpSmoothSimpleMusical, "lerpSmoothSimpleMusical");
      __name(bpmToInterval, "bpmToInterval");
      __name(intervalToBpm, "intervalToBpm");
      __name(bpmToAnimationFrameRate, "bpmToAnimationFrameRate");
      __name(isOnBeat, "isOnBeat");
      __name(getBeatPhase, "getBeatPhase");
      __name(getNextBeatTime, "getNextBeatTime");
      __name(easeBeatAnimation, "easeBeatAnimation");
      __name(calculateRhythmPhase, "calculateRhythmPhase");
      __name(calculateBreathingScale, "calculateBreathingScale");
      __name(calculateNavigationScale, "calculateNavigationScale");
      __name(rgbToOklab, "rgbToOklab");
      __name(oklabToRgb, "oklabToRgb");
      __name(processOklabColor, "processOklabColor");
      __name(calculateOklabDerivedProperties, "calculateOklabDerivedProperties");
      __name(generateHarmonicOklabColors, "generateHarmonicOklabColors");
      __name(lerp, "lerp");
      __name(colorDifference, "colorDifference");
      _HealthMonitor = class _HealthMonitor {
        registerSystem(name, instance2) {
        }
        updateSystemMetrics(name, metrics) {
        }
      };
      __name(_HealthMonitor, "HealthMonitor");
      HealthMonitor = _HealthMonitor;
      healthMonitorInstance = new HealthMonitor();
      __name(getHealthMonitor, "getHealthMonitor");
      __name(findRequiredLuminance, "findRequiredLuminance");
      __name(sleep, "sleep");
      __name(adjustColor, "adjustColor");
      __name(getCanonicalAccent, "getCanonicalAccent");
    }
  });

  // src-js/utils/color/OKLABColorProcessor.ts
  var _OKLABColorProcessor, OKLABColorProcessor;
  var init_OKLABColorProcessor = __esm({
    "src-js/utils/color/OKLABColorProcessor.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_Year3000Utilities();
      _OKLABColorProcessor = class _OKLABColorProcessor {
        constructor(enableDebug = false) {
          this.utils = Year3000Utilities_exports;
          this.debugEnabled = enableDebug;
        }
        /**
         * Process a color through OKLAB space with enhancement preset
         */
        processColor(hexColor, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const startTime = performance.now();
          let originalRgb = null;
          try {
            originalRgb = this.utils.hexToRgb(hexColor);
            if (!originalRgb) {
              throw new Error(`Invalid hex color: ${hexColor}`);
            }
            const oklabOriginal = this.utils.rgbToOklab(
              originalRgb.r,
              originalRgb.g,
              originalRgb.b
            );
            const oklabEnhanced = this.enhanceOKLABColor(oklabOriginal, preset);
            const oklabShadow = this.generateShadowColor(oklabOriginal, preset);
            const enhancedRgb = this.utils.oklabToRgb(
              oklabEnhanced.L,
              oklabEnhanced.a,
              oklabEnhanced.b
            );
            const shadowRgb = this.utils.oklabToRgb(
              oklabShadow.L,
              oklabShadow.a,
              oklabShadow.b
            );
            const enhancedHex = this.utils.rgbToHex(
              enhancedRgb.r,
              enhancedRgb.g,
              enhancedRgb.b
            );
            const shadowHex = this.utils.rgbToHex(
              shadowRgb.r,
              shadowRgb.g,
              shadowRgb.b
            );
            const oklchEnhanced = this.convertOklabToOklch(oklabEnhanced);
            const processingTime = performance.now() - startTime;
            const result = {
              originalHex: hexColor,
              originalRgb,
              enhancedHex,
              enhancedRgb,
              shadowHex,
              shadowRgb,
              oklabOriginal,
              oklabEnhanced,
              oklabShadow,
              oklchEnhanced,
              processingTime
            };
            if (this.debugEnabled) {
              Y3KDebug?.debug?.log("OKLABColorProcessor", "Color processed:", {
                input: hexColor,
                enhanced: enhancedHex,
                shadow: shadowHex,
                preset: preset.name,
                processingTime: `${processingTime.toFixed(2)}ms`
              });
            }
            return result;
          } catch (error) {
            if (this.debugEnabled) {
              Y3KDebug?.debug?.error(
                "OKLABColorProcessor",
                "Color processing failed:",
                error
              );
            }
            const fallbackRgb = originalRgb || { r: 124, g: 58, b: 237 };
            return this.createFallbackResult(hexColor, fallbackRgb);
          }
        }
        /**
         * Process multiple colors with consistent enhancement
         */
        processColorPalette(colors, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const results = {};
          Object.entries(colors).forEach(([key, hex]) => {
            if (hex && this.utils.hexToRgb(hex)) {
              results[key] = this.processColor(hex, preset);
            }
          });
          return results;
        }
        /**
         * Generate CSS variables from processed color
         */
        generateCSSVariables(processed, prefix = "sn-oklab") {
          const cssVars = {};
          cssVars[`--${prefix}-enhanced-hex`] = processed.enhancedHex;
          cssVars[`--${prefix}-enhanced-rgb`] = `${processed.enhancedRgb.r},${processed.enhancedRgb.g},${processed.enhancedRgb.b}`;
          cssVars[`--${prefix}-enhanced-r`] = Math.round(
            processed.enhancedRgb.r
          ).toString();
          cssVars[`--${prefix}-enhanced-g`] = Math.round(
            processed.enhancedRgb.g
          ).toString();
          cssVars[`--${prefix}-enhanced-b`] = Math.round(
            processed.enhancedRgb.b
          ).toString();
          cssVars[`--${prefix}-shadow-hex`] = processed.shadowHex;
          cssVars[`--${prefix}-shadow-rgb`] = `${processed.shadowRgb.r},${processed.shadowRgb.g},${processed.shadowRgb.b}`;
          cssVars[`--${prefix}-lightness`] = processed.oklabEnhanced.L.toFixed(3);
          cssVars[`--${prefix}-chroma-a`] = processed.oklabEnhanced.a.toFixed(3);
          cssVars[`--${prefix}-chroma-b`] = processed.oklabEnhanced.b.toFixed(3);
          cssVars[`--${prefix}-oklch-l`] = processed.oklchEnhanced.L.toFixed(3);
          cssVars[`--${prefix}-oklch-c`] = processed.oklchEnhanced.C.toFixed(3);
          cssVars[`--${prefix}-oklch-h`] = processed.oklchEnhanced.H.toFixed(1);
          return cssVars;
        }
        /**
         * Interpolate between two colors in OKLAB space
         */
        interpolateOKLAB(color1Hex, color2Hex, factor, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const rgb1 = this.utils.hexToRgb(color1Hex);
          const rgb2 = this.utils.hexToRgb(color2Hex);
          if (!rgb1 || !rgb2) {
            throw new Error("Invalid hex colors for interpolation");
          }
          const oklab1 = this.utils.rgbToOklab(rgb1.r, rgb1.g, rgb1.b);
          const oklab2 = this.utils.rgbToOklab(rgb2.r, rgb2.g, rgb2.b);
          const interpolatedOklab = {
            L: oklab1.L + (oklab2.L - oklab1.L) * factor,
            a: oklab1.a + (oklab2.a - oklab1.a) * factor,
            b: oklab1.b + (oklab2.b - oklab1.b) * factor
          };
          const interpolatedRgb = this.utils.oklabToRgb(
            interpolatedOklab.L,
            interpolatedOklab.a,
            interpolatedOklab.b
          );
          const interpolatedHex = this.utils.rgbToHex(
            interpolatedRgb.r,
            interpolatedRgb.g,
            interpolatedRgb.b
          );
          return this.processColor(interpolatedHex, preset);
        }
        /**
         * Generate gradient stops in OKLAB space
         */
        generateOKLABGradient(startHex, endHex, stopCount = 5, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const gradientStops = [];
          for (let i = 0; i < stopCount; i++) {
            const factor = i / (stopCount - 1);
            const interpolated = this.interpolateOKLAB(
              startHex,
              endHex,
              factor,
              preset
            );
            gradientStops.push(interpolated);
          }
          return gradientStops;
        }
        /**
         * Enhance color in OKLAB space
         */
        enhanceOKLABColor(oklab, preset) {
          const currentChroma = Math.sqrt(oklab.a * oklab.a + oklab.b * oklab.b);
          const enhancedL = Math.min(1, Math.max(0, oklab.L * preset.lightnessBoost));
          const chromaMultiplier = currentChroma > preset.vibrantThreshold ? preset.chromaBoost : 1;
          const enhancedA = oklab.a * chromaMultiplier;
          const enhancedB = oklab.b * chromaMultiplier;
          return { L: enhancedL, a: enhancedA, b: enhancedB };
        }
        /**
         * Generate shadow color by reducing lightness while preserving hue
         */
        generateShadowColor(oklab, preset) {
          return {
            L: Math.max(0.02, oklab.L * preset.shadowReduction),
            a: oklab.a * 0.8,
            // Slightly desaturate shadows
            b: oklab.b * 0.8
          };
        }
        /**
         * Convert OKLAB to OKLCH (cylindrical representation)
         */
        convertOklabToOklch(oklab) {
          const L = oklab.L;
          const C = Math.sqrt(oklab.a * oklab.a + oklab.b * oklab.b);
          let H = Math.atan2(oklab.b, oklab.a) * (180 / Math.PI);
          if (H < 0) H += 360;
          return { L, C, H };
        }
        /**
         * Create fallback result for error cases
         */
        createFallbackResult(hexColor, fallbackRgb) {
          const fallbackOklab = this.utils.rgbToOklab(
            fallbackRgb.r,
            fallbackRgb.g,
            fallbackRgb.b
          );
          return {
            originalHex: hexColor,
            originalRgb: fallbackRgb,
            enhancedHex: hexColor,
            enhancedRgb: fallbackRgb,
            shadowHex: "#000000",
            shadowRgb: { r: 0, g: 0, b: 0 },
            oklabOriginal: fallbackOklab,
            oklabEnhanced: fallbackOklab,
            oklabShadow: { L: 0.05, a: 0, b: 0 },
            oklchEnhanced: this.convertOklabToOklch(fallbackOklab),
            processingTime: 0
          };
        }
        /**
         * Get preset by name with fallback
         */
        static getPreset(name) {
          return _OKLABColorProcessor.PRESETS[name.toUpperCase()] || _OKLABColorProcessor.PRESETS.STANDARD;
        }
        /**
         * Create custom preset
         */
        static createCustomPreset(name, description, lightnessBoost, chromaBoost, shadowReduction = 0.3, vibrantThreshold = 0.1) {
          return {
            name,
            description,
            lightnessBoost: Math.max(0.5, Math.min(1.5, lightnessBoost)),
            chromaBoost: Math.max(0.5, Math.min(2, chromaBoost)),
            shadowReduction: Math.max(0.1, Math.min(0.5, shadowReduction)),
            vibrantThreshold: Math.max(0.05, Math.min(0.2, vibrantThreshold))
          };
        }
      };
      __name(_OKLABColorProcessor, "OKLABColorProcessor");
      // Built-in enhancement presets
      _OKLABColorProcessor.PRESETS = {
        SUBTLE: {
          name: "Subtle Enhancement",
          description: "Minimal color enhancement for conservative aesthetics",
          lightnessBoost: 1.05,
          chromaBoost: 1.1,
          shadowReduction: 0.4,
          vibrantThreshold: 0.08
        },
        STANDARD: {
          name: "Standard Enhancement",
          description: "Balanced color enhancement for general use",
          lightnessBoost: 1.1,
          chromaBoost: 1.15,
          shadowReduction: 0.3,
          vibrantThreshold: 0.1
        },
        VIBRANT: {
          name: "Vibrant Enhancement",
          description: "Enhanced vibrancy for dynamic color experiences",
          lightnessBoost: 1.15,
          chromaBoost: 1.25,
          shadowReduction: 0.25,
          vibrantThreshold: 0.12
        },
        COSMIC: {
          name: "Cosmic Enhancement",
          description: "Maximum enhancement for Year 3000 consciousness experiences",
          lightnessBoost: 1.2,
          chromaBoost: 1.35,
          shadowReduction: 0.2,
          vibrantThreshold: 0.15
        }
      };
      OKLABColorProcessor = _OKLABColorProcessor;
    }
  });

  // src-js/utils/color/EmotionalTemperatureMapper.ts
  var EMOTIONAL_TEMPERATURE_MAP, _EmotionalTemperatureMapper, EmotionalTemperatureMapper;
  var init_EmotionalTemperatureMapper = __esm({
    "src-js/utils/color/EmotionalTemperatureMapper.ts"() {
      "use strict";
      init_OKLABColorProcessor();
      EMOTIONAL_TEMPERATURE_MAP = {
        calm: {
          temperatureRange: [2700, 4e3],
          baseTemperature: 3200,
          characteristics: {
            energy: [0, 0.3],
            valence: [0.4, 0.8],
            intensity: 0.6
          },
          cssClass: "organic-emotion-calm",
          description: "Warm, soothing, meditative states",
          oklabBaseColor: "#89b4fa",
          // Catppuccin blue - calming base
          oklabPreset: "SUBTLE",
          perceptualCharacteristics: {
            lightness: [0.6, 0.8],
            // Moderate to high lightness for calming effect
            chromaBoost: 0.9,
            // Slightly reduced chroma for gentleness
            hueShift: 15
            // Slight warm shift towards cyan-blue
          }
        },
        melancholy: {
          temperatureRange: [2200, 3500],
          baseTemperature: 2800,
          characteristics: {
            energy: [0, 0.4],
            valence: [0, 0.4],
            intensity: 0.8
          },
          cssClass: "organic-emotion-melancholy",
          description: "Deep, introspective, amber-golden tones",
          oklabBaseColor: "#f9e2af",
          // Catppuccin yellow - warm melancholic base
          oklabPreset: "STANDARD",
          perceptualCharacteristics: {
            lightness: [0.4, 0.6],
            // Lower lightness for introspective mood
            chromaBoost: 1.1,
            // Enhanced warmth and saturation
            hueShift: -10
            // Shift towards warmer amber tones
          }
        },
        energetic: {
          temperatureRange: [5500, 7500],
          baseTemperature: 6500,
          characteristics: {
            energy: [0.6, 1],
            valence: [0.5, 1],
            intensity: 1
          },
          cssClass: "organic-emotion-energetic",
          description: "Bright, vibrant, high-energy states",
          oklabBaseColor: "#a6e3a1",
          // Catppuccin green - vibrant energetic base
          oklabPreset: "VIBRANT",
          perceptualCharacteristics: {
            lightness: [0.7, 0.9],
            // High lightness for energy
            chromaBoost: 1.3,
            // Maximum vibrancy
            hueShift: 5
            // Slight shift towards more vibrant green
          }
        },
        aggressive: {
          temperatureRange: [8e3, 12e3],
          baseTemperature: 1e4,
          characteristics: {
            energy: [0.7, 1],
            valence: [0, 0.6],
            intensity: 1.2
          },
          cssClass: "organic-emotion-aggressive",
          description: "Cool, intense, high-energy negative valence",
          oklabBaseColor: "#f38ba8",
          // Catppuccin red - intense aggressive base
          oklabPreset: "COSMIC",
          perceptualCharacteristics: {
            lightness: [0.5, 0.7],
            // Moderate lightness with high intensity
            chromaBoost: 1.4,
            // Maximum chroma for intensity
            hueShift: -5
            // Slight shift towards deeper red
          }
        },
        happy: {
          temperatureRange: [4500, 6500],
          baseTemperature: 5500,
          characteristics: {
            energy: [0.4, 0.8],
            valence: [0.6, 1],
            intensity: 0.9
          },
          cssClass: "organic-emotion-happy",
          description: "Balanced, joyful, warm-white tones",
          oklabBaseColor: "#fab387",
          // Catppuccin peach - warm happy base
          oklabPreset: "STANDARD",
          perceptualCharacteristics: {
            lightness: [0.75, 0.85],
            // High lightness for joy
            chromaBoost: 1.15,
            // Enhanced warmth
            hueShift: 8
            // Shift towards warmer orange
          }
        },
        romantic: {
          temperatureRange: [2500, 3500],
          baseTemperature: 3e3,
          characteristics: {
            energy: [0.2, 0.6],
            valence: [0.5, 0.9],
            intensity: 0.7
          },
          cssClass: "organic-emotion-romantic",
          description: "Soft, intimate, warm tones with pink accent",
          oklabBaseColor: "#f5c2e7",
          // Catppuccin pink - romantic base
          oklabPreset: "SUBTLE",
          perceptualCharacteristics: {
            lightness: [0.65, 0.8],
            // Soft, comfortable lightness
            chromaBoost: 1,
            // Natural saturation
            hueShift: 12
            // Shift towards warmer pink
          }
        },
        mysterious: {
          temperatureRange: [1800, 2800],
          baseTemperature: 2300,
          characteristics: {
            energy: [0.1, 0.5],
            valence: [0.1, 0.5],
            intensity: 0.9
          },
          cssClass: "organic-emotion-mysterious",
          description: "Deep, enigmatic, low temperature with purple accent",
          oklabBaseColor: "#cba6f7",
          // Catppuccin mauve - mysterious base
          oklabPreset: "VIBRANT",
          perceptualCharacteristics: {
            lightness: [0.3, 0.5],
            // Low lightness for mystery
            chromaBoost: 1.2,
            // Enhanced depth
            hueShift: -15
            // Shift towards deeper purple
          }
        },
        epic: {
          temperatureRange: [7e3, 15e3],
          baseTemperature: 11e3,
          characteristics: {
            energy: [0.6, 1],
            valence: [0.3, 0.8],
            intensity: 1.3
          },
          cssClass: "organic-emotion-epic",
          description: "Grand, cinematic, high contrast blue-gold",
          oklabBaseColor: "#74c7ec",
          // Catppuccin sapphire - epic base
          oklabPreset: "COSMIC",
          perceptualCharacteristics: {
            lightness: [0.6, 0.9],
            // Wide lightness range for drama
            chromaBoost: 1.35,
            // Maximum cinematic impact
            hueShift: 20
            // Shift towards more dramatic blue
          }
        },
        ambient: {
          temperatureRange: [3e3, 5e3],
          baseTemperature: 4e3,
          characteristics: {
            energy: [0.1, 0.4],
            valence: [0.3, 0.7],
            intensity: 0.5
          },
          cssClass: "organic-emotion-ambient",
          description: "Atmospheric, floating, neutral temperature",
          oklabBaseColor: "#94e2d5",
          // Catppuccin teal - ambient base
          oklabPreset: "SUBTLE",
          perceptualCharacteristics: {
            lightness: [0.5, 0.7],
            // Balanced lightness for atmosphere
            chromaBoost: 0.8,
            // Reduced chroma for subtlety
            hueShift: 0
            // No hue shift for neutrality
          }
        }
      };
      _EmotionalTemperatureMapper = class _EmotionalTemperatureMapper {
        constructor(enableDebug = false) {
          this.enableDebug = enableDebug;
          this.oklabProcessor = new OKLABColorProcessor(enableDebug);
        }
        /**
         * Analyzes music data and returns the appropriate emotional temperature configuration
         */
        mapMusicToEmotionalTemperature(musicData) {
          const { energy = 0.5, valence = 0.5, danceability = 0.5, tempo = 120, mode = 1 } = musicData;
          let primaryEmotion;
          let secondaryEmotion;
          let blendRatio = 1;
          if (energy >= 0.6 && valence >= 0.6) {
            primaryEmotion = danceability > 0.7 ? "energetic" : "happy";
            if (energy > 0.8 && valence > 0.8) {
              secondaryEmotion = "epic";
              blendRatio = 0.7;
            }
          } else if (energy >= 0.6 && valence < 0.5) {
            primaryEmotion = energy > 0.8 ? "aggressive" : "epic";
            if (valence < 0.3) {
              secondaryEmotion = "mysterious";
              blendRatio = 0.8;
            }
          } else if (energy < 0.4 && valence >= 0.5) {
            primaryEmotion = valence > 0.7 ? "calm" : "romantic";
            if (energy < 0.2) {
              secondaryEmotion = "ambient";
              blendRatio = 0.6;
            }
          } else {
            primaryEmotion = valence < 0.3 ? "melancholy" : "mysterious";
            if (energy < 0.2 && valence < 0.2) {
              secondaryEmotion = "ambient";
              blendRatio = 0.8;
            }
          }
          if (musicData.genre) {
            const genreAdjustment = this.getGenreEmotionalAdjustment(musicData.genre, primaryEmotion);
            if (genreAdjustment) {
              if (genreAdjustment.override) {
                primaryEmotion = genreAdjustment.override;
              }
              if (genreAdjustment.secondary) {
                secondaryEmotion = genreAdjustment.secondary;
                blendRatio = genreAdjustment.blendRatio || 0.7;
              }
            }
          }
          const baseIntensity = EMOTIONAL_TEMPERATURE_MAP[primaryEmotion].characteristics.intensity;
          const energyBoost = energy * 0.3;
          const valenceInfluence = Math.abs(valence - 0.5) * 0.2;
          const tempoInfluence = tempo > 140 ? 0.1 : tempo < 80 ? -0.1 : 0;
          const finalIntensity = Math.max(0.1, Math.min(
            1.5,
            baseIntensity + energyBoost + valenceInfluence + tempoInfluence
          ));
          const emotionData = EMOTIONAL_TEMPERATURE_MAP[primaryEmotion];
          const [minTemp, maxTemp] = emotionData.temperatureRange;
          const temperaturePosition = energy * 0.6 + valence * 0.4;
          const temperature = minTemp + (maxTemp - minTemp) * temperaturePosition;
          const oklabPreset = OKLABColorProcessor.getPreset(emotionData.oklabPreset);
          let oklabResult;
          let perceptualColorHex;
          try {
            const customPreset = this.createContextualOKLABPreset(
              emotionData,
              finalIntensity,
              energy,
              valence
            );
            oklabResult = this.oklabProcessor.processColor(
              emotionData.oklabBaseColor,
              customPreset
            );
            perceptualColorHex = oklabResult.enhancedHex;
            if (this.enableDebug) {
              console.log("\u{1F321}\uFE0F [EmotionalTemperatureMapper] OKLAB processing:", {
                emotion: primaryEmotion,
                baseColor: emotionData.oklabBaseColor,
                preset: customPreset.name,
                enhanced: perceptualColorHex,
                oklabCoords: oklabResult.oklabEnhanced
              });
            }
          } catch (error) {
            if (this.enableDebug) {
              console.warn("\u{1F321}\uFE0F [EmotionalTemperatureMapper] OKLAB processing failed:", error);
            }
            perceptualColorHex = emotionData.oklabBaseColor;
          }
          const cssVariables = this.generateEmotionalCSSVariables(
            primaryEmotion,
            secondaryEmotion,
            finalIntensity,
            temperature,
            blendRatio,
            oklabResult,
            perceptualColorHex
          );
          const result = {
            primaryEmotion,
            ...secondaryEmotion && { secondaryEmotion },
            intensity: finalIntensity,
            temperature: Math.round(temperature),
            blendRatio,
            cssClass: emotionData.cssClass,
            cssVariables,
            // OKLAB integration
            oklabPreset,
            ...oklabResult && { oklabResult },
            ...perceptualColorHex && { perceptualColorHex }
          };
          if (this.enableDebug) {
            console.log("\u{1F321}\uFE0F [EmotionalTemperatureMapper] Music analysis result:", {
              input: { energy, valence, genre: musicData.genre },
              output: result,
              reasoning: {
                energyValenceQuadrant: this.getEnergyValenceQuadrant(energy, valence),
                genreInfluence: musicData.genre,
                intensityFactors: { baseIntensity, energyBoost, valenceInfluence, tempoInfluence }
              }
            });
          }
          return result;
        }
        /**
         * Create contextual OKLAB preset based on emotional characteristics and music data
         */
        createContextualOKLABPreset(emotionData, intensity, energy, valence) {
          const basePreset = OKLABColorProcessor.getPreset(emotionData.oklabPreset);
          const perceptualChars = emotionData.perceptualCharacteristics;
          const lightnessFactor = energy * 0.5 + valence * 0.3 + 0.2;
          const targetLightness = perceptualChars.lightness[0] + (perceptualChars.lightness[1] - perceptualChars.lightness[0]) * lightnessFactor;
          const chromaMultiplier = perceptualChars.chromaBoost * intensity * (0.8 + energy * 0.4);
          return OKLABColorProcessor.createCustomPreset(
            `${emotionData.cssClass}-contextual`,
            `Contextual ${basePreset.description} for ${emotionData.description}`,
            targetLightness / 0.5,
            // Convert to lightness boost multiplier
            chromaMultiplier,
            basePreset.shadowReduction,
            basePreset.vibrantThreshold
          );
        }
        /**
         * Get genre-specific emotional adjustments
         */
        getGenreEmotionalAdjustment(genre, currentEmotion) {
          const genreMap = {
            // Electronic genres
            "edm": { secondary: "energetic", blendRatio: 0.8 },
            "house": { secondary: "energetic", blendRatio: 0.7 },
            "ambient": { override: "ambient" },
            "downtempo": { override: "calm", secondary: "ambient", blendRatio: 0.6 },
            // Rock genres
            "metal": { override: "aggressive" },
            "hard-rock": { secondary: "aggressive", blendRatio: 0.8 },
            "alternative": { secondary: "epic", blendRatio: 0.7 },
            // Classical and orchestral
            "classical": { override: "epic", secondary: "calm", blendRatio: 0.6 },
            "soundtrack": { override: "epic" },
            "orchestral": { override: "epic" },
            // Jazz and soul
            "jazz": { override: "mysterious", secondary: "romantic", blendRatio: 0.7 },
            "blues": { override: "melancholy" },
            "soul": { secondary: "romantic", blendRatio: 0.6 },
            // Folk and acoustic
            "folk": { override: "calm", secondary: "melancholy", blendRatio: 0.6 },
            "acoustic": { override: "romantic", secondary: "calm", blendRatio: 0.7 },
            // Hip-hop and urban
            "hip-hop": { secondary: "aggressive", blendRatio: 0.8 },
            "trap": { secondary: "aggressive", blendRatio: 0.9 },
            // Pop variations
            "pop": { secondary: "happy", blendRatio: 0.7 },
            "indie-pop": { secondary: "happy", blendRatio: 0.6 }
          };
          const normalizedGenre = genre.toLowerCase().replace(/[\s-_]/g, "-");
          return genreMap[normalizedGenre] || null;
        }
        /**
         * Determine energy-valence quadrant for debugging
         */
        getEnergyValenceQuadrant(energy, valence) {
          if (energy >= 0.5 && valence >= 0.5) return "High Energy + Positive";
          if (energy >= 0.5 && valence < 0.5) return "High Energy + Negative";
          if (energy < 0.5 && valence >= 0.5) return "Low Energy + Positive";
          return "Low Energy + Negative";
        }
        /**
         * Generate CSS variables for emotional temperature integration with OKLAB enhancement
         */
        generateEmotionalCSSVariables(primary, secondary, intensity, temperature, blendRatio, oklabResult, perceptualColorHex) {
          const cssVars = {};
          cssVars["--organic-current-emotion"] = primary;
          cssVars["--organic-emotional-intensity"] = intensity.toString();
          cssVars["--organic-current-temperature"] = temperature.toString();
          cssVars["--organic-emotion-primary"] = primary;
          if (secondary) {
            cssVars["--organic-emotion-secondary"] = secondary;
            cssVars["--organic-emotion-blend-ratio"] = blendRatio.toString();
          }
          cssVars["--organic-emotional-saturation"] = Math.max(0.5, intensity).toString();
          cssVars["--organic-cinematic-contrast"] = Math.max(0.8, intensity * 1.2).toString();
          cssVars["--organic-warmth"] = this.calculateWarmth(temperature).toString();
          const breathingSpeed = this.calculateBreathingSpeed(primary, intensity);
          cssVars["--organic-breathing-cycle"] = `${breathingSpeed}s`;
          const temperatureFilters = this.calculateTemperatureFilters(temperature, intensity);
          Object.assign(cssVars, temperatureFilters);
          if (oklabResult && perceptualColorHex) {
            cssVars["--organic-emotion-oklab-hex"] = perceptualColorHex;
            cssVars["--organic-emotion-oklab-rgb"] = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            cssVars["--organic-emotion-oklab-l"] = oklabResult.oklabEnhanced.L.toFixed(3);
            cssVars["--organic-emotion-oklab-a"] = oklabResult.oklabEnhanced.a.toFixed(3);
            cssVars["--organic-emotion-oklab-b"] = oklabResult.oklabEnhanced.b.toFixed(3);
            cssVars["--organic-emotion-oklch-l"] = oklabResult.oklchEnhanced.L.toFixed(3);
            cssVars["--organic-emotion-oklch-c"] = oklabResult.oklchEnhanced.C.toFixed(3);
            cssVars["--organic-emotion-oklch-h"] = oklabResult.oklchEnhanced.H.toFixed(1);
            cssVars["--organic-emotion-oklab-shadow-hex"] = oklabResult.shadowHex;
            cssVars["--organic-emotion-oklab-shadow-rgb"] = `${oklabResult.shadowRgb.r},${oklabResult.shadowRgb.g},${oklabResult.shadowRgb.b}`;
            cssVars["--organic-perceptual-emotion-color"] = perceptualColorHex;
            cssVars["--organic-perceptual-emotion-rgb"] = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            if (this.enableDebug) {
              console.log("\u{1F3A8} [EmotionalTemperatureMapper] Generated OKLAB CSS variables:", {
                emotion: primary,
                perceptualColor: perceptualColorHex,
                oklabCoords: oklabResult.oklabEnhanced,
                oklchCoords: oklabResult.oklchEnhanced
              });
            }
          }
          return cssVars;
        }
        /**
         * Calculate warmth factor based on temperature (0-1)
         */
        calculateWarmth(temperature) {
          if (temperature <= 4e3) {
            return 0.7 + (4e3 - temperature) / (4e3 - 1800) * 0.3;
          } else if (temperature >= 7e3) {
            return Math.max(0.2, 0.7 - (temperature - 7e3) / (15e3 - 7e3) * 0.5);
          } else {
            return 0.5 + (7e3 - temperature) / (7e3 - 4e3) * 0.2;
          }
        }
        /**
         * Calculate breathing animation speed based on emotion and intensity
         */
        calculateBreathingSpeed(emotion, intensity) {
          const baseSpeed = {
            calm: 6,
            melancholy: 8,
            energetic: 2,
            aggressive: 1.5,
            happy: 3,
            romantic: 5,
            mysterious: 7,
            epic: 2.5,
            ambient: 10
          };
          const base = baseSpeed[emotion];
          const intensityFactor = Math.max(0.5, Math.min(2, 2 - intensity));
          return base * intensityFactor;
        }
        /**
         * Calculate temperature-based CSS filter adjustments
         */
        calculateTemperatureFilters(temperature, intensity) {
          const filters = {};
          const hueRotation = this.mapTemperatureToHue(temperature);
          filters["--organic-temperature-hue-shift"] = `${hueRotation}deg`;
          const saturation = Math.max(0.8, Math.min(1.5, 1 + (intensity - 0.5) * 0.4));
          filters["--organic-temperature-saturation"] = saturation.toString();
          const brightness = this.mapTemperatureToBrightness(temperature);
          filters["--organic-temperature-brightness"] = brightness.toString();
          return filters;
        }
        /**
         * Map temperature to hue rotation (-30 to +30 degrees)
         */
        mapTemperatureToHue(temperature) {
          if (temperature <= 4e3) {
            return -15 + (4e3 - temperature) / (4e3 - 2e3) * -15;
          } else if (temperature >= 8e3) {
            return 10 + (temperature - 8e3) / (15e3 - 8e3) * 20;
          } else {
            return -5 + (temperature - 4e3) / (8e3 - 4e3) * 15;
          }
        }
        /**
         * Map temperature to brightness adjustment (0.8-1.2)
         */
        mapTemperatureToBrightness(temperature) {
          const normalized = (temperature - 2e3) / (15e3 - 2e3);
          return 0.9 + normalized * 0.3;
        }
        /**
         * Apply emotional temperature to an element via CSS class and variables
         */
        applyEmotionalTemperature(element, result) {
          const existingClasses = Array.from(element.classList).filter(
            (cls) => cls.startsWith("organic-emotion-")
          );
          element.classList.remove(...existingClasses);
          element.classList.add(result.cssClass);
          if (result.secondaryEmotion) {
            element.classList.add(`organic-emotion-blend-${result.secondaryEmotion}`);
          }
          Object.entries(result.cssVariables).forEach(([property, value]) => {
            element.style.setProperty(property, value);
          });
          if (this.enableDebug) {
            console.log("\u{1F3A8} [EmotionalTemperatureMapper] Applied emotional temperature:", {
              element: element.tagName,
              emotion: result.primaryEmotion,
              secondary: result.secondaryEmotion,
              intensity: result.intensity,
              temperature: result.temperature
            });
          }
        }
        /**
         * Get all available emotional states
         */
        static getAvailableEmotions() {
          return Object.keys(EMOTIONAL_TEMPERATURE_MAP);
        }
        /**
         * Get emotion characteristics for a specific state
         */
        static getEmotionCharacteristics(emotion) {
          return EMOTIONAL_TEMPERATURE_MAP[emotion];
        }
      };
      __name(_EmotionalTemperatureMapper, "EmotionalTemperatureMapper");
      EmotionalTemperatureMapper = _EmotionalTemperatureMapper;
    }
  });

  // src-js/utils/color/CatppuccinPalettes.ts
  function color(hex, h, s, l) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return {
      hex,
      rgb: `${r}, ${g}, ${b}`,
      hsl: [h, s, l],
      brightness
    };
  }
  function getBrightnessAdjustedBaseColor(flavor, brightnessMode) {
    const palette = CATPPUCCIN_PALETTES[flavor];
    const config = BRIGHTNESS_CONFIGS[brightnessMode];
    switch (brightnessMode) {
      case "bright":
        return flavor === "latte" ? palette.surface1 : palette.surface0;
      case "balanced":
        return flavor === "latte" ? palette.base : palette.surface0;
      case "dark":
        return flavor === "latte" ? palette.mantle : palette.base;
      default:
        return palette.base;
    }
  }
  function getBrightnessAdjustedSurfaceColor(flavor, brightnessMode) {
    const palette = CATPPUCCIN_PALETTES[flavor];
    switch (brightnessMode) {
      case "bright":
        return flavor === "latte" ? palette.surface2 : palette.surface1;
      case "balanced":
        return flavor === "latte" ? palette.surface0 : palette.surface1;
      case "dark":
        return flavor === "latte" ? palette.surface0 : palette.surface0;
      default:
        return palette.surface1;
    }
  }
  function getCatppuccinAccentColor(flavor, accentName) {
    return CATPPUCCIN_PALETTES[flavor][accentName];
  }
  function getDefaultAccentColor(flavor) {
    const palette = CATPPUCCIN_PALETTES[flavor];
    return flavor === "latte" ? palette.blue : palette.mauve;
  }
  var CATPPUCCIN_PALETTES, BRIGHTNESS_CONFIGS;
  var init_CatppuccinPalettes = __esm({
    "src-js/utils/color/CatppuccinPalettes.ts"() {
      "use strict";
      __name(color, "color");
      CATPPUCCIN_PALETTES = {
        mocha: {
          rosewater: color("#f5e0dc", 10, 56, 91),
          flamingo: color("#f2cdcd", 0, 59, 88),
          pink: color("#f5c2e7", 316, 72, 86),
          mauve: color("#cba6f7", 267, 84, 81),
          red: color("#f38ba8", 343, 81, 75),
          maroon: color("#eba0ac", 350, 65, 77),
          peach: color("#fab387", 23, 92, 75),
          yellow: color("#f9e2af", 41, 86, 83),
          green: color("#a6e3a1", 115, 54, 76),
          teal: color("#94e2d5", 174, 57, 73),
          sky: color("#89dceb", 189, 71, 73),
          sapphire: color("#74c7ec", 199, 76, 69),
          blue: color("#89b4fa", 217, 92, 76),
          lavender: color("#b4befe", 232, 97, 85),
          text: color("#cdd6f4", 226, 64, 88),
          subtext1: color("#bac2de", 227, 35, 80),
          subtext0: color("#a6adc8", 228, 24, 72),
          overlay2: color("#9399b2", 228, 17, 64),
          overlay1: color("#7f849c", 230, 13, 55),
          overlay0: color("#6c7086", 231, 11, 47),
          surface2: color("#585b70", 233, 12, 39),
          surface1: color("#45475a", 234, 13, 31),
          surface0: color("#313244", 237, 16, 23),
          base: color("#1e1e2e", 240, 21, 15),
          mantle: color("#181825", 240, 18, 13),
          crust: color("#11111b", 240, 23, 9)
        },
        latte: {
          rosewater: color("#dc8a78", 11, 59, 67),
          flamingo: color("#dd7878", 0, 60, 67),
          pink: color("#ea76cb", 316, 73, 69),
          mauve: color("#8839ef", 266, 85, 58),
          red: color("#d20f39", 347, 87, 44),
          maroon: color("#e64553", 355, 76, 59),
          peach: color("#fe640b", 22, 99, 52),
          yellow: color("#df8e1d", 35, 77, 49),
          green: color("#40a02b", 109, 58, 40),
          teal: color("#179299", 183, 74, 35),
          sky: color("#04a5e5", 197, 97, 46),
          sapphire: color("#209fb5", 189, 70, 42),
          blue: color("#1e66f5", 220, 91, 54),
          lavender: color("#7287fd", 231, 97, 72),
          text: color("#4c4f69", 234, 16, 35),
          subtext1: color("#5c5f77", 233, 13, 41),
          subtext0: color("#6c6f85", 233, 10, 47),
          overlay2: color("#7c7f93", 232, 10, 53),
          overlay1: color("#8c8fa1", 231, 10, 59),
          overlay0: color("#9ca0b0", 228, 11, 65),
          surface2: color("#acb0be", 227, 12, 71),
          surface1: color("#bcc0cc", 226, 14, 77),
          surface0: color("#ccd0da", 225, 16, 83),
          base: color("#eff1f5", 220, 23, 95),
          mantle: color("#e6e9ef", 220, 22, 92),
          crust: color("#dce0e8", 220, 21, 89)
        },
        frappe: {
          rosewater: color("#f2d5cf", 10, 57, 88),
          flamingo: color("#eebebe", 0, 58, 84),
          pink: color("#f4b8e4", 316, 73, 84),
          mauve: color("#ca9ee6", 277, 59, 76),
          red: color("#e78284", 359, 68, 71),
          maroon: color("#ea999c", 358, 56, 76),
          peach: color("#ef9f76", 20, 79, 70),
          yellow: color("#e5c890", 40, 62, 73),
          green: color("#a6d189", 96, 44, 68),
          teal: color("#81c8be", 172, 39, 65),
          sky: color("#99d1db", 189, 48, 73),
          sapphire: color("#85c1dc", 199, 55, 69),
          blue: color("#8caaee", 222, 74, 74),
          lavender: color("#babbf1", 239, 66, 84),
          text: color("#c6d0f5", 227, 70, 87),
          subtext1: color("#b5bfe2", 229, 44, 80),
          subtext0: color("#a5adce", 230, 34, 72),
          overlay2: color("#949cbb", 231, 19, 64),
          overlay1: color("#838ba7", 232, 16, 56),
          overlay0: color("#737994", 232, 13, 49),
          surface2: color("#626880", 233, 16, 42),
          surface1: color("#51576d", 234, 16, 35),
          surface0: color("#414559", 235, 16, 30),
          base: color("#303446", 229, 19, 23),
          mantle: color("#292c3c", 231, 19, 20),
          crust: color("#232634", 229, 20, 17)
        },
        macchiato: {
          rosewater: color("#f4dbd6", 10, 58, 90),
          flamingo: color("#f0c6c6", 0, 58, 86),
          pink: color("#f5bde6", 316, 74, 85),
          mauve: color("#c6a0f6", 267, 83, 79),
          red: color("#ed8796", 351, 74, 73),
          maroon: color("#ee99a0", 357, 70, 77),
          peach: color("#f5a97f", 21, 86, 73),
          yellow: color("#eed49f", 42, 79, 78),
          green: color("#a6da95", 105, 48, 72),
          teal: color("#8bd5ca", 172, 47, 69),
          sky: color("#91d7e3", 189, 59, 73),
          sapphire: color("#7dc4e4", 199, 66, 69),
          blue: color("#8aadf4", 220, 83, 75),
          lavender: color("#b7bdf8", 238, 82, 84),
          text: color("#cad3f5", 227, 68, 88),
          subtext1: color("#b8c0e0", 228, 39, 81),
          subtext0: color("#a5adcb", 227, 27, 72),
          overlay2: color("#939ab7", 228, 20, 64),
          overlay1: color("#8087a2", 230, 15, 56),
          overlay0: color("#6e738d", 230, 12, 48),
          surface2: color("#5b6078", 233, 16, 40),
          surface1: color("#494d64", 234, 15, 33),
          surface0: color("#363a4f", 235, 16, 26),
          base: color("#24273a", 232, 23, 19),
          mantle: color("#1e2030", 233, 23, 16),
          crust: color("#181926", 236, 23, 13)
        }
      };
      BRIGHTNESS_CONFIGS = {
        bright: {
          baseColorTarget: 0.25,
          // Lighter base colors
          surfaceColorTarget: 0.35,
          textContrastMin: 4.5
        },
        balanced: {
          baseColorTarget: 0.15,
          // Standard base colors  
          surfaceColorTarget: 0.25,
          textContrastMin: 4.5
        },
        dark: {
          baseColorTarget: 0.08,
          // Darker base colors
          surfaceColorTarget: 0.15,
          textContrastMin: 3
          // Slightly lower contrast for dark mode comfort
        }
      };
      __name(getBrightnessAdjustedBaseColor, "getBrightnessAdjustedBaseColor");
      __name(getBrightnessAdjustedSurfaceColor, "getBrightnessAdjustedSurfaceColor");
      __name(getCatppuccinAccentColor, "getCatppuccinAccentColor");
      __name(getDefaultAccentColor, "getDefaultAccentColor");
    }
  });

  // src-js/utils/color/Year3000Palettes.ts
  function color2(hex, h, s, l) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return {
      hex,
      rgb: `${r}, ${g}, ${b}`,
      hsl: [h, s, l],
      brightness
    };
  }
  function getBrightnessAdjustedBaseColor2(flavor, brightnessMode) {
    const palette = YEAR3000_PALETTES[flavor];
    const config = BRIGHTNESS_CONFIGS2[brightnessMode];
    switch (brightnessMode) {
      case "bright":
        return palette.surface1;
      case "balanced":
        return palette.surface0;
      case "dark":
        return palette.base;
      default:
        return palette.base;
    }
  }
  function getBrightnessAdjustedSurfaceColor2(flavor, brightnessMode) {
    const palette = YEAR3000_PALETTES[flavor];
    switch (brightnessMode) {
      case "bright":
        return palette.surface2;
      case "balanced":
        return palette.surface1;
      case "dark":
        return palette.surface0;
      default:
        return palette.surface1;
    }
  }
  function getYear3000AccentColor(flavor, accentName) {
    return YEAR3000_PALETTES[flavor][accentName];
  }
  function getDefaultAccentColor2(flavor) {
    const palette = YEAR3000_PALETTES[flavor];
    return palette.mauve;
  }
  function getCinematicGradientPair(flavor, intensity = "medium") {
    const palette = YEAR3000_PALETTES[flavor];
    switch (intensity) {
      case "low":
        return [palette.mauve, palette.blue];
      case "medium":
        return [palette.pink, palette.peach];
      case "high":
        return [palette.red, palette.teal];
      default:
        return [palette.mauve, palette.pink];
    }
  }
  function getAnimatedFlowColors(flavor) {
    const palette = YEAR3000_PALETTES[flavor];
    return {
      primary: palette.mauve,
      // Electric Purple
      secondary: palette.pink,
      // Vivid Magenta
      tertiary: palette.sky,
      // Electric Blue
      atmosphere: palette.base
      // Deep cosmic background
    };
  }
  var YEAR3000_PALETTES, BRIGHTNESS_CONFIGS2;
  var init_Year3000Palettes = __esm({
    "src-js/utils/color/Year3000Palettes.ts"() {
      "use strict";
      __name(color2, "color");
      YEAR3000_PALETTES = {
        // Subtle: Muted cinematic tones for professional environments
        subtle: {
          rosewater: color2("#e8d5d1", 15, 45, 85),
          flamingo: color2("#e5c3c3", 0, 45, 82),
          pink: color2("#d8a8cc", 316, 40, 75),
          mauve: color2("#9d7bc7", 267, 45, 65),
          // Electric Purple (muted)
          red: color2("#c85a7a", 343, 45, 60),
          maroon: color2("#c27882", 350, 35, 65),
          peach: color2("#d18a5f", 23, 50, 60),
          yellow: color2("#d4c285", 41, 45, 70),
          green: color2("#8cc98a", 115, 35, 65),
          teal: color2("#7bc5b8", 174, 35, 65),
          sky: color2("#7ab5c7", 189, 40, 65),
          sapphire: color2("#6baac7", 199, 45, 60),
          blue: color2("#7d9dd4", 217, 50, 65),
          // Electric Blue (muted)
          lavender: color2("#a8aed9", 232, 45, 75),
          text: color2("#c2c8d4", 226, 25, 80),
          subtext1: color2("#b2b8c8", 227, 20, 72),
          subtext0: color2("#9ca4b8", 228, 15, 65),
          overlay2: color2("#868ea8", 228, 12, 58),
          overlay1: color2("#757d95", 230, 10, 52),
          overlay0: color2("#656c82", 231, 8, 45),
          surface2: color2("#555c70", 233, 8, 38),
          surface1: color2("#454c5a", 234, 8, 32),
          surface0: color2("#353a46", 237, 10, 25),
          base: color2("#252832", 240, 12, 17),
          mantle: color2("#1f222a", 240, 10, 15),
          crust: color2("#181b22", 240, 15, 12)
        },
        // Balanced: Moderate cinematic intensity with vibrant gradients
        balanced: {
          rosewater: color2("#f2d8d3", 15, 60, 88),
          flamingo: color2("#eec6c6", 0, 60, 85),
          pink: color2("#e8b3d8", 316, 55, 80),
          mauve: color2("#b388d6", 267, 55, 70),
          // Electric Purple (balanced)
          red: color2("#d16b8a", 343, 55, 65),
          maroon: color2("#d08692", 350, 45, 70),
          peach: color2("#e59a6f", 23, 65, 65),
          yellow: color2("#e0d295", 41, 55, 75),
          green: color2("#9cd49a", 115, 40, 70),
          teal: color2("#8bd0c3", 174, 40, 70),
          sky: color2("#8ac0d2", 189, 50, 70),
          sapphire: color2("#7bb5d2", 199, 55, 65),
          blue: color2("#8da8e0", 217, 60, 70),
          // Electric Blue (balanced)
          lavender: color2("#b8bee5", 232, 55, 80),
          text: color2("#ced4e0", 226, 35, 85),
          subtext1: color2("#bec4d3", 227, 25, 77),
          subtext0: color2("#a8b0c3", 228, 20, 70),
          overlay2: color2("#929ab3", 228, 15, 63),
          overlay1: color2("#8289a0", 230, 12, 57),
          overlay0: color2("#72798f", 231, 10, 50),
          surface2: color2("#62697d", 233, 10, 43),
          surface1: color2("#525968", 234, 10, 37),
          surface0: color2("#424954", 237, 12, 30),
          base: color2("#2f323e", 240, 15, 22),
          mantle: color2("#282b36", 240, 12, 19),
          crust: color2("#21242e", 240, 18, 16)
        },
        // Cinematic: Full intensity Year 3000 gradients with dramatic contrast
        cinematic: {
          rosewater: color2("#fce0db", 15, 85, 92),
          flamingo: color2("#f5c9c9", 0, 85, 88),
          pink: color2("#ff6b9d", 316, 100, 70),
          // Vivid Magenta (from visual guide)
          mauve: color2("#6c5ce7", 267, 85, 65),
          // Electric Purple (from visual guide)
          red: color2("#ff4757", 343, 100, 65),
          // Cosmic Red (from visual guide)
          maroon: color2("#e84393", 350, 80, 70),
          peach: color2("#fd7f28", 23, 95, 58),
          // Luminous Orange (from visual guide)
          yellow: color2("#f39c12", 41, 88, 52),
          green: color2("#a6e3a1", 115, 54, 76),
          teal: color2("#00cec9", 174, 100, 40),
          // Neon Cyan (from visual guide)
          sky: color2("#74b9ff", 189, 100, 72),
          // Electric Blue (from visual guide)
          sapphire: color2("#0984e3", 199, 100, 46),
          blue: color2("#a29bfe", 217, 95, 80),
          lavender: color2("#c77dff", 232, 100, 75),
          text: color2("#e8f0ff", 226, 100, 95),
          subtext1: color2("#d0d8f0", 227, 65, 88),
          subtext0: color2("#b8c0d8", 228, 45, 80),
          overlay2: color2("#a0a8c0", 228, 30, 70),
          overlay1: color2("#8890a8", 230, 20, 60),
          overlay0: color2("#707890", 231, 15, 50),
          surface2: color2("#586078", 233, 15, 42),
          surface1: color2("#485060", 234, 15, 35),
          surface0: color2("#384048", 237, 18, 28),
          base: color2("#202030", 240, 25, 16),
          mantle: color2("#181828", 240, 22, 13),
          crust: color2("#101020", 240, 30, 9)
        },
        // Maximum: Ultra-intense Year 3000 with maximum saturation and contrast
        maximum: {
          rosewater: color2("#ffe5e0", 15, 100, 95),
          flamingo: color2("#ffcccc", 0, 100, 90),
          pink: color2("#ff3d7f", 316, 100, 62),
          // Maximum Vivid Magenta
          mauve: color2("#5a4fcf", 267, 100, 55),
          // Maximum Electric Purple
          red: color2("#ff2942", 343, 100, 58),
          // Maximum Cosmic Red
          maroon: color2("#e6337a", 350, 90, 65),
          peach: color2("#ff6500", 23, 100, 50),
          // Maximum Luminous Orange
          yellow: color2("#f1c40f", 48, 89, 50),
          green: color2("#00ff88", 150, 100, 50),
          teal: color2("#00ffff", 180, 100, 50),
          // Maximum Neon Cyan
          sky: color2("#4da6ff", 189, 100, 65),
          // Maximum Electric Blue
          sapphire: color2("#0066ff", 199, 100, 50),
          blue: color2("#8a7fff", 217, 100, 75),
          lavender: color2("#b347ff", 232, 100, 65),
          text: color2("#ffffff", 0, 0, 100),
          subtext1: color2("#e8e8ff", 240, 100, 95),
          subtext0: color2("#d0d0ff", 240, 100, 90),
          overlay2: color2("#b8b8ff", 240, 100, 85),
          overlay1: color2("#a0a0ff", 240, 100, 80),
          overlay0: color2("#8888ff", 240, 100, 75),
          surface2: color2("#4040aa", 240, 60, 45),
          surface1: color2("#303088", 240, 65, 35),
          surface0: color2("#202066", 240, 70, 25),
          base: color2("#0f0f33", 240, 70, 13),
          mantle: color2("#0a0a22", 240, 75, 10),
          crust: color2("#050511", 240, 80, 5)
        }
      };
      BRIGHTNESS_CONFIGS2 = {
        bright: {
          baseColorTarget: 0.25,
          // Lighter base colors
          surfaceColorTarget: 0.35,
          textContrastMin: 4.5
        },
        balanced: {
          baseColorTarget: 0.15,
          // Standard base colors  
          surfaceColorTarget: 0.25,
          textContrastMin: 4.5
        },
        dark: {
          baseColorTarget: 0.08,
          // Darker base colors
          surfaceColorTarget: 0.15,
          textContrastMin: 3
          // Slightly lower contrast for dark mode comfort
        }
      };
      __name(getBrightnessAdjustedBaseColor2, "getBrightnessAdjustedBaseColor");
      __name(getBrightnessAdjustedSurfaceColor2, "getBrightnessAdjustedSurfaceColor");
      __name(getYear3000AccentColor, "getYear3000AccentColor");
      __name(getDefaultAccentColor2, "getDefaultAccentColor");
      __name(getCinematicGradientPair, "getCinematicGradientPair");
      __name(getAnimatedFlowColors, "getAnimatedFlowColors");
    }
  });

  // src-js/utils/color/PaletteSystemManager.ts
  function getBrightnessAdjustedBaseColor3(flavor, brightnessMode = "balanced") {
    return paletteSystemManager.getBrightnessAdjustedBaseColor(flavor, brightnessMode);
  }
  function getBrightnessAdjustedSurfaceColor3(flavor, brightnessMode = "balanced") {
    return paletteSystemManager.getBrightnessAdjustedSurfaceColor(flavor, brightnessMode);
  }
  function getDefaultAccentColor3(flavor) {
    return paletteSystemManager.getDefaultAccentColor(flavor);
  }
  function getAccentColor(accentName, flavor) {
    return paletteSystemManager.getAccentColor(accentName, flavor);
  }
  var _PaletteSystemManager, PaletteSystemManager, paletteSystemManager;
  var init_PaletteSystemManager = __esm({
    "src-js/utils/color/PaletteSystemManager.ts"() {
      "use strict";
      init_globalConfig();
      init_CatppuccinPalettes();
      init_Year3000Palettes();
      init_CatppuccinPalettes();
      init_Year3000Palettes();
      _PaletteSystemManager = class _PaletteSystemManager {
        constructor() {
        }
        static getInstance() {
          if (!_PaletteSystemManager.instance) {
            _PaletteSystemManager.instance = new _PaletteSystemManager();
          }
          return _PaletteSystemManager.instance;
        }
        /**
         * Get the currently active palette system from configuration
         */
        getCurrentPaletteSystem() {
          return YEAR3000_CONFIG.paletteSystem || "catppuccin";
        }
        /**
         * Get the current active palette based on configuration
         */
        getCurrentPalette() {
          const system = this.getCurrentPaletteSystem();
          return system === "year3000" ? YEAR3000_PALETTES : CATPPUCCIN_PALETTES;
        }
        /**
         * Get the current default flavor for the active palette system
         */
        getCurrentDefaultFlavor() {
          const system = this.getCurrentPaletteSystem();
          return system === "year3000" ? "balanced" : "mocha";
        }
        /**
         * Get brightness-adjusted base color from current palette system
         */
        getBrightnessAdjustedBaseColor(flavor, brightnessMode = "balanced") {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getBrightnessAdjustedBaseColor2(
              activeFlavor,
              brightnessMode
            );
          } else {
            return getBrightnessAdjustedBaseColor(
              activeFlavor,
              brightnessMode
            );
          }
        }
        /**
         * Get brightness-adjusted surface color from current palette system
         */
        getBrightnessAdjustedSurfaceColor(flavor, brightnessMode = "balanced") {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getBrightnessAdjustedSurfaceColor2(
              activeFlavor,
              brightnessMode
            );
          } else {
            return getBrightnessAdjustedSurfaceColor(
              activeFlavor,
              brightnessMode
            );
          }
        }
        /**
         * Get default accent color from current palette system
         */
        getDefaultAccentColor(flavor) {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getDefaultAccentColor2(activeFlavor);
          } else {
            return getDefaultAccentColor(activeFlavor);
          }
        }
        /**
         * Get specific accent color from current palette system
         */
        getAccentColor(accentName, flavor) {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getYear3000AccentColor(
              activeFlavor,
              accentName
            );
          } else {
            return getCatppuccinAccentColor(
              activeFlavor,
              accentName
            );
          }
        }
        /**
         * Get cinematic gradient colors (Year 3000 specific, fallback for Catppuccin)
         */
        getCinematicGradientPair(flavor, intensity = "medium") {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getCinematicGradientPair(
              activeFlavor,
              intensity
            );
          } else {
            const palette = CATPPUCCIN_PALETTES[activeFlavor];
            switch (intensity) {
              case "low":
                return [palette.mauve, palette.blue];
              case "medium":
                return [palette.pink, palette.peach];
              case "high":
                return [palette.red, palette.teal];
              default:
                return [palette.mauve, palette.pink];
            }
          }
        }
        /**
         * Get organic flow colors (Year 3000 specific, fallback for Catppuccin)
         */
        getAnimatedFlowColors(flavor) {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getAnimatedFlowColors(activeFlavor);
          } else {
            const palette = CATPPUCCIN_PALETTES[activeFlavor];
            return {
              primary: palette.mauve,
              secondary: palette.pink,
              tertiary: palette.blue,
              atmosphere: palette.base
            };
          }
        }
        /**
         * Check if current palette system supports cinematic features
         */
        supportsCinematicFeatures() {
          return this.getCurrentPaletteSystem() === "year3000";
        }
        /**
         * Get palette system display name for UI
         */
        getPaletteSystemDisplayName() {
          const system = this.getCurrentPaletteSystem();
          return system === "year3000" ? "Year 3000 Cinematic" : "Catppuccin Classic";
        }
      };
      __name(_PaletteSystemManager, "PaletteSystemManager");
      PaletteSystemManager = _PaletteSystemManager;
      paletteSystemManager = PaletteSystemManager.getInstance();
      __name(getBrightnessAdjustedBaseColor3, "getBrightnessAdjustedBaseColor");
      __name(getBrightnessAdjustedSurfaceColor3, "getBrightnessAdjustedSurfaceColor");
      __name(getDefaultAccentColor3, "getDefaultAccentColor");
      __name(getAccentColor, "getAccentColor");
    }
  });

  // src-js/utils/core/PaletteExtensionManager.ts
  var GENRE_PALETTE_HINTS, _PaletteExtensionManager, PaletteExtensionManager;
  var init_PaletteExtensionManager = __esm({
    "src-js/utils/core/PaletteExtensionManager.ts"() {
      "use strict";
      GENRE_PALETTE_HINTS = {
        jazz: { temperatureShift: 15, saturationBoost: 1.1, warmth: 0.8 },
        electronic: { temperatureShift: -10, saturationBoost: 1.2, warmth: 0.2 },
        classical: { temperatureShift: 5, saturationBoost: 0.9, warmth: 0.6 },
        rock: { temperatureShift: 0, saturationBoost: 1.15, warmth: 0.5 },
        ambient: { temperatureShift: -5, saturationBoost: 0.8, warmth: 0.3 },
        hiphop: { temperatureShift: 8, saturationBoost: 1.25, warmth: 0.7 },
        pop: { temperatureShift: 0, saturationBoost: 1, warmth: 0.5 },
        metal: { temperatureShift: -15, saturationBoost: 1.3, warmth: 0.1 },
        indie: { temperatureShift: 10, saturationBoost: 0.95, warmth: 0.6 },
        default: { temperatureShift: 0, saturationBoost: 1, warmth: 0.5 }
      };
      _PaletteExtensionManager = class _PaletteExtensionManager {
        constructor(config, utils) {
          this.paletteCache = {};
          this.cacheTTL = 3e5;
          // 5 minutes
          this.maxCacheSize = 50;
          this.config = config;
          this.utils = utils;
        }
        // TODO: Phase 3 - Load custom palette from JSON with validation
        async loadCustomPalette(paletteId, source) {
          const cached = this.paletteCache[paletteId];
          if (cached && Date.now() - cached.timestamp < this.cacheTTL && cached.isValid) {
            if (this.config.enableDebug) {
              console.log(
                `[PaletteExtensionManager] Cache hit for palette: ${paletteId}`
              );
            }
            return cached.palette;
          }
          try {
            const fallbackPalette = this.generateFallbackPalette(paletteId);
            if (this.validatePalette(fallbackPalette)) {
              this.cachePalette(paletteId, fallbackPalette, true);
              return fallbackPalette;
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[PaletteExtensionManager] Failed to load palette ${paletteId}:`,
                error
              );
            }
          }
          return null;
        }
        // TODO: Phase 3 - Generate fallback palette for unknown themes
        generateFallbackPalette(themeName) {
          const root = this.utils.getRootStyle();
          const computedStyle = getComputedStyle(root);
          const baseColor = computedStyle.getPropertyValue("--spice-main").trim() || computedStyle.getPropertyValue("--spice-base").trim() || "#1e1e2e";
          const accentColor = (
            // Prefer Year 3000 dynamic accent if it's already available, else fall back to spice button, then to dynamic accent fallback.
            computedStyle.getPropertyValue("--sn-gradient-accent").trim() || computedStyle.getPropertyValue("--spice-button").trim() || computedStyle.getPropertyValue("--sn-dynamic-accent").trim() || computedStyle.getPropertyValue("--spice-accent").trim() || "#8caaee"
          );
          const baseRgb = this.utils.hexToRgb(
            baseColor.startsWith("#") ? baseColor : `#${baseColor}`
          );
          const accentRgb = this.utils.hexToRgb(
            accentColor.startsWith("#") ? accentColor : `#${accentColor}`
          );
          if (!baseRgb || !accentRgb) {
            const dynamicAccent = computedStyle.getPropertyValue("--sn-dynamic-accent").trim();
            const dynamicBase = computedStyle.getPropertyValue("--spice-base").trim();
            return {
              name: themeName,
              version: "1.0.0",
              accents: {
                mauve: dynamicAccent || "#ca9ee6",
                pink: "#f4b8e4",
                blue: dynamicAccent || "#8caaee",
                sapphire: "#85c1dc",
                sky: "#99d1db",
                teal: "#81c8be",
                green: "#a6d189",
                yellow: "#e5c890",
                peach: "#ef9f76",
                red: "#e78284",
                lavender: "#babbf1"
              },
              neutrals: {
                base: dynamicBase || "#1e1e2e",
                surface0: "#313244",
                surface1: "#45475a",
                surface2: "#585b70",
                overlay0: "#6c7086",
                overlay1: "#7f849c",
                overlay2: "#9399b2",
                text: "#cdd6f4"
              },
              metadata: {
                author: "PaletteExtensionManager",
                description: `Generated fallback for ${themeName}`,
                temperature: "neutral"
              }
            };
          }
          const baseHsl = this.utils.rgbToHsl(baseRgb.r, baseRgb.g, baseRgb.b);
          const accentHsl = this.utils.rgbToHsl(
            accentRgb.r,
            accentRgb.g,
            accentRgb.b
          );
          return {
            name: themeName,
            version: "1.0.0",
            accents: this.generateAccentVariations(accentHsl),
            neutrals: this.generateNeutralVariations(baseHsl),
            metadata: {
              author: "PaletteExtensionManager",
              description: `Generated palette for ${themeName}`,
              temperature: this.detectTemperature(baseHsl, accentHsl)
            }
          };
        }
        // TODO: Phase 3 - Apply genre-aware modifications to palette
        applyGenreAwareModifications(palette, genre) {
          const genreHints = GENRE_PALETTE_HINTS[genre] || GENRE_PALETTE_HINTS.default;
          if (this.config.enableDebug) {
            console.log(
              `[PaletteExtensionManager] Applying ${genre} hints to palette:`,
              genreHints
            );
          }
          const modifiedPalette = {
            ...palette,
            accents: {},
            neutrals: {},
            metadata: {
              ...palette.metadata,
              genre: [...palette.metadata?.genre || [], genre]
            }
          };
          for (const [key, color3] of Object.entries(palette.accents)) {
            modifiedPalette.accents[key] = this.applyGenreColorModification(
              color3,
              genreHints.temperatureShift,
              genreHints.saturationBoost
            );
          }
          for (const [key, color3] of Object.entries(palette.neutrals)) {
            modifiedPalette.neutrals[key] = this.applyGenreColorModification(
              color3,
              genreHints.temperatureShift * 0.3,
              // Less intense for neutrals
              genreHints.saturationBoost * 0.7
            );
          }
          return modifiedPalette;
        }
        // TODO: Phase 3 - Validate palette structure and required properties
        validatePalette(palette) {
          if (!palette || typeof palette !== "object") return false;
          if (!palette.name || typeof palette.name !== "string") return false;
          if (!palette.version || typeof palette.version !== "string") return false;
          if (!palette.accents || typeof palette.accents !== "object") return false;
          if (!palette.neutrals || typeof palette.neutrals !== "object") return false;
          const allColors = [
            ...Object.values(palette.accents),
            ...Object.values(palette.neutrals)
          ];
          for (const color3 of allColors) {
            if (typeof color3 !== "string" || !this.isValidHexColor(color3)) {
              return false;
            }
          }
          return true;
        }
        // TODO: Phase 3 - Cache management
        cachePalette(paletteId, palette, isValid) {
          if (Object.keys(this.paletteCache).length >= this.maxCacheSize) {
            const oldestEntry = Object.entries(this.paletteCache).sort(
              ([, aVal], [, bVal]) => aVal.timestamp - bVal.timestamp
            )[0];
            const oldestKey = oldestEntry?.[0];
            if (oldestKey && this.paletteCache[oldestKey]) {
              delete this.paletteCache[oldestKey];
            }
          }
          this.paletteCache[paletteId] = {
            palette,
            timestamp: Date.now(),
            isValid
          };
        }
        // TODO: Phase 3 - Generate accent color variations
        generateAccentVariations(baseHsl) {
          const variations = {};
          const hueShifts = [0, 30, 60, 120, 180, 210, 240, 300, 330, 45, 90];
          const names = [
            "primary",
            "secondary",
            "tertiary",
            "complement",
            "opposite",
            "warm1",
            "cool1",
            "accent1",
            "accent2",
            "highlight",
            "emphasis"
          ];
          hueShifts.forEach((shift, index) => {
            const name = names[index] || `variant${index}`;
            const adjustedHue = (baseHsl.h + shift) % 360;
            const rgb = this.utils.hslToRgb(adjustedHue, baseHsl.s, baseHsl.l);
            if (rgb) {
              variations[name] = this.utils.rgbToHex(rgb.r, rgb.g, rgb.b);
            }
          });
          return variations;
        }
        // TODO: Phase 3 - Generate neutral color variations
        generateNeutralVariations(baseHsl) {
          const neutrals = {};
          const lightnessLevels = [
            { name: "base", l: baseHsl.l },
            { name: "surface0", l: Math.min(95, baseHsl.l + 10) },
            { name: "surface1", l: Math.min(90, baseHsl.l + 20) },
            { name: "surface2", l: Math.min(85, baseHsl.l + 30) },
            { name: "overlay0", l: Math.min(80, baseHsl.l + 40) },
            { name: "overlay1", l: Math.min(75, baseHsl.l + 50) },
            { name: "text", l: Math.min(95, baseHsl.l + 60) }
          ];
          lightnessLevels.forEach((level) => {
            const rgb = this.utils.hslToRgb(
              baseHsl.h,
              Math.max(0, baseHsl.s - 20),
              level.l
            );
            if (rgb) {
              neutrals[level.name] = this.utils.rgbToHex(rgb.r, rgb.g, rgb.b);
            }
          });
          return neutrals;
        }
        // TODO: Phase 3 - Detect color temperature
        detectTemperature(baseHsl, accentHsl) {
          const avgHue = (baseHsl.h + accentHsl.h) / 2;
          if (avgHue >= 0 && avgHue <= 60 || avgHue >= 300 && avgHue <= 360) {
            return "warm";
          } else if (avgHue >= 120 && avgHue <= 240) {
            return "cool";
          } else {
            return "neutral";
          }
        }
        // TODO: Phase 3 - Apply genre-specific color modifications
        applyGenreColorModification(hexColor, temperatureShift, saturationBoost) {
          const rgb = this.utils.hexToRgb(hexColor);
          if (!rgb) return hexColor;
          const hsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
          const adjustedHue = (hsl.h + temperatureShift + 360) % 360;
          const adjustedSaturation = Math.max(
            0,
            Math.min(100, hsl.s * saturationBoost)
          );
          const modifiedRgb = this.utils.hslToRgb(
            adjustedHue,
            adjustedSaturation,
            hsl.l
          );
          if (modifiedRgb) {
            return this.utils.rgbToHex(modifiedRgb.r, modifiedRgb.g, modifiedRgb.b);
          }
          return hexColor;
        }
        // TODO: Phase 3 - Validate hex color format
        isValidHexColor(color3) {
          return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color3);
        }
        // TODO: Phase 3 - Public API for getting genre hints
        getGenreHints(genre) {
          return GENRE_PALETTE_HINTS[genre] || GENRE_PALETTE_HINTS.default;
        }
        // TODO: Phase 3 - Clear cache
        clearCache() {
          this.paletteCache = {};
          if (this.config.enableDebug) {
            console.log("[PaletteExtensionManager] Palette cache cleared");
          }
        }
      };
      __name(_PaletteExtensionManager, "PaletteExtensionManager");
      PaletteExtensionManager = _PaletteExtensionManager;
    }
  });

  // src-js/core/css/UnifiedCSSVariableManager.ts
  var CRITICAL_NOW_PLAYING_VARS, _UnifiedCSSVariableManager, UnifiedCSSVariableManager;
  var init_UnifiedCSSVariableManager = __esm({
    "src-js/core/css/UnifiedCSSVariableManager.ts"() {
      "use strict";
      init_UnifiedEventBus();
      CRITICAL_NOW_PLAYING_VARS = /* @__PURE__ */ new Set([
        // Legacy variables (Phase 1 migration)
        "--sn-beat-pulse-intensity",
        "--sn-breathing-scale",
        "--sn-accent-hex",
        "--sn-accent-rgb",
        // New namespaced variables (Phase 2+)
        "--sn.music.beat.pulse.intensity",
        "--sn.music.breathing.scale",
        "--sn.music.rhythm.phase",
        "--sn.music.spectrum.phase",
        "--sn.color.accent.hex",
        "--sn.color.accent.rgb",
        "--sn.bg.webgl.ready",
        "--sn.bg.active-backend"
      ]);
      _UnifiedCSSVariableManager = class _UnifiedCSSVariableManager {
        constructor(config, performanceCoordinator) {
          this.initialized = false;
          // === BATCHING LAYER (from UnifiedCSSVariableManager) ===
          this.cssVariableQueue = /* @__PURE__ */ new Map();
          this.batchUpdateTimer = null;
          this.rafHandle = null;
          this.microtaskScheduled = false;
          // === MANAGEMENT LAYER (from UnifiedCSSVariableManager) ===
          this.pendingTransactions = /* @__PURE__ */ new Map();
          this.transactionCounter = 0;
          this.updateQueue = /* @__PURE__ */ new Map();
          this.flushTimer = null;
          // === PERFORMANCE LAYER (from UnifiedCSSVariableManager) ===
          this.currentDeviceCapabilities = null;
          this.currentPerformanceMode = null;
          this.lastCSSUpdate = 0;
          this.cssUpdateThrottle = 100;
          // Update CSS at most every 100ms
          this.appliedClasses = /* @__PURE__ */ new Set();
          // === CONSCIOUSNESS LAYER (new integration) ===
          this.consciousnessState = null;
          this.consciousnessUpdateTimer = null;
          this.lastConsciousnessUpdate = 0;
          // Performance tracking
          this.performanceMetrics = {
            totalBatches: 0,
            totalUpdates: 0,
            totalBatchTime: 0,
            maxBatchTime: 0,
            averageBatchSize: 0,
            overBudgetBatches: 0,
            conflictResolutions: 0,
            transactionCount: 0,
            consciousnessUpdates: 0
          };
          // Priority weights for conflict resolution
          this.PRIORITY_WEIGHTS = {
            low: 1,
            normal: 2,
            high: 3,
            critical: 4
          };
          this.config = config;
          this.performanceCoordinator = performanceCoordinator;
          this.eventBus = unifiedEventBus;
          this.cssConfig = {
            // Batching configuration
            batchIntervalMs: 0,
            // 0 = coalesced; scheduling handled via rAF/microtask
            maxBatchSize: 50,
            enableDebug: config.enableDebug,
            useCssTextFastPath: false,
            autoHijack: true,
            // Performance configuration
            enableAdaptiveOptimization: true,
            enableThermalThrottling: true,
            enableBatteryOptimization: true,
            enableDeviceTierOptimization: true,
            debugPerformanceClasses: config.enableDebug,
            // Consciousness configuration
            enableConsciousnessIntegration: true,
            consciousnessUpdateInterval: 16,
            // 60fps
            enableMusicConsciousness: true,
            enableAestheticConsciousness: true
          };
          this.currentDeviceCapabilities = this.performanceCoordinator.getDeviceCapabilities();
          this.currentPerformanceMode = this.performanceCoordinator.getCurrentPerformanceMode();
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSVariableManager] Created with consciousness-driven CSS management"
            );
          }
        }
        // Deprecated getInstance() method removed - use dependency injection through SystemCoordinator
        // or getGlobalOptimizedCSSController() for simple utility usage
        // ===================================================================
        // IMANAGEDYSTEM INTERFACE IMPLEMENTATION
        // ===================================================================
        async initialize() {
          if (this.initialized) return;
          this.subscribeToEvents();
          this.applyInitialOptimizations();
          if (this.cssConfig.enableConsciousnessIntegration) {
            this.startConsciousnessIntegration();
          }
          if (this.cssConfig.autoHijack) {
            this.enableGlobalHijack();
          }
          this.initialized = true;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSVariableManager] Initialized with device tier:",
              this.currentDeviceCapabilities?.performanceTier
            );
          }
        }
        updateAnimation(deltaTime) {
        }
        async healthCheck() {
          const queueSize = this.cssVariableQueue.size + this.updateQueue.size;
          const pendingTransactions = this.pendingTransactions.size;
          const isHealthy = queueSize <= 1e3 && pendingTransactions <= 100;
          return {
            system: "UnifiedCSSVariableManager",
            healthy: isHealthy,
            ok: isHealthy,
            details: isHealthy ? "CSS consciousness controller operating normally" : "High queue size or pending transactions",
            metrics: {
              queueSize,
              pendingTransactions,
              performanceMetrics: this.performanceMetrics,
              consciousnessActive: this.consciousnessState !== null,
              deviceTier: this.currentDeviceCapabilities?.performanceTier,
              performanceMode: this.currentPerformanceMode?.name
            }
          };
        }
        destroy() {
          if (this.consciousnessUpdateTimer) {
            clearTimeout(this.consciousnessUpdateTimer);
            this.consciousnessUpdateTimer = null;
          }
          if (this.flushTimer) {
            clearTimeout(this.flushTimer);
            this.flushTimer = null;
          }
          if (this.rafHandle !== null) {
            cancelAnimationFrame(this.rafHandle);
            this.rafHandle = null;
          }
          this.flushCSSVariableBatch();
          for (const className of this.appliedClasses) {
            document.body.classList.remove(className);
          }
          this.appliedClasses.clear();
          this.cssVariableQueue.clear();
          this.updateQueue.clear();
          this.pendingTransactions.clear();
          this.initialized = false;
          if (this.config.enableDebug) {
            console.log("\u{1F30C} [UnifiedCSSVariableManager] Destroyed");
          }
        }
        forceRepaint(reason) {
          this.flushCSSVariableBatch();
          if (this.config.enableDebug && reason) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Force repaint: ${reason}`
            );
          }
        }
        // ===================================================================
        // PUBLIC API - UNIFIED CSS VARIABLE OPERATIONS
        // ===================================================================
        /**
         * Queue a CSS variable update with priority and consciousness awareness
         */
        queueCSSVariableUpdate(property, value, element = null, priority = "normal", source = "unknown") {
          if (CRITICAL_NOW_PLAYING_VARS.has(property)) {
            const styleDecl = (element || document.documentElement).style;
            if (_UnifiedCSSVariableManager.nativeSetProperty) {
              _UnifiedCSSVariableManager.nativeSetProperty.call(
                styleDecl,
                property,
                value
              );
            } else {
              styleDecl.setProperty(property, value);
            }
            return;
          }
          const target = element || document.documentElement;
          const elementKey = element ? `element_${element.id || element.className || "unnamed"}` : "root";
          const updateKey = `${elementKey}:${property}`;
          const update = {
            element: target,
            property,
            value,
            timestamp: performance.now(),
            priority,
            source
          };
          const existingUpdate = this.cssVariableQueue.get(updateKey);
          if (existingUpdate) {
            if (this.shouldReplaceUpdate(existingUpdate, update)) {
              this.cssVariableQueue.set(updateKey, update);
              this.performanceMetrics.conflictResolutions++;
            }
          } else {
            this.cssVariableQueue.set(updateKey, update);
          }
          this.performanceMetrics.totalUpdates++;
          this.scheduleFlush(priority);
          if (priority === "critical" || this.cssVariableQueue.size >= this.cssConfig.maxBatchSize) {
            this.flushCSSVariableBatch();
          }
        }
        /**
         * Update multiple CSS variables in a transaction
         */
        updateVariables(variables, priority = "normal", source = "unknown") {
          const transactionId = `tx_${++this.transactionCounter}`;
          const variableMap = new Map(Object.entries(variables));
          const transaction = {
            id: transactionId,
            variables: variableMap,
            timestamp: performance.now(),
            priority,
            completed: false
          };
          this.pendingTransactions.set(transactionId, transaction);
          for (const [property, value] of variableMap) {
            this.queueCSSVariableUpdate(
              property,
              value,
              null,
              priority,
              `${source}:${transactionId}`
            );
          }
          this.performanceMetrics.transactionCount++;
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Transaction ${transactionId} queued with ${variableMap.size} variables`
            );
          }
        }
        /**
         * Update consciousness-driven CSS variables
         */
        updateConsciousnessVariables(consciousnessState) {
          if (!this.cssConfig.enableConsciousnessIntegration) return;
          this.consciousnessState = consciousnessState;
          this.performanceMetrics.consciousnessUpdates++;
          const variables = {};
          if (consciousnessState.musicState && this.cssConfig.enableMusicConsciousness) {
            variables["--sn.music.beat.pulse.intensity"] = consciousnessState.musicState.intensity.toString();
            variables["--sn.music.tempo.bpm"] = consciousnessState.musicState.bpm.toString();
            variables["--sn.music.rhythm.phase"] = `${consciousnessState.musicState.rhythmPhase}deg`;
            variables["--sn.music.breathing.scale"] = consciousnessState.musicState.breathingScale.toString();
            variables["--sn.music.energy.level"] = consciousnessState.musicState.energy.toString();
            variables["--sn.music.valence"] = consciousnessState.musicState.valence.toString();
          }
          if (consciousnessState.aestheticState && this.cssConfig.enableAestheticConsciousness) {
            variables["--sn.aesthetic.harmony.level"] = consciousnessState.aestheticState.harmonyLevel.toString();
            variables["--sn.aesthetic.evolution.factor"] = consciousnessState.aestheticState.evolutionFactor.toString();
            variables["--sn.color.temperature"] = consciousnessState.aestheticState.colorTemperature.toString();
          }
          if (consciousnessState.performanceState) {
            variables["--sn.performance.mode"] = consciousnessState.performanceState.mode;
            variables["--sn.device.tier"] = consciousnessState.performanceState.deviceTier;
            variables["--sn.performance.optimization.level"] = consciousnessState.performanceState.optimizationLevel.toString();
          }
          this.updateVariables(variables, "high", "consciousness-system");
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Consciousness state updated with ${Object.keys(variables).length} variables`
            );
          }
        }
        /**
         * Apply performance-based optimizations
         */
        applyPerformanceOptimizations(performanceMode) {
          if (!this.cssConfig.enableAdaptiveOptimization) return;
          this.currentPerformanceMode = performanceMode;
          const variables = {
            "--sn.performance.mode": performanceMode.name,
            "--sn.performance.quality.level": performanceMode.qualityLevel.toString(),
            "--sn.performance.fps.target": performanceMode.frameRate.toString(),
            "--sn.performance.frame.budget": (1e3 / performanceMode.frameRate).toString(),
            "--sn.performance.optimization.level": performanceMode.optimizationLevel.toString(),
            "--sn.performance.blur.quality": performanceMode.blurQuality.toString(),
            "--sn.performance.shadow.quality": performanceMode.shadowQuality.toString(),
            "--sn.performance.animation.quality": performanceMode.animationQuality.toString(),
            "--sn.performance.effect.quality": performanceMode.effectQuality.toString()
          };
          this.updateVariables(variables, "high", "performance-coordinator");
          this.applyPerformanceModeOptimizations();
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Performance optimizations applied for mode: ${performanceMode.name}`
            );
          }
        }
        /**
         * Get a CSS variable value
         */
        getVariable(key) {
          const computedStyle = getComputedStyle(document.documentElement);
          return computedStyle.getPropertyValue(key).trim() || null;
        }
        /**
         * Force immediate flush of all pending updates
         */
        flushUpdates() {
          this.flushCSSVariableBatch();
        }
        /**
         * Optimized CSS variable batch flush with efficient DOM operations
         */
        flushCSSVariableBatch() {
          if (this.cssVariableQueue.size === 0) return;
          const startTime = performance.now();
          const FRAME_BUDGET = 8;
          const updates = Array.from(this.cssVariableQueue.values());
          this.cssVariableQueue.clear();
          if (this.rafHandle !== null) {
            cancelAnimationFrame(this.rafHandle);
            this.rafHandle = null;
          }
          this.microtaskScheduled = false;
          try {
            const updatesByElement = /* @__PURE__ */ new Map();
            for (const update of updates) {
              if (!updatesByElement.has(update.element)) {
                updatesByElement.set(update.element, []);
              }
              updatesByElement.get(update.element).push(update);
            }
            for (const [element, elementUpdates] of updatesByElement.entries()) {
              if (performance.now() - startTime > FRAME_BUDGET) {
                for (const update of elementUpdates) {
                  const updateKey = `${update.element.id || "root"}:${update.property}`;
                  this.cssVariableQueue.set(updateKey, update);
                }
                this.scheduleFlush("high");
                break;
              }
              if (elementUpdates.length >= 3) {
                this.applyCSSTextBatch(element, elementUpdates);
              } else {
                for (const update of elementUpdates) {
                  if (_UnifiedCSSVariableManager.nativeSetProperty) {
                    _UnifiedCSSVariableManager.nativeSetProperty.call(
                      element.style,
                      update.property,
                      update.value
                    );
                  } else {
                    element.style.setProperty(update.property, update.value);
                  }
                }
              }
            }
            const batchTime = performance.now() - startTime;
            this.updatePerformanceMetrics(batchTime, updates.length);
            if (batchTime > FRAME_BUDGET && this.config.enableDebug) {
              console.warn(
                `\u{1F30C} [UnifiedCSSVariableManager] CSS batch exceeded frame budget: ${batchTime.toFixed(
                  2
                )}ms (${updates.length} updates)`
              );
            } else if (this.config.enableDebug && Math.random() < 0.05) {
              console.log(
                `\u{1F30C} [UnifiedCSSVariableManager] Efficient CSS batch: ${updates.length} updates in ${batchTime.toFixed(2)}ms`
              );
            }
          } catch (error) {
            console.error(
              "[UnifiedCSSVariableManager] Error in optimized CSS batch processing:",
              error
            );
            this.applyUpdatesWithFallback(updates);
          }
        }
        /**
         * Optimized cssText batching using efficient string building
         */
        applyCSSTextBatch(element, updates) {
          try {
            const currentStyle = element.style.cssText;
            const propertyMap = /* @__PURE__ */ new Map();
            if (currentStyle) {
              const declarations = currentStyle.split(";");
              for (const declaration of declarations) {
                const colonIndex = declaration.indexOf(":");
                if (colonIndex > 0) {
                  const property = declaration.slice(0, colonIndex).trim();
                  const value = declaration.slice(colonIndex + 1).trim();
                  if (property && value) {
                    propertyMap.set(property, value);
                  }
                }
              }
            }
            for (const update of updates) {
              propertyMap.set(update.property, update.value);
            }
            const cssDeclarations = [];
            for (const [property, value] of propertyMap) {
              cssDeclarations.push(`${property}:${value}`);
            }
            element.style.cssText = cssDeclarations.join(";");
          } catch (error) {
            for (const update of updates) {
              try {
                element.style.setProperty(update.property, update.value);
              } catch (e) {
                console.warn(`Failed to apply ${update.property}:`, e);
              }
            }
          }
        }
        /**
         * Fallback update application with error recovery
         */
        applyUpdatesWithFallback(updates) {
          for (const update of updates) {
            try {
              if (_UnifiedCSSVariableManager.nativeSetProperty) {
                _UnifiedCSSVariableManager.nativeSetProperty.call(
                  update.element.style,
                  update.property,
                  update.value
                );
              } else {
                update.element.style.setProperty(update.property, update.value);
              }
            } catch (e) {
              console.warn(
                `[UnifiedCSSVariableManager] Failed to apply CSS property ${update.property}:`,
                e
              );
            }
          }
        }
        // ===================================================================
        // CONVENIENCE METHODS FOR COMMON CSS UPDATES
        // ===================================================================
        /**
         * Set music synchronization variables
         */
        setMusicMetrics(metrics) {
          const variables = {};
          if (metrics.beatIntensity !== void 0) {
            variables["--sn.music.beat.pulse.intensity"] = metrics.beatIntensity.toString();
          }
          if (metrics.rhythmPhase !== void 0) {
            variables["--sn.music.rhythm.phase"] = `${metrics.rhythmPhase}deg`;
          }
          if (metrics.breathingScale !== void 0) {
            variables["--sn.music.breathing.scale"] = metrics.breathingScale.toString();
          }
          if (metrics.spectrumPhase !== void 0) {
            variables["--sn.music.spectrum.phase"] = `${metrics.spectrumPhase}deg`;
          }
          if (metrics.energy !== void 0) {
            variables["--sn.music.energy.level"] = metrics.energy.toString();
          }
          if (metrics.valence !== void 0) {
            variables["--sn.music.valence"] = metrics.valence.toString();
          }
          if (metrics.bpm !== void 0) {
            variables["--sn.music.tempo.bpm"] = metrics.bpm.toString();
          }
          this.updateVariables(variables, "critical", "music-system");
        }
        /**
         * Set color variables
         */
        setColorTokens(colors) {
          const variables = {};
          if (colors.accentHex) {
            variables["--sn.color.accent.hex"] = colors.accentHex;
          }
          if (colors.accentRgb) {
            variables["--sn.color.accent.rgb"] = colors.accentRgb;
          }
          if (colors.primaryRgb) {
            variables["--sn.bg.gradient.primary.rgb"] = colors.primaryRgb;
          }
          if (colors.secondaryRgb) {
            variables["--sn.bg.gradient.secondary.rgb"] = colors.secondaryRgb;
          }
          if (colors.gradientOpacity !== void 0) {
            variables["--sn.bg.gradient.opacity"] = colors.gradientOpacity.toString();
          }
          if (colors.gradientBlur) {
            variables["--sn.bg.gradient.blur"] = colors.gradientBlur;
          }
          this.updateVariables(variables, "high", "color-system");
        }
        /**
         * Set performance variables
         */
        setPerformanceTokens(perf) {
          const variables = {};
          if (perf.webglReady !== void 0) {
            variables["--sn.bg.webgl.ready"] = perf.webglReady ? "1" : "0";
          }
          if (perf.activeBackend) {
            variables["--sn.bg.active-backend"] = perf.activeBackend;
          }
          if (perf.qualityLevel) {
            variables["--sn.perf.quality.level"] = perf.qualityLevel;
          }
          if (perf.reducedMotion !== void 0) {
            variables["--sn.anim.motion.reduced"] = perf.reducedMotion ? "1" : "0";
          }
          if (perf.gpuAcceleration !== void 0) {
            variables["--sn.perf.gpu.acceleration.enabled"] = perf.gpuAcceleration ? "1" : "0";
          }
          this.updateVariables(variables, "high", "performance-system");
        }
        /**
         * Direct property setter (convenience API)
         */
        setProperty(property, value, element = null) {
          if (property.startsWith("--spice-") && this.config.enableSpiceVariableDebug) {
            const caller = new Error().stack?.split("\n")[2]?.trim().replace(/^\s*at\s+/, "") || "unknown";
            console.log(
              `\u{1F527} [CSS Debug] Setting ${property} = ${value} (from: ${caller})`
            );
          }
          this.queueCSSVariableUpdate(property, value, element);
        }
        // ===================================================================
        // PERFORMANCE AND DEVICE OPTIMIZATION METHODS
        // ===================================================================
        /**
         * Apply device-specific CSS classes
         */
        applyDeviceOptimizations() {
          if (!this.cssConfig.enableDeviceTierOptimization || !this.currentDeviceCapabilities)
            return;
          this.removeClassesByPrefix("device-tier-");
          this.removeClassesByPrefix("device-mobile-");
          this.removeClassesByPrefix("device-gpu-");
          const tierClass = `device-tier-${this.currentDeviceCapabilities.performanceTier}`;
          this.addCSSClass(tierClass);
          if (this.currentDeviceCapabilities.isMobile) {
            this.addCSSClass("device-mobile-optimized");
          }
          if (this.currentDeviceCapabilities.gpuAcceleration) {
            this.addCSSClass("device-gpu-accelerated");
          } else {
            this.addCSSClass("device-gpu-fallback");
          }
          const memoryTier = this.getMemoryTier(
            this.currentDeviceCapabilities.memoryGB
          );
          this.addCSSClass(`device-memory-${memoryTier}`);
        }
        /**
         * Apply performance mode CSS classes
         */
        applyPerformanceModeOptimizations() {
          if (!this.currentPerformanceMode) return;
          this.removeClassesByPrefix("performance-mode-");
          const modeClass = `performance-mode-${this.currentPerformanceMode.name}`;
          this.addCSSClass(modeClass);
          const optimizationClass = `optimization-level-${this.currentPerformanceMode.optimizationLevel}`;
          this.addCSSClass(optimizationClass);
        }
        /**
         * Get performance report
         */
        getPerformanceReport() {
          const averageBatchTime = this.performanceMetrics.totalBatches > 0 ? this.performanceMetrics.totalBatchTime / this.performanceMetrics.totalBatches : 0;
          return {
            enabled: true,
            pendingUpdates: this.cssVariableQueue.size + this.updateQueue.size,
            totalUpdates: this.performanceMetrics.totalUpdates,
            totalBatches: this.performanceMetrics.totalBatches,
            averageBatchSize: Math.round(this.performanceMetrics.averageBatchSize * 10) / 10,
            averageBatchTime: Math.round(averageBatchTime * 100) / 100,
            maxBatchTime: Math.round(this.performanceMetrics.maxBatchTime * 100) / 100,
            overBudgetBatches: this.performanceMetrics.overBudgetBatches,
            conflictResolutions: this.performanceMetrics.conflictResolutions,
            transactionCount: this.performanceMetrics.transactionCount,
            consciousnessUpdates: this.performanceMetrics.consciousnessUpdates,
            consciousnessActive: this.consciousnessState !== null,
            deviceTier: this.currentDeviceCapabilities?.performanceTier,
            performanceMode: this.currentPerformanceMode?.name
          };
        }
        // ===================================================================
        // PRIVATE METHODS
        // ===================================================================
        subscribeToEvents() {
          this.eventBus.subscribe("performance:tier-changed", (payload) => {
            this.currentPerformanceMode = this.performanceCoordinator.getCurrentPerformanceMode();
            this.applyPerformanceModeOptimizations();
            this.updateCSSPerformanceVariables();
          }, "UnifiedCSSVariableManager");
          this.eventBus.subscribe("performance:frame", (payload) => {
            if (payload.temperature && payload.temperature > 80) {
              this.applyThermalOptimizations(payload.temperature);
            }
          }, "UnifiedCSSVariableManager");
        }
        applyInitialOptimizations() {
          try {
            this.applyDeviceOptimizations();
            this.applyPerformanceModeOptimizations();
            this.updateCSSPerformanceVariables();
            if (this.cssConfig.debugPerformanceClasses) {
              this.addCSSClass("debug-performance");
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[UnifiedCSSVariableManager] Error applying initial optimizations:",
                error
              );
            }
          }
        }
        applyCurrentOptimizations() {
          this.applyDeviceOptimizations();
          this.applyPerformanceModeOptimizations();
          const batteryState = this.performanceCoordinator.getBatteryState();
          const thermalState = this.performanceCoordinator.getThermalState();
          if (batteryState) {
            this.applyBatteryOptimizations(batteryState.level, batteryState.charging);
          }
          const thermalTemp = thermalState.temperature || "normal";
          this.applyThermalOptimizations(thermalTemp);
        }
        updateCSSPerformanceVariables() {
          const now = Date.now();
          if (now - this.lastCSSUpdate < this.cssUpdateThrottle) return;
          this.lastCSSUpdate = now;
          if (!this.currentPerformanceMode || !this.currentDeviceCapabilities) return;
          try {
            const variables = {
              "--sn.performance.mode": this.currentPerformanceMode.name || "balanced",
              "--sn.performance.quality.level": (this.currentPerformanceMode.qualityLevel ?? 0.8).toString(),
              "--sn.performance.fps.target": (this.currentPerformanceMode.frameRate ?? 60).toString(),
              "--sn.performance.frame.budget": (1e3 / (this.currentPerformanceMode.frameRate ?? 60)).toString(),
              "--sn.performance.optimization.level": (this.currentPerformanceMode.optimizationLevel ?? 1).toString(),
              "--sn.device.tier": this.currentDeviceCapabilities.performanceTier ?? "mid",
              "--sn.device.memory": (this.currentDeviceCapabilities.memoryGB ?? 8).toString(),
              "--sn.device.gpu": this.currentDeviceCapabilities.gpuAcceleration ?? true ? "1" : "0",
              "--sn.device.mobile": this.currentDeviceCapabilities.isMobile ?? false ? "1" : "0",
              "--sn.performance.blur.quality": (this.currentPerformanceMode.blurQuality ?? 0.8).toString(),
              "--sn.performance.shadow.quality": (this.currentPerformanceMode.shadowQuality ?? 0.8).toString(),
              "--sn.performance.animation.quality": (this.currentPerformanceMode.animationQuality ?? 0.8).toString(),
              "--sn.performance.effect.quality": (this.currentPerformanceMode.effectQuality ?? 0.8).toString()
            };
            this.updateVariables(variables, "high", "performance-coordinator");
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[UnifiedCSSVariableManager] Error updating CSS performance variables:",
                error
              );
            }
          }
        }
        startConsciousnessIntegration() {
          if (this.consciousnessUpdateTimer) return;
          const updateConsciousness = /* @__PURE__ */ __name(() => {
            const now = performance.now();
            if (now - this.lastConsciousnessUpdate >= this.cssConfig.consciousnessUpdateInterval) {
              this.lastConsciousnessUpdate = now;
              if (this.consciousnessState) {
                this.updateConsciousnessVariables(this.consciousnessState);
              }
            }
            this.consciousnessUpdateTimer = setTimeout(
              updateConsciousness,
              this.cssConfig.consciousnessUpdateInterval
            );
          }, "updateConsciousness");
          updateConsciousness();
        }
        shouldReplaceUpdate(existing, incoming) {
          const existingWeight = this.PRIORITY_WEIGHTS[existing.priority];
          const incomingWeight = this.PRIORITY_WEIGHTS[incoming.priority];
          if (incomingWeight > existingWeight) {
            return true;
          }
          if (incomingWeight === existingWeight) {
            return incoming.timestamp > existing.timestamp;
          }
          return false;
        }
        scheduleFlush(priority) {
          if (this.rafHandle !== null || this.microtaskScheduled) {
            return;
          }
          const flushCallback = /* @__PURE__ */ __name(() => {
            this.rafHandle = null;
            this.microtaskScheduled = false;
            this.flushCSSVariableBatch();
          }, "flushCallback");
          if (typeof document !== "undefined" && document.visibilityState === "hidden") {
            this.microtaskScheduled = true;
            queueMicrotask(flushCallback);
          } else if (typeof requestAnimationFrame === "function") {
            this.rafHandle = requestAnimationFrame(flushCallback);
          } else {
            setTimeout(flushCallback, 0);
          }
        }
        updatePerformanceMetrics(batchTime, batchSize) {
          this.performanceMetrics.totalBatches++;
          this.performanceMetrics.totalBatchTime += batchTime;
          this.performanceMetrics.maxBatchTime = Math.max(
            this.performanceMetrics.maxBatchTime,
            batchTime
          );
          this.performanceMetrics.averageBatchSize = (this.performanceMetrics.averageBatchSize * (this.performanceMetrics.totalBatches - 1) + batchSize) / this.performanceMetrics.totalBatches;
          if (batchTime > 8) {
            this.performanceMetrics.overBudgetBatches++;
            if (this.config.enableDebug) {
              console.warn(
                `[UnifiedCSSVariableManager] CSS batch took ${batchTime.toFixed(
                  2
                )}ms for ${batchSize} updates`
              );
            }
          }
        }
        enableGlobalHijack() {
          if (_UnifiedCSSVariableManager.hijackEnabled) return;
          const original = CSSStyleDeclaration.prototype.setProperty;
          _UnifiedCSSVariableManager.nativeSetProperty = original;
          const controllerInstance = this;
          CSSStyleDeclaration.prototype.setProperty = function(prop, value, priority) {
            if (prop && (prop.startsWith("--sn-") || prop.startsWith("--sn.")) && controllerInstance) {
              controllerInstance.queueCSSVariableUpdate(prop, String(value ?? ""));
            } else {
              original.call(this, prop, value, priority);
            }
          };
          _UnifiedCSSVariableManager.hijackEnabled = true;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSVariableManager] Global setProperty hijack enabled (--sn- and --sn. namespaces)"
            );
          }
        }
        addCSSClass(className) {
          if (!this.appliedClasses.has(className)) {
            document.body.classList.add(className);
            this.appliedClasses.add(className);
          }
        }
        removeCSSClass(className) {
          if (this.appliedClasses.has(className)) {
            document.body.classList.remove(className);
            this.appliedClasses.delete(className);
          }
        }
        removeClassesByPrefix(prefix) {
          const classesToRemove = Array.from(this.appliedClasses).filter(
            (className) => className.startsWith(prefix)
          );
          for (const className of classesToRemove) {
            this.removeCSSClass(className);
          }
        }
        getMemoryTier(memoryGB) {
          if (memoryGB >= 16) return "high";
          if (memoryGB >= 8) return "medium";
          if (memoryGB >= 4) return "low";
          return "minimal";
        }
        applyThermalOptimizations(thermalState) {
          if (!this.cssConfig.enableThermalThrottling) return;
          this.removeClassesByPrefix("thermal-");
          const thermalClass = `thermal-${thermalState}`;
          this.addCSSClass(thermalClass);
        }
        applyBatteryOptimizations(batteryLevel, charging) {
          if (!this.cssConfig.enableBatteryOptimization) return;
          this.removeClassesByPrefix("battery-");
          if (batteryLevel < 0.2) {
            this.addCSSClass("battery-low");
          } else if (batteryLevel < 0.5) {
            this.addCSSClass("battery-medium");
          } else {
            this.addCSSClass("battery-high");
          }
          if (charging) {
            this.addCSSClass("battery-charging");
          }
        }
        // ===================================================================
        // CONVENIENCE METHODS FROM UNIFIEDCSSVARIABLEMANAGER
        // ===================================================================
        /**
         * Update music system variables (from UnifiedCSSVariableManager)
         */
        updateMusicVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-music-${key.replace(/\./g, "-")}`;
              updates[fullKey] = String(value);
            }
          }
          this.updateVariables(updates, "critical", "music-system");
        }
        /**
         * Update color system variables (from UnifiedCSSVariableManager)
         */
        updateColorVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-color-${key.replace(/\./g, "-")}`;
              updates[fullKey] = String(value);
            }
          }
          this.updateVariables(updates, "high", "color-system");
        }
        /**
         * Update animation system variables (from UnifiedCSSVariableManager)
         */
        updateAnimationVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-anim-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.updateVariables(updates, "normal", "animation-system");
        }
        /**
         * Update performance system variables (from UnifiedCSSVariableManager)
         */
        updatePerformanceVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-performance-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.updateVariables(updates, "high", "performance-system");
        }
        /**
         * Update utility system variables (from UnifiedCSSVariableManager)
         */
        updateUtilityVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.updateVariables(updates, "low", "utility-system");
        }
        /**
         * Queue a CSS variable update (from UnifiedCSSVariableManager compatibility)
         */
        queueUpdate(property, value, priority = "normal", source = "unknown") {
          this.queueCSSVariableUpdate(property, value, null, priority, source);
        }
        /**
         * Queue multiple CSS variable updates in a transaction (from UnifiedCSSVariableManager)
         */
        queueTransaction(variables, priority = "normal", source = "unknown") {
          const transactionId = `tx_${++this.transactionCounter}`;
          const variableMap = new Map(Object.entries(variables));
          const transaction = {
            id: transactionId,
            variables: variableMap,
            timestamp: performance.now(),
            priority,
            completed: false
          };
          this.pendingTransactions.set(transactionId, transaction);
          for (const [property, value] of variableMap) {
            this.queueUpdate(property, value, priority, `${source}:${transactionId}`);
          }
          this.performanceMetrics.transactionCount++;
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Transaction ${transactionId} queued with ${variableMap.size} variables`
            );
          }
          return transactionId;
        }
        /**
         * Force immediate flush (from UnifiedCSSVariableManager)
         */
        forceFlush() {
          this.flushCSSVariableBatch();
        }
        /**
         * Register a variable group (from UnifiedCSSVariableManager compatibility)
         */
        registerVariableGroup(name, priority = "normal", batchSize = 50, flushInterval = 16) {
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Variable group registration: ${name} (handled internally)`
            );
          }
        }
        /**
         * Update variables in a specific group (from UnifiedCSSVariableManager compatibility)
         */
        updateVariableGroup(groupName, variables, source = "unknown") {
          this.updateVariables(variables, "normal", `group:${groupName}:${source}`);
        }
        /**
         * Update configuration (from CSSVariableBatcher compatibility)
         */
        updateConfig(newConfig) {
          this.cssConfig = { ...this.cssConfig, ...newConfig };
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSVariableManager] Configuration updated:",
              newConfig
            );
          }
        }
        // ===================================================================
        // LEGACY COMPATIBILITY METHODS
        // ===================================================================
        // For backwards compatibility with UnifiedCSSVariableManager API
        flushNow() {
          this.flushCSSVariableBatch();
        }
        setBatchingEnabled(enabled) {
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Batching ${enabled ? "enabled" : "disabled"}`
            );
          }
        }
        addCriticalVariable(variable) {
          CRITICAL_NOW_PLAYING_VARS.add(variable);
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Added critical variable: ${variable}`
            );
          }
        }
        removeCriticalVariable(variable) {
          CRITICAL_NOW_PLAYING_VARS.delete(variable);
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Removed critical variable: ${variable}`
            );
          }
        }
        isCriticalVariable(variable) {
          return CRITICAL_NOW_PLAYING_VARS.has(variable);
        }
        getCriticalVariables() {
          return Array.from(CRITICAL_NOW_PLAYING_VARS);
        }
        // ===================================================================
        // SIMPLIFIED COORDINATION PATTERNS (Extracted from SharedVariableCoordination.ts)
        // ===================================================================
        /**
         * Update consciousness intensity with simplified coordination through UnifiedEventBus
         * Replaces the complex ConsciousnessIntensityCoordinator pattern with a simple subscription-based approach
         */
        updateConsciousnessIntensity(intensity, sourceStrategy, musicEnergy) {
          const clampedIntensity = Math.max(0, Math.min(1, intensity));
          this.queueCSSVariableUpdate(
            "--consciousness-intensity",
            clampedIntensity.toString(),
            null,
            "high",
            `consciousness-${sourceStrategy}`
          );
          if (this.eventBus) {
            this.eventBus.emitSync("consciousness:intensity-changed", {
              intensity: clampedIntensity,
              userEngagement: 0.5,
              // Default engagement level
              timestamp: Date.now(),
              sourceStrategy,
              musicEnergy: musicEnergy ?? 0
            });
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Consciousness intensity updated by ${sourceStrategy}: ${clampedIntensity}`
            );
          }
        }
        /**
         * Update crossfade opacity with simplified coordination through UnifiedEventBus
         * Replaces the complex CrossfadeOpacityCoordinator pattern with a simple subscription-based approach
         */
        updateCrossfadeOpacity(opacity, sourceStrategy, webglEnabled) {
          let finalOpacity = Math.max(0, Math.min(1, opacity));
          if (!webglEnabled) {
            finalOpacity = 0;
          }
          this.queueCSSVariableUpdate(
            "--sn-gradient-crossfade-opacity",
            finalOpacity.toString(),
            null,
            "high",
            `crossfade-${sourceStrategy}`
          );
          if (this.eventBus) {
            this.eventBus.emitSync("gradient:crossfade-changed", {
              opacity: finalOpacity,
              sourceStrategy,
              webglEnabled,
              timestamp: Date.now()
            });
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Crossfade opacity updated by ${sourceStrategy}: ${finalOpacity} (WebGL: ${webglEnabled})`
            );
          }
        }
        /**
         * Subscribe to consciousness intensity changes from other strategies
         */
        subscribeToConsciousnessChanges(callback) {
          if (!this.eventBus) {
            console.warn(
              "[UnifiedCSSVariableManager] No UnifiedEventBus available for consciousness subscriptions"
            );
            return () => {
            };
          }
          const subscriptionId = this.eventBus.subscribe(
            "consciousness:intensity-changed",
            callback,
            "UnifiedCSSVariableManager"
          );
          return () => this.eventBus?.unsubscribe(subscriptionId);
        }
        /**
         * Subscribe to crossfade opacity changes from other strategies
         */
        subscribeToCrossfadeChanges(callback) {
          if (!this.eventBus) {
            console.warn(
              "[UnifiedCSSVariableManager] No UnifiedEventBus available for crossfade subscriptions"
            );
            return () => {
            };
          }
          const subscriptionId = this.eventBus.subscribe(
            "gradient:crossfade-changed",
            callback,
            "UnifiedCSSVariableManager"
          );
          return () => this.eventBus?.unsubscribe(subscriptionId);
        }
      };
      __name(_UnifiedCSSVariableManager, "UnifiedCSSVariableManager");
      _UnifiedCSSVariableManager.hijackEnabled = false;
      UnifiedCSSVariableManager = _UnifiedCSSVariableManager;
    }
  });

  // src-js/core/performance/OptimizedCSSVariableManager.ts
  function setGlobalOptimizedCSSController(instance2) {
    globalOptimizedCSSController = instance2;
  }
  function getGlobalOptimizedCSSController() {
    if (!globalOptimizedCSSController) {
      console.warn("[OptimizedCSSVariableManager] Global instance not initialized yet. This may indicate an initialization order issue.");
      throw new Error("Global OptimizedCSSVariableManager not initialized. Call setGlobalOptimizedCSSController() first.");
    }
    return globalOptimizedCSSController;
  }
  var _OptimizedCSSVariableManager, OptimizedCSSVariableManager, globalOptimizedCSSController;
  var init_OptimizedCSSVariableManager = __esm({
    "src-js/core/performance/OptimizedCSSVariableManager.ts"() {
      "use strict";
      init_UnifiedCSSVariableManager();
      _OptimizedCSSVariableManager = class _OptimizedCSSVariableManager extends UnifiedCSSVariableManager {
        constructor(year3000Config, performanceCoordinator, optimizedConfig = {}) {
          super(year3000Config, performanceCoordinator);
          // Performance tracking
          this.lastFPSCheck = 0;
          this.currentPerformanceLevel = "good";
          this.adaptiveThrottleLevel = 1;
          // Priority queues
          this.priorityQueues = /* @__PURE__ */ new Map();
          this.optimizedConfig = {
            batchIntervalMs: 16,
            maxBatchSize: 50,
            enableDebug: year3000Config.enableDebug,
            enableAdaptiveThrottling: true,
            priorityMappings: {
              critical: ["--sn-rs-glow-alpha", "--sn-rs-beat-intensity", "--sn-rs-hue-shift"],
              high: ["--sn-gradient-primary", "--sn-gradient-secondary", "--sn-gradient-accent"],
              normal: ["--sn-gradient-", "--sn-rs-"],
              low: ["--sn-debug-", "--sn-dev-"]
            },
            thresholds: {
              excellentFPS: 55,
              // 55+ FPS = excellent
              goodFPS: 45,
              // 45+ FPS = good
              poorFPS: 30
              // <30 FPS = poor
            },
            ...optimizedConfig
          };
          if (optimizedConfig.performanceAnalyzer) {
            this.performanceAnalyzer = optimizedConfig.performanceAnalyzer;
          }
          if (optimizedConfig.budgetManager) {
            this.budgetManager = optimizedConfig.budgetManager;
          }
          this.initializePriorityQueues();
          if (this.optimizedConfig.enableAdaptiveThrottling) {
            this.startAdaptiveMonitoring();
          }
        }
        /**
         * Initialize priority queues for different variable types
         */
        initializePriorityQueues() {
          this.priorityQueues.set("critical", /* @__PURE__ */ new Map());
          this.priorityQueues.set("high", /* @__PURE__ */ new Map());
          this.priorityQueues.set("normal", /* @__PURE__ */ new Map());
          this.priorityQueues.set("low", /* @__PURE__ */ new Map());
        }
        /**
         * Start adaptive performance monitoring
         */
        startAdaptiveMonitoring() {
          setInterval(() => {
            this.updatePerformanceLevel();
            this.adjustBatchingStrategy();
          }, 1e3);
        }
        /**
         * Update current performance level based on FPS
         */
        updatePerformanceLevel() {
          if (!this.performanceAnalyzer) return;
          const currentFPS = this.performanceAnalyzer.getMedianFPS();
          const { excellentFPS, goodFPS, poorFPS } = this.optimizedConfig.thresholds;
          const previousLevel = this.currentPerformanceLevel;
          if (currentFPS >= excellentFPS) {
            this.currentPerformanceLevel = "excellent";
          } else if (currentFPS >= goodFPS) {
            this.currentPerformanceLevel = "good";
          } else if (currentFPS < poorFPS) {
            this.currentPerformanceLevel = "poor";
          }
          if (previousLevel !== this.currentPerformanceLevel && this.optimizedConfig.enableDebug) {
            console.log(`\u{1F3A8} [OptimizedCSSVariableManager] Performance level changed: ${previousLevel} \u2192 ${this.currentPerformanceLevel} (${currentFPS} FPS)`);
          }
        }
        /**
         * Adjust batching strategy based on performance level
         */
        adjustBatchingStrategy() {
          let newBatchInterval;
          let newMaxBatchSize;
          switch (this.currentPerformanceLevel) {
            case "excellent":
              newBatchInterval = Math.max(8, this.optimizedConfig.batchIntervalMs / 2);
              newMaxBatchSize = Math.min(100, this.optimizedConfig.maxBatchSize * 2);
              this.adaptiveThrottleLevel = 0.5;
              break;
            case "good":
              newBatchInterval = this.optimizedConfig.batchIntervalMs;
              newMaxBatchSize = this.optimizedConfig.maxBatchSize;
              this.adaptiveThrottleLevel = 1;
              break;
            case "poor":
              newBatchInterval = this.optimizedConfig.batchIntervalMs * 2;
              newMaxBatchSize = Math.max(10, this.optimizedConfig.maxBatchSize / 2);
              this.adaptiveThrottleLevel = 2;
              break;
          }
          this.updateConfig({
            batchIntervalMs: newBatchInterval,
            maxBatchSize: newMaxBatchSize
          });
        }
        /**
         * Enhanced queueCSSVariableUpdate with priority handling
         * Fixed signature to match base class
         */
        queueCSSVariableUpdate(property, value, element = null, priority = "normal", source = "unknown") {
          const targetElement = element || document.documentElement;
          const effectivePriority = priority || this.determineVariablePriority(property);
          if (effectivePriority === "critical") {
            this.applyCriticalUpdate(property, value, targetElement);
            return;
          }
          const priorityQueue = this.priorityQueues.get(effectivePriority);
          if (priorityQueue) {
            const key = `${property}:${targetElement.tagName || "ROOT"}`;
            priorityQueue.set(key, {
              property,
              value,
              timestamp: performance.now()
            });
          }
          this.scheduleOptimizedFlush(effectivePriority);
        }
        /**
         * Determine variable priority based on configured mappings
         */
        determineVariablePriority(property) {
          const { priorityMappings } = this.optimizedConfig;
          for (const [priority, variables] of Object.entries(priorityMappings)) {
            if (variables.includes(property)) {
              return priority;
            }
          }
          for (const [priority, variables] of Object.entries(priorityMappings)) {
            for (const variable of variables) {
              if (property.startsWith(variable)) {
                return priority;
              }
            }
          }
          return "normal";
        }
        /**
         * Apply critical updates immediately
         */
        applyCriticalUpdate(property, value, element) {
          try {
            element.style.setProperty(property, value);
          } catch (error) {
            console.error(`\u{1F3A8} [OptimizedCSSVariableManager] Critical update failed for ${property}:`, error);
          }
        }
        /**
         * Schedule optimized flush based on priority
         */
        scheduleOptimizedFlush(priority) {
          const delay = this.getFlushDelay(priority);
          setTimeout(() => {
            this.flushPriorityQueue(priority);
          }, delay);
        }
        /**
         * Get flush delay based on priority and performance level
         */
        getFlushDelay(priority) {
          const baseDelay = this.optimizedConfig.batchIntervalMs;
          const adaptiveMultiplier = this.adaptiveThrottleLevel;
          switch (priority) {
            case "critical":
              return 0;
            case "high":
              return Math.max(4, baseDelay * 0.5 * adaptiveMultiplier);
            case "normal":
              return baseDelay * adaptiveMultiplier;
            case "low":
              return baseDelay * 2 * adaptiveMultiplier;
            default:
              return baseDelay * adaptiveMultiplier;
          }
        }
        /**
         * Flush a specific priority queue
         */
        flushPriorityQueue(priority) {
          const queue = this.priorityQueues.get(priority);
          if (!queue || queue.size === 0) return;
          const updates = Array.from(queue.values());
          queue.clear();
          for (const update of updates) {
            super.queueCSSVariableUpdate(update.property, update.value, null, "normal", update.timestamp.toString());
          }
        }
        /**
         * Get optimization metrics
         */
        getOptimizationMetrics() {
          const queueSizes = {};
          for (const [priority, queue] of this.priorityQueues) {
            queueSizes[priority] = queue.size;
          }
          const result = {
            performanceLevel: this.currentPerformanceLevel,
            adaptiveThrottleLevel: this.adaptiveThrottleLevel,
            queueSizes
          };
          result.budgetViolations = [];
          return result;
        }
        /**
         * Force flush all priority queues
         */
        flushAllQueues() {
          for (const priority of ["critical", "high", "normal", "low"]) {
            this.flushPriorityQueue(priority);
          }
          this.flushUpdates();
        }
        /**
         * Update priority mappings
         */
        updatePriorityMappings(mappings) {
          this.optimizedConfig.priorityMappings = {
            ...this.optimizedConfig.priorityMappings,
            ...mappings
          };
        }
        // ===================================================================
        // CONVENIENCE METHODS (from CSSVariableCoordinator)
        // ===================================================================
        /**
         * Convenience method for batch setting variables with caller context
         * Compatible with CSSVariableCoordinator API
         */
        async batchSetVariables(caller, variables, priority = "normal", source = "unknown") {
          this.updateVariables(variables, priority, `${caller}:${source}`);
        }
        /**
         * Convenience method for setting single variable with caller context
         * Compatible with CSSVariableCoordinator API
         */
        async setVariable(caller, property, value, priority = "normal", source = "unknown") {
          this.updateVariables({ [property]: value }, priority, `${caller}:${source}`);
        }
        /**
         * Direct DOM fallback (for compatibility with CSSVariableCoordinator pattern)
         */
        applyDirect(vars) {
          const root = document.documentElement;
          for (const [k, v] of Object.entries(vars)) {
            root.style.setProperty(k, v);
          }
        }
        /**
         * Static method for global instance access
         */
        static getGlobalInstance() {
          return getGlobalOptimizedCSSController();
        }
        /**
         * Cleanup and destroy
         */
        destroy() {
          for (const queue of this.priorityQueues.values()) {
            queue.clear();
          }
          this.priorityQueues.clear();
          super.destroy();
        }
      };
      __name(_OptimizedCSSVariableManager, "OptimizedCSSVariableManager");
      OptimizedCSSVariableManager = _OptimizedCSSVariableManager;
      globalOptimizedCSSController = null;
      __name(setGlobalOptimizedCSSController, "setGlobalOptimizedCSSController");
      __name(getGlobalOptimizedCSSController, "getGlobalOptimizedCSSController");
    }
  });

  // src-js/utils/spicetify/SemanticColorManager.ts
  var _SemanticColorManager, SemanticColorManager;
  var init_SemanticColorManager = __esm({
    "src-js/utils/spicetify/SemanticColorManager.ts"() {
      "use strict";
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_Year3000Utilities();
      _SemanticColorManager = class _SemanticColorManager {
        constructor(config = {}) {
          this.colorCache = /* @__PURE__ */ new Map();
          this.lastCacheUpdate = 0;
          // IManagedSystem interface
          this.initialized = false;
          // Event tracking for proper system integration
          this.eventSubscriptionIds = [];
          this.lastColorUpdate = 0;
          this.colorUpdateCount = 0;
          this.config = {
            enableDebug: false,
            fallbackToSpiceColors: true,
            cacheDuration: 5e3,
            // 5 seconds
            ...config
          };
        }
        async initialize(cssController) {
          if (this.initialized) {
            console.warn("[SemanticColorManager] Already initialized, skipping");
            return;
          }
          try {
            this.cssController = cssController || getGlobalOptimizedCSSController();
            this.setupEventSubscriptions();
            this.initialized = true;
            this.lastColorUpdate = Date.now();
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] Initialized as IManagedSystem with", {
                mappings: _SemanticColorManager.SEMANTIC_MAPPINGS.length,
                batcherAvailable: !!this.cssController,
                spicetifyAvailable: this.isSpicetifyAvailable(),
                eventSubscriptions: this.eventSubscriptionIds.length
              });
            }
            unifiedEventBus.emitSync("system:initialized", {
              systemName: "SemanticColorManager",
              timestamp: Date.now(),
              metadata: {
                mappings: _SemanticColorManager.SEMANTIC_MAPPINGS.length,
                spicetifyAvailable: this.isSpicetifyAvailable()
              }
            });
          } catch (error) {
            console.error("[SemanticColorManager] Initialization failed:", error);
            unifiedEventBus.emitSync("system:error", {
              systemName: "SemanticColorManager",
              error: error instanceof Error ? error.message : "Initialization failed",
              severity: "critical",
              timestamp: Date.now()
            });
            throw error;
          }
        }
        async updateSemanticColors() {
          if (!this.initialized) {
            console.warn("[SemanticColorManager] Not initialized, cannot update colors");
            return;
          }
          const now = Date.now();
          if (now - this.lastCacheUpdate < (this.config.cacheDuration || 5e3)) {
            return;
          }
          console.log("\u{1F3A8} [SemanticColorManager] Starting semantic color update...");
          try {
            const colorUpdateLog = {};
            const semanticColorUpdates = {};
            const rgbColorUpdates = {};
            for (const mapping of _SemanticColorManager.SEMANTIC_MAPPINGS) {
              const color3 = await this.getSemanticColor(mapping.semanticColor);
              colorUpdateLog[mapping.cssVariable] = {
                semanticColor: mapping.semanticColor,
                retrievedColor: color3,
                fallbackColor: mapping.fallbackColor,
                description: mapping.description
              };
              semanticColorUpdates[mapping.cssVariable] = color3;
              const rgbColor = hexToRgb(color3);
              if (rgbColor) {
                const rgbVariable = mapping.cssVariable.replace("--spice-", "--spice-rgb-");
                rgbColorUpdates[rgbVariable] = `${rgbColor.r},${rgbColor.g},${rgbColor.b}`;
                colorUpdateLog[rgbVariable] = `${rgbColor.r},${rgbColor.g},${rgbColor.b}`;
              }
            }
            this.cssController.batchSetVariables(
              "SemanticColorManager",
              semanticColorUpdates,
              "high",
              // High priority for semantic color system
              "semantic-color-update"
            );
            this.cssController.batchSetVariables(
              "SemanticColorManager",
              rgbColorUpdates,
              "high",
              // High priority for RGB color variants
              "semantic-rgb-update"
            );
            console.log("\u{1F3A8} [SemanticColorManager] Color update complete:", colorUpdateLog);
            this.lastCacheUpdate = now;
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] Updated all semantic colors");
            }
          } catch (error) {
            console.error("[SemanticColorManager] Failed to update semantic colors:", error);
          }
        }
        async getSemanticColor(semanticColor) {
          const cached = this.colorCache.get(semanticColor);
          if (cached && Date.now() - this.lastCacheUpdate < (this.config.cacheDuration || 5e3)) {
            return cached;
          }
          let color3;
          try {
            if (this.isSpicetifyAvailable() && Spicetify.Platform?.getSemanticColors) {
              const semanticColors = await Spicetify.Platform.getSemanticColors();
              color3 = semanticColors[semanticColor];
              console.log(`\u{1F3A8} [SemanticColorManager] Spicetify returned for ${semanticColor}:`, {
                rawValue: color3,
                type: typeof color3,
                isWhite: color3 === "#ffffff" || color3 === "#fff" || color3 === "white",
                isInvalid: !color3 || color3 === "undefined" || color3 === "null"
              });
            } else {
              console.warn(`\u{1F3A8} [SemanticColorManager] Spicetify not available, using fallback for ${semanticColor}`);
              color3 = this.getFallbackColor(semanticColor);
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(`[SemanticColorManager] Failed to get semantic color ${semanticColor}:`, error);
            }
            color3 = this.getFallbackColor(semanticColor);
          }
          color3 = this.validateColor(color3, semanticColor);
          this.colorCache.set(semanticColor, color3);
          return color3;
        }
        /**
         * Validate color to prevent white (#ffffff) or invalid colors from being applied
         */
        validateColor(color3, semanticColor) {
          const normalizedColor = color3?.toLowerCase().trim();
          const invalidColors = [
            "#ffffff",
            "#fff",
            "white",
            "#000000",
            "#000",
            "black",
            "",
            "undefined",
            "null",
            "transparent"
          ];
          if (!normalizedColor || invalidColors.includes(normalizedColor)) {
            const fallbackColor = this.getFallbackColor(semanticColor);
            if (this.config.enableDebug) {
              console.warn(`\u{1F527} [SemanticColorManager] Invalid color "${color3}" for ${semanticColor}, using fallback: ${fallbackColor}`);
            }
            return fallbackColor;
          }
          if (!normalizedColor.match(/^#[0-9a-f]{6}$/i) && !normalizedColor.match(/^#[0-9a-f]{3}$/i)) {
            const fallbackColor = this.getFallbackColor(semanticColor);
            if (this.config.enableDebug) {
              console.warn(`\u{1F527} [SemanticColorManager] Malformed color "${color3}" for ${semanticColor}, using fallback: ${fallbackColor}`);
            }
            return fallbackColor;
          }
          return color3;
        }
        getFallbackColor(semanticColor) {
          const mapping = _SemanticColorManager.SEMANTIC_MAPPINGS.find((m) => m.semanticColor === semanticColor);
          if (mapping) {
            return mapping.fallbackColor;
          }
          if (semanticColor.startsWith("text")) {
            return "#cad3f5";
          } else if (semanticColor.startsWith("background")) {
            return "#24273a";
          } else if (semanticColor.startsWith("essential")) {
            return "#c6a0f6";
          } else if (semanticColor.startsWith("decorative")) {
            return "#939ab7";
          }
          return "#cad3f5";
        }
        applyColorToCSS(cssVariable, color3, priority = "normal", source = "semantic-color-manager") {
          this.cssController.setVariable(
            "SemanticColorManager",
            cssVariable,
            color3,
            priority,
            source
          );
        }
        isSpicetifyAvailable() {
          return typeof Spicetify !== "undefined" && Spicetify.Platform && typeof Spicetify.Platform.getSemanticColors === "function";
        }
        flushUpdates() {
          if (this.cssController) {
            this.cssController.flushUpdates();
          }
        }
        clearCache() {
          this.colorCache.clear();
          this.lastCacheUpdate = 0;
        }
        /**
         * Update Spicetify variables directly with OKLAB-processed album colors
         * This bypasses CSS fallback chains and prevents Spotify overrides
         * 
         * Enhanced for comprehensive override protection across all visual systems
         */
        updateWithAlbumColors(oklabColors) {
          if (!this.initialized) {
            console.warn("[SemanticColorManager] Not initialized, cannot update with album colors");
            return;
          }
          try {
            const primaryColor = oklabColors["OKLAB_PRIMARY"] || oklabColors["VIBRANT"] || oklabColors["PRIMARY"];
            const accentColor = oklabColors["OKLAB_ACCENT"] || oklabColors["LIGHT_VIBRANT"] || oklabColors["SECONDARY"];
            const shadowColor = oklabColors["OKLAB_SHADOW"] || oklabColors["DARK_VIBRANT"] || oklabColors["DARK"];
            const highlightColor = oklabColors["OKLAB_HIGHLIGHT"] || oklabColors["VIBRANT_NON_ALARMING"] || oklabColors["LIGHT"];
            if (!primaryColor) {
              console.warn("[SemanticColorManager] No primary color found in OKLAB result, skipping update");
              return;
            }
            const colorDistribution = this.generateIntelligentColorDistribution(
              primaryColor,
              accentColor,
              shadowColor,
              highlightColor
            );
            const rgbDistribution = this.convertColorsToRgb(colorDistribution);
            const coreSpicetifyUpdates = {
              "--spice-accent": colorDistribution.primary,
              "--spice-rgb-accent": rgbDistribution.primary,
              "--spice-surface1": colorDistribution.surface1,
              "--spice-rgb-surface1": rgbDistribution.surface1,
              "--spice-button-active": colorDistribution.primary,
              "--spice-rgb-button-active": rgbDistribution.primary,
              "--spice-highlight": colorDistribution.highlight,
              "--spice-rgb-highlight": rgbDistribution.highlight,
              "--spice-press": colorDistribution.shadow,
              "--spice-rgb-press": rgbDistribution.shadow
            };
            const criticalSpicetifyUpdates = {
              "--spice-surface0": colorDistribution.surface0,
              "--spice-rgb-surface0": rgbDistribution.surface0,
              "--spice-surface2": colorDistribution.surface2,
              "--spice-rgb-surface2": rgbDistribution.surface2,
              "--spice-base": colorDistribution.base,
              "--spice-rgb-base": rgbDistribution.base
            };
            const coreLayoutSpicetifyUpdates = {
              "--spice-main": colorDistribution.base,
              "--spice-rgb-main": rgbDistribution.base,
              "--spice-main-elevated": colorDistribution.surface0,
              "--spice-rgb-main-elevated": rgbDistribution.surface0,
              "--spice-sidebar": colorDistribution.surface1,
              "--spice-rgb-sidebar": rgbDistribution.surface1,
              "--spice-text": this.generateTextColor(colorDistribution.base),
              "--spice-rgb-text": this.hexToRgb(this.generateTextColor(colorDistribution.base)),
              "--spice-subtext": this.generateSubtextColor(colorDistribution.base),
              "--spice-rgb-subtext": this.hexToRgb(this.generateSubtextColor(colorDistribution.base)),
              "--spice-highlight-elevated": colorDistribution.surface2,
              "--spice-rgb-highlight-elevated": rgbDistribution.surface2,
              // Missing Catppuccin overlay system (CRITICAL for background hierarchy)
              "--spice-overlay0": this.generateOverlayColor(colorDistribution.base, 0.04),
              "--spice-rgb-overlay0": this.hexToRgb(this.generateOverlayColor(colorDistribution.base, 0.04)),
              "--spice-overlay1": this.generateOverlayColor(colorDistribution.base, 0.08),
              "--spice-rgb-overlay1": this.hexToRgb(this.generateOverlayColor(colorDistribution.base, 0.08)),
              "--spice-overlay2": this.generateOverlayColor(colorDistribution.base, 0.12),
              "--spice-rgb-overlay2": this.hexToRgb(this.generateOverlayColor(colorDistribution.base, 0.12)),
              "--spice-crust": this.generateCrustColor(colorDistribution.base),
              "--spice-rgb-crust": this.hexToRgb(this.generateCrustColor(colorDistribution.base)),
              "--spice-mantle": this.generateMantleColor(colorDistribution.base),
              "--spice-rgb-mantle": this.hexToRgb(this.generateMantleColor(colorDistribution.base))
            };
            const neuralSpicetifyUpdates = {
              "--spice-blue": colorDistribution.neuralPrimary,
              "--spice-rgb-blue": rgbDistribution.neuralPrimary,
              "--spice-mauve": colorDistribution.neuralSecondary,
              "--spice-rgb-mauve": rgbDistribution.neuralSecondary,
              "--spice-teal": colorDistribution.neuralTertiary,
              "--spice-rgb-teal": rgbDistribution.neuralTertiary,
              // ZONE SYSTEM: Context-aware color variables for different UI zones
              "--spice-flamingo": this.generateZoneColor(colorDistribution.primary, "flamingo"),
              // Zone home secondary
              "--spice-rgb-flamingo": this.hexToRgb(this.generateZoneColor(colorDistribution.primary, "flamingo")),
              "--spice-lavender": this.generateZoneColor(colorDistribution.highlight, "lavender"),
              // Zone playlist/search primary
              "--spice-rgb-lavender": this.hexToRgb(this.generateZoneColor(colorDistribution.highlight, "lavender")),
              "--spice-peach": this.generateZoneColor(colorDistribution.surface2, "peach"),
              // Zone artist primary
              "--spice-rgb-peach": this.hexToRgb(this.generateZoneColor(colorDistribution.surface2, "peach")),
              "--spice-rosewater": this.generateZoneColor(colorDistribution.surface1, "rosewater"),
              // Zone artist/home secondary
              "--spice-rgb-rosewater": this.hexToRgb(this.generateZoneColor(colorDistribution.surface1, "rosewater")),
              "--spice-sapphire": this.generateZoneColor(colorDistribution.neuralPrimary, "sapphire"),
              // Zone search secondary
              "--spice-rgb-sapphire": this.hexToRgb(this.generateZoneColor(colorDistribution.neuralPrimary, "sapphire"))
            };
            const paletteSpicetifyUpdates = {
              "--spice-pink": this.generatePaletteColor(colorDistribution.primary, "pink"),
              "--spice-rgb-pink": this.hexToRgb(this.generatePaletteColor(colorDistribution.primary, "pink")),
              "--spice-sky": this.generatePaletteColor(colorDistribution.neuralPrimary, "sky"),
              "--spice-rgb-sky": this.hexToRgb(this.generatePaletteColor(colorDistribution.neuralPrimary, "sky")),
              "--spice-red": this.generatePaletteColor(colorDistribution.highlight, "red"),
              // Used for errors
              "--spice-rgb-red": this.hexToRgb(this.generatePaletteColor(colorDistribution.highlight, "red")),
              "--spice-maroon": this.generatePaletteColor(colorDistribution.shadow, "maroon"),
              "--spice-rgb-maroon": this.hexToRgb(this.generatePaletteColor(colorDistribution.shadow, "maroon")),
              "--spice-yellow": this.generatePaletteColor(colorDistribution.surface2, "yellow"),
              // Used for warnings
              "--spice-rgb-yellow": this.hexToRgb(this.generatePaletteColor(colorDistribution.surface2, "yellow")),
              "--spice-green": this.generatePaletteColor(colorDistribution.neuralTertiary, "green"),
              // Used for success
              "--spice-rgb-green": this.hexToRgb(this.generatePaletteColor(colorDistribution.neuralTertiary, "green")),
              "--spice-misc": colorDistribution.surface1,
              // Neutral grey from palette
              "--spice-rgb-misc": rgbDistribution.surface1
            };
            const effectsSpicetifyUpdates = {
              // Shimmer effect colors (neural consciousness colors for harmonious shimmer)
              "--spice-shimmer-primary": colorDistribution.neuralPrimary,
              "--spice-rgb-shimmer-primary": rgbDistribution.neuralPrimary,
              "--spice-shimmer-secondary": colorDistribution.neuralSecondary,
              "--spice-rgb-shimmer-secondary": rgbDistribution.neuralSecondary,
              "--spice-shimmer-tertiary": colorDistribution.neuralTertiary,
              "--spice-rgb-shimmer-tertiary": rgbDistribution.neuralTertiary,
              "--spice-shimmer-quaternary": colorDistribution.primary,
              "--spice-rgb-shimmer-quaternary": rgbDistribution.primary,
              // Particle consciousness colors
              "--spice-particle-glow": colorDistribution.highlight,
              "--spice-rgb-particle-glow": rgbDistribution.highlight,
              "--spice-particle-core": colorDistribution.primary,
              "--spice-rgb-particle-core": rgbDistribution.primary,
              "--spice-particle-trail": colorDistribution.shadow,
              "--spice-rgb-particle-trail": rgbDistribution.shadow,
              // Cinematic drama colors (high contrast variants)
              "--spice-cinematic-red": this.generateCinematicRed(colorDistribution.primary),
              "--spice-rgb-cinematic-red": this.hexToRgb(this.generateCinematicRed(colorDistribution.primary)),
              "--spice-cinematic-cyan": this.generateCinematicCyan(colorDistribution.primary),
              "--spice-rgb-cinematic-cyan": this.hexToRgb(this.generateCinematicCyan(colorDistribution.primary)),
              "--spice-cinematic-yellow": this.generateCinematicYellow(colorDistribution.highlight),
              "--spice-rgb-cinematic-yellow": this.hexToRgb(this.generateCinematicYellow(colorDistribution.highlight)),
              // Holographic UI colors (ethereal variants)
              "--spice-holographic-primary": this.generateHolographicPrimary(colorDistribution.primary),
              "--spice-rgb-holographic-primary": this.hexToRgb(this.generateHolographicPrimary(colorDistribution.primary)),
              "--spice-holographic-accent": this.generateHolographicAccent(colorDistribution.neuralPrimary),
              "--spice-rgb-holographic-accent": this.hexToRgb(this.generateHolographicAccent(colorDistribution.neuralPrimary)),
              "--spice-holographic-glow": this.generateHolographicGlow(colorDistribution.highlight),
              "--spice-rgb-holographic-glow": this.hexToRgb(this.generateHolographicGlow(colorDistribution.highlight))
            };
            const allSpicetifyUpdates = {
              ...coreSpicetifyUpdates,
              ...criticalSpicetifyUpdates,
              ...coreLayoutSpicetifyUpdates,
              ...neuralSpicetifyUpdates,
              ...paletteSpicetifyUpdates,
              ...effectsSpicetifyUpdates
            };
            this.cssController.batchSetVariables(
              "SemanticColorManager",
              allSpicetifyUpdates,
              "critical",
              // Critical priority for album color coordination
              "album-spicetify-update"
            );
            const starryNightUpdates = {
              "--sn-bg-gradient-accent": colorDistribution.primary,
              "--sn-bg-gradient-accent-rgb": rgbDistribution.primary,
              "--sn-bg-gradient-primary": colorDistribution.primary,
              "--sn-bg-gradient-primary-rgb": rgbDistribution.primary,
              "--sn-bg-gradient-secondary": colorDistribution.surface1,
              "--sn-bg-gradient-secondary-rgb": rgbDistribution.surface1
            };
            this.cssController.batchSetVariables(
              "SemanticColorManager",
              starryNightUpdates,
              "critical",
              // Critical priority for StarryNight gradient synchronization
              "album-starrynight-update"
            );
            const snColorUpdates = {
              "--sn-color-accent-hex": colorDistribution.primary,
              "--sn-color-accent-rgb": rgbDistribution.primary,
              "--sn-accent-hex": colorDistribution.primary,
              "--sn-accent-rgb": rgbDistribution.primary,
              "--sn-color-extracted-primary-rgb": rgbDistribution.primary,
              "--sn-color-extracted-secondary-rgb": rgbDistribution.surface1,
              "--sn-color-harmony-complementary-rgb": rgbDistribution.shadow,
              "--sn-color-harmony-analogous-rgb": rgbDistribution.highlight,
              "--sn-color-harmony-triadic-rgb": rgbDistribution.neuralPrimary
            };
            this.cssController.batchSetVariables(
              "SemanticColorManager",
              snColorUpdates,
              "critical",
              // Critical priority for Year 3000 System integration
              "album-y3k-integration-update"
            );
            this.clearCache();
            this.lastColorUpdate = Date.now();
            this.colorUpdateCount++;
            const totalVariablesUpdated = Object.keys(allSpicetifyUpdates).length + Object.keys(starryNightUpdates).length + Object.keys(snColorUpdates).length;
            unifiedEventBus.emitSync("colors:applied", {
              cssVariables: {
                ...allSpicetifyUpdates,
                ...starryNightUpdates,
                ...snColorUpdates
              },
              accentHex: colorDistribution.primary,
              accentRgb: rgbDistribution.primary,
              appliedAt: this.lastColorUpdate
            });
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] Comprehensive Spicetify variable update with OKLAB album colors:", {
                primaryColor: colorDistribution.primary,
                accentColor: colorDistribution.surface1,
                shadowColor: colorDistribution.shadow,
                highlightColor: colorDistribution.highlight,
                surfaceProgression: [colorDistribution.base, colorDistribution.surface0, colorDistribution.surface1, colorDistribution.surface2],
                neuralColors: [colorDistribution.neuralPrimary, colorDistribution.neuralSecondary, colorDistribution.neuralTertiary],
                effectColors: {
                  shimmerColors: 4,
                  // primary, secondary, tertiary, quaternary
                  particleColors: 3,
                  // glow, core, trail
                  cinematicColors: 3,
                  // red, cyan, yellow
                  holographicColors: 3
                  // primary, accent, glow
                },
                totalSpicetifyVariablesUpdated: Object.keys(allSpicetifyUpdates).length,
                coreLayoutVariablesUpdated: Object.keys(coreLayoutSpicetifyUpdates).length,
                starryNightVariablesUpdated: Object.keys(starryNightUpdates).length,
                snColorVariablesUpdated: Object.keys(snColorUpdates).length,
                effectVariablesAdded: Object.keys(effectsSpicetifyUpdates).length,
                eventEmitted: true,
                totalVariablesUpdated
              });
            }
          } catch (error) {
            console.error("[SemanticColorManager] Failed to update with album colors:", error);
          }
        }
        /**
         * Generate intelligent color distribution for comprehensive Spicetify variable coverage
         * Uses OKLAB-inspired color science for perceptually uniform depth progression and neural networks
         */
        generateIntelligentColorDistribution(primaryColor, accentColor, shadowColor, highlightColor) {
          const primary = primaryColor;
          const accent = accentColor || primaryColor;
          const shadow = shadowColor || this.generateDarkerVariant(primaryColor, 0.3);
          const highlight = highlightColor || this.generateLighterVariant(primaryColor, 0.2);
          const base = this.generateDarkerVariant(primaryColor, 0.6);
          const surface0 = this.generateDarkerVariant(primaryColor, 0.4);
          const surface1 = accent;
          const surface2 = this.generateLighterVariant(accent, 0.15);
          const neuralPrimary = this.generateHueRotatedColor(primaryColor, 120);
          const neuralSecondary = this.generateHueRotatedColor(primaryColor, -60);
          const neuralTertiary = this.generateHueRotatedColor(primaryColor, 180);
          return {
            primary,
            surface0,
            surface1,
            surface2,
            base,
            shadow,
            highlight,
            neuralPrimary,
            neuralSecondary,
            neuralTertiary
          };
        }
        /**
         * Convert color distribution object to RGB strings for CSS variables
         */
        convertColorsToRgb(colorDistribution) {
          const rgbDistribution = {};
          Object.entries(colorDistribution).forEach(([key, hexColor]) => {
            rgbDistribution[key] = this.hexToRgb(hexColor);
          });
          return rgbDistribution;
        }
        /**
         * Generate a darker variant of a color by reducing lightness
         */
        generateDarkerVariant(hexColor, factor) {
          try {
            const rgb = this.hexToRgbObject(hexColor);
            if (!rgb) return hexColor;
            const r = Math.max(0, Math.round(rgb.r * (1 - factor)));
            const g = Math.max(0, Math.round(rgb.g * (1 - factor)));
            const b = Math.max(0, Math.round(rgb.b * (1 - factor)));
            return this.rgbToHex(r, g, b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate darker variant:", error);
            return hexColor;
          }
        }
        /**
         * Generate a lighter variant of a color by increasing lightness
         */
        generateLighterVariant(hexColor, factor) {
          try {
            const rgb = this.hexToRgbObject(hexColor);
            if (!rgb) return hexColor;
            const r = Math.min(255, Math.round(rgb.r + (255 - rgb.r) * factor));
            const g = Math.min(255, Math.round(rgb.g + (255 - rgb.g) * factor));
            const b = Math.min(255, Math.round(rgb.b + (255 - rgb.b) * factor));
            return this.rgbToHex(r, g, b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate lighter variant:", error);
            return hexColor;
          }
        }
        /**
         * Generate a hue-rotated variant of a color for neural consciousness systems
         */
        generateHueRotatedColor(hexColor, hueDegrees) {
          try {
            const rgb = this.hexToRgbObject(hexColor);
            if (!rgb) return hexColor;
            const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
            hsl.h = (hsl.h + hueDegrees) % 360;
            if (hsl.h < 0) hsl.h += 360;
            const rotatedRgb = this.hslToRgb(hsl.h, hsl.s, hsl.l);
            return this.rgbToHex(rotatedRgb.r, rotatedRgb.g, rotatedRgb.b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate hue-rotated color:", error);
            return hexColor;
          }
        }
        /**
         * Convert hex color to RGB object
         */
        hexToRgbObject(hex) {
          const cleanHex = hex.replace("#", "");
          if (cleanHex.length !== 6) return null;
          const r = parseInt(cleanHex.substring(0, 2), 16);
          const g = parseInt(cleanHex.substring(2, 4), 16);
          const b = parseInt(cleanHex.substring(4, 6), 16);
          return { r, g, b };
        }
        /**
         * Convert RGB values to hex string
         */
        rgbToHex(r, g, b) {
          const toHex = /* @__PURE__ */ __name((n) => {
            const hex = Math.round(Math.max(0, Math.min(255, n))).toString(16);
            return hex.length === 1 ? "0" + hex : hex;
          }, "toHex");
          return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
        /**
         * Convert RGB to HSL for hue manipulation
         */
        rgbToHsl(r, g, b) {
          r /= 255;
          g /= 255;
          b /= 255;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h = 0;
          let s = 0;
          const l = (max + min) / 2;
          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return { h: h * 360, s: s * 100, l: l * 100 };
        }
        /**
         * Convert HSL back to RGB
         */
        hslToRgb(h, s, l) {
          h /= 360;
          s /= 100;
          l /= 100;
          const hue2rgb = /* @__PURE__ */ __name((p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          }, "hue2rgb");
          let r, g, b;
          if (s === 0) {
            r = g = b = l;
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
          };
        }
        /**
         * Convert hex color to RGB string for CSS variables
         */
        hexToRgb(hex) {
          const cleanHex = hex.replace("#", "");
          const r = parseInt(cleanHex.substring(0, 2), 16);
          const g = parseInt(cleanHex.substring(2, 4), 16);
          const b = parseInt(cleanHex.substring(4, 6), 16);
          return `${r}, ${g}, ${b}`;
        }
        getColorMappings() {
          return _SemanticColorManager.SEMANTIC_MAPPINGS;
        }
        //  PHASE 3: Effect-Specific Color Generators
        // Generate specialized colors for visual effect systems
        /**
         * Generate cinematic red color with high contrast characteristics
         * Based on album color psychology for dramatic effects
         */
        generateCinematicRed(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#FF0000";
            const dramaticRed = Math.min(255, rgb.r + 100);
            const warmGreen = Math.max(0, Math.min(rgb.g * 0.3, 100));
            const warmBlue = Math.max(0, Math.min(rgb.b * 0.2, 80));
            return this.rgbToHex(dramaticRed, warmGreen, warmBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate cinematic red:", error);
            return "#FF0000";
          }
        }
        /**
         * Generate cinematic cyan color complementary to the base color
         * Creates high contrast cyan for dramatic visual effects
         */
        generateCinematicCyan(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#00FFFF";
            const dramaticGreen = Math.min(255, rgb.g + 120);
            const dramaticBlue = Math.min(255, rgb.b + 140);
            const coolRed = Math.max(0, Math.min(rgb.r * 0.2, 60));
            return this.rgbToHex(coolRed, dramaticGreen, dramaticBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate cinematic cyan:", error);
            return "#00FFFF";
          }
        }
        /**
         * Generate cinematic yellow for accent dramatic effects
         * Bright, attention-grabbing yellow based on highlight color
         */
        generateCinematicYellow(highlightColor) {
          try {
            const rgb = this.hexToRgbObject(highlightColor);
            if (!rgb) return "#FFFF00";
            const brightRed = Math.min(255, rgb.r + 80);
            const brightGreen = Math.min(255, rgb.g + 100);
            const subtleBlue = Math.max(0, Math.min(rgb.b * 0.3, 120));
            return this.rgbToHex(brightRed, brightGreen, subtleBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate cinematic yellow:", error);
            return "#FFFF00";
          }
        }
        /**
         * Generate holographic primary color with ethereal characteristics
         * Creates iridescent, otherworldly color based on album primary
         */
        generateHolographicPrimary(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#8A2BE2";
            const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
            const enhancedSaturation = Math.min(1, hsl.s + 0.3);
            const etherealLightness = Math.min(0.8, Math.max(0.4, hsl.l + 0.1));
            const enhancedRgb = this.hslToRgb(hsl.h, enhancedSaturation, etherealLightness);
            return this.rgbToHex(enhancedRgb.r, enhancedRgb.g, enhancedRgb.b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate holographic primary:", error);
            return "#8A2BE2";
          }
        }
        /**
         * Generate holographic accent color with prismatic shift
         * Creates complementary holographic color for accent effects
         */
        generateHolographicAccent(neuralColor) {
          try {
            return this.generateHueRotatedColor(neuralColor, 45);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate holographic accent:", error);
            return "#FF00FF";
          }
        }
        /**
         * Generate holographic glow color for ethereal lighting effects
         * Creates soft, luminous glow based on highlight color
         */
        generateHolographicGlow(highlightColor) {
          try {
            const rgb = this.hexToRgbObject(highlightColor);
            if (!rgb) return "#E0E0FF";
            const glowIntensity = 0.7;
            const glowRed = Math.min(255, rgb.r + (255 - rgb.r) * glowIntensity);
            const glowGreen = Math.min(255, rgb.g + (255 - rgb.g) * glowIntensity);
            const glowBlue = Math.min(255, rgb.b + (255 - rgb.b) * glowIntensity);
            return this.rgbToHex(glowRed, glowGreen, glowBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate holographic glow:", error);
            return "#E0E0FF";
          }
        }
        /**
         * Generate high contrast text color based on background color
         * Creates optimal text readability for consciousness-aware design
         */
        generateTextColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#CAD3F5";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              return "#24273A";
            } else {
              return "#CAD3F5";
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate text color:", error);
            return "#CAD3F5";
          }
        }
        /**
         * Generate medium contrast subdued text color
         * Creates secondary text with reduced contrast for hierarchy
         */
        generateSubtextColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#A5ADCB";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              return "#5B6078";
            } else {
              return "#A5ADCB";
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate subtext color:", error);
            return "#A5ADCB";
          }
        }
        /**
         * Generate progressive overlay colors for background depth hierarchy
         * Creates Catppuccin-style overlay colors with OKLAB-enhanced base
         */
        generateOverlayColor(baseColor, opacity) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return `rgba(88,91,112,${opacity})`;
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              const factor = 1 - opacity * 2;
              const overlayRed = Math.max(0, Math.round(rgb.r * factor));
              const overlayGreen = Math.max(0, Math.round(rgb.g * factor));
              const overlayBlue = Math.max(0, Math.round(rgb.b * factor));
              return this.rgbToHex(overlayRed, overlayGreen, overlayBlue);
            } else {
              const factor = opacity * 255;
              const overlayRed = Math.min(255, Math.round(rgb.r + factor));
              const overlayGreen = Math.min(255, Math.round(rgb.g + factor));
              const overlayBlue = Math.min(255, Math.round(rgb.b + factor));
              return this.rgbToHex(overlayRed, overlayGreen, overlayBlue);
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate overlay color:", error);
            return `rgba(88,91,112,${opacity})`;
          }
        }
        /**
         * Generate window frame/border crust color
         * Creates subtle border color for window chrome elements
         */
        generateCrustColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#232634";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              const crustRed = Math.max(0, Math.round(rgb.r * 0.8));
              const crustGreen = Math.max(0, Math.round(rgb.g * 0.8));
              const crustBlue = Math.max(0, Math.round(rgb.b * 0.8));
              return this.rgbToHex(crustRed, crustGreen, crustBlue);
            } else {
              const crustRed = Math.min(255, Math.round(rgb.r + 20));
              const crustGreen = Math.min(255, Math.round(rgb.g + 20));
              const crustBlue = Math.min(255, Math.round(rgb.b + 20));
              return this.rgbToHex(crustRed, crustGreen, crustBlue);
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate crust color:", error);
            return "#232634";
          }
        }
        /**
         * Generate window background mantle color
         * Creates intermediate color between base and overlay0 for window backgrounds
         */
        generateMantleColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#1e2030";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              const mantleRed = Math.max(0, Math.round(rgb.r * 0.95));
              const mantleGreen = Math.max(0, Math.round(rgb.g * 0.95));
              const mantleBlue = Math.max(0, Math.round(rgb.b * 0.95));
              return this.rgbToHex(mantleRed, mantleGreen, mantleBlue);
            } else {
              const mantleRed = Math.min(255, Math.round(rgb.r + 10));
              const mantleGreen = Math.min(255, Math.round(rgb.g + 10));
              const mantleBlue = Math.min(255, Math.round(rgb.b + 10));
              return this.rgbToHex(mantleRed, mantleGreen, mantleBlue);
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate mantle color:", error);
            return "#1e2030";
          }
        }
        /**
         * Generate zone-specific colors with consciousness-aware hue shifts
         * Creates contextual color variations for different UI zones (home, playlist, artist, search)
         */
        generateZoneColor(baseColor, zoneType) {
          try {
            const rgb = hexToRgb(baseColor);
            if (!rgb) {
              console.warn(`\u{1F527} [SemanticColorManager] Failed to parse RGB from ${baseColor}`);
              return baseColor;
            }
            const zoneAdjustments = {
              flamingo: { rAdjust: 20, gAdjust: -10, bAdjust: -5 },
              // Warm pink for home comfort
              lavender: { rAdjust: 10, gAdjust: -5, bAdjust: 15 },
              // Cool purple for focus/playlist
              peach: { rAdjust: 25, gAdjust: 10, bAdjust: -15 },
              // Warm orange for artist discovery
              rosewater: { rAdjust: 15, gAdjust: -8, bAdjust: 0 },
              // Subtle pink for secondary elements
              sapphire: { rAdjust: -20, gAdjust: -10, bAdjust: 25 }
              // Deep blue for search precision
            };
            const config = zoneAdjustments[zoneType];
            const adjustedR = Math.max(0, Math.min(255, rgb.r + config.rAdjust));
            const adjustedG = Math.max(0, Math.min(255, rgb.g + config.gAdjust));
            const adjustedB = Math.max(0, Math.min(255, rgb.b + config.bAdjust));
            const zoneHex = rgbToHex(adjustedR, adjustedG, adjustedB);
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [SemanticColorManager] Generated ${zoneType} color: ${baseColor} \u2192 ${zoneHex} (RGB: ${rgb.r},${rgb.g},${rgb.b} \u2192 ${adjustedR},${adjustedG},${adjustedB})`);
            }
            return zoneHex;
          } catch (error) {
            console.warn(`\u{1F527} [SemanticColorManager] Failed to generate ${zoneType} color for "${baseColor}":`, error);
            return baseColor;
          }
        }
        /**
         * Generate palette-specific colors with consciousness-aware variations
         * Creates color variations for Catppuccin palette colors (pink, sky, red, maroon, yellow, green)
         */
        generatePaletteColor(baseColor, paletteType) {
          try {
            const rgb = hexToRgb(baseColor);
            if (!rgb) {
              console.warn(`\u{1F527} [SemanticColorManager] Failed to parse RGB from ${baseColor}`);
              return baseColor;
            }
            const paletteAdjustments = {
              pink: { rAdjust: 30, gAdjust: -20, bAdjust: -10 },
              // Soft pink for decorative elements
              sky: { rAdjust: -30, gAdjust: 10, bAdjust: 30 },
              // Bright sky blue for information
              red: { rAdjust: 35, gAdjust: -25, bAdjust: -15 },
              // Vibrant red for errors/warnings
              maroon: { rAdjust: 25, gAdjust: -15, bAdjust: -10 },
              // Deep maroon for emphasis
              yellow: { rAdjust: 30, gAdjust: 25, bAdjust: -30 },
              // Bright yellow for warnings
              green: { rAdjust: -25, gAdjust: 30, bAdjust: -20 }
              // Natural green for success
            };
            const config = paletteAdjustments[paletteType];
            const adjustedR = Math.max(0, Math.min(255, rgb.r + config.rAdjust));
            const adjustedG = Math.max(0, Math.min(255, rgb.g + config.gAdjust));
            const adjustedB = Math.max(0, Math.min(255, rgb.b + config.bAdjust));
            const paletteHex = rgbToHex(adjustedR, adjustedG, adjustedB);
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [SemanticColorManager] Generated ${paletteType} color: ${baseColor} \u2192 ${paletteHex} (RGB: ${rgb.r},${rgb.g},${rgb.b} \u2192 ${adjustedR},${adjustedG},${adjustedB})`);
            }
            return paletteHex;
          } catch (error) {
            console.warn(`\u{1F527} [SemanticColorManager] Failed to generate ${paletteType} color for "${baseColor}":`, error);
            return baseColor;
          }
        }
        destroy() {
          try {
            this.cleanupEventSubscriptions();
            this.clearCache();
            this.cssController = null;
            this.initialized = false;
            this.lastColorUpdate = 0;
            this.colorUpdateCount = 0;
            unifiedEventBus.emitSync("system:destroyed", {
              systemName: "SemanticColorManager",
              timestamp: Date.now(),
              reason: "Manual destruction"
            });
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] System destroyed and cleaned up");
            }
          } catch (error) {
            console.error("[SemanticColorManager] Error during destruction:", error);
          }
        }
        /**
         * IManagedSystem interface implementation
         */
        updateAnimation(deltaTime) {
        }
        /**
         * IManagedSystem health check implementation
         */
        async healthCheck() {
          const healthResult = {
            system: "SemanticColorManager",
            healthy: true,
            details: "SemanticColorManager operational",
            issues: [],
            metrics: {
              initialized: this.initialized,
              spicetifyAvailable: this.isSpicetifyAvailable(),
              cssConsciousnessAvailable: !!this.cssController,
              lastColorUpdate: this.lastColorUpdate,
              colorUpdateCount: this.colorUpdateCount,
              eventSubscriptions: this.eventSubscriptionIds.length,
              cacheSize: this.colorCache.size,
              lastCacheUpdate: this.lastCacheUpdate
            }
          };
          if (!this.initialized) {
            healthResult.healthy = false;
            healthResult.issues.push("System not initialized");
          }
          if (!this.isSpicetifyAvailable()) {
            healthResult.healthy = false;
            healthResult.issues.push("Spicetify API not available");
          }
          if (this.colorUpdateCount === 0 && this.initialized) {
            healthResult.issues.push("No color updates performed since initialization");
          }
          if (this.eventSubscriptionIds.length === 0 && this.initialized) {
            healthResult.issues.push("No event subscriptions active");
          }
          if (healthResult.issues.length > 0) {
            healthResult.details = `Issues detected: ${healthResult.issues.join(", ")}`;
            if (healthResult.issues.length >= 2) {
              healthResult.healthy = false;
            }
          }
          return healthResult;
        }
        /**
         * Setup event subscriptions for system integration
         */
        setupEventSubscriptions() {
          const trackChangeId = unifiedEventBus.subscribe(
            "music:track-changed",
            async (data) => {
              if (this.config.enableDebug) {
                console.log("\u{1F3A8} [SemanticColorManager] Track changed, preparing for color refresh:", data.trackUri);
              }
              this.clearCache();
            },
            "SemanticColorManager"
          );
          const settingsChangeId = unifiedEventBus.subscribe(
            "settings:changed",
            async (data) => {
              if (data.settingKey.includes("color") || data.settingKey.includes("theme")) {
                if (this.config.enableDebug) {
                  console.log("\u{1F3A8} [SemanticColorManager] Color-related setting changed:", data.settingKey);
                }
                this.clearCache();
              }
            },
            "SemanticColorManager"
          );
          this.eventSubscriptionIds = [trackChangeId, settingsChangeId];
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [SemanticColorManager] Event subscriptions established:", this.eventSubscriptionIds.length);
          }
        }
        /**
         * Clean up event subscriptions
         */
        cleanupEventSubscriptions() {
          for (const subscriptionId of this.eventSubscriptionIds) {
            unifiedEventBus.unsubscribe(subscriptionId);
          }
          this.eventSubscriptionIds = [];
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [SemanticColorManager] Event subscriptions cleaned up");
          }
        }
        /**
         * Get system metrics for monitoring
         */
        getSystemMetrics() {
          return {
            initialized: this.initialized,
            lastColorUpdate: this.lastColorUpdate,
            colorUpdateCount: this.colorUpdateCount,
            eventSubscriptions: this.eventSubscriptionIds.length,
            cacheSize: this.colorCache.size,
            spicetifyAvailable: this.isSpicetifyAvailable()
          };
        }
      };
      __name(_SemanticColorManager, "SemanticColorManager");
      // Semantic color mappings to our CSS variables
      _SemanticColorManager.SEMANTIC_MAPPINGS = [
        // Text colors (Catppuccin Macchiato)
        { semanticColor: "textBase", cssVariable: "--spice-text", fallbackColor: "#cad3f5", description: "Primary text color" },
        { semanticColor: "textSubdued", cssVariable: "--spice-subtext", fallbackColor: "#a5adcb", description: "Secondary text color" },
        { semanticColor: "textBrightAccent", cssVariable: "--spice-accent", fallbackColor: "#c6a0f6", description: "Accent text color" },
        { semanticColor: "textNegative", cssVariable: "--spice-red", fallbackColor: "#ed8796", description: "Error text color" },
        { semanticColor: "textWarning", cssVariable: "--spice-yellow", fallbackColor: "#eed49f", description: "Warning text color" },
        { semanticColor: "textPositive", cssVariable: "--spice-green", fallbackColor: "#a6da95", description: "Success text color" },
        { semanticColor: "textAnnouncement", cssVariable: "--spice-blue", fallbackColor: "#8aadf4", description: "Info text color" },
        // Essential colors (for icons, controls) - Catppuccin Macchiato
        { semanticColor: "essentialBase", cssVariable: "--spice-button", fallbackColor: "#cad3f5", description: "Primary button color" },
        { semanticColor: "essentialSubdued", cssVariable: "--spice-button-disabled", fallbackColor: "#6e738d", description: "Disabled button color" },
        { semanticColor: "essentialBrightAccent", cssVariable: "--spice-button-active", fallbackColor: "#c6a0f6", description: "Active button color" },
        { semanticColor: "essentialNegative", cssVariable: "--spice-notification-error", fallbackColor: "#ed8796", description: "Error button color" },
        { semanticColor: "essentialWarning", cssVariable: "--spice-notification-warning", fallbackColor: "#eed49f", description: "Warning button color" },
        { semanticColor: "essentialPositive", cssVariable: "--spice-notification-success", fallbackColor: "#a6da95", description: "Success button color" },
        // Background colors - Catppuccin Macchiato
        { semanticColor: "backgroundBase", cssVariable: "--spice-main", fallbackColor: "#24273a", description: "Main background color" },
        { semanticColor: "backgroundHighlight", cssVariable: "--spice-highlight", fallbackColor: "#363a4f", description: "Highlight background color" },
        { semanticColor: "backgroundPress", cssVariable: "--spice-press", fallbackColor: "#494d64", description: "Press state background color" },
        { semanticColor: "backgroundElevatedBase", cssVariable: "--spice-card", fallbackColor: "#1e2030", description: "Card background color" },
        { semanticColor: "backgroundElevatedHighlight", cssVariable: "--spice-card-highlight", fallbackColor: "#363a4f", description: "Card highlight background" },
        { semanticColor: "backgroundTintedBase", cssVariable: "--spice-sidebar", fallbackColor: "#363a4f", description: "Sidebar background color" },
        { semanticColor: "backgroundTintedHighlight", cssVariable: "--spice-sidebar-highlight", fallbackColor: "#494d64", description: "Sidebar highlight background" },
        // Decorative colors - Catppuccin Macchiato
        { semanticColor: "decorativeBase", cssVariable: "--spice-decorative", fallbackColor: "#cad3f5", description: "Decorative element color" },
        { semanticColor: "decorativeSubdued", cssVariable: "--spice-decorative-subdued", fallbackColor: "#939ab7", description: "Subdued decorative color" }
      ];
      SemanticColorManager = _SemanticColorManager;
    }
  });

  // src-js/utils/graphics/VisualCanvasFactory.ts
  function detectWebGL2Support() {
    try {
      const testCanvas = document.createElement("canvas");
      const gl = testCanvas.getContext("webgl2");
      if (!gl) return false;
      const hasRequiredExtensions = gl.getExtension("EXT_color_buffer_float") !== null;
      return true;
    } catch (e) {
      return false;
    }
  }
  function createWebGL2Context(canvas, options) {
    try {
      const contextOptions = {
        alpha: options.alpha ?? true,
        antialias: options.antialias ?? true,
        preserveDrawingBuffer: options.preserveDrawingBuffer ?? false,
        powerPreference: "high-performance",
        failIfMajorPerformanceCaveat: false
      };
      const gl = canvas.getContext(
        "webgl2",
        contextOptions
      );
      if (!gl) return null;
      const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      return {
        canvas,
        ctx: gl,
        type: "webgl2",
        capabilities: {
          supportsGPUAcceleration: true,
          supports3D: true,
          maxTextureSize
        }
      };
    } catch (error) {
      console.warn(
        "[VisualCanvasFactory] WebGL2 context creation failed:",
        error
      );
      return null;
    }
  }
  function create2DContext(canvas, options) {
    const contextOptions = {
      alpha: options.alpha ?? true,
      desynchronized: true
      // Optimize for animations
    };
    const ctx = canvas.getContext(
      "2d",
      contextOptions
    );
    return {
      canvas,
      ctx,
      type: "2d",
      capabilities: {
        supportsGPUAcceleration: false,
        supports3D: false
      }
    };
  }
  async function createOptimizedCanvas(options) {
    const canvas = document.createElement("canvas");
    canvas.id = options.id;
    canvas.width = options.width ?? window.innerWidth;
    canvas.height = options.height ?? window.innerHeight;
    const fallbackChain = options.fallbackChain ?? ["webgl2", "2d"];
    if (options.preferredType) {
      const chain = [
        options.preferredType,
        ...fallbackChain.filter((t) => t !== options.preferredType)
      ];
      fallbackChain.splice(0, fallbackChain.length, ...chain);
    }
    for (const contextType of fallbackChain) {
      let result = null;
      switch (contextType) {
        case "webgl2":
          if (detectWebGL2Support()) {
            result = createWebGL2Context(canvas, options);
          }
          break;
        case "2d":
          result = create2DContext(canvas, options);
          break;
      }
      if (result) {
        return result;
      }
    }
    return create2DContext(canvas, options);
  }
  function detectRenderingCapabilities() {
    const webgl2 = detectWebGL2Support();
    let recommendedType = "2d";
    if (webgl2) {
      recommendedType = "webgl2";
    }
    return { webgl2, recommendedType };
  }
  var init_VisualCanvasFactory = __esm({
    "src-js/utils/graphics/VisualCanvasFactory.ts"() {
      "use strict";
      __name(detectWebGL2Support, "detectWebGL2Support");
      __name(createWebGL2Context, "createWebGL2Context");
      __name(create2DContext, "create2DContext");
      __name(createOptimizedCanvas, "createOptimizedCanvas");
      __name(detectRenderingCapabilities, "detectRenderingCapabilities");
    }
  });

  // src-js/utils/animation/visualPerformance.ts
  function selectPerformanceProfile(quality, performanceProfiles, opts = {}) {
    const { trace } = opts;
    if (!performanceProfiles || typeof performanceProfiles !== "object") {
      trace?.(
        "[visualPerformance] No performanceProfiles provided \u2013 skipping selection"
      );
      return null;
    }
    let selected = performanceProfiles[quality];
    if (!selected) {
      trace?.(
        `[visualPerformance] Profile '${quality}' not found, falling back to 'balanced'`
      );
      selected = performanceProfiles["balanced"];
    }
    if (!selected) {
      const firstKey = Object.keys(
        performanceProfiles
      )[0];
      selected = performanceProfiles[firstKey];
      trace?.(
        `[visualPerformance] Using first available profile '${firstKey}' as fallback`
      );
    }
    return selected;
  }
  var init_visualPerformance = __esm({
    "src-js/utils/animation/visualPerformance.ts"() {
      "use strict";
      __name(selectPerformanceProfile, "selectPerformanceProfile");
    }
  });

  // src-js/visual/base/BaseVisualSystem.ts
  var _BaseVisualSystem, BaseVisualSystem;
  var init_BaseVisualSystem = __esm({
    "src-js/visual/base/BaseVisualSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_VisualCanvasFactory();
      init_Year3000Utilities();
      init_visualPerformance();
      _BaseVisualSystem = class _BaseVisualSystem {
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, performanceMonitor, musicSyncService, settingsManager2) {
          // GPU-accelerated canvas support
          this.canvasCapabilities = null;
          this.activeCanvasResults = /* @__PURE__ */ new Map();
          this.config = config;
          this.utils = utils;
          this.performanceMonitor = performanceMonitor;
          this.musicSyncService = musicSyncService;
          this.settingsManager = settingsManager2;
          this.systemName = this.constructor.name;
          this.initialized = false;
          this.isActive = false;
          this.currentPerformanceProfile = {};
          this.metrics = {
            initializationTime: 0,
            updates: 0,
            errors: 0
          };
          this._resizeHandler = null;
          this.boundHandleSettingsChange = this.handleSettingsChange.bind(this);
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Constructor`);
          }
        }
        // Replace the current skeletal `initialize` method with this complete, multi-phase version.
        async initialize() {
          const initStartTime = this.config.enableDebug ? performance.now() : 0;
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing...`);
          }
          if (this.settingsManager) {
            document.addEventListener(
              "year3000SystemSettingsChanged",
              this.boundHandleSettingsChange
            );
            try {
              const detectorInstance = globalThis.year3000System?.deviceCapabilityDetector;
              let quality = "balanced";
              if (detectorInstance?.isInitialized) {
                quality = detectorInstance.recommendPerformanceQuality();
              }
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Auto-selected performance quality '${quality}' based on device capability.`);
              }
              this._applyPerformanceProfile(quality);
            } catch (e) {
              this.performanceMonitor?.emitTrace?.(
                `[${this.systemName}] Device capability detection failed; defaulting to 'balanced'.`,
                e
              );
              this._applyPerformanceProfile("balanced");
            }
          }
          await this._performSystemSpecificInitialization();
          this.initialized = true;
          this.isActive = true;
          if (this.musicSyncService) {
            if (this._validateDependenciesForSubscription()) {
              this.musicSyncService.subscribe(this, this.systemName);
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Subscribed to MusicSyncService.`);
              }
            } else {
              console.warn(
                `[${this.systemName}] Dependency validation failed; subscription skipped.`
              );
            }
          }
          if (this.config.enableDebug) {
            const duration = performance.now() - initStartTime;
            console.log(`[${this.systemName}] Initialization complete in ${duration.toFixed(2)}ms`);
          }
        }
        // Add new virtual methods for subclass extension.
        // These provide safe hooks for custom initialization logic.
        async _performSystemSpecificInitialization() {
          this.canvasCapabilities = detectRenderingCapabilities();
          if (this.canvasCapabilities) {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Canvas capabilities detected: WebGL2=${this.canvasCapabilities.webgl2}, Recommended=${this.canvasCapabilities.recommendedType}`
            );
          }
        }
        _validateDependenciesForSubscription() {
          if (typeof this.updateFromMusicAnalysis !== "function") {
            console.error(
              `[${this.systemName}] Missing updateFromMusicAnalysis method.`
            );
            return false;
          }
          if (!this.initialized) {
            console.warn(`[${this.systemName}] System not initialized.`);
            return false;
          }
          return this._performAdditionalDependencyValidation();
        }
        _performAdditionalDependencyValidation() {
          return true;
        }
        // Replace the current skeletal `destroy` method with this complete version for proper cleanup.
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying...`);
          }
          try {
            this.initialized = false;
            this.isActive = false;
            if (this.musicSyncService) {
              this.musicSyncService.unsubscribe(this.systemName);
            }
            if (this.settingsManager && this.boundHandleSettingsChange) {
              document.removeEventListener(
                "year3000SystemSettingsChanged",
                this.boundHandleSettingsChange
              );
            }
            if (this._resizeHandler) {
              window.removeEventListener("resize", this._resizeHandler);
              this._resizeHandler = null;
            }
            this._performSystemSpecificCleanup();
          } catch (error) {
            console.error(`[${this.systemName}] Error during destruction:`, error);
            this.metrics.errors++;
          }
        }
        // Add the virtual cleanup hook for subclasses.
        _performSystemSpecificCleanup() {
          for (const [id, canvasResult] of this.activeCanvasResults) {
            const canvas = canvasResult.canvas;
            if (canvas.parentNode) {
              canvas.parentNode.removeChild(canvas);
            }
            if (this.config.enableDebug) {
              console.log(
                `[${this.systemName}] Cleaned up canvas: ${id} (type: ${canvasResult.type})`
              );
            }
          }
          this.activeCanvasResults.clear();
        }
        updateFromMusicAnalysis(processedMusicData, ...args) {
        }
        /**
         * Unified animation hook called by MasterAnimationCoordinator.
         * Subclasses can override this method or implement updateAnimation for legacy support.
         *
         * @param deltaMs - Time in milliseconds since the last frame for this system
         */
        onAnimate(deltaMs) {
          if (typeof this.updateAnimation === "function") {
            this.updateAnimation(performance.now(), deltaMs);
          }
        }
        updateModeConfiguration(modeConfig) {
        }
        /**
         * Base implementation of the settings-change hook. It is intentionally empty
         * now that the legacy `sn-performanceQuality` key has been removed. Subclasses
         * should override this method if they need to respond to other settings keys
         * and are still encouraged to call `super.handleSettingsChange(event)`.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        handleSettingsChange(event) {
        }
        _applyPerformanceProfile(quality) {
          if (!this.config?.performanceProfiles) {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Performance profiles not found in config.`
            );
            return;
          }
          const profile = selectPerformanceProfile(
            quality,
            this.config.performanceProfiles,
            {
              trace: /* @__PURE__ */ __name((msg) => this.performanceMonitor?.emitTrace(msg), "trace")
            }
          );
          if (profile) {
            this.currentPerformanceProfile = profile;
            this.performanceMonitor?.emitTrace?.(
              `[BaseVisualSystem (${this.systemName})] Applied performance profile '${quality}'`,
              profile
            );
          } else {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Performance profile '${quality}' not found.`
            );
          }
        }
        getCosmicState() {
          if (typeof document === "undefined") return {};
          const root = document.documentElement;
          const style = getComputedStyle(root);
          return {
            energy: parseFloat(style.getPropertyValue("--sn-kinetic-energy")) || 0.5,
            valence: parseFloat(style.getPropertyValue("--sn-kinetic-valence")) || 0.5,
            bpm: parseFloat(style.getPropertyValue("--sn-kinetic-bpm")) || 120,
            tempoMultiplier: parseFloat(style.getPropertyValue("--sn-kinetic-tempo-multiplier")) || 1,
            beatPhase: parseFloat(style.getPropertyValue("--sn-kinetic-beat-phase")) || 0,
            beatPulse: parseFloat(style.getPropertyValue("--sn-kinetic-beat-pulse")) || 0
          };
        }
        /**
         * Create GPU-accelerated optimized canvas with kinetic styling.
         * This method prioritizes WebGL2 > 2D Canvas based on device capabilities.
         */
        async _createOptimizedKineticCanvas(id, zIndex = 5, blendMode = "screen", kineticMode = "pulse") {
          const existing = document.getElementById(id);
          if (existing) {
            existing.remove();
          }
          let preferredType = "2d";
          if (this.canvasCapabilities && this.currentPerformanceProfile) {
            const quality = this.currentPerformanceProfile.quality || "balanced";
            if (quality !== "low" && this.canvasCapabilities.webgl2) {
              preferredType = "webgl2";
            }
          }
          const canvasResult = await createOptimizedCanvas({
            id,
            width: window.innerWidth,
            height: window.innerHeight,
            alpha: true,
            antialias: true,
            preferredType
          });
          const canvas = canvasResult.canvas;
          canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: ${zIndex};
      pointer-events: none;
      mix-blend-mode: ${blendMode};
    `;
          canvas.classList.add("year3000-kinetic-canvas");
          canvas.dataset.kineticMode = kineticMode;
          canvas.dataset.systemName = this.systemName;
          canvas.dataset.canvasType = canvasResult.type;
          const kineticStyles = this._getKineticStyles(kineticMode);
          Object.assign(canvas.style, kineticStyles);
          document.body.appendChild(canvas);
          this.activeCanvasResults.set(id, canvasResult);
          this._resizeHandler = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (typeof this.handleResize === "function") {
              this.handleResize();
            }
          };
          window.addEventListener("resize", this._resizeHandler);
          this._resizeHandler();
          if (this.config.enableDebug) {
            console.log(
              `[BaseVisualSystem (${this.systemName})] Created optimized kinetic canvas: ${canvasResult.type} (mode: ${kineticMode})`
            );
          }
          return canvasResult;
        }
        /**
         * Get current canvas rendering capabilities.
         */
        getCanvasCapabilities() {
          return this.canvasCapabilities;
        }
        /**
         * Check if GPU acceleration is available and active.
         */
        hasGPUAcceleration() {
          return this.canvasCapabilities?.webgl2 || false;
        }
        _createKineticCanvas(id, zIndex = 5, blendMode = "screen", kineticMode = "pulse") {
          const canvas = this._createCanvasElement(id, zIndex, blendMode);
          canvas.classList.add("year3000-kinetic-canvas");
          canvas.dataset.kineticMode = kineticMode;
          canvas.dataset.systemName = this.systemName;
          const kineticStyles = this._getKineticStyles(kineticMode);
          Object.assign(canvas.style, kineticStyles);
          if (this.config.enableDebug) {
            console.log(
              `[BaseVisualSystem (${this.systemName})] Created kinetic canvas with mode: ${kineticMode}`
            );
          }
          return canvas;
        }
        _getKineticStyles(kineticMode) {
          const baseStyles = {
            transition: "all 150ms cubic-bezier(0.25, 0.46, 0.45, 0.94)"
          };
          switch (kineticMode) {
            case "pulse":
              return {
                ...baseStyles,
                animation: "year3000-pulse calc(var(--sn-kinetic-tempo-multiplier, 1) * 1s) ease-in-out infinite"
              };
            case "breathe":
              return {
                ...baseStyles,
                animation: "year3000-breathe calc(var(--sn-kinetic-tempo-multiplier, 1) * 4s) ease-in-out infinite"
              };
            case "flow":
              return {
                ...baseStyles,
                animation: "year3000-flow calc(var(--sn-kinetic-tempo-multiplier, 1) * 8s) linear infinite"
              };
            default:
              return baseStyles;
          }
        }
        _createCanvasElement(id, zIndex, blendMode) {
          const existing = document.getElementById(id);
          if (existing) {
            existing.remove();
          }
          const canvas = document.createElement("canvas");
          canvas.id = id;
          canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: ${zIndex};
      pointer-events: none;
      mix-blend-mode: ${blendMode};
    `;
          document.body.appendChild(canvas);
          this._resizeHandler = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (typeof this.handleResize === "function") {
              this.handleResize();
            }
          };
          window.addEventListener("resize", this._resizeHandler);
          this._resizeHandler();
          return canvas;
        }
        /**
         * Apply a fully-resolved PerformanceProfile coming from Year3000System.
         * Sub-systems may override this to adjust internal parameters (particle
         * counts, throttle values, etc.). The base implementation simply stores the
         * profile so dependants can query `currentPerformanceProfile`.
         */
        applyPerformanceSettings(profile) {
          this.currentPerformanceProfile = profile;
          if (profile.quality && typeof this._applyPerformanceProfile === "function") {
            this._applyPerformanceProfile?.(profile.quality);
          }
          if (this.config.enableDebug) {
            this.performanceMonitor?.emitTrace?.(
              `[BaseVisualSystem (${this.systemName})] Performance settings applied`,
              profile
            );
          }
        }
        /**
         * Centralised settings responder invoked by Year3000System.  The base
         * implementation simply adapts the parameters into a synthetic CustomEvent
         * so that legacy subclasses overriding `handleSettingsChange` continue to
         * work without modification.  Newer systems can override this directly for
         * efficiency.
         */
        applyUpdatedSettings(key, value) {
          const evt = new CustomEvent("year3000SystemSettingsChanged", {
            detail: { key, value }
          });
          try {
            this.handleSettingsChange(evt);
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn(
                `[BaseVisualSystem] ${this.systemName} applyUpdatedSettings error`,
                err
              );
            }
          }
        }
        // ---------------------------------------------------------------------------
        // SETTINGS-AWARE REPAINT CONTRACT
        // ---------------------------------------------------------------------------
        /**
         * Default no-op implementation.  Subclasses that cache colours, shaders, or
         * other theme-dependent resources should override and perform a lightweight
         * refresh.
         */
        forceRepaint(_reason = "generic") {
        }
      };
      __name(_BaseVisualSystem, "BaseVisualSystem");
      BaseVisualSystem = _BaseVisualSystem;
    }
  });

  // src-js/core/performance/DeviceCapabilityDetector.ts
  var _DeviceCapabilityDetector, DeviceCapabilityDetector;
  var init_DeviceCapabilityDetector = __esm({
    "src-js/core/performance/DeviceCapabilityDetector.ts"() {
      "use strict";
      _DeviceCapabilityDetector = class _DeviceCapabilityDetector {
        constructor(config = {}) {
          this.deviceCapabilities = null;
          this.isInitialized = false;
          // New: Cache for expensive computations
          this.benchmarkCache = /* @__PURE__ */ new Map();
          this.detectionStartTime = 0;
          this.config = {
            enableDebug: config.enableDebug || false,
            runStressTests: config.runStressTests !== false,
            spicetifyContext: config.spicetifyContext || this._detectSpicetifyContext(),
            ...config
          };
          if (this.config.enableDebug) {
            console.log(
              "\u{1F50D} [DeviceCapabilityDetector] Initialized",
              this.config.spicetifyContext ? "(Spicetify-optimized)" : "(Standard)"
            );
          }
        }
        // New: Detect if we're running in Spicetify context
        _detectSpicetifyContext() {
          return !!window.Spicetify;
        }
        async initialize() {
          if (this.isInitialized) {
            return this.deviceCapabilities;
          }
          this.detectionStartTime = performance.now();
          if (this.config.enableDebug) {
            console.log(
              "\u{1F50D} [DeviceCapabilityDetector] Starting enhanced capability detection...",
              this.config.spicetifyContext ? "(Spicetify mode)" : "(Standard mode)"
            );
          }
          const memoryData = await this._analyzeMemoryCapabilities();
          const cpuData = await this._analyzeCPUCapabilities();
          const gpuData = await this._analyzeGPUCapabilities();
          this.deviceCapabilities = {
            memory: memoryData,
            cpu: cpuData,
            gpu: gpuData,
            browser: {
              supportsOffscreenCanvas: this._detectOffscreenCanvasSupport(),
              supportsWorkers: this._detectWorkerSupport(),
              supportsSharedArrayBuffer: this._detectSharedArrayBufferSupport(),
              supportsWASM: this._detectWASMSupport(),
              supportsCSSHoudini: this._detectCSSHoudiniSupport()
            },
            display: {
              pixelRatio: window.devicePixelRatio || 1,
              refreshRate: await this._detectRefreshRate(),
              colorGamut: this._detectColorGamut(),
              contrastRatio: this._detectContrastCapability(),
              reducedMotion: this._detectReducedMotion()
            },
            network: {
              effectiveType: navigator.connection?.effectiveType || "unknown",
              downlink: navigator.connection?.downlink || 0,
              rtt: navigator.connection?.rtt || 0,
              saveData: navigator.connection?.saveData || false
            },
            overall: "detecting",
            spicetifyProfile: await this._createSpicetifyProfile(memoryData, cpuData, gpuData)
          };
          if (this.config.runStressTests) {
            await this._runCapabilityTests();
            this.deviceCapabilities.spicetifyProfile = await this._createSpicetifyProfile(
              this.deviceCapabilities.memory,
              this.deviceCapabilities.cpu,
              this.deviceCapabilities.gpu
            );
          }
          this.deviceCapabilities.overall = this._calculateOverallPerformanceLevel();
          this.isInitialized = true;
          const detectionTime = performance.now() - this.detectionStartTime;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F4CA} [DeviceCapabilityDetector] Enhanced detection completed in",
              `${detectionTime.toFixed(1)}ms`,
              "\nSpicetify Profile:",
              this.deviceCapabilities.spicetifyProfile
            );
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F4CA} [DeviceCapabilityDetector] Capabilities detected:",
              this.deviceCapabilities
            );
          }
          return this.deviceCapabilities;
        }
        // New: Get enhanced Spicetify device profile
        getSpicetifyProfile() {
          return this.deviceCapabilities?.spicetifyProfile || null;
        }
        // New: Get recommended quality level (0-100)
        getRecommendedQualityLevel() {
          return this.deviceCapabilities?.spicetifyProfile?.recommendedQualityLevel || 50;
        }
        // Enhanced memory capability analysis with continuous scoring
        async _analyzeMemoryCapabilities() {
          const deviceMemory = navigator.deviceMemory;
          const hasMemoryAPI = typeof deviceMemory === "number";
          const estimatedMemory = deviceMemory || this._estimateMemoryFromOtherSources();
          const jsHeapSizeLimit = performance.memory?.jsHeapSizeLimit || 0;
          const estimatedAvailable = this._estimateAvailableMemory();
          const spicetifyOverhead = this.config.spicetifyContext ? this._estimateSpicetifyOverhead() : 0;
          const score = this._calculateMemoryScore(estimatedMemory, jsHeapSizeLimit, estimatedAvailable);
          return {
            total: estimatedMemory,
            score,
            level: score >= 7 ? "high" : score >= 4 ? "medium" : "low",
            jsHeapSizeLimit,
            estimatedAvailable,
            spicetifyOverhead,
            confidenceLevel: hasMemoryAPI ? 0.9 : 0.6
            // Lower confidence when API unavailable
          };
        }
        _detectMemoryLevel() {
          const memory = navigator.deviceMemory || 6;
          if (memory >= 8) return "high";
          if (memory >= 4) return "medium";
          return "low";
        }
        _estimateAvailableMemory() {
          if (performance.memory) {
            return performance.memory.jsHeapSizeLimit - performance.memory.usedJSHeapSize;
          }
          return (navigator.deviceMemory || 4) * 1024 * 1024 * 1024 * 0.7;
        }
        // Enhanced CPU capability analysis with performance benchmarking
        async _analyzeCPUCapabilities() {
          const cores = navigator.hardwareConcurrency || 4;
          const singleThreadPerformance = await this._benchmarkSingleThreadPerformance();
          const thermalThrottlingRisk = this._estimateThermalThrottlingRisk(cores);
          const score = this._calculateCPUScore(cores, singleThreadPerformance);
          return {
            cores,
            score,
            level: score >= 7 ? "high" : score >= 4 ? "medium" : "low",
            singleThreadPerformance,
            thermalThrottlingRisk,
            confidenceLevel: cores > 1 ? 0.8 : 0.5
            // Lower confidence for single-core detection
          };
        }
        _detectCPULevel() {
          const cores = navigator.hardwareConcurrency || 4;
          if (cores >= 8) return "high";
          if (cores >= 4) return "medium";
          return "low";
        }
        _detectWebGLSupport() {
          try {
            const canvas = document.createElement("canvas");
            return !!(canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
          } catch (e) {
            return false;
          }
        }
        _detectWebGL2Support() {
          try {
            const canvas = document.createElement("canvas");
            return !!canvas.getContext("webgl2");
          } catch (e) {
            return false;
          }
        }
        _getMaxTextureSize() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            return gl ? gl.getParameter(gl.MAX_TEXTURE_SIZE) : 0;
          } catch (e) {
            return 0;
          }
        }
        _getGPUVendor() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) return "unknown";
            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            return debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "unknown";
          } catch (e) {
            return "unknown";
          }
        }
        _getGPURenderer() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) return "unknown";
            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            return debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "unknown";
          } catch (e) {
            return "unknown";
          }
        }
        // Enhanced GPU capability analysis with WebGL performance testing
        async _analyzeGPUCapabilities() {
          const supportsWebGL = this._detectWebGLSupport();
          const supportsWebGL2 = this._detectWebGL2Support();
          const maxTextureSize = this._getMaxTextureSize();
          const vendor = this._getGPUVendor();
          const renderer = this._getGPURenderer();
          const webglCapabilityScore = await this._benchmarkWebGLCapabilities();
          const score = this._calculateGPUScore(renderer, webglCapabilityScore, supportsWebGL2, maxTextureSize);
          return {
            supportsWebGL,
            supportsWebGL2,
            maxTextureSize,
            score,
            level: score >= 7 ? "high" : score >= 4 ? "medium" : "low",
            vendor,
            renderer,
            webglCapabilityScore,
            confidenceLevel: supportsWebGL ? 0.8 : 0.3
            // Much lower confidence without WebGL
          };
        }
        _detectGPULevel() {
          const renderer = this._getGPURenderer().toLowerCase();
          if (/rtx|radeon rx|gtx 16|gtx 20|apple m[1-9]|iris xe/.test(renderer)) {
            return "high";
          }
          if (/gtx|radeon|intel iris|intel uhd|vega|ryzen/.test(renderer)) {
            return "medium";
          }
          return "low";
        }
        _detectOffscreenCanvasSupport() {
          return typeof OffscreenCanvas !== "undefined";
        }
        _detectWorkerSupport() {
          return typeof Worker !== "undefined";
        }
        _detectSharedArrayBufferSupport() {
          return typeof SharedArrayBuffer !== "undefined";
        }
        _detectWASMSupport() {
          return typeof WebAssembly !== "undefined";
        }
        _detectCSSHoudiniSupport() {
          return typeof CSS !== "undefined" && CSS.paintWorklet !== void 0;
        }
        async _detectRefreshRate() {
          return new Promise((resolve) => {
            let lastTime = performance.now();
            let frameCount = 0;
            const samples = [];
            const measure = /* @__PURE__ */ __name(() => {
              const currentTime = performance.now();
              const delta = currentTime - lastTime;
              samples.push(1e3 / delta);
              lastTime = currentTime;
              frameCount++;
              if (frameCount < 10) {
                requestAnimationFrame(measure);
              } else {
                const avgFPS = samples.reduce((a, b) => a + b, 0) / samples.length;
                resolve(Math.round(avgFPS));
              }
            }, "measure");
            requestAnimationFrame(measure);
          });
        }
        _detectColorGamut() {
          if (window.matchMedia("(color-gamut: p3)").matches) return "p3";
          if (window.matchMedia("(color-gamut: srgb)").matches) return "srgb";
          return "limited";
        }
        _detectContrastCapability() {
          if (window.matchMedia("(dynamic-range: high)").matches) return "high";
          if (window.matchMedia("(contrast: high)").matches) return "high";
          return "standard";
        }
        _detectReducedMotion() {
          return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        }
        async _runCapabilityTests() {
          if (this.deviceCapabilities) {
            this.deviceCapabilities.gpu.stressTestScore = await this._runGPUStressTest();
            this.deviceCapabilities.memory.stressTestScore = await this._runMemoryStressTest();
          }
          if (this.config.enableDebug) {
            console.log("\u26A1 [DeviceCapabilityDetector] Capability tests completed");
          }
        }
        async _runGPUStressTest() {
          return 0;
        }
        async _runMemoryStressTest() {
          return 0;
        }
        // New: Enhanced scoring and helper methods
        _estimateMemoryFromOtherSources() {
          const cores = navigator.hardwareConcurrency || 4;
          const screen = window.screen;
          let estimate = 4;
          if (cores >= 8) estimate = 16;
          else if (cores >= 6) estimate = 12;
          else if (cores >= 4) estimate = 8;
          else if (cores >= 2) estimate = 6;
          if (screen.width * screen.height > 2073600) estimate *= 1.5;
          return Math.round(estimate);
        }
        _estimateSpicetifyOverhead() {
          return this.config.spicetifyContext ? 0.15 : 0;
        }
        _calculateMemoryScore(memory, heapLimit, available) {
          let score = Math.min(memory / 2, 10);
          if (heapLimit > 0) {
            const heapGB = heapLimit / (1024 * 1024 * 1024);
            score = Math.max(score, Math.min(heapGB, 10));
          }
          if (this.config.spicetifyContext) {
            score *= 0.85;
          }
          return Math.min(Math.max(score, 1), 10);
        }
        async _benchmarkSingleThreadPerformance() {
          const cacheKey = "singleThreadPerf";
          if (this.benchmarkCache.has(cacheKey)) {
            return this.benchmarkCache.get(cacheKey);
          }
          return new Promise((resolve) => {
            const start = performance.now();
            let result = 0;
            for (let i = 0; i < 5e5; i++) {
              result += Math.sin(i) * Math.cos(i);
            }
            const duration = performance.now() - start;
            const score = Math.max(1, Math.min(10, 50 / duration));
            this.benchmarkCache.set(cacheKey, score);
            resolve(score);
          });
        }
        _estimateThermalThrottlingRisk(cores) {
          const isMobile = /Mobi|Android/i.test(navigator.userAgent);
          let risk = 0.1;
          if (cores >= 8) risk += 0.2;
          if (isMobile) risk += 0.3;
          return Math.min(risk, 1);
        }
        _calculateCPUScore(cores, singleThreadPerf) {
          const coreScore = Math.min(cores / 2, 10);
          const perfWeight = 0.7;
          return Math.min(coreScore * (1 - perfWeight) + singleThreadPerf * perfWeight, 10);
        }
        async _benchmarkWebGLCapabilities() {
          const cacheKey = "webglCapability";
          if (this.benchmarkCache.has(cacheKey)) {
            return this.benchmarkCache.get(cacheKey);
          }
          if (!this._detectWebGLSupport()) {
            this.benchmarkCache.set(cacheKey, 0);
            return 0;
          }
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
          if (!gl) {
            this.benchmarkCache.set(cacheKey, 0);
            return 0;
          }
          let score = 2;
          if (gl.getExtension("OES_texture_float")) score += 1;
          if (gl.getExtension("WEBGL_depth_texture")) score += 1;
          if (gl.getExtension("OES_element_index_uint")) score += 1;
          const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          if (maxTextureSize >= 4096) score += 2;
          else if (maxTextureSize >= 2048) score += 1;
          const maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
          if (maxVertexAttribs >= 16) score += 1;
          if (gl instanceof WebGL2RenderingContext) score += 2;
          this.benchmarkCache.set(cacheKey, Math.min(score, 10));
          return Math.min(score, 10);
        }
        _calculateGPUScore(renderer, webglScore, hasWebGL2, maxTexture) {
          let score = webglScore;
          const rendererLower = renderer.toLowerCase();
          if (/rtx|radeon rx|apple m[1-9]|arc a/.test(rendererLower)) {
            score += 2;
          } else if (/gtx|radeon|vega|iris xe|ryzen/.test(rendererLower)) {
            score += 1;
          } else if (/intel|qualcomm|mali|adreno/.test(rendererLower)) {
            score += 0.5;
          }
          return Math.min(Math.max(score, 1), 10);
        }
        async _createSpicetifyProfile(memory, cpu, gpu) {
          const memoryScore = memory.score;
          const cpuScore = cpu.score;
          const gpuScore = gpu.score;
          const compositeScore = Math.round(
            (memoryScore * 0.3 + cpuScore * 0.4 + gpuScore * 0.3) * 10
          );
          let recommendedQuality = Math.min(compositeScore, 100);
          if (this.config.spicetifyContext) {
            recommendedQuality *= 1 - memory.spicetifyOverhead;
          }
          recommendedQuality = Math.max(recommendedQuality, 20);
          const confidenceLevel = (memory.confidenceLevel + cpu.confidenceLevel + gpu.confidenceLevel) / 3;
          return {
            memoryScore,
            cpuScore,
            gpuScore,
            compositeScore,
            spicetifyOverhead: memory.spicetifyOverhead,
            userQualityPreference: "auto",
            // Default, will be overridden by settings
            confidenceLevel,
            recommendedQualityLevel: Math.round(recommendedQuality)
          };
        }
        _calculateOverallPerformanceLevel() {
          if (!this.deviceCapabilities) return "low";
          const compositeScore = this.deviceCapabilities.spicetifyProfile.compositeScore;
          const confidence = this.deviceCapabilities.spicetifyProfile.confidenceLevel;
          const adjustedScore = compositeScore * (0.7 + confidence * 0.3);
          if (adjustedScore >= 70) return "high";
          if (adjustedScore >= 40) return "medium";
          return "low";
        }
        getCapabilities() {
          if (!this.isInitialized) {
            console.warn(
              "[DeviceCapabilityDetector] Not initialized - call initialize() first"
            );
            return null;
          }
          return this.deviceCapabilities;
        }
        /**
         * Check if WebGL support is available (for BackgroundStrategySelector)
         */
        hasWebGLSupport() {
          if (this.isInitialized && this.deviceCapabilities) {
            return this.deviceCapabilities.gpu.supportsWebGL;
          }
          return this._detectWebGLSupport();
        }
        /**
         * Check if WebGL2 support is available
         */
        hasWebGL2Support() {
          if (this.isInitialized && this.deviceCapabilities) {
            return this.deviceCapabilities.gpu.supportsWebGL2;
          }
          return this._detectWebGL2Support();
        }
        destroy() {
          this.deviceCapabilities = null;
          this.isInitialized = false;
          if (this.config.enableDebug) {
            console.log("\u{1F50D} [DeviceCapabilityDetector] Destroyed");
          }
        }
        /**
         * Recommend a performance-quality label that callers (e.g., visual systems)
         * can use to pick an appropriate performance profile.
         * Returns one of `"low" | "balanced" | "high"`.
         */
        recommendPerformanceQuality() {
          if (!this.isInitialized || !this.deviceCapabilities) {
            return "balanced";
          }
          switch (this.deviceCapabilities.overall) {
            case "high":
              return "high";
            case "medium":
              return "balanced";
            case "low":
            default:
              return "low";
          }
        }
      };
      __name(_DeviceCapabilityDetector, "DeviceCapabilityDetector");
      DeviceCapabilityDetector = _DeviceCapabilityDetector;
    }
  });

  // src-js/ui/managers/SettingsManager.ts
  var _SettingsManager, SettingsManager;
  var init_SettingsManager = __esm({
    "src-js/ui/managers/SettingsManager.ts"() {
      "use strict";
      init_globalConfig();
      init_Year3000Utilities();
      init_config();
      _SettingsManager = class _SettingsManager {
        constructor(config = YEAR3000_CONFIG, harmonicModes = HARMONIC_MODES2, utils = Year3000Utilities_exports) {
          this.initialized = false;
          this.initialized = true;
          if (config?.enableDebug) {
            console.log("[SettingsManager] Initialized with new type-safe backend");
          }
        }
        forceRepaint(reason) {
          if (typeof document !== "undefined") {
            document.documentElement.style.display = "none";
            document.documentElement.offsetHeight;
            document.documentElement.style.display = "";
          }
        }
        async initialize() {
          this.initialized = true;
        }
        async healthCheck() {
          return {
            healthy: this.initialized,
            system: "SettingsManager",
            details: this.initialized ? "Settings manager operational" : "Settings manager not initialized"
          };
        }
        updateAnimation() {
        }
        destroy() {
          this.initialized = false;
        }
        // Settings operations using the new typed settings system
        get(key) {
          try {
            switch (key) {
              case "artisticMode":
                return settings.get("sn-artistic-mode");
              case "paletteSystem":
                return settings.get("sn-palette-system");
              case "gradientIntensity":
                return settings.get("sn-gradient-intensity");
              case "webglEnabled":
                return settings.get("sn-webgl-enabled");
              case "animationQuality":
                return settings.get("sn-animation-quality");
              default:
                if (typeof key === "string" && key.startsWith("sn-")) {
                  return settings.get(key);
                }
                return void 0;
            }
          } catch (error) {
            console.warn(`[SettingsManager] Failed to get setting ${String(key)}:`, error);
            return void 0;
          }
        }
        getAllowedValues(key) {
          switch (key) {
            case "artisticMode":
              return Object.keys(ARTISTIC_MODE_PROFILES2);
            case "paletteSystem":
              return ["catppuccin", "year3000"];
            case "gradientIntensity":
              return ["disabled", "minimal", "balanced", "intense"];
            case "webglEnabled":
              return [true, false];
            case "animationQuality":
              return ["auto", "low", "high"];
            default:
              return void 0;
          }
        }
        set(key, value) {
          try {
            switch (key) {
              case "artisticMode":
                return settings.set("sn-artistic-mode", value);
              case "paletteSystem":
                return settings.set("sn-palette-system", value);
              case "gradientIntensity":
                return settings.set("sn-gradient-intensity", value);
              case "webglEnabled":
                return settings.set("sn-webgl-enabled", Boolean(value));
              case "animationQuality":
                return settings.set("sn-animation-quality", value);
              default:
                if (typeof key === "string" && key.startsWith("sn-")) {
                  return settings.set(key, value);
                }
                console.warn(`[SettingsManager] Unknown setting key: ${String(key)}`);
                return false;
            }
          } catch (error) {
            console.warn(`[SettingsManager] Failed to set setting ${String(key)}:`, error);
            return false;
          }
        }
        getAllSettings() {
          return {
            artisticMode: this.get("artisticMode") || "artist-vision",
            paletteSystem: this.get("paletteSystem") || "catppuccin",
            gradientIntensity: this.get("gradientIntensity") || "balanced",
            webglEnabled: this.get("webglEnabled") ?? true,
            animationQuality: this.get("animationQuality") || "auto"
          };
        }
        validateAndRepair() {
          console.log("[SettingsManager] Settings validation handled by typed system");
        }
        resetAllToDefaults() {
          try {
            settings.set("sn-artistic-mode", "artist-vision");
            settings.set("sn-palette-system", "catppuccin");
            settings.set("sn-gradient-intensity", "balanced");
            settings.set("sn-webgl-enabled", true);
            settings.set("sn-animation-quality", "auto");
            console.log("[SettingsManager] Reset all settings to defaults");
          } catch (error) {
            console.warn("[SettingsManager] Failed to reset settings:", error);
          }
        }
        // Harmonic mode helpers
        getCurrentHarmonicMode() {
          const currentMode = settings.get("sn-artistic-mode") || "artist-vision";
          const harmonicMapping = {
            "artist-vision": "analogous-flow",
            "cosmic-maximum": "triadic-balance",
            "corporate-safe": "monochromatic-smooth"
          };
          const harmonicKey = harmonicMapping[String(currentMode)] || "analogous-flow";
          const harmonicMode = HARMONIC_MODES2[harmonicKey];
          return harmonicMode || HARMONIC_MODES2["analogous-flow"];
        }
        getHarmonicMode(key) {
          return HARMONIC_MODES2[key];
        }
      };
      __name(_SettingsManager, "SettingsManager");
      SettingsManager = _SettingsManager;
    }
  });

  // src-js/visual/strategies/DepthLayeredStrategy.ts
  var _DepthLayeredStrategy, DepthLayeredStrategy;
  var init_DepthLayeredStrategy = __esm({
    "src-js/visual/strategies/DepthLayeredStrategy.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_config();
      init_Year3000Utilities();
      _DepthLayeredStrategy = class _DepthLayeredStrategy {
        constructor() {
          this.utils = Year3000Utilities_exports;
          this.config = YEAR3000_CONFIG;
          this.cssController = null;
          this.depthState = {
            containerElement: null,
            backgroundContainer: null,
            depthLayers: /* @__PURE__ */ new Map(),
            animationFrameId: null,
            lastAnimationTime: 0,
            scrollY: 0,
            scrollX: 0,
            lastUpdateTime: 0,
            isInitialized: false,
            stylesInjected: false
          };
          this.depthSettings = {
            enabled: true,
            layerCount: 6,
            maxDepth: 1e3,
            parallaxStrength: 0.5,
            depthFogIntensity: 0.7,
            infiniteScrolling: true,
            qualityLevel: "medium",
            performanceMode: false,
            musicResponsiveness: 1
          };
          this.performanceMetrics = {
            totalLayers: 0,
            visibleLayers: 0,
            averageDepth: 0,
            parallaxRange: 0,
            renderTime: 0,
            memoryUsage: 0
          };
          this.layerTemplates = {
            cosmic: {
              animation: "cosmic-drift",
              duration: "120s",
              baseGradient: "radial-gradient(ellipse at center, {primary} 0%, {secondary} 50%, {base} 100%)"
            },
            nebula: {
              animation: "nebula-flow",
              duration: "180s",
              baseGradient: "conic-gradient(from 45deg, {primary} 0%, {secondary} 25%, {tertiary} 50%, {quaternary} 75%, {primary} 100%)"
            },
            stellar: {
              animation: "stellar-motion",
              duration: "240s",
              baseGradient: "linear-gradient(45deg, {primary} 0%, {secondary} 25%, {tertiary} 50%, {quaternary} 75%, {primary} 100%)"
            },
            quantum: {
              animation: "quantum-field",
              duration: "300s",
              baseGradient: "radial-gradient(circle at 30% 70%, {primary} 0%, transparent 50%), radial-gradient(circle at 70% 30%, {secondary} 0%, transparent 50%)"
            },
            dimensional: {
              animation: "dimensional-shift",
              duration: "360s",
              baseGradient: "linear-gradient(135deg, {primary} 0%, {secondary} 20%, {tertiary} 40%, {quaternary} 60%, {primary} 80%, {secondary} 100%)"
            },
            void: {
              animation: "void-expansion",
              duration: "480s",
              baseGradient: "radial-gradient(ellipse at center, {base} 0%, {secondary} 30%, {primary} 60%, transparent 100%)"
            }
          };
          // Event handlers
          this.boundScrollHandler = null;
          this.boundResizeHandler = null;
          this.deviceDetector = new DeviceCapabilityDetector();
          this.cssController = getGlobalOptimizedCSSController();
          this.loadDepthSettings();
          this.adaptToDeviceCapabilities();
          this.boundScrollHandler = this.handleScroll.bind(this);
          this.boundResizeHandler = this.handleResize.bind(this);
          Y3KDebug?.debug?.log(
            "DepthLayeredStrategy",
            "Depth layered strategy initialized",
            {
              layerCount: this.depthSettings.layerCount,
              qualityLevel: this.depthSettings.qualityLevel,
              deviceCapability: this.deviceDetector.recommendPerformanceQuality()
            }
          );
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "depth-layered";
        }
        /**
         * Check if strategy can handle the given context
         */
        canProcess(context) {
          return this.depthSettings.enabled;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          const baseTime = 15;
          const layerMultiplier = this.depthSettings.layerCount / 6;
          const qualityMultiplier = this.depthSettings.qualityLevel === "high" ? 1.3 : this.depthSettings.qualityLevel === "low" ? 0.7 : 1;
          return Math.round(baseTime * layerMultiplier * qualityMultiplier);
        }
        /**
         * Process colors using Depth Layered strategy
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            if (!this.depthState.isInitialized) {
              await this.initializeDepthSystem();
            }
            const depthColors = this.extractDepthColors(context.rawColors);
            await this.updateDepthLayers(depthColors);
            if (!this.depthState.animationFrameId) {
              this.startDepthAnimation();
            }
            if (context.musicData?.energy !== void 0) {
              this.updateDepthWithMusicEnergy(context.musicData.energy);
            }
            this.depthState.lastUpdateTime = Date.now();
            this.updatePerformanceMetrics();
            const processingTime = performance.now() - startTime;
            const result = {
              processedColors: {
                depthLayers: this.depthState.depthLayers.size.toString(),
                depthEnabled: this.depthSettings.enabled.toString(),
                qualityLevel: this.depthSettings.qualityLevel,
                ...context.rawColors
              },
              accentHex: this.selectPrimaryColor(context.rawColors) || "#cba6f7",
              accentRgb: this.convertToRgbString(
                this.selectPrimaryColor(context.rawColors) || "#cba6f7"
              ),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `depth-layered-${context.trackUri}`,
                harmonicIntensity: this.depthSettings.parallaxStrength,
                layerCount: this.depthState.depthLayers.size
              },
              context
            };
            Y3KDebug?.debug?.log(
              "DepthLayeredStrategy",
              "Depth layered processing completed",
              {
                layerCount: this.depthState.depthLayers.size,
                processingTime,
                trackUri: context.trackUri
              }
            );
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3KDebug?.debug?.error(
              "DepthLayeredStrategy",
              "Depth layered processing failed:",
              error
            );
            return {
              processedColors: context.rawColors,
              accentHex: this.selectPrimaryColor(context.rawColors) || "#cba6f7",
              accentRgb: this.convertToRgbString(
                this.selectPrimaryColor(context.rawColors) || "#cba6f7"
              ),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error"
              },
              context
            };
          }
        }
        /**
         * Load depth settings from settings manager
         */
        loadDepthSettings() {
          try {
            const gradientIntensity = settings.get("sn-gradient-intensity");
            if (gradientIntensity) {
              const qualityLevel = gradientIntensity === "intense" ? "high" : gradientIntensity === "balanced" ? "medium" : gradientIntensity === "minimal" ? "low" : "medium";
              this.depthSettings.qualityLevel = qualityLevel;
              this.adjustQualitySettings();
            }
            const enabledSetting = gradientIntensity !== "disabled";
            if (enabledSetting !== void 0) {
              this.depthSettings.enabled = enabledSetting;
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "DepthLayeredStrategy",
              "Failed to load settings:",
              error
            );
          }
        }
        /**
         * Adapt settings to device capabilities
         */
        adaptToDeviceCapabilities() {
          const recommendation = this.deviceDetector.recommendPerformanceQuality();
          switch (recommendation) {
            case "low":
              this.depthSettings.qualityLevel = "low";
              this.depthSettings.layerCount = 3;
              this.depthSettings.performanceMode = true;
              this.depthSettings.parallaxStrength = 0.3;
              this.depthSettings.depthFogIntensity = 0.5;
              break;
            case "balanced":
              this.depthSettings.qualityLevel = "medium";
              this.depthSettings.layerCount = 6;
              this.depthSettings.performanceMode = false;
              this.depthSettings.parallaxStrength = 0.5;
              this.depthSettings.depthFogIntensity = 0.7;
              break;
            case "high":
              this.depthSettings.qualityLevel = "high";
              this.depthSettings.layerCount = 9;
              this.depthSettings.performanceMode = false;
              this.depthSettings.parallaxStrength = 0.8;
              this.depthSettings.depthFogIntensity = 0.9;
              break;
          }
        }
        /**
         * Adjust quality settings based on selected level
         */
        adjustQualitySettings() {
          switch (this.depthSettings.qualityLevel) {
            case "low":
              this.depthSettings.layerCount = 3;
              this.depthSettings.parallaxStrength = 0.3;
              this.depthSettings.depthFogIntensity = 0.5;
              break;
            case "medium":
              this.depthSettings.layerCount = 6;
              this.depthSettings.parallaxStrength = 0.5;
              this.depthSettings.depthFogIntensity = 0.7;
              break;
            case "high":
              this.depthSettings.layerCount = 9;
              this.depthSettings.parallaxStrength = 0.8;
              this.depthSettings.depthFogIntensity = 0.9;
              break;
          }
        }
        /**
         * Initialize depth system
         */
        async initializeDepthSystem() {
          this.createContainerElements();
          this.injectDepthAnimations();
          this.setupEventListeners();
          this.depthState.isInitialized = true;
          Y3KDebug?.debug?.log(
            "DepthLayeredStrategy",
            "Depth system initialized successfully"
          );
        }
        /**
         * Create container elements for depth layers
         */
        createContainerElements() {
          this.depthState.containerElement = document.querySelector(".Root__main-view") || document.querySelector(".main-view-container") || document.body;
          this.depthState.backgroundContainer = document.createElement("div");
          this.depthState.backgroundContainer.className = "sn-depth-background-container";
          this.depthState.backgroundContainer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -20;
      pointer-events: none;
      overflow: hidden;
      perspective: 1000px;
      transform-style: preserve-3d;
    `;
          this.depthState.containerElement.insertBefore(
            this.depthState.backgroundContainer,
            this.depthState.containerElement.firstChild
          );
        }
        /**
         * Inject CSS animations for depth layers
         */
        injectDepthAnimations() {
          if (this.depthState.stylesInjected) return;
          const styleElement = document.createElement("style");
          styleElement.textContent = `
      .sn-depth-layer {
        position: absolute;
        width: 120%;
        height: 120%;
        top: -10%;
        left: -10%;
        pointer-events: none;
        transform-style: preserve-3d;
        will-change: transform, opacity;
      }

      @keyframes cosmic-drift {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        25% { transform: translate3d(-2%, 1%, 0) rotate(0.5deg) scale(1.02); }
        50% { transform: translate3d(0, -1%, 0) rotate(0deg) scale(0.98); }
        75% { transform: translate3d(2%, 0.5%, 0) rotate(-0.5deg) scale(1.01); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes nebula-flow {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        33% { transform: translate3d(1%, -1%, 0) rotate(1deg) scale(1.03); }
        66% { transform: translate3d(-1%, 1%, 0) rotate(-1deg) scale(0.97); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes stellar-motion {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        20% { transform: translate3d(-1%, 0.5%, 0) rotate(0.3deg) scale(1.01); }
        40% { transform: translate3d(0.5%, -0.5%, 0) rotate(-0.3deg) scale(0.99); }
        60% { transform: translate3d(1%, 0.5%, 0) rotate(0.2deg) scale(1.02); }
        80% { transform: translate3d(-0.5%, 1%, 0) rotate(-0.2deg) scale(0.98); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes quantum-field {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); filter: blur(0px); }
        25% { transform: translate3d(0.5%, -0.5%, 0) rotate(0.1deg) scale(1.01); filter: blur(0.5px); }
        50% { transform: translate3d(-0.5%, 0.5%, 0) rotate(-0.1deg) scale(0.99); filter: blur(1px); }
        75% { transform: translate3d(0.3%, 0.3%, 0) rotate(0.05deg) scale(1.005); filter: blur(0.3px); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); filter: blur(0px); }
      }

      @keyframes dimensional-shift {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        16% { transform: translate3d(0.2%, -0.2%, 0) rotate(0.1deg) scale(1.005); }
        32% { transform: translate3d(-0.2%, 0.2%, 0) rotate(-0.1deg) scale(0.995); }
        48% { transform: translate3d(0.1%, 0.1%, 0) rotate(0.05deg) scale(1.002); }
        64% { transform: translate3d(-0.1%, -0.1%, 0) rotate(-0.05deg) scale(0.998); }
        80% { transform: translate3d(0.15%, 0%, 0) rotate(0.02deg) scale(1.001); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes void-expansion {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.9; }
        50% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1.1); opacity: 0.6; }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.9; }
      }

      @media (prefers-reduced-motion: reduce) {
        .sn-depth-layer {
          animation: none !important;
        }
      }
    `;
          document.head.appendChild(styleElement);
          this.depthState.stylesInjected = true;
        }
        /**
         * Setup event listeners for depth system
         */
        setupEventListeners() {
          if (this.boundScrollHandler) {
            window.addEventListener("scroll", this.boundScrollHandler, {
              passive: true
            });
          }
          if (this.boundResizeHandler) {
            window.addEventListener("resize", this.boundResizeHandler, {
              passive: true
            });
          }
        }
        /**
         * Extract depth colors from color context
         */
        extractDepthColors(colors) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "LIGHT_VIBRANT",
            "DARK_VIBRANT",
            "VIBRANT_NON_ALARMING",
            "PROMINENT",
            "SECONDARY",
            "DESATURATED"
          ];
          const depthColors = [];
          const usedColors = /* @__PURE__ */ new Set();
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && !usedColors.has(color3) && this.utils.hexToRgb(color3)) {
              depthColors.push(color3);
              usedColors.add(color3);
              if (depthColors.length >= this.depthSettings.layerCount) break;
            }
          }
          while (depthColors.length < this.depthSettings.layerCount) {
            const baseColor = depthColors[0] || "#cba6f7";
            const variation = this.createColorVariation(
              baseColor,
              depthColors.length
            );
            depthColors.push(variation);
          }
          return depthColors;
        }
        /**
         * Create color variation for depth layers
         */
        createColorVariation(baseColor, index) {
          const rgb = this.utils.hexToRgb(baseColor);
          if (!rgb) return baseColor;
          const factor = 0.8 - index * 0.1;
          const r = Math.round(rgb.r * factor);
          const g = Math.round(rgb.g * factor);
          const b = Math.round(rgb.b * factor);
          return this.utils.rgbToHex(r, g, b);
        }
        /**
         * Update depth layers with new colors
         */
        async updateDepthLayers(depthColors) {
          if (!this.depthState.backgroundContainer) return;
          this.depthState.depthLayers.forEach((layer) => {
            if (layer.element.parentNode) {
              layer.element.parentNode.removeChild(layer.element);
            }
          });
          this.depthState.depthLayers.clear();
          const layerTemplateKeys = Object.keys(this.layerTemplates);
          for (let i = 0; i < this.depthSettings.layerCount; i++) {
            const depth = (i + 1) * (this.depthSettings.maxDepth / this.depthSettings.layerCount);
            const templateKey = layerTemplateKeys[i % layerTemplateKeys.length];
            const template = this.layerTemplates[templateKey];
            const layerElement = document.createElement("div");
            layerElement.className = "sn-depth-layer";
            layerElement.id = `sn-depth-layer-${i}`;
            const depthFactor = depth / this.depthSettings.maxDepth;
            const parallaxFactor = 1 - depthFactor * this.depthSettings.parallaxStrength;
            const opacity = 1 - depthFactor * this.depthSettings.depthFogIntensity;
            const scale = 1 + depthFactor * 0.2;
            const blur = depthFactor * 3;
            const gradient = this.createDepthGradient(
              template.baseGradient,
              depthColors,
              i
            );
            layerElement.style.cssText = `
        background: ${gradient};
        transform: translate3d(0, 0, ${-depth}px) scale(${scale});
        opacity: ${opacity};
        filter: blur(${blur}px);
        animation: ${template.animation} ${template.duration} ease-in-out infinite;
        animation-delay: ${i * 0.5}s;
      `;
            const depthLayer = {
              id: `depth-layer-${i}`,
              element: layerElement,
              depth,
              parallaxFactor,
              opacityRange: [opacity * 0.5, opacity],
              scaleRange: [scale * 0.95, scale * 1.05],
              rotationSpeed: 0.01 + i * 1e-3,
              colorShift: i * 30,
              blurAmount: blur,
              animationPhase: i * Math.PI / 4,
              enabled: true,
              gradientColors: depthColors.slice(i, i + 4)
            };
            this.depthState.depthLayers.set(depthLayer.id, depthLayer);
            this.depthState.backgroundContainer.appendChild(layerElement);
          }
          Y3KDebug?.debug?.log(
            "DepthLayeredStrategy",
            `Updated ${this.depthState.depthLayers.size} depth layers with new colors`
          );
        }
        /**
         * Create depth gradient from template and colors
         */
        createDepthGradient(template, colors, layerIndex) {
          const colorCount = colors.length;
          const primaryIndex = layerIndex % colorCount;
          const secondaryIndex = (layerIndex + 1) % colorCount;
          const tertiaryIndex = (layerIndex + 2) % colorCount;
          const quaternaryIndex = (layerIndex + 3) % colorCount;
          const depthFactor = layerIndex / this.depthSettings.layerCount;
          const baseOpacity = 0.8 - depthFactor * 0.6;
          const primary = this.convertToRgba(
            colors[primaryIndex] || "#cba6f7",
            baseOpacity
          );
          const secondary = this.convertToRgba(
            colors[secondaryIndex] || "#f5c2e7",
            baseOpacity * 0.7
          );
          const tertiary = this.convertToRgba(
            colors[tertiaryIndex] || "#fab387",
            baseOpacity * 0.5
          );
          const quaternary = this.convertToRgba(
            colors[quaternaryIndex] || "#a6e3a1",
            baseOpacity * 0.3
          );
          const base = this.convertToRgba("#1e1e2e", baseOpacity * 0.9);
          return template.replace(/\{primary\}/g, primary).replace(/\{secondary\}/g, secondary).replace(/\{tertiary\}/g, tertiary).replace(/\{quaternary\}/g, quaternary).replace(/\{base\}/g, base);
        }
        /**
         * Convert hex color to RGBA string
         */
        convertToRgba(hex, alpha) {
          const rgb = this.utils.hexToRgb(hex);
          return rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})` : `rgba(203, 166, 247, ${alpha})`;
        }
        /**
         * Start depth animation loop
         */
        startDepthAnimation() {
          this.depthState.lastAnimationTime = performance.now();
          const animate = /* @__PURE__ */ __name(() => {
            if (!this.depthState.isInitialized) return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.depthState.lastAnimationTime;
            if (deltaTime < 33) {
              this.depthState.animationFrameId = requestAnimationFrame(animate);
              return;
            }
            this.depthState.lastAnimationTime = currentTime;
            this.updateDepthAnimations(deltaTime);
            this.updatePerformanceMetrics();
            this.depthState.animationFrameId = requestAnimationFrame(animate);
          }, "animate");
          this.depthState.animationFrameId = requestAnimationFrame(animate);
        }
        /**
         * Update depth animations
         */
        updateDepthAnimations(deltaTime) {
          this.depthState.depthLayers.forEach((layer) => {
            layer.animationPhase += layer.rotationSpeed * deltaTime * 1e-3;
            const breathingFactor = Math.sin(layer.animationPhase) * 0.05;
            const currentOpacity = parseFloat(layer.element.style.opacity);
            const newOpacity = currentOpacity + breathingFactor;
            layer.element.style.opacity = Math.max(
              0,
              Math.min(1, newOpacity)
            ).toString();
          });
        }
        /**
         * Update depth with music energy
         */
        updateDepthWithMusicEnergy(energy) {
          const energyModulation = energy * this.depthSettings.musicResponsiveness * 0.3;
          this.depthState.depthLayers.forEach((layer) => {
            const baseOpacity = layer.opacityRange[0];
            const maxOpacity = layer.opacityRange[1];
            const newOpacity = baseOpacity + energyModulation * (maxOpacity - baseOpacity);
            layer.element.style.opacity = Math.max(
              0,
              Math.min(1, newOpacity)
            ).toString();
          });
        }
        /**
         * Handle scroll events for parallax
         */
        handleScroll(event) {
          if (!this.depthSettings.infiniteScrolling) return;
          this.depthState.scrollY = window.scrollY;
          this.depthState.scrollX = window.scrollX;
          this.updateParallaxEffects();
        }
        /**
         * Handle resize events
         */
        handleResize(event) {
          this.updateLayerDimensions();
        }
        /**
         * Update parallax effects
         */
        updateParallaxEffects() {
          this.depthState.depthLayers.forEach((layer) => {
            const parallaxY = this.depthState.scrollY * layer.parallaxFactor;
            const parallaxX = this.depthState.scrollX * layer.parallaxFactor * 0.5;
            const currentTransform = layer.element.style.transform;
            const newTransform = currentTransform.replace(
              /translate3d\([^)]*\)/,
              `translate3d(${parallaxX}px, ${parallaxY}px, ${-layer.depth}px)`
            );
            layer.element.style.transform = newTransform;
          });
        }
        /**
         * Update layer dimensions
         */
        updateLayerDimensions() {
          this.depthState.depthLayers.forEach((layer) => {
            const depthFactor = layer.depth / this.depthSettings.maxDepth;
            const scale = 1 + depthFactor * 0.2;
            const currentTransform = layer.element.style.transform;
            const newTransform = currentTransform.replace(
              /scale\([^)]*\)/,
              `scale(${scale})`
            );
            layer.element.style.transform = newTransform;
          });
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics() {
          this.performanceMetrics.totalLayers = this.depthState.depthLayers.size;
          this.performanceMetrics.visibleLayers = Array.from(
            this.depthState.depthLayers.values()
          ).filter((layer) => parseFloat(layer.element.style.opacity) > 0.01).length;
          this.performanceMetrics.averageDepth = Array.from(this.depthState.depthLayers.values()).reduce(
            (sum, layer) => sum + layer.depth,
            0
          ) / this.depthState.depthLayers.size;
          this.performanceMetrics.parallaxRange = this.depthSettings.parallaxStrength;
          this.performanceMetrics.renderTime = performance.now() - this.depthState.lastAnimationTime;
          if (this.cssController) {
            this.cssController.queueCSSVariableUpdate(
              "--sn-depth-layers-total",
              this.performanceMetrics.totalLayers.toString()
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-depth-layers-visible",
              this.performanceMetrics.visibleLayers.toString()
            );
          }
        }
        /**
         * Select primary color from extracted colors
         */
        selectPrimaryColor(colors) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "PROMINENT",
            "VIBRANT_NON_ALARMING",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Convert hex color to RGB string
         */
        convertToRgbString(hex) {
          const rgb = this.utils.hexToRgb(hex);
          return rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "203,166,247";
        }
        /**
         * Update configuration
         */
        updateConfig(newConfig) {
          this.depthSettings = { ...this.depthSettings, ...newConfig };
          if (newConfig.qualityLevel) {
            this.adjustQualitySettings();
          }
          Y3KDebug?.debug?.log(
            "DepthLayeredStrategy",
            "Configuration updated:",
            newConfig
          );
        }
        /**
         * Health check for strategy status
         */
        async healthCheck() {
          const hasRecentUpdate = Date.now() - this.depthState.lastUpdateTime < 3e4;
          return {
            healthy: this.depthState.isInitialized && this.depthSettings.enabled,
            canProcess: this.canProcess({}),
            issues: !this.depthState.isInitialized ? ["Depth system not initialized"] : !this.depthSettings.enabled ? ["Depth layers disabled in settings"] : [],
            metrics: {
              isInitialized: this.depthState.isInitialized,
              depthEnabled: this.depthSettings.enabled,
              layerCount: this.depthState.depthLayers.size,
              qualityLevel: this.depthSettings.qualityLevel,
              parallaxStrength: this.depthSettings.parallaxStrength,
              hasRecentUpdate,
              animationActive: this.depthState.animationFrameId !== null,
              performanceMetrics: this.performanceMetrics
            }
          };
        }
        /**
         * Cleanup depth resources
         */
        destroy() {
          if (this.depthState.animationFrameId) {
            cancelAnimationFrame(this.depthState.animationFrameId);
            this.depthState.animationFrameId = null;
          }
          if (this.boundScrollHandler) {
            window.removeEventListener("scroll", this.boundScrollHandler);
            this.boundScrollHandler = null;
          }
          if (this.boundResizeHandler) {
            window.removeEventListener("resize", this.boundResizeHandler);
            this.boundResizeHandler = null;
          }
          this.depthState.depthLayers.forEach((layer) => {
            if (layer.element.parentNode) {
              layer.element.parentNode.removeChild(layer.element);
            }
          });
          this.depthState.depthLayers.clear();
          if (this.depthState.backgroundContainer && this.depthState.backgroundContainer.parentNode) {
            this.depthState.backgroundContainer.parentNode.removeChild(
              this.depthState.backgroundContainer
            );
            this.depthState.backgroundContainer = null;
          }
          this.depthState.isInitialized = false;
          this.depthState.containerElement = null;
          Y3KDebug?.debug?.log(
            "DepthLayeredStrategy",
            "Depth layered strategy destroyed"
          );
        }
      };
      __name(_DepthLayeredStrategy, "DepthLayeredStrategy");
      DepthLayeredStrategy = _DepthLayeredStrategy;
    }
  });

  // src-js/visual/strategies/DynamicCatppuccinStrategy.ts
  var _DynamicCatppuccinStrategy, DynamicCatppuccinStrategy;
  var init_DynamicCatppuccinStrategy = __esm({
    "src-js/visual/strategies/DynamicCatppuccinStrategy.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_UnifiedDebugManager();
      init_config();
      init_OKLABColorProcessor();
      init_PaletteSystemManager();
      init_Year3000Utilities();
      _DynamicCatppuccinStrategy = class _DynamicCatppuccinStrategy {
        constructor(cssController) {
          this.utils = Year3000Utilities_exports;
          this.config = YEAR3000_CONFIG;
          this.dynamicColorState = this.getInitialColorState();
          this.integrationConfig = {
            accentUpdateEnabled: true,
            baseTransformationEnabled: true,
            consciousnessIntegrationEnabled: true,
            oklabEnhancementEnabled: true,
            smoothTransitionDuration: 800,
            // 0.8s smooth transitions
            energyResponseMultiplier: 1.2,
            oklabPreset: "VIBRANT"
            // Use vibrant OKLAB enhancement
          };
          // Transition management
          this.transitionTimer = 0;
          this.lastTransitionStartTime = 0;
          this.transitionFromAccent = "";
          this.transitionToAccent = "";
          this.cssController = cssController || getGlobalOptimizedCSSController();
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.initializeCurrentState();
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            "Color strategy initialized with CSS coordinator and OKLAB processing"
          );
        }
        /**
         * Get initial color state using current palette system
         */
        getInitialColorState() {
          try {
            const defaultAccent = paletteSystemManager.getDefaultAccentColor();
            const baseColor = paletteSystemManager.getBrightnessAdjustedBaseColor();
            return {
              currentAccentHex: defaultAccent.hex,
              currentAccentRgb: defaultAccent.rgb,
              baseBackgroundHex: baseColor.hex,
              baseBackgroundRgb: baseColor.rgb,
              lastUpdateTime: 0,
              musicEnergy: 0.5,
              transitionInProgress: false
            };
          } catch (error) {
            console.warn("[DynamicCatppuccinStrategy] Failed to get initial colors, using fallback:", error);
            return {
              currentAccentHex: "#7c3aed",
              // Fallback cosmic purple
              currentAccentRgb: "124,58,237",
              baseBackgroundHex: "#0d1117",
              // Fallback deep space black
              baseBackgroundRgb: "13,17,23",
              lastUpdateTime: 0,
              musicEnergy: 0.5,
              transitionInProgress: false
            };
          }
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "dynamic-catppuccin";
        }
        /**
         * Check if strategy can handle the given context
         */
        canProcess(context) {
          return this.checkDynamicAccentEnabled();
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          return 5;
        }
        /**
         * Process colors using Dynamic Catppuccin strategy with OKLAB enhancement
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const newAccentHex = this.selectBestAccentColor(context.rawColors);
            if (!newAccentHex) {
              throw new Error("No suitable accent color found in extracted colors");
            }
            let processedAccentHex = newAccentHex;
            let processedAccentRgb = this.utils.hexToRgb(newAccentHex);
            let oklabResult = null;
            if (this.integrationConfig.oklabEnhancementEnabled) {
              const preset = OKLABColorProcessor.getPreset(
                this.integrationConfig.oklabPreset
              );
              oklabResult = this.oklabProcessor.processColor(newAccentHex, preset);
              processedAccentHex = oklabResult.enhancedHex;
              processedAccentRgb = oklabResult.enhancedRgb;
              Y3KDebug?.debug?.log(
                "DynamicCatppuccinStrategy",
                "OKLAB color enhancement applied:",
                {
                  original: newAccentHex,
                  enhanced: processedAccentHex,
                  preset: preset.name,
                  processingTime: `${oklabResult.processingTime.toFixed(2)}ms`
                }
              );
            }
            await this.applyColorFacade(
              processedAccentHex,
              context.rawColors,
              oklabResult
            );
            this.dynamicColorState.currentAccentHex = processedAccentHex;
            if (processedAccentRgb) {
              this.dynamicColorState.currentAccentRgb = `${processedAccentRgb.r},${processedAccentRgb.g},${processedAccentRgb.b}`;
            }
            this.dynamicColorState.lastUpdateTime = Date.now();
            if (context.musicData?.energy !== void 0) {
              this.dynamicColorState.musicEnergy = context.musicData.energy;
              await this.updateConsciousnessWithMusicEnergy(context.musicData.energy);
            }
            const processingTime = performance.now() - startTime;
            const result = {
              processedColors: {
                accent: processedAccentHex,
                primary: processedAccentHex,
                originalAccent: newAccentHex,
                // Keep original for reference
                ...context.rawColors
              },
              accentHex: processedAccentHex,
              accentRgb: this.dynamicColorState.currentAccentRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `dynamic-catppuccin-${context.trackUri}`,
                harmonicIntensity: this.integrationConfig.energyResponseMultiplier,
                oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
                oklabPreset: this.integrationConfig.oklabPreset,
                ...oklabResult && {
                  oklabMetadata: {
                    originalHex: oklabResult.originalHex,
                    enhancedHex: oklabResult.enhancedHex,
                    shadowHex: oklabResult.shadowHex,
                    oklabProcessingTime: oklabResult.processingTime
                  }
                }
              },
              context
            };
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinStrategy",
              "Color processing completed",
              {
                originalAccent: newAccentHex,
                processedAccent: processedAccentHex,
                oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
                processingTime,
                trackUri: context.trackUri
              }
            );
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinStrategy",
              "Color processing failed:",
              error
            );
            return {
              processedColors: context.rawColors,
              accentHex: this.dynamicColorState.currentAccentHex,
              accentRgb: this.dynamicColorState.currentAccentRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error"
              },
              context
            };
          }
        }
        /**
         * Check if dynamic accent is enabled in settings
         */
        checkDynamicAccentEnabled() {
          try {
            const accentSetting = settings.get("catppuccin-accentColor");
            const isDynamic = String(accentSetting) === "dynamic";
            if (this.config.enableDebug) {
              Y3KDebug?.debug?.log(
                "DynamicCatppuccinStrategy",
                `Accent setting: ${accentSetting}, Dynamic: ${isDynamic}`
              );
            }
            return isDynamic;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinStrategy",
              "Error checking dynamic accent setting:",
              error
            );
            return false;
          }
        }
        /**
         * Initialize current state from existing CSS variables
         */
        initializeCurrentState() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentAccent = computedStyle.getPropertyValue("--spice-accent").trim() || computedStyle.getPropertyValue("--sn-color-accent-hex").trim();
          if (currentAccent) {
            this.dynamicColorState.currentAccentHex = currentAccent;
            const rgb = this.utils.hexToRgb(currentAccent);
            if (rgb) {
              this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
            }
          }
          const currentBase = computedStyle.getPropertyValue("--spice-base").trim() || "#1e1e2e";
          this.dynamicColorState.baseBackgroundHex = currentBase;
          const baseRgb = this.utils.hexToRgb(currentBase);
          if (baseRgb) {
            this.dynamicColorState.baseBackgroundRgb = `${baseRgb.r},${baseRgb.g},${baseRgb.b}`;
          }
          this.dynamicColorState.lastUpdateTime = Date.now();
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            "Current state initialized:",
            {
              accent: this.dynamicColorState.currentAccentHex,
              base: this.dynamicColorState.baseBackgroundHex
            }
          );
        }
        /**
         * Select best accent color from extracted colors
         */
        selectBestAccentColor(colors) {
          const priorities = [
            "VIBRANT_NON_ALARMING",
            // Best for UI - vibrant but not overwhelming
            "VIBRANT",
            // Strong and lively
            "LIGHT_VIBRANT",
            // Lighter variant
            "PROMINENT",
            // Most noticeable color
            "PRIMARY",
            // Primary extracted color
            "DARK_VIBRANT"
            // Darker variant as fallback
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Apply colors using Color Extension Facade pattern with coordinated updates
         * Updates both core Spicetify variables AND consciousness extensions with OKLAB enhancement
         */
        async applyColorFacade(accentHex, rawColors, oklabResult) {
          const rgb = this.utils.hexToRgb(accentHex);
          if (!rgb) return;
          const rgbString = `${rgb.r},${rgb.g},${rgb.b}`;
          const variablesToUpdate = {
            // Dynamic color variables (highest priority) - updated by music systems
            "--sn-dynamic-accent-hex": accentHex,
            "--sn-dynamic-accent-rgb": rgbString,
            "--sn-dynamic-primary-hex": accentHex,
            "--sn-dynamic-primary-rgb": rgbString,
            // Core Spicetify variables for compatibility
            "--spice-accent": accentHex,
            "--spice-button": accentHex,
            "--spice-button-active": accentHex,
            "--spice-rgb-accent": rgbString,
            "--spice-rgb-button": rgbString,
            // Extracted color variables for ColorHarmonyEngine
            "--sn-color-extracted-primary-rgb": rgbString,
            "--sn-color-extracted-vibrant-rgb": rgbString,
            "--sn-color-extracted-dominant-rgb": rgbString
          };
          if (oklabResult && this.integrationConfig.oklabEnhancementEnabled) {
            const oklabCSSVars = this.oklabProcessor.generateCSSVariables(
              oklabResult,
              "sn-oklab-accent"
            );
            Object.assign(variablesToUpdate, {
              ...oklabCSSVars,
              // Enhanced shadow variables for depth effects
              "--sn-dynamic-shadow-hex": oklabResult.shadowHex,
              "--sn-dynamic-shadow-rgb": `${oklabResult.shadowRgb.r},${oklabResult.shadowRgb.g},${oklabResult.shadowRgb.b}`,
              // OKLCH variables for advanced CSS features
              "--sn-accent-oklch-l": oklabResult.oklchEnhanced.L.toFixed(3),
              "--sn-accent-oklch-c": oklabResult.oklchEnhanced.C.toFixed(3),
              "--sn-accent-oklch-h": oklabResult.oklchEnhanced.H.toFixed(1)
            });
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinStrategy",
              "Added OKLAB-enhanced CSS variables:",
              {
                oklabVarsCount: Object.keys(oklabCSSVars).length,
                enhancedHex: oklabResult.enhancedHex,
                shadowHex: oklabResult.shadowHex
              }
            );
          }
          if (this.cssController) {
            this.cssController.updateVariables(
              variablesToUpdate,
              "high",
              "core-spicetify-facade"
            );
          }
          const primaryColor = rawColors["PRIMARY"] || rawColors["VIBRANT"];
          if (primaryColor) {
            await this.updateLivingBaseBackground(primaryColor);
          }
          if (this.integrationConfig.consciousnessIntegrationEnabled) {
            await this.updateConsciousnessWithAccent(accentHex, rgbString);
          }
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            `Applied coordinated color facade - Spicetify: ${accentHex}, Consciousness extensions updated`,
            {
              oklabProcessing: !!oklabResult,
              variableCount: Object.keys(variablesToUpdate).length
            }
          );
        }
        /**
         * Update living base background using coordinated variable updates
         * Preserves Spicetify base while adding consciousness layers
         */
        async updateLivingBaseBackground(primaryHex) {
          const primaryRgb = this.utils.hexToRgb(primaryHex);
          if (!primaryRgb) return;
          const primaryRgbString = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          const consciousnessGradient = `
      linear-gradient(135deg,
        var(--spice-base) 0%,
        rgba(${primaryRgbString}, 0.08) 30%,
        var(--spice-base) 70%
      ),
      var(--spice-base)
    `;
          const livingBaseVariables = {
            // Dynamic secondary colors
            "--sn-dynamic-secondary-hex": primaryHex,
            "--sn-dynamic-secondary-rgb": primaryRgbString,
            // Extracted color system for consciousness effects
            "--sn-color-extracted-secondary-rgb": primaryRgbString,
            "--sn-color-harmony-complementary-rgb": primaryRgbString,
            // Living gradient enhancements
            "--living-base-gradient": consciousnessGradient,
            "--consciousness-base-gradient": consciousnessGradient
          };
          if (this.cssController) {
            this.cssController.updateVariables(
              livingBaseVariables,
              "normal",
              "living-base-background"
            );
          }
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            `Coordinated living base facade updated - Primary: ${primaryHex}, preserving --spice-base`
          );
        }
        /**
         * Update consciousness system with new accent awareness using coordinated updates
         */
        async updateConsciousnessWithAccent(accentHex, accentRgb) {
          const consciousnessVariables = {
            // Holographic consciousness variables
            "--organic-holographic-rgb": accentRgb,
            "--holographic-scanline-rgb": accentRgb,
            // Depth consciousness variables
            "--consciousness-intensity": `calc(0.5 + var(--musical-sync-intensity) * ${this.integrationConfig.energyResponseMultiplier})`
          };
          if (this.cssController) {
            this.cssController.updateVariables(
              consciousnessVariables,
              "normal",
              "consciousness-accent-integration"
            );
          }
        }
        /**
         * Update consciousness with music energy using coordinated updates
         */
        async updateConsciousnessWithMusicEnergy(energy) {
          const adjustedEnergy = energy * this.integrationConfig.energyResponseMultiplier;
          const baseIntensity = 0.5;
          const consciousnessIntensity = Math.max(
            0.1,
            Math.min(1, baseIntensity + adjustedEnergy * 0.3)
          );
          const musicEnergyVariables = {
            "--musical-sync-intensity": adjustedEnergy.toString(),
            "--holographic-music-flicker-intensity": adjustedEnergy.toString(),
            "--consciousness-intensity": consciousnessIntensity.toString()
          };
          if (this.cssController) {
            this.cssController.updateVariables(
              musicEnergyVariables,
              "high",
              "consciousness-music-energy"
            );
            this.cssController.updateConsciousnessIntensity(
              parseFloat(consciousnessIntensity.toString()),
              "DynamicCatppuccinStrategy",
              adjustedEnergy
            );
          }
        }
        /**
         * Get current dynamic color state for debugging
         */
        getDynamicColorState() {
          return { ...this.dynamicColorState };
        }
        /**
         * Update integration configuration
         */
        updateConfig(newConfig) {
          this.integrationConfig = { ...this.integrationConfig, ...newConfig };
          if ("oklabEnhancementEnabled" in newConfig || "oklabPreset" in newConfig) {
            this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          }
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            "Configuration updated:",
            {
              ...newConfig,
              oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
              oklabPreset: this.integrationConfig.oklabPreset
            }
          );
        }
        /**
         * Health check for strategy status
         */
        async healthCheck() {
          const isDynamicEnabled = this.checkDynamicAccentEnabled();
          const hasRecentUpdate = Date.now() - this.dynamicColorState.lastUpdateTime < 3e4;
          return {
            healthy: isDynamicEnabled,
            canProcess: isDynamicEnabled,
            issues: !isDynamicEnabled ? ["Dynamic accent not enabled in settings"] : [],
            metrics: {
              dynamicAccentEnabled: isDynamicEnabled,
              currentAccent: this.dynamicColorState.currentAccentHex,
              lastUpdateAge: Date.now() - this.dynamicColorState.lastUpdateTime,
              hasRecentUpdate,
              transitionInProgress: this.dynamicColorState.transitionInProgress,
              musicEnergy: this.dynamicColorState.musicEnergy,
              oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
              oklabPreset: this.integrationConfig.oklabPreset,
              consciousnessIntegration: this.integrationConfig.consciousnessIntegrationEnabled
            }
          };
        }
        /**
         * Cleanup resources
         */
        destroy() {
          if (this.transitionTimer) {
            clearTimeout(this.transitionTimer);
            this.transitionTimer = 0;
          }
          this.dynamicColorState.transitionInProgress = false;
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            "Dynamic Catppuccin strategy destroyed"
          );
        }
      };
      __name(_DynamicCatppuccinStrategy, "DynamicCatppuccinStrategy");
      DynamicCatppuccinStrategy = _DynamicCatppuccinStrategy;
    }
  });

  // src-js/visual/strategies/LivingGradientStrategy.ts
  var LivingGradientStrategy_exports = {};
  __export(LivingGradientStrategy_exports, {
    LivingGradientStrategy: () => LivingGradientStrategy
  });
  var _LivingGradientStrategy, LivingGradientStrategy;
  var init_LivingGradientStrategy = __esm({
    "src-js/visual/strategies/LivingGradientStrategy.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_OKLABColorProcessor();
      init_Year3000Utilities();
      init_BaseVisualSystem();
      _LivingGradientStrategy = class _LivingGradientStrategy extends BaseVisualSystem {
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, performanceMonitor = null, musicSyncService = null, cssController, cssAnimationManager) {
          super(
            config,
            utils,
            performanceMonitor,
            musicSyncService,
            null
          );
          this.utils = Year3000Utilities_exports;
          this.config = YEAR3000_CONFIG;
          this.livingBaseState = {
            currentBaseHex: "#1e1e2e",
            // Catppuccin base
            currentBaseRgb: "30,30,46",
            currentPrimaryHex: "#cba6f7",
            // Default mauve
            currentPrimaryRgb: "203,166,247",
            consciousnessIntensity: 0.5,
            musicEnergy: 0.5,
            lastUpdateTime: 0,
            webglIntegrationActive: false,
            oklabGradientStops: []
          };
          this.gradientConfig = {
            baseTransformationEnabled: true,
            webglIntegrationEnabled: true,
            breathingAnimationEnabled: true,
            consciousnessLayerOpacity: 0.08,
            // Subtle but visible
            organicFlowIntensity: 1.2,
            musicResponsiveness: 1,
            oklabInterpolationEnabled: true,
            oklabPreset: "STANDARD",
            // Use standard OKLAB enhancement for gradients
            gradientSmoothness: 0.8,
            // High smoothness for natural transitions
            animationThrottleFps: 30,
            // 30fps for smooth breathing while conserving performance
            enablePerformanceBudget: true,
            // Enable frame budget enforcement
            maxFrameTimeMs: 16
            // 16ms budget for 60fps main thread responsiveness
          };
          // CSS Animation Manager integration for Year 3000 performance revolution  
          this.cssAnimationManager = null;
          // Will be injected
          // OKLAB calculation caching
          this.oklabCache = /* @__PURE__ */ new Map();
          this.gradientCache = /* @__PURE__ */ new Map();
          this.cacheValidityMs = 5e3;
          // Cache valid for 5 seconds
          this.lastCacheCleanup = 0;
          /**
           * Debounced event handler to prevent excessive processing of high-frequency events
           */
          this.musicEventDebounceTimers = {
            musicState: 0,
            harmonizedColors: 0,
            webglState: 0,
            consciousnessIntensity: 0
          };
          this.eventDebounceMs = 100;
          this.cssController = cssController || getGlobalOptimizedCSSController();
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.deviceDetector = new DeviceCapabilityDetector();
          this.cssAnimationManager = cssAnimationManager;
          this.initializeBaseState();
          this.applyDeviceAwareSettings().catch((error) => {
            Y3KDebug?.debug?.warn(
              "LivingGradientStrategy",
              "Failed to apply device-aware settings:",
              error
            );
          });
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            "Living gradient strategy initialized with OKLAB interpolation and device-aware performance"
          );
        }
        /**
         * BaseVisualSystem lifecycle implementation
         */
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            this.setupConsciousnessListeners();
            this.setupWebGLIntegrationListeners();
            this.initializeBaseState();
            this.initializeConsciousnessBreathing();
            await this.applyLivingConsciousnessBase();
            Y3KDebug?.debug?.log(
              "LivingGradientStrategy",
              "Living gradient system awakened with visual system lifecycle"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "LivingGradientStrategy",
              "Failed to initialize living gradient system:",
              error
            );
          }
        }
        /**
         * Setup listeners for consciousness and dynamic color changes
         * Phase 2: Migrated from DOM events to UnifiedEventBus for proper facade coordination
         */
        setupConsciousnessListeners() {
          if (typeof unifiedEventBus !== "undefined") {
            unifiedEventBus.subscribe(
              "colors:harmonized",
              (data) => {
                if (data && data.processedColors) {
                  this.handleHarmonizedColorUpdate(data.processedColors);
                }
              },
              "LivingGradientStrategy"
            );
          }
          document.addEventListener("music-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.handleMusicStateChange(customEvent.detail);
            }
          });
          document.addEventListener(
            "consciousness-intensity-change",
            (event) => {
              const customEvent = event;
              if (customEvent.detail && typeof customEvent.detail.intensity === "number") {
                this.updateConsciousnessIntensity(customEvent.detail.intensity);
              }
            }
          );
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            "Consciousness listeners established"
          );
        }
        /**
         * Setup WebGL integration listeners
         */
        setupWebGLIntegrationListeners() {
          document.addEventListener("webgl-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.handleWebGLStateChange(customEvent.detail);
            }
          });
          document.addEventListener("webgl-gradient-update", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.coordinateWithWebGLGradient(customEvent.detail);
            }
          });
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            "WebGL integration listeners established"
          );
        }
        /**
         * Handle harmonized color updates from Dynamic Catppuccin Bridge
         */
        handleHarmonizedColorUpdate(harmonizedColors) {
          this.debouncedEventHandler("harmonizedColors", () => {
            const primaryColor = harmonizedColors.VIBRANT || harmonizedColors.PRIMARY || harmonizedColors.PROMINENT;
            if (primaryColor && primaryColor !== this.livingBaseState.currentPrimaryHex) {
              this.livingBaseState.currentPrimaryHex = primaryColor;
              const primaryRgb = this.utils.hexToRgb(primaryColor);
              if (primaryRgb) {
                this.livingBaseState.currentPrimaryRgb = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
              }
              this.updateLivingConsciousnessBase();
              this.triggerConsciousnessBreathing();
              Y3KDebug?.debug?.log(
                "LivingGradientStrategy",
                "Living base updated with harmonized colors:",
                primaryColor
              );
            }
          });
        }
        /**
         * Handle music state changes for energy-responsive base
         */
        handleMusicStateChange(musicState) {
          this.debouncedEventHandler("musicState", () => {
            if (musicState.energy !== void 0) {
              this.livingBaseState.musicEnergy = musicState.energy;
              const baseIntensity = 0.5;
              const energyBoost = musicState.energy * this.gradientConfig.musicResponsiveness;
              this.livingBaseState.consciousnessIntensity = Math.max(
                0.1,
                Math.min(1, baseIntensity + energyBoost * 0.3)
              );
              this.updateMusicResponsiveVariables();
            }
          });
        }
        /**
         * Handle WebGL system state changes
         */
        handleWebGLStateChange(webglState) {
          this.debouncedEventHandler("webglState", () => {
            if (webglState.enabled !== void 0) {
              this.livingBaseState.webglIntegrationActive = webglState.enabled;
              this.coordinateWithWebGLSystem(webglState.enabled);
              Y3KDebug?.debug?.log(
                "LivingGradientStrategy",
                `WebGL integration ${webglState.enabled ? "activated" : "deactivated"}`
              );
            }
          });
        }
        /**
         * Update consciousness intensity
         */
        updateConsciousnessIntensity(intensity) {
          this.debouncedEventHandler("consciousnessIntensity", () => {
            this.livingBaseState.consciousnessIntensity = Math.max(
              0,
              Math.min(1, intensity)
            );
            this.updateConsciousnessVariables();
          });
        }
        debouncedEventHandler(eventType, handler) {
          const now = performance.now();
          if (now - this.musicEventDebounceTimers[eventType] >= this.eventDebounceMs) {
            handler();
            this.musicEventDebounceTimers[eventType] = now;
          }
        }
        /**
         * Initialize CSS-first consciousness breathing (Year 3000 performance revolution)
         */
        initializeConsciousnessBreathing() {
          if (!this.gradientConfig.breathingAnimationEnabled) return;
          if (!this.cssAnimationManager) {
            Y3KDebug?.debug?.warn(
              "LivingGradientStrategy",
              "CSSAnimationManager not available, falling back to basic consciousness"
            );
            return;
          }
          this.triggerConsciousnessBreathing();
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            "CSS-first consciousness breathing initialized"
          );
        }
        /**
         * Trigger consciousness breathing using CSSAnimationManager (Year 3000 CSS-first)
         */
        triggerConsciousnessBreathing() {
          if (!this.cssAnimationManager || !this.gradientConfig.breathingAnimationEnabled) return;
          const consciousnessElements = document.querySelectorAll(
            ".Root__main-view::before, .Root__main-view, [data-consciousness-breathing]"
          );
          if (consciousnessElements.length === 0) {
            const mainView = document.querySelector(".Root__main-view") || document.body;
            if (mainView) {
              mainView.setAttribute("data-consciousness-breathing", "true");
              this.cssAnimationManager.triggerConsciousnessBreathing(
                [mainView],
                this.livingBaseState.musicEnergy,
                120
                // Default tempo
              );
            }
          } else {
            this.cssAnimationManager.triggerConsciousnessBreathing(
              consciousnessElements,
              this.livingBaseState.musicEnergy,
              120
              // Will be updated by music events
            );
          }
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            `CSS-first consciousness breathing triggered for ${consciousnessElements.length} elements`
          );
        }
        /**
         * Apply device-aware performance settings based on device capabilities
         */
        async applyDeviceAwareSettings() {
          if (!this.deviceDetector.isInitialized) {
            try {
              await this.deviceDetector.initialize();
            } catch (error) {
              Y3KDebug?.debug?.warn(
                "LivingGradientStrategy",
                "Device detection failed, using default settings:",
                error
              );
              return;
            }
          }
          const capabilities = this.deviceDetector.getCapabilities();
          if (!capabilities) {
            Y3KDebug?.debug?.warn(
              "LivingGradientStrategy",
              "No device capabilities available, using default settings"
            );
            return;
          }
          const overallTier = capabilities.overall;
          switch (overallTier) {
            case "high":
              this.gradientConfig.animationThrottleFps = 30;
              this.gradientConfig.maxFrameTimeMs = 16;
              this.gradientConfig.enablePerformanceBudget = true;
              break;
            case "medium":
              this.gradientConfig.animationThrottleFps = 20;
              this.gradientConfig.maxFrameTimeMs = 20;
              this.gradientConfig.enablePerformanceBudget = true;
              break;
            case "low":
              this.gradientConfig.animationThrottleFps = 15;
              this.gradientConfig.maxFrameTimeMs = 33;
              this.gradientConfig.enablePerformanceBudget = true;
              this.gradientConfig.consciousnessLayerOpacity *= 0.7;
              this.gradientConfig.organicFlowIntensity *= 0.8;
              this.gradientConfig.oklabInterpolationEnabled = false;
              break;
            default:
              this.gradientConfig.animationThrottleFps = 20;
              this.gradientConfig.maxFrameTimeMs = 20;
              break;
          }
          if (!capabilities.gpu.supportsWebGL) {
            this.gradientConfig.webglIntegrationEnabled = false;
          }
          if (capabilities.memory.level === "low") {
            this.cacheValidityMs = 2e3;
          }
          if (capabilities.cpu.cores <= 2) {
            this.gradientConfig.animationThrottleFps = Math.min(
              this.gradientConfig.animationThrottleFps,
              15
            );
          }
          if (capabilities.display.reducedMotion) {
            this.gradientConfig.breathingAnimationEnabled = false;
            Y3KDebug?.debug?.log(
              "LivingGradientStrategy",
              "Breathing animation disabled due to reduced motion preference"
            );
          }
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            `Device-aware settings applied for ${overallTier}: ${this.gradientConfig.animationThrottleFps}fps, CSS-first breathing coordination`
          );
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "living-gradient";
        }
        /**
         * Check if strategy can handle the given context
         */
        canProcess(context) {
          return this.gradientConfig.baseTransformationEnabled;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          return 8;
        }
        /**
         * Process colors using Living Gradient strategy with OKLAB interpolation
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const primaryColor = this.selectPrimaryColor(context.rawColors);
            const secondaryColor = this.selectSecondaryColor(context.rawColors);
            if (!primaryColor) {
              throw new Error("No suitable primary color found for living gradient");
            }
            let processedPrimary = primaryColor;
            let processedSecondary = secondaryColor;
            let oklabGradientStops = [];
            if (this.gradientConfig.oklabInterpolationEnabled && primaryColor) {
              const preset = OKLABColorProcessor.getPreset(
                this.gradientConfig.oklabPreset
              );
              const primaryResult = this.oklabProcessor.processColor(
                primaryColor,
                preset
              );
              processedPrimary = primaryResult.enhancedHex;
              if (secondaryColor) {
                const secondaryResult = this.oklabProcessor.processColor(
                  secondaryColor,
                  preset
                );
                processedSecondary = secondaryResult.enhancedHex;
                const stopCount = Math.ceil(5 * this.gradientConfig.gradientSmoothness) + 3;
                oklabGradientStops = this.oklabProcessor.generateOKLABGradient(
                  processedPrimary,
                  processedSecondary,
                  stopCount,
                  preset
                );
              } else {
                const baseColor = this.livingBaseState.currentBaseHex;
                oklabGradientStops = this.oklabProcessor.generateOKLABGradient(
                  processedPrimary,
                  baseColor,
                  5,
                  preset
                );
                processedSecondary = oklabGradientStops[oklabGradientStops.length - 1]?.enhancedHex || processedPrimary;
              }
              Y3KDebug?.debug?.log(
                "LivingGradientStrategy",
                "OKLAB gradient processing applied:",
                {
                  originalPrimary: primaryColor,
                  processedPrimary,
                  originalSecondary: secondaryColor,
                  processedSecondary,
                  gradientStops: oklabGradientStops.length,
                  preset: preset.name
                }
              );
            }
            await this.updateLivingBaseState(
              processedPrimary,
              processedSecondary,
              context,
              oklabGradientStops
            );
            await this.applyLivingConsciousnessBase();
            this.triggerConsciousnessBreathing();
            await this.updateWebGLIntegration();
            const processingTime = performance.now() - startTime;
            const result = {
              processedColors: {
                primary: processedPrimary,
                secondary: processedSecondary || processedPrimary,
                originalPrimary: primaryColor,
                // Keep original for reference
                ...secondaryColor && { originalSecondary: secondaryColor },
                livingBase: this.livingBaseState.currentBaseHex,
                ...context.rawColors
              },
              accentHex: processedPrimary,
              accentRgb: this.livingBaseState.currentPrimaryRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `living-gradient-${context.trackUri}`,
                harmonicIntensity: this.gradientConfig.organicFlowIntensity,
                oklabInterpolation: this.gradientConfig.oklabInterpolationEnabled,
                oklabPreset: this.gradientConfig.oklabPreset,
                gradientStopCount: oklabGradientStops.length,
                gradientSmoothness: this.gradientConfig.gradientSmoothness
              },
              context
            };
            Y3KDebug?.debug?.log(
              "LivingGradientStrategy",
              "Living gradient processing completed",
              {
                originalPrimary: primaryColor,
                processedPrimary,
                originalSecondary: secondaryColor,
                processedSecondary,
                oklabProcessing: this.gradientConfig.oklabInterpolationEnabled,
                gradientStops: oklabGradientStops.length,
                processingTime,
                trackUri: context.trackUri
              }
            );
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3KDebug?.debug?.error(
              "LivingGradientStrategy",
              "Living gradient processing failed:",
              error
            );
            return {
              processedColors: context.rawColors,
              accentHex: this.livingBaseState.currentPrimaryHex,
              accentRgb: this.livingBaseState.currentPrimaryRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error"
              },
              context
            };
          }
        }
        /**
         * Initialize base state from existing CSS variables
         */
        initializeBaseState() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentBase = computedStyle.getPropertyValue("--spice-base").trim() || "#1e1e2e";
          this.livingBaseState.currentBaseHex = currentBase;
          const baseRgb = this.utils.hexToRgb(currentBase);
          if (baseRgb) {
            this.livingBaseState.currentBaseRgb = `${baseRgb.r},${baseRgb.g},${baseRgb.b}`;
          }
          const currentPrimary = computedStyle.getPropertyValue("--sn-bg-gradient-primary-rgb").trim();
          if (currentPrimary) {
            const rgbValues = currentPrimary.split(",").map((v) => parseInt(v.trim()));
            if (rgbValues.length === 3) {
              this.livingBaseState.currentPrimaryRgb = currentPrimary;
              this.livingBaseState.currentPrimaryHex = this.utils.rgbToHex(
                rgbValues[0],
                rgbValues[1],
                rgbValues[2]
              );
            }
          }
          this.livingBaseState.lastUpdateTime = Date.now();
          Y3KDebug?.debug?.log("LivingGradientStrategy", "Base state initialized:", {
            base: this.livingBaseState.currentBaseHex,
            primary: this.livingBaseState.currentPrimaryHex
          });
        }
        /**
         * Select primary color for living gradient
         */
        selectPrimaryColor(colors) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "PROMINENT",
            "VIBRANT_NON_ALARMING",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Select secondary color for gradient complexity
         */
        selectSecondaryColor(colors) {
          const priorities = [
            "SECONDARY",
            "DARK_VIBRANT",
            "DESATURATED",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Update living base state with new colors and context including OKLAB data
         */
        async updateLivingBaseState(primaryColor, secondaryColor, context, oklabGradientStops = []) {
          const primaryRgb = this.utils.hexToRgb(primaryColor);
          if (!primaryRgb) return;
          this.livingBaseState.currentPrimaryHex = primaryColor;
          this.livingBaseState.currentPrimaryRgb = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          this.livingBaseState.oklabGradientStops = oklabGradientStops;
          if (context.musicData?.energy !== void 0) {
            this.livingBaseState.musicEnergy = context.musicData.energy;
            const baseIntensity = this.gradientConfig.consciousnessLayerOpacity;
            const musicMultiplier = 1 + context.musicData.energy * this.gradientConfig.musicResponsiveness;
            this.livingBaseState.consciousnessIntensity = Math.max(
              0.05,
              Math.min(1, baseIntensity * musicMultiplier)
            );
          }
          this.livingBaseState.lastUpdateTime = Date.now();
        }
        /**
         * Apply living consciousness base gradient using coordinated updates
         */
        async applyLivingConsciousnessBase() {
          const consciousnessGradient = this.createLivingGradient(
            this.livingBaseState.oklabGradientStops
          );
          const currentTime = performance.now();
          const breathingPhase = currentTime / 4e3 * Math.PI * 2;
          const breathingMultiplier = 1 + Math.sin(breathingPhase) * 0.2;
          const finalOpacity = this.livingBaseState.consciousnessIntensity * breathingMultiplier;
          const flowX = Math.sin(breathingPhase * 0.7) * this.gradientConfig.organicFlowIntensity;
          const flowY = Math.cos(breathingPhase * 0.5) * this.gradientConfig.organicFlowIntensity;
          const baseDuration = 4e3;
          const energyMultiplier = 0.5 + this.livingBaseState.musicEnergy * 1.5;
          const breathingDuration = baseDuration / energyMultiplier;
          const consciousnessBaseVariables = {
            "--living-base-gradient": consciousnessGradient,
            "--consciousness-base-gradient": consciousnessGradient,
            "--consciousness-layer-opacity": finalOpacity.toString(),
            "--consciousness-flow-x": `${flowX}%`,
            "--consciousness-flow-y": `${flowY}%`,
            "--consciousness-breathing-duration": `${breathingDuration}ms`
          };
          await this.cssController.batchSetVariables(
            "LivingGradientStrategy",
            consciousnessBaseVariables,
            "high",
            // High priority for consciousness animations
            "living-consciousness-base"
          );
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            "Applied coordinated living consciousness base gradient"
          );
        }
        /**
         * Create cached gradient key for OKLAB gradient generation
         */
        createGradientCacheKey(primaryRgb, baseRgb, oklabGradientStops, breathingPhase) {
          const stopKey = oklabGradientStops.map((stop, index) => `${stop.enhancedHex}-${index}`).join("|");
          return `${primaryRgb}-${baseRgb}-${stopKey}-${Math.floor(
            breathingPhase * 10
          )}`;
        }
        /**
         * Clean up expired cache entries
         */
        cleanupCache() {
          const now = Date.now();
          if (now - this.lastCacheCleanup < 1e4) return;
          this.lastCacheCleanup = now;
          this.gradientCache.clear();
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log("LivingGradientStrategy", "Cache cleanup completed");
          }
        }
        /**
         * Create living gradient based on current state with OKLAB enhancement and caching
         */
        createLivingGradient(oklabGradientStops = []) {
          const primaryRgb = this.livingBaseState.currentPrimaryRgb;
          const baseRgb = this.livingBaseState.currentBaseRgb;
          const currentTime = performance.now();
          const breathingPhase = currentTime / 4e3 * Math.PI * 2;
          const cacheKey = this.createGradientCacheKey(
            primaryRgb,
            baseRgb,
            oklabGradientStops,
            breathingPhase
          );
          const cachedGradient = this.gradientCache.get(cacheKey);
          if (cachedGradient) {
            this.cleanupCache();
            return cachedGradient;
          }
          const gradient = this.generateLivingGradient(
            primaryRgb,
            baseRgb,
            oklabGradientStops
          );
          this.gradientCache.set(cacheKey, gradient);
          return gradient;
        }
        /**
         * Generate the actual gradient (extracted for caching)
         */
        generateLivingGradient(primaryRgb, baseRgb, oklabGradientStops) {
          if (this.gradientConfig.oklabInterpolationEnabled && oklabGradientStops.length > 0) {
            const gradientStops = oklabGradientStops.map((stop, index) => {
              const percentage = index / (oklabGradientStops.length - 1) * 100;
              const rgb = `${stop.enhancedRgb.r},${stop.enhancedRgb.g},${stop.enhancedRgb.b}`;
              const opacity = 0.6 * (1 - index / oklabGradientStops.length) + 0.1;
              return `rgba(${rgb}, calc(var(--consciousness-layer-opacity) * ${opacity})) ${percentage}%`;
            }).join(", ");
            return `
        radial-gradient(
          ellipse at calc(50% + var(--consciousness-flow-x)) calc(50% + var(--consciousness-flow-y)),
          ${gradientStops}
        ),
        linear-gradient(
          135deg,
          rgba(${oklabGradientStops[0]?.enhancedRgb.r || primaryRgb.split(",")[0]},${oklabGradientStops[0]?.enhancedRgb.g || primaryRgb.split(",")[1]},${oklabGradientStops[0]?.enhancedRgb.b || primaryRgb.split(",")[2]}, calc(var(--consciousness-layer-opacity) * 0.4)) 0%,
          var(--spice-base) 50%,
          rgba(${oklabGradientStops[oklabGradientStops.length - 1]?.enhancedRgb.r || primaryRgb.split(",")[0]},${oklabGradientStops[oklabGradientStops.length - 1]?.enhancedRgb.g || primaryRgb.split(",")[1]},${oklabGradientStops[oklabGradientStops.length - 1]?.enhancedRgb.b || primaryRgb.split(",")[2]}, calc(var(--consciousness-layer-opacity) * 0.2)) 100%
        ),
        var(--spice-base)
      `;
          }
          return `
      radial-gradient(
        ellipse at calc(50% + var(--consciousness-flow-x)) calc(50% + var(--consciousness-flow-y)),
        rgba(${primaryRgb}, calc(var(--consciousness-layer-opacity) * 0.6)) 0%,
        rgba(${primaryRgb}, calc(var(--consciousness-layer-opacity) * 0.3)) 30%,
        rgba(${baseRgb}, calc(var(--consciousness-layer-opacity) * 0.1)) 60%,
        var(--spice-base) 100%
      ),
      linear-gradient(
        135deg,
        rgba(${primaryRgb}, calc(var(--consciousness-layer-opacity) * 0.4)) 0%,
        var(--spice-base) 50%,
        rgba(${primaryRgb}, calc(var(--consciousness-layer-opacity) * 0.2)) 100%
      ),
      var(--spice-base)
    `;
        }
        /**
         * Update breathing animation (Year 3000 CSS-first approach)
         */
        updateBreathingAnimation() {
          this.triggerConsciousnessBreathing();
        }
        /**
         * Start breathing animation (Year 3000 CSS-first approach)
         */
        startBreathingAnimation() {
          this.triggerConsciousnessBreathing();
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            "CSS-first consciousness breathing started - 90%+ JavaScript overhead eliminated"
          );
        }
        /**
         * Schedule debounced CSS updates (Year 3000 - No longer needed with CSS-first approach)
         */
        scheduleDebouncedCssUpdate() {
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            "Debounced CSS updates eliminated - using CSS-first breathing"
          );
        }
        /**
         * Update WebGL integration variables using coordinated updates
         */
        async updateWebGLIntegration() {
          if (!this.gradientConfig.webglIntegrationEnabled) return;
          const webglIntegrationVariables = {
            "--sn-bg-gradient-primary-rgb": this.livingBaseState.currentPrimaryRgb,
            "--sn-webgl-living-gradient-sync": "1",
            "--sn-gradient-consciousness-level": this.livingBaseState.consciousnessIntensity.toString()
          };
          await this.cssController.batchSetVariables(
            "LivingGradientStrategy",
            webglIntegrationVariables,
            "high",
            // High priority for WebGL coordination
            "webgl-living-gradient-integration"
          );
          this.livingBaseState.webglIntegrationActive = true;
          Y3KDebug?.debug?.log("LivingGradientStrategy", "WebGL integration updated");
        }
        /**
         * Get current living base state for debugging
         */
        getLivingBaseState() {
          return { ...this.livingBaseState };
        }
        /**
         * Update living consciousness base when colors change
         */
        updateLivingConsciousnessBase() {
          this.applyLivingConsciousnessBase().catch((error) => {
            Y3KDebug?.debug?.error(
              "LivingGradientStrategy",
              "Failed to update living consciousness base:",
              error
            );
          });
          const updateEvent = new CustomEvent("living-base-update", {
            detail: {
              baseHex: this.livingBaseState.currentBaseHex,
              primaryHex: this.livingBaseState.currentPrimaryHex,
              consciousnessIntensity: this.livingBaseState.consciousnessIntensity,
              timestamp: Date.now()
            }
          });
          document.dispatchEvent(updateEvent);
        }
        /**
         * Update music-responsive variables
         */
        updateMusicResponsiveVariables() {
          const musicResponsiveVariables = {
            "--consciousness-music-energy": this.livingBaseState.musicEnergy.toString(),
            "--consciousness-music-intensity": this.livingBaseState.consciousnessIntensity.toString()
          };
          this.cssController.batchSetVariables(
            "LivingGradientStrategy",
            musicResponsiveVariables,
            3,
            // medium priority
            "music-responsive"
          ).catch((error) => {
            Y3KDebug?.debug?.error(
              "LivingGradientStrategy",
              "Failed to update music responsive variables:",
              error
            );
          });
        }
        /**
         * Update consciousness variables
         */
        updateConsciousnessVariables() {
          const consciousnessVariables = {
            "--consciousness-intensity-global": this.livingBaseState.consciousnessIntensity.toString(),
            "--consciousness-layer-opacity": (this.gradientConfig.consciousnessLayerOpacity * this.livingBaseState.consciousnessIntensity).toString()
          };
          this.cssController.batchSetVariables(
            "LivingGradientStrategy",
            consciousnessVariables,
            3,
            // medium priority
            "consciousness-vars"
          ).catch((error) => {
            Y3KDebug?.debug?.error(
              "LivingGradientStrategy",
              "Failed to update consciousness variables:",
              error
            );
          });
        }
        /**
         * Coordinate with WebGL gradient system
         */
        coordinateWithWebGLSystem(webglEnabled) {
          const webglCoordinationVariables = webglEnabled ? {
            // Reduce CSS layer opacity to allow WebGL to dominate
            "--consciousness-webgl-coordination": "0.7",
            "--consciousness-css-fallback": "0.3"
          } : {
            // Full CSS consciousness when WebGL is disabled
            "--consciousness-webgl-coordination": "0",
            "--consciousness-css-fallback": "1.0"
          };
          this.cssController.batchSetVariables(
            "LivingGradientStrategy",
            webglCoordinationVariables,
            "high",
            "webgl-coordination"
          ).catch((error) => {
            Y3KDebug?.debug?.error(
              "LivingGradientStrategy",
              "Failed to coordinate with WebGL system:",
              error
            );
          });
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            `WebGL coordination ${webglEnabled ? "enabled" : "disabled"}`
          );
        }
        /**
         * Coordinate with WebGL gradient updates
         */
        coordinateWithWebGLGradient(webglData) {
          if (!this.gradientConfig.webglIntegrationEnabled) return;
          if (webglData.flowState) {
            this.updateFlowStateFromWebGL(webglData.flowState);
          }
          if (webglData.colorState) {
            this.updateColorStateFromWebGL(webglData.colorState);
          }
        }
        /**
         * Update flow state from WebGL system
         */
        updateFlowStateFromWebGL(flowState) {
          const flowVariables = {};
          if (flowState.flowX !== void 0) {
            flowVariables["--consciousness-webgl-flow-x"] = `${flowState.flowX}%`;
          }
          if (flowState.flowY !== void 0) {
            flowVariables["--consciousness-webgl-flow-y"] = `${flowState.flowY}%`;
          }
          if (flowState.flowScale !== void 0) {
            flowVariables["--consciousness-webgl-scale"] = flowState.flowScale.toString();
          }
          if (Object.keys(flowVariables).length > 0) {
            this.cssController.batchSetVariables(
              "LivingGradientStrategy",
              flowVariables,
              3,
              // medium priority
              "webgl-flow"
            ).catch((error) => {
              Y3KDebug?.debug?.error(
                "LivingGradientStrategy",
                "Failed to update WebGL flow state:",
                error
              );
            });
          }
        }
        /**
         * Update color state from WebGL system
         */
        updateColorStateFromWebGL(colorState) {
          if (colorState.primaryColor) {
            this.livingBaseState.currentPrimaryRgb = colorState.primaryColor;
            this.updateLivingConsciousnessBase();
          }
        }
        /**
         * Health check to include both strategy and visual system status
         */
        async healthCheck() {
          const strategyHealth = await this.getStrategyHealthCheck();
          return {
            healthy: strategyHealth.healthy && this.isActive,
            canProcess: strategyHealth.canProcess,
            issues: strategyHealth.issues || [],
            metrics: {
              ...strategyHealth.metrics,
              systemType: "consolidated-living-gradient",
              isVisualSystem: true,
              isColorProcessor: true,
              isActive: this.isActive,
              initialized: this.initialized
            }
          };
        }
        /**
         * Get strategy-specific health check data
         */
        async getStrategyHealthCheck() {
          const hasRecentUpdate = Date.now() - this.livingBaseState.lastUpdateTime < 3e4;
          return {
            healthy: this.gradientConfig.baseTransformationEnabled,
            canProcess: this.gradientConfig.baseTransformationEnabled,
            issues: !this.gradientConfig.baseTransformationEnabled ? ["Base transformation disabled in configuration"] : [],
            metrics: {
              baseTransformationEnabled: this.gradientConfig.baseTransformationEnabled,
              breathingAnimationEnabled: this.gradientConfig.breathingAnimationEnabled,
              webglIntegrationActive: this.livingBaseState.webglIntegrationActive,
              consciousnessIntensity: this.livingBaseState.consciousnessIntensity,
              musicEnergy: this.livingBaseState.musicEnergy,
              hasRecentUpdate,
              cssFirstBreathing: true,
              // CSS-first breathing replaces JavaScript animation
              oklabInterpolation: this.gradientConfig.oklabInterpolationEnabled,
              oklabPreset: this.gradientConfig.oklabPreset,
              gradientSmoothness: this.gradientConfig.gradientSmoothness,
              oklabGradientStops: this.livingBaseState.oklabGradientStops.length
            }
          };
        }
        /**
         * Override destroy method to include both strategy and visual system cleanup
         */
        destroy() {
          if (this.cssAnimationManager) {
            this.cssAnimationManager.stopConsciousnessBreathing();
          }
          this.oklabCache.clear();
          this.gradientCache.clear();
          super.destroy();
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            "Consolidated living gradient system destroyed with complete cleanup"
          );
        }
        /**
         * Override BaseVisualSystem cleanup method
         */
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            "Living gradient system cleaned up"
          );
        }
        /**
         * Update configuration
         */
        updateConfig(newConfig) {
          this.gradientConfig = { ...this.gradientConfig, ...newConfig };
          if ("oklabInterpolationEnabled" in newConfig || "oklabPreset" in newConfig) {
            this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          }
          Y3KDebug?.debug?.log("LivingGradientStrategy", "Configuration updated:", {
            ...newConfig,
            oklabInterpolation: this.gradientConfig.oklabInterpolationEnabled,
            oklabPreset: this.gradientConfig.oklabPreset,
            gradientSmoothness: this.gradientConfig.gradientSmoothness
          });
        }
        /**
         * Stop breathing animation (Year 3000 CSS-first approach)
         */
        stopBreathingAnimation() {
          if (this.cssAnimationManager) {
            this.cssAnimationManager.stopConsciousnessBreathing();
          }
          Y3KDebug?.debug?.log(
            "LivingGradientStrategy",
            "CSS-first consciousness breathing stopped"
          );
        }
      };
      __name(_LivingGradientStrategy, "LivingGradientStrategy");
      LivingGradientStrategy = _LivingGradientStrategy;
    }
  });

  // src-js/utils/graphics/ShaderLoader.ts
  var ShaderLoader_exports = {};
  __export(ShaderLoader_exports, {
    DEFAULT_VERTEX_SHADER: () => DEFAULT_VERTEX_SHADER,
    ShaderLoader: () => ShaderLoader,
    createGradientTexture: () => createGradientTexture
  });
  function createGradientTexture(gl, stops, width = 256) {
    try {
      if (!gl) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "WebGL context is null or undefined"
        );
        return null;
      }
      if (!stops || stops.length === 0) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Invalid or empty color stops array"
        );
        return null;
      }
      if (width <= 0 || width > 8192) {
        Y3KDebug?.debug?.error("ShaderLoader", `Invalid texture width: ${width}`);
        return null;
      }
      const glError = gl.getError();
      if (glError !== gl.NO_ERROR) {
        Y3KDebug?.debug?.warn(
          "ShaderLoader",
          `WebGL context has pending error: ${glError}`
        );
      }
      if (gl.isContextLost()) {
        Y3KDebug?.debug?.error("ShaderLoader", "WebGL context is lost");
        return null;
      }
      const canvas = document.createElement("canvas");
      if (!canvas) {
        Y3KDebug?.debug?.error("ShaderLoader", "Failed to create canvas element");
        return null;
      }
      canvas.width = width;
      canvas.height = 1;
      const ctx = canvas.getContext("2d", { willReadFrequently: false });
      if (!ctx) {
        Y3KDebug?.debug?.error("ShaderLoader", "Failed to get 2D canvas context");
        return null;
      }
      const validStops = stops.filter((stop) => {
        if (typeof stop.r !== "number" || typeof stop.g !== "number" || typeof stop.b !== "number" || typeof stop.a !== "number" || typeof stop.position !== "number") {
          Y3KDebug?.debug?.warn(
            "ShaderLoader",
            "Invalid color stop found, skipping"
          );
          return false;
        }
        if (stop.position < 0 || stop.position > 1) {
          Y3KDebug?.debug?.warn(
            "ShaderLoader",
            `Invalid color stop position: ${stop.position}, clamping`
          );
          stop.position = Math.max(0, Math.min(1, stop.position));
        }
        return true;
      });
      if (validStops.length === 0) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "No valid color stops after validation"
        );
        return null;
      }
      validStops.sort((a, b) => a.position - b.position);
      const gradient = ctx.createLinearGradient(0, 0, width, 0);
      if (!gradient) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Failed to create linear gradient"
        );
        return null;
      }
      try {
        validStops.forEach((stop, index) => {
          const r = Math.max(0, Math.min(255, Math.round(stop.r * 255)));
          const g = Math.max(0, Math.min(255, Math.round(stop.g * 255)));
          const b = Math.max(0, Math.min(255, Math.round(stop.b * 255)));
          const a = Math.max(0, Math.min(1, stop.a));
          const color3 = `rgba(${r}, ${g}, ${b}, ${a})`;
          gradient.addColorStop(stop.position, color3);
        });
      } catch (error) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Failed to add color stops to gradient:",
          error
        );
        return null;
      }
      try {
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, 1);
      } catch (error) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Failed to fill canvas with gradient:",
          error
        );
        return null;
      }
      const texture = gl.createTexture();
      if (!texture) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Failed to create WebGL texture - gl.createTexture() returned null"
        );
        return null;
      }
      try {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const bindError = gl.getError();
        if (bindError !== gl.NO_ERROR) {
          Y3KDebug?.debug?.error(
            "ShaderLoader",
            `WebGL error after texture binding: ${bindError}`
          );
          gl.deleteTexture(texture);
          return null;
        }
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          canvas
        );
        const uploadError = gl.getError();
        if (uploadError !== gl.NO_ERROR) {
          Y3KDebug?.debug?.error(
            "ShaderLoader",
            `WebGL error after texture upload: ${uploadError}`
          );
          gl.deleteTexture(texture);
          return null;
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        const paramError = gl.getError();
        if (paramError !== gl.NO_ERROR) {
          Y3KDebug?.debug?.error(
            "ShaderLoader",
            `WebGL error after setting texture parameters: ${paramError}`
          );
          gl.deleteTexture(texture);
          return null;
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
        Y3KDebug?.debug?.log(
          "ShaderLoader",
          `Gradient texture created successfully: ${width}x1, ${validStops.length} stops`
        );
        return texture;
      } catch (error) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Exception during WebGL texture operations:",
          error
        );
        if (texture) {
          gl.deleteTexture(texture);
        }
        return null;
      }
    } catch (error) {
      Y3KDebug?.debug?.error(
        "ShaderLoader",
        `Gradient texture creation failed: ${error instanceof Error ? error.message : "Unknown error"}`
      );
      return null;
    }
  }
  var _ShaderLoader, ShaderLoader, DEFAULT_VERTEX_SHADER;
  var init_ShaderLoader = __esm({
    "src-js/utils/graphics/ShaderLoader.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _ShaderLoader = class _ShaderLoader {
        /**
         * Load and compile a fragment shader from source
         * @param gl WebGL2 rendering context
         * @param source GLSL fragment shader source code
         * @param cacheKey Optional cache key (defaults to hash of source)
         * @returns Compiled WebGL shader or null on failure
         */
        static loadFragment(gl, source, cacheKey) {
          const key = cacheKey || this.hashSource(source);
          const contextCache = this.getContextCache(gl);
          if (contextCache[key]) {
            return contextCache[key];
          }
          try {
            const shader = this.compileShader(gl, gl.FRAGMENT_SHADER, source);
            if (shader) {
              contextCache[key] = shader;
              Y3KDebug?.debug?.log(
                "ShaderLoader",
                `Fragment shader compiled: ${key.substring(0, 8)}...`
              );
            }
            return shader;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ShaderLoader",
              `Fragment shader compilation failed: ${error}`
            );
            return null;
          }
        }
        /**
         * Load and compile a vertex shader from source
         * @param gl WebGL2 rendering context
         * @param source GLSL vertex shader source code
         * @param cacheKey Optional cache key
         * @returns Compiled WebGL shader or null on failure
         */
        static loadVertex(gl, source, cacheKey) {
          const key = cacheKey || this.hashSource(source);
          const contextCache = this.getContextCache(gl);
          if (contextCache[key]) {
            return contextCache[key];
          }
          try {
            const shader = this.compileShader(gl, gl.VERTEX_SHADER, source);
            if (shader) {
              contextCache[key] = shader;
              Y3KDebug?.debug?.log(
                "ShaderLoader",
                `Vertex shader compiled: ${key.substring(0, 8)}...`
              );
            }
            return shader;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ShaderLoader",
              `Vertex shader compilation failed: ${error}`
            );
            return null;
          }
        }
        /**
         * Create a shader program from vertex and fragment shaders
         * @param gl WebGL2 rendering context
         * @param vertexShader Compiled vertex shader
         * @param fragmentShader Compiled fragment shader
         * @returns WebGL program or null on failure
         */
        static createProgram(gl, vertexShader, fragmentShader) {
          try {
            const program = gl.createProgram();
            if (!program) return null;
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
              const info = gl.getProgramInfoLog(program);
              gl.deleteProgram(program);
              throw new Error(`Program linking failed: ${info}`);
            }
            return program;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ShaderLoader",
              `Program creation failed: ${error}`
            );
            return null;
          }
        }
        /**
         * Clear shader cache for a specific WebGL context
         * @param gl WebGL2 rendering context
         */
        static clearCache(gl) {
          const contextCache = this.cache.get(gl);
          if (contextCache) {
            Object.values(contextCache).forEach((shader) => {
              gl.deleteShader(shader);
            });
            this.cache.delete(gl);
          }
        }
        /**
         * Clear all shader caches (use on theme hot-reload)
         */
        static clearAllCaches() {
          this.cache.clear();
        }
        static compileShader(gl, type, source) {
          const shader = gl.createShader(type);
          if (!shader) return null;
          gl.shaderSource(shader, source);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            const info = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error(`Shader compilation failed: ${info}`);
          }
          return shader;
        }
        /**
         * Clear shader cache for a specific WebGL context
         * This should be called when the WebGL context is lost to prevent
         * reusing invalid shader objects after context restoration
         */
        static clearContextCache(gl) {
          if (this.cache.has(gl)) {
            const contextCache = this.cache.get(gl);
            Object.values(contextCache).forEach((shader) => {
              if (shader && gl && !gl.isContextLost()) {
                try {
                  gl.deleteShader(shader);
                } catch (e) {
                }
              }
            });
            this.cache.set(gl, {});
            Y3KDebug?.debug?.log(
              "ShaderLoader",
              "Context cache cleared due to WebGL context loss/restore"
            );
          }
        }
        static getContextCache(gl) {
          if (!this.cache.has(gl)) {
            this.cache.set(gl, {});
          }
          return this.cache.get(gl);
        }
        static hashSource(source) {
          let hash = 0;
          for (let i = 0; i < source.length; i++) {
            const char = source.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
          }
          return hash.toString(16);
        }
      };
      __name(_ShaderLoader, "ShaderLoader");
      _ShaderLoader.cache = /* @__PURE__ */ new Map();
      ShaderLoader = _ShaderLoader;
      DEFAULT_VERTEX_SHADER = `#version 300 es
precision mediump float;

in vec2 a_position;
out vec2 v_uv;

void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;
      __name(createGradientTexture, "createGradientTexture");
    }
  });

  // src-js/visual/strategies/WebGLGradientStrategy.ts
  var FLOW_GRADIENT_SHADER, _WebGLGradientStrategy, WebGLGradientStrategy;
  var init_WebGLGradientStrategy = __esm({
    "src-js/visual/strategies/WebGLGradientStrategy.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_config();
      init_OKLABColorProcessor();
      init_PaletteSystemManager();
      init_Year3000Utilities();
      init_ShaderLoader();
      FLOW_GRADIENT_SHADER = `#version 300 es
precision mediump float;

uniform float u_time;
uniform sampler2D u_gradientTex;
uniform vec2 u_resolution;
uniform float u_flowStrength;
uniform float u_noiseScale;

// Wave stack uniforms
uniform float u_waveY[2];
uniform float u_waveHeight[2];
uniform float u_waveOffset[2];
uniform float u_blurExp;
uniform float u_blurMax;

out vec4 fragColor;

// Simplex noise implementation
vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

  i = mod289(i);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// Octave noise for richer detail
float octaveNoise(vec2 uv, float octaves, float persistence, float scale) {
  float value = 0.0;
  float amplitude = 1.0;
  float frequency = scale;
  float maxValue = 0.0;

  for(float i = 0.0; i < octaves; i++) {
    value += snoise(uv * frequency) * amplitude;
    maxValue += amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return value / maxValue;
}

// Wave alpha calculation with smooth transitions
float wave_alpha(vec2 uv, int waveIndex) {
  float y = uv.y;
  float waveCenter = u_waveY[waveIndex];
  float waveHeight = u_waveHeight[waveIndex];

  float distance = abs(y - waveCenter);
  float alpha = 1.0 - smoothstep(0.0, waveHeight * 0.5, distance);

  return alpha;
}

// Dynamic blur calculation using power function
float calc_blur(vec2 uv) {
  vec2 center = vec2(0.5, 0.5);
  float distance = length(uv - center);

  float blur = pow(distance, u_blurExp);
  blur = clamp(blur, 0.0, u_blurMax);

  return blur;
}

// Background noise generator with time offset
float background_noise(vec2 uv, float timeOffset) {
  vec2 flowUV = uv;
  float adjustedTime = u_time + timeOffset;

  flowUV.x += adjustedTime * 0.02 * u_flowStrength;
  flowUV.y += sin(adjustedTime * 0.03 + uv.x * 3.14159) * 0.01 * u_flowStrength;

  float noise1 = octaveNoise(flowUV * u_noiseScale, 4.0, 0.5, 1.0);
  float noise2 = octaveNoise(flowUV * u_noiseScale * 2.0 + vec2(100.0), 3.0, 0.4, 1.0);

  return (noise1 + noise2 * 0.3) * 0.5 + 0.5;
}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;

  // Generate three distinct background noise fields with time offsets
  float noise1 = background_noise(uv, u_waveOffset[0]);
  float noise2 = background_noise(uv, u_waveOffset[1]);
  float noise3 = background_noise(uv, 0.0); // Base noise without offset

  // Calculate wave alphas for blending
  float alpha1 = wave_alpha(uv, 0);
  float alpha2 = wave_alpha(uv, 1);
  float alpha3 = 1.0 - alpha1 - alpha2; // Remaining area
  alpha3 = max(alpha3, 0.0); // Ensure non-negative

  // Normalize alphas to ensure they sum to 1.0
  float totalAlpha = alpha1 + alpha2 + alpha3;
  if (totalAlpha > 0.0) {
    alpha1 /= totalAlpha;
    alpha2 /= totalAlpha;
    alpha3 /= totalAlpha;
  }

  // Blend the three noise fields based on wave alphas
  float t = noise1 * alpha1 + noise2 * alpha2 + noise3 * alpha3;
  t = clamp(t, 0.0, 1.0);

  // Sample gradient texture
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));

  // Apply dynamic blur based on position
  float blurAmount = calc_blur(uv);

  // Apply subtle vignette with blur modulation
  vec2 center = uv - 0.5;
  float vignette = 1.0 - dot(center, center) * (0.3 + blurAmount * 0.2);
  color.rgb *= vignette;

  // Apply blur effect to alpha channel for depth
  color.a *= (1.0 - blurAmount * 0.3);

  fragColor = color;
}`;
      _WebGLGradientStrategy = class _WebGLGradientStrategy {
        constructor(cssController) {
          this.utils = Year3000Utilities_exports;
          this.config = YEAR3000_CONFIG;
          this.webglState = {
            canvas: null,
            wrapper: null,
            gl: null,
            shaderProgram: null,
            gradientTexture: null,
            vertexBuffer: null,
            vao: null,
            isWebGLAvailable: false,
            webglReady: false,
            animationId: null,
            startTime: 0,
            lastFrameTime: 0,
            lastUpdateTime: 0,
            // Initialize LERP smoothing properties (current = target initially)
            currentFlowStrength: 0.3,
            targetFlowStrength: 0.3,
            currentNoiseScale: 1,
            targetNoiseScale: 1,
            currentBlurExp: 1.2,
            targetBlurExp: 1.2,
            currentBlurMax: 0.5,
            targetBlurMax: 0.5,
            currentWaveY: [0.3, 0.7],
            targetWaveY: [0.3, 0.7],
            currentWaveHeight: [0.4, 0.3],
            targetWaveHeight: [0.4, 0.3],
            currentWaveOffset: [0.1, 0.6],
            targetWaveOffset: [0.1, 0.6]
          };
          this.uniforms = {
            u_time: null,
            u_gradientTex: null,
            u_resolution: null,
            u_flowStrength: null,
            u_noiseScale: null,
            u_waveY: null,
            u_waveHeight: null,
            u_waveOffset: null,
            u_blurExp: null,
            u_blurMax: null
          };
          this.flowSettings = {
            enabled: true,
            intensity: "balanced",
            flowStrength: 0.7,
            noiseScale: 1.2,
            waveY: [0.25, 0.75],
            waveHeight: [0.4, 0.3],
            waveOffset: [2.5, -1.8],
            blurExp: 1.2,
            blurMax: 0.6,
            frameThrottleInterval: 1e3 / 45,
            // 45 FPS target
            oklabProcessingEnabled: true,
            oklabPreset: "VIBRANT",
            // Use vibrant preset for WebGL gradients
            gradientTextureSize: 512
            // High precision for OKLAB gradients
          };
          this.prefersReducedMotion = false;
          /**
           * WebGL animation loop
           */
          this.animateWebGL = /* @__PURE__ */ __name(() => {
            if (!this.webglState.webglReady || !this.webglState.gl || !this.webglState.canvas)
              return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.webglState.lastFrameTime;
            if (deltaTime < this.flowSettings.frameThrottleInterval) {
              this.webglState.animationId = requestAnimationFrame(this.animateWebGL);
              return;
            }
            this.webglState.lastFrameTime = currentTime;
            this.renderWebGLFrame(currentTime);
            this.webglState.animationId = requestAnimationFrame(this.animateWebGL);
          }, "animateWebGL");
          // LERP smoothing half-life values (in seconds) for WebGL uniform transitions
          this.lerpHalfLifeValues = {
            flowStrength: 0.25,
            // Fast flow response
            noiseScale: 0.3,
            // Moderate noise transitions
            blur: 0.2,
            // Quick blur transitions
            wave: 0.35
            // Gentle wave movements
          };
          /**
           * Resize WebGL canvas
           */
          this.resizeWebGLCanvas = /* @__PURE__ */ __name(() => {
            if (!this.webglState.canvas) return;
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            this.webglState.canvas.width = displayWidth * dpr;
            this.webglState.canvas.height = displayHeight * dpr;
            this.webglState.canvas.style.width = displayWidth + "px";
            this.webglState.canvas.style.height = displayHeight + "px";
          }, "resizeWebGLCanvas");
          this.deviceDetector = new DeviceCapabilityDetector();
          this.cssController = cssController || getGlobalOptimizedCSSController();
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.cssController = getGlobalOptimizedCSSController();
          this.prefersReducedMotion = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;
          this.webglState.isWebGLAvailable = this.checkWebGL2Support();
          this.loadFlowSettings();
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u{1F30A} WebGL gradient strategy initialized - Flow Gradient Recovery Debug",
            {
              webglAvailable: this.webglState.isWebGLAvailable,
              deviceCapability: this.deviceDetector.recommendPerformanceQuality(),
              oklabProcessing: this.flowSettings.oklabProcessingEnabled,
              flowSettings: {
                enabled: this.flowSettings.enabled,
                intensity: this.flowSettings.intensity,
                flowStrength: this.flowSettings.flowStrength,
                noiseScale: this.flowSettings.noiseScale
              },
              prefersReducedMotion: this.prefersReducedMotion,
              webgl2ContextTest: this.checkWebGL2Support()
            }
          );
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "webgl-gradient";
        }
        /**
         * Check if strategy can handle the given context
         * Updated to respect force WebGL settings and remove hard-coded device restrictions
         */
        canProcess(context) {
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u{1F50D} canProcess() - WebGL Gradient Capability Check",
            {
              isWebGLAvailable: this.webglState.isWebGLAvailable,
              flowSettingsEnabled: this.flowSettings.enabled,
              webglReady: this.webglState.webglReady,
              contextTrackUri: context.trackUri,
              contextColorCount: Object.keys(context.rawColors).length
            }
          );
          if (!this.webglState.isWebGLAvailable) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientStrategy",
              "\u274C canProcess: WebGL not available - failed WebGL2 context check"
            );
            return false;
          }
          if (!this.flowSettings.enabled) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientStrategy",
              "\u274C canProcess: WebGL strategy disabled in settings"
            );
            return false;
          }
          const webglEnabled = settings.get("sn-webgl-enabled");
          if (webglEnabled) {
            Y3KDebug?.debug?.log(
              "WebGLGradientStrategy",
              "canProcess: WebGL force enabled - bypassing device restrictions"
            );
            return true;
          }
          const performanceLevel = this.deviceDetector.recommendPerformanceQuality();
          if (performanceLevel === "low") {
            Y3KDebug?.debug?.log(
              "WebGLGradientStrategy",
              `canProcess: Low performance device detected, allowing based on strategy selection (not force mode)`
            );
            return true;
          }
          return true;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          const baseTime = 12;
          const shaderComplexity = this.flowSettings.intensity === "intense" ? 1.3 : 1;
          return Math.round(baseTime * shaderComplexity);
        }
        /**
         * Process colors using WebGL Gradient strategy with OKLAB enhancement
         */
        async processColors(context) {
          const startTime = performance.now();
          let oklabResults = {};
          try {
            if (!this.webglState.webglReady) {
              await this.initializeWebGLGradient();
            }
            let processedColors = context.rawColors;
            if (this.flowSettings.oklabProcessingEnabled) {
              const preset = OKLABColorProcessor.getPreset(
                this.flowSettings.oklabPreset
              );
              oklabResults = this.oklabProcessor.processColorPalette(
                context.rawColors,
                preset
              );
              processedColors = Object.fromEntries(
                Object.entries(oklabResults).map(([key, result2]) => [
                  key,
                  result2.enhancedHex
                ])
              );
              Y3KDebug?.debug?.log(
                "WebGLGradientStrategy",
                "OKLAB color enhancement applied:",
                {
                  originalColors: Object.keys(context.rawColors).length,
                  processedColors: Object.keys(processedColors).length,
                  preset: preset.name
                }
              );
            }
            const gradientStops = this.createGradientStops(
              processedColors,
              oklabResults
            );
            await this.updateGradientTexture(gradientStops);
            await this.enableHybridCoordination();
            if (!this.webglState.animationId) {
              this.startWebGLAnimation();
            }
            if (context.musicData?.energy !== void 0) {
              await this.updateFlowWithMusicEnergy(context.musicData.energy);
            }
            this.webglState.lastUpdateTime = Date.now();
            const processingTime = performance.now() - startTime;
            const primaryColor = this.selectPrimaryColor(processedColors) || paletteSystemManager.getDefaultAccentColor().hex;
            const result = {
              processedColors: {
                webgl: "active",
                gradientStops: gradientStops.length.toString(),
                ...processedColors,
                ...Object.keys(context.rawColors).length > 0 && {
                  originalColors: JSON.stringify(context.rawColors)
                }
              },
              accentHex: primaryColor,
              accentRgb: this.convertToRgbString(primaryColor),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `webgl-gradient-${context.trackUri}`,
                harmonicIntensity: this.flowSettings.flowStrength,
                webglReady: this.webglState.webglReady,
                oklabProcessing: this.flowSettings.oklabProcessingEnabled,
                oklabPreset: this.flowSettings.oklabPreset,
                gradientTextureSize: this.flowSettings.gradientTextureSize,
                oklabResultsCount: Object.keys(oklabResults).length
              },
              context
            };
            Y3KDebug?.debug?.log(
              "WebGLGradientStrategy",
              "WebGL gradient processing completed",
              {
                gradientStops: gradientStops.length,
                processingTime,
                trackUri: context.trackUri
              }
            );
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3KDebug?.debug?.error(
              "WebGLGradientStrategy",
              "WebGL gradient processing failed:",
              error
            );
            const fallbackResult = await this.executeProgressiveFallback(context, error);
            return {
              ...fallbackResult,
              metadata: {
                ...fallbackResult.metadata,
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error"
              },
              context
            };
          }
        }
        /**
         * Check WebGL2 support
         */
        checkWebGL2Support() {
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2");
          return gl !== null;
        }
        /**
         * Load flow settings from settings manager
         */
        loadFlowSettings() {
          try {
            const intensitySetting = settings.get(
              "sn-gradient-intensity"
            );
            if (intensitySetting === "disabled") {
              this.flowSettings.enabled = false;
              return;
            }
            this.flowSettings.intensity = intensitySetting || "balanced";
            switch (this.flowSettings.intensity) {
              case "minimal":
                this.flowSettings.flowStrength = 0.4;
                this.flowSettings.noiseScale = 0.8;
                this.flowSettings.waveHeight = [0.3, 0.2];
                this.flowSettings.waveOffset = [1.5, -1];
                this.flowSettings.blurExp = 1;
                this.flowSettings.blurMax = 0.4;
                break;
              case "balanced":
                this.flowSettings.flowStrength = 0.7;
                this.flowSettings.noiseScale = 1.2;
                this.flowSettings.waveHeight = [0.4, 0.3];
                this.flowSettings.waveOffset = [2.5, -1.8];
                this.flowSettings.blurExp = 1.2;
                this.flowSettings.blurMax = 0.6;
                break;
              case "intense":
                this.flowSettings.flowStrength = 1;
                this.flowSettings.noiseScale = 1.6;
                this.flowSettings.waveHeight = [0.5, 0.4];
                this.flowSettings.waveOffset = [3.5, -2.5];
                this.flowSettings.blurExp = 1.4;
                this.flowSettings.blurMax = 0.8;
                break;
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientStrategy",
              "Failed to load settings, using defaults:",
              error
            );
          }
        }
        /**
         * Initialize WebGL gradient system
         */
        async initializeWebGLGradient() {
          if (!this.webglState.isWebGLAvailable) {
            throw new Error("WebGL2 not available");
          }
          await this.createWebGLCanvas();
          await this.initializeWebGLContext();
          await this.compileWebGLShaders();
          this.createWebGLGeometry();
          this.setupWebGLUniforms();
          this.resizeWebGLCanvas();
          this.attachWebGLToDom();
          window.addEventListener("resize", this.resizeWebGLCanvas.bind(this));
          this.webglState.webglReady = true;
          try {
            const cssController = getGlobalOptimizedCSSController();
            cssController.setPerformanceTokens({
              webglReady: true,
              activeBackend: "webgl-strategy",
              qualityLevel: "high",
              gpuAcceleration: true
            });
            Y3KDebug?.debug?.log(
              "WebGLGradientStrategy",
              "\u{1F3A8} WebGL readiness announced to CSS consciousness system - CSS Variables Set",
              {
                webglReady: true,
                activeBackend: "webgl-strategy",
                qualityLevel: "high",
                gpuAcceleration: true,
                cssControllerReady: !!cssController
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientStrategy",
              "\u274C Failed to announce WebGL readiness - CSS Variables NOT Set:",
              error
            );
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "WebGL gradient system initialized successfully"
          );
        }
        /**
         * Create WebGL canvas and wrapper
         */
        async createWebGLCanvas() {
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u{1F3A8} Creating WebGL canvas and wrapper elements"
          );
          this.webglState.wrapper = document.createElement("div");
          this.webglState.wrapper.className = "sn-webgl-gradient-wrapper";
          this.webglState.wrapper.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -11;
      pointer-events: none;
      overflow: hidden;
    `;
          this.webglState.canvas = document.createElement("canvas");
          this.webglState.canvas.id = "sn-webgl-gradient-strategy";
          this.webglState.canvas.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    `;
          this.webglState.wrapper.appendChild(this.webglState.canvas);
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u2705 WebGL canvas and wrapper created successfully",
            {
              wrapperId: this.webglState.wrapper.className,
              canvasId: this.webglState.canvas.id,
              wrapperStyle: this.webglState.wrapper.style.cssText.replace(/\s+/g, " ").trim()
            }
          );
        }
        /**
         * Initialize WebGL context
         */
        async initializeWebGLContext() {
          if (!this.webglState.canvas) {
            throw new Error("Canvas not created");
          }
          this.webglState.gl = this.webglState.canvas.getContext("webgl2", {
            alpha: true,
            antialias: false,
            depth: false,
            stencil: false,
            powerPreference: "default"
          });
          if (!this.webglState.gl) {
            throw new Error("Failed to get WebGL2 context");
          }
        }
        /**
         * Compile WebGL shaders
         */
        async compileWebGLShaders() {
          if (!this.webglState.gl) {
            throw new Error("WebGL context not available");
          }
          const vertexShader = ShaderLoader.loadVertex(
            this.webglState.gl,
            DEFAULT_VERTEX_SHADER
          );
          const fragmentShader = ShaderLoader.loadFragment(
            this.webglState.gl,
            FLOW_GRADIENT_SHADER
          );
          if (!vertexShader || !fragmentShader) {
            throw new Error("Failed to compile shaders");
          }
          this.webglState.shaderProgram = ShaderLoader.createProgram(
            this.webglState.gl,
            vertexShader,
            fragmentShader
          );
          if (!this.webglState.shaderProgram) {
            throw new Error("Failed to create shader program");
          }
        }
        /**
         * Create WebGL geometry
         */
        createWebGLGeometry() {
          if (!this.webglState.gl || !this.webglState.shaderProgram) return;
          const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
          this.webglState.vertexBuffer = this.webglState.gl.createBuffer();
          this.webglState.gl.bindBuffer(
            this.webglState.gl.ARRAY_BUFFER,
            this.webglState.vertexBuffer
          );
          this.webglState.gl.bufferData(
            this.webglState.gl.ARRAY_BUFFER,
            vertices,
            this.webglState.gl.STATIC_DRAW
          );
          this.webglState.vao = this.webglState.gl.createVertexArray();
          this.webglState.gl.bindVertexArray(this.webglState.vao);
          const positionLocation = this.webglState.gl.getAttribLocation(
            this.webglState.shaderProgram,
            "a_position"
          );
          this.webglState.gl.enableVertexAttribArray(positionLocation);
          this.webglState.gl.vertexAttribPointer(
            positionLocation,
            2,
            this.webglState.gl.FLOAT,
            false,
            0,
            0
          );
          this.webglState.gl.bindVertexArray(null);
        }
        /**
         * Setup WebGL uniforms
         */
        setupWebGLUniforms() {
          if (!this.webglState.gl || !this.webglState.shaderProgram) return;
          this.uniforms.u_time = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_time"
          );
          this.uniforms.u_gradientTex = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_gradientTex"
          );
          this.uniforms.u_resolution = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_resolution"
          );
          this.uniforms.u_flowStrength = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_flowStrength"
          );
          this.uniforms.u_noiseScale = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_noiseScale"
          );
          this.uniforms.u_waveY = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_waveY"
          );
          this.uniforms.u_waveHeight = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_waveHeight"
          );
          this.uniforms.u_waveOffset = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_waveOffset"
          );
          this.uniforms.u_blurExp = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_blurExp"
          );
          this.uniforms.u_blurMax = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_blurMax"
          );
        }
        /**
         * Create gradient stops from extracted colors with OKLAB enhancement
         */
        createGradientStops(colors, oklabResults = {}) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "VIBRANT_NON_ALARMING",
            "LIGHT_VIBRANT",
            "DARK_VIBRANT",
            "PROMINENT"
          ];
          const stops = [];
          const usedColors = /* @__PURE__ */ new Set();
          let position = 0;
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && !usedColors.has(color3)) {
              const oklabResult = oklabResults[key];
              const finalColor = oklabResult ? oklabResult.enhancedHex : color3;
              const rgb = this.utils.hexToRgb(finalColor);
              if (rgb) {
                stops.push({
                  r: rgb.r / 255,
                  g: rgb.g / 255,
                  b: rgb.b / 255,
                  a: 1,
                  position: position / (Math.min(priorities.length, 4) - 1),
                  // Include OKLAB metadata for debugging
                  ...oklabResult && {
                    oklabOriginal: oklabResult.originalHex,
                    oklabEnhanced: oklabResult.enhancedHex
                  }
                });
                usedColors.add(color3);
                position++;
                if (stops.length >= 4) break;
              }
            }
          }
          if (stops.length === 0) {
            return this.getDefaultGradientStops();
          }
          return stops;
        }
        /**
         * Get default gradient stops
         */
        getDefaultGradientStops() {
          return [
            { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 0 },
            // Base
            { r: 0.549, g: 0.408, b: 0.878, a: 1, position: 0.3 },
            // Mauve
            { r: 0.788, g: 0.557, b: 0.902, a: 1, position: 0.6 },
            // Pink
            { r: 0.957, g: 0.761, b: 0.494, a: 1, position: 1 }
            // Peach
          ];
        }
        /**
         * Update gradient texture with new color stops
         */
        async updateGradientTexture(colorStops) {
          if (!this.webglState.gl) return;
          if (this.webglState.gradientTexture) {
            this.webglState.gl.deleteTexture(this.webglState.gradientTexture);
          }
          this.webglState.gradientTexture = createGradientTexture(
            this.webglState.gl,
            colorStops
          );
          if (!this.webglState.gradientTexture) {
            throw new Error("Failed to create gradient texture");
          }
          await this.updateCSSFallbackVariables(colorStops);
        }
        /**
         * Update CSS fallback variables for hybrid coordination using coordinated updates
         */
        async updateCSSFallbackVariables(colorStops) {
          const maxStops = Math.min(8, colorStops.length);
          const gradientStopVariables = {
            "--sn-grad-stop-count": String(maxStops)
          };
          for (let i = 0; i < maxStops; i++) {
            const c = colorStops[i];
            if (c) {
              gradientStopVariables[`--sn-grad-stop-${i}-rgb`] = `${Math.round(
                c.r * 255
              )},${Math.round(c.g * 255)},${Math.round(c.b * 255)}`;
            }
          }
          await this.cssController.batchSetVariables(
            "WebGLGradientStrategy",
            gradientStopVariables,
            "normal",
            // Normal priority for gradient configuration
            "gradient-stops-configuration"
          );
        }
        /**
         * Enable hybrid coordination between WebGL and CSS using coordinated updates
         */
        async enableHybridCoordination() {
          const hybridCoordinationVariables = {
            "--sn-webgl-ready": "1",
            "--sn-webgl-enabled": "1",
            "--sn-current-backend": "hybrid",
            "--sn-gradient-crossfade-opacity": "0.5"
            // 50% blend
          };
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u{1F517} Setting hybrid coordination CSS variables - WebGL Gradient Activation",
            {
              variables: hybridCoordinationVariables,
              cssControllerReady: !!this.cssController
            }
          );
          await this.cssController.batchSetVariables(
            "WebGLGradientStrategy",
            hybridCoordinationVariables,
            "high",
            // High priority for WebGL coordination
            "hybrid-coordination-enable"
          );
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u2705 Hybrid coordination CSS variables set successfully"
          );
        }
        /**
         * Start WebGL animation loop
         */
        startWebGLAnimation() {
          this.webglState.startTime = performance.now();
          this.webglState.lastFrameTime = this.webglState.startTime;
          this.animateWebGL();
        }
        /**
         * Update WebGL uniform values with LERP smoothing for framerate-independent transitions
         */
        updateUniformsWithLERP(deltaTimeSeconds) {
          this.webglState.targetFlowStrength = this.flowSettings.flowStrength;
          this.webglState.targetNoiseScale = this.flowSettings.noiseScale;
          this.webglState.targetBlurExp = this.flowSettings.blurExp;
          this.webglState.targetBlurMax = this.flowSettings.blurMax;
          this.webglState.targetWaveY = [
            this.flowSettings.waveY[0],
            this.flowSettings.waveY[1]
          ];
          this.webglState.targetWaveHeight = [
            this.flowSettings.waveHeight[0],
            this.flowSettings.waveHeight[1]
          ];
          this.webglState.targetWaveOffset = [
            this.flowSettings.waveOffset[0],
            this.flowSettings.waveOffset[1]
          ];
          this.webglState.currentFlowStrength = lerpSmooth(
            this.webglState.currentFlowStrength,
            this.webglState.targetFlowStrength,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.flowStrength
          );
          this.webglState.currentNoiseScale = lerpSmooth(
            this.webglState.currentNoiseScale,
            this.webglState.targetNoiseScale,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.noiseScale
          );
          this.webglState.currentBlurExp = lerpSmooth(
            this.webglState.currentBlurExp,
            this.webglState.targetBlurExp,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.blur
          );
          this.webglState.currentBlurMax = lerpSmooth(
            this.webglState.currentBlurMax,
            this.webglState.targetBlurMax,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.blur
          );
          const waveIndex0 = 0;
          const waveIndex1 = 1;
          this.webglState.currentWaveY[waveIndex0] = lerpSmooth(
            this.webglState.currentWaveY[waveIndex0],
            this.webglState.targetWaveY[waveIndex0],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveY[waveIndex1] = lerpSmooth(
            this.webglState.currentWaveY[waveIndex1],
            this.webglState.targetWaveY[waveIndex1],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveHeight[waveIndex0] = lerpSmooth(
            this.webglState.currentWaveHeight[waveIndex0],
            this.webglState.targetWaveHeight[waveIndex0],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveHeight[waveIndex1] = lerpSmooth(
            this.webglState.currentWaveHeight[waveIndex1],
            this.webglState.targetWaveHeight[waveIndex1],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveOffset[waveIndex0] = lerpSmooth(
            this.webglState.currentWaveOffset[waveIndex0],
            this.webglState.targetWaveOffset[waveIndex0],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveOffset[waveIndex1] = lerpSmooth(
            this.webglState.currentWaveOffset[waveIndex1],
            this.webglState.targetWaveOffset[waveIndex1],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
        }
        /**
         * Render WebGL frame
         */
        renderWebGLFrame(currentTime) {
          if (!this.webglState.gl || !this.webglState.shaderProgram || !this.webglState.vao || !this.webglState.gradientTexture) {
            return;
          }
          const deltaTimeSeconds = (currentTime - this.webglState.lastFrameTime) / 1e3;
          this.updateUniformsWithLERP(deltaTimeSeconds);
          this.webglState.gl.viewport(
            0,
            0,
            this.webglState.canvas.width,
            this.webglState.canvas.height
          );
          this.webglState.gl.clearColor(0, 0, 0, 0);
          this.webglState.gl.clear(this.webglState.gl.COLOR_BUFFER_BIT);
          this.webglState.gl.useProgram(this.webglState.shaderProgram);
          this.webglState.gl.bindVertexArray(this.webglState.vao);
          const time = this.prefersReducedMotion ? 0 : (currentTime - this.webglState.startTime) / 1e3;
          if (this.uniforms.u_time) {
            this.webglState.gl.uniform1f(this.uniforms.u_time, time);
          }
          if (this.uniforms.u_resolution) {
            this.webglState.gl.uniform2f(
              this.uniforms.u_resolution,
              this.webglState.canvas.width,
              this.webglState.canvas.height
            );
          }
          if (this.uniforms.u_flowStrength) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_flowStrength,
              this.webglState.currentFlowStrength
              // Use smoothed value
            );
          }
          if (this.uniforms.u_noiseScale) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_noiseScale,
              this.webglState.currentNoiseScale
              // Use smoothed value
            );
          }
          if (this.uniforms.u_waveY) {
            this.webglState.gl.uniform1fv(
              this.uniforms.u_waveY,
              this.webglState.currentWaveY
              // Use smoothed values
            );
          }
          if (this.uniforms.u_waveHeight) {
            this.webglState.gl.uniform1fv(
              this.uniforms.u_waveHeight,
              this.webglState.currentWaveHeight
              // Use smoothed values
            );
          }
          if (this.uniforms.u_waveOffset) {
            this.webglState.gl.uniform1fv(
              this.uniforms.u_waveOffset,
              this.webglState.currentWaveOffset
              // Use smoothed values
            );
          }
          if (this.uniforms.u_blurExp) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_blurExp,
              this.webglState.currentBlurExp
              // Use smoothed value
            );
          }
          if (this.uniforms.u_blurMax) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_blurMax,
              this.webglState.currentBlurMax
              // Use smoothed value
            );
          }
          this.webglState.gl.activeTexture(this.webglState.gl.TEXTURE0);
          this.webglState.gl.bindTexture(
            this.webglState.gl.TEXTURE_2D,
            this.webglState.gradientTexture
          );
          if (this.uniforms.u_gradientTex) {
            this.webglState.gl.uniform1i(this.uniforms.u_gradientTex, 0);
          }
          this.webglState.gl.drawArrays(this.webglState.gl.TRIANGLES, 0, 3);
          this.webglState.gl.bindVertexArray(null);
        }
        /**
         * Update flow with music energy using coordinated updates
         */
        async updateFlowWithMusicEnergy(energy) {
          const baseStrength = this.flowSettings.flowStrength;
          const energyMultiplier = 1 + energy * 0.5;
          const adjustedStrength = baseStrength * energyMultiplier;
          await this.cssController.setVariable(
            "WebGLGradientStrategy",
            "--sn-flow-strength",
            adjustedStrength.toString(),
            "high",
            // High priority for real-time music responsiveness
            "music-energy-flow-strength"
          );
        }
        /**
         * Attach WebGL canvas to DOM
         */
        attachWebGLToDom() {
          if (!this.webglState.wrapper) {
            Y3KDebug?.debug?.error(
              "WebGLGradientStrategy",
              "\u274C Cannot attach to DOM - wrapper element not created"
            );
            return;
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u{1F517} Attaching WebGL canvas to DOM - Searching for container"
          );
          const containers = [
            ".Root__main-view",
            ".main-view-container",
            ".main-gridContainer-gridContainer",
            ".Root__top-container",
            "body"
          ];
          let targetContainer = null;
          const containerResults = [];
          for (const selector of containers) {
            targetContainer = document.querySelector(selector);
            containerResults.push({ selector, found: !!targetContainer });
            if (targetContainer) break;
          }
          if (!targetContainer) {
            targetContainer = document.body;
          }
          targetContainer.appendChild(this.webglState.wrapper);
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u2705 WebGL canvas attached to DOM successfully",
            {
              containerSearch: containerResults,
              selectedContainer: targetContainer?.tagName || "unknown",
              containerClass: targetContainer?.className || "none",
              wrapperId: this.webglState.wrapper.className,
              canvasId: this.webglState.canvas?.id || "not-created"
            }
          );
        }
        /**
         * Execute progressive fallback chain: WebGL  CSS Gradients  Solid Color
         */
        async executeProgressiveFallback(context, originalError) {
          const primaryColor = this.selectPrimaryColor(context.rawColors) || paletteSystemManager.getDefaultAccentColor().hex;
          try {
            Y3KDebug?.debug?.warn(
              "WebGLGradientStrategy",
              "Attempting CSS gradient fallback"
            );
            await this.fallbackToCSSGradient();
            return {
              processedColors: {
                ...context.rawColors,
                fallbackMethod: "css-gradient"
              },
              accentHex: primaryColor,
              accentRgb: this.convertToRgbString(primaryColor),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime: 0,
                // Will be updated in processColors
                fallbackMode: "css-gradient",
                fallbackReason: "webgl-failed",
                gradientStops: Object.keys(context.rawColors).length
              },
              context
            };
          } catch (cssError) {
            Y3KDebug?.debug?.error(
              "WebGLGradientStrategy",
              "CSS gradient fallback failed, using solid color:",
              cssError
            );
            return await this.fallbackToSolidColor(context, primaryColor, originalError, cssError);
          }
        }
        /**
         * Final fallback to solid color when all gradient methods fail
         */
        async fallbackToSolidColor(context, primaryColor, webglError, cssError) {
          try {
            await this.cssController?.queueUpdate(
              "--sn-accent-color",
              primaryColor,
              "critical",
              "solid-color-fallback"
            );
            return {
              processedColors: {
                accentColor: primaryColor,
                fallbackMethod: "solid-color",
                originalColors: JSON.stringify(context.rawColors)
              },
              accentHex: primaryColor,
              accentRgb: this.convertToRgbString(primaryColor),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime: 0,
                // Will be updated in processColors
                fallbackMode: "solid-color",
                fallbackReason: "all-gradients-failed",
                webglError: webglError instanceof Error ? webglError.message : "Unknown WebGL error",
                cssError: cssError instanceof Error ? cssError.message : "Unknown CSS error",
                emergencyMode: true
              },
              context
            };
          } catch (solidColorError) {
            Y3KDebug?.debug?.error(
              "WebGLGradientStrategy",
              "All fallback methods failed, using emergency mode:",
              solidColorError
            );
            return {
              processedColors: { emergencyMode: "true" },
              accentHex: "#ff6b9d",
              // Catppuccin pink fallback
              accentRgb: "rgb(255, 107, 157)",
              metadata: {
                strategy: this.getStrategyName(),
                processingTime: 0,
                // Will be updated in processColors
                fallbackMode: "emergency",
                fallbackReason: "complete-system-failure",
                criticalError: true
              },
              context
            };
          }
        }
        /**
         * Fallback to CSS gradient rendering when WebGL fails
         */
        async fallbackToCSSGradient() {
          const cssGradientFallbackVariables = {
            "--sn-webgl-ready": "0",
            "--sn-webgl-enabled": "0",
            "--sn-current-backend": "css",
            "--sn-gradient-crossfade-opacity": "0"
          };
          await this.cssController.batchSetVariables(
            "WebGLGradientStrategy",
            cssGradientFallbackVariables,
            "critical",
            // Critical priority for fallback scenarios
            "css-gradient-fallback"
          );
          if (this.cssController) {
            this.startCSSFallbackAnimation();
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "Using CSS gradient fallback"
          );
        }
        /**
         * Start CSS fallback animation
         */
        startCSSFallbackAnimation() {
          if (!this.cssController) return;
          const animateCSS = /* @__PURE__ */ __name(() => {
            if (!this.webglState.webglReady) return;
            const time = performance.now() / 1e3;
            const flowX = Math.sin(time * 0.04) * 20 + Math.sin(time * 0.07) * 8;
            const flowY = Math.cos(time * 0.05) * 20 + Math.cos(time * 0.09) * 6;
            const scale = 1.15 + Math.sin(time * 0.03) * 0.2;
            this.cssController.queueCSSVariableUpdate(
              "--sn-gradient-flow-x",
              `${flowX}%`
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-gradient-flow-y",
              `${flowY}%`
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-gradient-flow-scale",
              scale.toString()
            );
            setTimeout(animateCSS, this.flowSettings.frameThrottleInterval);
          }, "animateCSS");
          animateCSS();
        }
        /**
         * Select primary color from extracted colors
         */
        selectPrimaryColor(colors) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "PROMINENT",
            "VIBRANT_NON_ALARMING",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Convert hex color to RGB string
         */
        convertToRgbString(hex) {
          const rgb = this.utils.hexToRgb(hex);
          return rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "203,166,247";
        }
        /**
         * Update configuration
         */
        updateConfig(newConfig) {
          this.flowSettings = { ...this.flowSettings, ...newConfig };
          if ("oklabProcessingEnabled" in newConfig || "oklabPreset" in newConfig) {
            this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          }
          Y3KDebug?.debug?.log("WebGLGradientStrategy", "Configuration updated:", {
            ...newConfig,
            oklabProcessing: this.flowSettings.oklabProcessingEnabled,
            oklabPreset: this.flowSettings.oklabPreset,
            gradientTextureSize: this.flowSettings.gradientTextureSize
          });
        }
        /**
         * Health check for strategy status
         */
        async healthCheck() {
          const hasRecentUpdate = Date.now() - this.webglState.lastUpdateTime < 3e4;
          return {
            healthy: this.webglState.webglReady && this.flowSettings.enabled,
            canProcess: this.canProcess({}),
            issues: !this.webglState.webglReady ? ["WebGL system not ready"] : !this.flowSettings.enabled ? ["WebGL gradient disabled in settings"] : [],
            metrics: {
              webglAvailable: this.webglState.isWebGLAvailable,
              webglReady: this.webglState.webglReady,
              flowEnabled: this.flowSettings.enabled,
              intensity: this.flowSettings.intensity,
              deviceCapability: this.deviceDetector.recommendPerformanceQuality(),
              hasRecentUpdate,
              animationActive: this.webglState.animationId !== null,
              oklabProcessing: this.flowSettings.oklabProcessingEnabled,
              oklabPreset: this.flowSettings.oklabPreset,
              gradientTextureSize: this.flowSettings.gradientTextureSize,
              canvasSize: this.webglState.canvas ? {
                width: this.webglState.canvas.width,
                height: this.webglState.canvas.height
              } : null
            }
          };
        }
        /**
         * Cleanup WebGL resources
         */
        destroy() {
          if (this.webglState.animationId) {
            cancelAnimationFrame(this.webglState.animationId);
            this.webglState.animationId = null;
          }
          if (this.webglState.gl) {
            if (this.webglState.gradientTexture) {
              this.webglState.gl.deleteTexture(this.webglState.gradientTexture);
              this.webglState.gradientTexture = null;
            }
            if (this.webglState.vertexBuffer) {
              this.webglState.gl.deleteBuffer(this.webglState.vertexBuffer);
              this.webglState.vertexBuffer = null;
            }
            if (this.webglState.vao) {
              this.webglState.gl.deleteVertexArray(this.webglState.vao);
              this.webglState.vao = null;
            }
            if (this.webglState.shaderProgram) {
              this.webglState.gl.deleteProgram(this.webglState.shaderProgram);
              this.webglState.shaderProgram = null;
            }
            ShaderLoader.clearCache(this.webglState.gl);
          }
          if (this.webglState.wrapper && this.webglState.wrapper.parentNode) {
            this.webglState.wrapper.parentNode.removeChild(this.webglState.wrapper);
            this.webglState.wrapper = null;
          }
          this.webglState.canvas = null;
          this.webglState.gl = null;
          this.webglState.webglReady = false;
          window.removeEventListener("resize", this.resizeWebGLCanvas);
          const resetVariables = {
            "--sn-webgl-ready": "0",
            "--sn-webgl-enabled": "0",
            "--sn-current-backend": "css",
            "--sn-gradient-crossfade-opacity": "0"
          };
          this.cssController.batchSetVariables(
            "WebGLGradientStrategy",
            resetVariables,
            "critical",
            // Critical priority for cleanup
            "strategy-destroy-cleanup"
          ).catch((error) => {
            Y3KDebug?.debug?.error(
              "WebGLGradientStrategy",
              "Error during destroy cleanup:",
              error
            );
          });
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "WebGL gradient strategy destroyed"
          );
        }
      };
      __name(_WebGLGradientStrategy, "WebGLGradientStrategy");
      WebGLGradientStrategy = _WebGLGradientStrategy;
    }
  });

  // src-js/visual/strategies/BackgroundStrategySelector.ts
  var _BackgroundStrategySelector, BackgroundStrategySelector;
  var init_BackgroundStrategySelector = __esm({
    "src-js/visual/strategies/BackgroundStrategySelector.ts"() {
      "use strict";
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_config();
      init_DepthLayeredStrategy();
      init_DynamicCatppuccinStrategy();
      init_LivingGradientStrategy();
      init_WebGLGradientStrategy();
      _BackgroundStrategySelector = class _BackgroundStrategySelector {
        constructor() {
          // Strategy instances (lazy-loaded)
          this.strategyInstances = /* @__PURE__ */ new Map();
          // Strategy metadata for selection decisions
          this.strategyMetadata = /* @__PURE__ */ new Map();
          this.deviceDetector = new DeviceCapabilityDetector();
          this.initializeStrategyMetadata();
          Y3KDebug?.debug?.log(
            "BackgroundStrategySelector",
            "Strategy selector initialized"
          );
        }
        /**
         * Initialize metadata for all available strategies
         */
        initializeStrategyMetadata() {
          this.strategyMetadata.set("dynamic-catppuccin", {
            name: "dynamic-catppuccin",
            priority: 10,
            // Highest priority - core accent system
            estimatedProcessingTime: 5,
            memoryImpact: 2,
            qualityScore: 9,
            compatibilityScore: 10
            // Always compatible
          });
          this.strategyMetadata.set("living-gradient", {
            name: "living-gradient",
            priority: 8,
            // High priority - foundation layer
            estimatedProcessingTime: 8,
            memoryImpact: 3,
            qualityScore: 8,
            compatibilityScore: 9
            // Compatible with most devices
          });
          this.strategyMetadata.set("webgl-gradient", {
            name: "webgl-gradient",
            priority: 6,
            // Medium-high priority - performance dependent
            estimatedProcessingTime: 12,
            memoryImpact: 7,
            qualityScore: 10,
            compatibilityScore: 6
            // Requires WebGL support
          });
          this.strategyMetadata.set("webgl-gradient-degraded", {
            name: "webgl-gradient-degraded",
            priority: 5,
            // Medium priority - for low-end devices
            estimatedProcessingTime: 8,
            memoryImpact: 4,
            qualityScore: 6,
            compatibilityScore: 8
            // Better compatibility for low-end devices
          });
          this.strategyMetadata.set("depth-layered", {
            name: "depth-layered",
            priority: 7,
            // Medium-high priority - consciousness enhancement
            estimatedProcessingTime: 15,
            memoryImpact: 5,
            qualityScore: 9,
            compatibilityScore: 7
            // Requires moderate device capabilities
          });
        }
        /**
         * Select optimal strategies based on comprehensive criteria analysis
         */
        selectStrategies(context, criteria) {
          const startTime = performance.now();
          const selectedStrategies = [];
          try {
            const deviceContext = criteria.deviceContext || this.buildDeviceContext();
            const settingsContext = criteria.settingsContext || this.buildSettingsContext();
            Y3KDebug?.debug?.log(
              "BackgroundStrategySelector",
              "\u{1F3AF} Strategy Selection Debug - WebGL Gradient Analysis",
              {
                trackUri: context.trackUri,
                colorCount: Object.keys(context.rawColors).length,
                deviceContext: {
                  supportsWebGL: deviceContext.supportsWebGL,
                  performanceLevel: deviceContext.performanceLevel,
                  memoryCapacity: deviceContext.memoryCapacity,
                  isMobile: deviceContext.isMobile
                },
                settingsContext: {
                  webglEnabled: settingsContext.webglEnabled,
                  webglForceEnabled: settingsContext.webglForceEnabled,
                  gradientIntensity: settingsContext.gradientIntensity,
                  consciousnessLevel: settingsContext.consciousnessLevel
                }
              }
            );
            const strategyDecisions = this.analyzeStrategyCompatibility(context, {
              ...criteria,
              deviceContext,
              settingsContext
            });
            for (const decision of strategyDecisions) {
              Y3KDebug?.debug?.log(
                "BackgroundStrategySelector",
                `Strategy decision: ${decision.strategyName}`,
                {
                  shouldInclude: decision.shouldInclude,
                  reason: decision.reason,
                  score: decision.score
                }
              );
              if (decision.shouldInclude) {
                const strategy = this.getOrCreateStrategy(decision.strategyName);
                if (strategy) {
                  const canProcess = strategy.canProcess(context);
                  Y3KDebug?.debug?.log(
                    "BackgroundStrategySelector",
                    `Strategy ${decision.strategyName} canProcess check`,
                    {
                      canProcess,
                      strategyName: decision.strategyName,
                      contextColors: Object.keys(context.rawColors).length
                    }
                  );
                  if (canProcess) {
                    selectedStrategies.push(strategy);
                    Y3KDebug?.debug?.log(
                      "BackgroundStrategySelector",
                      `\u2705 Selected strategy: ${decision.strategyName}`
                    );
                  } else {
                    Y3KDebug?.debug?.warn(
                      "BackgroundStrategySelector",
                      `\u274C Strategy rejected by canProcess(): ${decision.strategyName}`
                    );
                  }
                } else {
                  Y3KDebug?.debug?.error(
                    "BackgroundStrategySelector",
                    `Failed to create strategy: ${decision.strategyName}`
                  );
                }
              }
            }
            if (selectedStrategies.length === 0) {
              const fallbackStrategy = this.getOrCreateStrategy("living-gradient");
              if (fallbackStrategy?.canProcess(context)) {
                selectedStrategies.push(fallbackStrategy);
              }
            }
            const processingTime = performance.now() - startTime;
            Y3KDebug?.debug?.log(
              "BackgroundStrategySelector",
              "\u{1F3AF} Strategy selection completed",
              {
                selectedCount: selectedStrategies.length,
                strategies: selectedStrategies.map((s) => s.getStrategyName()),
                processingTime,
                deviceLevel: deviceContext.performanceLevel,
                visualGuideMode: settingsContext.visualGuideMode,
                webglEnabled: settingsContext.webglEnabled,
                webglForceEnabled: settingsContext.webglForceEnabled,
                supportsWebGL: deviceContext.supportsWebGL,
                totalDecisions: strategyDecisions.length,
                includedDecisions: strategyDecisions.filter((d) => d.shouldInclude).length
              }
            );
            return selectedStrategies;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "BackgroundStrategySelector",
              "Strategy selection failed:",
              error
            );
            const fallbackStrategy = this.getOrCreateStrategy("living-gradient");
            return fallbackStrategy ? [fallbackStrategy] : [];
          }
        }
        /**
         * Analyze strategy compatibility and selection logic
         */
        analyzeStrategyCompatibility(context, criteria) {
          const decisions = [];
          const dynamicScore = this.scoreDynamicCatppuccinStrategy(criteria);
          decisions.push({
            strategyName: "dynamic-catppuccin",
            shouldInclude: criteria.settingsContext.dynamicAccentEnabled && dynamicScore > 0.5,
            reason: criteria.settingsContext.dynamicAccentEnabled ? `Dynamic accent enabled (score: ${dynamicScore.toFixed(2)})` : "Dynamic accent disabled in settings",
            score: dynamicScore
          });
          const livingScore = this.scoreLivingGradientStrategy(criteria);
          decisions.push({
            strategyName: "living-gradient",
            shouldInclude: livingScore > 0.3,
            // Almost always include as foundation
            reason: `Living gradient foundation (score: ${livingScore.toFixed(2)})`,
            score: livingScore
          });
          const webglScore = this.scoreWebGLGradientStrategy(criteria);
          const webglDegradedScore = this.scoreWebGLDegradedStrategy(criteria);
          const canUseFullWebGL = criteria.settingsContext.webglEnabled && criteria.deviceContext.supportsWebGL && (criteria.deviceContext.performanceLevel !== "low" || criteria.settingsContext.webglForceEnabled) && webglScore > 0.6;
          decisions.push({
            strategyName: "webgl-gradient",
            shouldInclude: canUseFullWebGL,
            reason: `WebGL full quality (score: ${webglScore.toFixed(2)}, device: ${criteria.deviceContext.performanceLevel}${criteria.settingsContext.webglForceEnabled ? ", FORCED" : ""})`,
            score: webglScore
          });
          decisions.push({
            strategyName: "webgl-gradient-degraded",
            shouldInclude: criteria.settingsContext.webglEnabled && criteria.deviceContext.supportsWebGL && criteria.deviceContext.performanceLevel === "low" && !criteria.settingsContext.webglForceEnabled && // Don't use degraded if forcing full WebGL
            webglDegradedScore > 0.4,
            reason: `WebGL degraded mode (score: ${webglDegradedScore.toFixed(2)}, device: low${criteria.settingsContext.webglForceEnabled ? ", skipped due to force" : ""})`,
            score: webglDegradedScore
          });
          const depthScore = this.scoreDepthLayeredStrategy(criteria);
          decisions.push({
            strategyName: "depth-layered",
            shouldInclude: criteria.settingsContext.depthLayersEnabled && criteria.settingsContext.consciousnessLevel > 0.4 && criteria.deviceContext.performanceLevel !== "low" && depthScore > 0.5,
            reason: `Depth consciousness (score: ${depthScore.toFixed(
              2
            )}, consciousness: ${criteria.settingsContext.consciousnessLevel})`,
            score: depthScore
          });
          return decisions;
        }
        /**
         * Score Dynamic Catppuccin Strategy compatibility
         */
        scoreDynamicCatppuccinStrategy(criteria) {
          let score = 0.8;
          if (criteria.settingsContext.dynamicAccentEnabled) score += 0.2;
          if (criteria.musicContext?.energy && criteria.musicContext.energy > 0.7) {
            score += 0.1;
          }
          const visualModes = ["cosmic", "cinematic", "ethereal", "natural"];
          if (visualModes.includes(criteria.settingsContext.visualGuideMode)) {
            score += 0.1;
          }
          score += 0.1;
          return Math.min(1, score);
        }
        /**
         * Score Living Gradient Strategy compatibility
         */
        scoreLivingGradientStrategy(criteria) {
          let score = 0.9;
          if (criteria.settingsContext.breathingAnimationEnabled) score += 0.1;
          score += criteria.settingsContext.consciousnessLevel * 0.2;
          if (criteria.musicContext?.valence !== void 0) {
            score += 0.05;
          }
          if (criteria.deviceContext.performanceLevel === "high") score += 0.05;
          return Math.min(1, score);
        }
        /**
         * Score WebGL Gradient Strategy compatibility (full quality)
         */
        scoreWebGLGradientStrategy(criteria) {
          let score = 0;
          if (!criteria.deviceContext.supportsWebGL) return 0;
          if (!criteria.settingsContext.webglEnabled) return 0;
          score = 0.6;
          if (criteria.settingsContext.webglForceEnabled) {
            score += 0.4;
            Y3KDebug?.debug?.log(
              "BackgroundStrategySelector",
              "WebGL force enabled - boosting score by 0.4"
            );
          }
          switch (criteria.deviceContext.performanceLevel) {
            case "high":
              score += 0.3;
              break;
            case "medium":
              score += 0.2;
              break;
            case "low":
              if (!criteria.settingsContext.webglForceEnabled) {
                return 0;
              }
              score += 0.1;
              break;
          }
          if (criteria.deviceContext.memoryCapacity > 4e3) score += 0.1;
          if (criteria.deviceContext.memoryCapacity > 8e3) score += 0.1;
          if (criteria.settingsContext.consciousnessLevel > 0.7) score += 0.1;
          if (criteria.musicContext?.energy && criteria.musicContext.energy > 0.8) {
            score += 0.1;
          }
          if (criteria.deviceContext.isMobile) score -= 0.2;
          return Math.min(1, Math.max(0, score));
        }
        /**
         * Score Degraded WebGL Strategy compatibility (for low-end devices)
         */
        scoreWebGLDegradedStrategy(criteria) {
          let score = 0;
          if (!criteria.deviceContext.supportsWebGL) return 0;
          if (!criteria.settingsContext.webglEnabled) return 0;
          if (criteria.deviceContext.performanceLevel !== "low") return 0;
          score = 0.5;
          score += 0.3;
          if (criteria.settingsContext.consciousnessLevel > 0.5) score += 0.1;
          if (criteria.musicContext?.energy && criteria.musicContext.energy > 0.6) {
            score += 0.05;
          }
          if (criteria.deviceContext.isMobile) score -= 0.1;
          if (criteria.deviceContext.memoryCapacity > 2e3) score += 0.05;
          return Math.min(1, Math.max(0, score));
        }
        /**
         * Score Depth Layered Strategy compatibility
         */
        scoreDepthLayeredStrategy(criteria) {
          let score = 0;
          if (!criteria.settingsContext.depthLayersEnabled) return 0;
          score = 0.5;
          score += criteria.settingsContext.consciousnessLevel * 0.4;
          switch (criteria.deviceContext.performanceLevel) {
            case "high":
              score += 0.2;
              break;
            case "medium":
              score += 0.1;
              break;
            case "low":
              score = 0;
              return 0;
          }
          if (["cosmic", "cinematic"].includes(criteria.settingsContext.visualGuideMode)) {
            score += 0.2;
          }
          if (criteria.musicContext?.tempo && criteria.musicContext.tempo < 100) {
            score += 0.1;
          }
          if (criteria.deviceContext.memoryCapacity > 6e3) score += 0.1;
          if (criteria.deviceContext.isMobile) score -= 0.15;
          return Math.min(1, Math.max(0, score));
        }
        /**
         * Build device context from current device capabilities
         */
        buildDeviceContext() {
          const memoryMB = window.navigator.deviceMemory ? window.navigator.deviceMemory * 1024 : 4096;
          const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
          return {
            supportsWebGL: this.deviceDetector.hasWebGLSupport(),
            performanceLevel: this.deviceDetector.recommendPerformanceQuality(),
            memoryCapacity: memoryMB,
            isMobile
          };
        }
        /**
         * Build settings context from settings manager
         */
        buildSettingsContext() {
          try {
            return {
              dynamicAccentEnabled: true,
              // Always enabled for dynamic accent
              gradientIntensity: settings.get("sn-gradient-intensity"),
              webglEnabled: settings.get("sn-webgl-enabled"),
              webglForceEnabled: settings.get("sn-webgl-enabled"),
              // Use same setting
              visualGuideMode: settings.get("sn-artistic-mode"),
              // Use artistic mode as visual guide
              depthLayersEnabled: settings.get("sn-gradient-intensity") !== "disabled",
              consciousnessLevel: 0.8,
              // Fixed value for consciousness level
              breathingAnimationEnabled: true
              // Always enabled
            };
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "BackgroundStrategySelector",
              "Failed to load settings, using defaults:",
              error
            );
            return {
              dynamicAccentEnabled: true,
              gradientIntensity: "balanced",
              webglEnabled: true,
              webglForceEnabled: false,
              visualGuideMode: "cosmic",
              depthLayersEnabled: true,
              consciousnessLevel: 0.8,
              breathingAnimationEnabled: true
            };
          }
        }
        /**
         * Get or create strategy instance (lazy loading)
         */
        getOrCreateStrategy(strategyName) {
          if (this.strategyInstances.has(strategyName)) {
            return this.strategyInstances.get(strategyName);
          }
          let strategy = null;
          try {
            switch (strategyName) {
              case "dynamic-catppuccin":
                strategy = new DynamicCatppuccinStrategy();
                break;
              case "living-gradient":
                strategy = new LivingGradientStrategy();
                break;
              case "webgl-gradient":
                strategy = new WebGLGradientStrategy();
                break;
              case "webgl-gradient-degraded":
                strategy = new WebGLGradientStrategy();
                break;
              case "depth-layered":
                strategy = new DepthLayeredStrategy();
                break;
              default:
                Y3KDebug?.debug?.warn(
                  "BackgroundStrategySelector",
                  `Unknown strategy: ${strategyName}`
                );
                return null;
            }
            if (strategy) {
              this.strategyInstances.set(strategyName, strategy);
              Y3KDebug?.debug?.log(
                "BackgroundStrategySelector",
                `Created strategy instance: ${strategyName}`
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "BackgroundStrategySelector",
              `Failed to create strategy ${strategyName}:`,
              error
            );
            return null;
          }
          return strategy;
        }
        /**
         * Get estimated total processing time for selected strategies
         */
        getEstimatedProcessingTime(strategies, context) {
          return strategies.reduce((total, strategy) => {
            return total + strategy.getEstimatedProcessingTime(context);
          }, 0);
        }
        /**
         * Get strategy metadata for debugging
         */
        getStrategyMetadata(strategyName) {
          return this.strategyMetadata.get(strategyName) || null;
        }
        /**
         * Get all available strategy names
         */
        getAvailableStrategyNames() {
          return Array.from(this.strategyMetadata.keys());
        }
        /**
         * Update strategy selection criteria (for runtime adjustments)
         */
        updateSelectionCriteria(updates) {
          Y3KDebug?.debug?.log(
            "BackgroundStrategySelector",
            "Strategy selection criteria updated:",
            updates
          );
        }
        /**
         * Cleanup strategy instances
         */
        destroy() {
          this.strategyInstances.forEach((strategy, name) => {
            if ("destroy" in strategy && typeof strategy.destroy === "function") {
              try {
                strategy.destroy();
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "BackgroundStrategySelector",
                  `Error destroying strategy ${name}:`,
                  error
                );
              }
            }
          });
          this.strategyInstances.clear();
          this.strategyMetadata.clear();
          Y3KDebug?.debug?.log(
            "BackgroundStrategySelector",
            "Strategy selector destroyed"
          );
        }
      };
      __name(_BackgroundStrategySelector, "BackgroundStrategySelector");
      BackgroundStrategySelector = _BackgroundStrategySelector;
    }
  });

  // src-js/visual/integration/ColorOrchestrator.ts
  var _ColorStrategyRegistry, ColorStrategyRegistry, _ColorOrchestrator, ColorOrchestrator, globalColorOrchestrator;
  var init_ColorOrchestrator = __esm({
    "src-js/visual/integration/ColorOrchestrator.ts"() {
      "use strict";
      init_globalConfig();
      init_UnifiedEventBus();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_OKLABColorProcessor();
      init_Year3000Utilities();
      init_BackgroundStrategySelector();
      _ColorStrategyRegistry = class _ColorStrategyRegistry {
        constructor() {
          this.strategies = /* @__PURE__ */ new Map();
          this.defaultStrategy = null;
        }
        /**
         * Register a color processing strategy
         */
        register(strategy) {
          const name = strategy.getStrategyName();
          this.strategies.set(name, strategy);
          if (!this.defaultStrategy) {
            this.defaultStrategy = strategy;
          }
          Y3KDebug?.debug?.log(
            "ColorStrategyRegistry",
            `Registered strategy: ${name}`
          );
        }
        /**
         * Select best strategy for given criteria
         */
        selectStrategy(criteria) {
          if (criteria.performance === "high" && criteria.quality === "basic") {
            for (const strategy of this.strategies.values()) {
              const strategyName = strategy.getStrategyName().toLowerCase();
              if (strategyName.includes("lightweight") || strategyName.includes("fast")) {
                return strategy;
              }
            }
          }
          if (criteria.quality === "premium" && criteria.performance === "low") {
            for (const strategy of this.strategies.values()) {
              const strategyName = strategy.getStrategyName().toLowerCase();
              if (strategyName.includes("harmony") || strategyName.includes("advanced")) {
                return strategy;
              }
            }
          }
          if (criteria.deviceCapabilities?.isMobile) {
            for (const strategy of this.strategies.values()) {
              const strategyName = strategy.getStrategyName().toLowerCase();
              if (strategyName.includes("mobile") || strategyName.includes("optimized")) {
                return strategy;
              }
            }
          }
          return this.defaultStrategy;
        }
        /**
         * Get all registered strategies
         */
        getStrategies() {
          return Array.from(this.strategies.values());
        }
        /**
         * Get strategy by name
         */
        getStrategy(name) {
          return this.strategies.get(name) || null;
        }
        /**
         * Set default strategy
         */
        setDefaultStrategy(strategy) {
          this.defaultStrategy = strategy;
        }
        /**
         * Get registry status
         */
        getStatus() {
          return {
            strategyCount: this.strategies.size,
            strategies: Array.from(this.strategies.keys()),
            defaultStrategy: this.defaultStrategy?.getStrategyName() || null
          };
        }
      };
      __name(_ColorStrategyRegistry, "ColorStrategyRegistry");
      ColorStrategyRegistry = _ColorStrategyRegistry;
      _ColorOrchestrator = class _ColorOrchestrator {
        constructor() {
          this.isInitialized = false;
          this.processingQueue = [];
          this.isProcessing = false;
          this.currentStrategy = null;
          this.oklabCoordinationEnabled = true;
          // Phase 4: Recursion prevention
          this.processedContexts = /* @__PURE__ */ new Map();
          // trackUri -> timestamp
          this.CONTEXT_CACHE_TTL = 2e3;
          // 2 seconds to prevent rapid reprocessing
          this.MAX_QUEUE_SIZE = 10;
          // Prevent queue overflow
          // Enhanced result caching for performance
          this.resultCache = /* @__PURE__ */ new Map();
          this.cacheMaxSize = 50;
          this.cacheTimeoutMs = 3e5;
          // 5 minutes
          // Enhanced performance metrics
          this.orchestrationMetrics = {
            totalProcessingTime: 0,
            strategiesProcessed: 0,
            strategiesSucceeded: 0,
            strategiesFailed: 0,
            cacheHits: 0,
            averageStrategyTime: 0,
            memoryUsage: 0,
            oklabCoordinations: 0,
            oklabProcessingTime: 0
          };
          // Legacy performance tracking (maintained for compatibility)
          this.processedCount = 0;
          this.totalProcessingTime = 0;
          this.lastProcessingTime = 0;
          this.registry = new ColorStrategyRegistry();
          this.settingsManager = new SettingsManager();
          const globalSystem = globalThis.year3000System;
          this.performanceAnalyzer = globalSystem?.performanceAnalyzer || globalSystem?.facadeCoordinator?.getCachedNonVisualSystem?.("SimplePerformanceCoordinator") || null;
          this.deviceDetector = new DeviceCapabilityDetector();
          this.strategySelector = new BackgroundStrategySelector();
          this.oklabProcessor = new OKLABColorProcessor(YEAR3000_CONFIG.enableDebug);
          this.selectionCriteria = {
            performance: "medium",
            quality: "enhanced",
            deviceCapabilities: {
              hasWebGL: Boolean(window.WebGLRenderingContext),
              memoryMB: this.estimateMemoryMB(),
              isMobile: this.detectMobile()
            },
            userPreferences: {
              harmonicMode: "cosmic",
              intensity: 0.8,
              enableAdvancedBlending: true
            }
          };
          this.updateDeviceCapabilities();
          Y3KDebug?.debug?.log(
            "ColorOrchestrator",
            "Enhanced color orchestrator created with multi-strategy coordination"
          );
        }
        /**
         * Initialize enhanced orchestrator with event bus and strategy registry
         */
        async initialize() {
          if (this.isInitialized) {
            Y3KDebug?.debug?.warn("ColorOrchestrator", "Already initialized");
            return;
          }
          try {
            unifiedEventBus.subscribe(
              "colors:extracted",
              this.handleColorExtractionEvent.bind(this),
              "ColorOrchestrator"
            );
            this.updateDeviceCapabilities();
            this.loadUserPreferences();
            await this.registerDefaultStrategies();
            this.isInitialized = true;
            Y3KDebug?.debug?.log(
              "ColorOrchestrator",
              "Enhanced color orchestrator initialized",
              {
                strategies: this.registry.getStatus().strategyCount,
                criteria: this.selectionCriteria,
                oklabEnabled: this.oklabCoordinationEnabled,
                deviceLevel: this.deviceDetector.recommendPerformanceQuality()
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ColorOrchestrator",
              "Enhanced initialization failed:",
              error
            );
            throw error;
          }
        }
        /**
         * Handle color extraction event from UnifiedEventBus
         * Phase 3: Updated to handle UnifiedEventBus events directly (no event.type wrapper)
         */
        async handleColorExtractionEvent(data) {
          const context = data;
          await this.handleColorExtraction(context);
        }
        /**
         * Enhanced color extraction processing with multi-strategy coordination
         * Phase 4: Added recursion prevention, queue overflow protection, and caching
         */
        async handleColorExtraction(context) {
          const now = Date.now();
          const contextKey = context.trackUri || "unknown";
          Y3KDebug?.debug?.log(
            "ColorOrchestrator",
            "\u{1F3B5} Color Extraction Event Received - WebGL Gradient Entry Point",
            {
              trackUri: contextKey,
              rawColors: context.rawColors,
              colorCount: Object.keys(context.rawColors).length,
              isProcessing: this.isProcessing,
              queueLength: this.processingQueue.length,
              entryPoint: "handleColorExtraction"
            }
          );
          const lastProcessed = this.processedContexts.get(contextKey);
          if (lastProcessed && now - lastProcessed < this.CONTEXT_CACHE_TTL) {
            Y3KDebug?.debug?.warn(
              "ColorOrchestrator",
              `Skipping recent context to prevent recursion: ${contextKey}`,
              {
                lastProcessed: new Date(lastProcessed).toISOString(),
                timeDiff: now - lastProcessed
              }
            );
            return;
          }
          const cacheKey = this.generateCacheKey(context);
          const cachedResult = this.getCachedResult(cacheKey);
          if (cachedResult) {
            this.orchestrationMetrics.cacheHits++;
            await this.applyColorResult(cachedResult);
            Y3KDebug?.debug?.log("ColorOrchestrator", "Using cached color result", {
              cacheKey
            });
            return;
          }
          if (this.processingQueue.length >= this.MAX_QUEUE_SIZE) {
            Y3KDebug?.debug?.warn(
              "ColorOrchestrator",
              `Queue overflow protection: dropping context ${contextKey}`,
              {
                queueSize: this.processingQueue.length,
                maxSize: this.MAX_QUEUE_SIZE
              }
            );
            this.processingQueue.shift();
          }
          this.cleanupProcessedContexts(now);
          this.processingQueue.push(context);
          if (!this.isProcessing) {
            await this.processQueue();
          }
        }
        /**
         * Process the color processing queue
         */
        async processQueue() {
          if (this.isProcessing || this.processingQueue.length === 0) return;
          this.isProcessing = true;
          try {
            while (this.processingQueue.length > 0) {
              const context = this.processingQueue.shift();
              await this.processColorContext(context);
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ColorOrchestrator",
              "Queue processing failed:",
              error
            );
          } finally {
            this.isProcessing = false;
            this.currentStrategy = null;
          }
        }
        /**
         * Clean up expired processed context cache entries
         * Phase 4: Prevents memory leaks from recursion prevention cache
         */
        cleanupProcessedContexts(now) {
          for (const [contextKey, timestamp] of this.processedContexts.entries()) {
            if (now - timestamp > this.CONTEXT_CACHE_TTL) {
              this.processedContexts.delete(contextKey);
            }
          }
        }
        /**
         * Enhanced single color context processing with multi-strategy coordination
         * Phase 4: Added multi-strategy processing, OKLAB coordination, and result merging
         */
        async processColorContext(context) {
          const startTime = performance.now();
          const contextKey = context.trackUri || "unknown";
          Y3KDebug?.debug?.log(
            "ColorOrchestrator",
            "\u{1F3A8} Processing Color Context - WebGL Gradient Recovery Debug",
            {
              trackUri: contextKey,
              rawColors: context.rawColors,
              colorCount: Object.keys(context.rawColors).length,
              musicData: context.musicData,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            }
          );
          try {
            const selectedStrategies = this.strategySelector.selectStrategies(
              context,
              this.buildStrategySelectionCriteria(context)
            );
            if (selectedStrategies.length === 0) {
              const fallbackStrategy = this.selectStrategy(context);
              if (fallbackStrategy) {
                selectedStrategies.push(fallbackStrategy);
              } else {
                throw new Error(
                  "No suitable strategies selected for color processing"
                );
              }
            }
            const strategyResults = await this.processWithStrategies(
              context,
              selectedStrategies
            );
            if (this.oklabCoordinationEnabled && strategyResults.filter((r) => r.success).length > 1) {
              await this.coordinateOKLABProcessing(strategyResults, context);
            }
            const finalResult = this.mergeStrategyResults(strategyResults, context);
            const cacheKey = this.generateCacheKey(context);
            this.cacheResult(cacheKey, finalResult);
            await this.applyColorResult(finalResult);
            this.processedContexts.set(contextKey, Date.now());
            const totalTime = performance.now() - startTime;
            this.updateOrchestrationMetrics(strategyResults, totalTime);
            this.lastProcessingTime = totalTime;
            this.totalProcessingTime += totalTime;
            this.processedCount++;
            Y3KDebug?.debug?.log(
              "ColorOrchestrator",
              "Enhanced color processing completed",
              {
                strategies: selectedStrategies.map((s) => s.getStrategyName()),
                processingTime: totalTime,
                trackUri: context.trackUri,
                oklabCoordination: this.oklabCoordinationEnabled,
                successfulStrategies: strategyResults.filter((r) => r.success).length
              }
            );
          } catch (error) {
            const endTime = performance.now();
            this.lastProcessingTime = endTime - startTime;
            Y3KDebug?.debug?.error(
              "ColorOrchestrator",
              "Enhanced color processing failed:",
              {
                error,
                strategy: this.currentStrategy,
                trackUri: context.trackUri
              }
            );
            await this.applyFallbackColors(context);
          }
        }
        /**
         * Select best strategy for given context
         */
        selectStrategy(context) {
          const contextualCriteria = { ...this.selectionCriteria };
          if (context.performanceHints) {
            if (context.performanceHints.preferLightweight) {
              contextualCriteria.performance = "high";
              contextualCriteria.quality = "basic";
            }
            if (context.performanceHints.enableAdvancedBlending) {
              contextualCriteria.quality = "premium";
            }
          }
          if (context.musicData) {
            if (context.musicData.energy && context.musicData.energy > 0.8) {
              contextualCriteria.quality = "premium";
            }
          }
          return this.registry.selectStrategy(contextualCriteria);
        }
        /**
         * Register default strategies (ColorHarmonyEngine will self-register)
         */
        async registerDefaultStrategies() {
          Y3KDebug?.debug?.log(
            "ColorOrchestrator",
            "Default strategies registration completed"
          );
        }
        // ============================================================================
        // Enhanced Multi-Strategy Processing Methods
        // ============================================================================
        /**
         * Process colors with multiple strategies in parallel
         */
        async processWithStrategies(context, strategies) {
          const results = [];
          const strategyPromises = strategies.map(async (strategy) => {
            const strategyStartTime = performance.now();
            this.currentStrategy = strategy.getStrategyName();
            try {
              const result = await strategy.processColors(context);
              const processingTime = performance.now() - strategyStartTime;
              return {
                strategy,
                result,
                processingTime,
                success: true
              };
            } catch (error) {
              const processingTime = performance.now() - strategyStartTime;
              Y3KDebug?.debug?.error(
                "ColorOrchestrator",
                `Strategy ${strategy.getStrategyName()} failed:`,
                error
              );
              return {
                strategy,
                result: this.createErrorResult(context, strategy, error),
                processingTime,
                success: false,
                error: error instanceof Error ? error.message : "Unknown error"
              };
            }
          });
          const strategyResults = await Promise.all(strategyPromises);
          return strategyResults;
        }
        /**
         * Merge results from multiple strategies with intelligent conflict resolution
         */
        mergeStrategyResults(strategyResults, context) {
          const successfulResults = strategyResults.filter((r) => r.success);
          if (successfulResults.length === 0) {
            return this.createFallbackResult(context);
          }
          if (successfulResults.length === 1) {
            return successfulResults[0].result;
          }
          const mergeOptions = {
            priorityWeighting: true,
            conflictResolution: "merge",
            preserveMetadata: true,
            consciousnessBlending: true,
            oklabCoordination: this.oklabCoordinationEnabled
          };
          return this.performResultMerge(successfulResults, context, mergeOptions);
        }
        /**
         * Perform intelligent merging of multiple color results
         */
        performResultMerge(results, context, options) {
          const sortedResults = results.sort((a, b) => {
            const aPriority = this.strategySelector.getStrategyMetadata(a.strategy.getStrategyName())?.priority || 0;
            const bPriority = this.strategySelector.getStrategyMetadata(b.strategy.getStrategyName())?.priority || 0;
            return bPriority - aPriority;
          });
          const baseResult = sortedResults[0].result;
          const mergedResult = {
            processedColors: { ...baseResult.processedColors },
            accentHex: baseResult.accentHex,
            accentRgb: baseResult.accentRgb,
            metadata: {
              ...baseResult.metadata,
              strategy: "enhanced-orchestrator",
              mergedStrategies: sortedResults.map(
                (r) => r.strategy.getStrategyName()
              ),
              totalProcessingTime: sortedResults.reduce(
                (sum, r) => sum + r.processingTime,
                0
              )
            },
            context
          };
          for (let i = 1; i < sortedResults.length; i++) {
            const currentResult = sortedResults[i].result;
            Object.entries(currentResult.processedColors).forEach(([key, value]) => {
              if (options.conflictResolution === "override") {
                if (i === 1) mergedResult.processedColors[key] = value;
              } else if (options.conflictResolution === "merge") {
                const strategyName = currentResult.metadata.strategy;
                mergedResult.processedColors[`${strategyName}-${key}`] = value;
              }
            });
            if (options.preserveMetadata) {
              const strategyName = currentResult.metadata.strategy;
              mergedResult.metadata[`${strategyName}-metadata`] = currentResult.metadata;
            }
          }
          if (options.consciousnessBlending) {
            this.applyConsciousnessBlending(mergedResult, sortedResults);
          }
          if (options.oklabCoordination) {
            this.applyOKLABCoordination(mergedResult, sortedResults);
          }
          return mergedResult;
        }
        /**
         * Apply consciousness-aware blending to merged results
         */
        applyConsciousnessBlending(mergedResult, strategyResults) {
          let totalWeight = 0;
          let weightedR = 0, weightedG = 0, weightedB = 0;
          strategyResults.forEach((result) => {
            const strategyMetadata = this.strategySelector.getStrategyMetadata(
              result.strategy.getStrategyName()
            );
            const weight = (strategyMetadata?.qualityScore || 5) / 10;
            const rgb = this.hexToRgb(result.result.accentHex);
            if (rgb) {
              weightedR += rgb.r * weight;
              weightedG += rgb.g * weight;
              weightedB += rgb.b * weight;
              totalWeight += weight;
            }
          });
          if (totalWeight > 0) {
            const avgR = Math.round(weightedR / totalWeight);
            const avgG = Math.round(weightedG / totalWeight);
            const avgB = Math.round(weightedB / totalWeight);
            mergedResult.accentHex = this.rgbToHex(avgR, avgG, avgB);
            mergedResult.accentRgb = `${avgR},${avgG},${avgB}`;
            mergedResult.metadata.consciousnessBlending = {
              strategyCount: strategyResults.length,
              totalWeight,
              blendedAccent: mergedResult.accentHex
            };
          }
        }
        /**
         * Coordinate OKLAB processing across strategies for perceptual uniformity
         */
        async coordinateOKLABProcessing(strategyResults, context) {
          const oklabStartTime = performance.now();
          try {
            const successfulResults = strategyResults.filter((r) => r.success);
            const allColors = {};
            successfulResults.forEach((result) => {
              Object.entries(result.result.processedColors).forEach(
                ([key, value]) => {
                  if (value && value.startsWith("#")) {
                    allColors[`${result.strategy.getStrategyName()}-${key}`] = value;
                  }
                }
              );
            });
            const preset = this.getOptimalOKLABPreset(context);
            const oklabResults = this.oklabProcessor.processColorPalette(
              allColors,
              preset
            );
            successfulResults.forEach((result) => {
              const strategyName = result.strategy.getStrategyName();
              result.oklabData = Object.values(oklabResults).filter(
                (oklab) => oklab.originalHex in allColors && Object.keys(allColors).find(
                  (key) => key.startsWith(strategyName) && allColors[key] === oklab.originalHex
                )
              );
            });
            const oklabProcessingTime = performance.now() - oklabStartTime;
            this.orchestrationMetrics.oklabCoordinations++;
            this.orchestrationMetrics.oklabProcessingTime += oklabProcessingTime;
            Y3KDebug?.debug?.log(
              "ColorOrchestrator",
              "OKLAB coordination completed",
              {
                strategiesCoordinated: successfulResults.length,
                colorsProcessed: Object.keys(allColors).length,
                preset: preset.name,
                processingTime: oklabProcessingTime
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ColorOrchestrator",
              "OKLAB coordination failed:",
              error
            );
          }
        }
        /**
         * Apply OKLAB coordination to merged results for perceptual consistency
         */
        applyOKLABCoordination(mergedResult, strategyResults) {
          try {
            const allOKLABData = [];
            strategyResults.forEach((result) => {
              if (result.oklabData) {
                allOKLABData.push(...result.oklabData);
              }
            });
            if (allOKLABData.length === 0) return;
            const oklabAccent = this.calculatePerceptuallyUniformAccent(allOKLABData);
            if (oklabAccent) {
              mergedResult.accentHex = oklabAccent.enhancedHex;
              mergedResult.accentRgb = `${oklabAccent.enhancedRgb.r},${oklabAccent.enhancedRgb.g},${oklabAccent.enhancedRgb.b}`;
              const oklabCSSVars = this.oklabProcessor.generateCSSVariables(
                oklabAccent,
                "sn-oklab-unified"
              );
              Object.entries(oklabCSSVars).forEach(([key, value]) => {
                mergedResult.processedColors[key] = value;
              });
              mergedResult.metadata.oklabCoordination = {
                enabled: true,
                strategiesCoordinated: strategyResults.length,
                colorsProcessed: allOKLABData.length,
                perceptualAccent: oklabAccent.enhancedHex,
                lightness: oklabAccent.oklabEnhanced.L,
                chroma: oklabAccent.oklchEnhanced.C,
                hue: oklabAccent.oklchEnhanced.H
              };
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ColorOrchestrator",
              "OKLAB coordination application failed:",
              error
            );
          }
        }
        /**
         * Calculate perceptually uniform accent color from OKLAB data
         */
        calculatePerceptuallyUniformAccent(oklabData) {
          if (oklabData.length === 0) return null;
          if (oklabData.length === 1) return oklabData[0] || null;
          let totalWeight = 0;
          let weightedL = 0, weightedA = 0, weightedB = 0;
          oklabData.forEach((oklab) => {
            const chroma = Math.sqrt(
              oklab.oklabEnhanced.a ** 2 + oklab.oklabEnhanced.b ** 2
            );
            const weight = Math.max(0.1, chroma);
            weightedL += oklab.oklabEnhanced.L * weight;
            weightedA += oklab.oklabEnhanced.a * weight;
            weightedB += oklab.oklabEnhanced.b * weight;
            totalWeight += weight;
          });
          if (totalWeight === 0) return oklabData[0] || null;
          const avgOklab = {
            L: weightedL / totalWeight,
            a: weightedA / totalWeight,
            b: weightedB / totalWeight
          };
          const avgRgb = oklabToRgb(avgOklab.L, avgOklab.a, avgOklab.b);
          const avgHex = rgbToHex(avgRgb.r, avgRgb.g, avgRgb.b);
          const preset = OKLABColorProcessor.getPreset("STANDARD");
          return this.oklabProcessor.processColor(avgHex, preset);
        }
        /**
         * Get current processing status with enhanced metrics
         * Phase 4: Added recursion prevention status and orchestration metrics
         */
        getStatus() {
          return {
            isProcessing: this.isProcessing,
            ...this.currentStrategy ? { currentStrategy: this.currentStrategy } : {},
            queueSize: this.processingQueue.length,
            processedContextsCount: this.processedContexts.size,
            maxQueueSize: this.MAX_QUEUE_SIZE,
            contextCacheTTL: this.CONTEXT_CACHE_TTL,
            orchestrationMetrics: { ...this.orchestrationMetrics },
            oklabCoordinationEnabled: this.oklabCoordinationEnabled
          };
        }
        /**
         * Set strategy selection criteria
         */
        setSelectionCriteria(criteria) {
          this.selectionCriteria = { ...this.selectionCriteria, ...criteria };
          Y3KDebug?.debug?.log(
            "ColorOrchestrator",
            "Selection criteria updated",
            criteria
          );
        }
        /**
         * Get processing performance metrics
         */
        getPerformanceMetrics() {
          return {
            processedCount: this.processedCount,
            averageProcessingTime: this.processedCount > 0 ? this.totalProcessingTime / this.processedCount : 0,
            lastProcessingTime: this.lastProcessingTime,
            totalProcessingTime: this.totalProcessingTime
          };
        }
        /**
         * Register a new color processing strategy
         */
        registerStrategy(strategy) {
          this.registry.register(strategy);
        }
        /**
         * Get strategy registry for advanced operations
         */
        getRegistry() {
          return this.registry;
        }
        // ============================================================================
        // Utility Methods
        // ============================================================================
        /**
         * Estimate available memory in MB
         */
        estimateMemoryMB() {
          const memoryInfo = performance.memory;
          if (memoryInfo && memoryInfo.usedJSHeapSize && memoryInfo.jsHeapSizeLimit) {
            return (memoryInfo.jsHeapSizeLimit - memoryInfo.usedJSHeapSize) / (1024 * 1024);
          }
          return this.detectMobile() ? 256 : 1024;
        }
        /**
         * Detect if running on mobile device
         */
        detectMobile() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
        }
        // ============================================================================
        // Enhanced Utility Methods
        // ============================================================================
        /**
         * Build strategy selection criteria based on current context and settings
         */
        buildStrategySelectionCriteria(context) {
          return {
            ...this.selectionCriteria,
            settingsContext: {
              dynamicAccentEnabled: this.settingsManager.get("sn-dynamic-accent-enabled") ?? true,
              gradientIntensity: this.settingsManager.get("sn-gradient-intensity") ?? "balanced",
              webglEnabled: this.settingsManager.get("sn-webgl-enabled") ?? true,
              visualGuideMode: this.settingsManager.get("sn-visual-guide-mode") ?? "cosmic",
              depthLayersEnabled: this.settingsManager.get("sn-depth-enabled") ?? true,
              consciousnessLevel: this.settingsManager.get("sn-consciousness-level") ?? 0.8,
              breathingAnimationEnabled: this.settingsManager.get("sn-breathing-enabled") ?? true
            },
            musicContext: context.musicData,
            deviceContext: {
              supportsWebGL: this.deviceDetector.hasWebGLSupport ? this.deviceDetector.hasWebGLSupport() : false,
              performanceLevel: this.deviceDetector.recommendPerformanceQuality(),
              memoryCapacity: window.navigator.deviceMemory ? window.navigator.deviceMemory * 1024 : 4096,
              isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent
              )
            }
          };
        }
        /**
         * Get optimal OKLAB preset based on context
         */
        getOptimalOKLABPreset(context) {
          const intensity = this.selectionCriteria.userPreferences?.intensity || 0.8;
          const musicEnergy = context.musicData?.energy || 0.5;
          const combinedIntensity = (intensity + musicEnergy) / 2;
          if (combinedIntensity >= 0.8) {
            return OKLABColorProcessor.getPreset("COSMIC");
          } else if (combinedIntensity >= 0.6) {
            return OKLABColorProcessor.getPreset("VIBRANT");
          } else if (combinedIntensity >= 0.4) {
            return OKLABColorProcessor.getPreset("STANDARD");
          } else {
            return OKLABColorProcessor.getPreset("SUBTLE");
          }
        }
        /**
         *  PHASE 2: Emit color result instead of applying CSS directly
         * ColorStateManager will handle all CSS applications through batching
         */
        async applyColorResult(result) {
          try {
            unifiedEventBus.emit("colors:harmonized", {
              processedColors: result.processedColors,
              accentHex: result.accentHex || "#cba6f7",
              accentRgb: result.accentRgb || "203,166,247",
              strategies: [result.metadata.strategy],
              processingTime: result.metadata.processingTime,
              trackUri: result.metadata.trackUri,
              coordinationMetrics: {
                detectedGenre: result.metadata.genre || "unknown",
                emotionalState: result.metadata.emotion || "neutral",
                oklabPreset: result.metadata.oklabPreset || "default",
                coordinationStrategy: result.metadata.strategy,
                musicInfluenceStrength: result.metadata.intensity || 0.5
              },
              processingMode: "orchestrated"
            });
            const event = new CustomEvent("colors/harmonized", {
              detail: {
                type: "colors/harmonized",
                payload: {
                  ...result,
                  cssVariables: result.processedColors
                }
              }
            });
            document.dispatchEvent(event);
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ColorOrchestrator",
              "Failed to apply color result:",
              error
            );
          }
        }
        /**
         * Cache management methods
         */
        generateCacheKey(context) {
          return `${context.trackUri}-${context.timestamp}-${JSON.stringify(
            context.musicData || {}
          )}`;
        }
        getCachedResult(cacheKey) {
          return this.resultCache.get(cacheKey) || null;
        }
        cacheResult(cacheKey, result) {
          if (this.resultCache.size >= this.cacheMaxSize) {
            const firstKey = this.resultCache.keys().next().value;
            if (firstKey) this.resultCache.delete(firstKey);
          }
          this.resultCache.set(cacheKey, result);
          setTimeout(() => {
            this.resultCache.delete(cacheKey);
          }, this.cacheTimeoutMs);
        }
        /**
         * Device capability and preference management
         */
        updateDeviceCapabilities() {
          this.selectionCriteria.deviceCapabilities = {
            hasWebGL: this.deviceDetector.hasWebGLSupport ? this.deviceDetector.hasWebGLSupport() : false,
            memoryMB: window.navigator.deviceMemory ? window.navigator.deviceMemory * 1024 : 4096,
            isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
              navigator.userAgent
            )
          };
        }
        loadUserPreferences() {
          try {
            this.selectionCriteria.userPreferences = {
              harmonicMode: this.settingsManager.get("sn-visual-guide-mode") ?? "cosmic",
              intensity: this.settingsManager.get("sn-consciousness-level") ?? 0.8,
              enableAdvancedBlending: this.settingsManager.get("sn-advanced-blending") ?? true
            };
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "ColorOrchestrator",
              "Failed to load user preferences:",
              error
            );
          }
        }
        /**
         * Error handling and fallback methods
         */
        createErrorResult(context, strategy, error) {
          return {
            processedColors: context.rawColors,
            accentHex: "#cba6f7",
            // Fallback mauve
            accentRgb: "203,166,247",
            metadata: {
              strategy: strategy.getStrategyName(),
              processingTime: 0,
              error: error instanceof Error ? error.message : "Unknown error"
            },
            context
          };
        }
        createFallbackResult(context) {
          return {
            processedColors: context.rawColors,
            accentHex: "#cba6f7",
            // Fallback mauve
            accentRgb: "203,166,247",
            metadata: {
              strategy: "fallback",
              processingTime: 0,
              error: "All strategies failed"
            },
            context
          };
        }
        async applyFallbackColors(context) {
          const fallbackResult = this.createFallbackResult(context);
          await this.applyColorResult(fallbackResult);
        }
        /**
         * Update orchestration metrics
         */
        updateOrchestrationMetrics(results, totalTime) {
          this.orchestrationMetrics.totalProcessingTime += totalTime;
          this.orchestrationMetrics.strategiesProcessed += results.length;
          this.orchestrationMetrics.strategiesSucceeded += results.filter(
            (r) => r.success
          ).length;
          this.orchestrationMetrics.strategiesFailed += results.filter(
            (r) => !r.success
          ).length;
          const successfulTimes = results.filter((r) => r.success).map((r) => r.processingTime);
          if (successfulTimes.length > 0) {
            this.orchestrationMetrics.averageStrategyTime = successfulTimes.reduce((a, b) => a + b, 0) / successfulTimes.length;
          }
        }
        /**
         * Color utility methods
         */
        hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
          } : null;
        }
        rgbToHex(r, g, b) {
          return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        // ============================================================================
        // Enhanced Public Interface Methods
        // ============================================================================
        /**
         * Get orchestration metrics for monitoring
         */
        getOrchestrationMetrics() {
          return { ...this.orchestrationMetrics };
        }
        /**
         * Clear result cache
         */
        clearCache() {
          this.resultCache.clear();
          Y3KDebug?.debug?.log("ColorOrchestrator", "Result cache cleared");
        }
        /**
         * Enable or disable OKLAB coordination
         */
        setOKLABCoordinationEnabled(enabled) {
          this.oklabCoordinationEnabled = enabled;
          Y3KDebug?.debug?.log(
            "ColorOrchestrator",
            `OKLAB coordination ${enabled ? "enabled" : "disabled"}`
          );
        }
        /**
         * Get OKLAB coordination status
         */
        isOKLABCoordinationEnabled() {
          return this.oklabCoordinationEnabled;
        }
        /**
         * Get OKLAB processor for external use
         */
        getOKLABProcessor() {
          return this.oklabProcessor;
        }
        /**
         * Cleanup resources
         */
        async destroy() {
          unifiedEventBus.unsubscribeAll("ColorOrchestrator");
          this.clearCache();
          this.processingQueue = [];
          this.isProcessing = false;
          this.isInitialized = false;
          this.processedContexts.clear();
          this.strategySelector.destroy();
          Y3KDebug?.debug?.log(
            "ColorOrchestrator",
            "Enhanced color orchestrator destroyed"
          );
        }
      };
      __name(_ColorOrchestrator, "ColorOrchestrator");
      ColorOrchestrator = _ColorOrchestrator;
      globalColorOrchestrator = new ColorOrchestrator();
    }
  });

  // src-js/visual/music-sync/integration/MusicEmotionAnalyzer.ts
  var _MusicEmotionAnalyzer, MusicEmotionAnalyzer, _ValenceEnergyMapper, ValenceEnergyMapper, _AudioFeatureAnalyzer, AudioFeatureAnalyzer, _TemperatureCalculator, TemperatureCalculator, _ConsciousnessDetector, ConsciousnessDetector;
  var init_MusicEmotionAnalyzer = __esm({
    "src-js/visual/music-sync/integration/MusicEmotionAnalyzer.ts"() {
      "use strict";
      _MusicEmotionAnalyzer = class _MusicEmotionAnalyzer {
        constructor(config = {}) {
          this.initialized = false;
          this.emotionHistory = [];
          this.currentEmotion = null;
          this.emotionCache = /* @__PURE__ */ new Map();
          // Subscribers for emotion updates
          this.emotionSubscribers = /* @__PURE__ */ new Set();
          this.config = {
            emotionSensitivity: 0.7,
            confidenceThreshold: 0.6,
            smoothingFactor: 0.3,
            memoryDecay: 0.1,
            consciousnessAwareness: true,
            organicFlowDetection: true,
            cinematicAnalysis: true,
            analysisInterval: 500,
            // 2Hz analysis rate
            cacheSize: 100,
            ...config
          };
          this.valenceEnergyMapper = new ValenceEnergyMapper();
          this.audioFeatureAnalyzer = new AudioFeatureAnalyzer();
          this.temperatureCalculator = new TemperatureCalculator();
          this.consciousnessDetector = new ConsciousnessDetector();
        }
        // ===== SYSTEM LIFECYCLE =====
        async initialize() {
          if (this.initialized) return;
          try {
            await this.valenceEnergyMapper.initialize();
            await this.audioFeatureAnalyzer.initialize();
            await this.temperatureCalculator.initialize();
            if (this.config.consciousnessAwareness) {
              await this.consciousnessDetector.initialize();
            }
            this.initialized = true;
            console.log(
              "\u{1F3B5} MusicEmotionAnalyzer initialized with consciousness awareness"
            );
          } catch (error) {
            console.error("\u274C Failed to initialize MusicEmotionAnalyzer:", error);
            throw error;
          }
        }
        updateAnimation(_deltaTime) {
        }
        async healthCheck() {
          const issues = [];
          if (!this.initialized) {
            issues.push("MusicEmotionAnalyzer not initialized");
          }
          if (this.emotionHistory.length === 0) {
            issues.push("No emotion analysis history available");
          }
          if (this.currentEmotion && this.currentEmotion.confidence < this.config.confidenceThreshold) {
            issues.push(
              `Low emotion confidence: ${this.currentEmotion.confidence.toFixed(2)}`
            );
          }
          return {
            healthy: issues.length === 0,
            issues,
            metrics: {
              emotionHistorySize: this.emotionHistory.length,
              currentConfidence: this.currentEmotion?.confidence ?? 0,
              subscriberCount: this.emotionSubscribers.size,
              cacheSize: this.emotionCache.size
            }
          };
        }
        destroy() {
          this.emotionSubscribers.clear();
          this.emotionHistory = [];
          this.emotionCache.clear();
          this.currentEmotion = null;
          this.initialized = false;
        }
        // ===== PUBLIC API =====
        /**
         * Analyze audio features and extract emotional state
         */
        async analyzeEmotion(audioFeatures, audioData) {
          if (!this.initialized) {
            throw new Error(
              "MusicEmotionAnalyzer must be initialized before analysis"
            );
          }
          try {
            const cacheKey = this.createCacheKey(audioFeatures);
            if (this.emotionCache.has(cacheKey)) {
              const cachedEmotion = this.emotionCache.get(cacheKey);
              if (cachedEmotion) {
                this.updateCurrentEmotion(cachedEmotion);
                return cachedEmotion;
              }
            }
            const emotion = await this.performEmotionAnalysis(
              audioFeatures,
              audioData
            );
            this.cacheEmotion(cacheKey, emotion);
            this.updateCurrentEmotion(emotion);
            this.notifyEmotionUpdate(emotion);
            return emotion;
          } catch (error) {
            console.error("\u274C Error analyzing emotion:", error);
            return this.createNeutralEmotion(audioFeatures);
          }
        }
        /**
         * Get current emotional state
         */
        getCurrentEmotion() {
          return this.currentEmotion;
        }
        /**
         * Get emotion analysis history
         */
        getEmotionHistory(limit) {
          if (limit) {
            return this.emotionHistory.slice(-limit);
          }
          return [...this.emotionHistory];
        }
        /**
         * Subscribe to emotion updates
         */
        onEmotionUpdate(callback) {
          this.emotionSubscribers.add(callback);
          return () => {
            this.emotionSubscribers.delete(callback);
          };
        }
        /**
         * Update analysis configuration
         */
        updateConfig(newConfig) {
          this.config = { ...this.config, ...newConfig };
        }
        // ===== PRIVATE ANALYSIS METHODS =====
        async performEmotionAnalysis(audioFeatures, audioData) {
          const musicalCharacteristics = this.audioFeatureAnalyzer.extractCharacteristics(audioFeatures);
          const baseEmotion = this.valenceEnergyMapper.mapToEmotion(
            audioFeatures.valence,
            audioFeatures.energy,
            musicalCharacteristics
          );
          const colorTemperature = this.temperatureCalculator.calculateTemperature(
            baseEmotion,
            musicalCharacteristics
          );
          let consciousnessMetrics = {};
          if (this.config.consciousnessAwareness) {
            consciousnessMetrics = await this.consciousnessDetector.analyze(
              audioFeatures,
              musicalCharacteristics,
              audioData
            );
          }
          const smoothedEmotion = this.applyTemporalSmoothing(
            baseEmotion,
            musicalCharacteristics
          );
          const emotionalState = {
            primary: smoothedEmotion.primary,
            secondary: smoothedEmotion.secondary,
            intensity: smoothedEmotion.intensity,
            confidence: smoothedEmotion.confidence,
            valence: audioFeatures.valence,
            arousal: audioFeatures.energy,
            dominance: this.calculateDominance(audioFeatures, musicalCharacteristics),
            colorTemperature,
            timestamp: Date.now(),
            duration: this.calculateEmotionDuration(
              smoothedEmotion,
              musicalCharacteristics
            ),
            musicalCharacteristics: {
              ...musicalCharacteristics,
              organicFlow: consciousnessMetrics.organicFlow ?? musicalCharacteristics.organicFlow,
              cinematicDepth: consciousnessMetrics.cinematicDepth ?? musicalCharacteristics.cinematicDepth,
              consciousnessResonance: consciousnessMetrics.consciousnessResonance ?? 0.5
            }
          };
          return emotionalState;
        }
        applyTemporalSmoothing(baseEmotion, musicalCharacteristics) {
          if (!this.currentEmotion || this.config.smoothingFactor === 0) {
            return baseEmotion;
          }
          const smoothingFactor = this.config.smoothingFactor;
          const smoothedIntensity = baseEmotion.intensity * (1 - smoothingFactor) + this.currentEmotion.intensity * smoothingFactor;
          const smoothedConfidence = baseEmotion.confidence * (1 - smoothingFactor) + this.currentEmotion.confidence * smoothingFactor;
          const primary = baseEmotion.confidence > this.config.confidenceThreshold ? baseEmotion.primary : this.currentEmotion.primary;
          return {
            primary,
            secondary: baseEmotion.secondary,
            intensity: smoothedIntensity,
            confidence: smoothedConfidence
          };
        }
        calculateDominance(audioFeatures, characteristics) {
          const tempoFactor = Math.min(characteristics.tempo / 140, 1);
          const energyFactor = audioFeatures.energy;
          const loudnessFactor = Math.min((audioFeatures.loudness + 60) / 60, 1);
          return tempoFactor * 0.3 + energyFactor * 0.4 + loudnessFactor * 0.3;
        }
        calculateEmotionDuration(emotion, characteristics) {
          const baseDuration = 2e3;
          const tempoMultiplier = 6e4 / characteristics.tempo;
          const stabilityMultiplier = emotion.confidence * 2;
          return Math.min(
            baseDuration * tempoMultiplier * stabilityMultiplier,
            1e4
          );
        }
        createCacheKey(audioFeatures) {
          const precision = 100;
          return [
            Math.round(audioFeatures.valence * precision),
            Math.round(audioFeatures.energy * precision),
            Math.round(audioFeatures.danceability * precision),
            Math.round(audioFeatures.acousticness * precision),
            audioFeatures.key,
            audioFeatures.mode
          ].join("-");
        }
        cacheEmotion(key, emotion) {
          if (this.emotionCache.size >= this.config.cacheSize) {
            const firstKey = this.emotionCache.keys().next().value;
            if (firstKey !== void 0) {
              this.emotionCache.delete(firstKey);
            }
          }
          this.emotionCache.set(key, emotion);
        }
        updateCurrentEmotion(emotion) {
          this.currentEmotion = emotion;
          this.emotionHistory.push(emotion);
          if (this.emotionHistory.length > 1e3) {
            this.emotionHistory = this.emotionHistory.slice(-500);
          }
        }
        notifyEmotionUpdate(emotion) {
          this.emotionSubscribers.forEach((callback) => {
            try {
              callback(emotion);
            } catch (error) {
              console.error("\u274C Error in emotion subscriber callback:", error);
            }
          });
        }
        createNeutralEmotion(audioFeatures) {
          return {
            primary: "serenity",
            secondary: [],
            intensity: 0.5,
            confidence: 0.3,
            valence: audioFeatures.valence ?? 0.5,
            arousal: audioFeatures.energy ?? 0.5,
            dominance: 0.5,
            colorTemperature: 6500,
            // Neutral daylight temperature
            timestamp: Date.now(),
            duration: 3e3,
            musicalCharacteristics: this.audioFeatureAnalyzer.extractCharacteristics(audioFeatures)
          };
        }
      };
      __name(_MusicEmotionAnalyzer, "MusicEmotionAnalyzer");
      MusicEmotionAnalyzer = _MusicEmotionAnalyzer;
      _ValenceEnergyMapper = class _ValenceEnergyMapper {
        async initialize() {
        }
        mapToEmotion(valence, energy, characteristics) {
          let primary;
          let secondary = [];
          let intensity;
          let confidence = 0.8;
          if (valence >= 0.6 && energy >= 0.6) {
            primary = characteristics.danceability > 0.7 ? "excitement" : "joy";
            secondary = ["joy", "excitement"];
            intensity = Math.min(valence + energy - 0.2, 1);
          } else if (valence >= 0.6 && energy < 0.4) {
            primary = characteristics.acousticness > 0.6 ? "serenity" : "love";
            secondary = ["serenity", "love"];
            intensity = valence * 0.8;
          } else if (valence < 0.4 && energy >= 0.6) {
            primary = characteristics.mode === 0 ? "anger" : "fear";
            secondary = ["anger", "fear"];
            intensity = energy;
          } else if (valence < 0.4 && energy < 0.4) {
            primary = characteristics.acousticness > 0.5 ? "melancholy" : "sadness";
            secondary = ["sadness", "melancholy"];
            intensity = (1 - valence) * 0.8;
          } else {
            if (characteristics.instrumentalness > 0.8) {
              primary = "transcendence";
              secondary = ["transcendence", "consciousness"];
            } else {
              primary = "nostalgia";
              secondary = ["nostalgia"];
            }
            intensity = Math.abs(valence - 0.5) + Math.abs(energy - 0.5);
            confidence = 0.6;
          }
          if (characteristics.organicFlow > 0.8) {
            secondary.push("organic-flow");
          }
          if (characteristics.consciousnessResonance > 0.7) {
            secondary.push("consciousness");
          }
          return { primary, secondary, intensity, confidence };
        }
      };
      __name(_ValenceEnergyMapper, "ValenceEnergyMapper");
      ValenceEnergyMapper = _ValenceEnergyMapper;
      _AudioFeatureAnalyzer = class _AudioFeatureAnalyzer {
        async initialize() {
        }
        extractCharacteristics(audioFeatures) {
          return {
            tempo: audioFeatures.tempo,
            key: audioFeatures.key,
            mode: audioFeatures.mode,
            timeSignature: audioFeatures.timeSignature,
            energy: audioFeatures.energy,
            danceability: audioFeatures.danceability,
            acousticness: audioFeatures.acousticness,
            instrumentalness: audioFeatures.instrumentalness,
            liveness: audioFeatures.liveness,
            speechiness: audioFeatures.speechiness,
            // Calculate consciousness-specific metrics
            organicFlow: this.calculateOrganicFlow(audioFeatures),
            cinematicDepth: this.calculateCinematicDepth(audioFeatures),
            consciousnessResonance: this.calculateConsciousnessResonance(audioFeatures)
          };
        }
        calculateOrganicFlow(features) {
          const acousticWeight = features.acousticness * 0.4;
          const tempoWeight = (1 - Math.min(features.tempo / 140, 1)) * 0.3;
          const energyWeight = (1 - features.energy) * 0.2;
          const danceWeight = features.danceability * 0.1;
          return Math.min(
            acousticWeight + tempoWeight + energyWeight + danceWeight,
            1
          );
        }
        calculateCinematicDepth(features) {
          const instrumentalWeight = features.instrumentalness * 0.4;
          const liveWeight = (1 - features.liveness) * 0.2;
          const speechWeight = (1 - features.speechiness) * 0.2;
          const energyWeight = Math.abs(features.energy - 0.5) * 0.2;
          return Math.min(
            instrumentalWeight + liveWeight + speechWeight + energyWeight,
            1
          );
        }
        calculateConsciousnessResonance(features) {
          const valenceBalance = 1 - Math.abs(features.valence - 0.5) * 2;
          const energyBalance = 1 - Math.abs(features.energy - 0.4) * 2;
          const instrumentalWeight = features.instrumentalness * 0.3;
          const acousticWeight = features.acousticness * 0.2;
          return Math.max(
            0,
            (valenceBalance + energyBalance) * 0.5 + instrumentalWeight + acousticWeight
          );
        }
      };
      __name(_AudioFeatureAnalyzer, "AudioFeatureAnalyzer");
      AudioFeatureAnalyzer = _AudioFeatureAnalyzer;
      _TemperatureCalculator = class _TemperatureCalculator {
        async initialize() {
        }
        calculateTemperature(emotion, characteristics) {
          let baseTemperature;
          switch (emotion.primary) {
            case "joy":
            case "excitement":
              baseTemperature = 8e3;
              break;
            case "love":
            case "serenity":
              baseTemperature = 3e3;
              break;
            case "anger":
              baseTemperature = 15e3;
              break;
            case "fear":
              baseTemperature = 12e3;
              break;
            case "sadness":
            case "melancholy":
              baseTemperature = 2e3;
              break;
            case "nostalgia":
              baseTemperature = 2500;
              break;
            case "transcendence":
            case "consciousness":
              baseTemperature = 6500;
              break;
            case "organic-flow":
              baseTemperature = 4e3;
              break;
            default:
              baseTemperature = 6500;
          }
          const intensityAdjustment = (emotion.intensity - 0.5) * 2e3;
          const tempoAdjustment = (characteristics.tempo - 120) * 10;
          const energyAdjustment = (characteristics.energy - 0.5) * 1e3;
          const finalTemperature = baseTemperature + intensityAdjustment + tempoAdjustment + energyAdjustment;
          return Math.max(1e3, Math.min(2e4, finalTemperature));
        }
      };
      __name(_TemperatureCalculator, "TemperatureCalculator");
      TemperatureCalculator = _TemperatureCalculator;
      _ConsciousnessDetector = class _ConsciousnessDetector {
        async initialize() {
        }
        async analyze(audioFeatures, characteristics, audioData) {
          let organicFlow = characteristics.organicFlow;
          let cinematicDepth = characteristics.cinematicDepth;
          let consciousnessResonance = characteristics.consciousnessResonance;
          if (audioData?.waveform) {
            const waveformAnalysis = this.analyzeWaveformPatterns(audioData.waveform);
            organicFlow = Math.min(
              1,
              organicFlow + waveformAnalysis.smoothness * 0.2
            );
            cinematicDepth = Math.min(
              1,
              cinematicDepth + waveformAnalysis.dynamicRange * 0.3
            );
            consciousnessResonance = Math.min(
              1,
              consciousnessResonance + waveformAnalysis.harmonicComplexity * 0.2
            );
          }
          return {
            organicFlow,
            cinematicDepth,
            consciousnessResonance
          };
        }
        analyzeWaveformPatterns(waveform) {
          let smoothness = 0;
          let dynamicRange = 0;
          let harmonicComplexity = 0;
          if (waveform.length > 1) {
            let totalVariation = 0;
            for (let i = 1; i < waveform.length; i++) {
              const current = waveform[i];
              const previous = waveform[i - 1];
              if (current !== void 0 && previous !== void 0) {
                totalVariation += Math.abs(current - previous);
              }
            }
            smoothness = 1 - Math.min(totalVariation / waveform.length, 1);
            const max = Math.max(...waveform);
            const min = Math.min(...waveform);
            dynamicRange = max - min;
            harmonicComplexity = Math.min(this.estimateHarmonicContent(waveform), 1);
          }
          return { smoothness, dynamicRange, harmonicComplexity };
        }
        estimateHarmonicContent(waveform) {
          let zeroCrossings = 0;
          for (let i = 1; i < waveform.length; i++) {
            const current = waveform[i];
            const previous = waveform[i - 1];
            if (current !== void 0 && previous !== void 0) {
              if (current >= 0 !== previous >= 0) {
                zeroCrossings++;
              }
            }
          }
          return Math.min(zeroCrossings / (waveform.length * 0.1), 1);
        }
      };
      __name(_ConsciousnessDetector, "ConsciousnessDetector");
      ConsciousnessDetector = _ConsciousnessDetector;
    }
  });

  // src-js/audio/ColorHarmonyEngine.ts
  var _ColorHarmonyEngine, ColorHarmonyEngine;
  var init_ColorHarmonyEngine = __esm({
    "src-js/audio/ColorHarmonyEngine.ts"() {
      "use strict";
      init_settingKeys();
      init_GenreGradientEvolution();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      init_PaletteSystemManager();
      init_PaletteExtensionManager();
      init_Year3000Utilities();
      init_SemanticColorManager();
      init_BaseVisualSystem();
      init_ColorOrchestrator();
      init_MusicEmotionAnalyzer();
      _ColorHarmonyEngine = class _ColorHarmonyEngine extends BaseVisualSystem {
        constructor(config, utils, performanceMonitor, settingsManager2) {
          super(
            config,
            utils || Year3000Utilities_exports,
            performanceMonitor,
            null,
            // No direct music service dependency
            settingsManager2 || null
          );
          this.emergentEngine = null;
          // User-specified harmonic intensity (0-1). Multiplies defaultBlendRatio.
          this.userIntensity = 0.7;
          this.evolutionEnabled = true;
          this._evolutionTimer = null;
          // Timer ref for debounce
          this._pendingPaletteRefresh = null;
          // Track last applied genre to avoid redundant palette refreshes
          this._lastGenre = null;
          this.systemName = "ColorHarmonyEngine";
          this.paletteExtensionManager = new PaletteExtensionManager(
            this.config,
            this.utils
          );
          this.semanticColorManager = new SemanticColorManager({
            enableDebug: this.config.enableDebug,
            fallbackToSpiceColors: true,
            cacheDuration: 5e3
          });
          this.currentTheme = this.detectCurrentTheme();
          if (config && typeof config.harmonicIntensity === "number" && Number.isFinite(config.harmonicIntensity)) {
            const clamped = Math.max(
              0,
              Math.min(1, config.harmonicIntensity)
            );
            this.userIntensity = clamped;
          }
          this.harmonyMetrics = {
            totalHarmonyCalculations: 0,
            musicInfluencedAdjustments: 0,
            temporalMemoryEvents: 0,
            performance: []
          };
          this.musicalMemory = {
            recentTracks: [],
            userColorPreferences: /* @__PURE__ */ new Map(),
            energyHistory: [],
            maxMemorySize: 50
          };
          this.kineticState = {
            currentPulse: 0,
            breathingPhase: 0,
            lastBeatTime: 0,
            visualMomentum: 0
          };
          this.catppuccinPalettes = {
            frappe: {
              accents: {
                rosewater: "#f2d5cf",
                flamingo: "#eebebe",
                pink: "#ff6b9d",
                // Enhanced magenta for gradient drama
                mauve: "#c77dff",
                // Intensified purple for depth
                red: "#ff4757",
                // Vivid red for cinematic contrast
                maroon: "#ea999c",
                peach: "#ff7675",
                // Warmer orange for gradient flows
                yellow: "#fdcb6e",
                // Golden yellow for luminance
                green: "#6c5ce7",
                // Purple-blue for unique gradients
                teal: "#00cec9",
                // Cyan for electric contrast
                sky: "#74b9ff",
                // Bright blue for sky gradients
                sapphire: "#0984e3",
                // Deep blue for depth
                blue: "#a29bfe",
                // Lavender-blue for softness
                lavender: "#fd79a8"
                // Pink-lavender for warmth
              },
              neutrals: {
                base: "#303446",
                surface0: "#414559",
                surface1: "#51576d",
                surface2: "#626880"
              }
            },
            latte: {
              accents: {
                rosewater: "#dc8a78",
                flamingo: "#dd7878",
                pink: "#e84393",
                // Vibrant magenta for light theme gradients
                mauve: "#a55eea",
                // Rich purple for contrast
                red: "#fd79a8",
                // Warm red-pink for luminous gradients
                maroon: "#e64553",
                peach: "#fd7f28",
                // Bright orange for warmth
                yellow: "#f39c12",
                // Golden amber for energy
                green: "#00b894",
                // Teal-green for balance
                teal: "#00cec9",
                // Cyan for freshness
                sky: "#0984e3",
                // Deep sky blue
                sapphire: "#6c5ce7",
                // Purple-blue for depth
                blue: "#74b9ff",
                // Light blue for airiness
                lavender: "#a29bfe"
                // Soft lavender for gentleness
              },
              neutrals: {
                base: "#eff1f5",
                surface0: "#e6e9ef",
                surface1: "#dce0e8",
                surface2: "#c5c9d1"
              }
            },
            macchiato: {
              accents: {
                rosewater: "#f4dbd6",
                flamingo: "#f0c6c6",
                pink: "#ff6b9d",
                // Enhanced magenta for gradient drama
                mauve: "#c77dff",
                // Intensified purple for depth
                red: "#ff4757",
                // Vivid red for cinematic contrast
                maroon: "#ee99a0",
                peach: "#ff7675",
                // Warmer orange for gradient flows
                yellow: "#fdcb6e",
                // Golden yellow for luminance
                green: "#6c5ce7",
                // Purple-blue for unique gradients
                teal: "#00cec9",
                // Cyan for electric contrast
                sky: "#74b9ff",
                // Bright blue for sky gradients
                sapphire: "#0984e3",
                // Deep blue for depth
                blue: "#a29bfe",
                // Lavender-blue for softness
                lavender: "#fd79a8"
                // Pink-lavender for warmth
              },
              neutrals: {
                base: "#24273a",
                surface0: "#363a4f",
                surface1: "#494d64",
                surface2: "#5b6078"
              }
            },
            mocha: {
              accents: {
                rosewater: "#f5e0dc",
                flamingo: "#f2cdcd",
                pink: "#ff6b9d",
                // Enhanced magenta for gradient drama
                mauve: "#c77dff",
                // Intensified purple for depth
                red: "#ff4757",
                // Vivid red for cinematic contrast
                maroon: "#eba0ac",
                peach: "#ff7675",
                // Warmer orange for gradient flows
                yellow: "#fdcb6e",
                // Golden yellow for luminance
                green: "#6c5ce7",
                // Purple-blue for unique gradients
                teal: "#00cec9",
                // Cyan for electric contrast
                sky: "#74b9ff",
                // Bright blue for sky gradients
                sapphire: "#0984e3",
                // Deep blue for depth
                blue: "#a29bfe",
                // Lavender-blue for softness
                lavender: "#fd79a8"
                // Pink-lavender for warmth
              },
              neutrals: {
                base: "#1e1e2e",
                surface0: "#313244",
                surface1: "#45475a",
                surface2: "#585b70"
              }
            }
          };
          this.vibrancyConfig = {
            defaultBlendRatio: 0.75,
            // Dramatic extracted color dominance for cinematic gradients
            minimumSaturation: 0.6,
            // High saturation for vibrant gradient aesthetics
            maximumDesaturation: 0.1,
            // Minimal desaturation to maintain intensity
            contrastBoostIntensity: 1.4,
            // Enhanced contrast for dramatic depth
            harmonyTolerance: 0.3,
            // Tighter harmony for cohesive gradient flows
            //  Cinematic Gradient Enhancement Factors
            artisticSaturationBoost: 1.35,
            // Strong saturation for vibrant gradient aesthetics
            cosmicLuminanceBoost: 1.25,
            // Enhanced luminance for gradient depth
            energyResponsiveness: 0.8,
            // High energy responsiveness for dynamic gradients
            //  Cinematic Gradient Blending Based on Artistic Mode
            getBlendRatio(artisticMode = "artist-vision") {
              const ratios = {
                "corporate-safe": 0.6,
                // Moderate: 60% extracted for professional gradients
                "artist-vision": 0.75,
                // Cinematic: 75% extracted for balanced drama
                "cosmic-maximum": 0.85
                // Maximum: 85% extracted for full intensity!
              };
              return ratios[artisticMode] || this.defaultBlendRatio;
            }
          };
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Initialized with Year 3000 Quantum Empathy"
            );
          }
          if (config && typeof config.harmonicEvolution === "boolean") {
            this.evolutionEnabled = config.harmonicEvolution;
          }
          this.emotionalTemperatureMapper = new EmotionalTemperatureMapper(
            this.config.enableDebug
          );
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.musicEmotionAnalyzer = new MusicEmotionAnalyzer({
            emotionSensitivity: 0.7,
            confidenceThreshold: 0.6,
            consciousnessAwareness: true,
            organicFlowDetection: true,
            cinematicAnalysis: true,
            analysisInterval: 500
            // 2Hz analysis rate
          });
          this.genreGradientEvolution = new GenreGradientEvolution(
            void 0,
            // cssConsciousnessController will be set during initialize()
            null,
            // musicSyncService will be injected if available
            null,
            // emotionalGradientMapper will be injected if available
            this.settingsManager
          );
          this.oklabState = {
            currentPreset: OKLABColorProcessor.PRESETS.STANDARD,
            processedPalette: {},
            perceptualGradientCache: /* @__PURE__ */ new Map(),
            colorHarmonyCache: /* @__PURE__ */ new Map(),
            lastProcessingTime: 0
          };
          this.emotionalState = {
            currentEmotion: null,
            emotionHistory: [],
            lastEmotionUpdate: 0,
            emotionInfluenceIntensity: 0.8
            // Strong emotion influence by default
          };
          this.genreState = {
            currentGenre: "unknown",
            genreConfidence: 0,
            genreHistory: [],
            lastGenreUpdate: 0,
            genreInfluenceIntensity: 0.7
            // Moderate genre influence by default
          };
          this._boundSettingsChangeHandler = this._handleSettingsChange.bind(this);
          this._boundArtisticModeHandler = this._handleArtisticModeChanged.bind(this);
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this._boundSettingsChangeHandler
          );
          document.addEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          if (this.evolutionEnabled) {
            this._startEvolutionLoop();
          }
        }
        /**
         * Get current active palette from PaletteSystemManager
         * Falls back to hardcoded catppuccinPalettes for compatibility
         */
        getCurrentActivePalette() {
          try {
            const paletteSystem = paletteSystemManager.getCurrentPaletteSystem();
            if (paletteSystem === "year3000") {
              const year3000Palette = paletteSystemManager.getCurrentPalette();
              const currentFlavor = paletteSystemManager.getCurrentDefaultFlavor();
              const activePalette = year3000Palette[currentFlavor];
              if (!activePalette) {
                throw new Error(`No palette found for flavor: ${currentFlavor}`);
              }
              const accents = {};
              const neutrals = {};
              Object.entries(activePalette).forEach(([key, color3]) => {
                if (["base", "surface0", "surface1", "surface2", "mantle", "crust"].includes(key)) {
                  neutrals[key] = color3.hex;
                } else {
                  accents[key] = color3.hex;
                }
              });
              return { accents, neutrals };
            } else {
              return this.catppuccinPalettes[this.currentTheme];
            }
          } catch (error) {
            console.warn("[ColorHarmonyEngine] Failed to get active palette, using fallback:", error);
            return this.catppuccinPalettes[this.currentTheme];
          }
        }
        // Unified implementation
        updateAnimation(timestampOrDelta, maybeDelta) {
          const delta = maybeDelta ?? timestampOrDelta;
          this.onAnimate(delta);
        }
        // TODO: Implement proper onAnimate method for Year 3000 per-frame updates
        onAnimate(deltaMs) {
          this._updateCSSVariables(deltaMs);
          this._calculateBeatPulse(deltaMs);
          unifiedEventBus.emitSync("performance:frame", {
            deltaTime: deltaMs,
            fps: 60,
            memoryUsage: performance.memory?.usedJSHeapSize || 0,
            timestamp: performance.now()
          });
        }
        //  PHASE 2: Emit harmony state instead of applying CSS directly
        _updateCSSVariables(deltaMs) {
          const harmonyVariables = {
            "--sn-harmony-energy": this.kineticState.visualMomentum.toFixed(3),
            "--sn-harmony-pulse": this.kineticState.currentPulse.toFixed(3),
            "--sn-harmony-breathing-phase": (Math.sin(this.kineticState.breathingPhase) * 0.5 + 0.5).toFixed(3)
          };
          if (this.kineticState.musicIntensityMultiplier !== void 0) {
            harmonyVariables["--sn-harmony-intensity"] = this.kineticState.musicIntensityMultiplier.toFixed(3);
          }
          if (this.kineticState.valenceGravity !== void 0) {
            harmonyVariables["--sn-harmony-valence"] = this.kineticState.valenceGravity.toFixed(3);
          }
          if (this.kineticState.beatPhase !== void 0) {
            harmonyVariables["--sn-harmony-beat-phase"] = this.kineticState.beatPhase.toFixed(3);
          }
          if (this.kineticState.hueShift !== void 0) {
            harmonyVariables["--sn-harmony-hue-shift"] = `${this.kineticState.hueShift.toFixed(1)}deg`;
          }
          const glow = Math.max(0, Math.min(1, this.kineticState.currentPulse * 1.2));
          harmonyVariables["--sn-text-glow-intensity"] = glow.toFixed(3);
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: harmonyVariables,
            timestamp: Date.now()
          });
        }
        // TODO: Private method for calculating beat pulse effects
        _calculateBeatPulse(deltaMs) {
          this.kineticState.currentPulse *= Math.pow(0.95, deltaMs / 16.67);
          this.kineticState.breathingPhase += deltaMs / 1e3 * 0.5;
          if (this.kineticState.breathingPhase > 2 * Math.PI) {
            this.kineticState.breathingPhase -= 2 * Math.PI;
          }
          this._emitGradientBreathingEvents(deltaMs);
        }
        /**
         * Emit gradient breathing events for dimensional consciousness integration
         */
        _emitGradientBreathingEvents(deltaMs) {
          const currentEnergy = this._calculateCurrentEnergyLevel();
          const beatDetected = this._detectBeatFromAudioAnalysis();
          if (Math.random() < 0.1) {
            unifiedEventBus.emit("music:energy", {
              energy: currentEnergy.energy,
              valence: currentEnergy.valence,
              tempo: 120,
              timestamp: performance.now()
            });
          }
          if (beatDetected.detected) {
            unifiedEventBus.emit("music:beat", {
              intensity: beatDetected.intensity,
              confidence: beatDetected.confidence,
              timestamp: performance.now(),
              bpm: 120
              // Default BPM value
            });
          }
        }
        /**
         * Calculate current energy level from music analysis data
         */
        _calculateCurrentEnergyLevel() {
          const breathingEnergy = 0.5 + Math.sin(this.kineticState.breathingPhase) * 0.3;
          return {
            energy: Math.max(0.2, breathingEnergy),
            valence: 0.5 + this.kineticState.currentPulse * 0.3,
            arousal: 0.4 + this.kineticState.currentPulse * 0.4
          };
        }
        /**
         * Detect beats from current audio analysis for gradient breathing
         */
        _detectBeatFromAudioAnalysis() {
          const pulseThreshold = 0.3;
          const currentPulse = this.kineticState.currentPulse;
          if (currentPulse > pulseThreshold) {
            return {
              detected: true,
              intensity: Math.min(1, currentPulse * 1.5),
              confidence: Math.min(
                1,
                (currentPulse - pulseThreshold) / (1 - pulseThreshold)
              )
            };
          }
          const breathingBeat = Math.sin(this.kineticState.breathingPhase) > 0.8;
          if (breathingBeat) {
            return {
              detected: true,
              intensity: 0.4,
              confidence: 0.6
            };
          }
          return { detected: false, intensity: 0, confidence: 0 };
        }
        async initialize() {
          await super.initialize();
          const cssConsciousnessController = this.performanceMonitor ? this.performanceMonitor.cssConsciousnessController : void 0;
          this.semanticColorManager.initialize(cssConsciousnessController);
          unifiedEventBus.subscribe(
            "colors:extracted",
            this.handleColorExtraction.bind(this),
            "ColorHarmonyEngine"
          );
          try {
            globalColorOrchestrator.registerStrategy(this);
            if (this.config.enableDebug) {
              console.log(
                "\u{1F3A8} [ColorHarmonyEngine] Registered with ColorOrchestrator as strategy processor."
              );
            }
          } catch (error) {
            console.warn(
              "\u{1F3A8} [ColorHarmonyEngine] Failed to register with ColorOrchestrator:",
              error
            );
          }
          try {
            await this.musicEmotionAnalyzer.initialize();
            this.musicEmotionAnalyzer.onEmotionUpdate((emotion) => {
              this.handleEmotionUpdate(emotion);
            });
            if (this.config.enableDebug) {
              console.log(
                "\u{1F3AD} [ColorHarmonyEngine] MusicEmotionAnalyzer initialized with consciousness awareness"
              );
            }
          } catch (error) {
            console.warn(
              "\u{1F3AD} [ColorHarmonyEngine] Failed to initialize MusicEmotionAnalyzer:",
              error
            );
          }
          try {
            await this.genreGradientEvolution.initialize();
            if (this.config.enableDebug) {
              console.log(
                "\u{1F3B6} [ColorHarmonyEngine] GenreGradientEvolution initialized with aesthetic intelligence"
              );
            }
          } catch (error) {
            console.warn(
              "\u{1F3B6} [ColorHarmonyEngine] Failed to initialize GenreGradientEvolution:",
              error
            );
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Initialized with Year 3000 Quantum Empathy via BaseVisualSystem and SemanticColorManager."
            );
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Subscribed to 'colors/extracted' events for strategy pattern processing."
            );
          }
          this.initialized = true;
        }
        /**
         * Handle emotion updates from MusicEmotionAnalyzer
         * Updates emotional state and triggers consciousness-aware color processing
         */
        handleEmotionUpdate(emotion) {
          if (!this.initialized) return;
          try {
            this.emotionalState.currentEmotion = emotion;
            this.emotionalState.emotionHistory.push(emotion);
            this.emotionalState.lastEmotionUpdate = Date.now();
            if (this.emotionalState.emotionHistory.length > 50) {
              this.emotionalState.emotionHistory = this.emotionalState.emotionHistory.slice(-25);
            }
            unifiedEventBus.emit("emotion:analyzed", {
              emotion,
              colorTemperature: emotion.colorTemperature,
              consciousnessLevel: emotion.musicalCharacteristics.consciousnessResonance,
              organicFlow: emotion.musicalCharacteristics.organicFlow,
              cinematicDepth: emotion.musicalCharacteristics.cinematicDepth,
              timestamp: emotion.timestamp
            });
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3AD} [ColorHarmonyEngine] Emotion updated: ${emotion.primary} (intensity: ${emotion.intensity.toFixed(
                  2
                )}, confidence: ${emotion.confidence.toFixed(2)})`
              );
            }
            this.triggerEmotionalColorUpdate(emotion);
          } catch (error) {
            console.error(
              "\u{1F3AD} [ColorHarmonyEngine] Error handling emotion update:",
              error
            );
          }
        }
        /**
         * Trigger color update based on emotional state
         */
        triggerEmotionalColorUpdate(emotion) {
          if (this.emotionalState.emotionInfluenceIntensity > 0 && emotion.confidence > 0.6) {
            if (this._pendingPaletteRefresh) {
              clearTimeout(this._pendingPaletteRefresh);
            }
            this._pendingPaletteRefresh = setTimeout(() => {
              this.refreshPaletteWithEmotion(emotion);
              this._pendingPaletteRefresh = null;
            }, 100);
          }
        }
        /**
         * Refresh palette with emotional influence
         */
        async refreshPaletteWithEmotion(emotion) {
          try {
            const emotionalContext = {
              primaryEmotion: emotion.primary,
              emotionIntensity: emotion.intensity,
              colorTemperature: emotion.colorTemperature,
              valence: emotion.valence,
              arousal: emotion.arousal,
              dominance: emotion.dominance,
              organicFlow: emotion.musicalCharacteristics.organicFlow,
              cinematicDepth: emotion.musicalCharacteristics.cinematicDepth,
              consciousnessResonance: emotion.musicalCharacteristics.consciousnessResonance
            };
            unifiedEventBus.emit("emotionalColorContext:updated", emotionalContext);
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3AD} [ColorHarmonyEngine] Refreshing colors with ${emotion.primary} emotion influence`
              );
            }
          } catch (error) {
            console.error(
              "\u{1F3AD} [ColorHarmonyEngine] Error refreshing palette with emotion:",
              error
            );
          }
        }
        async healthCheck() {
          if (!this.getCurrentActivePalette()) {
            return {
              healthy: false,
              ok: false,
              details: `Current theme '${this.currentTheme}' not found in palettes.`,
              issues: [`Current theme '${this.currentTheme}' not found in palettes.`],
              system: "ColorHarmonyEngine"
            };
          }
          return {
            healthy: true,
            ok: true,
            details: "Palettes are loaded correctly.",
            issues: [],
            system: "ColorHarmonyEngine"
          };
        }
        // ============================================================================
        // IColorProcessor Strategy Pattern Implementation
        // ============================================================================
        /**
         * Process colors according to Catppuccin harmony strategy with enhanced OKLAB integration
         * Implements the Strategy pattern for color processing with comprehensive system utilization
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const { rawColors, trackUri, musicData } = context;
            const optimalPreset = this.determineOptimalOKLABPreset(context);
            this.oklabState.currentPreset = optimalPreset;
            const genreData = await this.analyzeGenreAesthetics(musicData, rawColors);
            const emotionalTemperature = await this.getAdvancedEmotionalTemperature(
              musicData,
              rawColors
            );
            const processedColors = await this.blendWithAdvancedOKLAB(
              rawColors,
              musicData,
              emotionalTemperature,
              genreData || void 0
            );
            const accentHex = processedColors["VIBRANT"] || processedColors["PROMINENT"] || Object.values(processedColors)[0] || "#a6adc8";
            const rgb = this.utils.hexToRgb(accentHex);
            const accentRgb = rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "166,173,200";
            try {
              const harmonizedEventData = {
                processedColors,
                accentHex,
                accentRgb,
                originalColors: rawColors,
                trackUri,
                musicData,
                timestamp: Date.now(),
                strategies: ["ColorHarmonyEngine"],
                processingTime: performance.now() - startTime,
                coordinationMetrics: {
                  detectedGenre: genreData?.genre || "unknown",
                  genreConfidence: genreData?.confidence || 0,
                  emotionalState: this.emotionalState.currentEmotion?.primary || "neutral",
                  oklabPreset: optimalPreset?.name || "standard",
                  coordinationStrategy: "genre-emotion-color-unified",
                  musicInfluenceStrength: this.genreState.genreInfluenceIntensity
                }
              };
              unifiedEventBus.emitSync("colors:harmonized", harmonizedEventData);
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F3A8} [ColorHarmonyEngine] Emitted colors:harmonized via UnifiedEventBus (facade pattern):",
                  {
                    processedColors: Object.keys(processedColors),
                    accentHex,
                    noDomEvents: "correct architecture"
                  }
                );
              }
            } catch (eventError) {
              if (this.config.enableDebug) {
                console.warn(
                  "[ColorHarmonyEngine] Failed to emit colors:harmonized event:",
                  eventError
                );
              }
            }
            const processingTime = performance.now() - startTime;
            this.harmonyMetrics.totalHarmonyCalculations++;
            this.harmonyMetrics.performance.push(processingTime);
            const result = {
              processedColors,
              accentHex,
              accentRgb,
              metadata: {
                strategy: "CatppuccinHarmony",
                processingTime,
                cacheKey: `catppuccin-${trackUri}-${this.currentTheme}`,
                harmonicIntensity: this.userIntensity
              },
              context
            };
            const cssVariables = this.generateAdvancedOKLABCSSVariables(result);
            this.applyCSSVariablesToDOM(cssVariables);
            this.generatePerceptualGradientData(result);
            this.updateAdvancedHarmonyMetrics(result, processingTime);
            unifiedEventBus.emitSync("colors:harmonized", {
              processedColors: result.processedColors,
              accentHex: result.accentHex,
              accentRgb: result.accentRgb,
              strategies: result.metadata?.strategy ? [result.metadata.strategy] : ["ColorHarmonyEngine"],
              processingTime,
              trackUri: result.context.trackUri
            });
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3A8} [ColorHarmonyEngine] Processed colors via strategy pattern in ${processingTime.toFixed(
                  2
                )}ms`,
                {
                  accentHex,
                  strategy: "CatppuccinHarmony",
                  cssVariablesCount: Object.keys(cssVariables).length
                }
              );
            }
            return result;
          } catch (error) {
            console.error("[ColorHarmonyEngine] Strategy processing failed:", error);
            return {
              processedColors: { VIBRANT: "#a6adc8" },
              accentHex: "#a6adc8",
              accentRgb: "166,173,200",
              metadata: {
                strategy: "CatppuccinHarmony",
                processingTime: performance.now() - startTime,
                error: String(error)
              },
              context
            };
          }
        }
        /**
         * Get strategy name for identification
         */
        getStrategyName() {
          return "CatppuccinHarmony";
        }
        /**
         * Check if this strategy can process the given context
         */
        canProcess(context) {
          return context && context.rawColors && Object.keys(context.rawColors).length > 0;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          const baseTime = 5;
          const colorCount = Object.keys(context.rawColors || {}).length;
          const complexityFactor = Math.max(1, colorCount / 5);
          return baseTime * complexityFactor;
        }
        /**
         * Handle color extraction events from unifiedEventBus
         * Event-driven entry point for strategy pattern
         */
        async handleColorExtraction(data) {
          try {
            if (!this.initialized) {
              if (this.config.enableDebug) {
                console.warn(
                  "[ColorHarmonyEngine] Received color extraction event but not initialized"
                );
              }
              return;
            }
            const context = {
              rawColors: data.rawColors,
              trackUri: data.trackUri,
              timestamp: data.timestamp,
              harmonicMode: this.currentTheme,
              musicData: data.musicData,
              performanceHints: {
                preferLightweight: false,
                enableAdvancedBlending: true,
                maxProcessingTime: 100
              }
            };
            if (this.canProcess(context)) {
              await this.processColors(context);
            } else {
              if (this.config.enableDebug) {
                console.warn(
                  "[ColorHarmonyEngine] Cannot process color context:",
                  context
                );
              }
            }
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Error handling color extraction event:",
              error
            );
          }
        }
        /**
         * Generate CSS variables from color result
         */
        generateCSSVariables(result) {
          const cssVars = {};
          cssVars["--sn-accent-hex"] = result.accentHex;
          cssVars["--sn-accent-rgb"] = result.accentRgb;
          cssVars[_ColorHarmonyEngine.CANONICAL_HEX_VAR] = result.accentHex;
          cssVars[_ColorHarmonyEngine.CANONICAL_RGB_VAR] = result.accentRgb;
          const processedColors = result.processedColors;
          const primaryColor = processedColors["VIBRANT"] || processedColors["PROMINENT"] || result.accentHex;
          const secondaryColor = processedColors["DARK_VIBRANT"] || processedColors["DESATURATED"] || primaryColor;
          const accentColor = processedColors["VIBRANT_NON_ALARMING"] || processedColors["LIGHT_VIBRANT"] || primaryColor;
          cssVars["--sn-bg-gradient-primary"] = primaryColor;
          cssVars["--sn-bg-gradient-secondary"] = secondaryColor;
          cssVars["--sn-bg-gradient-accent"] = accentColor;
          const primaryRgb = this.utils.hexToRgb(primaryColor);
          const secondaryRgb = this.utils.hexToRgb(secondaryColor);
          const accentRgb = this.utils.hexToRgb(accentColor);
          if (primaryRgb) {
            cssVars["--sn-bg-gradient-primary-rgb"] = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          }
          if (secondaryRgb) {
            cssVars["--sn-bg-gradient-secondary-rgb"] = `${secondaryRgb.r},${secondaryRgb.g},${secondaryRgb.b}`;
          }
          if (accentRgb) {
            cssVars["--sn-bg-gradient-accent-rgb"] = `${accentRgb.r},${accentRgb.g},${accentRgb.b}`;
          }
          this.generateOKLABVariables(cssVars, result);
          if (this.config.enableDebug) {
            console.log(
              "\u{1F527} [ColorHarmonyEngine] Generated background gradient CSS variables:",
              {
                primary: `${primaryColor} -> ${cssVars["--sn-bg-gradient-primary-rgb"]}`,
                secondary: `${secondaryColor} -> ${cssVars["--sn-bg-gradient-secondary-rgb"]}`,
                accent: `${accentColor} -> ${cssVars["--sn-bg-gradient-accent-rgb"]}`,
                totalVariables: Object.keys(cssVars).length,
                note: "CSS mapping automatically updates --sn-gradient-* variables"
              }
            );
          }
          return cssVars;
        }
        /**
         * Generate OKLAB-processed CSS variables for perceptual color processing
         */
        generateOKLABVariables(cssVars, result) {
          try {
            const primaryHex = result.accentHex;
            const processedColors = result.processedColors;
            const secondaryHex = processedColors["DARK_VIBRANT"] || processedColors["DESATURATED"] || primaryHex;
            const primaryRgb = this.utils.hexToRgb(primaryHex);
            const secondaryRgb = this.utils.hexToRgb(secondaryHex);
            if (primaryRgb) {
              const oklabPrimary = this.utils.rgbToOklab(
                primaryRgb.r,
                primaryRgb.g,
                primaryRgb.b
              );
              const enhancedOklab = {
                L: Math.min(1, oklabPrimary.L * 1.1),
                // Slight lightness boost
                a: oklabPrimary.a * 1.15,
                // Enhanced chroma for vibrancy
                b: oklabPrimary.b * 1.15
              };
              const enhancedRgb = this.utils.oklabToRgb(
                enhancedOklab.L,
                enhancedOklab.a,
                enhancedOklab.b
              );
              cssVars["--sn-color-oklab-bright-highlight-rgb"] = `${enhancedRgb.r},${enhancedRgb.g},${enhancedRgb.b}`;
              cssVars["--sn-color-oklab-primary-r"] = Math.round(
                enhancedRgb.r
              ).toString();
              cssVars["--sn-color-oklab-primary-g"] = Math.round(
                enhancedRgb.g
              ).toString();
              cssVars["--sn-color-oklab-primary-b"] = Math.round(
                enhancedRgb.b
              ).toString();
              cssVars["--sn-color-oklab-accent-r"] = Math.round(
                enhancedRgb.r
              ).toString();
              cssVars["--sn-color-oklab-accent-g"] = Math.round(
                enhancedRgb.g
              ).toString();
              cssVars["--sn-color-oklab-accent-b"] = Math.round(
                enhancedRgb.b
              ).toString();
              cssVars["--sn-color-oklab-accent-luminance"] = enhancedOklab.L.toFixed(3);
              const oklch = this.convertOklabToOklch(enhancedOklab);
              cssVars["--sn-color-oklch-accent-l"] = oklch.L.toFixed(3);
              cssVars["--sn-color-oklch-accent-c"] = oklch.C.toFixed(3);
              cssVars["--sn-color-oklch-accent-h"] = oklch.H.toFixed(1);
              cssVars["--sn-color-oklch-primary-l"] = oklch.L.toFixed(3);
              cssVars["--sn-color-oklch-primary-c"] = oklch.C.toFixed(3);
              cssVars["--sn-color-oklch-primary-h"] = oklch.H.toFixed(1);
            }
            if (secondaryRgb) {
              const oklabSecondary = this.utils.rgbToOklab(
                secondaryRgb.r,
                secondaryRgb.g,
                secondaryRgb.b
              );
              const shadowOklab = {
                L: Math.max(0.05, oklabSecondary.L * 0.3),
                // Much darker for shadow
                a: oklabSecondary.a * 0.8,
                // Slightly desaturated
                b: oklabSecondary.b * 0.8
              };
              const shadowRgb = this.utils.oklabToRgb(
                shadowOklab.L,
                shadowOklab.a,
                shadowOklab.b
              );
              cssVars["--sn-color-oklab-dynamic-shadow-rgb"] = `${shadowRgb.r},${shadowRgb.g},${shadowRgb.b}`;
              cssVars["--sn-color-oklab-base-luminance"] = shadowOklab.L.toFixed(3);
            }
            if (this.config.enableDebug) {
              console.log(
                "\u{1F52C} [ColorHarmonyEngine] Generated OKLAB-processed variables:",
                {
                  primaryColor: primaryHex,
                  secondaryColor: secondaryHex,
                  oklabVariablesCount: Object.keys(cssVars).filter(
                    (k) => k.includes("oklab")
                  ).length,
                  oklchVariablesCount: Object.keys(cssVars).filter(
                    (k) => k.includes("oklch")
                  ).length
                }
              );
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "\u{1F52C} [ColorHarmonyEngine] OKLAB processing failed, using fallbacks:",
                error
              );
            }
            const fallbackRgb = this.utils.hexToRgb(result.accentHex);
            if (fallbackRgb) {
              cssVars["--sn-color-oklab-bright-highlight-rgb"] = `${fallbackRgb.r},${fallbackRgb.g},${fallbackRgb.b}`;
              cssVars["--sn-color-oklab-dynamic-shadow-rgb"] = `${Math.round(
                fallbackRgb.r * 0.3
              )},${Math.round(fallbackRgb.g * 0.3)},${Math.round(
                fallbackRgb.b * 0.3
              )}`;
            }
          }
        }
        /**
         * Convert OKLAB to OKLCH (cylindrical representation)
         */
        convertOklabToOklch(oklab) {
          const L = oklab.L;
          const C = Math.sqrt(oklab.a * oklab.a + oklab.b * oklab.b);
          let H = Math.atan2(oklab.b, oklab.a) * (180 / Math.PI);
          if (H < 0) H += 360;
          return { L, C, H };
        }
        detectCurrentTheme() {
          const rootElement = this.utils.getRootStyle();
          if (!rootElement) {
            console.warn(
              "[ColorHarmonyEngine detectCurrentTheme] Root element not found. Defaulting to mocha."
            );
            return "mocha";
          }
          const computedRootStyle = getComputedStyle(rootElement);
          const baseColorHex = computedRootStyle.getPropertyValue("--spice-main").trim();
          const normalizedBaseColor = baseColorHex.startsWith("#") ? baseColorHex.substring(1).toUpperCase() : baseColorHex.toUpperCase();
          const themeMap = {
            "303446": "frappe",
            EFF1F5: "latte",
            "24273A": "macchiato",
            "1E1E2E": "mocha"
          };
          const knownTheme = themeMap[normalizedBaseColor];
          if (knownTheme) {
            if (this.config.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Detected Catppuccin theme: ${knownTheme}`
              );
            }
            return knownTheme;
          }
          if (this.config.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] Unknown theme detected (${normalizedBaseColor}), attempting to generate fallback`
            );
          }
          const fallbackThemeName = `custom-${normalizedBaseColor.toLowerCase()}`;
          try {
            const fallbackPalette = this.paletteExtensionManager.generateFallbackPalette(fallbackThemeName);
            if (this.config.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Generated fallback palette for theme: ${fallbackThemeName}`,
                fallbackPalette
              );
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[ColorHarmonyEngine] Failed to generate fallback palette:`,
                error
              );
            }
          }
          if (this.config.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] Falling back to mocha theme for unknown base color: ${normalizedBaseColor}`
            );
          }
          return "mocha";
        }
        // TODO: Phase 3 - New method to get genre-aware palette
        async _getGenreAwarePalette(genre) {
          const basePalette = this.getCurrentActivePalette();
          if (!genre || !basePalette) {
            return basePalette;
          }
          try {
            const customPalette = {
              name: this.currentTheme,
              version: "1.0.0",
              accents: basePalette.accents,
              neutrals: basePalette.neutrals,
              metadata: {
                author: "Catppuccin",
                description: `${this.currentTheme} flavor`,
                temperature: "neutral"
              }
            };
            const modifiedPalette = this.paletteExtensionManager.applyGenreAwareModifications(
              customPalette,
              genre
            );
            return {
              accents: modifiedPalette.accents,
              neutrals: modifiedPalette.neutrals
            };
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[ColorHarmonyEngine] Failed to apply genre modifications for ${genre}:`,
                error
              );
            }
            return basePalette;
          }
        }
        getMusicIntensityMultiplier(energy = 0.5, valence = 0.5) {
          const baseMultiplier = this.config.getCurrentMultipliers().musicEnergyBoost;
          const energyBoost = energy > 0.7 ? 1.3 : energy > 0.4 ? 1 : 0.8;
          const valenceBoost = valence > 0.6 ? 1.2 : valence < 0.4 ? 0.9 : 1;
          return baseMultiplier * energyBoost * valenceBoost;
        }
        validateColorHarmony(color3, context = "general") {
          const startTime = performance.now();
          this.harmonyMetrics.totalHarmonyCalculations++;
          const contextRequirements = {
            general: {
              minContrast: 1.8,
              minHarmony: this.vibrancyConfig.harmonyTolerance
            },
            search: { minContrast: 2.8, minHarmony: 0.4 },
            navigation: { minContrast: 2.5, minHarmony: 0.45 },
            text: { minContrast: 4.5, minHarmony: 0.6 },
            accent: { minContrast: 1.5, minHarmony: 0.3 }
          };
          const requirements = contextRequirements[context] || contextRequirements["general"];
          const currentPalette = this.getCurrentActivePalette();
          if (!currentPalette?.neutrals?.base) {
            const errorMsg = `[StarryNight] Catppuccin palette or base neutral not found for theme: ${this.currentTheme}`;
            console.error(errorMsg);
            return {
              isValid: false,
              error: "Palette configuration error.",
              contrastRatio: 0,
              harmonyScore: 0,
              meetsContrast: false,
              isHarmonious: false,
              artisticMode: this.config.artisticMode,
              adjustedRequirements: requirements,
              recommendations: []
            };
          }
          const backgroundColor = currentPalette.neutrals.base;
          const colorHex = this.utils.rgbToHex(color3.r, color3.g, color3.b);
          const contrastRatio = this.utils.calculateContrastRatio(
            colorHex,
            backgroundColor
          );
          const harmonyScore = this.calculateHarmonyScore(color3, currentPalette);
          const currentMode = this.config.artisticMode;
          let adjustedRequirements = { ...requirements };
          if (currentMode === "cosmic-maximum") {
            adjustedRequirements.minContrast *= 0.7;
            adjustedRequirements.minHarmony *= 0.6;
          } else if (currentMode === "artist-vision") {
            adjustedRequirements.minContrast *= 0.85;
            adjustedRequirements.minHarmony *= 0.8;
          }
          const meetsContrast = contrastRatio >= adjustedRequirements.minContrast;
          const isHarmonious = harmonyScore >= adjustedRequirements.minHarmony;
          const endTime = performance.now();
          this.harmonyMetrics.performance.push(endTime - startTime);
          return {
            isValid: meetsContrast && isHarmonious,
            contrastRatio,
            harmonyScore,
            meetsContrast,
            isHarmonious,
            artisticMode: currentMode,
            adjustedRequirements,
            recommendations: this.generateRecommendations(
              color3,
              contrastRatio,
              harmonyScore,
              adjustedRequirements
            )
          };
        }
        calculateHarmonyScore(color3, palette) {
          const colorHsl = this.utils.rgbToHsl(color3.r, color3.g, color3.b);
          let maxHarmony = 0;
          const accentColors = Object.values(palette.accents);
          for (const accentColor of accentColors) {
            const accentRgb = this.utils.hexToRgb(accentColor);
            if (!accentRgb) continue;
            const accentHsl = this.utils.rgbToHsl(
              accentRgb.r,
              accentRgb.g,
              accentRgb.b
            );
            const hueDiff = Math.abs(colorHsl.h - accentHsl.h);
            const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);
            const harmoniousAngles = [
              0,
              30,
              60,
              90,
              120,
              150,
              180,
              210,
              240,
              270,
              300,
              330
            ];
            const isHarmonious = harmoniousAngles.some(
              (angle) => Math.abs(normalizedHueDiff - angle) < 20
            );
            if (isHarmonious) {
              const harmonyStrength = 1 - Math.min(
                ...harmoniousAngles.map(
                  (angle) => Math.abs(normalizedHueDiff - angle)
                )
              ) / 20;
              maxHarmony = Math.max(maxHarmony, harmonyStrength);
            }
          }
          return maxHarmony;
        }
        findBestHarmoniousAccent(rgb, palette) {
          let bestAccent = {
            name: "mauve",
            hex: this.utils.getRootStyle()?.style.getPropertyValue("--sn-dynamic-accent")?.trim() || this.utils.getRootStyle()?.style.getPropertyValue("--spice-accent")?.trim() || "#cba6f7",
            // Fallback to default mauve hex
            rgb: { r: 203, g: 166, b: 247 }
          };
          const accentPriority = [
            "mauve",
            "lavender",
            "blue",
            "sapphire",
            "sky",
            "pink",
            "peach",
            "teal"
          ];
          let bestScore = -1;
          const inputHsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
          for (const accentName of accentPriority) {
            const accentHex = palette.accents[accentName];
            if (accentHex) {
              const accentRgb = this.utils.hexToRgb(accentHex);
              if (!accentRgb) continue;
              const accentHsl = this.utils.rgbToHsl(
                accentRgb.r,
                accentRgb.g,
                accentRgb.b
              );
              const hueDiff = Math.abs(inputHsl.h - accentHsl.h);
              const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);
              const harmonyScore = 1 - normalizedHueDiff / 180;
              const saturationBonus = accentHsl.s * 0.3;
              const totalScore = harmonyScore + saturationBonus;
              if (totalScore > bestScore) {
                bestScore = totalScore;
                bestAccent = {
                  name: accentName,
                  hex: accentHex,
                  rgb: accentRgb
                };
              }
            }
          }
          return bestAccent;
        }
        blendColors(rgb1, rgb2, ratio = this.vibrancyConfig.defaultBlendRatio) {
          const r = Math.max(0, Math.min(1, ratio));
          const oklab1 = this.utils.rgbToOklab(rgb1.r, rgb1.g, rgb1.b);
          const oklab2 = this.utils.rgbToOklab(rgb2.r, rgb2.g, rgb2.b);
          const lerp2 = /* @__PURE__ */ __name((a, b) => a * r + b * (1 - r), "lerp");
          const blendedOklab = {
            L: lerp2(oklab1.L, oklab2.L),
            a: lerp2(oklab1.a, oklab2.a),
            b: lerp2(oklab1.b, oklab2.b)
          };
          const blendedRgb = this.utils.oklabToRgb(
            blendedOklab.L,
            blendedOklab.a,
            blendedOklab.b
          );
          const blendedHsl = this.utils.rgbToHsl(
            blendedRgb.r,
            blendedRgb.g,
            blendedRgb.b
          );
          const artisticMode = this.config?.artisticMode ?? "artist-vision";
          const emergentMultipliers = this.emergentEngine?.getCurrentMultipliers?.() || void 0;
          const shouldUseEmergent = artisticMode === "cosmic-maximum" && !!emergentMultipliers;
          const validMultipliers = emergentMultipliers || {};
          const saturationBoostFactor = shouldUseEmergent ? (validMultipliers.visualIntensityBase || 1) * 1.25 : this.vibrancyConfig.artisticSaturationBoost;
          const luminanceBoostFactor = shouldUseEmergent ? (validMultipliers.aestheticGravityStrength || 1) * 1.15 : this.vibrancyConfig.cosmicLuminanceBoost;
          blendedHsl.s = Math.max(
            blendedHsl.s,
            this.vibrancyConfig.minimumSaturation * 100
          );
          blendedHsl.s = Math.min(100, blendedHsl.s * saturationBoostFactor);
          if (artisticMode !== "corporate-safe") {
            blendedHsl.l = Math.min(95, blendedHsl.l * luminanceBoostFactor);
          }
          const finalRgb = this.utils.hslToRgb(
            blendedHsl.h,
            blendedHsl.s,
            blendedHsl.l
          );
          return { r: finalRgb.r, g: finalRgb.g, b: finalRgb.b };
        }
        blendWithCatppuccin(extractedColors, musicContext = null) {
          this.performanceMonitor?.emitTrace?.(
            "[ColorHarmonyEngine] Starting blendWithCatppuccin"
          );
          let emotionalTemperature = null;
          if (musicContext) {
            try {
              const musicAnalysis = {
                energy: musicContext.energy || 0.5,
                valence: musicContext.valence || 0.5,
                danceability: musicContext.danceability,
                tempo: musicContext.enhancedBPM || musicContext.tempo,
                loudness: musicContext.loudness,
                acousticness: musicContext.acousticness,
                instrumentalness: musicContext.instrumentalness,
                speechiness: musicContext.speechiness,
                mode: musicContext.mode,
                key: musicContext.key,
                genre: musicContext.genre
              };
              emotionalTemperature = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(
                musicAnalysis
              );
              if (emotionalTemperature) {
                unifiedEventBus.emit("system:css-variables", {
                  source: "ColorHarmonyEngine",
                  variables: emotionalTemperature.cssVariables,
                  timestamp: Date.now()
                });
                document.body.classList.remove(
                  ...Array.from(document.body.classList).filter(
                    (c) => c.startsWith("organic-emotion-")
                  )
                );
                document.body.classList.add(emotionalTemperature.cssClass);
                if (emotionalTemperature.secondaryEmotion) {
                  document.body.classList.add(
                    `organic-emotion-blend-${emotionalTemperature.secondaryEmotion}`
                  );
                }
              }
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F321}\uFE0F [ColorHarmonyEngine] Applied emotional temperature:",
                  emotionalTemperature
                );
              }
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn(
                  "\u{1F321}\uFE0F [ColorHarmonyEngine] Failed to apply emotional temperature:",
                  error
                );
              }
            }
          }
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [ColorHarmonyEngine] blendWithCatppuccin debug:", {
              extractedColors,
              musicContext,
              emotionalTemperature,
              currentTheme: this.currentTheme,
              vibrancyConfig: this.vibrancyConfig,
              userIntensity: this.userIntensity
            });
          }
          const currentPalette = this.getCurrentActivePalette();
          if (!currentPalette) {
            console.error(
              `[StarryNight] Catppuccin palette not found for theme: ${this.currentTheme}`
            );
            return extractedColors;
          }
          const harmonizedColors = {};
          for (const [role, color3] of Object.entries(extractedColors)) {
            if (!color3) continue;
            const extractedRgb = this.utils.hexToRgb(color3);
            if (!extractedRgb) {
              if (this.config.enableDebug) {
                console.warn(
                  `\u{1F3A8} [ColorHarmonyEngine] Failed to parse color for role ${role}: ${color3}`
                );
              }
              harmonizedColors[role] = color3;
              continue;
            }
            const extractedHsl = this.utils.rgbToHsl(
              extractedRgb.r,
              extractedRgb.g,
              extractedRgb.b
            );
            const saturationCheck = extractedHsl.s >= this.vibrancyConfig.minimumSaturation * 100;
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [ColorHarmonyEngine] Processing color ${role}:`, {
                originalColor: color3,
                rgb: extractedRgb,
                hsl: extractedHsl,
                saturationCheck,
                minimumSaturationRequired: this.vibrancyConfig.minimumSaturation * 100,
                actualSaturation: extractedHsl.s
              });
            }
            const bestAccent = this.findBestHarmoniousAccent(
              extractedRgb,
              currentPalette
            );
            if (!bestAccent?.rgb) {
              console.warn(
                `[StarryNight] Could not find a valid harmonious accent for role: ${role}. Using original color.`
              );
              harmonizedColors[role] = color3;
              continue;
            }
            let blendRatio = this.vibrancyConfig.getBlendRatio(
              this.config.artisticMode
            );
            if (emotionalTemperature) {
              const emotionalIntensity = emotionalTemperature.intensity;
              blendRatio *= emotionalIntensity * this.userIntensity;
              const temperatureInfluence = this.calculateTemperatureBlendInfluence(
                emotionalTemperature.temperature
              );
              blendRatio *= temperatureInfluence;
              blendRatio = Math.max(0, Math.min(1, blendRatio));
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F321}\uFE0F [ColorHarmonyEngine] Emotional temperature blend adjustment:",
                  {
                    originalRatio: this.vibrancyConfig.getBlendRatio(
                      this.config.artisticMode
                    ),
                    emotionalIntensity,
                    temperatureInfluence,
                    finalBlendRatio: blendRatio,
                    temperature: emotionalTemperature.temperature
                  }
                );
              }
            } else if (musicContext) {
              const musicIntensity = this.getMusicIntensityMultiplier(
                musicContext.energy,
                musicContext.valence
              );
              blendRatio *= musicIntensity * this.userIntensity;
              blendRatio = Math.max(0, Math.min(1, blendRatio));
            }
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [ColorHarmonyEngine] Blending ${role}:`, {
                extractedRgb,
                bestAccent: bestAccent.hex,
                blendRatio,
                artisticMode: this.config.artisticMode
              });
            }
            const finalRgb = this.blendColors(
              extractedRgb,
              bestAccent.rgb,
              blendRatio
            );
            const finalHex = this.utils.rgbToHex(finalRgb.r, finalRgb.g, finalRgb.b);
            harmonizedColors[role] = finalHex;
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3A8} [ColorHarmonyEngine] Final color for ${role}: ${color3} \u2192 ${finalHex}`
              );
            }
          }
          this.harmonyMetrics.musicInfluencedAdjustments++;
          this.performanceMonitor?.emitTrace?.(
            "[ColorHarmonyEngine] Completed blendWithCatppuccin"
          );
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [ColorHarmonyEngine] Final harmonized result:", {
              inputColors: extractedColors,
              outputColors: harmonizedColors,
              colorCount: Object.keys(harmonizedColors).length
            });
          }
          this.updateSemanticColorsWithHarmonizedPalette(harmonizedColors);
          return harmonizedColors;
        }
        /**
         * Updates semantic colors using the harmonized palette
         * Integrates with Spicetify's semantic color system for consistent theming
         */
        updateSemanticColorsWithHarmonizedPalette(harmonizedColors) {
          if (!this.semanticColorManager) {
            return;
          }
          try {
            this.semanticColorManager.updateWithAlbumColors(harmonizedColors);
            const primaryColor = harmonizedColors["VIBRANT"] || harmonizedColors["PRIMARY"];
            const secondaryColor = harmonizedColors["DARK_VIBRANT"] || harmonizedColors["SECONDARY"];
            const accentColor = harmonizedColors["VIBRANT_NON_ALARMING"] || harmonizedColors["LIGHT_VIBRANT"];
            if (primaryColor) {
              this.semanticColorManager.getSemanticColor("essentialBrightAccent").then((color3) => {
                const blendedColor = this.blendWithSemanticColor(
                  primaryColor,
                  color3,
                  0.7
                );
                this.applyCSSVariable("--spice-accent", blendedColor);
                this.applyCSSVariable("--spice-button-active", blendedColor);
              });
            }
            if (secondaryColor) {
              this.semanticColorManager.getSemanticColor("backgroundElevatedHighlight").then((color3) => {
                const blendedColor = this.blendWithSemanticColor(
                  secondaryColor,
                  color3,
                  0.5
                );
                this.applyCSSVariable("--spice-highlight", blendedColor);
              });
            }
            if (accentColor) {
              this.semanticColorManager.getSemanticColor("textBrightAccent").then((color3) => {
                const blendedColor = this.blendWithSemanticColor(
                  accentColor,
                  color3,
                  0.6
                );
                this.applyCSSVariable("--spice-text-accent", blendedColor);
              });
            }
            this.semanticColorManager.flushUpdates();
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[ColorHarmonyEngine] Failed to update semantic colors:",
                error
              );
            }
          }
        }
        /**
         * Blends a harmonized color with a semantic color for consistency
         */
        blendWithSemanticColor(harmonizedHex, semanticHex, blendRatio) {
          const harmonizedRgb = this.utils.hexToRgb(harmonizedHex);
          const semanticRgb = this.utils.hexToRgb(semanticHex);
          if (!harmonizedRgb || !semanticRgb) {
            return harmonizedHex;
          }
          const blendedRgb = this.blendColors(harmonizedRgb, semanticRgb, blendRatio);
          return this.utils.rgbToHex(blendedRgb.r, blendedRgb.g, blendedRgb.b);
        }
        /**
         *  PHASE 2: Emit CSS variable instead of applying directly
         */
        applyCSSVariable(property, value) {
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: { [property]: value },
            timestamp: Date.now()
          });
        }
        /**
         * Apply multiple CSS variables to the DOM efficiently
         * Enhanced with comprehensive UI component support and robust fallbacks
         */
        applyCSSVariablesToDOM(cssVariables) {
          const year3000System2 = globalThis.year3000System;
          const cssConsciousnessController = year3000System2?.cssConsciousnessController || this.performanceMonitor?.cssConsciousnessController || year3000System2?.facadeCoordinator?.getCachedNonVisualSystem?.(
            "UnifiedCSSVariableManager"
          );
          const enhancedCssVariables = this.enhanceCSSVariablesForUIComponents(cssVariables);
          if (cssConsciousnessController && typeof cssConsciousnessController.batchSetVariables === "function") {
            try {
              cssConsciousnessController.batchSetVariables(
                "ColorHarmonyEngine",
                enhancedCssVariables,
                "high",
                // High priority for color processing
                "color-harmony-oklab-processing"
              );
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F527} [ColorHarmonyEngine] Applied CSS variables via cssConsciousnessController batcher"
                );
              }
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn(
                  "\u{1F527} [ColorHarmonyEngine] cssConsciousnessController.batchSetVariables failed, using direct application:",
                  error
                );
              }
              this.applyVariablesDirectly(enhancedCssVariables);
            }
          } else {
            if (this.config.enableDebug) {
              console.log(
                "\u{1F527} [ColorHarmonyEngine] cssConsciousnessController not available, using direct DOM application"
              );
            }
            this.applyVariablesDirectly(enhancedCssVariables);
          }
          unifiedEventBus.emitSync("colors:applied", {
            cssVariables: enhancedCssVariables,
            accentHex: enhancedCssVariables["--sn-accent-hex"] || "#a6adc8",
            accentRgb: enhancedCssVariables["--sn-accent-rgb"] || "166,173,200",
            appliedAt: Date.now()
          });
          if (this.config.enableDebug) {
            console.log(
              "\u{1F52C} [ColorHarmonyEngine] Applied enhanced CSS variables to DOM:",
              {
                totalVariables: Object.keys(enhancedCssVariables).length,
                oklabVariables: Object.keys(enhancedCssVariables).filter(
                  (k) => k.includes("oklab")
                ).length,
                oklchVariables: Object.keys(enhancedCssVariables).filter(
                  (k) => k.includes("oklch")
                ).length,
                gradientVariables: Object.keys(enhancedCssVariables).filter(
                  (k) => k.includes("gradient")
                ).length,
                spiceVariables: Object.keys(enhancedCssVariables).filter(
                  (k) => k.includes("spice")
                ).length,
                sidebarVariables: Object.keys(enhancedCssVariables).filter(
                  (k) => k.includes("sidebar")
                ).length,
                cssConsciousnessControllerUsed: !!cssConsciousnessController
              }
            );
          }
        }
        /**
         * Enhance CSS variables with UI component-specific mappings
         * Maps OKLAB-processed colors to variables that sidebar, now-playing, and other UI components expect
         */
        enhanceCSSVariablesForUIComponents(cssVariables) {
          const enhanced = { ...cssVariables };
          const accentHex = enhanced["--sn-accent-hex"] || enhanced[_ColorHarmonyEngine.CANONICAL_HEX_VAR];
          const accentRgb = enhanced["--sn-accent-rgb"] || enhanced[_ColorHarmonyEngine.CANONICAL_RGB_VAR];
          const primaryHex = enhanced["--sn-bg-gradient-primary"];
          const primaryRgb = enhanced["--sn-bg-gradient-primary-rgb"];
          const secondaryHex = enhanced["--sn-bg-gradient-secondary"];
          const secondaryRgb = enhanced["--sn-bg-gradient-secondary-rgb"];
          if (accentHex && accentRgb) {
            enhanced["--spice-accent"] = accentHex;
            enhanced["--spice-button"] = accentHex;
            enhanced["--spice-button-active"] = accentHex;
            enhanced["--spice-rgb-accent"] = accentRgb;
            enhanced["--spice-rgb-button"] = accentRgb;
            enhanced["--spice-text-accent"] = accentHex;
            enhanced["--sn-sidebar-entanglement-color-rgb"] = accentRgb;
            enhanced["--sn-sidebar-accent-color"] = accentHex;
            enhanced["--sn-sidebar-accent-rgb"] = accentRgb;
            enhanced["--sn-sidebar-dynamic-accent"] = accentHex;
            enhanced["--sn-nowplaying-accent-color"] = accentHex;
            enhanced["--sn-nowplaying-accent-rgb"] = accentRgb;
            enhanced["--sn-nowplaying-primary-color"] = accentHex;
            enhanced["--sn-nowplaying-primary-rgb"] = accentRgb;
            enhanced["--sn-main-feed-accent-color"] = accentHex;
            enhanced["--sn-main-feed-accent-rgb"] = accentRgb;
            enhanced["--sn-content-accent-color"] = accentHex;
            enhanced["--sn-content-accent-rgb"] = accentRgb;
          }
          if (primaryHex && primaryRgb) {
            enhanced["--sn-primary-gradient-color"] = primaryHex;
            enhanced["--sn-primary-gradient-rgb"] = primaryRgb;
            enhanced["--sn-main-feed-primary-color"] = primaryHex;
            enhanced["--sn-main-feed-primary-rgb"] = primaryRgb;
          }
          if (secondaryHex && secondaryRgb) {
            enhanced["--sn-secondary-gradient-color"] = secondaryHex;
            enhanced["--sn-secondary-gradient-rgb"] = secondaryRgb;
            enhanced["--sn-main-feed-secondary-color"] = secondaryHex;
            enhanced["--sn-main-feed-secondary-rgb"] = secondaryRgb;
          }
          const oklabBrightHighlight = enhanced["--sn-color-oklab-bright-highlight-rgb"];
          if (oklabBrightHighlight) {
            enhanced["--sn-consciousness-bright-accent-rgb"] = oklabBrightHighlight;
            enhanced["--sn-holographic-accent-rgb"] = oklabBrightHighlight;
            enhanced["--organic-holographic-rgb"] = oklabBrightHighlight;
          }
          const oklabDynamicShadow = enhanced["--sn-color-oklab-dynamic-shadow-rgb"];
          if (oklabDynamicShadow) {
            enhanced["--sn-consciousness-shadow-rgb"] = oklabDynamicShadow;
            enhanced["--sn-depth-shadow-rgb"] = oklabDynamicShadow;
          }
          return enhanced;
        }
        /**
         *  PHASE 2: Emit CSS variables instead of applying directly
         */
        applyVariablesDirectly(cssVariables) {
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: cssVariables,
            timestamp: Date.now()
          });
        }
        generateRecommendations(color3, contrastRatio, harmonyScore, requirements) {
          const recommendations = [];
          const currentPalette = this.getCurrentActivePalette();
          const baseRgb = this.utils.hexToRgb(currentPalette?.neutrals?.base || "#1e1e2e");
          if (!baseRgb) {
            return [];
          }
          if (contrastRatio < requirements.minContrast) {
            const targetL = this.utils.findRequiredLuminance(
              color3,
              baseRgb,
              requirements.minContrast
            );
            const currentHsl = this.utils.rgbToHsl(color3.r, color3.g, color3.b);
            const adjustedRgbArr = this.utils.hslToRgb(
              currentHsl.h,
              currentHsl.s,
              targetL
            );
            const adjustedRgb = {
              r: adjustedRgbArr.r,
              g: adjustedRgbArr.g,
              b: adjustedRgbArr.b
            };
            recommendations.push({
              type: "contrast",
              suggestion: `Adjust luminance to meet contrast of ${requirements.minContrast}`,
              recommendedColor: this.utils.rgbToHex(
                adjustedRgb.r,
                adjustedRgb.g,
                adjustedRgb.b
              )
            });
          }
          if (harmonyScore < requirements.minHarmony) {
            const harmoniousAccent = this.findBestHarmoniousAccent(
              color3,
              currentPalette
            );
            const blendedColor = this.blendColors(color3, harmoniousAccent.rgb, 0.5);
            recommendations.push({
              type: "harmony",
              suggestion: `Blend with harmonious accent color to improve score to at least ${requirements.minHarmony}`,
              recommendedColor: this.utils.rgbToHex(
                blendedColor.r,
                blendedColor.g,
                blendedColor.b
              )
            });
          }
          return recommendations;
        }
        getPerformanceReport() {
          return {
            system: this.systemName,
            metrics: this.harmonyMetrics,
            kineticState: this.kineticState,
            musicalMemorySize: this.musicalMemory.recentTracks.length,
            currentTheme: this.currentTheme
          };
        }
        updateFromMusicAnalysis(processedMusicData, rawFeatures, trackUri) {
          if (!processedMusicData) return;
          const g = processedMusicData.genre;
          if (g && g !== this._lastGenre) {
            this._applyGenrePalette(g).then(() => {
              this._lastGenre = g;
              this._forcePaletteRepaint();
            });
          }
          this._updateMusicalMemory(processedMusicData, trackUri);
          this._updateKineticState(processedMusicData);
          this._applyAestheticGravity(processedMusicData);
          this._calculateMusicAwareDynamics(processedMusicData);
        }
        // TODO: Phase 2 - New method for music-aware dynamic calculations
        _calculateMusicAwareDynamics(musicData) {
          const {
            energy = 0.5,
            valence = 0.5,
            enhancedBPM = 120,
            beatOccurred = false
          } = musicData;
          const musicIntensityMultiplier = this._calculateMusicIntensityMultiplier(
            energy,
            valence
          );
          const beatPhase = this._calculateBeatPhase(enhancedBPM);
          const valenceGravity = (valence - 0.5) * 2;
          const hueShift = this._calculateHueShift(beatOccurred, energy, beatPhase);
          this.kineticState = {
            ...this.kineticState,
            musicIntensityMultiplier,
            beatPhase,
            valenceGravity,
            hueShift
          };
        }
        // TODO: Phase 2 - Calculate music intensity based on energy and valence
        _calculateMusicIntensityMultiplier(energy, valence) {
          const baseIntensity = energy * 0.7 + valence * 0.3;
          const contrastBoost = Math.abs(valence - 0.5) * 0.4;
          return Math.max(0.1, Math.min(2, baseIntensity + contrastBoost));
        }
        // TODO: Phase 2 - Calculate beat phase for cyclic effects
        _calculateBeatPhase(enhancedBPM) {
          const now = performance.now();
          const beatInterval = 6e4 / enhancedBPM;
          const timeSinceStart = now % beatInterval;
          return timeSinceStart / beatInterval;
        }
        // TODO: Phase 2 - Calculate dynamic hue shift for beat effects
        _calculateHueShift(beatOccurred, energy, beatPhase) {
          if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
            return 0;
          }
          const artisticMode = this.config.artisticMode;
          const baseAmplitude = artisticMode === "cosmic-maximum" ? 8 : 5;
          let hueShift = Math.sin(beatPhase * 2 * Math.PI) * baseAmplitude;
          if (beatOccurred) {
            const beatBoost = artisticMode === "cosmic-maximum" ? 12 : 10;
            hueShift += energy * beatBoost;
          }
          const clampRange = artisticMode === "cosmic-maximum" ? 25 : 15;
          return Math.max(-clampRange, Math.min(clampRange, hueShift));
        }
        _updateMusicalMemory(musicData, trackUri) {
          this.musicalMemory.recentTracks.unshift({
            trackUri,
            ...musicData,
            timestamp: Date.now()
          });
          if (this.musicalMemory.recentTracks.length > this.musicalMemory.maxMemorySize) {
            this.musicalMemory.recentTracks.pop();
          }
          this.musicalMemory.energyHistory.unshift(musicData.energy);
          if (this.musicalMemory.energyHistory.length > 20) {
            this.musicalMemory.energyHistory.pop();
          }
          this.harmonyMetrics.temporalMemoryEvents++;
        }
        _updateKineticState(musicData) {
          const { energy, enhancedBPM, beatOccurred } = musicData;
          const now = performance.now();
          if (beatOccurred) {
            this.kineticState.lastBeatTime = now;
            this.kineticState.currentPulse = 1;
          } else {
            this.kineticState.currentPulse *= 0.95;
          }
          const timeSinceLastBeat = now - this.kineticState.lastBeatTime;
          const beatInterval = 6e4 / (enhancedBPM || 120);
          this.kineticState.breathingPhase = timeSinceLastBeat % beatInterval / beatInterval * 2 * Math.PI;
          this.kineticState.visualMomentum = this.utils.lerp(
            this.kineticState.visualMomentum,
            energy,
            0.1
          );
        }
        //  PHASE 2: Emit gravity variables instead of applying CSS directly
        _applyAestheticGravity(musicData) {
          const { visualIntensity, valence, energy } = musicData;
          const gravityX = (valence - 0.5) * 2;
          const gravityY = (energy - 0.5) * 2;
          const gravityStrength = visualIntensity;
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: {
              "--sn-gravity-x": gravityX.toFixed(3),
              "--sn-gravity-y": gravityY.toFixed(3),
              "--sn-gravity-strength": gravityStrength.toFixed(3)
            },
            timestamp: Date.now()
          });
        }
        generateHarmonicVariations(baseRgb) {
          const oklab = this.utils.rgbToOklab(baseRgb.r, baseRgb.g, baseRgb.b);
          const darkOklabL = Math.max(0, Math.min(1, oklab.L * 0.75));
          const darkRgb = this.utils.oklabToRgb(darkOklabL, oklab.a, oklab.b);
          const lightOklabL = Math.max(0, Math.min(1, oklab.L * 1.25));
          const lightRgb = this.utils.oklabToRgb(lightOklabL, oklab.a, oklab.b);
          return {
            darkVibrantHex: this.utils.rgbToHex(darkRgb.r, darkRgb.g, darkRgb.b),
            lightVibrantHex: this.utils.rgbToHex(lightRgb.r, lightRgb.g, lightRgb.b)
          };
        }
        /**
         * Get current gradient colors optimized for WebGL texture creation
         * Uses variable inheritance from OKLAB processed consciousness-aware colors
         * @param stopCount Number of gradient stops to generate (default: 5)
         * @returns Array of RGB color objects or null if unavailable
         */
        getCurrentGradient(stopCount = 5) {
          try {
            const currentPalette = this.getCurrentActivePalette();
            if (!currentPalette) {
              return null;
            }
            const rootEl = this.utils.getRootStyle();
            if (!rootEl) {
              return this.generateFallbackGradient(stopCount);
            }
            const computedStyle = getComputedStyle(rootEl);
            const inheritedColors = this.getInheritedGradientColors(computedStyle);
            if (!inheritedColors) {
              Y3KDebug?.debug?.warn(
                "ColorHarmonyEngine",
                "Failed to inherit processed gradient variables, using fallback"
              );
              return this.generateFallbackGradient(stopCount);
            }
            const gradientColors = [];
            const musicInfluence = this.kineticState.musicIntensityMultiplier || 1;
            const hueShift = this.kineticState.hueShift || 0;
            const valenceGravity = this.kineticState.valenceGravity || 0.5;
            const emotionalTemperature = this.emotionalState?.currentEmotion?.colorTemperature || 0.5;
            const { primary, secondary, accent, emotional, tertiary } = inheritedColors;
            const baseColors = [
              primary,
              // Deep consciousness base
              secondary,
              // Harmonic transition
              accent,
              // Vibrational peak
              emotional,
              // Emotional resonance
              tertiary
              // Transcendent highlight
            ];
            for (let i = 0; i < stopCount; i++) {
              const position = i / (stopCount - 1);
              let interpolatedColor;
              if (stopCount === 1) {
                interpolatedColor = accent;
              } else {
                const colorIndex = position * (baseColors.length - 1);
                const lowerIndex = Math.floor(colorIndex);
                const upperIndex = Math.min(lowerIndex + 1, baseColors.length - 1);
                const interpolationFactor = colorIndex - lowerIndex;
                const temperatureInfluence = Math.sin(emotionalTemperature * Math.PI) * 0.3;
                const adjustedFactor = Math.max(
                  0,
                  Math.min(1, interpolationFactor + temperatureInfluence)
                );
                const color1 = baseColors[lowerIndex];
                const color22 = baseColors[upperIndex];
                if (color1 && color22) {
                  interpolatedColor = {
                    r: color1.r + (color22.r - color1.r) * adjustedFactor,
                    g: color1.g + (color22.g - color1.g) * adjustedFactor,
                    b: color1.b + (color22.b - color1.b) * adjustedFactor
                  };
                } else {
                  interpolatedColor = accent;
                }
              }
              let finalColor = this._applyConsciousnessModulation(interpolatedColor, {
                musicInfluence,
                valenceGravity,
                hueShift,
                emotionalTemperature,
                position
              });
              gradientColors.push({
                r: Math.round(Math.max(0, Math.min(255, finalColor.r))),
                g: Math.round(Math.max(0, Math.min(255, finalColor.g))),
                b: Math.round(Math.max(0, Math.min(255, finalColor.b)))
              });
            }
            if (this.config?.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Generated gradient with ${stopCount} stops:`,
                gradientColors
              );
            }
            return gradientColors;
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "Unknown error";
            const errorDetails = {
              method: "getCurrentGradient",
              stopCount,
              currentTheme: this.currentTheme,
              kineticState: this.kineticState,
              timestamp: Date.now(),
              error: errorMessage
            };
            Y3KDebug?.debug?.error(
              "ColorHarmonyEngine",
              "Failed to generate gradient colors",
              errorDetails
            );
            unifiedEventBus.emit("system:error", {
              systemName: "ColorHarmonyEngine",
              error: `Gradient generation failed: ${errorMessage}`,
              severity: "error",
              timestamp: Date.now()
            });
            try {
              const fallbackColors = this.generateFallbackGradient(stopCount);
              if (fallbackColors && fallbackColors.length > 0) {
                Y3KDebug?.debug?.warn(
                  "ColorHarmonyEngine",
                  "Using fallback gradient after error",
                  { fallbackColorCount: fallbackColors.length }
                );
                return fallbackColors;
              }
            } catch (fallbackError) {
              Y3KDebug?.debug?.error(
                "ColorHarmonyEngine",
                "Fallback gradient generation also failed",
                fallbackError
              );
            }
            return null;
          }
        }
        /**
         * Get inherited gradient colors from processed OKLAB CSS variables
         * Uses variable inheritance instead of manual CSS reading
         */
        getInheritedGradientColors(computedStyle) {
          try {
            const primaryRgb = this.parseRGBVariable(
              computedStyle,
              "--sn-oklab-processed-primary-rgb"
            ) || this.parseRGBVariable(computedStyle, "--sn-bg-gradient-primary-rgb") || this.parseRGBVariable(
              computedStyle,
              "--sn-musical-harmony-primary-rgb"
            );
            const secondaryRgb = this.parseRGBVariable(
              computedStyle,
              "--sn-oklab-processed-secondary-rgb"
            ) || this.parseRGBVariable(computedStyle, "--sn-bg-gradient-secondary-rgb") || this.parseRGBVariable(
              computedStyle,
              "--sn-musical-harmony-secondary-rgb"
            );
            const accentRgb = this.parseRGBVariable(
              computedStyle,
              "--sn-oklab-processed-accent-rgb"
            ) || this.parseRGBVariable(computedStyle, "--sn-bg-gradient-accent-rgb") || this.parseRGBVariable(computedStyle, "--sn-color-accent-rgb");
            const emotionalRgb = this.parseRGBVariable(
              computedStyle,
              "--sn-oklab-emotional-temperature-rgb"
            ) || this.parseRGBVariable(
              computedStyle,
              "--sn-emotional-temperature-warm-rgb"
            ) || accentRgb;
            const tertiaryRgb = this.parseRGBVariable(
              computedStyle,
              "--sn-oklab-processed-bright-highlight-rgb"
            ) || this.parseRGBVariable(computedStyle, "--sn-consciousness-flow-rgb") || this.parseRGBVariable(
              computedStyle,
              "--sn-musical-harmony-tertiary-rgb"
            );
            if (!primaryRgb || !accentRgb) {
              Y3KDebug?.debug?.warn(
                "ColorHarmonyEngine",
                "Missing essential inherited colors",
                {
                  hasPrimary: !!primaryRgb,
                  hasAccent: !!accentRgb
                }
              );
              return null;
            }
            return {
              primary: primaryRgb,
              secondary: secondaryRgb || primaryRgb,
              accent: accentRgb,
              emotional: emotionalRgb || accentRgb,
              tertiary: tertiaryRgb || accentRgb
            };
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ColorHarmonyEngine",
              "Failed to inherit gradient colors:",
              error
            );
            return null;
          }
        }
        /**
         * Parse RGB variable from CSS computed style with fallback chain
         */
        parseRGBVariable(computedStyle, variableName) {
          try {
            const value = computedStyle.getPropertyValue(variableName).trim();
            if (!value) return null;
            const rgbMatch = value.match(/(\d+),\s*(\d+),\s*(\d+)/);
            if (rgbMatch && rgbMatch[1] && rgbMatch[2] && rgbMatch[3]) {
              return {
                r: parseInt(rgbMatch[1], 10),
                g: parseInt(rgbMatch[2], 10),
                b: parseInt(rgbMatch[3], 10)
              };
            }
            return null;
          } catch (error) {
            return null;
          }
        }
        /**
         * Interpolate between two colors using perceptually aware interpolation
         */
        interpolateOKLABColors(color1, color22, factor) {
          const gamma = 2.2;
          const r1 = Math.pow(color1.r / 255, gamma);
          const g1 = Math.pow(color1.g / 255, gamma);
          const b1 = Math.pow(color1.b / 255, gamma);
          const r2 = Math.pow(color22.r / 255, gamma);
          const g2 = Math.pow(color22.g / 255, gamma);
          const b2 = Math.pow(color22.b / 255, gamma);
          const rInterp = r1 + (r2 - r1) * factor;
          const gInterp = g1 + (g2 - g1) * factor;
          const bInterp = b1 + (b2 - b1) * factor;
          return {
            r: Math.round(Math.pow(rInterp, 1 / gamma) * 255),
            g: Math.round(Math.pow(gInterp, 1 / gamma) * 255),
            b: Math.round(Math.pow(bInterp, 1 / gamma) * 255)
          };
        }
        /**
         * Apply consciousness modulation to color (preserves OKLAB processing)
         */
        _applyConsciousnessModulation(color3, modulation) {
          try {
            const hsl = this.utils.rgbToHsl(color3.r, color3.g, color3.b);
            let { h, s, l } = hsl;
            s = Math.max(0, Math.min(1, s * (0.7 + modulation.musicInfluence * 0.6)));
            h = (h + modulation.hueShift + (modulation.emotionalTemperature - 0.5) * 60) % 360;
            const gravityEffect = modulation.valenceGravity * 0.2 * Math.sin(modulation.position * Math.PI);
            l = Math.max(0.1, Math.min(0.9, l + gravityEffect));
            const modulatedRgb = this.utils.hslToRgb(h, s, l);
            return {
              r: modulatedRgb.r,
              g: modulatedRgb.g,
              b: modulatedRgb.b
            };
          } catch (error) {
            return color3;
          }
        }
        /**
         * Generate fallback gradient colors when primary generation fails
         * Uses safe Catppuccin colors to prevent complete gradient failure
         */
        generateFallbackGradient(stopCount) {
          try {
            const fallbackHexColors = [
              "#1e1e2e",
              // Base
              "#313244",
              // Surface0
              "#45475a",
              // Surface1
              "#585b70",
              // Surface2
              "#cba6f7",
              // Mauve (primary accent)
              "#f5c2e7",
              // Pink
              "#fab387"
              // Peach
            ];
            if (stopCount < 2 || stopCount > fallbackHexColors.length) {
              Y3KDebug?.debug?.warn(
                "ColorHarmonyEngine",
                `Invalid fallback stopCount: ${stopCount}, using default`
              );
              stopCount = Math.min(Math.max(stopCount, 2), fallbackHexColors.length);
            }
            const fallbackColors = [];
            for (let i = 0; i < stopCount; i++) {
              const colorIndex = Math.floor(
                i / (stopCount - 1) * (fallbackHexColors.length - 1)
              );
              const hex = fallbackHexColors[colorIndex];
              const rgb = hex ? this.utils.hexToRgb(hex) : null;
              if (rgb) {
                fallbackColors.push(rgb);
              } else {
                fallbackColors.push({
                  r: 203,
                  g: 166,
                  b: 247
                  // Mauve fallback
                });
              }
            }
            if (fallbackColors.length < 2) {
              fallbackColors.push(
                { r: 30, g: 30, b: 46 },
                // Base
                { r: 203, g: 166, b: 247 }
                // Mauve
              );
            }
            Y3KDebug?.debug?.log(
              "ColorHarmonyEngine",
              `Generated fallback gradient with ${fallbackColors.length} colors`,
              fallbackColors
            );
            return fallbackColors;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ColorHarmonyEngine",
              "Critical error in fallback gradient generation",
              error
            );
            return null;
          }
        }
        /**
         * Analyze music and update emotional state for consciousness-aware color processing
         * This method connects the Music  Emotion  Color flow
         */
        async analyzeMusicEmotion(audioFeatures, audioData) {
          if (!this.initialized || !this.musicEmotionAnalyzer) {
            if (this.config.enableDebug) {
              console.warn(
                "\u{1F3AD} [ColorHarmonyEngine] Cannot analyze music emotion: not initialized"
              );
            }
            return null;
          }
          try {
            const emotion = await this.musicEmotionAnalyzer.analyzeEmotion(
              audioFeatures,
              audioData
            );
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3AD} [ColorHarmonyEngine] Analyzed music emotion: ${emotion.primary} (${emotion.intensity.toFixed(
                  2
                )} intensity, ${emotion.confidence.toFixed(2)} confidence)`
              );
            }
            return emotion;
          } catch (error) {
            console.error(
              "\u{1F3AD} [ColorHarmonyEngine] Error analyzing music emotion:",
              error
            );
            return null;
          }
        }
        /**
         * Get current emotional state
         */
        getCurrentEmotion() {
          return this.emotionalState?.currentEmotion || null;
        }
        /**
         * Get emotion history for consciousness flow analysis
         */
        getEmotionHistory(limit = 10) {
          if (!this.emotionalState?.emotionHistory) return [];
          return this.emotionalState.emotionHistory.slice(-limit);
        }
        /**
         * Set emotion influence intensity (0-1) for color processing
         */
        setEmotionInfluenceIntensity(intensity) {
          if (this.emotionalState) {
            this.emotionalState.emotionInfluenceIntensity = Math.max(
              0,
              Math.min(1, intensity)
            );
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3AD} [ColorHarmonyEngine] Emotion influence intensity set to ${this.emotionalState.emotionInfluenceIntensity}`
              );
            }
          }
        }
        /**
         * Create a color variant with lightness, saturation, and hue adjustments
         */
        _createVariant(baseColor, lightnessFactor, valenceGravity, hueShift) {
          const oklab = this.utils.rgbToOklab(baseColor.r, baseColor.g, baseColor.b);
          const newL = Math.max(0, Math.min(1, oklab.L + lightnessFactor * 0.2));
          const chromaScale = 0.8 + valenceGravity * 0.4;
          const newA = oklab.a * chromaScale;
          const newB = oklab.b * chromaScale;
          const hueAdjustment = hueShift * 0.1;
          const adjustedA = newA * Math.cos(hueAdjustment) - newB * Math.sin(hueAdjustment);
          const adjustedB = newA * Math.sin(hueAdjustment) + newB * Math.cos(hueAdjustment);
          return this.utils.oklabToRgb(newL, adjustedA, adjustedB);
        }
        /**
         * Apply music intensity influence to color
         */
        _applyMusicInfluence(color3, intensity, position) {
          const positionEffect = 1 + Math.sin(position * Math.PI) * 0.2;
          const effectiveIntensity = Math.max(
            0.7,
            Math.min(1.3, intensity * positionEffect)
          );
          return {
            r: color3.r * effectiveIntensity,
            g: color3.g * effectiveIntensity,
            b: color3.b * effectiveIntensity
          };
        }
        // =========================
        // PUBLIC API  User Control
        // =========================
        /**
         * Update user-defined harmonic intensity (01). Values outside range are clamped.
         */
        setIntensity(value) {
          const clamped = Math.max(0, Math.min(1, value));
          this.userIntensity = clamped;
          if (this.config?.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] User harmonic intensity set to ${clamped}`
            );
          }
        }
        /**
         * External systems can push a pre-computed RGB palette to the engine.
         * Currently this simply triggers a palette refresh so all CSS variables
         * are recalculated.  Future phases may blend these colours directly.
         *
         * @param colors  Array of RGB objects ({ r,g,b }) representing the new palette
         */
        updatePalette(colors) {
          if (!colors?.length) return;
          if (this.config?.enableDebug) {
            console.log("[ColorHarmonyEngine] updatePalette invoked", {
              count: colors.length
            });
          }
          this.forceRepaint("external-palette");
        }
        // ============================
        // Settings / Event Integration
        // ============================
        _handleSettingsChange(event) {
          const { key, value } = event.detail || {};
          switch (key) {
            case HARMONIC_INTENSITY_KEY: {
              const num = parseFloat(value);
              if (!Number.isNaN(num)) {
                this.setIntensity(num);
              }
              break;
            }
            case HARMONIC_EVOLUTION_KEY: {
              const enabled = value === "true" || value === true;
              this._setEvolutionEnabled(enabled);
              break;
            }
          }
        }
        _handleArtisticModeChanged() {
          this.currentTheme = this.detectCurrentTheme();
          if (!this._pendingPaletteRefresh) {
            this._pendingPaletteRefresh = setTimeout(() => {
              this._pendingPaletteRefresh = null;
              this.refreshPalette();
            }, 80);
          }
        }
        _forcePaletteRepaint() {
          this.kineticState.hueShift = (this.kineticState.hueShift || 0) + 0.01;
        }
        // Evolution helpers
        _startEvolutionLoop() {
          if (this._evolutionTimer) return;
          const basePeriod = 3e4;
          const period = basePeriod / Math.max(0.1, this.userIntensity);
          this._evolutionTimer = setInterval(() => {
            const step = 2 * this.userIntensity;
            const current = this.kineticState.hueShift ?? 0;
            this.kineticState.hueShift = (current + step + 360) % 360 - 180;
          }, period);
        }
        _stopEvolutionLoop() {
          if (this._evolutionTimer) {
            clearInterval(this._evolutionTimer);
            this._evolutionTimer = null;
          }
        }
        _setEvolutionEnabled(enabled) {
          if (this.evolutionEnabled === enabled) return;
          this.evolutionEnabled = enabled;
          if (enabled) this._startEvolutionLoop();
          else this._stopEvolutionLoop();
        }
        // Clean up listeners when destroyed
        destroy() {
          this._stopEvolutionLoop();
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this._boundSettingsChangeHandler
          );
          document.removeEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          if (this.semanticColorManager) {
            this.semanticColorManager.destroy();
          }
          if (this.musicEmotionAnalyzer) {
            this.musicEmotionAnalyzer.destroy();
          }
          if (this.emotionalState) {
            this.emotionalState.currentEmotion = null;
            this.emotionalState.emotionHistory = [];
          }
          super.destroy?.();
        }
        /**
         * Public helper that triggers a colour rebake based on the current track.
         * Prefer calling the global Year3000System where available so the full
         * pipeline (extraction  harmonisation  CSS variable batch) is reused.
         */
        async refreshPalette() {
          try {
            const y3kSystem = globalThis.year3000System;
            if (y3kSystem?.updateColorsFromCurrentTrack) {
              await y3kSystem.updateColorsFromCurrentTrack();
              return;
            }
            const root = this.utils.getRootStyle();
            if (!root) return;
            const styles = getComputedStyle(root);
            const primary = styles.getPropertyValue("--sn-gradient-primary").trim();
            if (primary) {
              const rgb = this.utils.hexToRgb(primary);
              const variables = {
                "--sn-bg-gradient-primary": primary
              };
              if (rgb) {
                variables["--sn-bg-gradient-primary-rgb"] = `${rgb.r},${rgb.g},${rgb.b}`;
              }
              unifiedEventBus.emit("system:css-variables", {
                source: "ColorHarmonyEngine",
                variables,
                timestamp: Date.now()
              });
            }
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn("[ColorHarmonyEngine] refreshPalette failed", err);
            }
          }
        }
        /**
         * Swap Catppuccin palette accents & neutrals based on detected genre.
         * Executes asynchronously to avoid blocking audio thread.
         */
        async _applyGenrePalette(genre) {
          try {
            const palette = await this._getGenreAwarePalette(genre);
            if (!palette) return;
            this.catppuccinPalettes[this.currentTheme] = palette;
            await this.refreshPalette();
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [ColorHarmonyEngine] Genre changed to: ${genre}`);
            }
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn("[ColorHarmonyEngine] _applyGenrePalette failed", err);
            }
          }
        }
        setEmergentEngine(engine) {
          this.emergentEngine = engine;
        }
        // ---------------------------------------------------------------------------
        //  SETTINGS-AWARE REPAINT IMPLEMENTATION
        // ---------------------------------------------------------------------------
        /**
         * Calculate temperature-based blend influence for emotional temperature integration
         * Maps color temperature (1000K-20000K) to blend ratio influence (0.7-1.3)
         */
        calculateTemperatureBlendInfluence(temperature) {
          const normalized = Math.max(
            0,
            Math.min(1, (temperature - 1e3) / (2e4 - 1e3))
          );
          if (temperature <= 4e3) {
            const warmFactor = (4e3 - temperature) / (4e3 - 1e3);
            return 1 + warmFactor * 0.3;
          } else if (temperature >= 8e3) {
            const coolFactor = (temperature - 8e3) / (2e4 - 8e3);
            return 1.1 + coolFactor * 0.2;
          } else {
            const midFactor = Math.abs(temperature - 6e3) / 2e3;
            return 0.9 + midFactor * 0.2;
          }
        }
        /**
         * Re-apply the current palette immediately.  This is extremely lightweight
         * (just re-blends colours + sets CSS vars) so it can be called synchronously
         * from Year3000System after a relevant settings change.
         */
        forceRepaint(_reason = "settings-change") {
          this.refreshPalette?.();
        }
        // ============================================================================
        //  ENHANCED OKLAB INTEGRATION METHODS
        // ============================================================================
        /**
         * Determine optimal OKLAB enhancement preset based on musical and visual context
         */
        determineOptimalOKLABPreset(context) {
          const musicData = context.musicData;
          let selectedPreset = OKLABColorProcessor.PRESETS.STANDARD;
          if (musicData) {
            const { energy = 0.5, valence = 0.5 } = musicData;
            if (energy > 0.8 && valence > 0.7) {
              selectedPreset = OKLABColorProcessor.PRESETS.COSMIC;
            } else if (energy > 0.7 && valence < 0.4) {
              selectedPreset = OKLABColorProcessor.PRESETS.VIBRANT;
            } else if (energy < 0.3) {
              selectedPreset = OKLABColorProcessor.PRESETS.SUBTLE;
            }
          }
          if (context.performanceHints?.preferLightweight) {
            selectedPreset = OKLABColorProcessor.PRESETS.SUBTLE;
          }
          if (this.config?.enableDebug) {
            console.log("\u{1F52C} [ColorHarmonyEngine] OKLAB preset selection:", {
              energy: musicData?.energy,
              valence: musicData?.valence,
              selectedPreset: selectedPreset.name,
              reason: this.getPresetSelectionReason(musicData, context)
            });
          }
          return selectedPreset;
        }
        /**
         * Get comprehensive emotional temperature analysis using EmotionalTemperatureMapper
         * Enhanced with album art color analysis for multi-sensory emotion intelligence
         */
        async getAdvancedEmotionalTemperature(musicData, albumArtColors) {
          if (!this.emotionalTemperatureMapper || !musicData) {
            return null;
          }
          try {
            const analysisData = {
              energy: musicData.energy || 0.5,
              valence: musicData.valence || 0.5,
              danceability: musicData.danceability,
              tempo: musicData.tempo,
              loudness: musicData.loudness,
              acousticness: musicData.acousticness,
              instrumentalness: musicData.instrumentalness,
              speechiness: musicData.speechiness,
              mode: musicData.mode,
              key: musicData.key,
              genre: musicData.genre
            };
            const enhancedAnalysisData = await this.enhanceWithAlbumArtPsychology(
              analysisData,
              albumArtColors
            );
            const emotionalResult = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(
              enhancedAnalysisData
            );
            if (this.config?.enableDebug) {
              console.log(
                "\u{1F321}\uFE0F [ColorHarmonyEngine] Advanced emotional temperature with album art enhancement:",
                {
                  input: analysisData,
                  enhanced: enhancedAnalysisData,
                  albumArtInfluence: albumArtColors ? Object.keys(albumArtColors).length + " colors" : "None",
                  emotion: emotionalResult.primaryEmotion,
                  secondaryEmotion: emotionalResult.secondaryEmotion,
                  intensity: emotionalResult.intensity,
                  temperature: emotionalResult.temperature,
                  oklabPreset: emotionalResult.oklabPreset.name,
                  perceptualColor: emotionalResult.perceptualColorHex
                }
              );
            }
            return emotionalResult;
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Advanced emotional temperature analysis failed:",
              error
            );
            return null;
          }
        }
        /**
         * Enhance music emotion analysis with album art color psychology
         * Uses color theory and psychological associations to calibrate emotion detection
         * Creating a multi-sensory approach to artist consciousness recognition
         */
        async enhanceWithAlbumArtPsychology(originalAnalysis, albumArtColors) {
          if (!albumArtColors || Object.keys(albumArtColors).length === 0) {
            return originalAnalysis;
          }
          try {
            const colorPsychology = this.analyzeAlbumArtPsychology(albumArtColors);
            const enhanced = { ...originalAnalysis };
            const currentEnergy = enhanced.energy || 0.5;
            const currentValence = enhanced.valence || 0.5;
            if (colorPsychology.warmth > 0.6) {
              enhanced.energy = Math.min(
                1,
                currentEnergy * (1 + colorPsychology.warmth * 0.3)
              );
              enhanced.valence = Math.min(
                1,
                currentValence + colorPsychology.warmth * 0.2
              );
            }
            if (colorPsychology.coolness > 0.6) {
              enhanced.energy = Math.max(
                0,
                currentEnergy * (1 - colorPsychology.coolness * 0.2)
              );
              if (colorPsychology.saturation > 0.5) {
                enhanced.valence = Math.min(
                  1,
                  currentValence + colorPsychology.coolness * 0.15
                );
              }
            }
            if (colorPsychology.saturation > 0.7) {
              enhanced.energy = Math.min(
                1,
                currentEnergy + colorPsychology.saturation * 0.2
              );
            }
            if (colorPsychology.saturation < 0.3) {
              enhanced.valence = Math.max(0, currentValence - 0.15);
              enhanced.energy = Math.max(0, currentEnergy - 0.1);
            }
            if (colorPsychology.darkness > 0.7) {
              const finalEnergy = enhanced.energy || currentEnergy;
              if (finalEnergy > 0.6) {
                enhanced.energy = Math.min(1, finalEnergy + 0.1);
              } else {
                enhanced.valence = Math.max(
                  0,
                  (enhanced.valence || currentValence) - 0.2
                );
              }
            }
            if (colorPsychology.brightness > 0.8) {
              enhanced.valence = Math.min(
                1,
                (enhanced.valence || currentValence) + colorPsychology.brightness * 0.2
              );
            }
            if (colorPsychology.harmony > 0.8) {
              enhanced.valence = Math.min(
                1,
                (enhanced.valence || currentValence) + 0.1
              );
            } else if (colorPsychology.harmony < 0.3) {
              enhanced.energy = Math.min(
                1,
                (enhanced.energy || currentEnergy) + 0.15
              );
            }
            if (this.config?.enableDebug) {
              console.log(
                "\u{1F3A8} [ColorHarmonyEngine] Album art psychology enhancement:",
                {
                  original: {
                    energy: originalAnalysis.energy || 0.5,
                    valence: originalAnalysis.valence || 0.5
                  },
                  enhanced: {
                    energy: enhanced.energy || 0.5,
                    valence: enhanced.valence || 0.5
                  },
                  colorPsychology,
                  adjustments: {
                    energyChange: (enhanced.energy || 0.5) - (originalAnalysis.energy || 0.5),
                    valenceChange: (enhanced.valence || 0.5) - (originalAnalysis.valence || 0.5)
                  }
                }
              );
            }
            return enhanced;
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Album art psychology enhancement failed:",
              error
            );
            return originalAnalysis;
          }
        }
        /**
         * Analyze album art colors for psychological and emotional indicators
         *  PHASE 2.3: Enhanced with genre indicators and artist consciousness recognition
         * Based on color psychology research and artist expression patterns
         */
        analyzeAlbumArtPsychology(albumArtColors) {
          try {
            const colors = Object.values(albumArtColors);
            if (colors.length === 0) {
              return {
                warmth: 0.5,
                coolness: 0.5,
                saturation: 0.5,
                brightness: 0.5,
                darkness: 0.5,
                harmony: 0.5,
                dominantHue: 180,
                emotionalIntensity: 0.5,
                genreIndicators: {
                  electronicLikelihood: 0.5,
                  organicLikelihood: 0.5,
                  metalHardcoreLikelihood: 0.5,
                  popCommercialLikelihood: 0.5,
                  jazzClassicalLikelihood: 0.5,
                  folkAcousticLikelihood: 0.5
                },
                artistConsciousness: {
                  visualSophistication: 0.5,
                  artisticIntention: 0.5,
                  culturalIndicators: [],
                  emotionalDepth: 0.5
                }
              };
            }
            let totalWarmth = 0, totalCoolness = 0, totalSaturation = 0;
            let totalBrightness = 0, totalDarkness = 0;
            const hues = [];
            for (const color3 of colors) {
              const rgb = this.utils.hexToRgb(color3);
              if (!rgb) continue;
              const hsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
              const { h, s, l } = hsl;
              hues.push(h);
              if (h >= 0 && h <= 60 || h >= 300 && h <= 360) {
                totalWarmth += s * l;
              } else if (h >= 120 && h <= 240) {
                totalCoolness += s * l;
              }
              totalSaturation += s;
              totalBrightness += l;
              totalDarkness += 1 - l;
            }
            const count = colors.length;
            const avgWarmth = totalWarmth / count;
            const avgCoolness = totalCoolness / count;
            const avgSaturation = totalSaturation / count;
            const avgBrightness = totalBrightness / count;
            const avgDarkness = totalDarkness / count;
            const harmony = this.calculateColorHarmony(hues);
            const dominantHue = this.calculateDominantHue(hues);
            const emotionalIntensity = Math.min(
              1,
              (avgSaturation + this.calculateContrast(colors)) / 2
            );
            const genreIndicators = this._analyzeGenreIndicatorsFromColors({
              warmth: Math.min(1, avgWarmth),
              coolness: Math.min(1, avgCoolness),
              saturation: avgSaturation,
              brightness: avgBrightness,
              darkness: avgDarkness,
              harmony,
              dominantHue,
              emotionalIntensity
            });
            const artistConsciousness = this._analyzeArtistConsciousness(colors, {
              avgSaturation,
              avgBrightness,
              harmony,
              emotionalIntensity,
              colorCount: colors.length
            });
            return {
              warmth: Math.min(1, avgWarmth),
              coolness: Math.min(1, avgCoolness),
              saturation: avgSaturation,
              brightness: avgBrightness,
              darkness: avgDarkness,
              harmony,
              dominantHue,
              emotionalIntensity,
              genreIndicators,
              artistConsciousness
            };
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Album art psychology analysis failed:",
              error
            );
            return {
              warmth: 0.5,
              coolness: 0.5,
              saturation: 0.5,
              brightness: 0.5,
              darkness: 0.5,
              harmony: 0.5,
              dominantHue: 180,
              emotionalIntensity: 0.5,
              genreIndicators: {
                electronicLikelihood: 0.5,
                organicLikelihood: 0.5,
                metalHardcoreLikelihood: 0.5,
                popCommercialLikelihood: 0.5,
                jazzClassicalLikelihood: 0.5,
                folkAcousticLikelihood: 0.5
              },
              artistConsciousness: {
                visualSophistication: 0.5,
                artisticIntention: 0.5,
                culturalIndicators: [],
                emotionalDepth: 0.5
              }
            };
          }
        }
        /**
         * Calculate color harmony score based on hue relationships
         */
        calculateColorHarmony(hues) {
          if (hues.length <= 1) return 1;
          let harmonyScore = 0;
          const harmonyTypes = [
            60,
            // Complementary
            120,
            // Triadic
            30,
            // Analogous
            90
            // Tetradic
          ];
          for (let i = 0; i < hues.length; i++) {
            for (let j = i + 1; j < hues.length; j++) {
              const hue1 = hues[i];
              const hue2 = hues[j];
              if (hue1 === void 0 || hue2 === void 0) continue;
              const diff = Math.abs(hue1 - hue2);
              const minDiff = Math.min(diff, 360 - diff);
              for (const harmonic of harmonyTypes) {
                if (Math.abs(minDiff - harmonic) <= 15) {
                  harmonyScore += 1;
                }
              }
            }
          }
          const maxPossible = hues.length * (hues.length - 1) / 2;
          return Math.min(1, harmonyScore / maxPossible);
        }
        /**
         * Calculate dominant hue from hue array
         */
        calculateDominantHue(hues) {
          if (hues.length === 0) return 180;
          const segments = new Array(12).fill(0);
          for (const hue of hues) {
            const segment = Math.floor(hue / 30);
            segments[segment]++;
          }
          const maxSegment = segments.indexOf(Math.max(...segments));
          return maxSegment * 30 + 15;
        }
        /**
         * Calculate contrast level between colors
         */
        calculateContrast(colors) {
          if (colors.length <= 1) return 0;
          let totalContrast = 0;
          let comparisons = 0;
          for (let i = 0; i < colors.length; i++) {
            for (let j = i + 1; j < colors.length; j++) {
              const color1 = colors[i];
              const color22 = colors[j];
              if (!color1 || !color22) continue;
              const rgb1 = this.utils.hexToRgb(color1);
              const rgb2 = this.utils.hexToRgb(color22);
              if (rgb1 && rgb2) {
                const lum1 = (rgb1.r * 0.299 + rgb1.g * 0.587 + rgb1.b * 0.114) / 255;
                const lum2 = (rgb2.r * 0.299 + rgb2.g * 0.587 + rgb2.b * 0.114) / 255;
                totalContrast += Math.abs(lum1 - lum2);
                comparisons++;
              }
            }
          }
          return comparisons > 0 ? totalContrast / comparisons : 0;
        }
        /**
         * Blend colors using advanced OKLAB processing for perceptually uniform results
         */
        async blendWithAdvancedOKLAB(rawColors, musicData, emotionalTemperature, genreData) {
          const processedColors = { ...rawColors };
          try {
            const optimalPreset = emotionalTemperature?.oklabPreset || this.oklabState.currentPreset;
            let genreAdjustedPreset = optimalPreset;
            if (genreData && genreData.confidence > 0.5 && this.genreState.genreInfluenceIntensity > 0) {
              genreAdjustedPreset = this.applyGenreColorAesthetics(
                optimalPreset,
                genreData
              );
            }
            const colorPriorities = [
              "PRIMARY",
              "VIBRANT",
              "PROMINENT",
              "VIBRANT_NON_ALARMING",
              "LIGHT_VIBRANT"
            ];
            for (const colorKey of colorPriorities) {
              const colorHex = rawColors[colorKey];
              if (colorHex && this.isValidHex(colorHex)) {
                try {
                  const genreKey = genreData ? `-${genreData.genre}` : "";
                  const cacheKey = `${colorHex}-${genreAdjustedPreset.name}${genreKey}`;
                  if (this.oklabState.processedPalette[cacheKey]) {
                    processedColors[colorKey] = this.oklabState.processedPalette[cacheKey].enhancedHex;
                    continue;
                  }
                  const oklabResult = this.oklabProcessor.processColor(
                    colorHex,
                    genreAdjustedPreset
                  );
                  processedColors[colorKey] = oklabResult.enhancedHex;
                  this.oklabState.processedPalette[cacheKey] = oklabResult;
                  if (this.config?.enableDebug) {
                    console.log(
                      `\u{1F3A8} [ColorHarmonyEngine] OKLAB enhanced ${colorKey}:`,
                      {
                        original: colorHex,
                        enhanced: oklabResult.enhancedHex,
                        preset: optimalPreset.name,
                        processingTime: oklabResult.processingTime
                      }
                    );
                  }
                } catch (error) {
                  console.warn(
                    `[ColorHarmonyEngine] OKLAB processing failed for ${colorKey}:`,
                    error
                  );
                }
              }
            }
            if (emotionalTemperature?.perceptualColorHex && processedColors.PRIMARY) {
              try {
                const blendResult = this.oklabProcessor.interpolateOKLAB(
                  processedColors.PRIMARY,
                  emotionalTemperature.perceptualColorHex,
                  emotionalTemperature.intensity * 0.3,
                  // Blend factor based on intensity
                  optimalPreset
                );
                processedColors.EMOTIONAL_BLEND = blendResult.enhancedHex;
                if (this.config?.enableDebug) {
                  console.log("\u{1F321}\uFE0F [ColorHarmonyEngine] Emotional color blending:", {
                    primary: processedColors.PRIMARY,
                    emotionalColor: emotionalTemperature.perceptualColorHex,
                    blendFactor: emotionalTemperature.intensity * 0.3,
                    result: blendResult.enhancedHex
                  });
                }
              } catch (error) {
                console.warn(
                  "[ColorHarmonyEngine] Emotional color blending failed:",
                  error
                );
              }
            }
            this.oklabState.lastProcessingTime = Date.now();
            const albumArtInfluence = this.getAlbumArtInfluenceSetting();
            if (albumArtInfluence > 0 && rawColors && Object.keys(rawColors).length > 0) {
              try {
                const albumBlendedColors = await this._applyDirectAlbumColorBlending(
                  processedColors,
                  rawColors,
                  albumArtInfluence,
                  genreAdjustedPreset
                );
                Object.assign(processedColors, albumBlendedColors);
                if (this.config?.enableDebug) {
                  console.log(
                    "\u{1F3A8} [ColorHarmonyEngine] Applied direct album color blending:",
                    {
                      albumInfluence: (albumArtInfluence * 100).toFixed(1) + "%",
                      blendedKeys: Object.keys(albumBlendedColors),
                      note: "album colors now directly influence final UI colors"
                    }
                  );
                }
              } catch (error) {
                console.warn(
                  "[ColorHarmonyEngine] Direct album color blending failed:",
                  error
                );
              }
            }
            if (this.semanticColorManager) {
              try {
                this.semanticColorManager.updateWithAlbumColors(processedColors);
                if (this.config?.enableDebug) {
                  console.log(
                    "\u{1F3A8} [ColorHarmonyEngine] Applied comprehensive Spicetify variable updates via strategy pattern:",
                    {
                      processedColorCount: Object.keys(processedColors).length,
                      methodUsed: "blendWithAdvancedOKLAB"
                    }
                  );
                }
              } catch (error) {
                console.warn(
                  "[ColorHarmonyEngine] Failed to update Spicetify variables via strategy pattern:",
                  error
                );
              }
            }
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Advanced OKLAB blending failed:",
              error
            );
          }
          return processedColors;
        }
        /**
         * Generate advanced CSS variables with comprehensive OKLAB integration
         */
        generateAdvancedOKLABCSSVariables(result) {
          const cssVariables = {};
          try {
            Object.entries(result.processedColors).forEach(([key, value]) => {
              if (value && typeof value === "string") {
                cssVariables[`--sn-processed-${key.toLowerCase()}`] = value;
              }
            });
            Object.entries(this.oklabState.processedPalette).forEach(
              ([cacheKey, oklabResult]) => {
                const [originalColor, presetName] = cacheKey.split("-");
                if (originalColor && presetName) {
                  const prefix = `sn-oklab-${presetName.toLowerCase()}`;
                  const oklabVars = this.oklabProcessor.generateCSSVariables(
                    oklabResult,
                    prefix
                  );
                  Object.assign(cssVariables, oklabVars);
                }
              }
            );
            if (this.oklabState.perceptualGradientCache.size > 0) {
              const gradientEntries = Array.from(
                this.oklabState.perceptualGradientCache.entries()
              );
              const [gradientKey, gradientStops] = gradientEntries[0] || [];
              if (gradientStops && gradientStops.length > 0) {
                gradientStops.forEach((stop, index) => {
                  const percentage = index / (gradientStops.length - 1) * 100;
                  cssVariables[`--sn-oklab-gradient-stop-${index}`] = stop.enhancedHex;
                  cssVariables[`--sn-oklab-gradient-stop-${index}-rgb`] = `${stop.enhancedRgb.r},${stop.enhancedRgb.g},${stop.enhancedRgb.b}`;
                  cssVariables[`--sn-oklab-gradient-stop-${index}-pos`] = `${percentage}%`;
                });
                const gradientString = gradientStops.map((stop, index) => {
                  const percentage = index / (gradientStops.length - 1) * 100;
                  return `${stop.enhancedHex} ${percentage}%`;
                }).join(", ");
                cssVariables["--sn-oklab-perceptual-gradient"] = `linear-gradient(135deg, ${gradientString})`;
                cssVariables["--sn-oklab-gradient-stop-count"] = gradientStops.length.toString();
              }
            }
            if (result.processedColors.EMOTIONAL_BLEND) {
              cssVariables["--sn-consciousness-emotional-color"] = result.processedColors.EMOTIONAL_BLEND;
              const emotionalRgb = hexToRgb(
                result.processedColors.EMOTIONAL_BLEND
              );
              if (emotionalRgb) {
                cssVariables["--sn-consciousness-emotional-rgb"] = `${emotionalRgb.r},${emotionalRgb.g},${emotionalRgb.b}`;
              }
            }
            cssVariables["--sn-oklab-preset-active"] = this.oklabState.currentPreset.name;
            cssVariables["--sn-oklab-cache-size"] = Object.keys(
              this.oklabState.processedPalette
            ).length.toString();
            cssVariables["--sn-oklab-last-processing"] = this.oklabState.lastProcessingTime.toString();
            if (this.config?.enableDebug) {
              console.log(
                "\u{1F3A8} [ColorHarmonyEngine] Generated advanced OKLAB CSS variables:",
                {
                  totalVariables: Object.keys(cssVariables).length,
                  gradientStops: this.oklabState.perceptualGradientCache.size,
                  oklabProcessedColors: Object.keys(this.oklabState.processedPalette).length
                }
              );
            }
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Advanced OKLAB CSS variable generation failed:",
              error
            );
          }
          return cssVariables;
        }
        /**
         * Generate perceptual gradient data using OKLAB interpolation for smooth color transitions
         */
        generatePerceptualGradientData(result) {
          try {
            const primaryColor = result.processedColors.PRIMARY;
            const secondaryColor = result.processedColors.SECONDARY || result.processedColors.EMOTIONAL_BLEND;
            if (!primaryColor || !this.isValidHex(primaryColor)) {
              return;
            }
            const startColor = primaryColor;
            const endColor = secondaryColor && this.isValidHex(secondaryColor) ? secondaryColor : this.generateComplementaryColor(primaryColor);
            const gradientKey = `${startColor}-${endColor}-${this.oklabState.currentPreset.name}`;
            if (this.oklabState.perceptualGradientCache.has(gradientKey)) {
              return;
            }
            const stopCount = 7;
            const gradientStops = this.oklabProcessor.generateOKLABGradient(
              startColor,
              endColor,
              stopCount,
              this.oklabState.currentPreset
            );
            this.oklabState.perceptualGradientCache.set(gradientKey, gradientStops);
            if (this.oklabState.perceptualGradientCache.size > 10) {
              const firstKey = this.oklabState.perceptualGradientCache.keys().next().value;
              if (firstKey) {
                this.oklabState.perceptualGradientCache.delete(firstKey);
              }
            }
            if (this.config?.enableDebug) {
              console.log(
                "\u{1F308} [ColorHarmonyEngine] Generated perceptual gradient data:",
                {
                  startColor,
                  endColor,
                  stopCount,
                  preset: this.oklabState.currentPreset.name,
                  cacheKey: gradientKey,
                  cacheSize: this.oklabState.perceptualGradientCache.size
                }
              );
            }
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Perceptual gradient generation failed:",
              error
            );
          }
        }
        /**
         * Update advanced harmony metrics with comprehensive performance and quality tracking
         */
        updateAdvancedHarmonyMetrics(result, processingTime) {
          try {
            const primaryColor = result.processedColors.PRIMARY;
            const secondaryColor = result.processedColors.SECONDARY;
            let harmonyScore = 0.5;
            if (primaryColor && this.isValidHex(primaryColor)) {
              const primaryRgb = hexToRgb(primaryColor);
              if (primaryRgb) {
                const vibrancy = this.calculateColorVibrancy(primaryRgb);
                harmonyScore = Math.min(1, vibrancy * 0.8 + 0.2);
              }
            }
            const metrics = {
              processingTime,
              harmonyScore,
              oklabProcessedColors: Object.keys(this.oklabState.processedPalette).length,
              perceptualGradientsCached: this.oklabState.perceptualGradientCache.size,
              currentPreset: this.oklabState.currentPreset.name,
              lastUpdate: Date.now()
            };
            if (result.metadata) {
              result.metadata.advancedHarmonyMetrics = metrics;
            }
            if (this.config?.enableDebug) {
              console.log(
                "\u{1F4CA} [ColorHarmonyEngine] Advanced harmony metrics updated:",
                metrics
              );
            }
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Advanced harmony metrics update failed:",
              error
            );
          }
        }
        // ============================================================================
        //  UTILITY METHODS FOR ENHANCED OKLAB INTEGRATION
        // ============================================================================
        /**
         * Get preset selection reasoning for debugging
         */
        getPresetSelectionReason(musicData, context) {
          if (!musicData) return "No music data available";
          const { energy = 0.5, valence = 0.5 } = musicData;
          if (context.performanceHints?.preferLightweight)
            return "Performance optimization requested";
          if (energy > 0.8 && valence > 0.7) return "High energy + positive valence";
          if (energy > 0.7 && valence < 0.4) return "High energy + negative valence";
          if (energy < 0.3) return "Low energy music";
          return "Standard balanced processing";
        }
        /**
         * Generate complementary color for gradient endpoints
         */
        generateComplementaryColor(hexColor) {
          try {
            const rgb = hexToRgb(hexColor);
            if (!rgb) return hexColor;
            const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
            const complementHue = (hsl.h + 180) % 360;
            const complementRgb = this.hslToRgb(complementHue, hsl.s, hsl.l);
            return rgbToHex(
              complementRgb.r,
              complementRgb.g,
              complementRgb.b
            );
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Complementary color generation failed:",
              error
            );
            return hexColor;
          }
        }
        /**
         * Calculate color vibrancy metric (0-1)
         */
        calculateColorVibrancy(rgb) {
          const max = Math.max(rgb.r, rgb.g, rgb.b);
          const min = Math.min(rgb.r, rgb.g, rgb.b);
          const delta = max - min;
          if (max === 0) return 0;
          const saturation = delta / max;
          const lightness = max / 255;
          const lightnessFactor = 1 - Math.abs(lightness - 0.5) * 2;
          return saturation * lightnessFactor;
        }
        /**
         * Validate hex color format
         */
        isValidHex(hex) {
          return /^#[0-9A-Fa-f]{6}$/.test(hex);
        }
        /**
         * Convert RGB to HSL color space
         */
        rgbToHsl(r, g, b) {
          r /= 255;
          g /= 255;
          b /= 255;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const delta = max - min;
          let h = 0;
          let s = 0;
          const l = (max + min) / 2;
          if (delta !== 0) {
            s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
            switch (max) {
              case r:
                h = (g - b) / delta + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / delta + 2;
                break;
              case b:
                h = (r - g) / delta + 4;
                break;
            }
            h /= 6;
          }
          return { h: h * 360, s, l };
        }
        /**
         * Convert HSL to RGB color space
         */
        hslToRgb(h, s, l) {
          h /= 360;
          const hue2rgb = /* @__PURE__ */ __name((p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          }, "hue2rgb");
          let r, g, b;
          if (s === 0) {
            r = g = b = l;
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
          };
        }
        // ============================================================================
        // GENRE AESTHETIC INTELLIGENCE METHODS
        // ============================================================================
        /**
         * Analyze current music for genre-specific aesthetic characteristics
         */
        async analyzeGenreAesthetics(musicData, albumArtColors) {
          try {
            if (!this.genreGradientEvolution) {
              return null;
            }
            const currentGenre = this.genreGradientEvolution.getCurrentGenre();
            const genreConfidence = this.genreGradientEvolution.getGenreConfidence();
            if (genreConfidence < 0.3) {
              return null;
            }
            const genreCharacteristics = this.genreGradientEvolution.getGenreCharacteristics(currentGenre);
            const genreVisualStyle = this.genreGradientEvolution.getGenreVisualStyle(currentGenre);
            let albumGenreHarmonyScore = 1;
            let genreValidatedByAlbumColors = genreConfidence;
            if (albumArtColors && Object.keys(albumArtColors).length > 0) {
              try {
                const albumColorAnalysis = this._analyzeAlbumGenreHarmony(
                  albumArtColors,
                  currentGenre,
                  genreCharacteristics
                );
                albumGenreHarmonyScore = albumColorAnalysis.harmonyScore;
                genreValidatedByAlbumColors = genreConfidence * albumGenreHarmonyScore;
                if (this.config.enableDebug) {
                  console.log(
                    `\u{1F3A8} [ColorHarmonyEngine] Album-Genre harmony analysis:`,
                    {
                      genre: currentGenre,
                      originalConfidence: (genreConfidence * 100).toFixed(1) + "%",
                      harmonyScore: (albumGenreHarmonyScore * 100).toFixed(1) + "%",
                      validatedConfidence: (genreValidatedByAlbumColors * 100).toFixed(1) + "%",
                      albumColorCount: Object.keys(albumArtColors).length
                    }
                  );
                }
              } catch (error) {
                console.warn(
                  "[ColorHarmonyEngine] Album-genre harmony analysis failed:",
                  error
                );
              }
            }
            this.genreState.currentGenre = currentGenre;
            this.genreState.genreConfidence = genreValidatedByAlbumColors;
            this.genreState.lastGenreUpdate = Date.now();
            this.genreState.genreHistory.unshift({
              genre: currentGenre,
              confidence: genreValidatedByAlbumColors,
              // Use album-enhanced confidence
              timestamp: Date.now()
            });
            if (this.genreState.genreHistory.length > 10) {
              this.genreState.genreHistory = this.genreState.genreHistory.slice(
                0,
                10
              );
            }
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3B6} [ColorHarmonyEngine] Genre aesthetic analysis: ${currentGenre} (${(genreValidatedByAlbumColors * 100).toFixed(1)}% album-validated confidence)`
              );
            }
            return {
              genre: currentGenre,
              confidence: genreValidatedByAlbumColors,
              // Return album-enhanced confidence
              characteristics: genreCharacteristics,
              visualStyle: genreVisualStyle
            };
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Error analyzing genre aesthetics:",
              error
            );
            return null;
          }
        }
        /**
         * Apply genre-specific characteristics to OKLAB color preset
         */
        applyGenreColorAesthetics(basePreset, genreData) {
          const { characteristics, visualStyle, confidence } = genreData;
          const genreAdjustedPreset = {
            ...basePreset,
            name: `${basePreset.name}-${genreData.genre}`,
            description: `${basePreset.description} with ${genreData.genre} aesthetic characteristics`
          };
          const genreInfluence = confidence * this.genreState.genreInfluenceIntensity;
          if (characteristics.saturation > 0.7) {
            genreAdjustedPreset.chromaBoost = Math.min(
              2,
              basePreset.chromaBoost + 0.3 * genreInfluence
            );
          } else if (characteristics.saturation < 0.3) {
            genreAdjustedPreset.chromaBoost = Math.max(
              0.8,
              basePreset.chromaBoost - 0.2 * genreInfluence
            );
          }
          if (characteristics.harmonicComplexity > 0.7) {
            genreAdjustedPreset.vibrantThreshold = Math.max(
              0.05,
              basePreset.vibrantThreshold - 0.05 * genreInfluence
            );
          } else if (characteristics.harmonicComplexity < 0.3) {
            genreAdjustedPreset.vibrantThreshold = Math.min(
              0.2,
              basePreset.vibrantThreshold + 0.03 * genreInfluence
            );
          }
          if (characteristics.emotionalRange > 0.7 && characteristics.organicness > 0.6) {
            genreAdjustedPreset.lightnessBoost = Math.max(
              0.9,
              basePreset.lightnessBoost - 0.1 * genreInfluence
            );
          } else if (characteristics.artificialProcessing > 0.7) {
            genreAdjustedPreset.lightnessBoost = Math.min(
              1.4,
              basePreset.lightnessBoost + 0.2 * genreInfluence
            );
          }
          if (visualStyle.contrastLevel > 0.7) {
            genreAdjustedPreset.shadowReduction = Math.max(
              0.1,
              basePreset.shadowReduction - 0.1 * genreInfluence
            );
          } else if (characteristics.organicness > 0.6) {
            genreAdjustedPreset.shadowReduction = Math.min(
              0.5,
              basePreset.shadowReduction + 0.1 * genreInfluence
            );
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F3A8} [ColorHarmonyEngine] Applied ${genreData.genre} aesthetics to ${basePreset.name} preset:`,
              {
                chromaBoost: `${basePreset.chromaBoost} \u2192 ${genreAdjustedPreset.chromaBoost}`,
                lightnessBoost: `${basePreset.lightnessBoost} \u2192 ${genreAdjustedPreset.lightnessBoost}`,
                vibrantThreshold: `${basePreset.vibrantThreshold} \u2192 ${genreAdjustedPreset.vibrantThreshold}`,
                genreInfluence: `${(genreInfluence * 100).toFixed(1)}%`
              }
            );
          }
          return genreAdjustedPreset;
        }
        /**
         *  PHASE 2.1: Analyze album color harmony with detected genre for enhanced validation
         */
        _analyzeAlbumGenreHarmony(albumArtColors, genre, genreCharacteristics) {
          try {
            let harmonyScore = 1;
            let explanationParts = [];
            const albumHslColors = Object.entries(albumArtColors).map(([role, hex]) => {
              const rgb = this.utils.hexToRgb(hex);
              return rgb ? this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b) : null;
            }).filter((hsl) => hsl !== null);
            if (albumHslColors.length === 0) {
              return {
                harmonyScore: 1,
                explanation: "No valid album colors found"
              };
            }
            const avgSaturation = albumHslColors.reduce((sum, hsl) => sum + hsl.s, 0) / albumHslColors.length;
            const expectedSaturation = genreCharacteristics.saturation || 0.5;
            const saturationDiff = Math.abs(avgSaturation / 100 - expectedSaturation);
            if (saturationDiff < 0.2) {
              harmonyScore *= 1.1;
              explanationParts.push(
                `album saturation matches genre (\xB1${(saturationDiff * 100).toFixed(
                  1
                )}%)`
              );
            } else if (saturationDiff > 0.4) {
              harmonyScore *= 0.85;
              explanationParts.push(
                `album saturation differs from genre expectations (${(saturationDiff * 100).toFixed(1)}% diff)`
              );
            }
            const avgHue = albumHslColors.reduce((sum, hsl) => sum + hsl.h, 0) / albumHslColors.length;
            const isWarmAlbum = avgHue >= 15 && avgHue <= 45 || avgHue >= 315 && avgHue <= 345;
            const isCoolAlbum = avgHue >= 180 && avgHue <= 270;
            const expectedWarmth = genreCharacteristics.energyLevel || 0.5;
            if (expectedWarmth > 0.6 && isWarmAlbum) {
              harmonyScore *= 1.15;
              explanationParts.push("warm album colors match high-energy genre");
            } else if (expectedWarmth < 0.4 && isCoolAlbum) {
              harmonyScore *= 1.1;
              explanationParts.push("cool album colors match low-energy genre");
            } else if (expectedWarmth > 0.6 && isCoolAlbum || expectedWarmth < 0.4 && isWarmAlbum) {
              harmonyScore *= 0.9;
              explanationParts.push(
                "album color temperature differs from genre energy"
              );
            }
            const avgLightness = albumHslColors.reduce((sum, hsl) => sum + hsl.l, 0) / albumHslColors.length;
            const isDarkAlbum = avgLightness < 40;
            const isBrightAlbum = avgLightness > 70;
            if (genre.includes("metal") || genre.includes("goth") || genre.includes("dark")) {
              if (isDarkAlbum) {
                harmonyScore *= 1.2;
                explanationParts.push("dark album aesthetic matches genre");
              } else if (isBrightAlbum) {
                harmonyScore *= 0.8;
                explanationParts.push(
                  "bright album conflicts with dark genre aesthetic"
                );
              }
            } else if (genre.includes("pop") || genre.includes("dance") || genre.includes("electronic")) {
              if (isBrightAlbum) {
                harmonyScore *= 1.15;
                explanationParts.push(
                  "bright album aesthetic matches energetic genre"
                );
              }
            }
            const colorHues = albumHslColors.map((hsl) => hsl.h);
            const hueSpread = Math.max(...colorHues) - Math.min(...colorHues);
            const isMonochromatic = hueSpread < 30;
            const isPolychromatic = hueSpread > 120;
            const expectedComplexity = genreCharacteristics.harmonicComplexity || 0.5;
            if (expectedComplexity > 0.7 && isPolychromatic) {
              harmonyScore *= 1.1;
              explanationParts.push("diverse album colors match complex genre");
            } else if (expectedComplexity < 0.3 && isMonochromatic) {
              harmonyScore *= 1.1;
              explanationParts.push("unified album colors match simple genre");
            }
            harmonyScore = Math.max(0.7, Math.min(1.3, harmonyScore));
            const explanation = explanationParts.length > 0 ? explanationParts.join("; ") : "album colors analyzed for genre harmony";
            return {
              harmonyScore,
              explanation
            };
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Album-genre harmony analysis error:",
              error
            );
            return {
              harmonyScore: 1,
              explanation: "harmony analysis failed, using default confidence"
            };
          }
        }
        /**
         *  PHASE 2.2: Get album art influence setting (0-1) for user control
         */
        getAlbumArtInfluenceSetting() {
          return 0.5;
        }
        /**
         *  PHASE 2.2: Apply direct album color blending using OKLAB for perceptual uniformity
         */
        async _applyDirectAlbumColorBlending(processedColors, albumArtColors, albumInfluence, oklabPreset) {
          const blendedColors = {};
          try {
            const albumDominantColors = this._extractDominantAlbumColors(albumArtColors);
            if (albumDominantColors.length === 0) {
              return {};
            }
            const blendTargets = [
              "PRIMARY",
              "VIBRANT",
              "PROMINENT",
              "VIBRANT_NON_ALARMING"
            ];
            for (const colorKey of blendTargets) {
              const processedColor = processedColors[colorKey];
              if (!processedColor || !this.isValidHex(processedColor)) {
                continue;
              }
              try {
                const bestAlbumColor = this._selectHarmoniousAlbumColor(
                  processedColor,
                  albumDominantColors
                );
                if (bestAlbumColor) {
                  const blendResult = this.oklabProcessor.interpolateOKLAB(
                    processedColor,
                    bestAlbumColor,
                    albumInfluence * 0.6,
                    // Scale down for subtle but noticeable effect
                    oklabPreset
                  );
                  blendedColors[colorKey] = blendResult.enhancedHex;
                  if (this.config?.enableDebug) {
                    console.log(
                      `\u{1F3A8} [ColorHarmonyEngine] Album-blended ${colorKey}:`,
                      {
                        original: processedColor,
                        albumColor: bestAlbumColor,
                        blended: blendResult.enhancedHex,
                        blendFactor: (albumInfluence * 0.6).toFixed(2)
                      }
                    );
                  }
                }
              } catch (error) {
                console.warn(
                  `[ColorHarmonyEngine] Album blending failed for ${colorKey}:`,
                  error
                );
              }
            }
            if (albumDominantColors.length > 0 && albumInfluence > 0.3) {
              try {
                const mostVibrantAlbum = this._selectMostVibrantColor(albumDominantColors);
                if (mostVibrantAlbum) {
                  const albumAccentResult = this.oklabProcessor.processColor(
                    mostVibrantAlbum,
                    oklabPreset
                  );
                  blendedColors["ALBUM_ACCENT"] = albumAccentResult.enhancedHex;
                  if (this.config?.enableDebug) {
                    console.log("\u{1F3A8} [ColorHarmonyEngine] Created ALBUM_ACCENT:", {
                      source: mostVibrantAlbum,
                      enhanced: albumAccentResult.enhancedHex
                    });
                  }
                }
              } catch (error) {
                console.warn(
                  "[ColorHarmonyEngine] Album accent creation failed:",
                  error
                );
              }
            }
            return blendedColors;
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Direct album color blending error:",
              error
            );
            return {};
          }
        }
        /**
         *  PHASE 2.2: Extract dominant colors from album art for blending
         */
        _extractDominantAlbumColors(albumArtColors) {
          const dominantColors = [];
          const colorPriorities = [
            "VIBRANT",
            "DOMINANT",
            "PRIMARY",
            "PROMINENT",
            "LIGHT_VIBRANT",
            "DARK_VIBRANT"
          ];
          for (const priority of colorPriorities) {
            const color3 = albumArtColors[priority];
            if (color3 && this.isValidHex(color3)) {
              dominantColors.push(color3);
            }
          }
          if (dominantColors.length < 3) {
            Object.values(albumArtColors).forEach((color3) => {
              if (color3 && this.isValidHex(color3) && !dominantColors.includes(color3)) {
                dominantColors.push(color3);
              }
            });
          }
          return dominantColors.slice(0, 5);
        }
        /**
         *  PHASE 2.2: Select the most harmonious album color for blending with a processed color
         */
        _selectHarmoniousAlbumColor(processedColor, albumColors) {
          if (albumColors.length === 0) return null;
          try {
            const processedRgb = this.utils.hexToRgb(processedColor);
            if (!processedRgb) return albumColors[0] || null;
            const processedHsl = this.utils.rgbToHsl(
              processedRgb.r,
              processedRgb.g,
              processedRgb.b
            );
            let bestColor = albumColors[0] || null;
            let bestHarmonyScore = 0;
            for (const albumColor of albumColors) {
              const albumRgb = this.utils.hexToRgb(albumColor);
              if (!albumRgb) continue;
              const albumHsl = this.utils.rgbToHsl(
                albumRgb.r,
                albumRgb.g,
                albumRgb.b
              );
              const hueDiff = Math.abs(processedHsl.h - albumHsl.h);
              const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);
              let harmonyScore = 0;
              if (normalizedHueDiff < 30) {
                harmonyScore = 0.9;
              } else if (normalizedHueDiff > 150 && normalizedHueDiff < 210) {
                harmonyScore = 0.8;
              } else if (normalizedHueDiff > 90 && normalizedHueDiff < 150) {
                harmonyScore = 0.6;
              } else {
                harmonyScore = 0.4;
              }
              const saturationDiff = Math.abs(processedHsl.s - albumHsl.s);
              if (saturationDiff < 20) {
                harmonyScore += 0.1;
              }
              if (harmonyScore > bestHarmonyScore) {
                bestHarmonyScore = harmonyScore;
                bestColor = albumColor;
              }
            }
            return bestColor;
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Harmonious color selection failed:",
              error
            );
            return albumColors[0] || null;
          }
        }
        /**
         *  PHASE 2.2: Select the most vibrant color from album colors
         */
        _selectMostVibrantColor(albumColors) {
          if (albumColors.length === 0) return null;
          try {
            let mostVibrant = albumColors[0] || null;
            let highestVibrancy = 0;
            for (const color3 of albumColors) {
              const rgb = this.utils.hexToRgb(color3);
              if (!rgb) continue;
              const hsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
              const vibrancy = hsl.s / 100 * (1 - Math.abs(hsl.l - 50) / 50);
              if (vibrancy > highestVibrancy) {
                highestVibrancy = vibrancy;
                mostVibrant = color3;
              }
            }
            return mostVibrant;
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Most vibrant color selection failed:",
              error
            );
            return albumColors[0] || null;
          }
        }
        /**
         *  PHASE 2.3: Analyze genre indicators from color psychology characteristics
         */
        _analyzeGenreIndicatorsFromColors(colorPsychology) {
          const {
            warmth,
            coolness,
            saturation,
            brightness,
            darkness,
            harmony,
            dominantHue,
            emotionalIntensity
          } = colorPsychology;
          const electronicLikelihood = Math.min(
            1,
            saturation * 0.4 + coolness * 0.3 + (brightness > 0.7 || darkness < 0.3 ? 0.2 : 0) + (dominantHue >= 180 && dominantHue <= 270 ? 0.1 : 0)
            // Blues/cyans
          );
          const organicLikelihood = Math.min(
            1,
            (warmth > coolness ? warmth : 0) * 0.3 + (saturation >= 0.3 && saturation <= 0.7 ? 0.3 : 0) + (brightness >= 0.4 && brightness <= 0.7 ? 0.2 : 0) + harmony * 0.2
            // Natural colors tend to be harmonious
          );
          const metalHardcoreLikelihood = Math.min(
            1,
            darkness * 0.4 + emotionalIntensity * 0.3 + (dominantHue >= 0 && dominantHue <= 30 || dominantHue >= 330 ? 0.2 : 0) + // Reds
            (saturation > 0.6 || saturation < 0.2 ? 0.1 : 0)
            // High contrast
          );
          const popCommercialLikelihood = Math.min(
            1,
            (brightness > 0.6 ? brightness * 0.3 : 0) + saturation * 0.3 + (warmth > 0.5 ? warmth * 0.2 : 0) + (emotionalIntensity > 0.5 ? 0.2 : 0)
          );
          const jazzClassicalLikelihood = Math.min(
            1,
            harmony * 0.4 + (saturation >= 0.4 && saturation <= 0.8 ? 0.3 : 0) + (brightness >= 0.3 && brightness <= 0.8 ? 0.2 : 0) + (warmth + coolness) / 2 * 0.1
            // Balanced temperature
          );
          const folkAcousticLikelihood = Math.min(
            1,
            warmth * 0.4 + (saturation >= 0.2 && saturation <= 0.6 ? 0.3 : 0) + harmony * 0.2 + (dominantHue >= 15 && dominantHue <= 60 ? 0.1 : 0)
            // Earth tones (oranges/browns)
          );
          return {
            electronicLikelihood,
            organicLikelihood,
            metalHardcoreLikelihood,
            popCommercialLikelihood,
            jazzClassicalLikelihood,
            folkAcousticLikelihood
          };
        }
        /**
         *  PHASE 2.3: Analyze artist consciousness through color sophistication and intention
         */
        _analyzeArtistConsciousness(colors, metrics) {
          const {
            avgSaturation,
            avgBrightness,
            harmony,
            emotionalIntensity,
            colorCount
          } = metrics;
          const visualSophistication = Math.min(
            1,
            harmony * 0.4 + // Good color relationships indicate sophistication
            (colorCount > 2 && colorCount <= 5 ? 0.3 : 0.1) + // Appropriate complexity
            (avgSaturation >= 0.3 && avgSaturation <= 0.8 ? 0.2 : 0) + // Balanced saturation
            (avgBrightness >= 0.2 && avgBrightness <= 0.8 ? 0.1 : 0)
            // Appropriate brightness range
          );
          const artisticIntention = Math.min(
            1,
            harmony * 0.5 + // Harmonious colors suggest intention
            emotionalIntensity * 0.3 + // Strong emotional content suggests purpose
            (colorCount >= 2 && colorCount <= 4 ? 0.2 : 0)
            // Focused palette suggests curation
          );
          const culturalIndicators = [];
          if (avgSaturation > 0.8 && emotionalIntensity > 0.7) {
            culturalIndicators.push("high-energy-culture");
          }
          if (harmony > 0.7 && avgSaturation < 0.6) {
            culturalIndicators.push("minimalist-aesthetic");
          }
          if (avgBrightness < 0.3 && emotionalIntensity > 0.6) {
            culturalIndicators.push("dark-artistic");
          }
          if (avgBrightness > 0.7 && avgSaturation > 0.6) {
            culturalIndicators.push("commercial-pop");
          }
          const emotionalDepth = Math.min(
            1,
            emotionalIntensity * 0.5 + (avgSaturation > 0.4 ? 0.2 : 0) + // Saturated colors convey more emotion
            (harmony > 0.5 ? 0.2 : 0) + // Harmonious colors suggest emotional maturity
            (colorCount >= 3 ? 0.1 : 0)
            // Multiple colors allow for emotional complexity
          );
          return {
            visualSophistication,
            artisticIntention,
            culturalIndicators,
            emotionalDepth
          };
        }
      };
      __name(_ColorHarmonyEngine, "ColorHarmonyEngine");
      /**
       * Canonical accent CSS custom property names.
       *   `--sn-accent-hex`  : Hex string (e.g. "#cba6f7")
       *   `--sn-accent-rgb`  : Comma-separated R,G,B channels (e.g. "203,166,247")
       *
       * These are written by the Year3000System colour pipeline and are considered
       * the single source-of-truth accent accessed by SCSS and visual systems.
       */
      _ColorHarmonyEngine.CANONICAL_HEX_VAR = "--sn-accent-hex";
      _ColorHarmonyEngine.CANONICAL_RGB_VAR = "--sn-accent-rgb";
      ColorHarmonyEngine = _ColorHarmonyEngine;
    }
  });

  // src-js/utils/platform/SpicetifyCompat.ts
  var _SpicetifyCompat, SpicetifyCompat;
  var init_SpicetifyCompat = __esm({
    "src-js/utils/platform/SpicetifyCompat.ts"() {
      "use strict";
      _SpicetifyCompat = class _SpicetifyCompat {
        /**
         * Get audio data with fallback handling
         * Uses correct Spicetify.getAudioData() API with fallback to legacy patterns
         */
        static async getAudioData() {
          try {
            if (typeof Spicetify !== "undefined" && Spicetify.getAudioData) {
              return await Spicetify.getAudioData();
            } else {
              console.warn("[SpicetifyCompat] Spicetify.getAudioData not available");
              return null;
            }
          } catch (error) {
            console.error("[SpicetifyCompat] Error fetching audio data:", error);
            return null;
          }
        }
        /**
         * Check if Spicetify APIs are available
         */
        static isAvailable() {
          return typeof Spicetify !== "undefined" && !!Spicetify.getAudioData;
        }
        /**
         * Retry wrapper for audio data fetching
         */
        static async getAudioDataWithRetry(retryDelay = 200, maxRetries = 10) {
          for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
              const audioData = await this.getAudioData();
              if (audioData) {
                return audioData;
              }
            } catch (error) {
              if (attempt < maxRetries - 1) {
                console.log(
                  `[SpicetifyCompat] Retrying audio data fetch (${attempt + 1}/${maxRetries})...`
                );
                await new Promise((resolve) => setTimeout(resolve, retryDelay));
              } else {
                console.warn(
                  `[SpicetifyCompat] Audio data fetch failed after ${maxRetries} attempts:`,
                  error
                );
              }
            }
          }
          return null;
        }
      };
      __name(_SpicetifyCompat, "SpicetifyCompat");
      SpicetifyCompat = _SpicetifyCompat;
    }
  });

  // src-js/audio/GenreProfileManager.ts
  var GENRE_PROFILES, _GenreProfileManager, GenreProfileManager;
  var init_GenreProfileManager = __esm({
    "src-js/audio/GenreProfileManager.ts"() {
      "use strict";
      init_globalConfig();
      init_OKLABColorProcessor();
      GENRE_PROFILES = {
        // Electronic genres - high energy, vibrant colors with dynamic range
        electronic: {
          energyBoost: 1.1,
          beatEmphasis: 1.2,
          precision: 0.9,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "dynamic"
          }
        },
        dance: {
          energyBoost: 1.2,
          beatEmphasis: 1.25,
          precision: 0.95,
          oklabPreset: "COSMIC",
          colorCharacteristics: {
            vibrancyLevel: "cosmic",
            emotionalRange: "extreme",
            colorTemperature: "dynamic"
          }
        },
        house: {
          energyBoost: 1.2,
          beatEmphasis: 1.25,
          precision: 0.95,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        techno: {
          energyBoost: 1.15,
          beatEmphasis: 1.3,
          precision: 1,
          oklabPreset: "COSMIC",
          colorCharacteristics: {
            vibrancyLevel: "cosmic",
            emotionalRange: "extreme",
            colorTemperature: "cool"
          }
        },
        trance: {
          energyBoost: 1.15,
          beatEmphasis: 1.1,
          precision: 0.85,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "dynamic"
          }
        },
        // Rock genres - intense but controlled vibrancy
        rock: {
          energyBoost: 1.05,
          intensityMultiplier: 1.1,
          dynamicRange: 1.1,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        metal: {
          energyBoost: 1.15,
          intensityMultiplier: 1.2,
          dynamicRange: 1.2,
          oklabPreset: "COSMIC",
          colorCharacteristics: {
            vibrancyLevel: "cosmic",
            emotionalRange: "extreme",
            colorTemperature: "cool"
          }
        },
        punk: {
          energyBoost: 1.2,
          intensityMultiplier: 1.1,
          precision: 0.8,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "dynamic"
          }
        },
        // Urban genres - rhythmic emphasis with moderate vibrancy
        hiphop: {
          beatEmphasis: 1.3,
          grooveFactor: 1.2,
          tempoMultiplier: 0.95,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "warm"
          }
        },
        rap: {
          beatEmphasis: 1.3,
          grooveFactor: 1.2,
          tempoMultiplier: 0.95,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "neutral"
          }
        },
        // Sophisticated genres - subtle, refined enhancement
        jazz: {
          adaptiveVariation: true,
          complexity: 1.2,
          smoothingFactor: 1.3,
          oklabPreset: "SUBTLE",
          colorCharacteristics: {
            vibrancyLevel: "subtle",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        classical: {
          gentleMode: true,
          dynamicRange: 1.4,
          tempoVariationHandling: "adaptive",
          oklabPreset: "SUBTLE",
          colorCharacteristics: {
            vibrancyLevel: "subtle",
            emotionalRange: "extreme",
            colorTemperature: "neutral"
          }
        },
        ambient: {
          subtleMode: true,
          intensityReduction: 0.7,
          smoothingFactor: 1.5,
          oklabPreset: "SUBTLE",
          colorCharacteristics: {
            vibrancyLevel: "subtle",
            emotionalRange: "narrow",
            colorTemperature: "cool"
          }
        },
        // Popular genres - balanced enhancement
        pop: {
          energyBoost: 1.05,
          beatEmphasis: 1.1,
          precision: 0.85,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "warm"
          }
        },
        rnb: {
          grooveFactor: 1.25,
          smoothingFactor: 1.1,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "warm"
          }
        },
        soul: {
          grooveFactor: 1.3,
          smoothingFactor: 1.15,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        // Default fallback - safe, balanced enhancement
        default: {
          balanced: true,
          energyBoost: 1,
          beatEmphasis: 1,
          precision: 1,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "neutral"
          }
        }
      };
      _GenreProfileManager = class _GenreProfileManager {
        constructor(dependencies = {}) {
          this.config = dependencies.YEAR3000_CONFIG || YEAR3000_CONFIG;
          if (this.config.enableDebug) {
            console.log("\u{1F9EC} [GenreProfileManager] Initialized");
          }
        }
        _getGenreFromAudioFeatures(features) {
          if (!features) return "default";
          const {
            danceability = 0.5,
            energy = 0.5,
            acousticness = 0.5,
            instrumentalness = 0.5,
            tempo = 120
          } = features;
          if (instrumentalness > 0.6 && acousticness < 0.2 && energy > 0.6) {
            if (tempo > 120) return "techno";
            return "electronic";
          }
          if (danceability > 0.7 && energy > 0.7) return "dance";
          if (acousticness > 0.7 && energy < 0.4) return "classical";
          if (acousticness > 0.5 && instrumentalness < 0.1) return "jazz";
          if (energy > 0.7 && instrumentalness < 0.1 && danceability > 0.5)
            return "rock";
          if (danceability > 0.7 && instrumentalness < 0.2 && energy > 0.5 && tempo < 110)
            return "hiphop";
          return "default";
        }
        getProfileForTrack(audioFeatures) {
          const genre = this._getGenreFromAudioFeatures(audioFeatures);
          const profile = GENRE_PROFILES[genre];
          if (this.config.enableDebug) {
            console.log(
              `[GenreProfileManager] Detected genre: '${genre}'. Applying profile.`
            );
          }
          if (profile) {
            return profile;
          }
          const defaultProfile = GENRE_PROFILES.default;
          if (defaultProfile) {
            return defaultProfile;
          }
          throw new Error(
            "[GenreProfileManager] Critical: Default genre profile is missing."
          );
        }
        /**
         * Public helper that returns the genre string detected for the given audio-features without
         * allocating a full profile. Useful for colour/palette routing.
         */
        detectGenre(features) {
          return this._getGenreFromAudioFeatures(features);
        }
        // === OKLAB INTEGRATION METHODS ===
        /**
         * Get OKLAB enhancement preset for a specific genre
         * Returns the appropriate OKLAB preset based on genre characteristics
         */
        getOKLABPresetForGenre(genre) {
          const profile = GENRE_PROFILES[genre] || GENRE_PROFILES.default;
          const presetName = profile.oklabPreset || "STANDARD";
          try {
            const preset = OKLABColorProcessor.getPreset(presetName);
            if (this.config.enableDebug) {
              console.log(`\u{1F9EC} [GenreProfileManager] OKLAB preset for genre '${genre}':`, {
                genre,
                preset: presetName,
                colorCharacteristics: profile.colorCharacteristics
              });
            }
            return preset;
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(`\u{1F9EC} [GenreProfileManager] Failed to get OKLAB preset '${presetName}' for genre '${genre}', using STANDARD:`, error);
            }
            return OKLABColorProcessor.getPreset("STANDARD");
          }
        }
        /**
         * Get OKLAB enhancement preset for a track based on its audio features
         * Automatically detects genre and returns appropriate OKLAB preset
         */
        getOKLABPresetForTrack(audioFeatures) {
          const detectedGenre = this.detectGenre(audioFeatures);
          return this.getOKLABPresetForGenre(detectedGenre);
        }
        /**
         * Get color characteristics for a specific genre
         * Returns detailed color processing guidance for visual systems
         */
        getColorCharacteristicsForGenre(genre) {
          const profile = GENRE_PROFILES[genre] || GENRE_PROFILES.default;
          const characteristics = profile.colorCharacteristics || {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "neutral"
          };
          if (this.config.enableDebug) {
            console.log(`\u{1F9EC} [GenreProfileManager] Color characteristics for genre '${genre}':`, characteristics);
          }
          return characteristics;
        }
        /**
         * Get color characteristics for a track based on its audio features
         */
        getColorCharacteristicsForTrack(audioFeatures) {
          const detectedGenre = this.detectGenre(audioFeatures);
          return this.getColorCharacteristicsForGenre(detectedGenre);
        }
        /**
         * Create contextual OKLAB preset based on genre and additional factors
         * Allows for dynamic preset customization based on runtime conditions
         */
        createContextualOKLABPreset(audioFeatures, intensityMultiplier = 1, customSuffix = "contextual") {
          const detectedGenre = this.detectGenre(audioFeatures);
          const basePreset = this.getOKLABPresetForGenre(detectedGenre);
          const characteristics = this.getColorCharacteristicsForGenre(detectedGenre);
          const energyInfluence = audioFeatures.energy || 0.5;
          const danceabilityInfluence = audioFeatures.danceability || 0.5;
          const combinedIntensity = (energyInfluence + danceabilityInfluence) / 2 * intensityMultiplier;
          const contextualChromaBoost = basePreset.chromaBoost * (0.8 + combinedIntensity * 0.4);
          const contextualLightnessBoost = basePreset.lightnessBoost * (0.9 + combinedIntensity * 0.2);
          const contextualPreset = OKLABColorProcessor.createCustomPreset(
            `${detectedGenre}-${customSuffix}`,
            `Contextual ${basePreset.description} for ${detectedGenre}`,
            contextualLightnessBoost,
            contextualChromaBoost,
            basePreset.shadowReduction,
            basePreset.vibrantThreshold
          );
          if (this.config.enableDebug) {
            console.log(`\u{1F9EC} [GenreProfileManager] Created contextual OKLAB preset:`, {
              genre: detectedGenre,
              basePreset: basePreset.name,
              contextualPreset: contextualPreset.name,
              adjustments: {
                chromaBoost: `${basePreset.chromaBoost} \u2192 ${contextualChromaBoost}`,
                lightnessBoost: `${basePreset.lightnessBoost} \u2192 ${contextualLightnessBoost}`,
                intensityMultiplier,
                combinedIntensity
              }
            });
          }
          return contextualPreset;
        }
        /**
         * Get all available genre-OKLAB preset mappings
         * Useful for system initialization and debugging
         */
        getAllGenreOKLABMappings() {
          const mappings = {};
          Object.entries(GENRE_PROFILES).forEach(([genre, profile]) => {
            mappings[genre] = {
              preset: profile.oklabPreset || "STANDARD",
              characteristics: profile.colorCharacteristics
            };
          });
          if (this.config.enableDebug) {
            console.log("\u{1F9EC} [GenreProfileManager] All genre-OKLAB mappings:", mappings);
          }
          return mappings;
        }
      };
      __name(_GenreProfileManager, "GenreProfileManager");
      GenreProfileManager = _GenreProfileManager;
    }
  });

  // src-js/audio/MusicSyncService.ts
  var MUSIC_SYNC_CONFIG, _MusicSyncService, MusicSyncService;
  var init_MusicSyncService = __esm({
    "src-js/audio/MusicSyncService.ts"() {
      "use strict";
      init_globalConfig();
      init_UnifiedEventBus();
      init_Year3000Utilities();
      init_SpicetifyCompat();
      init_config();
      init_GenreProfileManager();
      init_OKLABColorProcessor();
      init_EmotionalTemperatureMapper();
      MUSIC_SYNC_CONFIG = {
        enableDebug: true,
        enableBeatSynchronization: true,
        enableGenreAnalysis: true,
        enableMoodAdaptation: true,
        bpmCalculation: {
          useEnhancedAlgorithm: true,
          danceabilityWeight: 0.9,
          energyWeight: 0.6,
          bpmWeight: 0.6,
          energyThreshold: 0.5,
          danceabilityThreshold: 0.5,
          bpmThreshold: 0.8,
          maxBPM: 180,
          minBPM: 60
        },
        performance: {
          cacheSize: 100,
          cacheTTL: 3e5,
          maxRetries: 10,
          retryDelay: 200,
          enableMetrics: true,
          processingTimeTarget: 50
        },
        synchronization: {
          beatAccuracyTarget: 50,
          maxSyncDelay: 1e3,
          adaptiveQuality: true,
          predictiveCaching: true,
          debounceRapidChanges: 200
        },
        genreProfiles: {
          electronic: { intensityMultiplier: 1.2, precisionBoost: 1.1 },
          jazz: { smoothingFactor: 1.3, adaptiveVariation: true },
          classical: { gentleMode: true, tempoVariationHandling: "adaptive" },
          rock: { energyBoost: 1.15, consistentTiming: true },
          ambient: { subtleMode: true, intensityReduction: 0.7 },
          hiphop: { beatEmphasis: 1.25, rhythmPrecision: "high" },
          default: { balanced: true }
        },
        musicVisualSync: {
          enhancedBPM: {
            fallbacks: {
              tempo: 120,
              loudness: -5,
              key: 0,
              timeSignature: 4
            },
            danceabilityEstimation: {
              highDance: { min: 125, max: 145, value: 0.8 },
              mediumDance: { min: 100, max: 124, value: 0.7 },
              lowMediumDance: { min: 80, max: 99, value: 0.6 },
              lowDance: { value: 0.5 }
            },
            energyEstimation: {
              tempoRange: { min: 80, max: 160 },
              loudnessRange: { min: -15, max: 0 },
              tempoWeight: 0.6,
              loudnessWeight: 0.4
            }
          }
        }
      };
      _MusicSyncService = class _MusicSyncService {
        constructor(dependencies = {}) {
          this.isInitialized = false;
          this.currentTrack = null;
          this.audioData = null;
          this.currentTrackUri = null;
          this.latestProcessedData = null;
          // High-precision beat scheduling
          this.beatSchedulerTimer = null;
          // Phase 1: Song Change Debouncing
          this.songChangeDebounceTimer = null;
          this.nextBeatIndex = 0;
          this.currentSongBeats = [];
          this.songStartTimestamp = 0;
          this.metrics = {
            bpmCalculations: 0,
            beatSyncs: 0,
            cacheHits: 0,
            cacheMisses: 0,
            avgProcessingTime: 0,
            performance: [],
            errors: 0,
            updates: 0
          };
          this.unifiedCache = /* @__PURE__ */ new Map();
          this.subscribers = /* @__PURE__ */ new Map();
          this.beatSync = {
            lastBeatTime: 0,
            nextBeatTime: 0,
            beatInterval: 0,
            confidence: 0,
            isActive: false
          };
          this.performanceInterval = null;
          this.cacheCleanupInterval = null;
          // Increment this prefix whenever cache schema changes to avoid stale data
          this.CACHE_KEY_VERSION_PREFIX = "v3";
          // Phase 1: Event Processing State Tracking for Loop Prevention
          this.eventProcessingState = {
            isProcessingEvent: false,
            eventChain: [],
            lastEventTime: 0,
            consecutiveEvents: 0
          };
          this.MAX_CONSECUTIVE_EVENTS = 5;
          this.EVENT_RESET_TIMEOUT = 3e3;
          /** Current unit beat direction vector (updated each beat). */
          this.currentBeatVector = { x: 0, y: 0 };
          this.config = dependencies.YEAR3000_CONFIG || YEAR3000_CONFIG;
          this.utils = dependencies.Year3000Utilities || Year3000Utilities_exports;
          this.settingsManager = dependencies.settingsManager;
          this.year3000System = dependencies.year3000System;
          this.genreProfileManager = dependencies.genreProfileManager || new GenreProfileManager({ YEAR3000_CONFIG: this.config });
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.emotionalTemperatureMapper = new EmotionalTemperatureMapper(this.config.enableDebug);
          this.cacheTTL = MUSIC_SYNC_CONFIG.performance.cacheTTL;
          this.userPreferences = this.loadUserPreferences();
          if (this.config.enableDebug) {
            console.log("\u{1F3B5} MusicSyncService constructor called");
            console.log(
              "\u{1F3B5} [MusicSyncService] Initialized with GenreProfileManager support"
            );
          }
        }
        /**
         * Public getter for initialization status (required for AdaptivePerformanceSystem dependency validation)
         */
        get initialized() {
          return this.isInitialized;
        }
        async initialize() {
          try {
            if (this.config.enableDebug) {
              console.log("\u{1F3B5} Initializing unified MusicSyncService...");
            }
            if (!SpicetifyCompat.isAvailable()) {
              console.warn(
                "[MusicSyncService] Spicetify audio data API not available at initialization. Some features may be limited."
              );
            }
            this.setupCacheManagement();
            if (MUSIC_SYNC_CONFIG.performance.enableMetrics) {
              this.setupPerformanceMonitoring();
            }
            this.isInitialized = true;
            if (this.config.enableDebug) {
              console.log("\u{1F31F} MusicSyncService initialized successfully!");
            }
          } catch (error) {
            console.error("\u274C MusicSyncService initialization failed:", error);
            this.metrics.errors++;
          }
        }
        // === SUBSCRIBER MANAGEMENT ===
        subscribe(systemInstance, systemName) {
          if (!systemInstance || typeof systemInstance.updateFromMusicAnalysis !== "function") {
            console.warn(
              `[MusicSyncService] Invalid system or missing updateFromMusicAnalysis method: ${systemName}`
            );
            return;
          }
          if (this.subscribers.has(systemName)) {
            if (this.config.enableDebug) {
              console.warn(
                `[MusicSyncService] System ${systemName} already subscribed.`
              );
            }
            return;
          }
          this.subscribers.set(systemName, systemInstance);
          if (this.config.enableDebug) {
            console.log(`[MusicSyncService] System subscribed: ${systemName}`);
          }
          if (this.latestProcessedData && systemInstance.initialized) {
            try {
              systemInstance.updateFromMusicAnalysis(
                this.latestProcessedData,
                null,
                this.currentTrackUri
              );
            } catch (error) {
              console.error(
                `[MusicSyncService] Error notifying new subscriber ${systemName}:`,
                error
              );
            }
          }
        }
        unsubscribe(systemName) {
          if (this.subscribers.has(systemName)) {
            this.subscribers.delete(systemName);
            if (this.config.enableDebug) {
              console.log(`[MusicSyncService] System unsubscribed: ${systemName}`);
            }
          }
        }
        notifySubscribers(processedData, rawFeatures, trackUri) {
          if (!this.isInitialized) {
            console.warn(
              "[MusicSyncService] Not initialized, cannot notify subscribers."
            );
            return;
          }
          this.latestProcessedData = processedData;
          for (const [name, system] of this.subscribers) {
            try {
              if (system.initialized && typeof system.updateFromMusicAnalysis === "function") {
                system.updateFromMusicAnalysis(processedData, rawFeatures, trackUri);
              }
            } catch (error) {
              console.error(
                `[MusicSyncService] Error notifying subscriber ${name}:`,
                error
              );
              this.metrics.errors++;
            }
          }
        }
        // === DATA FETCHING & CACHING ===
        async fetchAudioData(options = {}) {
          const {
            retryDelay = MUSIC_SYNC_CONFIG.performance.retryDelay,
            maxRetries = MUSIC_SYNC_CONFIG.performance.maxRetries
          } = options;
          const currentTrackUri = Spicetify.Player.data?.item?.uri;
          if (!currentTrackUri) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] No current track URI to fetch audio data."
              );
            }
            return null;
          }
          const cacheKey = this.generateCacheKey(currentTrackUri, "audioData");
          const cached = this.getFromCache(cacheKey);
          if (cached?.audioData) {
            if (this.isValidAudioData(cached.audioData)) {
              this.metrics.cacheHits++;
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Cache hit for audioData: ${cacheKey}`
                );
              }
              return cached.audioData;
            }
            this.unifiedCache.delete(cacheKey);
          }
          this.metrics.cacheMisses++;
          for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
              const audioData = await SpicetifyCompat.getAudioData();
              if (this.isValidAudioData(audioData)) {
                this.setInCache(cacheKey, { audioData });
                return audioData;
              }
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Audio analysis unavailable (attempt ${attempt + 1}/${maxRetries}). Retrying\u2026`
                );
              }
            } catch (error) {
              if (attempt === maxRetries - 1) {
                if (this.config.enableDebug) {
                  console.warn(
                    `[MusicSyncService] Audio data fetch error on final attempt:`,
                    error
                  );
                }
                this.metrics.errors++;
                const fallback = {
                  tempo: 120,
                  energy: 0.5,
                  valence: 0.5,
                  loudness: -10,
                  key: 0,
                  time_signature: 4,
                  danceability: 0.5,
                  acousticness: 0.5,
                  instrumentalness: 0,
                  speechiness: 0.05,
                  liveness: 0.2,
                  mode: 1
                };
                if (this.config.enableDebug) {
                  console.warn(
                    `[MusicSyncService] All audio-data attempts failed \u2013 using fallback defaults`
                  );
                }
                return fallback;
              }
            }
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
          }
          return null;
        }
        async getAudioFeatures() {
          try {
            const currentTrack = Spicetify.Player.data?.item;
            if (!currentTrack?.uri) return null;
            const trackId = currentTrack.uri.split(":")[2] || "fallback";
            const cacheKey = this.generateCacheKey(trackId, "features");
            const cached = this.getFromCache(
              cacheKey
            );
            if (cached?.audioFeatures) {
              this.metrics.cacheHits++;
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Cache hit for audioFeatures: ${cacheKey}`
                );
              }
              return cached.audioFeatures;
            }
            this.metrics.cacheMisses++;
            const response = await Spicetify.CosmosAsync.get(
              `https://api.spotify.com/v1/audio-features/${trackId}`
            );
            const features = {
              danceability: response.danceability,
              energy: response.energy,
              valence: response.valence,
              acousticness: response.acousticness,
              instrumentalness: response.instrumentalness,
              tempo: response.tempo
            };
            this.setInCache(cacheKey, { audioFeatures: features });
            return features;
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] Could not fetch audio features:",
                error
              );
            }
            return null;
          }
        }
        generateCacheKey(identifier, type = "default") {
          return `${this.CACHE_KEY_VERSION_PREFIX}-${identifier}-${type}`;
        }
        getFromCache(key) {
          const cached = this.unifiedCache.get(key);
          if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
            return cached.data;
          }
          if (cached) {
            this.unifiedCache.delete(key);
          }
          return null;
        }
        setInCache(key, data) {
          this.unifiedCache.set(key, {
            data,
            timestamp: Date.now()
          });
        }
        // === ENHANCED BPM CALCULATION ===
        async calculateEnhancedBPM(audioData, options = {}) {
          const startTime = performance.now();
          try {
            if (!audioData?.tempo) {
              if (this.config.enableDebug) {
                console.warn("[MusicSyncService] No BPM data available for track");
              }
              return this.getFallbackBPM();
            }
            const trackBPM = audioData.tempo;
            const config = {
              ...MUSIC_SYNC_CONFIG.bpmCalculation,
              ...options
            };
            const audioFeatures = await this.getAudioFeatures();
            if (!audioFeatures) {
              if (this.config.enableDebug) {
                console.log("[MusicSyncService] Using basic BPM calculation");
              }
              return this.validateBPM(trackBPM);
            }
            const { danceability, energy, valence = 0.5 } = audioFeatures;
            if (this.config.enableDebug) {
              console.log(
                `[MusicSyncService] Audio features - Danceability: ${danceability}, Energy: ${energy}, Valence: ${valence}`
              );
            }
            const profile = this.genreProfileManager.getProfileForTrack(
              audioFeatures || void 0
            );
            const detectedGenre = this.genreProfileManager.detectGenre(
              audioFeatures || void 0
            );
            const enhancedBPM = this.computeAdvancedBPM({
              trackBPM,
              danceability,
              energy,
              valence,
              config,
              profile
            });
            const currentTrack = Spicetify.Player.data?.item || Spicetify.Player.data;
            const uriParts = currentTrack?.uri?.split(":") ?? [];
            const trackId = uriParts.length > 2 && uriParts[2] ? uriParts[2] : "fallback";
            const cacheKey = this.generateCacheKey(trackId, "bpm");
            this.setInCache(cacheKey, {
              bpm: enhancedBPM,
              audioFeatures
            });
            this.metrics.bpmCalculations++;
            if (this.config.enableDebug) {
              console.log(
                `[MusicSyncService] Enhanced BPM: ${enhancedBPM} (original: ${trackBPM})`
              );
            }
            return enhancedBPM;
          } catch (error) {
            console.error("[MusicSyncService] BPM calculation failed:", error);
            this.metrics.errors++;
            return this.getFallbackBPM();
          }
        }
        computeAdvancedBPM(params) {
          const { trackBPM, danceability, energy, valence, config, profile } = params;
          const {
            danceabilityWeight,
            energyWeight,
            bpmWeight,
            energyThreshold,
            danceabilityThreshold,
            bpmThreshold,
            maxBPM,
            minBPM
          } = config;
          const normalizedBPM = Math.min(trackBPM / 120, 2);
          let adjustedDanceabilityWeight = danceabilityWeight;
          let adjustedEnergyWeight = energyWeight;
          let adjustedBpmWeight = bpmWeight;
          if (danceability < danceabilityThreshold) {
            adjustedDanceabilityWeight *= danceability;
          }
          if (energy < energyThreshold) {
            adjustedEnergyWeight *= energy;
          }
          if (normalizedBPM < bpmThreshold) {
            adjustedBpmWeight = 0.9;
          }
          let valenceInfluence = 1;
          if (valence > 0.6) {
            valenceInfluence = 1.05;
          } else if (valence < 0.4 && energy < 0.5) {
            valenceInfluence = 0.95;
          }
          const weightSum = adjustedDanceabilityWeight + adjustedEnergyWeight + adjustedBpmWeight;
          const weightedAverage = (danceability * adjustedDanceabilityWeight + energy * adjustedEnergyWeight + normalizedBPM * adjustedBpmWeight) / weightSum;
          let enhancedBPM = weightedAverage * 120 * valenceInfluence;
          if (profile.beatEmphasis) {
            enhancedBPM *= profile.beatEmphasis;
          }
          enhancedBPM = Math.max(minBPM, Math.min(maxBPM, enhancedBPM));
          return Math.round(enhancedBPM * 100) / 100;
        }
        validateBPM(bpm) {
          const { minBPM, maxBPM } = MUSIC_SYNC_CONFIG.bpmCalculation;
          return Math.max(minBPM, Math.min(maxBPM * 2, Math.round(bpm * 100) / 100));
        }
        getFallbackBPM() {
          return 75;
        }
        // === FEATURE ESTIMATION & FALLBACKS ===
        estimateDanceabilityFromTempo(tempo) {
          const config = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.danceabilityEstimation;
          if (tempo >= config.highDance.min && tempo <= config.highDance.max) {
            return config.highDance.value;
          }
          if (tempo >= config.mediumDance.min && tempo <= config.mediumDance.max) {
            return config.mediumDance.value;
          }
          if (tempo >= config.lowMediumDance.min && tempo <= config.lowMediumDance.max) {
            return config.lowMediumDance.value;
          }
          return config.lowDance.value;
        }
        estimateEnergyFromTempoLoudness(tempo, loudness) {
          const config = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.energyEstimation;
          const tempoFactor = Math.max(
            0,
            Math.min(
              1,
              (tempo - config.tempoRange.min) / (config.tempoRange.max - config.tempoRange.min)
            )
          );
          const loudnessFactor = Math.max(
            0,
            Math.min(
              1,
              (loudness - config.loudnessRange.min) / (config.loudnessRange.max - config.loudnessRange.min)
            )
          );
          return tempoFactor * config.tempoWeight + loudnessFactor * config.loudnessWeight;
        }
        estimateValenceFromKey(key) {
          const majorKeys = [0, 2, 4, 5, 7, 9, 11];
          return majorKeys.includes(key) ? 0.6 : 0.4;
        }
        getFallbackProcessedData(trackUri) {
          const fallbacks = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks;
          const fallbackBeatInterval = 6e4 / fallbacks.tempo;
          return {
            trackUri,
            timestamp: Date.now(),
            tempo: fallbacks.tempo,
            loudness: fallbacks.loudness,
            key: fallbacks.key,
            timeSignature: fallbacks.timeSignature,
            estimatedDanceability: this.estimateDanceabilityFromTempo(
              fallbacks.tempo
            ),
            estimatedEnergy: this.estimateEnergyFromTempoLoudness(
              fallbacks.tempo,
              fallbacks.loudness
            ),
            estimatedValence: 0.5,
            energy: 0.5,
            valence: 0.5,
            processedEnergy: 0.5,
            visualIntensity: 0.5,
            moodIdentifier: "neutral",
            baseBPM: fallbacks.tempo,
            enhancedBPM: fallbacks.tempo,
            beatInterval: fallbackBeatInterval,
            bmpCalculationMethod: "fallback",
            dataSource: "fallback"
          };
        }
        // === OKLAB-ENHANCED COLOR PROCESSING ===
        /**
         * Create OKLAB-enhanced fallback colors based on music emotional context
         * Uses EmotionalTemperatureMapper to determine appropriate emotional state and OKLAB processing
         */
        async createOKLABEnhancedFallbackColors(audioFeatures) {
          const baseFallbackColors = {
            VIBRANT: "#f2cdcd",
            // Catppuccin rosewater
            DARK_VIBRANT: "#cba6f7",
            // Catppuccin mauve  
            LIGHT_VIBRANT: "#f5c2e7",
            // Catppuccin pink
            PROMINENT: "#cba6f7",
            // Catppuccin mauve
            VIBRANT_NON_ALARMING: "#f2cdcd",
            // Catppuccin rosewater
            DESATURATED: "#9399b2"
            // Catppuccin overlay1
          };
          if (!audioFeatures || typeof audioFeatures.energy !== "number" || typeof audioFeatures.valence !== "number") {
            const standardPreset = OKLABColorProcessor.getPreset("STANDARD");
            const processedColors2 = {};
            for (const [key, color3] of Object.entries(baseFallbackColors)) {
              try {
                const oklabResult = this.oklabProcessor.processColor(color3, standardPreset);
                processedColors2[key] = oklabResult.enhancedHex;
              } catch (error) {
                if (this.config.enableDebug) {
                  console.warn(`\u{1F3A8} [MusicSyncService] OKLAB processing failed for ${key}:`, error);
                }
                processedColors2[key] = color3;
              }
            }
            return processedColors2;
          }
          const musicAnalysisData = {
            energy: audioFeatures.energy,
            valence: audioFeatures.valence,
            danceability: audioFeatures.danceability,
            tempo: audioFeatures.tempo,
            mode: audioFeatures.mode,
            genre: this.genreProfileManager.detectGenre(audioFeatures)
          };
          const emotionalResult = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(musicAnalysisData);
          let preset;
          if (emotionalResult.intensity >= 1) {
            preset = OKLABColorProcessor.getPreset("COSMIC");
          } else if (emotionalResult.intensity >= 0.7) {
            preset = OKLABColorProcessor.getPreset("VIBRANT");
          } else if (emotionalResult.intensity >= 0.5) {
            preset = OKLABColorProcessor.getPreset("STANDARD");
          } else {
            preset = OKLABColorProcessor.getPreset("SUBTLE");
          }
          const processedColors = {};
          for (const [key, color3] of Object.entries(baseFallbackColors)) {
            try {
              const oklabResult = this.oklabProcessor.processColor(color3, preset);
              processedColors[key] = oklabResult.enhancedHex;
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn(`\u{1F3A8} [MusicSyncService] OKLAB processing failed for ${key}:`, error);
              }
              processedColors[key] = color3;
            }
          }
          processedColors["--sn-emotional-primary"] = emotionalResult.perceptualColorHex || emotionalResult.primaryEmotion;
          processedColors["--sn-emotional-intensity"] = emotionalResult.intensity.toString();
          processedColors["--sn-emotional-preset"] = preset.name;
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [MusicSyncService] Created OKLAB-enhanced fallback colors:", {
              emotion: emotionalResult.primaryEmotion,
              intensity: emotionalResult.intensity,
              preset: preset.name,
              oklabCoordination: processedColors,
              musicContext: { energy: audioFeatures.energy, valence: audioFeatures.valence }
            });
          }
          return processedColors;
        }
        /**
         * Enhance successfully extracted colors with OKLAB processing based on music emotional context
         * Applies perceptually uniform color processing while preserving the original color relationships
         */
        async enhanceExtractedColorsWithOKLAB(extractedColors, audioFeatures) {
          const enhancedColors = {};
          let preset = OKLABColorProcessor.getPreset("STANDARD");
          if (audioFeatures && typeof audioFeatures.energy === "number" && typeof audioFeatures.valence === "number") {
            const musicAnalysisData = {
              energy: audioFeatures.energy,
              valence: audioFeatures.valence,
              danceability: audioFeatures.danceability,
              tempo: audioFeatures.tempo,
              mode: audioFeatures.mode,
              genre: this.genreProfileManager.detectGenre(audioFeatures)
            };
            const emotionalResult = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(musicAnalysisData);
            if (emotionalResult.intensity >= 1) {
              preset = OKLABColorProcessor.getPreset("COSMIC");
            } else if (emotionalResult.intensity >= 0.7) {
              preset = OKLABColorProcessor.getPreset("VIBRANT");
            } else if (emotionalResult.intensity >= 0.5) {
              preset = OKLABColorProcessor.getPreset("STANDARD");
            } else {
              preset = OKLABColorProcessor.getPreset("SUBTLE");
            }
            enhancedColors["--sn-emotional-primary"] = emotionalResult.perceptualColorHex || `oklabColorProcessor-${emotionalResult.primaryEmotion}`;
            enhancedColors["--sn-emotional-intensity"] = emotionalResult.intensity.toString();
            enhancedColors["--sn-emotional-temperature"] = emotionalResult.temperature.toString();
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [MusicSyncService] Applying OKLAB enhancement with emotional context:", {
                emotion: emotionalResult.primaryEmotion,
                intensity: emotionalResult.intensity,
                preset: preset.name,
                colorCount: Object.keys(extractedColors).length
              });
            }
          }
          for (const [key, color3] of Object.entries(extractedColors)) {
            if (!color3 || typeof color3 !== "string" || !color3.startsWith("#")) {
              enhancedColors[key] = color3;
              continue;
            }
            try {
              const oklabResult = this.oklabProcessor.processColor(color3, preset);
              enhancedColors[key] = oklabResult.enhancedHex;
              enhancedColors[`${key}-oklab-l`] = oklabResult.oklabEnhanced.L.toFixed(3);
              enhancedColors[`${key}-oklab-a`] = oklabResult.oklabEnhanced.a.toFixed(3);
              enhancedColors[`${key}-oklab-b`] = oklabResult.oklabEnhanced.b.toFixed(3);
              enhancedColors[`${key}-oklch-c`] = oklabResult.oklchEnhanced.C.toFixed(3);
              enhancedColors[`${key}-oklch-h`] = oklabResult.oklchEnhanced.H.toFixed(1);
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn(`\u{1F3A8} [MusicSyncService] OKLAB processing failed for ${key} (${color3}):`, error);
              }
              enhancedColors[key] = color3;
            }
          }
          enhancedColors["--sn-oklab-preset"] = preset.name;
          enhancedColors["--sn-oklab-enhanced"] = "true";
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [MusicSyncService] OKLAB color enhancement completed:", {
              originalCount: Object.keys(extractedColors).length,
              enhancedCount: Object.keys(enhancedColors).length,
              preset: preset.name,
              sampleEnhanced: {
                original: extractedColors.VIBRANT || extractedColors[Object.keys(extractedColors)[0] || ""],
                enhanced: enhancedColors.VIBRANT || enhancedColors[Object.keys(enhancedColors)[0] || ""]
              }
            });
          }
          return enhancedColors;
        }
        // === MAIN PROCESSING PIPELINE ===
        async processAudioFeatures(rawSpicetifyAudioFeatures, trackUri, trackDurationMs) {
          if (!this.isInitialized) {
            console.warn("[MusicSyncService] Not initialized, skipping processing.");
            return;
          }
          this.stopBeatScheduler();
          this.currentTrackUri = trackUri;
          const cacheKey = this.generateCacheKey(trackUri, "processed");
          const cached = this.getFromCache(cacheKey);
          if (cached?.processedData) {
            this.notifySubscribers(cached.processedData, null, trackUri);
            return;
          }
          try {
            let audioAnalysisData = rawSpicetifyAudioFeatures;
            if (!audioAnalysisData) {
              audioAnalysisData = await this.fetchAudioData();
            }
            if (!audioAnalysisData) {
              throw new Error("Failed to fetch or receive audio data.");
            }
            if (audioAnalysisData.beats && audioAnalysisData.beats.length > 0) {
              this.currentSongBeats = audioAnalysisData.beats;
              this.songStartTimestamp = Date.now();
              this.nextBeatIndex = 0;
              this.scheduleNextBeatEvent();
            }
            const enhancedBPM = await this.calculateEnhancedBPM(audioAnalysisData);
            const beatInterval = enhancedBPM > 0 ? 6e4 / enhancedBPM : 0;
            const trackData = audioAnalysisData;
            const {
              tempo = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.tempo,
              loudness = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.loudness,
              key = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.key,
              time_signature: timeSignature = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.timeSignature
            } = trackData;
            const audioFeatures = await this.getAudioFeatures();
            const estimatedDanceability = audioFeatures?.danceability ?? this.estimateDanceabilityFromTempo(tempo);
            const estimatedEnergy = audioFeatures?.energy ?? this.estimateEnergyFromTempoLoudness(tempo, loudness);
            const estimatedValence = audioFeatures?.valence ?? this.estimateValenceFromKey(key);
            const artisticMultipliers = this.config.getCurrentMultipliers?.() || {
              musicEnergyBoost: 1,
              visualIntensityBase: 1
            };
            const processedEnergy = Math.max(
              0.1,
              Math.min(
                1,
                estimatedEnergy * (artisticMultipliers.musicEnergyBoost || 1)
              )
            );
            const baseIntensity = estimatedEnergy * 0.6 + estimatedDanceability * 0.4;
            const visualIntensity = baseIntensity * (artisticMultipliers.visualIntensityBase || 1);
            let moodIdentifier = "neutral";
            if (estimatedValence > 0.6 && estimatedEnergy > 0.6) {
              moodIdentifier = "energetic-happy";
            } else if (estimatedValence > 0.6 && estimatedEnergy <= 0.6) {
              moodIdentifier = "calm-happy";
            } else if (estimatedValence <= 0.4 && estimatedEnergy > 0.6) {
              moodIdentifier = "intense-moody";
            } else if (estimatedValence <= 0.4 && estimatedEnergy <= 0.4) {
              moodIdentifier = "calm-melancholy";
            }
            const animationSpeedFactor = Math.max(0.5, 0.8 + visualIntensity * 0.4);
            const genreTag = this.genreProfileManager.detectGenre(
              audioFeatures || void 0
            );
            const processedData = {
              trackUri,
              timestamp: Date.now(),
              tempo,
              loudness,
              key,
              timeSignature,
              duration: trackDurationMs,
              estimatedDanceability,
              estimatedEnergy,
              estimatedValence,
              energy: estimatedEnergy,
              valence: estimatedValence,
              processedEnergy,
              visualIntensity,
              moodIdentifier,
              baseBPM: tempo,
              enhancedBPM,
              beatInterval,
              bmpCalculationMethod: "unified-service",
              dataSource: "unified-music-sync-service",
              beatOccurred: false,
              animationSpeedFactor,
              genre: genreTag
            };
            this.setInCache(cacheKey, { processedData });
            this.latestProcessedData = processedData;
            if (this.config.enableDebug) {
              console.log("\u{1F3B5} [MusicSyncService] Processed music data:", {
                baseTempo: tempo,
                enhancedBPM,
                mood: moodIdentifier,
                energy: estimatedEnergy.toFixed(2),
                visualIntensity: visualIntensity.toFixed(2)
              });
            }
            this.notifySubscribers(
              processedData,
              rawSpicetifyAudioFeatures,
              trackUri
            );
            unifiedEventBus.emitSync("music:beat", {
              bpm: processedData.enhancedBPM,
              intensity: processedData.visualIntensity,
              timestamp: performance.now(),
              confidence: 0.8
            });
            unifiedEventBus.emitSync("music:energy", {
              energy: processedData.energy || 0.5,
              valence: processedData.valence || 0.5,
              tempo: processedData.enhancedBPM,
              timestamp: performance.now()
            });
            unifiedEventBus.emitSync("performance:frame", {
              deltaTime: 16,
              // Approximate frame time
              fps: 60,
              memoryUsage: performance.memory?.usedJSHeapSize || 0,
              timestamp: performance.now()
            });
            if (this.config.enableDebug) {
              console.log(
                "[MusicSyncService] Successfully processed audio features.",
                {
                  baseTempo: tempo,
                  enhancedBPM,
                  mood: moodIdentifier,
                  energy: estimatedEnergy.toFixed(2),
                  visualIntensity: visualIntensity.toFixed(2)
                }
              );
            }
          } catch (error) {
            console.error("[MusicSyncService] Processing failed:", error);
            this.metrics.errors++;
            const fallbackData = this.getFallbackProcessedData(trackUri);
            this.latestProcessedData = fallbackData;
            this.notifySubscribers(fallbackData, null, trackUri);
          }
        }
        /**
         * Re-extract colours & (optionally) recompute beat analysis for the current
         * track.  When `force === true` the method runs even if the track URI hasn't
         * changed (used after live settings updates so gradients repaint instantly).
         */
        async processSongUpdate(force = false) {
          const trackUri = Spicetify.Player?.data?.item?.uri;
          if (!trackUri) return;
          if (!force && trackUri === this.currentTrackUri) {
            return;
          }
          if (this.songChangeDebounceTimer) {
            clearTimeout(this.songChangeDebounceTimer);
          }
          if (force) {
            await this._processSongUpdateInternal(trackUri);
            return;
          }
          this.songChangeDebounceTimer = setTimeout(async () => {
            this.songChangeDebounceTimer = null;
            await this._processSongUpdateInternal(trackUri);
          }, MUSIC_SYNC_CONFIG.synchronization.debounceRapidChanges);
        }
        /**
         * Internal implementation of song processing, extracted for debouncing.
         *  PHASE 1: Enhanced with event loop prevention and chain tracking
         */
        async _processSongUpdateInternal(trackUri) {
          if (this.eventProcessingState.isProcessingEvent) {
            if (this.config.enableDebug) {
              console.warn("\u{1F504} [MusicSyncService] Already processing song update - skipping to prevent recursion");
            }
            return;
          }
          this.eventProcessingState.isProcessingEvent = true;
          this.eventProcessingState.lastEventTime = Date.now();
          this.eventProcessingState.consecutiveEvents++;
          this.eventProcessingState.eventChain.push("_processSongUpdateInternal");
          if (this.eventProcessingState.consecutiveEvents > this.MAX_CONSECUTIVE_EVENTS) {
            console.error("\u{1F504} [MusicSyncService] CRITICAL: Too many consecutive events - circuit breaker activated", {
              consecutiveEvents: this.eventProcessingState.consecutiveEvents,
              eventChain: this.eventProcessingState.eventChain
            });
            this._resetEventProcessingState();
            return;
          }
          const resetTimeout = setTimeout(() => {
            if (this.config.enableDebug) {
              console.warn("\u{1F504} [MusicSyncService] Event processing timeout - resetting state");
            }
            this._resetEventProcessingState();
          }, this.EVENT_RESET_TIMEOUT);
          try {
            this.invalidateTrackCaches(trackUri);
            const trackDuration = Spicetify.Player.data?.item?.duration?.milliseconds || 0;
            const results = await Promise.allSettled([
              this.getAudioFeatures(),
              this.robustColorExtraction(trackUri)
              //  IMPROVED: More robust color extraction
            ]);
            const audioFeatures = results[0].status === "fulfilled" ? results[0].value : null;
            const rawColors = results[1].status === "fulfilled" ? results[1].value : null;
            if (results[0].status === "rejected") {
              if (this.config.enableDebug) {
                console.warn(
                  "[MusicSyncService] Audio features retrieval failed, continuing without music analysis:",
                  results[0].reason
                );
              }
            }
            if (results[1].status === "rejected") {
              if (this.config.enableDebug) {
                console.warn(
                  "[MusicSyncService] Color extraction failed, continuing without color processing:",
                  results[1].reason
                );
              }
            }
            if (this.config.enableDebug) {
              const successCount = (audioFeatures ? 1 : 0) + (rawColors ? 1 : 0);
              if (successCount === 1) {
                console.log(
                  `[MusicSyncService] Graceful degradation: Continuing with ${audioFeatures ? "audio features only" : "color extraction only"}`
                );
              } else if (successCount === 2) {
                console.log("[MusicSyncService] Full feature extraction successful");
              } else {
                console.warn(
                  "[MusicSyncService] Both strategies failed, will use fallback data"
                );
              }
            }
            console.log("\u{1F3A8} [MusicSyncService] Raw colors BEFORE sanitization:", {
              rawColors,
              rawColorType: typeof rawColors,
              rawColorKeys: rawColors ? Object.keys(rawColors) : [],
              rawColorEntries: rawColors ? Object.entries(rawColors) : []
            });
            const colors = this.utils.sanitizeColorMap(
              rawColors || {}
            );
            console.log("\u{1F3A8} [MusicSyncService] Colors AFTER sanitization:", {
              sanitizedColors: colors,
              sanitizedColorType: typeof colors,
              sanitizedColorKeys: Object.keys(colors),
              sanitizedColorEntries: Object.entries(colors),
              colorCount: Object.keys(colors).length,
              droppedCount: rawColors ? Object.keys(rawColors).length - Object.keys(colors).length : 0
            });
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [MusicSyncService] Color extraction debug:", {
                trackUri,
                rawColorsReceived: rawColors,
                sanitizedColors: colors,
                colorCount: Object.keys(colors).length,
                colorExtractorFailed: results[1].status === "rejected"
              });
            }
            let finalColors = colors;
            let usingFallback = false;
            if (Object.keys(colors).length > 0) {
              try {
                finalColors = await this.enhanceExtractedColorsWithOKLAB(colors, audioFeatures);
                if (this.config.enableDebug) {
                  console.log("\u{1F3A8} [MusicSyncService] Successfully enhanced extracted colors with OKLAB processing");
                }
              } catch (oklabError) {
                if (this.config.enableDebug) {
                  console.warn("\u{1F3A8} [MusicSyncService] OKLAB enhancement failed, using original extracted colors:", oklabError);
                }
                finalColors = colors;
              }
            }
            if (Object.keys(colors).length === 0) {
              try {
                const fallbackColors = await this.createOKLABEnhancedFallbackColors(audioFeatures);
                finalColors = fallbackColors;
                usingFallback = true;
                if (this.config.enableDebug) {
                  console.warn(
                    "\u{1F3A8} [MusicSyncService] Color extraction failed, using OKLAB-enhanced Catppuccin fallback colors with emotional context"
                  );
                }
              } catch (oklabError) {
                if (this.config.enableDebug) {
                  console.warn("\u{1F3A8} [MusicSyncService] OKLAB fallback processing failed, using static fallback colors:", oklabError);
                }
                finalColors = {
                  VIBRANT: "#f2cdcd",
                  // Catppuccin rosewater
                  DARK_VIBRANT: "#cba6f7",
                  // Catppuccin mauve
                  LIGHT_VIBRANT: "#f5c2e7",
                  // Catppuccin pink
                  PROMINENT: "#cba6f7",
                  // Catppuccin mauve
                  VIBRANT_NON_ALARMING: "#f2cdcd",
                  // Catppuccin rosewater
                  DESATURATED: "#9399b2"
                  // Catppuccin overlay1
                };
                usingFallback = true;
              }
            }
            const colorContext = {
              rawColors: finalColors,
              trackUri,
              timestamp: Date.now(),
              harmonicMode: this.config.currentHarmonicMode || "catppuccin",
              musicData: audioFeatures ? {
                energy: audioFeatures.energy,
                valence: audioFeatures.valence,
                tempo: audioFeatures.tempo,
                genre: this.genreProfileManager.detectGenre(audioFeatures)
              } : void 0,
              performanceHints: {
                preferLightweight: false,
                enableAdvancedBlending: true,
                maxProcessingTime: 100
                // 100ms max for color processing
              }
            };
            console.log("\u{1F3A8} [MusicSyncService] FINAL colors before event emission:", {
              finalColors,
              finalColorKeys: Object.keys(finalColors),
              finalColorEntries: Object.entries(finalColors),
              usingFallback,
              extractionFailed: Object.keys(colors).length === 0
            });
            const eventData = {
              rawColors: colorContext.rawColors,
              trackUri: colorContext.trackUri,
              timestamp: Date.now()
            };
            if (colorContext.musicData) {
              eventData.musicData = colorContext.musicData;
            }
            console.log("\u{1F3A8} [MusicSyncService] Emitting colors:extracted event with data:", {
              eventData,
              rawColorKeys: eventData.rawColors ? Object.keys(eventData.rawColors) : [],
              rawColorEntries: eventData.rawColors ? Object.entries(eventData.rawColors) : []
            });
            unifiedEventBus.emitSync("colors:extracted", eventData);
            if (this.config.enableDebug) {
              console.log(
                "\u{1F3B5} [MusicSyncService] Emitted colors:extracted event for strategy processing",
                {
                  trackUri,
                  colorCount: Object.keys(finalColors).length,
                  usingFallback,
                  extractionFailed: Object.keys(colors).length === 0
                }
              );
            }
            if (audioFeatures) {
              const provisionalAudioData = this.convertFeaturesToAudioData(audioFeatures);
              await this.processAudioFeatures(
                provisionalAudioData,
                trackUri,
                trackDuration
              );
            }
            (async () => {
              const fullAnalysis = await this.fetchAudioData();
              if (this.isValidAudioData(fullAnalysis)) {
                await this.processAudioFeatures(
                  fullAnalysis,
                  trackUri,
                  trackDuration
                );
              }
            })();
          } catch (error) {
            console.error(
              `[MusicSyncService] Error processing song update for ${trackUri}:`,
              error
            );
            this.metrics.errors++;
          } finally {
            clearTimeout(resetTimeout);
            this._resetEventProcessingState();
            const chainIndex = this.eventProcessingState.eventChain.indexOf("_processSongUpdateInternal");
            if (chainIndex > -1) {
              this.eventProcessingState.eventChain.splice(chainIndex, 1);
            }
          }
        }
        /**
         * Phase 1: Reset event processing state for loop prevention
         */
        _resetEventProcessingState() {
          this.eventProcessingState.isProcessingEvent = false;
          this.eventProcessingState.eventChain = [];
          const now = Date.now();
          const timeSinceLastEvent = now - this.eventProcessingState.lastEventTime;
          if (timeSinceLastEvent > this.EVENT_RESET_TIMEOUT) {
            this.eventProcessingState.consecutiveEvents = 0;
          } else {
            const decayFactor = Math.min(1, timeSinceLastEvent / this.EVENT_RESET_TIMEOUT);
            this.eventProcessingState.consecutiveEvents = Math.floor(
              this.eventProcessingState.consecutiveEvents * (1 - decayFactor)
            );
          }
          if (this.config.enableDebug && this.eventProcessingState.consecutiveEvents > 0) {
            console.log("\u{1F504} [MusicSyncService] Event processing state reset", {
              consecutiveEvents: this.eventProcessingState.consecutiveEvents,
              timeSinceLastEvent
            });
          }
        }
        // === LIFECYCLE & HELPERS ===
        setupCacheManagement() {
          this.cacheCleanupInterval = setInterval(() => {
            const now = Date.now();
            for (const [key, cacheEntry] of this.unifiedCache.entries()) {
              if (now - cacheEntry.timestamp > this.cacheTTL) {
                this.unifiedCache.delete(key);
              }
            }
          }, this.cacheTTL);
        }
        setupPerformanceMonitoring() {
          this.performanceInterval = setInterval(() => {
            if (this.metrics.performance.length > 0) {
              const avg = this.metrics.performance.reduce((a, b) => a + b, 0) / this.metrics.performance.length;
              this.metrics.avgProcessingTime = avg;
              this.metrics.performance = [];
            }
          }, 6e4);
        }
        loadUserPreferences() {
          try {
            return {
              enableMusicSync: true,
              // Always enabled since no specific setting exists
              audioAnalysisQuality: settings.get("sn-webgl-quality") || "medium",
              gradientIntensity: settings.get("sn-gradient-intensity") || "balanced",
              artisticMode: settings.get("sn-artistic-mode") || "artist-vision"
            };
          } catch (e) {
            return {
              enableMusicSync: true,
              audioAnalysisQuality: "medium",
              gradientIntensity: "balanced",
              artisticMode: "artist-vision"
            };
          }
        }
        saveUserPreferences() {
          try {
            if (this.config.enableDebug) {
              console.log("[MusicSyncService] User preferences updated via settings system");
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] Could not save user preferences:",
                error
              );
            }
          }
        }
        updateConfiguration(newConfig) {
          const previousConfig = { ...MUSIC_SYNC_CONFIG };
          Object.assign(MUSIC_SYNC_CONFIG, newConfig);
          if (this.config.enableDebug) {
            console.log("\u{1F3B5} [MusicSyncService] Configuration updated", {
              from: previousConfig,
              to: MUSIC_SYNC_CONFIG
            });
          }
          this.cacheTTL = MUSIC_SYNC_CONFIG.performance.cacheTTL;
          if (previousConfig.performance.enableMetrics !== MUSIC_SYNC_CONFIG.performance.enableMetrics) {
            if (MUSIC_SYNC_CONFIG.performance.enableMetrics) {
              this.setupPerformanceMonitoring();
            } else if (this.performanceInterval) {
              clearInterval(this.performanceInterval);
              this.performanceInterval = null;
            }
          }
        }
        destroy() {
          if (this.songChangeDebounceTimer) {
            clearTimeout(this.songChangeDebounceTimer);
            this.songChangeDebounceTimer = null;
          }
          this.stopBeatScheduler();
          if (this.performanceInterval) clearInterval(this.performanceInterval);
          if (this.cacheCleanupInterval) clearInterval(this.cacheCleanupInterval);
          this.subscribers.clear();
          this.unifiedCache.clear();
          this.isInitialized = false;
          this.latestProcessedData = null;
          this.metrics = {
            bpmCalculations: 0,
            beatSyncs: 0,
            cacheHits: 0,
            cacheMisses: 0,
            avgProcessingTime: 0,
            performance: [],
            errors: 0,
            updates: 0
          };
          this.cacheCleanupInterval = null;
        }
        // Legacy method for backward compatibility - now uses event-driven pattern
        setColorHarmonyEngine(engine) {
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3B5} [MusicSyncService] setColorHarmonyEngine called - now using event-driven pattern instead of direct dependency."
            );
          }
        }
        getLatestProcessedData() {
          return this.latestProcessedData;
        }
        /**
         * Get the latest beat vector (unit direction) for visual systems that need
         * directional rhythm cues. Falls back to {0,0} when unavailable.
         */
        getCurrentBeatVector() {
          return { ...this.currentBeatVector };
        }
        stopBeatScheduler() {
          if (this.beatSchedulerTimer) {
            clearTimeout(this.beatSchedulerTimer);
            this.beatSchedulerTimer = null;
          }
        }
        triggerBeatEvent() {
          const GOLDEN_RATIO = 0.61803398875;
          const angle = this.nextBeatIndex * GOLDEN_RATIO % 1 * Math.PI * 2;
          this.currentBeatVector = { x: Math.cos(angle), y: Math.sin(angle) };
          if (this.latestProcessedData) {
            const beatUpdate = {
              ...this.latestProcessedData,
              beatOccurred: true,
              beatVector: this.currentBeatVector
            };
            this.notifySubscribers(beatUpdate, null, this.currentTrackUri);
          }
          this.nextBeatIndex++;
          this.scheduleNextBeatEvent();
        }
        scheduleNextBeatEvent() {
          if (this.nextBeatIndex >= this.currentSongBeats.length) {
            return;
          }
          const nextBeat = this.currentSongBeats[this.nextBeatIndex];
          const timeSinceSongStart = Date.now() - this.songStartTimestamp;
          const delay = nextBeat.start * 1e3 - timeSinceSongStart;
          if (delay >= 0) {
            this.beatSchedulerTimer = setTimeout(
              () => this.triggerBeatEvent(),
              delay
            );
          } else {
            this.nextBeatIndex++;
            this.scheduleNextBeatEvent();
          }
        }
        /**
         * Validate that the returned audio analysis object actually contains usable
         * information (primarily tempo). Spotify may return an empty object when the
         * analysis is not ready yet  treating that as valid poisons the cache.
         */
        isValidAudioData(data) {
          return !!data && typeof data.tempo === "number" && data.tempo > 0;
        }
        /**
         * Remove any cached entries (audioData, features, bpm, processed) belonging
         * to the provided track URI. Useful when switching tracks to ensure we do
         * not reuse stale or invalid data cached under the previous song.
         */
        invalidateTrackCaches(trackUri) {
          if (!trackUri) return;
          for (const key of this.unifiedCache.keys()) {
            if (key.includes(trackUri)) {
              this.unifiedCache.delete(key);
            }
          }
        }
        /**
         * Convert the lightweight `audio-features` payload into a pseudo `AudioData`
         * object so the rest of the pipeline (which expects full analysis) can work
         * immediately. Missing properties are filled with sensible defaults.
         */
        convertFeaturesToAudioData(features) {
          const fb = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks;
          return {
            tempo: features.tempo,
            energy: features.energy,
            valence: features.valence,
            loudness: fb.loudness,
            key: fb.key,
            time_signature: fb.timeSignature,
            danceability: features.danceability,
            acousticness: features.acousticness,
            instrumentalness: features.instrumentalness,
            speechiness: 0,
            liveness: 0,
            mode: 0
            // Optional arrays left undefined  beat grid will arrive later
          };
        }
        /**
         *  IMPROVED: Robust color extraction with retry logic and fallbacks
         */
        async robustColorExtraction(trackUri, maxRetries = 3) {
          console.log("\u{1F3A8} [MusicSyncService] Starting robust color extraction:", {
            trackUri,
            maxRetries,
            timestamp: Date.now()
          });
          for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
              if (!trackUri) {
                console.warn(
                  "\u{1F3A8} [MusicSyncService] Empty trackUri provided to color extraction"
                );
                return null;
              }
              console.log(`\u{1F3A8} [MusicSyncService] Calling Spicetify.colorExtractor (attempt ${attempt})...`);
              const colors = await Spicetify.colorExtractor(trackUri);
              console.log(
                `\u{1F3A8} [MusicSyncService] Raw color extraction result (attempt ${attempt}):`,
                {
                  trackUri,
                  success: !!colors,
                  colorsType: typeof colors,
                  colorsIsNull: colors === null,
                  colorsIsUndefined: colors === void 0,
                  colorCount: colors ? Object.keys(colors).length : 0,
                  rawColors: colors,
                  colorKeys: colors ? Object.keys(colors) : [],
                  colorValues: colors ? Object.values(colors) : []
                }
              );
              if (colors && typeof colors === "object" && Object.keys(colors).length > 0) {
                Object.entries(colors).forEach(([key, value]) => {
                  console.log(`\u{1F3A8} [MusicSyncService] Extracted color: ${key} = ${value}`);
                });
                return colors;
              } else {
                console.warn(`\u{1F3A8} [MusicSyncService] Color extraction returned empty/invalid data on attempt ${attempt}`);
              }
            } catch (error) {
              console.error(
                `\u{1F3A8} [MusicSyncService] Color extraction attempt ${attempt} failed with error:`,
                error,
                {
                  errorMessage: error instanceof Error ? error.message : String(error),
                  errorStack: error instanceof Error ? error.stack : void 0
                }
              );
              if (attempt < maxRetries) {
                const waitTime = 100 * attempt;
                console.log(`\u{1F3A8} [MusicSyncService] Waiting ${waitTime}ms before retry...`);
                await new Promise((resolve) => setTimeout(resolve, waitTime));
              }
            }
          }
          console.error(
            `\u{1F3A8} [MusicSyncService] CRITICAL: All color extraction attempts failed for ${trackUri}`
          );
          return null;
        }
        // -------------------------------------------------------------------
        // External adapter integration helpers ------------------------------
        // -------------------------------------------------------------------
        /**
         * Adapter-facing helper to push music metrics without relying on the
         * full processing pipeline.  Currently a no-op placeholder that may be
         * expanded in future phases.
         */
        updateMetrics(metrics) {
          this.latestProcessedData = metrics;
        }
        /**
         * Get current music state for consciousness systems
         */
        getCurrentMusicState() {
          if (!this.latestProcessedData || !this.audioData) {
            return null;
          }
          return {
            emotion: this.latestProcessedData.emotion || null,
            beat: {
              tempo: this.latestProcessedData.bpm || this.audioData.tempo || 120,
              energy: this.latestProcessedData.energy || this.audioData.energy || 0.5,
              timestamp: Date.now()
            },
            intensity: this.latestProcessedData.intensity || this.audioData.energy || 0.5
          };
        }
        /**
         * Health check method for system status reporting
         */
        async healthCheck() {
          try {
            const isSpicetifyAvailable = SpicetifyCompat.isAvailable();
            const hasSubscribers = this.subscribers.size > 0;
            const hasRecentData = this.latestProcessedData !== null;
            const totalOperations = this.metrics.bpmCalculations + this.metrics.beatSyncs + this.metrics.cacheHits + this.metrics.cacheMisses;
            const errorRate = totalOperations > 0 ? this.metrics.errors / totalOperations : 0;
            if (!this.isInitialized) {
              return {
                status: "critical",
                message: "System not initialized",
                details: { initialized: this.isInitialized, spicetifyAvailable: isSpicetifyAvailable }
              };
            }
            if (!isSpicetifyAvailable) {
              return {
                status: "degraded",
                message: "Spicetify audio data API not available - running in limited mode",
                details: {
                  initialized: this.isInitialized,
                  spicetifyAvailable: isSpicetifyAvailable,
                  subscribers: hasSubscribers,
                  recentData: hasRecentData,
                  errorRate
                }
              };
            }
            if (errorRate > 0.5) {
              return {
                status: "degraded",
                message: `High error rate detected: ${(errorRate * 100).toFixed(1)}%`,
                details: {
                  initialized: this.isInitialized,
                  spicetifyAvailable: isSpicetifyAvailable,
                  subscribers: hasSubscribers,
                  recentData: hasRecentData,
                  errorRate,
                  errors: this.metrics.errors,
                  totalOperations
                }
              };
            }
            return {
              status: "healthy",
              message: "Music sync service operational",
              details: {
                initialized: this.isInitialized,
                spicetifyAvailable: isSpicetifyAvailable,
                subscribers: hasSubscribers,
                subscriberCount: this.subscribers.size,
                recentData: hasRecentData,
                errorRate,
                bpmCalculations: this.metrics.bpmCalculations,
                beatSyncs: this.metrics.beatSyncs,
                cacheHits: this.metrics.cacheHits,
                cacheMisses: this.metrics.cacheMisses,
                avgProcessingTime: this.metrics.avgProcessingTime,
                errors: this.metrics.errors,
                updates: this.metrics.updates
              }
            };
          } catch (error) {
            return {
              status: "critical",
              message: `Health check failed: ${error instanceof Error ? error.message : "Unknown error"}`,
              details: { error: error instanceof Error ? error.message : "Unknown error" }
            };
          }
        }
      };
      __name(_MusicSyncService, "MusicSyncService");
      MusicSyncService = _MusicSyncService;
    }
  });

  // src-js/types/signature.ts
  var createDefaultSignature;
  var init_signature = __esm({
    "src-js/types/signature.ts"() {
      "use strict";
      createDefaultSignature = /* @__PURE__ */ __name((userId) => ({
        version: "1.0.0",
        userId,
        createdAt: Date.now(),
        lastModified: Date.now(),
        colorMemories: /* @__PURE__ */ new Map(),
        rhythmicPreferences: /* @__PURE__ */ new Map(),
        emotionalResonanceProfile: {},
        evolutionaryTrajectory: {
          adaptability: 0.5,
          // Start balanced
          explorationFactor: 0.5,
          // Start balanced
          lastUpdate: Date.now()
        }
      }), "createDefaultSignature");
    }
  });

  // node_modules/idb/build/index.js
  function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
      IDBDatabase,
      IDBObjectStore,
      IDBIndex,
      IDBCursor,
      IDBTransaction
    ]);
  }
  function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey
    ]);
  }
  function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
      const unlisten = /* @__PURE__ */ __name(() => {
        request.removeEventListener("success", success);
        request.removeEventListener("error", error);
      }, "unlisten");
      const success = /* @__PURE__ */ __name(() => {
        resolve(wrap(request.result));
        unlisten();
      }, "success");
      const error = /* @__PURE__ */ __name(() => {
        reject(request.error);
        unlisten();
      }, "error");
      request.addEventListener("success", success);
      request.addEventListener("error", error);
    });
    reverseTransformCache.set(promise, request);
    return promise;
  }
  function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx))
      return;
    const done = new Promise((resolve, reject) => {
      const unlisten = /* @__PURE__ */ __name(() => {
        tx.removeEventListener("complete", complete);
        tx.removeEventListener("error", error);
        tx.removeEventListener("abort", error);
      }, "unlisten");
      const complete = /* @__PURE__ */ __name(() => {
        resolve();
        unlisten();
      }, "complete");
      const error = /* @__PURE__ */ __name(() => {
        reject(tx.error || new DOMException("AbortError", "AbortError"));
        unlisten();
      }, "error");
      tx.addEventListener("complete", complete);
      tx.addEventListener("error", error);
      tx.addEventListener("abort", error);
    });
    transactionDoneMap.set(tx, done);
  }
  function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
  }
  function wrapFunction(func) {
    if (getCursorAdvanceMethods().includes(func)) {
      return function(...args) {
        func.apply(unwrap(this), args);
        return wrap(this.request);
      };
    }
    return function(...args) {
      return wrap(func.apply(unwrap(this), args));
    };
  }
  function transformCachableValue(value) {
    if (typeof value === "function")
      return wrapFunction(value);
    if (value instanceof IDBTransaction)
      cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
      return new Proxy(value, idbProxyTraps);
    return value;
  }
  function wrap(value) {
    if (value instanceof IDBRequest)
      return promisifyRequest(value);
    if (transformCache.has(value))
      return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
      transformCache.set(value, newValue);
      reverseTransformCache.set(newValue, value);
    }
    return newValue;
  }
  function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap(request);
    if (upgrade) {
      request.addEventListener("upgradeneeded", (event) => {
        upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
      });
    }
    if (blocked) {
      request.addEventListener("blocked", (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion,
        event.newVersion,
        event
      ));
    }
    openPromise.then((db) => {
      if (terminated)
        db.addEventListener("close", () => terminated());
      if (blocking) {
        db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
      }
    }).catch(() => {
    });
    return openPromise;
  }
  function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
      return;
    }
    if (cachedMethods.get(prop))
      return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, "");
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
    ) {
      return;
    }
    const method = /* @__PURE__ */ __name(async function(storeName, ...args) {
      const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
      let target2 = tx.store;
      if (useIndex)
        target2 = target2.index(args.shift());
      return (await Promise.all([
        target2[targetFuncName](...args),
        isWrite && tx.done
      ]))[0];
    }, "method");
    cachedMethods.set(prop, method);
    return method;
  }
  async function* iterate(...args) {
    let cursor = this;
    if (!(cursor instanceof IDBCursor)) {
      cursor = await cursor.openCursor(...args);
    }
    if (!cursor)
      return;
    cursor = cursor;
    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
    reverseTransformCache.set(proxiedCursor, unwrap(cursor));
    while (cursor) {
      yield proxiedCursor;
      cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
      advanceResults.delete(proxiedCursor);
    }
  }
  function isIteratorProp(target, prop) {
    return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
  }
  var instanceOfAny, idbProxyableTypes, cursorAdvanceMethods, transactionDoneMap, transformCache, reverseTransformCache, idbProxyTraps, unwrap, readMethods, writeMethods, cachedMethods, advanceMethodProps, methodMap, advanceResults, ittrProxiedCursorToOriginalProxy, cursorIteratorTraps;
  var init_build = __esm({
    "node_modules/idb/build/index.js"() {
      instanceOfAny = /* @__PURE__ */ __name((object, constructors) => constructors.some((c) => object instanceof c), "instanceOfAny");
      __name(getIdbProxyableTypes, "getIdbProxyableTypes");
      __name(getCursorAdvanceMethods, "getCursorAdvanceMethods");
      transactionDoneMap = /* @__PURE__ */ new WeakMap();
      transformCache = /* @__PURE__ */ new WeakMap();
      reverseTransformCache = /* @__PURE__ */ new WeakMap();
      __name(promisifyRequest, "promisifyRequest");
      __name(cacheDonePromiseForTransaction, "cacheDonePromiseForTransaction");
      idbProxyTraps = {
        get(target, prop, receiver) {
          if (target instanceof IDBTransaction) {
            if (prop === "done")
              return transactionDoneMap.get(target);
            if (prop === "store") {
              return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
            }
          }
          return wrap(target[prop]);
        },
        set(target, prop, value) {
          target[prop] = value;
          return true;
        },
        has(target, prop) {
          if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
            return true;
          }
          return prop in target;
        }
      };
      __name(replaceTraps, "replaceTraps");
      __name(wrapFunction, "wrapFunction");
      __name(transformCachableValue, "transformCachableValue");
      __name(wrap, "wrap");
      unwrap = /* @__PURE__ */ __name((value) => reverseTransformCache.get(value), "unwrap");
      __name(openDB, "openDB");
      readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
      writeMethods = ["put", "add", "delete", "clear"];
      cachedMethods = /* @__PURE__ */ new Map();
      __name(getMethod, "getMethod");
      replaceTraps((oldTraps) => ({
        ...oldTraps,
        get: /* @__PURE__ */ __name((target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver), "get"),
        has: /* @__PURE__ */ __name((target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop), "has")
      }));
      advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
      methodMap = {};
      advanceResults = /* @__PURE__ */ new WeakMap();
      ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
      cursorIteratorTraps = {
        get(target, prop) {
          if (!advanceMethodProps.includes(prop))
            return target[prop];
          let cachedFunc = methodMap[prop];
          if (!cachedFunc) {
            cachedFunc = methodMap[prop] = function(...args) {
              advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
            };
          }
          return cachedFunc;
        }
      };
      __name(iterate, "iterate");
      __name(isIteratorProp, "isIteratorProp");
      replaceTraps((oldTraps) => ({
        ...oldTraps,
        get(target, prop, receiver) {
          if (isIteratorProp(target, prop))
            return iterate;
          return oldTraps.get(target, prop, receiver);
        },
        has(target, prop) {
          return isIteratorProp(target, prop) || oldTraps.has(target, prop);
        }
      }));
    }
  });

  // src-js/audio/TemporalMemoryService.ts
  var DB_NAME, DB_VERSION, SIGNATURE_STORE, SIGNATURE_KEY, _TemporalMemoryService, TemporalMemoryService, temporalMemoryService;
  var init_TemporalMemoryService = __esm({
    "src-js/audio/TemporalMemoryService.ts"() {
      "use strict";
      init_signature();
      init_build();
      DB_NAME = "Year3000-TemporalMemory";
      DB_VERSION = 1;
      SIGNATURE_STORE = "aestheticSignatures";
      SIGNATURE_KEY = "currentUser";
      _TemporalMemoryService = class _TemporalMemoryService {
        constructor() {
          this.dbPromise = openDB(DB_NAME, DB_VERSION, {
            upgrade(db) {
              if (!db.objectStoreNames.contains(SIGNATURE_STORE)) {
                db.createObjectStore(SIGNATURE_STORE);
              }
            }
          });
        }
        async getSignature(userId = "defaultUser") {
          try {
            const db = await this.dbPromise;
            const signature = await db.get(SIGNATURE_STORE, SIGNATURE_KEY);
            if (signature) {
              return signature;
            } else {
              const defaultSignature = createDefaultSignature(userId);
              await this.saveSignature(defaultSignature);
              return defaultSignature;
            }
          } catch (error) {
            console.error(
              "[TemporalMemoryService] Failed to get signature from IndexedDB. Returning default.",
              error
            );
            return createDefaultSignature(userId);
          }
        }
        async saveSignature(signature) {
          try {
            const db = await this.dbPromise;
            signature.lastModified = Date.now();
            await db.put(SIGNATURE_STORE, signature, SIGNATURE_KEY);
          } catch (error) {
            console.error(
              "[TemporalMemoryService] Failed to save signature to IndexedDB.",
              error
            );
          }
        }
        async resetSignature(userId = "defaultUser") {
          const defaultSignature = createDefaultSignature(userId);
          await this.saveSignature(defaultSignature);
          console.log("[TemporalMemoryService] Aesthetic signature has been reset.");
          return defaultSignature;
        }
        async getSignatureTrends(signature) {
          if (!signature) return null;
          const trends = {
            dominantColor: null,
            dominantRhythm: null,
            avgEnergy: 0,
            avgValence: 0
          };
          let dominantColor = null;
          signature.colorMemories.forEach((mem, hex) => {
            if (!dominantColor || mem.count > dominantColor.count) {
              dominantColor = { hex, count: mem.count };
            }
            trends.avgValence += mem.emotionalValence * mem.count;
          });
          let totalColorCount = 0;
          signature.colorMemories.forEach((mem) => totalColorCount += mem.count);
          if (totalColorCount > 0) {
            trends.avgValence /= totalColorCount;
          }
          trends.dominantColor = dominantColor;
          let dominantRhythm = null;
          signature.rhythmicPreferences.forEach((pattern, id) => {
            if (!dominantRhythm || pattern.count > dominantRhythm.count) {
              dominantRhythm = { id, count: pattern.count };
            }
            trends.avgEnergy += pattern.associatedEnergy * pattern.count;
          });
          let totalRhythmCount = 0;
          signature.rhythmicPreferences.forEach((p) => totalRhythmCount += p.count);
          if (totalRhythmCount > 0) {
            trends.avgEnergy /= totalRhythmCount;
          }
          trends.dominantRhythm = dominantRhythm;
          return trends;
        }
      };
      __name(_TemporalMemoryService, "TemporalMemoryService");
      TemporalMemoryService = _TemporalMemoryService;
      temporalMemoryService = new TemporalMemoryService();
    }
  });

  // src-js/core/animation/EnhancedMasterAnimationCoordinator.ts
  var _EnhancedMasterAnimationCoordinator, EnhancedMasterAnimationCoordinator;
  var init_EnhancedMasterAnimationCoordinator = __esm({
    "src-js/core/animation/EnhancedMasterAnimationCoordinator.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_TemporalMemoryService();
      _EnhancedMasterAnimationCoordinator = class _EnhancedMasterAnimationCoordinator {
        constructor(config, performanceCoordinator, cssAnimationManager) {
          this.performanceCoordinator = null;
          this.cssAnimationManager = null;
          // Animation management
          this.animations = /* @__PURE__ */ new Map();
          this.frameCallbacks = /* @__PURE__ */ new Map();
          this.callbackCounter = 0;
          // Master animation loop
          this.animationFrameId = null;
          this.isRunning = false;
          this.isPaused = false;
          // Timing and performance
          this.lastTimestamp = 0;
          this.frameCount = 0;
          this.startTime = 0;
          this.frameTimeBudget = 16;
          // 60fps
          // Performance metrics
          this.metrics = {
            totalFrames: 0,
            droppedFrames: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            performanceMode: "quality",
            activeAnimations: 0,
            activeCallbacks: 0,
            frameRate: 60,
            lastOptimization: 0
          };
          // Frame context for visual systems
          this.frameContext = {
            timestamp: 0,
            deltaMs: 0,
            performanceMode: "quality",
            frameBudget: 16,
            beatIntensity: 0,
            scrollRatio: 0,
            tiltXY: { x: 0, y: 0 }
          };
          // Performance tracking
          this.performanceHistory = [];
          this.MAX_HISTORY_SIZE = 60;
          // ===================================================================
          // EMERGENT CHOREOGRAPHY ENGINE INTEGRATION (from consolidation)
          // ===================================================================
          // Emergent choreography state
          this.signature = null;
          this.saveInterval = null;
          this.currentBpm = 120;
          this.currentIntensity = 0.5;
          this.emergentEventSubscriptions = [];
          // =========================================================================
          // PRIVATE METHODS
          // =========================================================================
          /**
           * Main animation loop with proper frame time budgeting
           */
          this.animate = /* @__PURE__ */ __name(() => {
            if (!this.isRunning) return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.lastTimestamp;
            if (this.isPaused) {
              this.animationFrameId = requestAnimationFrame(this.animate);
              return;
            }
            this.frameContext.timestamp = currentTime;
            this.frameContext.deltaMs = deltaTime;
            const frameStartTime = performance.now();
            const FRAME_BUDGET = this.frameTimeBudget;
            const callbackStartTime = performance.now();
            this.executeFrameCallbacks(deltaTime, currentTime);
            const callbackTime = performance.now() - callbackStartTime;
            const remainingBudget = FRAME_BUDGET - callbackTime;
            if (remainingBudget > 2) {
              this.executeAnimationSystemsWithBudget(deltaTime, currentTime, remainingBudget);
            } else {
              this.metrics.droppedFrames++;
              if (this.config.enableDebug && Math.random() < 0.1) {
                console.warn(`[EnhancedMasterAnimationCoordinator] Skipped animation systems - budget exceeded: ${callbackTime.toFixed(2)}ms`);
              }
            }
            const midFrameTime = performance.now() - frameStartTime;
            if (midFrameTime < FRAME_BUDGET * 0.8) {
              this.processEmergentTick(deltaTime);
            }
            const frameTime = performance.now() - frameStartTime;
            this.updatePerformanceMetrics(frameTime);
            if (this.performanceCoordinator) {
              this.performanceCoordinator.trackSubsystem("MasterAnimationCoordinator", {
                frameTime,
                fps: this.metrics.frameRate,
                memoryUsage: performance.memory?.usedJSHeapSize || 0,
                cpuUsage: frameTime > this.frameTimeBudget ? frameTime / this.frameTimeBudget * 10 : 0
              });
            }
            this.lastTimestamp = currentTime;
            this.frameCount++;
            if (frameTime > FRAME_BUDGET * 1.5) {
              setTimeout(() => {
                this.animationFrameId = requestAnimationFrame(this.animate);
              }, 4);
            } else {
              this.animationFrameId = requestAnimationFrame(this.animate);
            }
          }, "animate");
          this.config = config;
          this.eventBus = unifiedEventBus;
          this.performanceCoordinator = performanceCoordinator || null;
          this.cssAnimationManager = cssAnimationManager || null;
          this.startTime = performance.now();
          this.lastTimestamp = this.startTime;
          this.currentMultipliers = this.config.cosmicMultipliers;
          this.subscribeToEvents();
          this.initializeEmergentChoreography();
          this.updateFrameBudget();
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Initialized with unified animation coordination and emergent choreography");
          }
        }
        // 1 second at 60fps
        // ===================================================================
        // CSS-FIRST BREATHING COORDINATION - YEAR 3000 PERFORMANCE REVOLUTION
        // ===================================================================
        /**
         * Coordinate consciousness breathing with CSSAnimationManager
         * Integrates beat events with CSS-first breathing for 90%+ JavaScript overhead elimination
         */
        coordinateConsciousnessBreathing(payload) {
          if (!this.cssAnimationManager) return;
          const energyLevel = payload.energy || payload.intensity || 0.5;
          const tempo = payload.bpm || this.currentBpm || 120;
          const energyDelta = Math.abs(energyLevel - this.currentIntensity);
          if (energyDelta < 0.1 && Math.abs(tempo - this.currentBpm) < 5) {
            return;
          }
          const consciousnessElements = document.querySelectorAll(
            ".Root__main-view::before, .Root__main-view, [data-consciousness-breathing]"
          );
          if (consciousnessElements.length > 0) {
            this.cssAnimationManager.triggerConsciousnessBreathing(
              consciousnessElements,
              energyLevel,
              tempo
            );
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] Consciousness breathing coordinated - Energy: ${energyLevel.toFixed(2)}, Tempo: ${tempo} BPM`);
            }
          }
          this.currentIntensity = energyLevel;
          this.currentBpm = tempo;
        }
        /**
         * Get or create singleton instance
         */
        static getInstance(config, performanceCoordinator, cssAnimationManager) {
          if (!_EnhancedMasterAnimationCoordinator.instance) {
            if (!config) {
              throw new Error("EnhancedMasterAnimationCoordinator requires config for first initialization");
            }
            _EnhancedMasterAnimationCoordinator.instance = new _EnhancedMasterAnimationCoordinator(config, performanceCoordinator, cssAnimationManager);
          }
          return _EnhancedMasterAnimationCoordinator.instance;
        }
        /**
         * Register CSSAnimationManager for breathing coordination
         */
        registerCSSAnimationManager(cssAnimationManager) {
          this.cssAnimationManager = cssAnimationManager;
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] CSSAnimationManager registered for breathing coordination");
          }
        }
        /**
         * Register an animation system (legacy AnimationConductor compatibility)
         */
        registerAnimationSystem(name, system, priority = "normal", targetFPS = 60) {
          if (this.animations.has(name)) {
            if (this.config.enableDebug) {
              console.warn(`[EnhancedMasterAnimationCoordinator] Animation system ${name} already registered`);
            }
            return false;
          }
          const registration = {
            name,
            system,
            priority,
            targetFPS,
            type: "animation",
            enabled: true,
            frameInterval: 1e3 / targetFPS,
            lastUpdate: 0,
            frameCount: 0,
            totalTime: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            skippedFrames: 0
          };
          this.animations.set(name, registration);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered animation system: ${name} (priority: ${priority}, fps: ${targetFPS})`);
          }
          return true;
        }
        /**
         * Register a visual system (legacy VisualFrameCoordinator compatibility)
         */
        registerVisualSystem(system, priority = "normal") {
          if (this.animations.has(system.systemName)) {
            if (this.config.enableDebug) {
              console.warn(`[EnhancedMasterAnimationCoordinator] Visual system ${system.systemName} already registered`);
            }
            return false;
          }
          const registration = {
            name: system.systemName,
            system,
            priority,
            targetFPS: 60,
            type: "visual",
            enabled: true,
            frameInterval: 16.67,
            // 60fps
            lastUpdate: 0,
            frameCount: 0,
            totalTime: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            skippedFrames: 0
          };
          this.animations.set(system.systemName, registration);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered visual system: ${system.systemName} (priority: ${priority})`);
          }
          return true;
        }
        /**
         * Register a frame callback for unified RAF management
         */
        registerFrameCallback(callback, priority = "normal", system) {
          const id = `callback_${++this.callbackCounter}`;
          const frameCallback = {
            id,
            callback,
            priority,
            system: system || void 0,
            enabled: true,
            frameCount: 0,
            totalTime: 0,
            lastExecution: 0
          };
          this.frameCallbacks.set(id, frameCallback);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered frame callback: ${id} (priority: ${priority})`);
          }
          return id;
        }
        /**
         * Unregister an animation system
         */
        unregisterAnimationSystem(name) {
          const removed = this.animations.delete(name);
          if (removed) {
            this.updateMetrics();
            if (this.animations.size === 0 && this.frameCallbacks.size === 0) {
              this.stopMasterAnimationLoop();
            }
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] Unregistered animation system: ${name}`);
            }
          }
          return removed;
        }
        /**
         * Unregister a frame callback
         */
        unregisterFrameCallback(id) {
          const removed = this.frameCallbacks.delete(id);
          if (removed) {
            this.updateMetrics();
            if (this.animations.size === 0 && this.frameCallbacks.size === 0) {
              this.stopMasterAnimationLoop();
            }
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] Unregistered frame callback: ${id}`);
            }
          }
          return removed;
        }
        /**
         * Start the master animation loop
         */
        startMasterAnimationLoop() {
          if (this.isRunning) return;
          this.isRunning = true;
          this.isPaused = false;
          this.lastTimestamp = performance.now();
          this.frameCount = 0;
          this.animate();
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Master animation loop started");
          }
        }
        /**
         * Stop the master animation loop
         */
        stopMasterAnimationLoop() {
          if (!this.isRunning) return;
          this.isRunning = false;
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Master animation loop stopped");
          }
        }
        /**
         * Pause the animation loop
         */
        pauseAnimationLoop() {
          this.isPaused = true;
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Animation loop paused");
          }
        }
        /**
         * Resume the animation loop
         */
        resumeAnimationLoop() {
          if (!this.isPaused) return;
          this.isPaused = false;
          this.lastTimestamp = performance.now();
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Animation loop resumed");
          }
        }
        /**
         * Set performance mode for all registered systems
         */
        setPerformanceMode(mode) {
          this.metrics.performanceMode = mode;
          this.frameContext.performanceMode = mode;
          this.frameTimeBudget = mode === "performance" ? 8 : 16;
          this.frameContext.frameBudget = this.frameTimeBudget;
          for (const registration of this.animations.values()) {
            if (registration.system.onPerformanceModeChange) {
              registration.system.onPerformanceModeChange(mode);
            }
          }
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Performance mode set to: ${mode}`);
          }
        }
        /**
         * Get current performance metrics
         */
        getPerformanceMetrics() {
          return { ...this.metrics };
        }
        /**
         * Get all registered systems
         */
        getRegisteredSystems() {
          return {
            animations: new Map(this.animations),
            callbacks: new Map(this.frameCallbacks)
          };
        }
        /**
         * Enable or disable a specific system
         */
        setSystemEnabled(name, enabled) {
          const animation = this.animations.get(name);
          if (animation) {
            animation.enabled = enabled;
            this.updateMetrics();
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] System ${name} ${enabled ? "enabled" : "disabled"}`);
            }
            return true;
          }
          return false;
        }
        /**
         * Get current multipliers for emergent choreography
         */
        getCurrentMultipliers() {
          return this.currentMultipliers;
        }
        /**
         * Force update evolutionary trajectory
         */
        async updateEvolutionaryTrajectory() {
          await this._updateEvolutionaryTrajectory();
        }
        /**
         * Destroy the coordinator and clean up resources
         */
        destroy() {
          this.stopMasterAnimationLoop();
          this.destroyEmergentChoreography();
          for (const registration of this.animations.values()) {
            if (registration.type === "visual" && "destroy" in registration.system) {
              try {
                registration.system.destroy();
              } catch (error) {
                console.error(`[EnhancedMasterAnimationCoordinator] Error destroying system ${registration.name}:`, error);
              }
            }
          }
          this.animations.clear();
          this.frameCallbacks.clear();
          if (_EnhancedMasterAnimationCoordinator.instance === this) {
            _EnhancedMasterAnimationCoordinator.instance = null;
          }
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Destroyed");
          }
        }
        /**
         * Execute frame callbacks with priority ordering
         */
        executeFrameCallbacks(deltaTime, timestamp) {
          const sortedCallbacks = Array.from(this.frameCallbacks.values()).filter((callback) => callback.enabled).sort((a, b) => {
            const priorityOrder = { critical: 0, normal: 1, background: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
          });
          for (const callback of sortedCallbacks) {
            const callbackStartTime = performance.now();
            try {
              callback.callback(deltaTime, timestamp);
              const callbackTime = performance.now() - callbackStartTime;
              callback.totalTime += callbackTime;
              callback.frameCount++;
              callback.lastExecution = timestamp;
              if (callbackTime > this.frameTimeBudget * 0.5) {
                if (this.config.enableDebug) {
                  console.warn(`[EnhancedMasterAnimationCoordinator] Callback ${callback.id} exceeded budget: ${callbackTime.toFixed(2)}ms`);
                }
              }
            } catch (error) {
              console.error(`[EnhancedMasterAnimationCoordinator] Error in callback ${callback.id}:`, error);
            }
          }
        }
        /**
         * Execute animation systems with priority ordering and FPS throttling
         */
        executeAnimationSystems(deltaTime, timestamp) {
          const sortedSystems = Array.from(this.animations.values()).filter((animation) => animation.enabled).sort((a, b) => {
            const priorityOrder = { critical: 0, normal: 1, background: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
          });
          for (const animation of sortedSystems) {
            if (timestamp - animation.lastUpdate < animation.frameInterval) {
              animation.skippedFrames++;
              continue;
            }
            const systemStartTime = performance.now();
            try {
              if (animation.type === "visual") {
                animation.system.onAnimate(deltaTime, this.frameContext);
              } else {
                const animationSystem = animation.system;
                if (animationSystem.onAnimate) {
                  animationSystem.onAnimate(deltaTime);
                }
                if (animationSystem.updateAnimation) {
                  animationSystem.updateAnimation(timestamp, deltaTime);
                }
              }
              const systemTime = performance.now() - systemStartTime;
              animation.totalTime += systemTime;
              animation.frameCount++;
              animation.lastUpdate = timestamp;
              animation.averageFrameTime = animation.totalTime / animation.frameCount;
              animation.maxFrameTime = Math.max(animation.maxFrameTime, systemTime);
              if (systemTime > this.frameTimeBudget * 0.8) {
                if (this.config.enableDebug) {
                  console.warn(`[EnhancedMasterAnimationCoordinator] System ${animation.name} exceeded budget: ${systemTime.toFixed(2)}ms`);
                }
              }
            } catch (error) {
              console.error(`[EnhancedMasterAnimationCoordinator] Error in system ${animation.name}:`, error);
            }
          }
        }
        /**
         * Execute animation systems with frame time budget enforcement
         */
        executeAnimationSystemsWithBudget(deltaTime, timestamp, budget) {
          const startTime = performance.now();
          const sortedSystems = Array.from(this.animations.values()).filter((animation) => animation.enabled).sort((a, b) => {
            const priorityOrder = { critical: 0, normal: 1, background: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
          });
          let processedCount = 0;
          let skippedCount = 0;
          for (const animation of sortedSystems) {
            const elapsed = performance.now() - startTime;
            if (elapsed >= budget * 0.9) {
              skippedCount = sortedSystems.length - processedCount;
              if (this.config.enableDebug && skippedCount > 0) {
                console.warn(`[EnhancedMasterAnimationCoordinator] Budget exhausted: skipped ${skippedCount} systems`);
              }
              break;
            }
            if (timestamp - animation.lastUpdate < animation.frameInterval) {
              animation.skippedFrames++;
              continue;
            }
            const systemStartTime = performance.now();
            try {
              if (animation.type === "visual") {
                animation.system.onAnimate(deltaTime, this.frameContext);
              } else {
                const animationSystem = animation.system;
                if (animationSystem.onAnimate) {
                  animationSystem.onAnimate(deltaTime);
                }
                if (animationSystem.updateAnimation) {
                  animationSystem.updateAnimation(timestamp, deltaTime);
                }
              }
              const systemTime = performance.now() - systemStartTime;
              animation.totalTime += systemTime;
              animation.frameCount++;
              animation.lastUpdate = timestamp;
              animation.averageFrameTime = animation.totalTime / animation.frameCount;
              animation.maxFrameTime = Math.max(animation.maxFrameTime, systemTime);
              processedCount++;
              if (systemTime > budget * 0.3) {
                if (this.config.enableDebug) {
                  console.warn(`[EnhancedMasterAnimationCoordinator] System ${animation.name} consuming excessive budget: ${systemTime.toFixed(2)}ms`);
                }
              }
            } catch (error) {
              console.error(`[EnhancedMasterAnimationCoordinator] Error in system ${animation.name}:`, error);
              processedCount++;
            }
          }
          const totalTime = performance.now() - startTime;
          if (skippedCount > 0) {
            this.metrics.droppedFrames += skippedCount;
          }
          if (this.config.enableDebug && Math.random() < 0.02) {
            console.log(`[EnhancedMasterAnimationCoordinator] Budget usage: ${totalTime.toFixed(2)}ms/${budget.toFixed(2)}ms, processed: ${processedCount}/${sortedSystems.length}`);
          }
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics(frameTime) {
          this.metrics.totalFrames++;
          this.metrics.maxFrameTime = Math.max(this.metrics.maxFrameTime, frameTime);
          this.performanceHistory.push(frameTime);
          if (this.performanceHistory.length > this.MAX_HISTORY_SIZE) {
            this.performanceHistory.shift();
          }
          this.metrics.averageFrameTime = this.performanceHistory.reduce((sum, time) => sum + time, 0) / this.performanceHistory.length;
          this.metrics.frameRate = this.performanceHistory.length > 0 ? 1e3 / this.metrics.averageFrameTime : 60;
          if (frameTime > this.frameTimeBudget * 1.5) {
            this.metrics.droppedFrames++;
          }
          if (this.metrics.averageFrameTime > this.frameTimeBudget * 1.2 && this.metrics.performanceMode === "quality") {
            this.setPerformanceMode("performance");
            this.metrics.lastOptimization = Date.now();
          } else if (this.metrics.averageFrameTime < this.frameTimeBudget * 0.8 && this.metrics.performanceMode === "performance") {
            if (Date.now() - this.metrics.lastOptimization > 5e3) {
              this.setPerformanceMode("quality");
            }
          }
        }
        /**
         * Update frame budget based on performance mode
         */
        updateFrameBudget() {
          this.frameTimeBudget = this.metrics.performanceMode === "performance" ? 8 : 16;
          this.frameContext.frameBudget = this.frameTimeBudget;
        }
        /**
         * Update metrics counts
         */
        updateMetrics() {
          this.metrics.activeAnimations = Array.from(this.animations.values()).filter((a) => a.enabled).length;
          this.metrics.activeCallbacks = Array.from(this.frameCallbacks.values()).filter((c) => c.enabled).length;
        }
        /**
         * Subscribe to performance events
         */
        subscribeToEvents() {
          this.eventBus.subscribe("music:beat", (payload) => {
            this.frameContext.beatIntensity = payload.intensity || 0;
            this.coordinateConsciousnessBreathing(payload);
          }, "EnhancedMasterAnimationCoordinator");
          this.eventBus.subscribe("performance:frame", (payload) => {
            if (payload.fps < 45) {
              for (const animation of this.animations.values()) {
                animation.frameInterval = Math.min(animation.frameInterval * 1.5, 33.33);
              }
              this.setPerformanceMode("performance");
            } else if (payload.fps > 55) {
              this.setPerformanceMode("quality");
            }
          }, "EnhancedMasterAnimationCoordinator");
        }
        // =========================================================================
        // EMERGENT CHOREOGRAPHY ENGINE METHODS (from consolidation)
        // =========================================================================
        /**
         * Initialize emergent choreography functionality
         */
        async initializeEmergentChoreography() {
          try {
            this.signature = await temporalMemoryService.getSignature();
            this.registerEmergentEventListeners();
            this.saveInterval = setInterval(() => {
              if (this.signature) {
                temporalMemoryService.saveSignature(this.signature);
              }
            }, 3e4);
            if (this.config.enableDebug) {
              console.log("[EnhancedMasterAnimationCoordinator] Emergent choreography initialized");
            }
          } catch (error) {
            console.error("[EnhancedMasterAnimationCoordinator] Failed to initialize emergent choreography:", error);
          }
        }
        /**
         * Register emergent choreography event listeners
         */
        registerEmergentEventListeners() {
          const beatFrameSub = this.eventBus.subscribe(
            "music:beat",
            (payload) => this.handleBeatFrame(payload),
            "EnhancedMasterAnimationCoordinator"
          );
          const harmonyFrameSub = this.eventBus.subscribe(
            "colors:harmonized",
            (payload) => this.handleHarmonyFrame(payload),
            "EnhancedMasterAnimationCoordinator"
          );
          const bpmSub = this.eventBus.subscribe(
            "music:energy",
            (payload) => {
              this.currentBpm = payload.tempo;
            },
            "EnhancedMasterAnimationCoordinator"
          );
          const intensitySub = this.eventBus.subscribe(
            "music:beat",
            (payload) => {
              this.currentIntensity = payload.intensity;
            },
            "EnhancedMasterAnimationCoordinator"
          );
          this.emergentEventSubscriptions.push(
            beatFrameSub,
            harmonyFrameSub,
            bpmSub,
            intensitySub
          );
        }
        /**
         * Handle beat frame events for emergent adaptation
         */
        handleBeatFrame(payload) {
          if (!this.signature) return;
          this.signature.lastModified = Date.now();
          this.coordinateConsciousnessBreathing({
            intensity: payload.intensity || this.currentIntensity,
            energy: payload.energy || this.currentIntensity,
            bpm: this.currentBpm
          });
        }
        /**
         * Handle harmony frame events for emergent adaptation
         */
        handleHarmonyFrame(payload) {
          if (!this.signature) return;
          const { kineticState } = payload;
          this.signature.lastModified = Date.now();
        }
        /**
         * Update evolutionary trajectory based on signature trends
         */
        async _updateEvolutionaryTrajectory() {
          if (!this.signature) return;
          const trends = await temporalMemoryService.getSignatureTrends(
            this.signature
          );
          if (!trends) return;
          const { avgEnergy, avgValence } = trends;
          const explorationFactor = 0.5 + (avgEnergy - 0.5) * 0.2;
          this.signature.evolutionaryTrajectory.explorationFactor = Math.max(
            0.1,
            Math.min(0.9, explorationFactor)
          );
          const adaptability = 0.5 + (Math.abs(avgValence) - 0.2) * 0.3;
          this.signature.evolutionaryTrajectory.adaptability = Math.max(
            0.1,
            Math.min(0.9, adaptability)
          );
          this.signature.evolutionaryTrajectory.lastUpdate = Date.now();
        }
        /**
         * Calculate visual pulse based on current BPM and intensity
         */
        _calculateVisualPulse(deltaMs) {
          const beatInterval = 6e4 / this.currentBpm;
          const phase = performance.now() % beatInterval / beatInterval;
          const hueShift = Math.sin(phase * 2 * Math.PI + Math.PI / 2) * 15 * this.currentIntensity;
          return {
            timestamp: performance.now(),
            bpm: this.currentBpm,
            intensity: this.currentIntensity,
            phase,
            hueShift
          };
        }
        /**
         * Calculate adaptive coefficients based on signature
         */
        _calculateAdaptiveCoefficients() {
          if (!this.signature) return;
          const { adaptability, explorationFactor } = this.signature.evolutionaryTrajectory;
          const kineticIntensity = 0.5 + adaptability * 0.5;
          const visualIntensityBase = 0.8 + explorationFactor * 0.4;
          this.currentMultipliers = {
            ...this.config.cosmicMultipliers,
            kineticIntensity,
            visualIntensityBase
          };
        }
        /**
         * Process emergent choreography tick within animation loop
         */
        processEmergentTick(deltaMs) {
          if (!this.signature) return;
          this._calculateAdaptiveCoefficients();
          if (this.signature && Date.now() - this.signature.evolutionaryTrajectory.lastUpdate > 6e4) {
            this._updateEvolutionaryTrajectory();
          }
          const visualPulse = this._calculateVisualPulse(deltaMs);
          if (visualPulse) {
          }
          const emergentPayload = {
            timestamp: performance.now(),
            deltaMs
            // ...other emergent data to be calculated in later phases
          };
        }
        /**
         * Clean up emergent choreography resources
         */
        destroyEmergentChoreography() {
          if (this.signature) {
            temporalMemoryService.saveSignature(this.signature);
          }
          if (this.saveInterval) {
            clearInterval(this.saveInterval);
            this.saveInterval = null;
          }
          this.emergentEventSubscriptions.forEach((subscriptionId) => this.eventBus.unsubscribe(subscriptionId));
          this.emergentEventSubscriptions = [];
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Emergent choreography destroyed");
          }
        }
      };
      __name(_EnhancedMasterAnimationCoordinator, "EnhancedMasterAnimationCoordinator");
      _EnhancedMasterAnimationCoordinator.instance = null;
      EnhancedMasterAnimationCoordinator = _EnhancedMasterAnimationCoordinator;
    }
  });

  // src-js/core/performance/TimerConsolidationSystem.ts
  var _TimerConsolidationSystem, TimerConsolidationSystem;
  var init_TimerConsolidationSystem = __esm({
    "src-js/core/performance/TimerConsolidationSystem.ts"() {
      "use strict";
      _TimerConsolidationSystem = class _TimerConsolidationSystem {
        constructor(config = {}) {
          this._timerRegistry = /* @__PURE__ */ new Map();
          this._timerMasterInterval = null;
          this.config = {
            timerIntervalMs: config.timerIntervalMs || 50,
            maxTimerBudget: config.maxTimerBudget || 10,
            enableDebug: config.enableDebug || false,
            ...config
          };
          this._timerPerformanceMetrics = {
            totalExecutions: 0,
            totalTime: 0,
            maxExecutionTime: 0,
            averageExecutionTime: 0,
            skippedTimers: 0,
            timerCallbacks: /* @__PURE__ */ new Map()
          };
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Initialized");
          }
        }
        initialize() {
          if (this.config.enableDebug) {
            console.log(
              "\u23F1\uFE0F [TimerConsolidationSystem] Timer consolidation initialized"
            );
          }
        }
        registerConsolidatedTimer(timerId, callback, intervalMs, priority = "normal") {
          if (this._timerRegistry.has(timerId)) {
            console.warn(
              `[TimerConsolidationSystem] Timer ${timerId} already registered`
            );
            return;
          }
          const timerConfig = {
            callback,
            intervalMs,
            priority,
            lastExecution: 0,
            enabled: true,
            executionCount: 0,
            totalExecutionTime: 0,
            maxExecutionTime: 0,
            skippedExecutions: 0
          };
          this._timerRegistry.set(timerId, timerConfig);
          this._timerPerformanceMetrics.timerCallbacks.set(timerId, {
            calls: 0,
            totalTime: 0,
            maxTime: 0
          });
          if (this.config.enableDebug) {
            console.log(
              `\u23F1\uFE0F [TimerConsolidationSystem] Registered timer: ${timerId} (${intervalMs}ms, ${priority} priority)`
            );
          }
          if (this._timerRegistry.size === 1 && !this._timerMasterInterval) {
            this._startMasterTimer();
          }
        }
        unregisterConsolidatedTimer(timerId) {
          if (this._timerRegistry.has(timerId)) {
            this._timerRegistry.delete(timerId);
            this._timerPerformanceMetrics.timerCallbacks.delete(timerId);
            if (this.config.enableDebug) {
              console.log(
                `\u23F1\uFE0F [TimerConsolidationSystem] Unregistered timer: ${timerId}`
              );
            }
            if (this._timerRegistry.size === 0) {
              this._stopMasterTimer();
            }
          }
        }
        _startMasterTimer() {
          if (this._timerMasterInterval) return;
          this._timerMasterInterval = setInterval(() => {
            this._executeMasterTimerFrame();
          }, this.config.timerIntervalMs);
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Master timer started");
          }
        }
        _stopMasterTimer() {
          if (this._timerMasterInterval) {
            clearInterval(this._timerMasterInterval);
            this._timerMasterInterval = null;
          }
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Master timer stopped");
          }
        }
        _executeMasterTimerFrame() {
          const frameStartTime = performance.now();
          let remainingBudget = this.config.maxTimerBudget;
          const timersByPriority = Array.from(this._timerRegistry.entries()).sort(
            ([, a], [, b]) => {
              const priorityOrder = { critical: 0, normal: 1, background: 2 };
              return priorityOrder[a.priority] - priorityOrder[b.priority];
            }
          );
          for (const [timerId, config] of timersByPriority) {
            if (!config.enabled || remainingBudget <= 0 && config.priority === "background") {
              if (remainingBudget <= 0) config.skippedExecutions++;
              continue;
            }
            const timeSinceLastExecution = frameStartTime - config.lastExecution;
            if (timeSinceLastExecution < config.intervalMs) {
              continue;
            }
            const timerStartTime = performance.now();
            try {
              config.callback();
              const timerExecutionTime = performance.now() - timerStartTime;
              config.executionCount++;
              config.totalExecutionTime += timerExecutionTime;
              config.maxExecutionTime = Math.max(
                config.maxExecutionTime,
                timerExecutionTime
              );
              config.lastExecution = frameStartTime;
              const stats = this._timerPerformanceMetrics.timerCallbacks.get(timerId);
              if (stats) {
                stats.calls++;
                stats.totalTime += timerExecutionTime;
                stats.maxTime = Math.max(stats.maxTime, timerExecutionTime);
              }
              remainingBudget -= timerExecutionTime;
            } catch (error) {
              console.error(
                `[TimerConsolidationSystem] Error in timer ${timerId}:`,
                error
              );
              config.enabled = false;
            }
          }
          const totalFrameTime = performance.now() - frameStartTime;
          this._updateTimerPerformanceMetrics(totalFrameTime);
        }
        _updateTimerPerformanceMetrics(frameTime) {
          const metrics = this._timerPerformanceMetrics;
          metrics.totalExecutions++;
          metrics.totalTime += frameTime;
          metrics.maxExecutionTime = Math.max(metrics.maxExecutionTime, frameTime);
          metrics.averageExecutionTime = metrics.totalTime / metrics.totalExecutions;
          if (frameTime > this.config.maxTimerBudget) {
            metrics.skippedTimers++;
          }
        }
        destroy() {
          this._stopMasterTimer();
          this._timerRegistry.clear();
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Destroyed");
          }
        }
      };
      __name(_TimerConsolidationSystem, "TimerConsolidationSystem");
      TimerConsolidationSystem = _TimerConsolidationSystem;
    }
  });

  // src-js/core/performance/PerformanceAwareLerpCoordinator.ts
  var _PerformanceAwareLerpCoordinator, PerformanceAwareLerpCoordinator;
  var init_PerformanceAwareLerpCoordinator = __esm({
    "src-js/core/performance/PerformanceAwareLerpCoordinator.ts"() {
      "use strict";
      init_globalConfig();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      _PerformanceAwareLerpCoordinator = class _PerformanceAwareLerpCoordinator {
        // 3 seconds
        constructor() {
          this.initialized = false;
          this.performanceOrchestrator = null;
          // Performance thresholds and targets
          this.performanceThresholds = {
            excellent: { minFPS: 58, maxFrameTime: 17, maxCPU: 0.15 },
            good: { minFPS: 50, maxFrameTime: 20, maxCPU: 0.25 },
            degraded: { minFPS: 40, maxFrameTime: 25, maxCPU: 0.35 },
            critical: { minFPS: 30, maxFrameTime: 33, maxCPU: 0.5 }
          };
          // Quality tier configurations
          this.qualityTierConfigs = /* @__PURE__ */ new Map([
            [
              "minimal",
              {
                halfLife: 0.2,
                performanceMultiplier: 0.3,
                complexityReduction: 0.8,
                updateFrequency: 0.5,
                enableBeatPhase: false,
                enableEnergyModulation: false,
                enableTemperatureMapping: false,
                useSimplifiedCalculations: true,
                skipNonCriticalUpdates: true,
                batchUpdates: true
              }
            ],
            [
              "low",
              {
                halfLife: 0.15,
                performanceMultiplier: 0.5,
                complexityReduction: 0.6,
                updateFrequency: 0.7,
                enableBeatPhase: false,
                enableEnergyModulation: true,
                enableTemperatureMapping: false,
                useSimplifiedCalculations: true,
                skipNonCriticalUpdates: true,
                batchUpdates: true
              }
            ],
            [
              "medium",
              {
                halfLife: 0.1,
                performanceMultiplier: 0.8,
                complexityReduction: 0.4,
                updateFrequency: 0.8,
                enableBeatPhase: true,
                enableEnergyModulation: true,
                enableTemperatureMapping: true,
                useSimplifiedCalculations: false,
                skipNonCriticalUpdates: false,
                batchUpdates: false
              }
            ],
            [
              "high",
              {
                halfLife: 0.08,
                performanceMultiplier: 1,
                complexityReduction: 0.2,
                updateFrequency: 0.9,
                enableBeatPhase: true,
                enableEnergyModulation: true,
                enableTemperatureMapping: true,
                useSimplifiedCalculations: false,
                skipNonCriticalUpdates: false,
                batchUpdates: false
              }
            ],
            [
              "ultra",
              {
                halfLife: 0.05,
                performanceMultiplier: 1.2,
                complexityReduction: 0,
                updateFrequency: 1,
                enableBeatPhase: true,
                enableEnergyModulation: true,
                enableTemperatureMapping: true,
                useSimplifiedCalculations: false,
                skipNonCriticalUpdates: false,
                batchUpdates: false
              }
            ]
          ]);
          // Performance adaptation state
          this.lastPerformanceCheck = 0;
          this.performanceCheckInterval = 1e3;
          // 1 second
          this.lastQualityAdjustment = 0;
          this.qualityAdjustmentCooldown = 3e3;
          this.eventBus = unifiedEventBus;
          this.currentPerformanceContext = this.createDefaultPerformanceContext();
          this.currentLerpParams = this.qualityTierConfigs.get("medium");
          this.performanceMetrics = this.createDefaultMetrics();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3KDebug?.debug?.log(
              "PerformanceAwareLerpCoordinator",
              "Performance-aware LERP coordinator initialized"
            );
          }
        }
        // ========================================================================
        // IMANAGEDYSTEM INTERFACE IMPLEMENTATION
        // ========================================================================
        async initialize() {
          if (this.initialized) return;
          try {
            this.subscribeToPerformanceEvents();
            this.startPerformanceMonitoring();
            this.initialized = true;
            if (YEAR3000_CONFIG.enableDebug) {
              Y3KDebug?.debug?.log(
                "PerformanceAwareLerpCoordinator",
                "Performance-aware LERP coordination fully initialized"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "PerformanceAwareLerpCoordinator",
              "Initialization failed:",
              error
            );
            throw error;
          }
        }
        updateAnimation(deltaTime) {
          this.updatePerformanceMetrics(deltaTime);
          if (this.shouldAdaptPerformance()) {
            this.adaptLerpPerformance();
          }
        }
        async healthCheck() {
          const metrics = this.performanceMetrics;
          const frameTimeImpact = metrics.frameTimeImpact;
          const calculationTime = metrics.averageCalculationTime;
          const isHealthy = frameTimeImpact < 1 && // < 1ms frame impact
          calculationTime < 0.1 && // < 0.1ms per calculation
          metrics.musicalAccuracy > 0.7;
          return {
            system: "PerformanceAwareLerpCoordinator",
            healthy: isHealthy,
            ok: isHealthy,
            details: isHealthy ? "Performance-aware LERP coordination operating efficiently" : `Performance issues: impact=${frameTimeImpact.toFixed(
              2
            )}ms, calc=${calculationTime.toFixed(3)}ms`,
            metrics: {
              frameTimeImpact,
              averageCalculationTime: calculationTime,
              musicalAccuracy: metrics.musicalAccuracy,
              qualityLevel: this.currentPerformanceContext.qualityLevel,
              thermalState: this.currentPerformanceContext.thermalState,
              calculationsPerSecond: metrics.calculationsPerSecond
            }
          };
        }
        destroy() {
          this.stopPerformanceMonitoring();
          this.unsubscribeFromPerformanceEvents();
          this.initialized = false;
          if (YEAR3000_CONFIG.enableDebug) {
            Y3KDebug?.debug?.log(
              "PerformanceAwareLerpCoordinator",
              "Performance-aware LERP coordinator destroyed"
            );
          }
        }
        // ========================================================================
        // PUBLIC API - PERFORMANCE-AWARE LERP FUNCTIONS
        // ========================================================================
        /**
         * Calculate performance-aware musical LERP with complete system integration
         */
        calculatePerformanceAwareMusicalLerp(current, target, deltaTime, musicalContext, animationType = "flow", baseHalfLife) {
          const startTime = performance.now();
          const lerpParams = this.getCurrentLerpParams();
          const effectiveHalfLife = this.calculateEffectiveHalfLife(
            musicalContext,
            animationType,
            baseHalfLife,
            lerpParams
          );
          let result;
          if (lerpParams.useSimplifiedCalculations || !musicalContext) {
            result = this.calculateSimplifiedLerp(
              current,
              target,
              deltaTime,
              effectiveHalfLife
            );
          } else {
            result = this.calculateFullMusicalLerp(
              current,
              target,
              deltaTime,
              musicalContext,
              animationType,
              effectiveHalfLife,
              lerpParams
            );
          }
          const calculationTime = performance.now() - startTime;
          this.updateCalculationMetrics(calculationTime);
          return result;
        }
        /**
         * Get current performance context for external systems
         */
        getCurrentPerformanceContext() {
          return { ...this.currentPerformanceContext };
        }
        /**
         * Get current LERP parameters for external systems
         */
        getCurrentLerpParams() {
          return { ...this.currentLerpParams };
        }
        /**
         * Get performance metrics for monitoring
         */
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Set reference to consolidated SimplePerformanceCoordinator (Phase 3 integration)
         */
        setSimplePerformanceCoordinator(orchestrator) {
          this.performanceOrchestrator = orchestrator;
          if (YEAR3000_CONFIG.enableDebug) {
            Y3KDebug?.debug?.log(
              "PerformanceAwareLerpCoordinator",
              "Integrated with consolidated SimplePerformanceCoordinator"
            );
          }
        }
        /**
         * Sync performance state from consolidated SimplePerformanceCoordinator
         */
        syncWithOrchestrator() {
          if (!this.performanceOrchestrator) return;
          try {
            const orchestratorState = this.performanceOrchestrator.getCurrentPerformanceState?.();
            if (orchestratorState) {
              const performanceContext = {
                currentFPS: orchestratorState.currentFPS || this.currentPerformanceContext.currentFPS,
                frameTimeMs: orchestratorState.frameTimeMs || this.currentPerformanceContext.frameTimeMs,
                qualityLevel: orchestratorState.qualityLevel || this.currentPerformanceContext.qualityLevel,
                thermalState: orchestratorState.thermalState || this.currentPerformanceContext.thermalState,
                memoryPressure: orchestratorState.memoryPressure || this.currentPerformanceContext.memoryPressure,
                cpuUtilization: orchestratorState.cpuUtilization || this.currentPerformanceContext.cpuUtilization
              };
              this.updatePerformanceState(performanceContext);
            }
          } catch (error) {
            if (YEAR3000_CONFIG.enableDebug) {
              Y3KDebug?.debug?.warn(
                "PerformanceAwareLerpCoordinator",
                "Failed to sync with orchestrator:",
                error
              );
            }
          }
        }
        /**
         * Force performance state update (for external performance systems)
         */
        updatePerformanceState(performanceState) {
          this.currentPerformanceContext = {
            ...this.currentPerformanceContext,
            ...performanceState
          };
          this.adaptLerpParameters();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3KDebug?.debug?.log(
              "PerformanceAwareLerpCoordinator",
              "Performance state updated",
              {
                qualityLevel: this.currentPerformanceContext.qualityLevel,
                currentFPS: this.currentPerformanceContext.currentFPS,
                thermalState: this.currentPerformanceContext.thermalState
              }
            );
          }
        }
        // ========================================================================
        // PRIVATE IMPLEMENTATION - PERFORMANCE ADAPTATION
        // ========================================================================
        createDefaultPerformanceContext() {
          return {
            currentFPS: 60,
            targetFPS: 60,
            frameTimeMs: 16.67,
            frameBudgetMs: 16.67,
            qualityLevel: "medium",
            qualityScore: 0.5,
            deviceTier: "medium",
            thermalState: "nominal",
            powerLevel: "balanced",
            memoryPressure: "low",
            cpuUtilization: 0.2,
            memoryUtilization: 0.3,
            gpuUtilization: 0.2
          };
        }
        createDefaultMetrics() {
          return {
            averageCalculationTime: 0,
            calculationsPerSecond: 0,
            frameTimeImpact: 0,
            cpuImpact: 0,
            memoryImpact: 0,
            musicalAccuracy: 1,
            smoothnessQuality: 1,
            responsiveness: 1,
            qualityReductions: 0,
            performanceRecoveries: 0
          };
        }
        subscribeToPerformanceEvents() {
        }
        unsubscribeFromPerformanceEvents() {
        }
        startPerformanceMonitoring() {
        }
        stopPerformanceMonitoring() {
        }
        shouldAdaptPerformance() {
          const now = performance.now();
          if (now - this.lastPerformanceCheck < this.performanceCheckInterval) {
            return false;
          }
          this.lastPerformanceCheck = now;
          const context = this.currentPerformanceContext;
          const performanceIssue = context.currentFPS < context.targetFPS * 0.9 || context.frameTimeMs > context.frameBudgetMs * 1.2 || context.thermalState !== "nominal" || context.memoryPressure === "high";
          const canRecoverQuality = context.currentFPS > context.targetFPS * 1.1 && context.frameTimeMs < context.frameBudgetMs * 0.8 && context.thermalState === "nominal" && now - this.lastQualityAdjustment > this.qualityAdjustmentCooldown;
          return performanceIssue || canRecoverQuality;
        }
        adaptLerpPerformance() {
          const context = this.currentPerformanceContext;
          const shouldReduceQuality = context.currentFPS < context.targetFPS * 0.8 || context.frameTimeMs > context.frameBudgetMs * 1.3 || context.thermalState === "hot" || context.thermalState === "critical" || context.memoryPressure === "high";
          const canIncreaseQuality = context.currentFPS > context.targetFPS * 1.1 && context.frameTimeMs < context.frameBudgetMs * 0.7 && context.thermalState === "nominal" && context.memoryPressure === "low";
          if (shouldReduceQuality) {
            this.reducePerformanceQuality();
          } else if (canIncreaseQuality) {
            this.increasePerformanceQuality();
          }
        }
        reducePerformanceQuality() {
          const currentParams = this.currentLerpParams;
          currentParams.performanceMultiplier = Math.min(
            2,
            currentParams.performanceMultiplier * 1.2
          );
          currentParams.complexityReduction = Math.min(
            0.9,
            currentParams.complexityReduction + 0.1
          );
          currentParams.updateFrequency = Math.max(
            0.3,
            currentParams.updateFrequency * 0.9
          );
          if (currentParams.enableTemperatureMapping) {
            currentParams.enableTemperatureMapping = false;
          } else if (currentParams.enableEnergyModulation) {
            currentParams.enableEnergyModulation = false;
          } else if (currentParams.enableBeatPhase) {
            currentParams.enableBeatPhase = false;
          }
          currentParams.useSimplifiedCalculations = true;
          currentParams.skipNonCriticalUpdates = true;
          currentParams.batchUpdates = true;
          this.performanceMetrics.qualityReductions++;
          this.lastQualityAdjustment = performance.now();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3KDebug?.debug?.warn(
              "PerformanceAwareLerpCoordinator",
              "Reduced LERP quality for performance",
              {
                performanceMultiplier: currentParams.performanceMultiplier,
                complexityReduction: currentParams.complexityReduction
              }
            );
          }
        }
        increasePerformanceQuality() {
          const currentParams = this.currentLerpParams;
          currentParams.performanceMultiplier = Math.max(
            0.5,
            currentParams.performanceMultiplier * 0.9
          );
          currentParams.complexityReduction = Math.max(
            0,
            currentParams.complexityReduction - 0.1
          );
          currentParams.updateFrequency = Math.min(
            1,
            currentParams.updateFrequency * 1.1
          );
          if (!currentParams.enableBeatPhase && currentParams.complexityReduction < 0.3) {
            currentParams.enableBeatPhase = true;
          } else if (!currentParams.enableEnergyModulation && currentParams.complexityReduction < 0.2) {
            currentParams.enableEnergyModulation = true;
          } else if (!currentParams.enableTemperatureMapping && currentParams.complexityReduction < 0.1) {
            currentParams.enableTemperatureMapping = true;
          }
          this.performanceMetrics.performanceRecoveries++;
          this.lastQualityAdjustment = performance.now();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3KDebug?.debug?.log(
              "PerformanceAwareLerpCoordinator",
              "Increased LERP quality",
              {
                performanceMultiplier: currentParams.performanceMultiplier,
                complexityReduction: currentParams.complexityReduction
              }
            );
          }
        }
        adaptLerpParameters() {
          const context = this.currentPerformanceContext;
          const qualityConfig = this.qualityTierConfigs.get(context.qualityLevel);
          if (qualityConfig) {
            this.currentLerpParams = { ...qualityConfig };
            if (context.thermalState === "warm") {
              this.currentLerpParams.performanceMultiplier *= 1.2;
            } else if (context.thermalState === "hot") {
              this.currentLerpParams.performanceMultiplier *= 1.5;
              this.currentLerpParams.enableTemperatureMapping = false;
            } else if (context.thermalState === "critical") {
              this.currentLerpParams.performanceMultiplier *= 2;
              this.currentLerpParams.enableTemperatureMapping = false;
              this.currentLerpParams.enableEnergyModulation = false;
              this.currentLerpParams.useSimplifiedCalculations = true;
            }
            if (context.powerLevel === "battery-saver") {
              this.currentLerpParams.performanceMultiplier *= 1.5;
              this.currentLerpParams.enableTemperatureMapping = false;
              this.currentLerpParams.updateFrequency *= 0.7;
            }
            if (context.memoryPressure === "high") {
              this.currentLerpParams.batchUpdates = true;
              this.currentLerpParams.skipNonCriticalUpdates = true;
              this.currentLerpParams.updateFrequency *= 0.8;
            }
          }
        }
        // ========================================================================
        // PRIVATE IMPLEMENTATION - LERP CALCULATIONS
        // ========================================================================
        calculateEffectiveHalfLife(musicalContext, animationType, baseHalfLife, lerpParams) {
          let halfLife = baseHalfLife || lerpParams.halfLife;
          halfLife *= lerpParams.performanceMultiplier;
          if (musicalContext && lerpParams.enableEnergyModulation) {
            const tempoFactor = Math.max(
              0.5,
              Math.min(2, musicalContext.tempo / 120)
            );
            halfLife /= tempoFactor;
            if (lerpParams.enableEnergyModulation) {
              const energyFactor = 0.7 + musicalContext.energy * 0.6;
              halfLife /= energyFactor;
            }
          }
          return Math.max(0.01, Math.min(1, halfLife));
        }
        calculateSimplifiedLerp(current, target, deltaTime, halfLife) {
          const factor = Math.pow(2, -(deltaTime / 1e3) / halfLife);
          return current + (target - current) * (1 - factor);
        }
        calculateFullMusicalLerp(current, target, deltaTime, musicalContext, animationType, effectiveHalfLife, lerpParams) {
          let result = this.calculateSimplifiedLerp(
            current,
            target,
            deltaTime,
            effectiveHalfLife
          );
          if (lerpParams.enableBeatPhase && musicalContext.beatPhase) {
            const beatPhaseModifier = this.calculateBeatPhaseModifier(
              musicalContext.beatPhase,
              musicalContext.timeSinceLastBeat,
              musicalContext.beatInterval,
              animationType
            );
            const phaseInfluence = lerpParams.complexityReduction > 0.5 ? 0.1 : 0.2;
            result += (target - current) * beatPhaseModifier * phaseInfluence;
          }
          if (lerpParams.enableEnergyModulation && musicalContext.danceability > 0) {
            const danceabilityFactor = 0.9 + musicalContext.danceability * 0.2;
            result = current + (result - current) * danceabilityFactor;
          }
          return result;
        }
        calculateBeatPhaseModifier(beatPhase, timeSinceLastBeat, beatInterval, animationType) {
          switch (beatPhase) {
            case "attack":
              return animationType === "pulse" ? 0.3 : 0.1;
            case "sustain":
              return animationType === "flow" ? 0.1 : 0.05;
            case "decay":
              return animationType === "pulse" ? -0.1 : -0.05;
            case "rest":
              return 0;
            default:
              return 0;
          }
        }
        // ========================================================================
        // PRIVATE IMPLEMENTATION - METRICS AND MONITORING
        // ========================================================================
        updatePerformanceMetrics(deltaTime) {
          const currentImpact = this.performanceMetrics.frameTimeImpact;
          this.performanceMetrics.frameTimeImpact = currentImpact * 0.9 + 0 * 0.1;
          const calculationsThisFrame = 1;
          this.performanceMetrics.calculationsPerSecond = this.performanceMetrics.calculationsPerSecond * 0.95 + calculationsThisFrame / (deltaTime / 1e3) * 0.05;
        }
        updateCalculationMetrics(calculationTime) {
          const currentAvg = this.performanceMetrics.averageCalculationTime;
          this.performanceMetrics.averageCalculationTime = currentAvg * 0.9 + calculationTime * 0.1;
          const currentImpact = this.performanceMetrics.frameTimeImpact;
          this.performanceMetrics.frameTimeImpact = currentImpact * 0.9 + calculationTime * 0.1;
          const params = this.currentLerpParams;
          let accuracy = 1;
          if (!params.enableBeatPhase) accuracy -= 0.2;
          if (!params.enableEnergyModulation) accuracy -= 0.15;
          if (!params.enableTemperatureMapping) accuracy -= 0.1;
          if (params.useSimplifiedCalculations) accuracy -= 0.1;
          this.performanceMetrics.musicalAccuracy = Math.max(0.3, accuracy);
          this.performanceMetrics.smoothnessQuality = Math.max(
            0.5,
            1 - (params.performanceMultiplier - 1) * 0.3
          );
          this.performanceMetrics.responsiveness = params.updateFrequency;
        }
        // ========================================================================
        // EVENT HANDLERS
        // ========================================================================
        handleQualityChange(data) {
          const { newLevel } = data;
          if (newLevel && newLevel.level) {
            this.currentPerformanceContext.qualityLevel = newLevel.level;
            this.adaptLerpParameters();
          }
        }
        handleThermalWarning(data) {
          this.currentPerformanceContext.thermalState = "hot";
          this.adaptLerpParameters();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3KDebug?.debug?.warn(
              "PerformanceAwareLerpCoordinator",
              "Thermal warning - adapting LERP performance"
            );
          }
        }
        handleQualityLevelChange(data) {
          const { newLevel } = data;
          if (newLevel && typeof newLevel.level === "string") {
            this.currentPerformanceContext.qualityLevel = newLevel.level;
            this.adaptLerpParameters();
          }
        }
      };
      __name(_PerformanceAwareLerpCoordinator, "PerformanceAwareLerpCoordinator");
      PerformanceAwareLerpCoordinator = _PerformanceAwareLerpCoordinator;
    }
  });

  // src-js/core/performance/EnhancedDeviceTierDetector.ts
  var _EnhancedDeviceTierDetector, EnhancedDeviceTierDetector;
  var init_EnhancedDeviceTierDetector = __esm({
    "src-js/core/performance/EnhancedDeviceTierDetector.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _EnhancedDeviceTierDetector = class _EnhancedDeviceTierDetector {
        /**
         * Detect device performance tier with focus on giving most users full experience
         */
        static detectTier() {
          const capabilities = this._analyzeDeviceCapabilities();
          const reasoning = [];
          let tier = "medium";
          let confidence = 0.8;
          if (this._isHighTierDevice(capabilities, reasoning)) {
            tier = "high";
            confidence = 0.9;
          } else if (this._isLowTierDevice(capabilities, reasoning)) {
            tier = "low";
            confidence = 0.85;
          } else {
            reasoning.push("Standard modern device - full experience enabled");
            reasoning.push(`${capabilities.memory}GB RAM, ${capabilities.cores} cores, WebGL2: ${capabilities.webgl2}`);
          }
          const result = {
            tier,
            confidence,
            reasoning,
            capabilities
          };
          Y3KDebug?.debug?.log("EnhancedDeviceTierDetector", "Tier detection complete", result);
          return result;
        }
        static _analyzeDeviceCapabilities() {
          const memory = navigator.deviceMemory || this._estimateMemory();
          const cores = navigator.hardwareConcurrency || this._estimateCores();
          const webgl = this._checkWebGLSupport();
          const webgl2 = this._checkWebGL2Support();
          const userAgent = navigator.userAgent;
          const platform = navigator.platform || "unknown";
          return {
            memory,
            cores,
            webgl,
            webgl2,
            userAgent,
            platform,
            hardwareInfo: {
              isHighEnd: this._detectHighEndHardware(memory, cores, userAgent),
              isMobile: this._isMobileDevice(userAgent, platform),
              isOldDevice: this._isOldDevice(userAgent),
              hasPerformanceIndicators: this._hasPerformanceIndicators(userAgent)
            }
          };
        }
        static _isHighTierDevice(capabilities, reasoning) {
          const { memory, cores, webgl2, hardwareInfo } = capabilities;
          const hasHighEndSpecs = memory >= 8 && cores >= 6 && webgl2;
          if (!hasHighEndSpecs) {
            return false;
          }
          const indicators = [];
          if (memory >= 16) indicators.push("16+GB RAM");
          if (cores >= 8) indicators.push("8+ CPU cores");
          if (hardwareInfo.hasPerformanceIndicators) indicators.push("Performance GPU detected");
          if (hardwareInfo.isHighEnd) indicators.push("High-end hardware signatures");
          if (indicators.length >= 2) {
            reasoning.push("High-end device detected");
            reasoning.push(`Specs: ${memory}GB RAM, ${cores} cores, WebGL2: ${webgl2}`);
            reasoning.push(`Indicators: ${indicators.join(", ")}`);
            return true;
          }
          if (this._isGamingOrWorkstation(capabilities)) {
            reasoning.push("Gaming/workstation device detected");
            reasoning.push(`High-performance device indicators found`);
            return true;
          }
          return false;
        }
        static _isLowTierDevice(capabilities, reasoning) {
          const { memory, cores, webgl2, hardwareInfo } = capabilities;
          const reasons = [];
          if (memory < 4) {
            reasons.push(`Low memory: ${memory}GB`);
          }
          if (cores < 4) {
            reasons.push(`Few CPU cores: ${cores}`);
          }
          if (!webgl2) {
            reasons.push("No WebGL2 support");
          }
          if (hardwareInfo.isOldDevice) {
            reasons.push("Legacy device detected");
          }
          if (hardwareInfo.isMobile && memory <= 4 && cores <= 4) {
            reasons.push("Resource-constrained mobile device");
          }
          if (reasons.length >= 2) {
            reasoning.push("Budget/legacy device detected - enabling performance optimizations");
            reasoning.push(...reasons);
            return true;
          }
          return false;
        }
        static _estimateMemory() {
          const ua = navigator.userAgent.toLowerCase();
          if (ua.includes("mobile") || ua.includes("android")) {
            return 4;
          }
          if (ua.includes("ipad") || ua.includes("tablet")) {
            return 6;
          }
          return 8;
        }
        static _estimateCores() {
          const ua = navigator.userAgent.toLowerCase();
          if (ua.includes("mobile")) {
            return 4;
          }
          return 4;
        }
        static _checkWebGLSupport() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            const hasWebGL = gl !== null;
            canvas.remove();
            return hasWebGL;
          } catch {
            return false;
          }
        }
        static _checkWebGL2Support() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl2");
            const hasWebGL2 = gl !== null;
            canvas.remove();
            return hasWebGL2;
          } catch {
            return false;
          }
        }
        static _detectHighEndHardware(memory, cores, userAgent) {
          const ua = userAgent.toLowerCase();
          const indicators = [
            ua.includes("gaming"),
            ua.includes("nvidia"),
            ua.includes("amd"),
            ua.includes("geforce"),
            ua.includes("radeon"),
            memory >= 16,
            cores >= 8
          ];
          return indicators.filter(Boolean).length >= 2;
        }
        static _isMobileDevice(userAgent, platform) {
          const ua = userAgent.toLowerCase();
          const p = platform.toLowerCase();
          return ua.includes("mobile") || ua.includes("android") || ua.includes("iphone") || ua.includes("ipad") || p.includes("arm") || "ontouchstart" in window;
        }
        static _isOldDevice(userAgent) {
          const ua = userAgent.toLowerCase();
          const oldBrowsers = [
            /chrome\/[1-6]\d\./,
            // Chrome < 70
            /firefox\/[1-5]\d\./,
            // Firefox < 60
            /safari\/[1-9]\./,
            // Very old Safari
            /msie|trident/
            // Internet Explorer
          ];
          return oldBrowsers.some((pattern) => pattern.test(ua));
        }
        static _hasPerformanceIndicators(userAgent) {
          const ua = userAgent.toLowerCase();
          const indicators = [
            "nvidia",
            "amd",
            "geforce",
            "radeon",
            "quadro",
            "gaming",
            "performance"
          ];
          return indicators.some((indicator) => ua.includes(indicator));
        }
        static _isGamingOrWorkstation(capabilities) {
          const { userAgent, memory, cores } = capabilities;
          const ua = userAgent.toLowerCase();
          const gamingIndicators = [
            ua.includes("gaming"),
            ua.includes("rog"),
            // ASUS ROG
            ua.includes("msi"),
            ua.includes("alienware"),
            ua.includes("predator"),
            // Acer Predator
            memory >= 16 && cores >= 8
          ];
          return gamingIndicators.some(Boolean);
        }
        /**
         * Get a human-readable description of the device capabilities
         */
        static getDeviceDescription(capabilities) {
          const { memory, cores, webgl2, hardwareInfo } = capabilities;
          let description = `${memory}GB RAM, ${cores} CPU cores`;
          if (webgl2) description += ", WebGL2";
          if (hardwareInfo.isHighEnd) description += ", High-end hardware";
          if (hardwareInfo.isMobile) description += ", Mobile device";
          if (hardwareInfo.hasPerformanceIndicators) description += ", Performance GPU";
          return description;
        }
      };
      __name(_EnhancedDeviceTierDetector, "EnhancedDeviceTierDetector");
      EnhancedDeviceTierDetector = _EnhancedDeviceTierDetector;
    }
  });

  // src-js/core/performance/SimpleTierBasedPerformanceSystem.ts
  var _SimpleTierBasedPerformanceSystem, SimpleTierBasedPerformanceSystem;
  var init_SimpleTierBasedPerformanceSystem = __esm({
    "src-js/core/performance/SimpleTierBasedPerformanceSystem.ts"() {
      "use strict";
      init_EnhancedDeviceTierDetector();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      _SimpleTierBasedPerformanceSystem = class _SimpleTierBasedPerformanceSystem {
        constructor(enhancedDeviceTierDetector) {
          this.initialized = false;
          this.webglIntegration = null;
          // Performance state
          this.deviceTier = "medium";
          this.tierDetectionResult = null;
          this.energyBoostActive = false;
          this.energyBoostTimeout = null;
          // Configuration
          this.tierSettings = {
            low: {
              webglQuality: "low",
              animationDensity: 0.6,
              // Still decent for budget devices
              updateFrequency: 45,
              // Smooth enough
              particleMultiplier: 0.4,
              corridorEffects: false,
              // Only restriction for low tier
              advancedFeatures: false,
              experimentalFeatures: false
            },
            medium: {
              webglQuality: "high",
              // Full experience for standard devices
              animationDensity: 0.9,
              // Near maximum
              updateFrequency: 60,
              // Full smoothness
              particleMultiplier: 1,
              // Full particles
              corridorEffects: true,
              // Full corridor effects
              advancedFeatures: true,
              // All standard features
              experimentalFeatures: false
            },
            high: {
              webglQuality: "high",
              animationDensity: 1,
              // Maximum
              updateFrequency: 60,
              particleMultiplier: 1.2,
              // Extra particles for high-end
              corridorEffects: true,
              advancedFeatures: true,
              experimentalFeatures: true
              // Experimental features for enthusiasts
            }
          };
          this.energyBoostSettings = {
            animationBoost: 1.3,
            // 30% boost during energetic songs
            particleBoost: 1.5,
            // 50% more particles
            duration: 1e4
            // 10 seconds after song change
          };
          this.enhancedDeviceTierDetector = enhancedDeviceTierDetector;
          this.currentSettings = this.tierSettings.medium;
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "Initialized with tier-based performance management");
        }
        async initialize() {
          if (this.initialized) return;
          this.tierDetectionResult = EnhancedDeviceTierDetector.detectTier();
          this.deviceTier = this.tierDetectionResult.tier;
          this.currentSettings = this.tierSettings[this.deviceTier];
          this._setupMusicAnalysisListener();
          this._applyTierSettings();
          this.initialized = true;
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "Initialization complete", {
            deviceTier: this.deviceTier,
            confidence: this.tierDetectionResult.confidence,
            reasoning: this.tierDetectionResult.reasoning,
            deviceDescription: EnhancedDeviceTierDetector.getDeviceDescription(this.tierDetectionResult.capabilities),
            settings: this.currentSettings
          });
        }
        async healthCheck() {
          if (!this.initialized) {
            return {
              healthy: false,
              details: "Not initialized",
              system: "SimpleTierBasedPerformanceSystem"
            };
          }
          return {
            healthy: true,
            details: `Performance tier: ${this.deviceTier}, Energy boost: ${this.energyBoostActive ? "active" : "inactive"}`,
            system: "SimpleTierBasedPerformanceSystem"
          };
        }
        destroy() {
          if (this.energyBoostTimeout) {
            clearTimeout(this.energyBoostTimeout);
            this.energyBoostTimeout = null;
          }
          unifiedEventBus.unsubscribe("colors:extracted");
          unifiedEventBus.unsubscribe("music:track-changed");
          this.initialized = false;
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "Destroyed");
        }
        updateAnimation(deltaTime) {
        }
        // =============================================================================
        // PUBLIC API
        // =============================================================================
        /**
         * Register WebGL integration for performance management
         */
        registerWebGLIntegration(integration) {
          this.webglIntegration = integration;
          if (this.initialized) {
            this._applyWebGLSettings();
          }
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "WebGL integration registered");
        }
        /**
         * Get detected device tier
         */
        getDeviceTier() {
          return this.deviceTier;
        }
        /**
         * Get full tier detection result including reasoning and device capabilities
         */
        getTierDetectionResult() {
          return this.tierDetectionResult;
        }
        /**
         * Get human-readable device description
         */
        getDeviceDescription() {
          return this.tierDetectionResult ? EnhancedDeviceTierDetector.getDeviceDescription(this.tierDetectionResult.capabilities) : "Unknown device";
        }
        /**
         * Get current tier settings
         */
        getCurrentSettings() {
          return { ...this.currentSettings };
        }
        /**
         * Check if energy boost is currently active
         */
        hasEnergyBoost() {
          return this.energyBoostActive;
        }
        /**
         * Get effective settings including energy boost
         */
        getEffectiveSettings() {
          const base = { ...this.currentSettings };
          if (this.energyBoostActive) {
            return {
              ...base,
              animationDensity: Math.min(1, base.animationDensity * this.energyBoostSettings.animationBoost),
              particleMultiplier: base.particleMultiplier * this.energyBoostSettings.particleBoost,
              energyBoosted: true
            };
          }
          return {
            ...base,
            energyBoosted: false
          };
        }
        /**
         * Force a specific tier (for testing/debugging)
         */
        setTier(tier) {
          this.deviceTier = tier;
          this.currentSettings = this.tierSettings[tier];
          this._applyTierSettings();
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", `Tier manually set to ${tier}`);
        }
        // =============================================================================
        // PRIVATE IMPLEMENTATION
        // =============================================================================
        _setupMusicAnalysisListener() {
          unifiedEventBus.subscribe("colors:extracted", (data) => {
            if (data.musicData) {
              this._handleMusicAnalysis({
                energy: data.musicData.energy || 0.5,
                valence: data.musicData.valence || 0.5,
                bpm: data.musicData.tempo || 120,
                genre: data.musicData.genre || "unknown"
              });
            }
          });
          unifiedEventBus.subscribe("music:track-changed", (data) => {
            this._handleSongChange(data);
          });
        }
        _handleSongChange(data) {
          if (data.analysis) {
            this._checkEnergyBoost(data.analysis);
          }
        }
        _handleMusicAnalysis(analysis) {
          this._checkEnergyBoost(analysis);
        }
        _checkEnergyBoost(analysis) {
          const isEnergeticSong = analysis.energy > 0.7 && analysis.bpm > 130 && (analysis.danceability || 0) > 0.6;
          const shouldBoost = isEnergeticSong && !this.energyBoostActive;
          const shouldUnboost = !isEnergeticSong && this.energyBoostActive;
          if (shouldBoost) {
            this._activateEnergyBoost(analysis);
          } else if (shouldUnboost) {
            this._deactivateEnergyBoost();
          }
        }
        _activateEnergyBoost(analysis) {
          this.energyBoostActive = true;
          if (this.energyBoostTimeout) {
            clearTimeout(this.energyBoostTimeout);
          }
          this._applyTierSettings();
          this.energyBoostTimeout = window.setTimeout(() => {
            this._deactivateEnergyBoost();
          }, this.energyBoostSettings.duration);
          unifiedEventBus.emit("performance:tier-changed", {
            tier: this.deviceTier,
            // Convert tier format
            previousTier: this.deviceTier,
            timestamp: Date.now()
          });
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "Energy boost activated", {
            bpm: analysis.bpm,
            energy: analysis.energy,
            danceability: analysis.danceability
          });
        }
        _deactivateEnergyBoost() {
          if (!this.energyBoostActive) return;
          this.energyBoostActive = false;
          if (this.energyBoostTimeout) {
            clearTimeout(this.energyBoostTimeout);
            this.energyBoostTimeout = null;
          }
          this._applyTierSettings();
          unifiedEventBus.emit("performance:tier-changed", {
            tier: this.deviceTier,
            previousTier: this.deviceTier,
            timestamp: Date.now()
          });
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "Energy boost deactivated");
        }
        _applyTierSettings() {
          this._applyWebGLSettings();
          this._applySystemSettings();
          const effectiveSettings = this.getEffectiveSettings();
          unifiedEventBus.emit("performance:tier-changed", {
            tier: this.deviceTier,
            previousTier: this.deviceTier,
            timestamp: Date.now()
          });
        }
        _applyWebGLSettings() {
          if (!this.webglIntegration) return;
          const effectiveSettings = this.getEffectiveSettings();
          this.webglIntegration.setQuality(effectiveSettings.webglQuality);
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "WebGL settings applied", {
            tier: this.deviceTier,
            quality: effectiveSettings.webglQuality,
            energyBoosted: effectiveSettings.energyBoosted
          });
        }
        _applySystemSettings() {
          const effectiveSettings = this.getEffectiveSettings();
          unifiedEventBus.emit("performance:frame", {
            deltaTime: 16,
            // Approximate 60fps
            fps: effectiveSettings.updateFrequency,
            memoryUsage: 0.5,
            // Placeholder
            timestamp: Date.now()
          });
        }
      };
      __name(_SimpleTierBasedPerformanceSystem, "SimpleTierBasedPerformanceSystem");
      SimpleTierBasedPerformanceSystem = _SimpleTierBasedPerformanceSystem;
    }
  });

  // src-js/core/performance/SimplePerformanceCoordinator.ts
  var _SimplePerformanceCoordinator, SimplePerformanceCoordinator;
  var init_SimplePerformanceCoordinator = __esm({
    "src-js/core/performance/SimplePerformanceCoordinator.ts"() {
      "use strict";
      init_SimpleTierBasedPerformanceSystem();
      init_UnifiedDebugManager();
      _SimplePerformanceCoordinator = class _SimplePerformanceCoordinator {
        constructor(enhancedDeviceTierDetector, webglIntegration) {
          this.initialized = false;
          this.enhancedDeviceTierDetector = enhancedDeviceTierDetector;
          this.webglIntegration = webglIntegration;
          this.performanceSystem = new SimpleTierBasedPerformanceSystem(enhancedDeviceTierDetector);
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", "Created simple performance coordination");
        }
        async initialize() {
          if (this.initialized) return;
          await this.performanceSystem.initialize();
          this.performanceSystem.registerWebGLIntegration(this.webglIntegration);
          this.initialized = true;
          const tierResult = this.performanceSystem.getTierDetectionResult();
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", "Coordination established", {
            deviceTier: this.performanceSystem.getDeviceTier(),
            deviceDescription: this.performanceSystem.getDeviceDescription(),
            confidence: tierResult?.confidence,
            webglState: this.webglIntegration?.getWebGLState() || "disabled"
          });
        }
        async healthCheck() {
          if (!this.initialized) {
            return {
              healthy: false,
              details: "Not initialized",
              system: "SimplePerformanceCoordinator"
            };
          }
          const performanceHealth = await this.performanceSystem.healthCheck();
          const webglHealth = this.webglIntegration ? await this.webglIntegration.healthCheck() : { healthy: false, details: "WebGL integration not available" };
          const issues = [];
          if (!performanceHealth.healthy) {
            issues.push(`Performance: ${performanceHealth.details}`);
          }
          if (!webglHealth.healthy) {
            issues.push(`WebGL: ${webglHealth.details}`);
          }
          return {
            healthy: issues.length === 0,
            details: issues.length > 0 ? `Issues: ${issues.join(", ")}` : `Coordinating ${this.performanceSystem.getDeviceTier()} tier performance with ${this.webglIntegration?.getWebGLState() || "disabled"} WebGL`,
            issues,
            system: "SimplePerformanceCoordinator"
          };
        }
        destroy() {
          this.performanceSystem.destroy();
          this.initialized = false;
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", "Coordination destroyed");
        }
        updateAnimation(deltaTime) {
          this.performanceSystem.updateAnimation(deltaTime);
        }
        // =============================================================================
        // PUBLIC API - Simplified Performance Management
        // =============================================================================
        /**
         * Get the performance system for direct access
         */
        getPerformanceSystem() {
          return this.performanceSystem;
        }
        /**
         * Get current device performance tier
         */
        getDeviceTier() {
          return this.performanceSystem.getDeviceTier();
        }
        /**
         * Get device description for debugging
         */
        getDeviceDescription() {
          return this.performanceSystem.getDeviceDescription();
        }
        /**
         * Check if energy boost is currently active
         */
        hasEnergyBoost() {
          return this.performanceSystem.hasEnergyBoost();
        }
        /**
         * Get current effective performance settings
         */
        getCurrentSettings() {
          return this.performanceSystem.getEffectiveSettings();
        }
        /**
         * Get WebGL integration status
         */
        getWebGLStatus() {
          if (!this.webglIntegration) {
            return {
              state: "disabled",
              quality: "low",
              enabled: false
            };
          }
          return {
            state: this.webglIntegration.getWebGLState(),
            quality: this.webglIntegration.getQuality(),
            enabled: this.webglIntegration.isWebGLActive()
          };
        }
        /**
         * Get performance summary for debugging
         */
        getPerformanceSummary() {
          const tierResult = this.performanceSystem.getTierDetectionResult();
          return {
            deviceTier: this.getDeviceTier(),
            deviceDescription: this.getDeviceDescription(),
            confidence: tierResult?.confidence || 0,
            reasoning: tierResult?.reasoning || [],
            webglStatus: this.getWebGLStatus(),
            energyBoost: this.hasEnergyBoost(),
            settings: this.getCurrentSettings()
          };
        }
        // =============================================================================
        // REQUIRED INTERFACE COMPATIBILITY
        // =============================================================================
        /**
         * Start monitoring (required by Year3000System interface)
         */
        startMonitoring() {
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", "Monitoring started (tier-based system)");
        }
        // =============================================================================
        // ESSENTIAL LEGACY API METHODS (Still actively used)
        // =============================================================================
        emitTrace(event, data) {
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", `${event}`, data);
        }
        recordMetric(name, value) {
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", `Metric ${name}: ${value}`);
        }
        getMedianFPS() {
          const tier = this.getDeviceTier();
          switch (tier) {
            case "high":
              return 60;
            case "medium":
              return 50;
            case "low":
              return 30;
            default:
              return 30;
          }
        }
        calculateHealthScore() {
          const tier = this.getDeviceTier();
          switch (tier) {
            case "high":
              return 0.95;
            case "medium":
              return 0.75;
            case "low":
              return 0.5;
            default:
              return 0.5;
          }
        }
        shouldReduceQuality() {
          return this.getDeviceTier() === "low";
        }
        timeOperation(name, operation) {
          const start = performance.now();
          const result = operation();
          const duration = performance.now() - start;
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", `Operation ${name}: ${duration.toFixed(2)}ms`);
          return result;
        }
        async timeOperationAsync(name, operation) {
          const start = performance.now();
          const result = await operation();
          const duration = performance.now() - start;
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", `Async operation ${name}: ${duration.toFixed(2)}ms`);
          return result;
        }
        getAverageTime(name) {
          const tier = this.getDeviceTier();
          switch (tier) {
            case "high":
              return 5;
            case "medium":
              return 15;
            case "low":
              return 30;
            default:
              return 15;
          }
        }
        updateBudget(name, value) {
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", `Budget update ignored: ${name}=${value} (tier-based system)`);
        }
        startTiming(name) {
          const timingId = `${name}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", `Timing started: ${name} (${timingId})`);
          return timingId;
        }
        endTiming(timingId, context) {
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", `Timing ended: ${timingId}`, context);
        }
      };
      __name(_SimplePerformanceCoordinator, "SimplePerformanceCoordinator");
      SimplePerformanceCoordinator = _SimplePerformanceCoordinator;
    }
  });

  // src-js/core/webgl/UnifiedWebGLController.ts
  var _UnifiedWebGLController, UnifiedWebGLController;
  var init_UnifiedWebGLController = __esm({
    "src-js/core/webgl/UnifiedWebGLController.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_UnifiedEventBus();
      _UnifiedWebGLController = class _UnifiedWebGLController {
        constructor(deviceCapabilities) {
          this.initialized = false;
          this.currentState = "disabled";
          // Registered WebGL systems (ordered by priority)
          this.webglSystems = /* @__PURE__ */ new Map();
          // Performance monitoring
          this.lastStateChange = 0;
          this.stateChangeHistory = [];
          // User preference tracking
          this.userExplicitlyDisabled = false;
          this.userExplicitQuality = null;
          this.deviceCapabilities = deviceCapabilities;
          this.config = {
            enabled: true,
            quality: "medium",
            forceEnabled: false,
            allowPerformanceAdjustment: true
          };
          Y3KDebug?.debug?.log("UnifiedWebGLController", "Initialized with unified WebGL management");
        }
        async initialize() {
          if (this.initialized) return;
          if (!this.deviceCapabilities.isInitialized) {
            await this.deviceCapabilities.initialize();
          }
          await this._loadSettings();
          await this._determineInitialState();
          this._setupEventListeners();
          this._applyStateToAllSystems();
          this.initialized = true;
          Y3KDebug?.debug?.log("UnifiedWebGLController", "Initialization complete", {
            state: this.currentState,
            quality: this.config.quality,
            systemCount: this.webglSystems.size
          });
        }
        async healthCheck() {
          if (!this.initialized) {
            return {
              healthy: false,
              details: "Not initialized",
              system: "UnifiedWebGLController"
            };
          }
          const systemIssues = [];
          for (const [name, ref] of this.webglSystems) {
            if (ref.system.healthCheck) {
              try {
                const health = await ref.system.healthCheck();
                if (!health.healthy) {
                  systemIssues.push(`${name}: ${health.details || "unhealthy"}`);
                }
              } catch (error) {
                systemIssues.push(`${name}: health check failed`);
              }
            }
          }
          const recentStateChanges = this.stateChangeHistory.filter((change) => Date.now() - change.timestamp < 3e4).length;
          if (systemIssues.length > 0 || recentStateChanges > 3) {
            return {
              healthy: true,
              // Still working, but with issues
              details: `Issues detected: ${systemIssues.join(", ")}`,
              issues: systemIssues,
              system: "UnifiedWebGLController"
            };
          }
          return {
            healthy: true,
            details: "All WebGL systems operating normally",
            system: "UnifiedWebGLController"
          };
        }
        destroy() {
          this._setState("disabled");
          this.webglSystems.clear();
          unifiedEventBus.unsubscribe("settings:changed");
          unifiedEventBus.unsubscribe("system:state-changed");
          this.initialized = false;
          Y3KDebug?.debug?.log("UnifiedWebGLController", "Destroyed - all WebGL systems disabled");
        }
        updateAnimation(deltaTime) {
          if (this.currentState === "webgl-active") {
            for (const [name, ref] of this.webglSystems) {
              if (ref.system.updateAnimation) {
                try {
                  ref.system.updateAnimation(deltaTime);
                } catch (error) {
                  Y3KDebug?.debug?.warn("UnifiedWebGLController", `Animation update failed for ${name}:`, error);
                }
              }
            }
          }
        }
        // =============================================================================
        // PUBLIC API - Simple Developer Interface
        // =============================================================================
        /**
         * Enable all WebGL effects
         */
        enable() {
          this.userExplicitlyDisabled = false;
          this.config.enabled = true;
          this._determineAndApplyState();
          this._saveSettings();
          Y3KDebug?.debug?.log("UnifiedWebGLController", "WebGL enabled by user");
        }
        /**
         * Disable all WebGL effects (fallback to CSS)
         */
        disable() {
          this.userExplicitlyDisabled = true;
          this.config.enabled = false;
          this._setState("css-fallback");
          this._saveSettings();
          Y3KDebug?.debug?.log("UnifiedWebGLController", "WebGL disabled by user");
        }
        /**
         * Set quality level for all WebGL effects
         */
        setQuality(quality) {
          this.userExplicitQuality = quality;
          this.config.quality = quality;
          this._applyQualityToAllSystems();
          this._saveSettings();
          Y3KDebug?.debug?.log("UnifiedWebGLController", `Quality set to ${quality} by user`);
        }
        /**
         * Check if WebGL is currently enabled and active
         */
        isEnabled() {
          return this.currentState === "webgl-active";
        }
        /**
         * Check if WebGL is available (device supports it)
         */
        isAvailable() {
          const profile = this.deviceCapabilities.getSpicetifyProfile();
          return profile?.webglCapabilities?.available || false;
        }
        /**
         * Get current WebGL state
         */
        getState() {
          return this.currentState;
        }
        /**
         * Get current quality level
         */
        getQuality() {
          return this.config.quality;
        }
        /**
         * Force enable WebGL (override device capability detection)
         */
        forceEnable(force = true) {
          this.config.forceEnabled = force;
          this._determineAndApplyState();
          this._saveSettings();
          Y3KDebug?.debug?.log("UnifiedWebGLController", `Force enable set to ${force}`);
        }
        // =============================================================================
        // SYSTEM REGISTRATION
        // =============================================================================
        /**
         * Register a WebGL system for unified management
         */
        registerSystem(name, system, priority = 0) {
          this.webglSystems.set(name, {
            system,
            name,
            priority
          });
          if (this.initialized) {
            this._applyStateToSystem(name, system);
          }
          Y3KDebug?.debug?.log("UnifiedWebGLController", `System registered: ${name} (priority: ${priority})`);
        }
        /**
         * Unregister a WebGL system
         */
        unregisterSystem(name) {
          const systemRef = this.webglSystems.get(name);
          if (systemRef) {
            if (systemRef.system.setEnabled) {
              systemRef.system.setEnabled(false);
            }
            this.webglSystems.delete(name);
            Y3KDebug?.debug?.log("UnifiedWebGLController", `System unregistered: ${name}`);
          }
        }
        // =============================================================================
        // PERFORMANCE SYSTEM INTEGRATION
        // =============================================================================
        /**
         * Called by performance system to suggest quality adjustment
         */
        suggestQualityAdjustment(suggestedQuality, reason) {
          if (!this.config.allowPerformanceAdjustment) {
            Y3KDebug?.debug?.log("UnifiedWebGLController", `Performance adjustment ignored (not allowed): ${reason}`);
            return;
          }
          if (this.userExplicitQuality !== null) {
            Y3KDebug?.debug?.log("UnifiedWebGLController", `Performance adjustment ignored (user set explicit quality): ${reason}`);
            return;
          }
          if (this.config.quality !== suggestedQuality) {
            const oldQuality = this.config.quality;
            this.config.quality = suggestedQuality;
            this._applyQualityToAllSystems();
            Y3KDebug?.debug?.log("UnifiedWebGLController", `Quality adjusted by performance system: ${oldQuality} \u2192 ${suggestedQuality} (${reason})`);
          }
        }
        /**
         * Called by performance system to temporarily disable WebGL
         */
        performanceDisable(reason) {
          if (!this.config.allowPerformanceAdjustment || this.userExplicitlyDisabled === false) {
            return;
          }
          if (this.currentState === "webgl-active") {
            this._setState("css-fallback");
            Y3KDebug?.debug?.log("UnifiedWebGLController", `WebGL disabled by performance system: ${reason}`);
          }
        }
        /**
         * Called by performance system to re-enable WebGL when performance improves
         */
        performanceEnable(reason) {
          if (!this.config.allowPerformanceAdjustment || this.userExplicitlyDisabled) {
            return;
          }
          if (this.currentState === "css-fallback" && this.config.enabled) {
            this._determineAndApplyState();
            Y3KDebug?.debug?.log("UnifiedWebGLController", `WebGL re-enabled by performance system: ${reason}`);
          }
        }
        // =============================================================================
        // PRIVATE IMPLEMENTATION
        // =============================================================================
        async _loadSettings() {
          try {
            const webglEnabled = localStorage.getItem("sn-webgl-enabled");
            const webglQuality = localStorage.getItem("sn-webgl-quality");
            const webglForceEnabled = localStorage.getItem("sn-webgl-force-enabled");
            if (webglEnabled !== null) {
              this.config.enabled = webglEnabled === "true";
              if (webglEnabled === "false") {
                this.userExplicitlyDisabled = true;
              }
            }
            if (webglQuality && ["low", "medium", "high"].includes(webglQuality)) {
              this.config.quality = webglQuality;
              this.userExplicitQuality = webglQuality;
            }
            if (webglForceEnabled !== null) {
              this.config.forceEnabled = webglForceEnabled === "true";
            }
            Y3KDebug?.debug?.log("UnifiedWebGLController", "Settings loaded", this.config);
          } catch (error) {
            Y3KDebug?.debug?.warn("UnifiedWebGLController", "Failed to load settings:", error);
          }
        }
        _saveSettings() {
          try {
            localStorage.setItem("sn-webgl-enabled", this.config.enabled.toString());
            localStorage.setItem("sn-webgl-quality", this.config.quality);
            localStorage.setItem("sn-webgl-force-enabled", this.config.forceEnabled.toString());
          } catch (error) {
            Y3KDebug?.debug?.warn("UnifiedWebGLController", "Failed to save settings:", error);
          }
        }
        async _determineInitialState() {
          if (!this.config.enabled || this.userExplicitlyDisabled) {
            this._setState("css-fallback");
            return;
          }
          if (this.config.forceEnabled || this.isAvailable()) {
            this._setState("webgl-active");
          } else {
            this._setState("css-fallback");
          }
        }
        _determineAndApplyState() {
          if (!this.config.enabled || this.userExplicitlyDisabled) {
            this._setState("css-fallback");
          } else if (this.config.forceEnabled || this.isAvailable()) {
            this._setState("webgl-active");
          } else {
            this._setState("css-fallback");
          }
        }
        _setState(newState) {
          if (this.currentState === newState) return;
          const oldState = this.currentState;
          this.currentState = newState;
          this.lastStateChange = Date.now();
          this.stateChangeHistory.push({
            state: newState,
            quality: this.config.quality,
            timestamp: this.lastStateChange
          });
          if (this.stateChangeHistory.length > 20) {
            this.stateChangeHistory = this.stateChangeHistory.slice(-20);
          }
          this._applyStateToAllSystems();
          unifiedEventBus.emit("performance:tier-changed", {
            tier: newState,
            previousTier: oldState,
            timestamp: this.lastStateChange
          });
          Y3KDebug?.debug?.log("UnifiedWebGLController", `State changed: ${oldState} \u2192 ${newState}`);
        }
        _applyStateToAllSystems() {
          const sortedSystems = Array.from(this.webglSystems.entries()).sort(([, a], [, b]) => b.priority - a.priority);
          for (const [name, ref] of sortedSystems) {
            this._applyStateToSystem(name, ref.system);
          }
        }
        _applyStateToSystem(name, system) {
          try {
            const isWebGLActive = this.currentState === "webgl-active";
            if (system.setEnabled) {
              system.setEnabled(isWebGLActive);
            }
            if (isWebGLActive && system.setQuality) {
              system.setQuality(this.config.quality);
            }
            if (name === "corridor-effects" && system.setEnabled) {
              const shouldEnableCorridors = isWebGLActive && (this.config.quality === "medium" || this.config.quality === "high");
              system.setEnabled(shouldEnableCorridors);
            }
          } catch (error) {
            Y3KDebug?.debug?.warn("UnifiedWebGLController", `Failed to apply state to ${name}:`, error);
          }
        }
        _applyQualityToAllSystems() {
          if (this.currentState !== "webgl-active") return;
          for (const [name, ref] of this.webglSystems) {
            try {
              if (ref.system.setQuality) {
                ref.system.setQuality(this.config.quality);
              }
              if (name === "corridor-effects") {
                const shouldEnable = this.config.quality === "medium" || this.config.quality === "high";
                if (ref.system.setEnabled) {
                  ref.system.setEnabled(shouldEnable);
                }
              }
            } catch (error) {
              Y3KDebug?.debug?.warn("UnifiedWebGLController", `Failed to apply quality to ${name}:`, error);
            }
          }
          unifiedEventBus.emit("performance:tier-changed", {
            tier: this.config.quality,
            previousTier: this.config.quality,
            timestamp: Date.now()
          });
        }
        _setupEventListeners() {
          unifiedEventBus.subscribe("settings:changed", (data) => {
            if (data.settingKey === "sn-webgl-enabled") {
              this.config.enabled = data.newValue === "true";
              this.userExplicitlyDisabled = data.newValue === "false";
              this._determineAndApplyState();
            } else if (data.settingKey === "sn-webgl-quality") {
              this.setQuality(data.newValue);
            } else if (data.settingKey === "sn-webgl-force-enabled") {
              this.config.forceEnabled = data.newValue === "true";
              this._determineAndApplyState();
            }
          });
          unifiedEventBus.subscribe("performance:tier-changed", (data) => {
            const qualityFromTier = data.tier === "excellent" ? "high" : data.tier === "good" ? "medium" : "low";
            if (qualityFromTier !== this.config.quality) {
              this.setQuality(qualityFromTier);
            }
          });
        }
      };
      __name(_UnifiedWebGLController, "UnifiedWebGLController");
      UnifiedWebGLController = _UnifiedWebGLController;
    }
  });

  // src-js/core/webgl/WebGLSystemInterface.ts
  var _WebGLQualityMapper, WebGLQualityMapper;
  var init_WebGLSystemInterface = __esm({
    "src-js/core/webgl/WebGLSystemInterface.ts"() {
      "use strict";
      _WebGLQualityMapper = class _WebGLQualityMapper {
        /**
         * Map quality level to animation density (0.0 - 1.0)
         */
        static getAnimationDensity(quality) {
          switch (quality) {
            case "low":
              return 0.3;
            case "medium":
              return 0.7;
            case "high":
              return 1;
          }
        }
        /**
         * Map quality level to update frequency (Hz)
         */
        static getUpdateFrequency(quality) {
          switch (quality) {
            case "low":
              return 30;
            case "medium":
              return 45;
            case "high":
              return 60;
          }
        }
        /**
         * Map quality level to shader complexity (0.0 - 1.0)
         */
        static getShaderComplexity(quality) {
          switch (quality) {
            case "low":
              return 0.4;
            case "medium":
              return 0.7;
            case "high":
              return 1;
          }
        }
        /**
         * Map quality level to particle count multiplier
         */
        static getParticleMultiplier(quality) {
          switch (quality) {
            case "low":
              return 0.3;
            case "medium":
              return 0.6;
            case "high":
              return 1;
          }
        }
        /**
         * Check if corridor effects should be enabled at this quality level
         */
        static shouldEnableCorridorEffects(quality) {
          return quality === "medium" || quality === "high";
        }
        /**
         * Check if advanced features should be enabled at this quality level
         */
        static shouldEnableAdvancedFeatures(quality) {
          return quality === "high";
        }
        /**
         * Get CSS mix-blend-mode based on quality level
         */
        static getBlendMode(quality) {
          switch (quality) {
            case "low":
              return "normal";
            case "medium":
              return "screen";
            case "high":
              return "screen";
          }
        }
        /**
         * Get frame throttling based on quality level (ms between frames)
         */
        static getFrameThrottling(quality) {
          switch (quality) {
            case "low":
              return 33;
            case "medium":
              return 22;
            case "high":
              return 16;
          }
        }
      };
      __name(_WebGLQualityMapper, "WebGLQualityMapper");
      WebGLQualityMapper = _WebGLQualityMapper;
    }
  });

  // src-js/visual/backgrounds/WebGLGradientAdapter.ts
  var _WebGLGradientAdapter, WebGLGradientAdapter;
  var init_WebGLGradientAdapter = __esm({
    "src-js/visual/backgrounds/WebGLGradientAdapter.ts"() {
      "use strict";
      init_WebGLSystemInterface();
      init_UnifiedDebugManager();
      _WebGLGradientAdapter = class _WebGLGradientAdapter {
        constructor(system) {
          this.enabled = false;
          this.quality = "medium";
          this.system = system;
          Y3KDebug?.debug?.log("WebGLGradientAdapter", "Created adapter for WebGL gradient system");
        }
        setEnabled(enabled) {
          if (this.enabled === enabled) return;
          this.enabled = enabled;
          if (enabled) {
            this._enableSystem();
          } else {
            this._disableSystem();
          }
          Y3KDebug?.debug?.log("WebGLGradientAdapter", `WebGL gradient ${enabled ? "enabled" : "disabled"}`);
        }
        setQuality(quality) {
          if (this.quality === quality) return;
          this.quality = quality;
          if (this.enabled) {
            this._applyQualitySettings();
          }
          Y3KDebug?.debug?.log("WebGLGradientAdapter", `Quality set to ${quality}`);
        }
        isEnabled() {
          return this.enabled;
        }
        isCapable() {
          return this._checkWebGLCapability();
        }
        getQuality() {
          return this.quality;
        }
        getSystemName() {
          return "WebGL Gradient Background";
        }
        _enableSystem() {
          try {
            const intensityMapping = this._mapQualityToIntensity(this.quality);
            if (this.system["settingsManager"]) {
              this.system["settingsManager"].set("sn-gradient-intensity", intensityMapping);
              this.system["settingsManager"].set("sn-webgl-enabled", "true");
            }
            if (!this.system.initialized) {
              this.system.initialize();
            }
            this._applyQualitySettings();
          } catch (error) {
            Y3KDebug?.debug?.warn("WebGLGradientAdapter", "Failed to enable system:", error);
          }
        }
        _disableSystem() {
          try {
            if (this.system["settingsManager"]) {
              this.system["settingsManager"].set("sn-gradient-intensity", "disabled");
            }
            if (typeof this.system["disable"] === "function") {
              this.system["disable"]();
            } else if (typeof this.system.destroy === "function") {
              this.system.destroy();
            }
          } catch (error) {
            Y3KDebug?.debug?.warn("WebGLGradientAdapter", "Failed to disable system:", error);
          }
        }
        _applyQualitySettings() {
          try {
            const settings2 = this.system["settings"];
            if (!settings2) return;
            settings2.flowStrength = this._getFlowStrength(this.quality);
            settings2.noiseScale = this._getNoiseScale(this.quality);
            settings2.corridorIntensity = this._getColorIntensity(this.quality);
            const updateFrequency = WebGLQualityMapper.getUpdateFrequency(this.quality);
            if (this.system["updateFrequency"] !== void 0) {
              this.system["updateFrequency"] = updateFrequency;
            }
            if (typeof this.system.forceRepaint === "function") {
              this.system.forceRepaint(`quality-change-${this.quality}`);
            }
          } catch (error) {
            Y3KDebug?.debug?.warn("WebGLGradientAdapter", "Failed to apply quality settings:", error);
          }
        }
        _mapQualityToIntensity(quality) {
          switch (quality) {
            case "low":
              return "minimal";
            case "medium":
              return "balanced";
            case "high":
              return "intense";
            default:
              return "balanced";
          }
        }
        _getFlowStrength(quality) {
          switch (quality) {
            case "low":
              return 0.3;
            case "medium":
              return 0.7;
            case "high":
              return 1;
            default:
              return 0.7;
          }
        }
        _getAnimationSpeed(quality) {
          switch (quality) {
            case "low":
              return 0.5;
            case "medium":
              return 0.8;
            case "high":
              return 1.2;
            default:
              return 0.8;
          }
        }
        _getNoiseScale(quality) {
          switch (quality) {
            case "low":
              return 1.5;
            case "medium":
              return 2;
            case "high":
              return 2.8;
            default:
              return 2;
          }
        }
        _getColorIntensity(quality) {
          switch (quality) {
            case "low":
              return 0.6;
            case "medium":
              return 0.8;
            case "high":
              return 1;
            default:
              return 0.8;
          }
        }
        _checkWebGLCapability() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
            canvas.remove();
            return gl !== null;
          } catch {
            return false;
          }
        }
      };
      __name(_WebGLGradientAdapter, "WebGLGradientAdapter");
      WebGLGradientAdapter = _WebGLGradientAdapter;
    }
  });

  // src-js/core/webgl/WebGLSystemsIntegration.ts
  var _WebGLSystemsIntegration, WebGLSystemsIntegration;
  var init_WebGLSystemsIntegration = __esm({
    "src-js/core/webgl/WebGLSystemsIntegration.ts"() {
      "use strict";
      init_UnifiedWebGLController();
      init_WebGLGradientAdapter();
      init_UnifiedDebugManager();
      _WebGLSystemsIntegration = class _WebGLSystemsIntegration {
        constructor(deviceCapabilities) {
          this.initialized = false;
          this.webglGradientSystem = null;
          this.webglGradientAdapter = null;
          this.controller = new UnifiedWebGLController(deviceCapabilities);
          Y3KDebug?.debug?.log("WebGLSystemsIntegration", "Created WebGL systems integration");
        }
        async initialize() {
          if (this.initialized) return;
          await this.controller.initialize();
          await this._registerWebGLSystems();
          this.initialized = true;
          Y3KDebug?.debug?.log("WebGLSystemsIntegration", "Integration initialized", {
            controllerState: this.controller.getState(),
            quality: this.controller.getQuality(),
            registeredSystems: this._getRegisteredSystemNames()
          });
        }
        async healthCheck() {
          if (!this.initialized) {
            return {
              healthy: false,
              details: "Not initialized",
              system: "WebGLSystemsIntegration"
            };
          }
          const controllerHealth = await this.controller.healthCheck();
          if (!controllerHealth.healthy) {
            return {
              healthy: false,
              details: `Controller unhealthy: ${controllerHealth.details}`,
              system: "WebGLSystemsIntegration"
            };
          }
          const systemIssues = [];
          if (this.webglGradientSystem) {
            try {
              const gradientHealth = await this.webglGradientSystem.healthCheck();
              if (!gradientHealth.ok) {
                systemIssues.push(`WebGL Gradient: ${gradientHealth.details}`);
              }
            } catch (error) {
              systemIssues.push("WebGL Gradient: health check failed");
            }
          }
          return {
            healthy: true,
            details: systemIssues.length > 0 ? `Some system issues: ${systemIssues.join(", ")}` : "All WebGL systems healthy",
            issues: systemIssues,
            system: "WebGLSystemsIntegration"
          };
        }
        destroy() {
          if (this.webglGradientSystem) {
            this.webglGradientSystem.destroy();
          }
          this.controller.destroy();
          this.initialized = false;
          Y3KDebug?.debug?.log("WebGLSystemsIntegration", "Integration destroyed");
        }
        updateAnimation(deltaTime) {
          if (this.initialized) {
            this.controller.updateAnimation(deltaTime);
          }
        }
        // =============================================================================
        // PUBLIC API - Simplified WebGL Management
        // =============================================================================
        /**
         * Get the unified WebGL controller for direct access
         */
        getController() {
          return this.controller;
        }
        /**
         * Enable all WebGL effects
         */
        enableWebGL() {
          this.controller.enable();
        }
        /**
         * Disable all WebGL effects
         */
        disableWebGL() {
          this.controller.disable();
        }
        /**
         * Set quality for all WebGL effects
         */
        setQuality(quality) {
          this.controller.setQuality(quality);
        }
        /**
         * Check if WebGL is currently active
         */
        isWebGLActive() {
          return this.controller.isEnabled();
        }
        /**
         * Get current WebGL state
         */
        getWebGLState() {
          return this.controller.getState();
        }
        /**
         * Get current quality level
         */
        getQuality() {
          return this.controller.getQuality();
        }
        // =============================================================================
        // PERFORMANCE SYSTEM INTEGRATION
        // =============================================================================
        /**
         * Called by tier-based performance system to set quality level
         */
        handlePerformanceQualityAdjustment(suggestedQuality, reason) {
          this.controller.suggestQualityAdjustment(suggestedQuality, reason);
        }
        /**
         * Called by performance system to temporarily disable WebGL
         */
        handlePerformanceDisable(reason) {
          this.controller.performanceDisable(reason);
        }
        /**
         * Called by performance system to re-enable WebGL
         */
        handlePerformanceEnable(reason) {
          this.controller.performanceEnable(reason);
        }
        /**
         * Set quality based on device tier (simplified approach)
         */
        setQualityFromTier(tier) {
          this.controller.setQuality(tier);
          Y3KDebug?.debug?.log("WebGLSystemsIntegration", `Quality set from device tier: ${tier}`);
        }
        // =============================================================================
        // PRIVATE IMPLEMENTATION
        // =============================================================================
        async _registerWebGLSystems() {
          try {
            await this._registerWebGLGradientSystem();
            Y3KDebug?.debug?.log("WebGLSystemsIntegration", "All WebGL systems registered successfully");
          } catch (error) {
            Y3KDebug?.debug?.warn("WebGLSystemsIntegration", "Failed to register some WebGL systems:", error);
          }
        }
        async _registerWebGLGradientSystem() {
          try {
            const year3000System2 = globalThis.year3000System;
            if (!year3000System2) {
              Y3KDebug?.debug?.warn("WebGLSystemsIntegration", "Year3000System not available");
              return;
            }
            const possibleSystems = [
              "webglGradientBackgroundSystem",
              "flowingLiquidConsciousnessSystem",
              "webglBackgroundSystem"
            ];
            let foundSystem = null;
            for (const systemName of possibleSystems) {
              if (year3000System2[systemName]) {
                foundSystem = year3000System2[systemName];
                break;
              }
            }
            if (!foundSystem) {
              Y3KDebug?.debug?.warn("WebGLSystemsIntegration", "WebGL gradient system not found in Year3000System");
              return;
            }
            this.webglGradientSystem = foundSystem;
            this.webglGradientAdapter = new WebGLGradientAdapter(this.webglGradientSystem);
            this.controller.registerSystem(
              "webgl-gradient-background",
              this.webglGradientAdapter,
              100
              // High priority
            );
            Y3KDebug?.debug?.log("WebGLSystemsIntegration", "WebGL gradient system registered");
          } catch (error) {
            Y3KDebug?.debug?.warn("WebGLSystemsIntegration", "Failed to register WebGL gradient system:", error);
          }
        }
        _getRegisteredSystemNames() {
          const systemNames = [];
          if (this.webglGradientAdapter) {
            systemNames.push("WebGL Gradient Background");
          }
          return systemNames;
        }
      };
      __name(_WebGLSystemsIntegration, "WebGLSystemsIntegration");
      WebGLSystemsIntegration = _WebGLSystemsIntegration;
    }
  });

  // src-js/core/performance/UnifiedPerformanceCoordinator.ts
  var _UnifiedPerformanceCoordinator, UnifiedPerformanceCoordinator;
  var init_UnifiedPerformanceCoordinator = __esm({
    "src-js/core/performance/UnifiedPerformanceCoordinator.ts"() {
      "use strict";
      init_UnifiedEventBus();
      _UnifiedPerformanceCoordinator = class _UnifiedPerformanceCoordinator {
        constructor(config, performanceAnalyzer2) {
          // Subsystem tracking
          this.subsystemMetrics = /* @__PURE__ */ new Map();
          // Optimization management
          this.optimizationStrategies = /* @__PURE__ */ new Map();
          this.adaptiveOptimizationEnabled = false;
          this.optimizationInterval = null;
          // Issue tracking
          this.activeIssues = /* @__PURE__ */ new Map();
          this.issueHistory = [];
          // Health monitoring
          this.lastHealthCheck = 0;
          this.healthCheckInterval = null;
          this.HEALTH_CHECK_INTERVAL = 5e3;
          // Initialized in initializeThermalMonitoring
          this.batteryState = null;
          // Initialized in constructor
          this.frameTimeHistory = [];
          this.memoryUsageHistory = [];
          this.lastOptimizationTime = 0;
          this.optimizationCooldown = 5e3;
          // 5 seconds
          // Performance thresholds
          this.PERFORMANCE_THRESHOLDS = {
            frameTime: {
              warning: 16.67,
              // 60fps
              critical: 33.33
              // 30fps
            },
            memoryUsage: {
              warning: 50 * 1024 * 1024,
              // 50MB
              critical: 100 * 1024 * 1024
              // 100MB
            },
            cpuUsage: {
              warning: 15,
              // 15%
              critical: 30
              // 30%
            },
            fps: {
              warning: 50,
              critical: 30
            }
          };
          // Performance modes configuration (from PerformanceOptimizationManager)
          this.PERFORMANCE_MODES = {
            battery: {
              name: "battery",
              qualityLevel: 0.4,
              animationQuality: 0.3,
              effectQuality: 0.2,
              blurQuality: 0.3,
              shadowQuality: 0.2,
              frameRate: 30,
              optimizationLevel: 3
            },
            balanced: {
              name: "balanced",
              qualityLevel: 0.8,
              animationQuality: 0.8,
              effectQuality: 0.7,
              blurQuality: 0.8,
              shadowQuality: 0.7,
              frameRate: 60,
              optimizationLevel: 1
            },
            performance: {
              name: "performance",
              qualityLevel: 1,
              animationQuality: 1,
              effectQuality: 1,
              blurQuality: 1,
              shadowQuality: 1,
              frameRate: 60,
              optimizationLevel: 0
            },
            auto: {
              name: "auto",
              qualityLevel: 0.8,
              // Will be dynamically adjusted
              animationQuality: 0.8,
              effectQuality: 0.8,
              blurQuality: 0.8,
              shadowQuality: 0.8,
              frameRate: 60,
              optimizationLevel: 1
            }
          };
          this.config = config;
          this.performanceAnalyzer = performanceAnalyzer2;
          this.eventBus = unifiedEventBus;
          this.initializeDeviceCapabilities();
          this.initializeThermalMonitoring();
          this.initializeBatteryMonitoring();
          this.currentPerformanceMode = this.PERFORMANCE_MODES.auto;
          this.initializeDefaultStrategies();
          this.startHealthMonitoring();
          this.subscribeToEvents();
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Initialized with enhanced device capabilities, thermal monitoring, and battery optimization");
          }
        }
        /**
         * Get or create singleton instance
         */
        static getInstance(config, performanceAnalyzer2) {
          if (!_UnifiedPerformanceCoordinator.instance) {
            if (!config || !performanceAnalyzer2) {
              throw new Error("UnifiedPerformanceCoordinator requires config and performanceAnalyzer for first initialization");
            }
            _UnifiedPerformanceCoordinator.instance = new _UnifiedPerformanceCoordinator(config, performanceAnalyzer2);
          }
          return _UnifiedPerformanceCoordinator.instance;
        }
        /**
         * Track performance metrics for a subsystem
         */
        trackSubsystem(name, metrics) {
          const currentTime = performance.now();
          const existingMetrics = this.subsystemMetrics.get(name) || {
            name,
            frameTime: 0,
            memoryUsage: 0,
            cpuUsage: 0,
            fps: 60,
            lastUpdate: currentTime,
            status: "healthy",
            issues: []
          };
          const updatedMetrics = {
            ...existingMetrics,
            ...metrics,
            lastUpdate: currentTime
          };
          updatedMetrics.status = this.calculateHealthStatus(updatedMetrics);
          this.updateSubsystemIssues(updatedMetrics);
          this.subsystemMetrics.set(name, updatedMetrics);
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.recordMetric(`subsystem_${name}_frame_time`, updatedMetrics.frameTime);
            this.performanceAnalyzer.recordMetric(`subsystem_${name}_memory`, updatedMetrics.memoryUsage);
            this.performanceAnalyzer.recordMetric(`subsystem_${name}_fps`, updatedMetrics.fps);
          }
          if (this.adaptiveOptimizationEnabled && updatedMetrics.status !== "healthy") {
            this.checkAndTriggerOptimization(updatedMetrics);
          }
          if (this.config.enableDebug && updatedMetrics.status !== "healthy") {
            console.warn(`[UnifiedPerformanceCoordinator] Subsystem ${name} status: ${updatedMetrics.status}`, updatedMetrics);
          }
        }
        /**
         * Get comprehensive system health report
         */
        getSystemHealth() {
          const currentTime = performance.now();
          const subsystems = new Map(this.subsystemMetrics);
          let healthyCount = 0;
          let warningCount = 0;
          let criticalCount = 0;
          for (const metrics of subsystems.values()) {
            switch (metrics.status) {
              case "healthy":
                healthyCount++;
                break;
              case "warning":
                warningCount++;
                break;
              case "critical":
                criticalCount++;
                break;
            }
          }
          const totalSubsystems = subsystems.size;
          let overall = "healthy";
          if (criticalCount > 0) {
            overall = "critical";
          } else if (warningCount > 0) {
            overall = "warning";
          }
          const performanceScore = this.calculatePerformanceScore(subsystems);
          const recommendations = this.generateRecommendations(subsystems);
          const healthReport = {
            overall,
            totalSubsystems,
            healthySubsystems: healthyCount,
            warningSubsystems: warningCount,
            criticalSubsystems: criticalCount,
            subsystems,
            recommendations,
            performanceScore,
            lastUpdate: currentTime
          };
          this.lastHealthCheck = currentTime;
          return healthReport;
        }
        /**
         * Start monitoring (required by Year3000System interface)
         */
        startMonitoring() {
          this.enableAdaptiveOptimization();
          if (!this.healthCheckInterval) {
            this.startHealthMonitoring();
          }
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Monitoring started");
          }
        }
        /**
         * Enable adaptive optimization
         */
        enableAdaptiveOptimization() {
          if (this.adaptiveOptimizationEnabled) return;
          this.adaptiveOptimizationEnabled = true;
          this.optimizationInterval = setInterval(() => {
            this.performOptimizationCheck();
          }, 2e3);
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Adaptive optimization enabled");
          }
        }
        /**
         * Disable adaptive optimization
         */
        disableAdaptiveOptimization() {
          if (!this.adaptiveOptimizationEnabled) return;
          this.adaptiveOptimizationEnabled = false;
          if (this.optimizationInterval) {
            clearInterval(this.optimizationInterval);
            this.optimizationInterval = null;
          }
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Adaptive optimization disabled");
          }
        }
        /**
         * Register an optimization strategy
         */
        registerOptimizationStrategy(strategy) {
          this.optimizationStrategies.set(strategy.name, strategy);
          if (this.config.enableDebug) {
            console.log(`[UnifiedPerformanceCoordinator] Registered optimization strategy: ${strategy.name}`);
          }
        }
        /**
         * Trigger optimization for a specific issue
         */
        triggerOptimization(issue) {
          this.activeIssues.set(`${issue.subsystem}:${issue.type}`, issue);
          this.issueHistory.push(issue);
          if (this.issueHistory.length > 100) {
            this.issueHistory.shift();
          }
          const applicableStrategies = Array.from(this.optimizationStrategies.values()).filter((strategy) => strategy.subsystem === issue.subsystem || strategy.subsystem === "*").sort((a, b) => b.priority - a.priority);
          for (const strategy of applicableStrategies) {
            const subsystemMetrics = this.subsystemMetrics.get(issue.subsystem);
            if (subsystemMetrics && strategy.condition(subsystemMetrics)) {
              try {
                strategy.action(subsystemMetrics);
                if (this.config.enableDebug) {
                  console.log(`[UnifiedPerformanceCoordinator] Applied optimization strategy: ${strategy.name} for ${issue.subsystem}`);
                }
                break;
              } catch (error) {
                console.error(`[UnifiedPerformanceCoordinator] Error applying optimization strategy ${strategy.name}:`, error);
              }
            }
          }
        }
        /**
         * Get current performance metrics for debugging
         */
        getMetrics() {
          return {
            subsystems: new Map(this.subsystemMetrics),
            issues: new Map(this.activeIssues),
            strategies: new Map(this.optimizationStrategies),
            adaptiveOptimizationEnabled: this.adaptiveOptimizationEnabled
          };
        }
        /**
         * Destroy the coordinator and clean up resources
         */
        destroy() {
          this.disableAdaptiveOptimization();
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          this.subsystemMetrics.clear();
          this.optimizationStrategies.clear();
          this.activeIssues.clear();
          this.issueHistory = [];
          if (_UnifiedPerformanceCoordinator.instance === this) {
            _UnifiedPerformanceCoordinator.instance = null;
          }
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Destroyed");
          }
        }
        // =========================================================================
        // PRIVATE METHODS
        // =========================================================================
        /**
         * Initialize default optimization strategies
         */
        initializeDefaultStrategies() {
          this.registerOptimizationStrategy({
            name: "memory-cleanup",
            type: "memory_cleanup",
            priority: 100,
            subsystem: "*",
            description: "Trigger garbage collection and memory cleanup",
            condition: /* @__PURE__ */ __name((metrics) => metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
            }, "action")
          });
          this.registerOptimizationStrategy({
            name: "fps-optimization",
            type: "reduce_quality",
            priority: 80,
            subsystem: "*",
            description: "Reduce quality settings to improve FPS",
            condition: /* @__PURE__ */ __name((metrics) => metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
            }, "action")
          });
          this.registerOptimizationStrategy({
            name: "cpu-throttling",
            type: "throttle_updates",
            priority: 70,
            subsystem: "*",
            description: "Throttle update frequency to reduce CPU usage",
            condition: /* @__PURE__ */ __name((metrics) => metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
            }, "action")
          });
        }
        /**
         * Calculate health status for subsystem
         */
        calculateHealthStatus(metrics) {
          const issues = [];
          if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.critical) {
            issues.push("critical-frame-time");
          } else if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.warning) {
            issues.push("warning-frame-time");
          }
          if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.critical) {
            issues.push("critical-memory");
          } else if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning) {
            issues.push("warning-memory");
          }
          if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.critical) {
            issues.push("critical-cpu");
          } else if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning) {
            issues.push("warning-cpu");
          }
          if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.critical) {
            issues.push("critical-fps");
          } else if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning) {
            issues.push("warning-fps");
          }
          metrics.issues = issues;
          if (issues.some((issue) => issue.startsWith("critical"))) {
            return "critical";
          } else if (issues.some((issue) => issue.startsWith("warning"))) {
            return "warning";
          } else {
            return "healthy";
          }
        }
        /**
         * Update subsystem issues based on thresholds
         */
        updateSubsystemIssues(metrics) {
          const issueKey = `${metrics.name}:performance`;
          if (metrics.status === "healthy") {
            if (this.activeIssues.has(issueKey)) {
              const issue = this.activeIssues.get(issueKey);
              issue.resolved = true;
              this.activeIssues.delete(issueKey);
            }
          } else {
            const issue = {
              type: "render",
              severity: metrics.status === "critical" ? "critical" : "medium",
              subsystem: metrics.name,
              message: `Performance degradation detected: ${metrics.issues.join(", ")}`,
              timestamp: Date.now(),
              resolved: false
            };
            this.activeIssues.set(issueKey, issue);
          }
        }
        /**
         * Check and trigger optimization if needed
         */
        checkAndTriggerOptimization(metrics) {
          const issueKey = `${metrics.name}:performance`;
          const issue = this.activeIssues.get(issueKey);
          if (issue && !issue.resolved) {
            this.triggerOptimization(issue);
          }
        }
        /**
         * Perform periodic optimization check
         */
        performOptimizationCheck() {
          const currentTime = performance.now();
          for (const [name, metrics] of this.subsystemMetrics) {
            if (currentTime - metrics.lastUpdate > 1e4) {
              continue;
            }
            if (metrics.status !== "healthy") {
              this.checkAndTriggerOptimization(metrics);
            }
          }
        }
        /**
         * Calculate overall performance score
         */
        calculatePerformanceScore(subsystems) {
          if (subsystems.size === 0) return 100;
          let totalScore = 0;
          for (const metrics of subsystems.values()) {
            let subsystemScore = 100;
            if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.warning) {
              subsystemScore -= 20;
            }
            if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.critical) {
              subsystemScore -= 30;
            }
            if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning) {
              subsystemScore -= 15;
            }
            if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.critical) {
              subsystemScore -= 25;
            }
            if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning) {
              subsystemScore -= 10;
            }
            if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.critical) {
              subsystemScore -= 20;
            }
            if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning) {
              subsystemScore -= 15;
            }
            if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.critical) {
              subsystemScore -= 25;
            }
            totalScore += Math.max(0, subsystemScore);
          }
          return Math.round(totalScore / subsystems.size);
        }
        /**
         * Generate recommendations based on system health
         */
        generateRecommendations(subsystems) {
          const recommendations = [];
          const allIssues = Array.from(subsystems.values()).flatMap((metrics) => metrics.issues);
          const issueCounts = /* @__PURE__ */ new Map();
          for (const issue of allIssues) {
            issueCounts.set(issue, (issueCounts.get(issue) || 0) + 1);
          }
          for (const [issue, count] of issueCounts) {
            if (count >= 2) {
              switch (issue) {
                case "critical-frame-time":
                case "warning-frame-time":
                  recommendations.push("Consider reducing animation quality or frequency");
                  break;
                case "critical-memory":
                case "warning-memory":
                  recommendations.push("Memory cleanup needed - consider reducing cache sizes");
                  break;
                case "critical-cpu":
                case "warning-cpu":
                  recommendations.push("High CPU usage detected - consider throttling updates");
                  break;
                case "critical-fps":
                case "warning-fps":
                  recommendations.push("Low FPS detected - consider disabling non-essential effects");
                  break;
              }
            }
          }
          if (recommendations.length === 0) {
            recommendations.push("System performance is optimal");
          }
          return recommendations;
        }
        /**
         * Start health monitoring
         */
        startHealthMonitoring() {
          this.healthCheckInterval = setInterval(() => {
            this.getSystemHealth();
          }, this.HEALTH_CHECK_INTERVAL);
        }
        /**
         * Subscribe to performance events
         */
        subscribeToEvents() {
        }
        // ===============================================================================
        // ENHANCED CAPABILITIES FROM PERFORMANCEOPTIMIZATIONMANAGER CONSOLIDATION
        // ===============================================================================
        /**
         * Initialize device capabilities detection
         */
        initializeDeviceCapabilities() {
          const nav = navigator;
          const memory = performance.memory;
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
          let maxTextureSize = 2048;
          if (gl) {
            maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE) || 2048;
          }
          const estimatedMemory = memory ? Math.round(memory.jsHeapSizeLimit / (1024 * 1024 * 1024)) : 4;
          let performanceTier = "medium";
          if (estimatedMemory >= 8 && nav.hardwareConcurrency >= 8 && maxTextureSize >= 4096) {
            performanceTier = "premium";
          } else if (estimatedMemory >= 4 && nav.hardwareConcurrency >= 4) {
            performanceTier = "high";
          } else if (estimatedMemory >= 2 && nav.hardwareConcurrency >= 2) {
            performanceTier = "medium";
          } else {
            performanceTier = "low";
          }
          this.deviceCapabilities = {
            performanceTier,
            memoryGB: estimatedMemory,
            cpuCores: nav.hardwareConcurrency || 4,
            gpuAcceleration: !!gl,
            isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(nav.userAgent),
            supportsWebGL: !!gl,
            supportsBackdropFilter: CSS.supports("backdrop-filter", "blur(10px)"),
            maxTextureSize,
            devicePixelRatio: window.devicePixelRatio || 1
          };
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Device capabilities detected:", this.deviceCapabilities);
          }
        }
        /**
         * Initialize thermal state monitoring
         */
        initializeThermalMonitoring() {
          this.thermalState = {
            temperature: "normal",
            throttleLevel: 0,
            cpuUsage: 0,
            gpuUsage: 0,
            memoryUsage: 0
          };
          setInterval(() => {
            this.updateThermalState();
          }, 1e4);
        }
        /**
         * Initialize battery monitoring if available
         */
        async initializeBatteryMonitoring() {
          try {
            const nav = navigator;
            if ("getBattery" in nav) {
              const battery = await nav.getBattery();
              this.batteryState = {
                level: battery.level,
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
              };
              battery.addEventListener("levelchange", () => {
                if (this.batteryState) {
                  this.batteryState.level = battery.level;
                  this.adjustPerformanceModeForBattery();
                }
              });
              battery.addEventListener("chargingchange", () => {
                if (this.batteryState) {
                  this.batteryState.charging = battery.charging;
                  this.adjustPerformanceModeForBattery();
                }
              });
              if (this.config.enableDebug) {
                console.log("[UnifiedPerformanceCoordinator] Battery monitoring initialized");
              }
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.log("[UnifiedPerformanceCoordinator] Battery API not available");
            }
          }
        }
        /**
         * Update thermal state based on performance metrics
         */
        updateThermalState() {
          const currentFPS = this.performanceAnalyzer.getMedianFPS() || 60;
          const memory = performance.memory;
          const memoryUsage = memory ? memory.usedJSHeapSize / memory.jsHeapSizeLimit : 0;
          let temperature = "normal";
          let throttleLevel = 0;
          if (currentFPS < 30 || memoryUsage > 0.9) {
            temperature = "critical";
            throttleLevel = 0.8;
          } else if (currentFPS < 45 || memoryUsage > 0.7) {
            temperature = "hot";
            throttleLevel = 0.4;
          } else if (currentFPS < 55 || memoryUsage > 0.5) {
            temperature = "warm";
            throttleLevel = 0.2;
          }
          this.thermalState = {
            temperature,
            throttleLevel,
            cpuUsage: Math.min(1 - currentFPS / 60, 1),
            gpuUsage: 0,
            // TODO: Implement GPU usage detection
            memoryUsage
          };
          if (temperature === "critical" && this.currentPerformanceMode.name !== "battery") {
            this.setPerformanceMode("battery");
          } else if (temperature === "normal" && this.currentPerformanceMode.name === "battery") {
            this.setPerformanceMode("auto");
          }
        }
        /**
         * Adjust performance mode based on battery state
         */
        adjustPerformanceModeForBattery() {
          if (!this.batteryState) return;
          if (!this.batteryState.charging && this.batteryState.level < 0.2) {
            this.setPerformanceMode("battery");
          } else if (this.batteryState.charging && this.currentPerformanceMode.name === "battery") {
            this.setPerformanceMode("auto");
          }
        }
        /**
         * Set performance mode
         */
        setPerformanceMode(modeName) {
          const mode = this.PERFORMANCE_MODES[modeName];
          if (!mode) return;
          this.currentPerformanceMode = mode;
          if (this.config.enableDebug) {
            console.log(`[UnifiedPerformanceCoordinator] Performance mode changed to: ${modeName}`);
          }
        }
        /**
         * Get current device capabilities
         */
        getDeviceCapabilities() {
          return { ...this.deviceCapabilities };
        }
        /**
         * Get current thermal state
         */
        getThermalState() {
          return { ...this.thermalState };
        }
        /**
         * Get current battery state
         */
        getBatteryState() {
          return this.batteryState ? { ...this.batteryState } : null;
        }
        /**
         * Get current performance mode
         */
        getCurrentPerformanceMode() {
          return { ...this.currentPerformanceMode };
        }
      };
      __name(_UnifiedPerformanceCoordinator, "UnifiedPerformanceCoordinator");
      _UnifiedPerformanceCoordinator.instance = null;
      UnifiedPerformanceCoordinator = _UnifiedPerformanceCoordinator;
    }
  });

  // src-js/core/performance/PerformanceBudgetManager.ts
  var _PerformanceBudgetManager, PerformanceBudgetManager;
  var init_PerformanceBudgetManager = __esm({
    "src-js/core/performance/PerformanceBudgetManager.ts"() {
      "use strict";
      _PerformanceBudgetManager = class _PerformanceBudgetManager {
        constructor(config = {}, performanceAnalyzer2) {
          this.cssVariableManager = null;
          // Optimization state
          this.optimizationLevel = "none";
          this.disabledFeatures = /* @__PURE__ */ new Set();
          this.config = {
            budgets: {
              animationFrame: 16.67,
              // 60 FPS
              cssVariableUpdate: 2,
              domObservation: 5,
              audioAnalysis: 10,
              visualEffects: 8,
              userInteraction: 100
            },
            autoOptimize: {
              enabled: true,
              violationThreshold: 5,
              recoveryThreshold: 80
            },
            enableDebug: false,
            ...config
          };
          this.performanceAnalyzer = performanceAnalyzer2;
          this.setupBudgetMonitoring();
        }
        static getInstance(config, performanceAnalyzer2) {
          if (!_PerformanceBudgetManager.instance && performanceAnalyzer2) {
            _PerformanceBudgetManager.instance = new _PerformanceBudgetManager(
              config,
              performanceAnalyzer2
            );
          }
          return _PerformanceBudgetManager.instance;
        }
        /**
         * Register CSS Variable Batcher for optimization
         */
        registerUnifiedCSSVariableManager(batcher) {
          this.cssVariableManager = batcher;
        }
        /**
         * Set up automatic budget monitoring and optimization
         */
        setupBudgetMonitoring() {
          if (!this.config.autoOptimize.enabled) return;
          setInterval(() => {
            this.checkBudgets();
          }, 5e3);
        }
        /**
         * Check budget violations and trigger optimizations
         * Note: Tier-based system doesn't generate budget violations, 
         * so this primarily monitors health score
         */
        checkBudgets() {
          const healthScore = this.performanceAnalyzer.calculateHealthScore();
          if (healthScore >= this.config.autoOptimize.recoveryThreshold) {
            this.recoverOptimizations();
          }
        }
        /**
         * Optimize a specific operation that's violating budget
         */
        optimizeOperation(operation) {
          if (this.disabledFeatures.has(operation)) return;
          switch (operation) {
            case "cssVariableUpdate":
              this.optimizeCSSVariableUpdates();
              break;
            case "domObservation":
              this.optimizeDOMObservation();
              break;
            case "visualEffects":
              this.optimizeVisualEffects();
              break;
            case "audioAnalysis":
              this.optimizeAudioAnalysis();
              break;
          }
          this.disabledFeatures.add(operation);
          if (this.config.enableDebug) {
            console.log(`\u{1F3AF} [PerformanceBudgetManager] Optimized ${operation} due to budget violations`);
          }
        }
        /**
         * Optimize CSS variable updates
         */
        optimizeCSSVariableUpdates() {
          if (!this.cssVariableManager) return;
          this.cssVariableManager.updateConfig({
            batchIntervalMs: 32,
            // Reduce to 30 FPS
            maxBatchSize: 25
            // Smaller batches
          });
        }
        /**
         * Optimize DOM observation
         */
        optimizeDOMObservation() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-dom-observation", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Optimize visual effects
         */
        optimizeVisualEffects() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-visual-effects", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Optimize audio analysis
         */
        optimizeAudioAnalysis() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-audio-analysis", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Escalate optimization level
         */
        escalateOptimization() {
          if (this.optimizationLevel === "none") {
            this.optimizationLevel = "conservative";
          } else if (this.optimizationLevel === "conservative") {
            this.optimizationLevel = "aggressive";
          }
          if (this.config.enableDebug) {
            console.log(`\u{1F3AF} [PerformanceBudgetManager] Escalated to ${this.optimizationLevel} optimization`);
          }
        }
        /**
         * Recover from optimizations when performance improves
         */
        recoverOptimizations() {
          if (this.optimizationLevel === "none") return;
          this.disabledFeatures.clear();
          if (this.cssVariableManager) {
            this.cssVariableManager.updateConfig({
              batchIntervalMs: 16,
              maxBatchSize: 50
            });
          }
          document.dispatchEvent(new CustomEvent("year3000:recover-optimizations", {
            detail: { previousLevel: this.optimizationLevel }
          }));
          this.optimizationLevel = "none";
          if (this.config.enableDebug) {
            console.log("\u{1F3AF} [PerformanceBudgetManager] Recovered from optimizations");
          }
        }
        /**
         * Get current optimization status
         */
        getOptimizationStatus() {
          return {
            level: this.optimizationLevel,
            disabledFeatures: Array.from(this.disabledFeatures),
            budgetViolations: [],
            // Tier-based system doesn't generate budget violations
            healthScore: this.performanceAnalyzer.calculateHealthScore()
          };
        }
        /**
         * Manually trigger optimization for testing
         */
        manualOptimize(operation) {
          this.optimizeOperation(operation);
        }
        /**
         * Manually recover from optimizations
         */
        manualRecover() {
          this.recoverOptimizations();
        }
        /**
         * Update performance budgets
         */
        updateBudgets(budgets) {
          this.config.budgets = { ...this.config.budgets, ...budgets };
          for (const [operation, budget] of Object.entries(budgets)) {
            this.performanceAnalyzer.updateBudget(operation, budget);
          }
        }
        /**
         * Destroy and cleanup
         */
        destroy() {
          this.disabledFeatures.clear();
          this.cssVariableManager = null;
          _PerformanceBudgetManager.instance = null;
        }
      };
      __name(_PerformanceBudgetManager, "PerformanceBudgetManager");
      _PerformanceBudgetManager.instance = null;
      PerformanceBudgetManager = _PerformanceBudgetManager;
    }
  });

  // src-js/core/consciousness/VisualEffectsCoordinator.ts
  var _VisualEffectsCoordinator, VisualEffectsCoordinator, globalVisualEffectsCoordinator;
  var init_VisualEffectsCoordinator = __esm({
    "src-js/core/consciousness/VisualEffectsCoordinator.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_Year3000Utilities();
      _VisualEffectsCoordinator = class _VisualEffectsCoordinator {
        constructor(utils = Year3000Utilities_exports, settingsManager2 = null) {
          this.initialized = false;
          // === TRANSITION MANAGEMENT ===
          this.transitionTimer = 0;
          this.lastTransitionStartTime = 0;
          this.transitionFromAccent = "";
          this.transitionToAccent = "";
          this.settingsManager = null;
          this.utils = utils;
          this.settingsManager = settingsManager2;
          this.consciousnessState = {
            consciousnessResonance: 0.7,
            multidimensionalAwareness: 0.8,
            transcendenceLevel: 0.6,
            dominantEmotionalTemperature: 6500,
            emotionalDepth: 0.7,
            emotionalComplexity: 0.5,
            totalIntensity: 0.5,
            activeLayerCount: 3,
            volumetricDepth: 0.4,
            cinematicPerspective: 0.6,
            holographicInfluence: 0.2,
            dataStreamIntensity: 0.3,
            interferencePatterns: 0.1,
            projectionStability: 0.9,
            temporalMemoryDepth: 0.5,
            consciousnessEvolution: 0,
            futureProjection: 0.2,
            catppuccinPreservationLevel: 0.8,
            currentPalette: [],
            paletteEvolution: {
              currentGeneration: 0,
              totalEvolutions: 0,
              evolutionVelocity: 0.1,
              adaptationRate: 0.3,
              previousGenerations: [],
              futureProjections: [],
              temporalPatterns: [],
              consciousnessGrowth: 0,
              transcendenceProgress: 0,
              cosmicAlignment: 0.5
            },
            atmosphericDensity: 0.3,
            cosmicResonance: 0.5,
            quantumFluctuation: 0.2,
            lastBlendTime: Date.now(),
            consciousnessFrameRate: 60,
            systemHealthConsciousness: 1
          };
          this.dynamicColorState = {
            currentAccentHex: "#4b19a1",
            // Default StarryNight cosmic purple
            currentAccentRgb: "75,25,161",
            baseBackgroundHex: "#0d1117",
            // Default StarryNight deep space black
            baseBackgroundRgb: "13,17,23",
            lastUpdateTime: 0,
            musicEnergy: 0.5,
            transitionInProgress: false
          };
          this.integrationConfig = {
            accentUpdateEnabled: true,
            baseTransformationEnabled: true,
            consciousnessIntegrationEnabled: true,
            smoothTransitionDuration: 800,
            // 0.8s smooth transitions
            energyResponseMultiplier: 1.2
          };
        }
        async initialize() {
          if (this.initialized) return;
          try {
            this.setupUnifiedEventSubscriptions();
            this.setupSettingsListeners();
            this.initializeCurrentDynamicState();
            const isDynamicEnabled = this.checkDynamicAccentEnabled();
            this.integrationConfig.accentUpdateEnabled = isDynamicEnabled;
            this.initialized = true;
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              "\u{1F3A8} Unified consciousness coordinator initialized successfully",
              {
                consciousnessLevel: this.consciousnessState.consciousnessResonance,
                dynamicAccentEnabled: isDynamicEnabled,
                accentHex: this.dynamicColorState.currentAccentHex
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualEffectsCoordinator",
              "Failed to initialize:",
              error
            );
            throw error;
          }
        }
        async healthCheck() {
          const issues = [];
          if (!this.initialized) {
            issues.push("Coordinator not initialized");
          }
          if (this.dynamicColorState.transitionInProgress && Date.now() - this.lastTransitionStartTime > 1e4) {
            issues.push("Dynamic color transition appears stuck");
          }
          if (this.consciousnessState.systemHealthConsciousness < 0.5) {
            issues.push(
              `Low consciousness health: ${(this.consciousnessState.systemHealthConsciousness * 100).toFixed(1)}%`
            );
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Unified consciousness coordination - consciousness level: ${this.consciousnessState.consciousnessResonance.toFixed(
              2
            )}, dynamic accent: ${this.integrationConfig.accentUpdateEnabled}`,
            issues,
            system: "VisualEffectsCoordinator"
          };
        }
        updateAnimation(deltaTime) {
          this.consciousnessState.consciousnessFrameRate = 1e3 / deltaTime;
          this.consciousnessState.consciousnessEvolution += deltaTime * 1e-4;
          if (this.consciousnessState.consciousnessEvolution > 1) {
            this.consciousnessState.consciousnessEvolution = 0;
          }
          this.consciousnessState.quantumFluctuation = 0.2 + Math.sin(Date.now() * 2e-3) * 0.1;
        }
        destroy() {
          if (this.transitionTimer) {
            clearTimeout(this.transitionTimer);
            this.transitionTimer = 0;
          }
          unifiedEventBus.unsubscribeAll("VisualEffectsCoordinator");
          this.dynamicColorState.transitionInProgress = false;
          this.initialized = false;
          Y3KDebug?.debug?.log(
            "VisualEffectsCoordinator",
            "Unified consciousness coordinator destroyed"
          );
        }
        // ============================================================================
        // Unified Event System Integration
        // ============================================================================
        /**
         * Setup unified event subscriptions for both consciousness systems
         */
        setupUnifiedEventSubscriptions() {
          unifiedEventBus.subscribe(
            "colors:harmonized",
            (data) => {
              this.handleUnifiedColorUpdate(data);
            },
            "VisualEffectsCoordinator"
          );
          unifiedEventBus.subscribe(
            "colors:extracted",
            (data) => {
              if (data.rawColors) {
                this.handleExtractedColors(data.rawColors);
              }
            },
            "VisualEffectsCoordinator"
          );
          unifiedEventBus.subscribe(
            "colors:applied",
            (data) => {
              if (data.cssVariables && this.integrationConfig.accentUpdateEnabled) {
                this.handleCSSVariablesApplied(
                  data.cssVariables,
                  data.accentHex,
                  data.accentRgb
                );
              }
            },
            "VisualEffectsCoordinator"
          );
          unifiedEventBus.subscribe(
            "settings:changed",
            (data) => {
              this.handleSettingsChange(data);
            },
            "VisualEffectsCoordinator"
          );
          if (typeof document !== "undefined") {
            document.addEventListener("music-state-change", (event) => {
              const customEvent = event;
              if (customEvent.detail) {
                this.handleMusicStateChange(customEvent.detail);
              }
            });
          }
          Y3KDebug?.debug?.log(
            "VisualEffectsCoordinator",
            "Unified event subscriptions setup complete"
          );
        }
        /**
         *  PHASE 4: Handle unified color events (ColorConsciousnessState logic)
         */
        handleUnifiedColorUpdate(data) {
          const { processedColors, accentHex, accentRgb, coordinationMetrics } = data;
          const musicEmotion = coordinationMetrics?.emotionalState || "neutral";
          const beatData = coordinationMetrics?.musicInfluenceStrength || 0.5;
          this.updateConsciousnessFromMusic(musicEmotion, beatData);
          this.updatePaletteFromUnifiedColors(processedColors, accentHex, accentRgb);
          if (this.integrationConfig.accentUpdateEnabled && accentHex && accentHex !== this.dynamicColorState.currentAccentHex) {
            this.scheduleSmoothAccentTransition(accentHex);
          }
          this.publishConsciousnessUpdate();
        }
        /**
         *  PHASE 4: Handle extracted colors (DynamicCatppuccinBridge logic)
         */
        handleExtractedColors(extractedColors) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            const newAccentHex = this.selectBestAccentColor(extractedColors);
            if (newAccentHex && newAccentHex !== this.dynamicColorState.currentAccentHex) {
              this.scheduleSmoothAccentTransition(newAccentHex);
            }
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              "Processed extracted colors:",
              {
                input: Object.keys(extractedColors),
                selectedAccent: newAccentHex
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualEffectsCoordinator",
              "Error handling extracted colors:",
              error
            );
          }
        }
        /**
         *  PHASE 4: Handle CSS variables applied (DynamicCatppuccinBridge logic)
         */
        handleCSSVariablesApplied(cssVariables, accentHex, accentRgb) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            if (accentHex && accentHex !== this.dynamicColorState.currentAccentHex) {
              this.dynamicColorState.currentAccentHex = accentHex;
              this.dynamicColorState.currentAccentRgb = accentRgb;
              this.dynamicColorState.lastUpdateTime = Date.now();
            }
            const enhancedVariables = {};
            const accent = cssVariables["--sn-accent-hex"] || cssVariables["--spice-accent"] || accentHex;
            const accentRgbVar = cssVariables["--sn-accent-rgb"] || cssVariables["--spice-rgb-accent"] || accentRgb;
            if (accent && accentRgbVar) {
              enhancedVariables["--sn-dynamic-accent-hex"] = accent;
              enhancedVariables["--sn-dynamic-accent-rgb"] = accentRgbVar;
              enhancedVariables["--sn-dynamic-primary-hex"] = accent;
              enhancedVariables["--sn-dynamic-primary-rgb"] = accentRgbVar;
              if (typeof document !== "undefined") {
                const root = document.documentElement;
                Object.entries(enhancedVariables).forEach(([property, value]) => {
                  root.style.setProperty(property, value);
                });
              }
            }
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              "Processed colors:applied event:",
              {
                accentHex: accent,
                accentRgb: accentRgbVar,
                variablesProcessed: Object.keys(cssVariables).length,
                enhancedVariables: Object.keys(enhancedVariables).length
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualEffectsCoordinator",
              "Error handling CSS variables applied:",
              error
            );
          }
        }
        /**
         * Handle music state changes for unified consciousness coordination
         */
        handleMusicStateChange(musicState) {
          if (musicState.energy !== void 0) {
            this.dynamicColorState.musicEnergy = musicState.energy;
            if (this.integrationConfig.consciousnessIntegrationEnabled) {
              this.updateConsciousnessWithMusicEnergy(musicState.energy);
            }
          }
        }
        /**
         * Handle settings changes for unified consciousness
         */
        handleSettingsChange(data) {
          if ([
            "catppuccin-flavor",
            "catppuccin-accentColor",
            "sn-dynamic-color-intensity"
          ].includes(data.settingKey)) {
            this.consciousnessState.consciousnessEvolution = 0;
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              "Consciousness state reset due to settings change:",
              data.settingKey
            );
          }
          if (data.settingKey === "catppuccin-accentColor") {
            const isDynamic = String(data.value) === "dynamic";
            this.integrationConfig.accentUpdateEnabled = isDynamic;
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              `Accent setting changed to: ${data.value}, Dynamic enabled: ${isDynamic}`
            );
          }
        }
        // ============================================================================
        // Consciousness Processing (ColorConsciousnessState logic)
        // ============================================================================
        /**
         * Update consciousness parameters from musical input
         */
        updateConsciousnessFromMusic(musicEmotion, beatData) {
          if (musicEmotion) {
            this.consciousnessState.consciousnessResonance = (musicEmotion.valence + musicEmotion.intensity) * 0.5;
            this.consciousnessState.dominantEmotionalTemperature = 4e3 + musicEmotion.valence * 4e3;
            this.consciousnessState.totalIntensity = musicEmotion.intensity || 0.5;
            this.consciousnessState.multidimensionalAwareness = Math.min(
              1,
              (musicEmotion.valence + musicEmotion.arousal) * 0.6
            );
            this.consciousnessState.emotionalDepth = Math.abs(musicEmotion.valence - 0.5) * 2;
            this.consciousnessState.dataStreamIntensity = musicEmotion.intensity * 0.7;
          }
          if (beatData) {
            this.consciousnessState.holographicInfluence = Math.min(
              0.8,
              beatData.strength * 0.6
            );
            if (beatData.strength > 0.7) {
              this.updateTemporalMemory(beatData);
            }
            this.consciousnessState.volumetricDepth = Math.min(
              1,
              beatData.strength * 0.8
            );
          }
        }
        /**
         * Convert unified processed colors to consciousness format
         */
        updatePaletteFromUnifiedColors(processedColors, accentHex, accentRgb) {
          const paletteColors = [
            { hex: accentHex, rgb: this.hexToRgb(accentHex) },
            {
              hex: processedColors["primary"] || accentHex,
              rgb: this.hexToRgb(processedColors["primary"] || accentHex)
            },
            {
              hex: processedColors["secondary"] || accentHex,
              rgb: this.hexToRgb(processedColors["secondary"] || accentHex)
            }
          ].filter((color3) => color3.hex);
          this.updatePaletteFromHarmony(paletteColors);
        }
        /**
         * Convert color harmony palette to consciousness format
         */
        updatePaletteFromHarmony(palette) {
          if (this.consciousnessState.currentPalette.length > 0) {
            this.consciousnessState.paletteEvolution.previousGenerations.push([
              ...this.consciousnessState.currentPalette
            ]);
            if (this.consciousnessState.paletteEvolution.previousGenerations.length > 5) {
              this.consciousnessState.paletteEvolution.previousGenerations.shift();
            }
          }
          this.consciousnessState.currentPalette = palette.map(
            (color3, index) => ({
              rgb: color3.rgb || { r: color3.r || 0, g: color3.g || 0, b: color3.b || 0 },
              oklab: color3.oklab,
              hsl: color3.hsl,
              xyz: color3.xyz,
              // Consciousness properties
              consciousnessLevel: this.consciousnessState.consciousnessResonance,
              emotionalResonance: this.consciousnessState.emotionalDepth,
              transcendenceIndex: this.consciousnessState.transcendenceLevel,
              // Temporal properties
              temporalStability: Math.max(0.1, 1 - index * 0.1),
              evolutionRate: this.consciousnessState.paletteEvolution.evolutionVelocity,
              memoryImprint: this.consciousnessState.temporalMemoryDepth,
              // Atmospheric properties
              volumetricPresence: this.consciousnessState.volumetricDepth * (1 - index * 0.15),
              holographicReflectance: this.consciousnessState.holographicInfluence,
              cosmicFrequency: 432 + index * 111,
              // Metadata
              colorSpace: color3.oklab ? "oklab" : "rgb",
              generationMethod: "harmony",
              timestamp: Date.now()
            })
          );
          this.consciousnessState.activeLayerCount = palette.length;
          this.consciousnessState.lastBlendTime = Date.now();
          this.consciousnessState.paletteEvolution.currentGeneration++;
          this.consciousnessState.paletteEvolution.totalEvolutions++;
        }
        /**
         * Update temporal memory based on strong beats
         */
        updateTemporalMemory(beatData) {
          const currentTime = Date.now();
          const pattern = {
            patternId: `pattern-${currentTime}`,
            frequency: beatData.tempo || 120,
            strength: beatData.strength,
            colorSequence: [...this.consciousnessState.currentPalette],
            musicalCorrelation: beatData.strength,
            consciousnessSignature: this.consciousnessState.consciousnessResonance
          };
          this.consciousnessState.paletteEvolution.temporalPatterns.push(pattern);
          if (this.consciousnessState.paletteEvolution.temporalPatterns.length > 10) {
            this.consciousnessState.paletteEvolution.temporalPatterns.shift();
          }
          this.consciousnessState.temporalMemoryDepth = Math.min(
            1,
            this.consciousnessState.temporalMemoryDepth + 0.1
          );
        }
        /**
         * Publish consciousness update for dependent systems
         */
        publishConsciousnessUpdate() {
          unifiedEventBus.emit("consciousness:updated", {
            type: "colorConsciousnessUpdate",
            payload: {
              // Core Data (preserved for compatibility)
              palette: this.consciousnessState.currentPalette,
              consciousnessLevel: this.consciousnessState.consciousnessResonance,
              emotionalTemperature: this.consciousnessState.dominantEmotionalTemperature,
              // Enhanced Transcendent Data
              multidimensionalAwareness: this.consciousnessState.multidimensionalAwareness,
              transcendenceLevel: this.consciousnessState.transcendenceLevel,
              volumetricDepth: this.consciousnessState.volumetricDepth,
              dataStreamIntensity: this.consciousnessState.dataStreamIntensity,
              temporalMemoryDepth: this.consciousnessState.temporalMemoryDepth,
              cosmicResonance: this.consciousnessState.cosmicResonance,
              // Evolution State
              paletteGeneration: this.consciousnessState.paletteEvolution.currentGeneration,
              temporalPatternCount: this.consciousnessState.paletteEvolution.temporalPatterns.length,
              // Full State (for advanced consumers including dynamic color integration)
              fullConsciousnessState: this.consciousnessState
            }
          });
          if (this.consciousnessState.dataStreamIntensity > 0.5) {
            unifiedEventBus.emit("consciousness:holographic-stream", {
              type: "holographicStreamUpdate",
              payload: {
                intensity: this.consciousnessState.dataStreamIntensity,
                interferencePatterns: this.consciousnessState.interferencePatterns,
                projectionStability: this.consciousnessState.projectionStability
              }
            });
          }
          if (this.consciousnessState.paletteEvolution.temporalPatterns.length > 3) {
            unifiedEventBus.emit("consciousness:temporal-pattern", {
              type: "temporalPatternDetected",
              payload: {
                patterns: this.consciousnessState.paletteEvolution.temporalPatterns,
                memoryDepth: this.consciousnessState.temporalMemoryDepth
              }
            });
          }
          if (this.consciousnessState.transcendenceLevel > 0.8) {
            unifiedEventBus.emit("consciousness:transcendence-high", {
              type: "transcendenceLevelHigh",
              payload: {
                level: this.consciousnessState.transcendenceLevel,
                cosmicAlignment: this.consciousnessState.paletteEvolution.cosmicAlignment
              }
            });
          }
        }
        // ============================================================================
        // Dynamic Color Processing (DynamicCatppuccinBridge logic)
        // ============================================================================
        /**
         * Schedule smooth transition between accent colors
         */
        scheduleSmoothAccentTransition(newAccentHex) {
          if (this.dynamicColorState.transitionInProgress) {
            this.transitionToAccent = newAccentHex;
            return;
          }
          this.transitionFromAccent = this.dynamicColorState.currentAccentHex;
          this.transitionToAccent = newAccentHex;
          this.dynamicColorState.transitionInProgress = true;
          this.lastTransitionStartTime = Date.now();
          this.animateAccentTransition();
          Y3KDebug?.debug?.log(
            "VisualEffectsCoordinator",
            `Accent transition scheduled: ${this.transitionFromAccent} \u2192 ${newAccentHex}`
          );
        }
        /**
         * Animate smooth accent color transitions
         */
        animateAccentTransition() {
          const animate = /* @__PURE__ */ __name(() => {
            if (!this.dynamicColorState.transitionInProgress) return;
            const elapsed = Date.now() - this.lastTransitionStartTime;
            const progress = Math.min(
              elapsed / this.integrationConfig.smoothTransitionDuration,
              1
            );
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const currentColor = this.interpolateColors(
              this.transitionFromAccent,
              this.transitionToAccent,
              easeProgress
            );
            if (currentColor) {
              this.applyDynamicAccent(currentColor);
            }
            if (progress >= 1) {
              this.dynamicColorState.transitionInProgress = false;
              this.dynamicColorState.currentAccentHex = this.transitionToAccent;
              this.dynamicColorState.lastUpdateTime = Date.now();
              const rgb = this.utils.hexToRgb(this.transitionToAccent);
              if (rgb) {
                this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
              }
              Y3KDebug?.debug?.log(
                "VisualEffectsCoordinator",
                `Accent transition complete: ${this.transitionToAccent}`
              );
            } else {
              requestAnimationFrame(animate);
            }
          }, "animate");
          requestAnimationFrame(animate);
        }
        /**
         * Apply dynamic accent using unified consciousness coordination
         */
        applyDynamicAccent(accentHex) {
          if (typeof document === "undefined") return;
          const root = document.documentElement;
          const rgb = this.utils.hexToRgb(accentHex);
          if (!rgb) return;
          const rgbString = `${rgb.r},${rgb.g},${rgb.b}`;
          root.style.setProperty("--sn-dynamic-accent-hex", accentHex);
          root.style.setProperty("--sn-dynamic-accent-rgb", rgbString);
          root.style.setProperty("--sn-dynamic-primary-hex", accentHex);
          root.style.setProperty("--sn-dynamic-primary-rgb", rgbString);
          root.style.setProperty("--spice-accent", accentHex);
          root.style.setProperty("--spice-button", accentHex);
          root.style.setProperty("--spice-button-active", accentHex);
          root.style.setProperty("--spice-rgb-accent", rgbString);
          root.style.setProperty("--spice-rgb-button", rgbString);
          root.style.setProperty("--sn-color-extracted-primary-rgb", rgbString);
          root.style.setProperty("--sn-color-extracted-vibrant-rgb", rgbString);
          root.style.setProperty("--sn-color-extracted-dominant-rgb", rgbString);
          if (this.integrationConfig.consciousnessIntegrationEnabled) {
            this.updateConsciousnessWithAccent(accentHex, rgbString);
          }
        }
        /**
         * Update consciousness system with new accent awareness
         */
        updateConsciousnessWithAccent(accentHex, accentRgb) {
          if (typeof document === "undefined") return;
          const root = document.documentElement;
          root.style.setProperty("--organic-holographic-rgb", accentRgb);
          root.style.setProperty("--holographic-scanline-rgb", accentRgb);
          root.style.setProperty(
            "--consciousness-intensity",
            `calc(0.5 + var(--musical-sync-intensity) * ${this.integrationConfig.energyResponseMultiplier})`
          );
        }
        /**
         * Update consciousness with music energy
         */
        updateConsciousnessWithMusicEnergy(energy) {
          if (typeof document === "undefined") return;
          const root = document.documentElement;
          const adjustedEnergy = energy * this.integrationConfig.energyResponseMultiplier;
          root.style.setProperty(
            "--musical-sync-intensity",
            adjustedEnergy.toString()
          );
          root.style.setProperty(
            "--holographic-music-flicker-intensity",
            adjustedEnergy.toString()
          );
          const baseIntensity = 0.5;
          const consciousnessIntensity = Math.max(
            0.1,
            Math.min(1, baseIntensity + adjustedEnergy * 0.3)
          );
          root.style.setProperty(
            "--consciousness-intensity",
            consciousnessIntensity.toString()
          );
        }
        // ============================================================================
        // Utility Methods (Consolidated)
        // ============================================================================
        /**
         * Helper method to convert hex to RGB
         */
        hexToRgb(hex) {
          hex = hex.replace("#", "");
          const r = parseInt(hex.substring(0, 2), 16);
          const g = parseInt(hex.substring(2, 4), 16);
          const b = parseInt(hex.substring(4, 6), 16);
          return { r, g, b };
        }
        /**
         * Interpolate between two hex colors
         */
        interpolateColors(fromHex, toHex, progress) {
          const fromRgb = this.utils.hexToRgb(fromHex);
          const toRgb = this.utils.hexToRgb(toHex);
          if (!fromRgb || !toRgb) return null;
          const r = Math.round(fromRgb.r + (toRgb.r - fromRgb.r) * progress);
          const g = Math.round(fromRgb.g + (toRgb.g - fromRgb.g) * progress);
          const b = Math.round(fromRgb.b + (toRgb.b - fromRgb.b) * progress);
          return this.utils.rgbToHex(r, g, b);
        }
        /**
         * Select best accent color from extracted colors
         */
        selectBestAccentColor(colors) {
          const priorities = [
            "VIBRANT_NON_ALARMING",
            "VIBRANT",
            "LIGHT_VIBRANT",
            "PROMINENT",
            "PRIMARY",
            "DARK_VIBRANT"
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Check if dynamic accent is enabled in settings
         */
        checkDynamicAccentEnabled() {
          try {
            if (!this.settingsManager) return false;
            const accentSetting = this.settingsManager.get("catppuccin-accentColor");
            return String(accentSetting) === "dynamic";
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualEffectsCoordinator",
              "Error checking dynamic accent setting:",
              error
            );
            return false;
          }
        }
        /**
         * Initialize current dynamic state from existing CSS variables
         */
        initializeCurrentDynamicState() {
          if (typeof document === "undefined") return;
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentAccent = computedStyle.getPropertyValue("--sn-dynamic-accent-hex").trim() || computedStyle.getPropertyValue("--sn-cosmic-accent-hex").trim() || computedStyle.getPropertyValue("--spice-accent").trim();
          if (currentAccent) {
            this.dynamicColorState.currentAccentHex = currentAccent;
            const rgb = this.utils.hexToRgb(currentAccent);
            if (rgb) {
              this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
            }
          }
          this.dynamicColorState.lastUpdateTime = Date.now();
        }
        /**
         * Setup settings change listeners
         */
        setupSettingsListeners() {
          if (typeof document === "undefined") return;
          document.addEventListener(
            "year3000SystemSettingsChanged",
            (event) => {
              const customEvent = event;
              const { key, value } = customEvent.detail || {};
              if (key === "catppuccin-accentColor") {
                const isDynamic = String(value) === "dynamic";
                this.integrationConfig.accentUpdateEnabled = isDynamic;
                Y3KDebug?.debug?.log(
                  "VisualEffectsCoordinator",
                  `Accent setting changed to: ${value}, Coordinator active: ${this.initialized}`
                );
              }
            }
          );
        }
        // ============================================================================
        // Public API (Backward Compatibility)
        // ============================================================================
        /**
         * Get current consciousness state (ColorConsciousnessState compatibility)
         */
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        /**
         * Set consciousness parameters manually (ColorConsciousnessState compatibility)
         */
        setConsciousness(level, temperature = 6500) {
          this.consciousnessState.consciousnessResonance = Math.max(
            0,
            Math.min(1, level)
          );
          this.consciousnessState.dominantEmotionalTemperature = Math.max(
            1e3,
            Math.min(1e4, temperature)
          );
          this.consciousnessState.transcendenceLevel = Math.min(1, level * 1.2);
          this.consciousnessState.multidimensionalAwareness = level * 0.9;
          this.publishConsciousnessUpdate();
        }
        /**
         * Get transcendent color palette (ColorConsciousnessState compatibility)
         */
        getTranscendentPalette() {
          return [...this.consciousnessState.currentPalette];
        }
        /**
         * Get temporal patterns (ColorConsciousnessState compatibility)
         */
        getTemporalPatterns() {
          return [...this.consciousnessState.paletteEvolution.temporalPatterns];
        }
        /**
         * Get current dynamic color state (DynamicCatppuccinBridge compatibility)
         */
        getDynamicColorState() {
          return { ...this.dynamicColorState };
        }
        /**
         * Update integration configuration (DynamicCatppuccinBridge compatibility)
         */
        updateConfig(newConfig) {
          this.integrationConfig = { ...this.integrationConfig, ...newConfig };
          Y3KDebug?.debug?.log(
            "VisualEffectsCoordinator",
            "Configuration updated:",
            newConfig
          );
        }
        /**
         * Set transcendence level manually (ColorConsciousnessState compatibility)
         */
        setTranscendence(level) {
          this.consciousnessState.transcendenceLevel = Math.max(
            0,
            Math.min(1, level)
          );
          this.consciousnessState.cosmicResonance = level * 0.8;
          this.consciousnessState.paletteEvolution.transcendenceProgress = level;
          this.publishConsciousnessUpdate();
        }
        /**
         * Set data stream intensity (ColorConsciousnessState compatibility)
         */
        setDataStreamIntensity(intensity) {
          this.consciousnessState.dataStreamIntensity = Math.max(
            0,
            Math.min(1, intensity)
          );
          this.publishConsciousnessUpdate();
        }
      };
      __name(_VisualEffectsCoordinator, "VisualEffectsCoordinator");
      VisualEffectsCoordinator = _VisualEffectsCoordinator;
      globalVisualEffectsCoordinator = new VisualEffectsCoordinator();
    }
  });

  // src-js/utils/color/MusicalOKLABCoordinator.ts
  var _MusicalOKLABCoordinator, MusicalOKLABCoordinator;
  var init_MusicalOKLABCoordinator = __esm({
    "src-js/utils/color/MusicalOKLABCoordinator.ts"() {
      "use strict";
      init_GenreProfileManager();
      init_globalConfig();
      init_UnifiedDebugManager();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      _MusicalOKLABCoordinator = class _MusicalOKLABCoordinator {
        // 5 minutes
        constructor(enableDebug = YEAR3000_CONFIG.enableDebug) {
          this.coordinationCache = /* @__PURE__ */ new Map();
          this.cacheMaxSize = 20;
          this.cacheTimeoutMs = 3e5;
          this.enableDebug = enableDebug;
          this.oklabProcessor = new OKLABColorProcessor(enableDebug);
          this.emotionalMapper = new EmotionalTemperatureMapper(enableDebug);
          this.genreManager = new GenreProfileManager({ YEAR3000_CONFIG });
          if (this.enableDebug) {
            Y3KDebug?.debug?.log(
              "MusicalOKLABCoordinator",
              "Unified music-to-OKLAB coordinator initialized"
            );
          }
        }
        /**
         * Main coordination method - processes musical context through complete OKLAB pipeline
         */
        async coordinateMusicalColors(context, options = {}) {
          const startTime = performance.now();
          const cacheKey = this.generateCacheKey(context);
          const cachedResult = this.coordinationCache.get(cacheKey);
          if (cachedResult) {
            if (this.enableDebug) {
              Y3KDebug?.debug?.log(
                "MusicalOKLABCoordinator",
                "Using cached coordination result",
                { cacheKey }
              );
            }
            return cachedResult;
          }
          try {
            const coordinationStrategy = this.determineCoordinationStrategy(
              context,
              options
            );
            const oklabPreset = await this.getOptimalOKLABPreset(
              context,
              coordinationStrategy,
              options
            );
            const colorProcessingResult = await this.processColorsWithMusicalContext(
              context.rawColors,
              context.musicData,
              oklabPreset
            );
            const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(context.musicData);
            const detectedGenre = this.genreManager.detectGenre(context.musicData);
            const genreCharacteristics = this.genreManager.getColorCharacteristicsForGenre(detectedGenre);
            const musicInfluenceStrength = this.calculateMusicInfluenceStrength(
              context.musicData,
              emotionalResult
            );
            const cssVariables = this.generateUnifiedCSSVariables(
              colorProcessingResult,
              emotionalResult,
              genreCharacteristics,
              oklabPreset
            );
            const { accentHex, accentRgb } = this.selectOptimalAccentColor(
              colorProcessingResult
            );
            const processingTime = performance.now() - startTime;
            const result = {
              enhancedColors: Object.fromEntries(
                Object.entries(colorProcessingResult).map(([key, oklabResult]) => [
                  key,
                  oklabResult.enhancedHex
                ])
              ),
              accentHex,
              accentRgb,
              oklabPreset,
              oklabResults: colorProcessingResult,
              detectedGenre,
              emotionalResult,
              genreCharacteristics,
              processingTime,
              musicInfluenceStrength,
              coordinationStrategy,
              cssVariables
            };
            this.cacheResult(cacheKey, result);
            if (this.enableDebug) {
              Y3KDebug?.debug?.log(
                "MusicalOKLABCoordinator",
                "Musical OKLAB coordination completed",
                {
                  genre: detectedGenre,
                  emotion: emotionalResult.primaryEmotion,
                  strategy: coordinationStrategy,
                  preset: oklabPreset.name,
                  processingTime,
                  colorCount: Object.keys(colorProcessingResult).length
                }
              );
            }
            return result;
          } catch (error) {
            if (this.enableDebug) {
              Y3KDebug?.debug?.error(
                "MusicalOKLABCoordinator",
                "Musical coordination failed:",
                error
              );
            }
            return this.createFallbackResult(context, performance.now() - startTime);
          }
        }
        /**
         * Determine the optimal coordination strategy based on musical context
         */
        determineCoordinationStrategy(context, options) {
          const { musicData } = context;
          if (!musicData || typeof musicData.energy !== "number" || typeof musicData.valence !== "number") {
            return "fallback";
          }
          if (options.preferGenreOverEmotion === true) {
            return "genre-primary";
          } else if (options.preferGenreOverEmotion === false) {
            return "emotion-primary";
          }
          const energyExtremity = Math.abs(musicData.energy - 0.5) * 2;
          const valenceExtremity = Math.abs(musicData.valence - 0.5) * 2;
          const emotionalExtremity = (energyExtremity + valenceExtremity) / 2;
          if (emotionalExtremity > 0.6) {
            return "emotion-primary";
          }
          const detectedGenre = this.genreManager.detectGenre(musicData);
          if (detectedGenre !== "default") {
            return "genre-primary";
          }
          return "balanced";
        }
        /**
         * Get optimal OKLAB preset considering both genre and emotional context
         */
        async getOptimalOKLABPreset(context, strategy, options) {
          const { musicData } = context;
          try {
            let preset;
            switch (strategy) {
              case "genre-primary":
                preset = this.genreManager.getOKLABPresetForTrack(musicData);
                break;
              case "emotion-primary":
                const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
                preset = emotionalResult.oklabPreset;
                break;
              case "balanced":
                const genrePreset = this.genreManager.getOKLABPresetForTrack(musicData);
                const emotionalResult2 = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
                preset = this.blendPresets(
                  genrePreset,
                  emotionalResult2.oklabPreset,
                  options.intensityMultiplier || 1
                );
                break;
              default:
                preset = OKLABColorProcessor.getPreset("STANDARD");
            }
            return preset;
          } catch (error) {
            if (this.enableDebug) {
              Y3KDebug?.debug?.warn(
                "MusicalOKLABCoordinator",
                "Failed to get optimal preset, using STANDARD:",
                error
              );
            }
            return OKLABColorProcessor.getPreset("STANDARD");
          }
        }
        /**
         * Blend two OKLAB presets for balanced coordination strategy
         */
        blendPresets(genrePreset, emotionalPreset, intensityMultiplier) {
          const blendedChromaBoost = (genrePreset.chromaBoost + emotionalPreset.chromaBoost) / 2 * intensityMultiplier;
          const blendedLightnessBoost = (genrePreset.lightnessBoost + emotionalPreset.lightnessBoost) / 2;
          const blendedShadowReduction = (genrePreset.shadowReduction + emotionalPreset.shadowReduction) / 2;
          const blendedVibrantThreshold = (genrePreset.vibrantThreshold + emotionalPreset.vibrantThreshold) / 2;
          return OKLABColorProcessor.createCustomPreset(
            "blended-genre-emotion",
            `Blended ${genrePreset.name} + ${emotionalPreset.name}`,
            blendedLightnessBoost,
            blendedChromaBoost,
            blendedShadowReduction,
            blendedVibrantThreshold
          );
        }
        /**
         * Process all colors through OKLAB with musical context
         */
        async processColorsWithMusicalContext(rawColors, musicData, preset) {
          const results = {};
          for (const [key, color3] of Object.entries(rawColors)) {
            if (!color3 || typeof color3 !== "string" || !color3.startsWith("#")) {
              continue;
            }
            try {
              const oklabResult = this.oklabProcessor.processColor(color3, preset);
              results[key] = oklabResult;
            } catch (error) {
              if (this.enableDebug) {
                Y3KDebug?.debug?.warn(
                  "MusicalOKLABCoordinator",
                  `Failed to process color ${key}:`,
                  error
                );
              }
            }
          }
          return results;
        }
        /**
         * Calculate music influence strength for coordination
         */
        calculateMusicInfluenceStrength(musicData, emotionalResult) {
          const energyInfluence = musicData.energy || 0.5;
          const valenceExtremity = Math.abs((musicData.valence || 0.5) - 0.5) * 2;
          const emotionalIntensity = emotionalResult.intensity;
          const baseInfluence = (energyInfluence + valenceExtremity + emotionalIntensity) / 3;
          let contextBoost = 1;
          if (musicData.tempo && musicData.tempo > 0) contextBoost += 0.1;
          if (musicData.danceability && musicData.danceability > 0.7)
            contextBoost += 0.1;
          if (musicData.genre && musicData.genre !== "default") contextBoost += 0.1;
          return Math.min(1, baseInfluence * contextBoost);
        }
        /**
         * Generate comprehensive CSS variables for all visual systems
         */
        generateUnifiedCSSVariables(oklabResults, emotionalResult, genreCharacteristics, preset) {
          const variables = {};
          Object.entries(oklabResults).forEach(([key, result]) => {
            variables[`--sn-${key.toLowerCase()}-enhanced`] = result.enhancedHex;
            variables[`--sn-${key.toLowerCase()}-oklab-l`] = result.oklabEnhanced.L.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklab-a`] = result.oklabEnhanced.a.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklab-b`] = result.oklabEnhanced.b.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklch-c`] = result.oklchEnhanced.C.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklch-h`] = result.oklchEnhanced.H.toFixed(1);
            variables[`--sn-${key.toLowerCase()}-shadow`] = result.shadowHex;
          });
          Object.entries(emotionalResult.cssVariables).forEach(([key, value]) => {
            variables[key] = value;
          });
          variables["--sn-detected-genre"] = genreCharacteristics ? genreCharacteristics.vibrancyLevel : "standard";
          variables["--sn-color-temperature"] = genreCharacteristics ? genreCharacteristics.colorTemperature : "neutral";
          variables["--sn-emotional-range"] = genreCharacteristics ? genreCharacteristics.emotionalRange : "moderate";
          variables["--sn-oklab-preset-name"] = preset.name;
          variables["--sn-oklab-chroma-boost"] = preset.chromaBoost.toString();
          variables["--sn-oklab-lightness-boost"] = preset.lightnessBoost.toString();
          variables["--sn-musical-oklab-coordination"] = "enabled";
          variables["--sn-color-processing-mode"] = "unified-musical-oklab";
          return variables;
        }
        /**
         * Select optimal accent color from enhanced palette
         */
        selectOptimalAccentColor(oklabResults) {
          const priorityKeys = [
            "VIBRANT",
            "PROMINENT",
            "DARK_VIBRANT",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorityKeys) {
            if (oklabResults[key]) {
              const result = oklabResults[key];
              return {
                accentHex: result.enhancedHex,
                accentRgb: `${result.enhancedRgb.r},${result.enhancedRgb.g},${result.enhancedRgb.b}`
              };
            }
          }
          const firstResult = Object.values(oklabResults)[0];
          if (firstResult) {
            return {
              accentHex: firstResult.enhancedHex,
              accentRgb: `${firstResult.enhancedRgb.r},${firstResult.enhancedRgb.g},${firstResult.enhancedRgb.b}`
            };
          }
          return {
            accentHex: "#cba6f7",
            // Catppuccin mauve
            accentRgb: "203,166,247"
          };
        }
        /**
         * Create fallback result when coordination fails
         */
        createFallbackResult(context, processingTime) {
          const fallbackPreset = OKLABColorProcessor.getPreset("STANDARD");
          return {
            enhancedColors: context.rawColors,
            accentHex: "#cba6f7",
            accentRgb: "203,166,247",
            oklabPreset: fallbackPreset,
            oklabResults: {},
            detectedGenre: "default",
            emotionalResult: {
              primaryEmotion: "calm",
              intensity: 0.5,
              temperature: 3500,
              blendRatio: 1,
              cssClass: "organic-emotion-calm",
              cssVariables: {},
              oklabPreset: fallbackPreset
            },
            genreCharacteristics: {
              vibrancyLevel: "standard",
              emotionalRange: "moderate",
              colorTemperature: "neutral"
            },
            processingTime,
            musicInfluenceStrength: 0.5,
            coordinationStrategy: "fallback",
            cssVariables: {
              "--sn-musical-oklab-coordination": "fallback",
              "--sn-oklab-preset-name": "STANDARD"
            }
          };
        }
        // Utility methods
        generateCacheKey(context) {
          return `${context.trackUri}-${context.timestamp}-${JSON.stringify(
            context.musicData
          )}`;
        }
        cacheResult(cacheKey, result) {
          if (this.coordinationCache.size >= this.cacheMaxSize) {
            const firstKey = this.coordinationCache.keys().next().value;
            if (firstKey) this.coordinationCache.delete(firstKey);
          }
          this.coordinationCache.set(cacheKey, result);
          setTimeout(() => {
            this.coordinationCache.delete(cacheKey);
          }, this.cacheTimeoutMs);
        }
        /**
         * Convert MusicalOKLABResult to ColorResult for integration with existing systems
         */
        convertToColorResult(musicalResult, context) {
          return {
            processedColors: {
              ...musicalResult.enhancedColors,
              ...musicalResult.cssVariables
            },
            accentHex: musicalResult.accentHex,
            accentRgb: musicalResult.accentRgb,
            metadata: {
              strategy: "musical-oklab-coordinator",
              processingTime: musicalResult.processingTime,
              detectedGenre: musicalResult.detectedGenre,
              emotionalState: musicalResult.emotionalResult.primaryEmotion,
              oklabPreset: musicalResult.oklabPreset.name,
              coordinationStrategy: musicalResult.coordinationStrategy,
              musicInfluenceStrength: musicalResult.musicInfluenceStrength
            },
            context: {
              rawColors: context.rawColors,
              trackUri: context.trackUri,
              timestamp: context.timestamp,
              harmonicMode: context.harmonicMode || "musical-oklab",
              musicData: context.musicData
            }
          };
        }
        /**
         * Clear coordination cache
         */
        clearCache() {
          this.coordinationCache.clear();
          if (this.enableDebug) {
            Y3KDebug?.debug?.log(
              "MusicalOKLABCoordinator",
              "Coordination cache cleared"
            );
          }
        }
        /**
         * Get coordination metrics for monitoring
         */
        getCoordinationMetrics() {
          return {
            cacheSize: this.coordinationCache.size,
            maxCacheSize: this.cacheMaxSize,
            cacheTimeoutMs: this.cacheTimeoutMs,
            enableDebug: this.enableDebug
          };
        }
      };
      __name(_MusicalOKLABCoordinator, "MusicalOKLABCoordinator");
      MusicalOKLABCoordinator = _MusicalOKLABCoordinator;
    }
  });

  // src-js/visual/strategies/BackgroundStrategyRegistry.ts
  var _BackgroundStrategyRegistry, BackgroundStrategyRegistry;
  var init_BackgroundStrategyRegistry = __esm({
    "src-js/visual/strategies/BackgroundStrategyRegistry.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _BackgroundStrategyRegistry = class _BackgroundStrategyRegistry {
        // 30 seconds
        constructor() {
          this.strategiesMap = /* @__PURE__ */ new Map();
          // Performance monitoring
          this.metrics = {
            totalStrategies: 0,
            healthyStrategies: 0,
            averageResponseTime: 0,
            totalUsageCount: 0,
            cacheHitRate: 0,
            memoryUsage: 0
          };
          // Health monitoring
          this.healthCheckInterval = null;
          this.HEALTH_CHECK_INTERVAL_MS = 3e4;
          this.startHealthMonitoring();
          Y3KDebug?.debug?.log(
            "BackgroundStrategyRegistry",
            "Strategy registry initialized"
          );
        }
        /**
         * Register a color processing strategy
         */
        register(strategy) {
          const strategyName = strategy.getStrategyName();
          if (this.strategiesMap.has(strategyName)) {
            Y3KDebug?.debug?.warn(
              "BackgroundStrategyRegistry",
              `Strategy ${strategyName} is already registered, replacing...`
            );
          }
          try {
            const registration = {
              strategy,
              registrationTime: Date.now(),
              lastUsed: 0,
              usageCount: 0,
              errorCount: 0,
              averageProcessingTime: 0,
              isHealthy: true,
              metadata: this.inferStrategyMetadata(strategy)
            };
            this.strategiesMap.set(strategyName, registration);
            this.updateMetrics();
            Y3KDebug?.debug?.log(
              "BackgroundStrategyRegistry",
              `Registered strategy: ${strategyName}`,
              {
                category: registration.metadata.category,
                priority: registration.metadata.priority,
                memoryImpact: registration.metadata.memoryImpact
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "BackgroundStrategyRegistry",
              `Failed to register strategy ${strategyName}:`,
              error
            );
          }
        }
        /**
         * Select best strategy for given criteria
         */
        selectStrategy(criteria) {
          const availableStrategies = Array.from(this.strategiesMap.values()).filter((reg) => reg.isHealthy).sort(
            (a, b) => this.scoreStrategy(b, criteria) - this.scoreStrategy(a, criteria)
          );
          if (availableStrategies.length === 0) {
            Y3KDebug?.debug?.warn(
              "BackgroundStrategyRegistry",
              "No healthy strategies available"
            );
            return null;
          }
          const selectedStrategy = availableStrategies[0];
          if (!selectedStrategy) {
            Y3KDebug?.debug?.warn(
              "BackgroundStrategyRegistry",
              "No strategies available after filtering"
            );
            return null;
          }
          this.recordStrategyUsage(selectedStrategy.strategy.getStrategyName());
          Y3KDebug?.debug?.log(
            "BackgroundStrategyRegistry",
            `Selected strategy: ${selectedStrategy.strategy.getStrategyName()}`,
            {
              score: this.scoreStrategy(selectedStrategy, criteria),
              totalAvailable: availableStrategies.length
            }
          );
          return selectedStrategy.strategy;
        }
        /**
         * Get all registered strategies
         */
        getStrategies() {
          return Array.from(this.strategiesMap.values()).filter((reg) => reg.isHealthy).map((reg) => reg.strategy);
        }
        /**
         * Get strategy by name
         */
        getStrategy(name) {
          const registration = this.strategiesMap.get(name);
          return registration && registration.isHealthy ? registration.strategy : null;
        }
        /**
         * Get multiple strategies by criteria with intelligent selection
         */
        selectMultipleStrategies(criteria, maxStrategies = 4) {
          const scoredStrategies = Array.from(this.strategiesMap.values()).filter((reg) => reg.isHealthy).map((reg) => ({
            registration: reg,
            score: this.scoreStrategy(reg, criteria)
          })).sort((a, b) => b.score - a.score).slice(0, maxStrategies);
          scoredStrategies.forEach((scored) => {
            this.recordStrategyUsage(scored.registration.strategy.getStrategyName());
          });
          const selectedStrategies = scoredStrategies.map(
            (scored) => scored.registration.strategy
          );
          Y3KDebug?.debug?.log(
            "BackgroundStrategyRegistry",
            `Selected ${selectedStrategies.length} strategies`,
            {
              strategies: selectedStrategies.map((s) => s.getStrategyName()),
              scores: scoredStrategies.map((s) => s.score)
            }
          );
          return selectedStrategies;
        }
        /**
         * Score a strategy based on selection criteria
         */
        scoreStrategy(registration, criteria) {
          let score = 0;
          score += registration.metadata.priority * 10;
          switch (criteria.performance) {
            case "high":
              if (registration.metadata.memoryImpact === "low") score += 20;
              if (registration.averageProcessingTime < 10) score += 15;
              break;
            case "medium":
              if (registration.metadata.memoryImpact !== "high") score += 10;
              if (registration.averageProcessingTime < 20) score += 10;
              break;
            case "low":
              break;
          }
          switch (criteria.quality) {
            case "premium":
              if (registration.metadata.category === "enhancement") score += 15;
              if (registration.metadata.tags.includes("webgl")) score += 10;
              break;
            case "enhanced":
              if (registration.metadata.category !== "effects") score += 10;
              break;
            case "basic":
              if (registration.metadata.category === "foundation") score += 15;
              break;
          }
          if (criteria.deviceCapabilities) {
            if (criteria.deviceCapabilities.hasWebGL && registration.metadata.tags.includes("webgl")) {
              score += 15;
            }
            if (criteria.deviceCapabilities.isMobile && registration.metadata.memoryImpact === "low") {
              score += 10;
            }
            if (criteria.deviceCapabilities.memoryMB && criteria.deviceCapabilities.memoryMB < 4e3) {
              if (registration.metadata.memoryImpact === "high") score -= 20;
            }
          }
          if (criteria.userPreferences) {
            if (criteria.userPreferences.enableAdvancedBlending && registration.metadata.tags.includes("advanced-blending")) {
              score += 12;
            }
            if (criteria.userPreferences.harmonicMode) {
              const mode = criteria.userPreferences.harmonicMode;
              if (registration.metadata.tags.includes(mode)) {
                score += 8;
              }
            }
          }
          const errorRate = registration.usageCount > 0 ? registration.errorCount / registration.usageCount : 0;
          score -= errorRate * 30;
          const timeSinceLastUse = Date.now() - registration.lastUsed;
          if (timeSinceLastUse < 3e5) {
            score += 5;
          }
          return Math.max(0, score);
        }
        /**
         * Infer strategy metadata from strategy instance
         */
        inferStrategyMetadata(strategy) {
          const strategyName = strategy.getStrategyName();
          const tags = [];
          let category = "enhancement";
          let priority = 5;
          let memoryImpact = "medium";
          let deviceRequirements = [];
          switch (strategyName) {
            case "dynamic-catppuccin":
              category = "accent";
              priority = 10;
              memoryImpact = "low";
              tags.push("catppuccin", "dynamic", "accent", "spicetify");
              break;
            case "living-gradient":
              category = "foundation";
              priority = 8;
              memoryImpact = "low";
              tags.push("gradient", "breathing", "foundation", "css");
              break;
            case "webgl-gradient":
              category = "enhancement";
              priority = 6;
              memoryImpact = "high";
              deviceRequirements.push("webgl");
              tags.push("webgl", "gradient", "performance", "advanced-blending");
              break;
            case "depth-layered":
              category = "effects";
              priority = 7;
              memoryImpact = "medium";
              tags.push(
                "depth",
                "layers",
                "parallax",
                "consciousness",
                "cosmic",
                "cinematic"
              );
              break;
            default:
              break;
          }
          return {
            category,
            priority,
            memoryImpact,
            deviceRequirements,
            tags
          };
        }
        /**
         * Record strategy usage for metrics
         */
        recordStrategyUsage(strategyName) {
          const registration = this.strategiesMap.get(strategyName);
          if (registration) {
            registration.usageCount++;
            registration.lastUsed = Date.now();
          }
        }
        /**
         * Record strategy error for health monitoring
         */
        recordStrategyError(strategyName, error) {
          const registration = this.strategiesMap.get(strategyName);
          if (registration) {
            registration.errorCount++;
            const errorRate = registration.errorCount / Math.max(1, registration.usageCount);
            if (errorRate > 0.5 && registration.usageCount > 5) {
              registration.isHealthy = false;
              Y3KDebug?.debug?.warn(
                "BackgroundStrategyRegistry",
                `Strategy ${strategyName} marked as unhealthy`,
                {
                  errorRate,
                  errorCount: registration.errorCount,
                  usageCount: registration.usageCount
                }
              );
            }
          }
        }
        /**
         * Record strategy processing time for performance tracking
         */
        recordStrategyProcessingTime(strategyName, processingTime) {
          const registration = this.strategiesMap.get(strategyName);
          if (registration) {
            const totalTime = registration.averageProcessingTime * (registration.usageCount - 1) + processingTime;
            registration.averageProcessingTime = totalTime / registration.usageCount;
          }
        }
        /**
         * Start health monitoring for all registered strategies
         */
        startHealthMonitoring() {
          this.healthCheckInterval = window.setInterval(() => {
            this.performHealthChecks();
          }, this.HEALTH_CHECK_INTERVAL_MS);
        }
        /**
         * Perform health checks on all registered strategies
         */
        async performHealthChecks() {
          try {
            for (const [name, registration] of this.strategiesMap.entries()) {
              try {
                if ("healthCheck" in registration.strategy && typeof registration.strategy.healthCheck === "function") {
                  const healthResult = await registration.strategy.healthCheck();
                  registration.isHealthy = healthResult?.healthy ?? true;
                  if (!registration.isHealthy) {
                    Y3KDebug?.debug?.warn(
                      "BackgroundStrategyRegistry",
                      `Strategy ${name} failed health check:`,
                      healthResult
                    );
                  }
                }
              } catch (error) {
                registration.isHealthy = false;
                Y3KDebug?.debug?.error(
                  "BackgroundStrategyRegistry",
                  `Health check failed for strategy ${name}:`,
                  error
                );
              }
            }
            this.updateMetrics();
          } catch (error) {
            Y3KDebug?.debug?.error(
              "BackgroundStrategyRegistry",
              "Health check monitoring failed:",
              error
            );
          }
        }
        /**
         * Update registry metrics
         */
        updateMetrics() {
          const registrations = Array.from(this.strategiesMap.values());
          this.metrics.totalStrategies = registrations.length;
          this.metrics.healthyStrategies = registrations.filter(
            (r) => r.isHealthy
          ).length;
          this.metrics.totalUsageCount = registrations.reduce(
            (sum, r) => sum + r.usageCount,
            0
          );
          const processingTimes = registrations.filter((r) => r.averageProcessingTime > 0).map((r) => r.averageProcessingTime);
          if (processingTimes.length > 0) {
            this.metrics.averageResponseTime = processingTimes.reduce((a, b) => a + b, 0) / processingTimes.length;
          }
          this.metrics.memoryUsage = registrations.reduce((sum, r) => {
            const impact = r.metadata.memoryImpact === "high" ? 3 : r.metadata.memoryImpact === "medium" ? 2 : 1;
            return sum + impact;
          }, 0);
        }
        /**
         * Get registry metrics for monitoring
         */
        getRegistryMetrics() {
          return { ...this.metrics };
        }
        /**
         * Get detailed strategy information
         */
        getStrategyInfo(strategyName) {
          const registration = this.strategiesMap.get(strategyName);
          return registration ? { ...registration } : null;
        }
        /**
         * Get all strategy information for debugging
         */
        getAllStrategyInfo() {
          return Array.from(this.strategiesMap.entries()).map(
            ([name, registration]) => ({
              name,
              registration: { ...registration }
            })
          );
        }
        /**
         * Unregister a strategy
         */
        unregister(strategyName) {
          const success = this.strategiesMap.delete(strategyName);
          if (success) {
            this.updateMetrics();
            Y3KDebug?.debug?.log(
              "BackgroundStrategyRegistry",
              `Unregistered strategy: ${strategyName}`
            );
          }
          return success;
        }
        /**
         * Clear all strategies
         */
        clear() {
          this.strategiesMap.clear();
          this.updateMetrics();
          Y3KDebug?.debug?.log(
            "BackgroundStrategyRegistry",
            "All strategies cleared from registry"
          );
        }
        /**
         * Cleanup resources
         */
        destroy() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          for (const [name, registration] of this.strategiesMap.entries()) {
            if ("destroy" in registration.strategy && typeof registration.strategy.destroy === "function") {
              try {
                registration.strategy.destroy();
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "BackgroundStrategyRegistry",
                  `Error destroying strategy ${name}:`,
                  error
                );
              }
            }
          }
          this.clear();
          Y3KDebug?.debug?.log(
            "BackgroundStrategyRegistry",
            "Strategy registry destroyed"
          );
        }
      };
      __name(_BackgroundStrategyRegistry, "BackgroundStrategyRegistry");
      BackgroundStrategyRegistry = _BackgroundStrategyRegistry;
    }
  });

  // src-js/core/color/UnifiedColorProcessingEngine.ts
  var _UnifiedColorProcessingEngine, UnifiedColorProcessingEngine, getSharedDependencies, settingsManager, performanceAnalyzer, globalUnifiedColorProcessingEngine;
  var init_UnifiedColorProcessingEngine = __esm({
    "src-js/core/color/UnifiedColorProcessingEngine.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_MusicalOKLABCoordinator();
      init_OKLABColorProcessor();
      init_BackgroundStrategyRegistry();
      init_BackgroundStrategySelector();
      _UnifiedColorProcessingEngine = class _UnifiedColorProcessingEngine {
        // 30 seconds
        constructor(settingsManager2, performanceAnalyzer2) {
          this.initialized = false;
          // === STATE MANAGEMENT ===
          this.processingState = {
            isProcessing: false,
            currentTrackUri: null,
            lastExtractedColors: null,
            lastProcessedResult: null,
            lastProcessingTime: 0,
            processingQueue: [],
            queueSize: 0
          };
          this.metrics = {
            totalExtractions: 0,
            totalProcessed: 0,
            totalApplied: 0,
            averageProcessingTime: 0,
            successRate: 0,
            errorCount: 0,
            lastProcessingTime: 0,
            oklabCoordinations: 0,
            strategySelections: 0,
            cacheHits: 0
          };
          // === PERFORMANCE OPTIMIZATION ===
          this.processingTimeout = null;
          this.PROCESSING_TIMEOUT_MS = 1e4;
          // 10 seconds
          this.MAX_QUEUE_SIZE = 10;
          this.processingCache = /* @__PURE__ */ new Map();
          this.CACHE_TTL_MS = 3e4;
          this.settingsManager = settingsManager2 || new SettingsManager();
          this.performanceAnalyzer = performanceAnalyzer2 || null;
          this.deviceCapabilityDetector = new DeviceCapabilityDetector();
          this.strategyRegistry = new BackgroundStrategyRegistry();
          this.strategySelector = new BackgroundStrategySelector();
          this.oklabProcessor = new OKLABColorProcessor();
          this.musicalOKLABCoordinator = new MusicalOKLABCoordinator(true);
        }
        async initialize() {
          if (this.initialized) return;
          try {
            await this.deviceCapabilityDetector.initialize();
            this.setupEventSubscriptions();
            this.registerDefaultStrategies();
            this.initialized = true;
            Y3KDebug?.debug?.log(
              "UnifiedColorProcessingEngine",
              "\u{1F3A8} Unified color processing engine initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedColorProcessingEngine",
              "Failed to initialize:",
              error
            );
            throw error;
          }
        }
        async healthCheck() {
          const issues = [];
          if (!this.initialized) {
            issues.push("Engine not initialized");
          }
          if (this.processingState.isProcessing && Date.now() - this.processingState.lastProcessingTime > this.PROCESSING_TIMEOUT_MS) {
            issues.push("Processing appears stuck");
          }
          if (this.metrics.errorCount > 0 && this.metrics.successRate < 0.8) {
            issues.push(
              `Low success rate: ${(this.metrics.successRate * 100).toFixed(1)}%`
            );
          }
          if (this.processingState.queueSize > this.MAX_QUEUE_SIZE) {
            issues.push(`Queue overflow: ${this.processingState.queueSize} items`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Unified color processing - ${this.metrics.totalProcessed} processed, ${this.metrics.successRate.toFixed(2)} success rate`,
            issues,
            system: "UnifiedColorProcessingEngine"
          };
        }
        updateAnimation(deltaTime) {
          if (this.processingCache.size > 50) {
            this.cleanupCache();
          }
        }
        destroy() {
          if (this.processingTimeout) {
            clearTimeout(this.processingTimeout);
            this.processingTimeout = null;
          }
          this.processingState.processingQueue = [];
          this.processingCache.clear();
          unifiedEventBus.unsubscribeAll("UnifiedColorProcessingEngine");
          this.initialized = false;
        }
        // ============================================================================
        // Event Subscription Setup
        // ============================================================================
        setupEventSubscriptions() {
          unifiedEventBus.subscribe(
            "colors:extracted",
            (data) => {
              this.handleColorExtraction(data);
            },
            "UnifiedColorProcessingEngine"
          );
          unifiedEventBus.subscribe(
            "settings:changed",
            (data) => {
              this.handleSettingsChange(data);
            },
            "UnifiedColorProcessingEngine"
          );
        }
        // ============================================================================
        // Main Processing Pipeline
        // ============================================================================
        /**
         *  PHASE 3: Main color processing entry point
         * Consolidates processing logic from all three orchestrators
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const cacheKey = this.generateCacheKey(context);
            const cached = this.getCachedResult(cacheKey);
            if (cached) {
              this.metrics.cacheHits++;
              return cached;
            }
            const strategy = await this.selectOptimalStrategy(context);
            this.metrics.strategySelections++;
            const result = await this.processWithOKLAB(context, strategy);
            const processingTime = performance.now() - startTime;
            this.updateMetrics(processingTime, true);
            const unifiedResult = {
              ...result,
              processingTime,
              strategy,
              success: true,
              timestamp: Date.now(),
              coordinationMetrics: {
                detectedGenre: context.musicData?.genre || "unknown",
                emotionalState: context.musicData?.energy ? this.classifyEmotionalState(context.musicData.energy) : "neutral",
                oklabPreset: this.determineOKLABPreset(context),
                coordinationStrategy: strategy.getStrategyName(),
                musicInfluenceStrength: context.musicData?.energy || 0.5
              }
            };
            this.cacheResult(cacheKey, unifiedResult);
            unifiedEventBus.emit("colors:harmonized", {
              processedColors: result.processedColors,
              accentHex: result.accentHex || "#cba6f7",
              accentRgb: result.accentRgb || "203,166,247",
              strategies: [strategy.getStrategyName()],
              coordinationMetrics: unifiedResult.coordinationMetrics,
              oklabData: unifiedResult.oklabData,
              processingTime,
              timestamp: Date.now()
            });
            return unifiedResult;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            this.updateMetrics(processingTime, false);
            Y3KDebug?.debug?.error(
              "UnifiedColorProcessingEngine",
              "Processing failed:",
              error
            );
            return this.createFallbackResult(context, error);
          }
        }
        /**
         *  PHASE 3: Handle color extraction events - IColorOrchestrator interface
         * Accepts both ColorContext and UnifiedEventBus data formats
         */
        async handleColorExtraction(contextOrData) {
          if ("rawColors" in contextOrData && "trackUri" in contextOrData) {
            return this.processColorContext(contextOrData);
          }
          return this.handleColorExtractionEvent(contextOrData);
        }
        /**
         * Process ColorContext directly (IColorOrchestrator interface)
         */
        async processColorContext(context) {
          this.metrics.totalExtractions++;
          try {
            if (this.processingState.isProcessing) {
              this.addToQueue(context);
              return;
            }
            await this.processWithTimeout(context);
          } catch (error) {
            this.metrics.errorCount++;
            Y3KDebug?.debug?.error(
              "UnifiedColorProcessingEngine",
              "Color context processing failed:",
              error
            );
          }
        }
        /**
         * Handle UnifiedEventBus format events
         */
        async handleColorExtractionEvent(data) {
          this.metrics.totalExtractions++;
          try {
            const context = {
              rawColors: data.rawColors,
              trackUri: data.trackUri,
              musicData: data.musicData,
              timestamp: data.timestamp || Date.now()
            };
            if (this.processingState.isProcessing) {
              this.addToQueue(context);
              return;
            }
            await this.processWithTimeout(context);
          } catch (error) {
            this.metrics.errorCount++;
            Y3KDebug?.debug?.error(
              "UnifiedColorProcessingEngine",
              "Color extraction handling failed:",
              error
            );
          }
        }
        /**
         *  PHASE 3: Process context with OKLAB coordination
         * Consolidates OKLAB processing from ColorHarmonyEngine
         */
        async processWithOKLAB(context, strategy) {
          const musicalContext = {
            rawColors: context.rawColors,
            musicData: context.musicData,
            // Type compatibility
            trackUri: context.trackUri,
            timestamp: context.timestamp
          };
          const oklabResult = await this.musicalOKLABCoordinator.coordinateMusicalColors(
            musicalContext
          );
          this.metrics.oklabCoordinations++;
          const strategyResult = await strategy.processColors(context);
          const enhancedColors = await this.enhanceWithOKLAB(
            strategyResult.processedColors,
            oklabResult
          );
          return {
            ...strategyResult,
            processedColors: enhancedColors,
            metadata: {
              ...strategyResult.metadata,
              oklabPreset: this.determineOKLABPreset(context),
              oklabCoordination: oklabResult
            }
          };
        }
        /**
         *  PHASE 3: Strategy selection consolidating all orchestrator logic
         */
        async selectOptimalStrategy(context) {
          try {
            const capabilities = this.deviceCapabilityDetector.getCapabilities();
            const backgroundCriteria = {
              performance: "medium",
              quality: "enhanced",
              deviceCapabilities: {
                hasWebGL: capabilities?.gpu?.supportsWebGL || true,
                memoryMB: capabilities?.memory?.total || 4096,
                isMobile: false
              },
              userPreferences: {
                harmonicMode: "cosmic",
                intensity: 0.8,
                enableAdvancedBlending: true
              },
              // BackgroundStrategySelector-specific properties
              settingsContext: {
                dynamicAccentEnabled: true,
                gradientIntensity: "medium",
                webglEnabled: capabilities?.gpu?.supportsWebGL || true,
                webglForceEnabled: false,
                // Default to false in unified engine
                visualGuideMode: "enhanced",
                depthLayersEnabled: true,
                consciousnessLevel: 0.8,
                breathingAnimationEnabled: true
              },
              deviceContext: {
                supportsWebGL: capabilities?.gpu?.supportsWebGL || true,
                performanceLevel: "medium",
                memoryCapacity: capabilities?.memory?.total || 4096,
                isMobile: false
              }
            };
            const strategies = this.strategySelector.selectStrategies(
              context,
              backgroundCriteria
            );
            if (strategies && strategies.length > 0 && strategies[0]) {
              return strategies[0];
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "UnifiedColorProcessingEngine",
              "Strategy selection failed, using fallback:",
              error
            );
          }
          const fallbackStrategy = {
            getStrategyName: /* @__PURE__ */ __name(() => "fallback", "getStrategyName"),
            canProcess: /* @__PURE__ */ __name((ctx) => true, "canProcess"),
            getEstimatedProcessingTime: /* @__PURE__ */ __name((ctx) => 50, "getEstimatedProcessingTime"),
            // 50ms estimate
            processColors: /* @__PURE__ */ __name(async (ctx) => ({
              processedColors: ctx.rawColors,
              accentHex: "#cba6f7",
              accentRgb: "203,166,247",
              context: ctx,
              metadata: {
                strategy: "fallback",
                timestamp: Date.now(),
                processingTime: 0
              }
            }), "processColors")
          };
          return fallbackStrategy;
        }
        // ============================================================================
        // Queue Management (from orchestrators)
        // ============================================================================
        addToQueue(context) {
          if (this.processingState.queueSize >= this.MAX_QUEUE_SIZE) {
            this.processingState.processingQueue.shift();
          }
          this.processingState.processingQueue.push(context);
          this.processingState.queueSize = this.processingState.processingQueue.length;
        }
        async processQueue() {
          while (this.processingState.processingQueue.length > 0 && !this.processingState.isProcessing) {
            const context = this.processingState.processingQueue.shift();
            this.processingState.queueSize = this.processingState.processingQueue.length;
            await this.processWithTimeout(context);
          }
        }
        async processWithTimeout(context) {
          this.processingState.isProcessing = true;
          this.processingState.lastProcessingTime = Date.now();
          this.processingTimeout = window.setTimeout(() => {
            Y3KDebug?.debug?.warn(
              "UnifiedColorProcessingEngine",
              "Processing timeout - forcing reset"
            );
            this.processingState.isProcessing = false;
            this.metrics.errorCount++;
          }, this.PROCESSING_TIMEOUT_MS);
          try {
            await this.processColors(context);
            this.metrics.totalProcessed++;
          } finally {
            if (this.processingTimeout) {
              clearTimeout(this.processingTimeout);
              this.processingTimeout = null;
            }
            this.processingState.isProcessing = false;
            if (this.processingState.processingQueue.length > 0) {
              setTimeout(() => this.processQueue(), 0);
            }
          }
        }
        // ============================================================================
        // Performance Optimization
        // ============================================================================
        generateCacheKey(context) {
          const keyData = {
            colors: Object.keys(context.rawColors).sort().join(","),
            music: context.musicData?.energy || 0
          };
          return JSON.stringify(keyData);
        }
        getCachedResult(key) {
          const cached = this.processingCache.get(key);
          if (cached && Date.now() - cached.timestamp < this.CACHE_TTL_MS) {
            return cached;
          }
          return null;
        }
        cacheResult(key, result) {
          this.processingCache.set(key, { ...result, timestamp: Date.now() });
        }
        cleanupCache() {
          const now = Date.now();
          for (const [key, result] of this.processingCache.entries()) {
            if (now - result.timestamp > this.CACHE_TTL_MS) {
              this.processingCache.delete(key);
            }
          }
        }
        updateMetrics(processingTime, success) {
          this.metrics.averageProcessingTime = (this.metrics.averageProcessingTime * this.metrics.totalProcessed + processingTime) / (this.metrics.totalProcessed + 1);
          if (success) {
            this.metrics.successRate = (this.metrics.successRate * this.metrics.totalProcessed + 1) / (this.metrics.totalProcessed + 1);
          } else {
            this.metrics.successRate = this.metrics.successRate * this.metrics.totalProcessed / (this.metrics.totalProcessed + 1);
          }
          this.metrics.lastProcessingTime = Date.now();
        }
        // ============================================================================
        // Utility Methods
        // ============================================================================
        async enhanceWithOKLAB(colors, oklabResult) {
          const enhanced = { ...colors };
          if (oklabResult.enhancedColors) {
            Object.entries(oklabResult.enhancedColors).forEach(([key, value]) => {
              enhanced[`oklab-${key}`] = value;
            });
          }
          return enhanced;
        }
        classifyEmotionalState(energy) {
          if (energy > 0.8) return "energetic";
          if (energy > 0.6) return "upbeat";
          if (energy > 0.4) return "moderate";
          if (energy > 0.2) return "calm";
          return "peaceful";
        }
        determineOKLABPreset(context) {
          const energy = context.musicData?.energy || 0.5;
          if (energy > 0.8) return "high-energy";
          if (energy > 0.6) return "dynamic";
          if (energy > 0.4) return "balanced";
          return "ambient";
        }
        createFallbackResult(context, error) {
          return {
            processedColors: {
              fallback: "#cba6f7"
              // Default Catppuccin mauve
            },
            accentHex: "#cba6f7",
            accentRgb: "203,166,247",
            context,
            // Required by ColorResult interface
            metadata: {
              strategy: "fallback",
              error: error.message,
              timestamp: Date.now(),
              processingTime: 0
            }
          };
        }
        registerDefaultStrategies() {
        }
        async handleSettingsChange(data) {
          if ([
            "catppuccin-flavor",
            "catppuccin-accentColor",
            "sn-dynamic-color-intensity"
          ].includes(data.settingKey)) {
            this.processingCache.clear();
            Y3KDebug?.debug?.log(
              "UnifiedColorProcessingEngine",
              "Cache cleared due to settings change:",
              data.settingKey
            );
          }
        }
        async handlePerformanceWarning(data) {
          if (data.memoryUsage > 50) {
            this.processingCache.clear();
            Y3KDebug?.debug?.log(
              "UnifiedColorProcessingEngine",
              "Cache cleared due to memory pressure"
            );
          }
        }
        // ============================================================================
        // Public API (Backward Compatibility)
        // ============================================================================
        /**
         * Get processing metrics for debugging and monitoring
         */
        getMetrics() {
          return { ...this.metrics };
        }
        /**
         * Force reprocess current colors (compatibility method)
         */
        async forceReprocessColors() {
          this.processingCache.clear();
          if (this.processingState.lastExtractedColors) {
            const context = {
              rawColors: this.processingState.lastExtractedColors,
              trackUri: this.processingState.currentTrackUri || "",
              timestamp: Date.now()
            };
            await this.processColors(context);
          }
        }
        /**
         * Get current processing state (debugging)
         */
        getProcessingState() {
          return { ...this.processingState };
        }
        // ============================================================================
        // IColorOrchestrator Interface Implementation
        // ============================================================================
        /**
         * Get current processing status (IColorOrchestrator interface)
         */
        getStatus() {
          return {
            isProcessing: this.processingState.isProcessing,
            queueSize: this.processingState.queueSize
          };
        }
        /**
         * Set strategy selection criteria (IColorOrchestrator interface)
         */
        setSelectionCriteria(criteria) {
          Y3KDebug?.debug?.log(
            "UnifiedColorProcessingEngine",
            "Strategy selection criteria updated:",
            criteria
          );
        }
      };
      __name(_UnifiedColorProcessingEngine, "UnifiedColorProcessingEngine");
      UnifiedColorProcessingEngine = _UnifiedColorProcessingEngine;
      getSharedDependencies = /* @__PURE__ */ __name(() => {
        const globalSystem = globalThis.year3000System;
        return {
          settingsManager: globalSystem?.settingsManager,
          performanceAnalyzer: globalSystem?.performanceAnalyzer || globalSystem?.facadeCoordinator?.getCachedNonVisualSystem?.("PerformanceAnalyzer")
        };
      }, "getSharedDependencies");
      ({ settingsManager, performanceAnalyzer } = getSharedDependencies());
      globalUnifiedColorProcessingEngine = new UnifiedColorProcessingEngine(settingsManager, performanceAnalyzer);
    }
  });

  // src-js/ui/managers/Card3DManager.ts
  var _Card3DManager, Card3DManager;
  var init_Card3DManager = __esm({
    "src-js/ui/managers/Card3DManager.ts"() {
      "use strict";
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      init_UnifiedEventBus();
      _Card3DManager = class _Card3DManager {
        constructor(performanceMonitor, settingsManager2, utils) {
          this.initialized = false;
          this.cardQuerySelector = ".main-card-card, .main-gridContainer-gridContainer.main-gridContainer-fixedWidth";
          this.cardEventHandlers = /* @__PURE__ */ new WeakMap();
          // Year 3000 consciousness integration
          this.musicSyncService = null;
          // Quality scaling state
          this.currentQualityLevel = null;
          this.qualityCapabilities = [];
          // Cross-system consciousness coordination
          this.consciousnessCoordinationCallbacks = /* @__PURE__ */ new Set();
          this.config = {
            perspective: 1e3,
            maxRotation: 5,
            scale: 1.02,
            transitionSpeed: "200ms",
            glowOpacity: 0.8,
            selector: ".main-card-card, .main-grid-grid > *, .main-shelf-shelf > * > *",
            // Year 3000 consciousness enhancements
            consciousnessDepthMultiplier: 1.5,
            emotionalResponseStrength: 0.8,
            beatSyncIntensity: 0.6,
            cinematicDramaMultiplier: 1.2
          };
          this.performanceMonitor = performanceMonitor;
          this.settingsManager = settingsManager2;
          this.utils = utils;
          this.cards = document.querySelectorAll(this.config.selector);
          this.emotionalMapper = new EmotionalTemperatureMapper(true);
          this.oklabProcessor = new OKLABColorProcessor(true);
          this.cinematicPreset = OKLABColorProcessor.getPreset("VIBRANT");
          this.consciousnessState = {
            currentEmotion: "neutral",
            emotionalIntensity: 0.5,
            beatPhase: 0,
            lastBeatTime: 0,
            cinematicDramaLevel: 0,
            dynamicAccentHex: "#cba6f7",
            // Catppuccin mauve fallback
            dynamicAccentRgb: "203,166,247",
            consciousnessLevel: 0.5
          };
          this.boundHandleSettingsChange = this.handleSettingsChange.bind(this);
        }
        static getInstance(performanceMonitor, settingsManager2, utils) {
          if (!_Card3DManager.instance) {
            _Card3DManager.instance = new _Card3DManager(
              performanceMonitor,
              settingsManager2,
              utils
            );
          }
          return _Card3DManager.instance;
        }
        async initialize() {
          if (this.initialized) return;
          const quality = this.performanceMonitor.shouldReduceQuality();
          if (quality) {
            if (false) {
              console.log(
                `[Card3DManager] Performance is low. 3D effects disabled. Current quality: ${quality}`
              );
              return;
            }
          }
          this.cards = document.querySelectorAll(this.config.selector);
          await this.applyEventListeners();
          await this.initializeConsciousnessIntegration();
          this.initializeCrossSystemCoordination();
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this.boundHandleSettingsChange
          );
          this.initialized = true;
        }
        async healthCheck() {
          const elements = document.querySelectorAll(this.cardQuerySelector);
          if (elements.length > 0) {
            return {
              healthy: true,
              ok: true,
              details: `Found ${elements.length} cards to manage.`,
              issues: [],
              system: "Card3DManager"
            };
          }
          return {
            healthy: false,
            ok: false,
            details: "No card elements found with the configured selector.",
            issues: ["No card elements found with the configured selector."],
            system: "Card3DManager"
          };
        }
        updateAnimation(deltaTime) {
        }
        apply3DMode(mode) {
          console.log(`[Card3DManager] Applying 3D mode: ${mode}`);
          if (mode === "disabled") {
            this.destroy();
          } else {
            this.initialize();
          }
        }
        get shouldEnable3DEffects() {
          const quality = this.performanceMonitor.shouldReduceQuality();
          const setting = this.settingsManager.get("sn-enable3dCards");
          return !quality && setting !== "disabled";
        }
        async applyEventListeners() {
          this.cards.forEach((card) => {
            if (this.cardEventHandlers.has(card)) return;
            const moveHandler = /* @__PURE__ */ __name((e) => this.handleMouseMove(card, e), "moveHandler");
            const leaveHandler = /* @__PURE__ */ __name(() => this.handleMouseLeave(card), "leaveHandler");
            this.cardEventHandlers.set(card, {
              move: moveHandler,
              leave: leaveHandler
            });
            card.addEventListener("mousemove", moveHandler);
            card.addEventListener("mouseleave", leaveHandler);
          });
        }
        handleMouseMove(card, e) {
          if (!this.shouldEnable3DEffects) return;
          const { clientX, clientY } = e;
          const { top, left, width, height } = card.getBoundingClientRect();
          const x = clientX - left;
          const y = clientY - top;
          const rotateX = this.config.maxRotation * (y - height / 2) / (height / 2);
          const rotateY = -this.config.maxRotation * (x - width / 2) / (width / 2);
          card.style.transform = `perspective(${this.config.perspective}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale3d(${this.config.scale}, ${this.config.scale}, ${this.config.scale})`;
          card.style.transition = `transform ${this.config.transitionSpeed} ease-out`;
          this.applyGlow(card, x, y, width, height);
        }
        handleMouseLeave(card) {
          card.style.transform = "perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)";
          card.style.transition = "transform 600ms ease-in-out";
          this.removeGlow(card);
        }
        applyGlow(card, x, y, width, height) {
          let glowElement = card.querySelector(".card-glow");
          if (!glowElement) {
            glowElement = document.createElement("div");
            glowElement.className = "card-glow";
            card.appendChild(glowElement);
          }
          const { dynamicAccentRgb, emotionalIntensity, beatPhase, cinematicDramaLevel } = this.consciousnessState;
          const baseOpacity = this.config.glowOpacity;
          const emotionalModulation = 1 + (emotionalIntensity - 0.5) * this.config.emotionalResponseStrength;
          const beatModulation = 1 + Math.sin(beatPhase) * this.config.beatSyncIntensity * 0.3;
          const cinematicModulation = 1 + cinematicDramaLevel * this.config.cinematicDramaMultiplier * 0.4;
          const consciousnessOpacity = baseOpacity * emotionalModulation * beatModulation * cinematicModulation;
          const finalOpacity = Math.max(0.1, Math.min(1, consciousnessOpacity));
          const baseRadius = 40;
          const breathingRadius = baseRadius + Math.sin(beatPhase * 0.5) * 8 * this.config.beatSyncIntensity;
          glowElement.style.background = `radial-gradient(circle at ${x}px ${y}px, 
      rgba(${dynamicAccentRgb}, ${finalOpacity}) 0%, 
      rgba(${dynamicAccentRgb}, ${finalOpacity * 0.6}) 20%, 
      transparent ${breathingRadius}%)`;
        }
        removeGlow(card) {
          const glowElement = card.querySelector(".card-glow");
          if (glowElement) {
            glowElement.style.background = "transparent";
          }
        }
        destroy() {
          this.cards.forEach((card) => {
            const handlers = this.cardEventHandlers.get(card);
            if (handlers) {
              card.removeEventListener("mousemove", handlers.move);
              card.removeEventListener("mouseleave", handlers.leave);
              this.cardEventHandlers.delete(card);
            }
            this.removeGlow(card);
            card.style.transform = "";
            card.style.transition = "";
          });
          this.initialized = false;
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this.boundHandleSettingsChange
          );
        }
        handleSettingsChange(event) {
          const { key, value } = event.detail || {};
          if (false) {
            this.apply3DMode(value);
          }
        }
        // ===================================================================
        // Year 3000 Consciousness Integration Methods
        // ===================================================================
        /**
         * Initialize consciousness integration with music sync and emotional systems
         */
        async initializeConsciousnessIntegration() {
          try {
            unifiedEventBus.subscribe("colors:extracted", (event) => {
              this.onColorsExtracted(event);
            }, "Card3DManager");
            unifiedEventBus.subscribe("colors:harmonized", (event) => {
              this.onColorsHarmonized(event);
            }, "Card3DManager");
            unifiedEventBus.subscribe("music:beat", (event) => {
              this.onMusicBeat(event);
            }, "Card3DManager");
            unifiedEventBus.subscribe("consciousness:dramatic-moment", (event) => {
              this.onCinematicDramaEvent(event);
            }, "Card3DManager");
            this.updateDynamicAccentColor();
            console.log("[Card3DManager] \u2705 Year 3000 consciousness integration initialized");
          } catch (error) {
            console.error("[Card3DManager] Failed to initialize consciousness integration:", error);
          }
        }
        /**
         * Handle color extraction events
         */
        onColorsExtracted(event) {
          const { rawColors, musicData } = event;
          if (musicData) {
            const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
            this.updateEmotionalState(emotionalResult);
          }
        }
        /**
         * Handle color harmonization events
         */
        onColorsHarmonized(event) {
          const { processedColors, coordinationMetrics } = event;
          if (processedColors.VIBRANT) {
            const oklabResult = this.oklabProcessor.processColor(processedColors.VIBRANT, this.cinematicPreset);
            this.consciousnessState.dynamicAccentHex = oklabResult.enhancedHex;
            this.consciousnessState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
          }
          if (coordinationMetrics?.consciousnessLevel !== void 0) {
            this.consciousnessState.consciousnessLevel = coordinationMetrics.consciousnessLevel;
          }
        }
        /**
         * Handle music beat events for rhythm-responsive 3D effects
         */
        onMusicBeat(event) {
          const { beat, intensity, timestamp } = event;
          this.consciousnessState.beatPhase += Math.PI * 2 * this.config.beatSyncIntensity;
          this.consciousnessState.lastBeatTime = timestamp || Date.now();
          if (intensity > 0.7) {
            this.applyBeatSyncDepthPulse(intensity);
          }
        }
        /**
         * Handle cinematic drama events for intense 3D effects
         */
        onCinematicDramaEvent(event) {
          const { intensity, type } = event;
          this.consciousnessState.cinematicDramaLevel = intensity;
          if (intensity > 0.8) {
            this.applyDramaticDepthDistortion(intensity);
          }
        }
        /**
         * Update emotional state from music analysis
         */
        updateEmotionalState(emotionalResult) {
          this.consciousnessState.currentEmotion = emotionalResult.primaryEmotion;
          this.consciousnessState.emotionalIntensity = emotionalResult.intensity;
          switch (emotionalResult.primaryEmotion) {
            case "energetic":
            case "aggressive":
              this.cinematicPreset = OKLABColorProcessor.getPreset("COSMIC");
              break;
            case "calm":
            case "ambient":
              this.cinematicPreset = OKLABColorProcessor.getPreset("SUBTLE");
              break;
            default:
              this.cinematicPreset = OKLABColorProcessor.getPreset("VIBRANT");
          }
        }
        /**
         * Apply beat-synchronized depth pulse to all cards
         */
        applyBeatSyncDepthPulse(intensity) {
          const pulseScale = 1 + intensity * 0.15 * this.config.beatSyncIntensity;
          this.cards.forEach((card) => {
            if (card instanceof HTMLElement) {
              const currentTransform = card.style.transform || "";
              const scaledTransform = currentTransform.replace(/scale3d\([^)]*\)/, `scale3d(${pulseScale}, ${pulseScale}, ${pulseScale})`);
              card.style.transform = scaledTransform || `scale3d(${pulseScale}, ${pulseScale}, ${pulseScale})`;
              card.style.transition = "transform 100ms ease-out";
              setTimeout(() => {
                if (card.style.transform.includes(`scale3d(${pulseScale}`)) {
                  card.style.transform = card.style.transform.replace(/scale3d\([^)]*\)/, "scale3d(1, 1, 1)");
                }
              }, 200);
            }
          });
        }
        /**
         * Apply dramatic depth distortion for cinematic moments
         */
        applyDramaticDepthDistortion(intensity) {
          const dramaticPerspective = this.config.perspective * (1 + intensity * this.config.cinematicDramaMultiplier);
          const dramaticRotation = this.config.maxRotation * (1 + intensity * 0.8);
          this.cards.forEach((card) => {
            if (card instanceof HTMLElement) {
              const dramaticTransform = `perspective(${dramaticPerspective}px) rotateX(${dramaticRotation * 0.3}deg) rotateY(${dramaticRotation * 0.2}deg)`;
              card.style.transform = dramaticTransform;
              card.style.transition = "transform 800ms ease-out";
              setTimeout(() => {
                card.style.transform = "perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)";
                card.style.transition = "transform 1200ms ease-in-out";
              }, 1500);
            }
          });
        }
        /**
         * Update dynamic accent color from CSS variables
         */
        updateDynamicAccentColor() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const dynamicAccentHex = computedStyle.getPropertyValue("--sn-dynamic-accent-hex").trim() || computedStyle.getPropertyValue("--sn-color-accent-hex").trim() || computedStyle.getPropertyValue("--spice-accent").trim();
          const dynamicAccentRgb = computedStyle.getPropertyValue("--sn-dynamic-accent-rgb").trim() || computedStyle.getPropertyValue("--sn-color-accent-rgb").trim() || computedStyle.getPropertyValue("--spice-rgb-accent").trim();
          if (dynamicAccentHex && dynamicAccentHex !== "") {
            this.consciousnessState.dynamicAccentHex = dynamicAccentHex;
          }
          if (dynamicAccentRgb && dynamicAccentRgb !== "") {
            this.consciousnessState.dynamicAccentRgb = dynamicAccentRgb;
          }
        }
        /**
         * Set music sync service for consciousness integration
         */
        setMusicSyncService(musicSyncService) {
          this.musicSyncService = musicSyncService;
        }
        /**
         * Get current consciousness state for debugging
         */
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        // ===================================================================
        // Quality Scaling Implementation (QualityScalingCapable)
        // ===================================================================
        /**
         * Set quality level for 3D effects
         */
        setQualityLevel(level) {
          this.currentQualityLevel = level;
          switch (level) {
            case "low":
              this.config.perspective = 900;
              this.config.maxRotation = 3;
              this.config.consciousnessDepthMultiplier = 1.2;
              this.config.emotionalResponseStrength = 0.5;
              this.config.beatSyncIntensity = 0.4;
              this.config.cinematicDramaMultiplier = 0.8;
              break;
            case "medium":
              this.config.perspective = 1e3;
              this.config.maxRotation = 5;
              this.config.consciousnessDepthMultiplier = 1.5;
              this.config.emotionalResponseStrength = 0.8;
              this.config.beatSyncIntensity = 0.6;
              this.config.cinematicDramaMultiplier = 1.2;
              break;
            case "high":
              this.config.perspective = 1200;
              this.config.maxRotation = 7;
              this.config.consciousnessDepthMultiplier = 1.8;
              this.config.emotionalResponseStrength = 1;
              this.config.beatSyncIntensity = 0.8;
              this.config.cinematicDramaMultiplier = 1.5;
              break;
            default:
              this.config.perspective = 1e3;
              this.config.maxRotation = 5;
              this.config.consciousnessDepthMultiplier = 1.5;
              this.config.emotionalResponseStrength = 0.8;
              this.config.beatSyncIntensity = 0.6;
              this.config.cinematicDramaMultiplier = 1.2;
              break;
          }
          console.log(`[Card3DManager] Quality level set to: ${level}`);
        }
        /**
         * Adjust quality level (QualityScalingCapable interface)
         */
        adjustQuality(level) {
          this.setQualityLevel(level);
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const cardCount = this.cards.length;
          const baseImpact = cardCount * 0.1;
          const consciousnessImpact = this.config.consciousnessDepthMultiplier * 0.2;
          const emotionalImpact = this.config.emotionalResponseStrength * 0.15;
          const cinematicImpact = this.config.cinematicDramaMultiplier * 0.1;
          return {
            fps: 60,
            frameTime: baseImpact + consciousnessImpact + emotionalImpact + cinematicImpact,
            memoryUsage: cardCount * 0.05,
            // Minimal memory impact
            cpuUsage: (baseImpact + consciousnessImpact) * 100
          };
        }
        /**
         * Reduce quality level
         */
        reduceQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.config.consciousnessDepthMultiplier = Math.max(0.5, this.config.consciousnessDepthMultiplier - amount);
          this.config.emotionalResponseStrength = Math.max(0.1, this.config.emotionalResponseStrength - amount);
          this.config.beatSyncIntensity = Math.max(0.1, this.config.beatSyncIntensity - amount);
          this.config.cinematicDramaMultiplier = Math.max(0.5, this.config.cinematicDramaMultiplier - amount);
          console.log(`[Card3DManager] Quality reduced by ${amount}`);
        }
        /**
         * Increase quality level
         */
        increaseQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.config.consciousnessDepthMultiplier = Math.min(2, this.config.consciousnessDepthMultiplier + amount);
          this.config.emotionalResponseStrength = Math.min(1.5, this.config.emotionalResponseStrength + amount);
          this.config.beatSyncIntensity = Math.min(1, this.config.beatSyncIntensity + amount);
          this.config.cinematicDramaMultiplier = Math.min(2, this.config.cinematicDramaMultiplier + amount);
          console.log(`[Card3DManager] Quality increased by ${amount}`);
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          if (this.qualityCapabilities.length === 0) {
            this.qualityCapabilities = [
              {
                name: "3D Perspective",
                enabled: true,
                qualityLevel: "medium"
              },
              {
                name: "Consciousness Glow",
                enabled: true,
                qualityLevel: "low"
              },
              {
                name: "Beat Sync Effects",
                enabled: true,
                qualityLevel: "low"
              },
              {
                name: "Dramatic Distortion",
                enabled: true,
                qualityLevel: "medium"
              },
              {
                name: "Emotional Modulation",
                enabled: true,
                qualityLevel: "low"
              }
            ];
          }
          return this.qualityCapabilities;
        }
        /**
         * Refresh color state for efficient color system updates
         */
        async refreshColorState(trigger) {
          try {
            this.updateDynamicAccentColor();
            if (this.consciousnessState.dynamicAccentHex) {
              const oklabResult = this.oklabProcessor.processColor(
                this.consciousnessState.dynamicAccentHex,
                this.cinematicPreset
              );
              this.consciousnessState.dynamicAccentHex = oklabResult.enhancedHex;
              this.consciousnessState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            }
            console.log(`[Card3DManager] Color state refreshed for trigger: ${trigger}`);
          } catch (error) {
            console.error("[Card3DManager] Error refreshing color state:", error);
          }
        }
        // ===================================================================
        // Cross-System Consciousness Coordination
        // ===================================================================
        /**
         * Register for consciousness coordination updates
         */
        onConsciousnessCoordination(callback) {
          this.consciousnessCoordinationCallbacks.add(callback);
          return () => {
            this.consciousnessCoordinationCallbacks.delete(callback);
          };
        }
        /**
         * Synchronize consciousness state with other systems
         */
        synchronizeConsciousnessState(sharedState) {
          if (sharedState.currentEmotion) {
            this.consciousnessState.currentEmotion = sharedState.currentEmotion;
          }
          if (sharedState.emotionalIntensity !== void 0) {
            this.consciousnessState.emotionalIntensity = sharedState.emotionalIntensity;
          }
          if (sharedState.beatPhase !== void 0) {
            this.consciousnessState.beatPhase = sharedState.beatPhase;
          }
          if (sharedState.cinematicDramaLevel !== void 0) {
            this.consciousnessState.cinematicDramaLevel = sharedState.cinematicDramaLevel;
          }
          if (sharedState.consciousnessLevel !== void 0) {
            this.consciousnessState.consciousnessLevel = sharedState.consciousnessLevel;
          }
          if (sharedState.dynamicAccentHex) {
            this.consciousnessState.dynamicAccentHex = sharedState.dynamicAccentHex;
          }
          if (sharedState.dynamicAccentRgb) {
            this.consciousnessState.dynamicAccentRgb = sharedState.dynamicAccentRgb;
          }
          this.broadcastConsciousnessState();
        }
        /**
         * Broadcast consciousness state to coordinated systems
         */
        broadcastConsciousnessState() {
          this.consciousnessCoordinationCallbacks.forEach((callback) => {
            try {
              callback(this.consciousnessState);
            } catch (error) {
              console.error("[Card3DManager] Error in consciousness coordination callback:", error);
            }
          });
        }
        /**
         * Enhanced emotional state update with coordination
         */
        updateEmotionalStateWithCoordination(emotionalResult) {
          this.updateEmotionalState(emotionalResult);
          this.broadcastConsciousnessState();
          unifiedEventBus.emit("consciousness:coordination", {
            source: "Card3DManager",
            state: this.consciousnessState,
            timestamp: Date.now()
          });
        }
        /**
         * Enhanced beat event with coordination
         */
        onMusicBeatWithCoordination(event) {
          this.onMusicBeat(event);
          this.broadcastConsciousnessState();
          unifiedEventBus.emit("consciousness:beat-sync", {
            source: "Card3DManager",
            beatPhase: this.consciousnessState.beatPhase,
            lastBeatTime: this.consciousnessState.lastBeatTime,
            timestamp: Date.now()
          });
        }
        /**
         * Enhanced dramatic event with coordination
         */
        onCinematicDramaEventWithCoordination(event) {
          this.onCinematicDramaEvent(event);
          this.broadcastConsciousnessState();
          unifiedEventBus.emit("consciousness:dramatic-sync", {
            source: "Card3DManager",
            dramaticLevel: this.consciousnessState.cinematicDramaLevel,
            type: event.type,
            timestamp: Date.now()
          });
        }
        /**
         * Initialize cross-system consciousness coordination
         */
        initializeCrossSystemCoordination() {
          try {
            unifiedEventBus.subscribe("consciousness:coordination", (event) => {
              if (event.source !== "Card3DManager") {
                this.synchronizeConsciousnessState(event.state);
              }
            }, "Card3DManager");
            unifiedEventBus.subscribe("consciousness:beat-sync", (event) => {
              if (event.source !== "Card3DManager") {
                this.consciousnessState.beatPhase = event.beatPhase;
                this.consciousnessState.lastBeatTime = event.lastBeatTime;
              }
            }, "Card3DManager");
            unifiedEventBus.subscribe("consciousness:dramatic-sync", (event) => {
              if (event.source !== "Card3DManager") {
                this.consciousnessState.cinematicDramaLevel = event.dramaticLevel;
              }
            }, "Card3DManager");
            console.log("[Card3DManager] \u2705 Cross-system consciousness coordination initialized");
          } catch (error) {
            console.error("[Card3DManager] Failed to initialize cross-system coordination:", error);
          }
        }
      };
      __name(_Card3DManager, "Card3DManager");
      Card3DManager = _Card3DManager;
    }
  });

  // src-js/utils/performance/ViewportAwarenessManager.ts
  var _ViewportAwarenessManager, ViewportAwarenessManager, ViewportManager;
  var init_ViewportAwarenessManager = __esm({
    "src-js/utils/performance/ViewportAwarenessManager.ts"() {
      "use strict";
      _ViewportAwarenessManager = class _ViewportAwarenessManager {
        constructor() {
          this.observers = /* @__PURE__ */ new Map();
          this.trackedElements = /* @__PURE__ */ new Map();
          this.isSupported = typeof IntersectionObserver !== "undefined";
          if (!this.isSupported) {
            console.warn("[ViewportAwarenessManager] IntersectionObserver not supported, falling back to always-visible behavior");
          }
        }
        static getInstance() {
          if (!_ViewportAwarenessManager.instance) {
            _ViewportAwarenessManager.instance = new _ViewportAwarenessManager();
          }
          return _ViewportAwarenessManager.instance;
        }
        /**
         * Track an element's visibility with callback
         */
        trackElement(element, callback, options = {}) {
          if (!this.isSupported) {
            const fallbackState = {
              isVisible: true,
              intersectionRatio: 1,
              lastVisibilityChange: Date.now(),
              element
            };
            callback(fallbackState);
            return () => {
            };
          }
          const opts = {
            visibilityThreshold: 0.1,
            rootMargin: "50px",
            trackRootElement: false,
            ...options
          };
          const observerKey = this.getObserverKey(opts);
          let observer = this.observers.get(observerKey);
          if (!observer) {
            observer = new IntersectionObserver(
              (entries) => this.handleIntersectionChanges(entries),
              {
                threshold: opts.visibilityThreshold,
                rootMargin: opts.rootMargin,
                root: opts.rootSelector ? document.querySelector(opts.rootSelector) : null
              }
            );
            this.observers.set(observerKey, observer);
          }
          const initialState = {
            isVisible: false,
            // Will be updated by intersection callback
            intersectionRatio: 0,
            lastVisibilityChange: Date.now(),
            element
          };
          this.trackedElements.set(element, {
            callback,
            options: opts,
            state: initialState
          });
          observer.observe(element);
          return () => this.untrackElement(element);
        }
        /**
         * Check if an element is currently visible
         */
        isElementVisible(element) {
          const tracked = this.trackedElements.get(element);
          return tracked?.state.isVisible ?? true;
        }
        /**
         * Get current visibility state for an element
         */
        getVisibilityState(element) {
          return this.trackedElements.get(element)?.state ?? null;
        }
        /**
         * Stop tracking an element
         */
        untrackElement(element) {
          const tracked = this.trackedElements.get(element);
          if (!tracked) return;
          const observerKey = this.getObserverKey(tracked.options);
          const observer = this.observers.get(observerKey);
          if (observer) {
            observer.unobserve(element);
          }
          this.trackedElements.delete(element);
        }
        /**
         * Track viewport visibility of the main Spotify container
         */
        trackSpotifyContainer(callback) {
          const spotifySelectors = [
            ".Root__main-view",
            '[data-testid="topbar"]',
            ".main-view-container",
            "#main"
          ];
          let element = null;
          for (const selector of spotifySelectors) {
            element = document.querySelector(selector);
            if (element) break;
          }
          if (!element) {
            console.warn("[ViewportAwarenessManager] Could not find Spotify main container, using document.body");
            element = document.body;
          }
          return this.trackElement(element, callback, {
            visibilityThreshold: 0.1,
            rootMargin: "0px",
            trackRootElement: true
          });
        }
        /**
         * Bulk check visibility of multiple elements
         */
        checkBulkVisibility(elements) {
          const results = /* @__PURE__ */ new Map();
          for (const element of elements) {
            results.set(element, this.isElementVisible(element));
          }
          return results;
        }
        /**
         * Cleanup all observers and tracked elements
         */
        destroy() {
          for (const observer of this.observers.values()) {
            observer.disconnect();
          }
          this.observers.clear();
          this.trackedElements.clear();
        }
        handleIntersectionChanges(entries) {
          for (const entry of entries) {
            const tracked = this.trackedElements.get(entry.target);
            if (!tracked) continue;
            const wasVisible = tracked.state.isVisible;
            const isNowVisible = entry.isIntersecting;
            tracked.state = {
              isVisible: isNowVisible,
              intersectionRatio: entry.intersectionRatio,
              lastVisibilityChange: wasVisible !== isNowVisible ? Date.now() : tracked.state.lastVisibilityChange,
              element: entry.target
            };
            if (wasVisible !== isNowVisible) {
              try {
                tracked.callback(tracked.state);
              } catch (error) {
                console.error("[ViewportAwarenessManager] Error in visibility callback:", error);
              }
            }
          }
        }
        getObserverKey(options) {
          return `${options.visibilityThreshold}-${options.rootMargin}-${options.rootSelector || "viewport"}`;
        }
      };
      __name(_ViewportAwarenessManager, "ViewportAwarenessManager");
      ViewportAwarenessManager = _ViewportAwarenessManager;
      ViewportManager = ViewportAwarenessManager.getInstance();
    }
  });

  // src-js/visual/base/ViewportAwareSystem.ts
  var _ViewportAwareSystem, ViewportAwareSystem;
  var init_ViewportAwareSystem = __esm({
    "src-js/visual/base/ViewportAwareSystem.ts"() {
      "use strict";
      init_ViewportAwarenessManager();
      init_UnifiedEventBus();
      _ViewportAwareSystem = class _ViewportAwareSystem {
        constructor(options = {}) {
          this.initialized = false;
          this.isVisible = true;
          // Default to visible until we know otherwise
          this.visibilityState = null;
          this.animationsPaused = false;
          this.settingsUpdatesPaused = false;
          this.viewportOptions = {
            visibilityThreshold: 0.1,
            rootMargin: "50px",
            pauseAnimationsWhenHidden: true,
            pauseSettingsUpdatesWhenHidden: true,
            resumeDelay: 100,
            ...options
          };
        }
        async initialize() {
          await this.initializeViewportTracking();
          await this.initializeEventSubscriptions();
          await this.initializeSystem();
          this.initialized = true;
        }
        async healthCheck() {
          const systemHealth = await this.performHealthCheck();
          return {
            ...systemHealth,
            details: `${systemHealth.details} | Viewport: ${this.isVisible ? "visible" : "hidden"}`
          };
        }
        updateAnimation(deltaTime) {
          if (this.shouldSkipAnimationUpdate()) {
            return;
          }
          this.performAnimationUpdate(deltaTime);
        }
        destroy() {
          this.cleanupViewportTracking();
          this.cleanupEventSubscriptions();
          this.performDestroy();
        }
        /**
         * Handle settings changes with viewport awareness
         */
        handleSettingsChange(event) {
          if (this.shouldSkipSettingsUpdate()) {
            return;
          }
          this.performSettingsUpdate(event);
        }
        /**
         * Force a repaint/update regardless of visibility
         */
        forceRepaint(reason) {
          this.performForceRepaint?.(reason);
        }
        // Optional hooks for viewport awareness
        onVisibilityChanged(state) {
        }
        onBecomingVisible() {
        }
        onBecomingHidden() {
        }
        async initializeViewportTracking() {
          let targetElement = null;
          if (this.viewportOptions.trackingSelector) {
            targetElement = document.querySelector(this.viewportOptions.trackingSelector);
          }
          if (!targetElement) {
            this.untrackViewport = ViewportManager.trackSpotifyContainer(
              (state) => this.handleVisibilityChange(state)
            );
          } else {
            this.untrackViewport = ViewportManager.trackElement(
              targetElement,
              (state) => this.handleVisibilityChange(state),
              this.viewportOptions
            );
          }
        }
        async initializeEventSubscriptions() {
          this.settingsSubscriptionId = unifiedEventBus.subscribe(
            "settings:changed",
            (data) => this.handleUnifiedSettingsChange(data),
            `ViewportAwareSystem-${this.constructor.name}`
          );
        }
        cleanupEventSubscriptions() {
          if (this.settingsSubscriptionId) {
            unifiedEventBus.unsubscribe(this.settingsSubscriptionId);
            delete this.settingsSubscriptionId;
          }
        }
        handleUnifiedSettingsChange(data) {
          if (this.shouldSkipSettingsUpdate()) {
            return;
          }
          const legacyEvent = new CustomEvent("year3000SystemSettingsChanged", {
            detail: { key: data.settingKey, value: data.newValue }
          });
          this.performSettingsUpdate(legacyEvent);
        }
        handleVisibilityChange(state) {
          const wasVisible = this.isVisible;
          this.isVisible = state.isVisible;
          this.visibilityState = state;
          if (!wasVisible && this.isVisible) {
            this.handleBecomingVisible();
          } else if (wasVisible && !this.isVisible) {
            this.handleBecomingHidden();
          }
          this.onVisibilityChanged(state);
        }
        handleBecomingVisible() {
          if (this.resumeTimeoutId) {
            clearTimeout(this.resumeTimeoutId);
          }
          this.resumeTimeoutId = window.setTimeout(() => {
            this.animationsPaused = false;
            this.settingsUpdatesPaused = false;
            this.onBecomingVisible();
          }, this.viewportOptions.resumeDelay || 100);
        }
        handleBecomingHidden() {
          if (this.viewportOptions.pauseAnimationsWhenHidden) {
            this.animationsPaused = true;
          }
          if (this.viewportOptions.pauseSettingsUpdatesWhenHidden) {
            this.settingsUpdatesPaused = true;
          }
          this.onBecomingHidden();
        }
        shouldSkipAnimationUpdate() {
          return this.animationsPaused || !this.isVisible && (this.viewportOptions.pauseAnimationsWhenHidden ?? true);
        }
        shouldSkipSettingsUpdate() {
          return this.settingsUpdatesPaused || !this.isVisible && (this.viewportOptions.pauseSettingsUpdatesWhenHidden ?? true);
        }
        cleanupViewportTracking() {
          if (this.untrackViewport) {
            this.untrackViewport();
            delete this.untrackViewport;
          }
          if (this.resumeTimeoutId) {
            clearTimeout(this.resumeTimeoutId);
            delete this.resumeTimeoutId;
          }
        }
        /**
         * Get current visibility information for debugging
         */
        getVisibilityInfo() {
          return {
            isVisible: this.isVisible,
            animationsPaused: this.animationsPaused,
            settingsUpdatesPaused: this.settingsUpdatesPaused,
            ...this.visibilityState?.intersectionRatio !== void 0 && {
              intersectionRatio: this.visibilityState.intersectionRatio
            }
          };
        }
      };
      __name(_ViewportAwareSystem, "ViewportAwareSystem");
      ViewportAwareSystem = _ViewportAwareSystem;
    }
  });

  // src-js/ui/managers/GlassmorphismManager.ts
  var _GlassmorphismManager, GlassmorphismManager;
  var init_GlassmorphismManager = __esm({
    "src-js/ui/managers/GlassmorphismManager.ts"() {
      "use strict";
      init_globalConfig();
      init_settingKeys();
      init_OptimizedCSSVariableManager();
      init_ViewportAwareSystem();
      init_Year3000Utilities();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      init_UnifiedEventBus();
      _GlassmorphismManager = class _GlassmorphismManager extends ViewportAwareSystem {
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, cssBatcher = null, performanceAnalyzer2 = null, settingsManager2, viewportOptions = {}) {
          super({
            visibilityThreshold: 0.2,
            // More generous threshold since glass effects are subtle
            pauseAnimationsWhenHidden: false,
            // Glass effects are mostly static
            pauseSettingsUpdatesWhenHidden: true,
            // Skip expensive glass calculations when hidden
            resumeDelay: 50,
            // Quick resume for UI effects
            ...viewportOptions
          });
          this.cssBatcher = null;
          this.performanceAnalyzer = null;
          this.observers = [];
          // Year 3000 consciousness integration
          this.musicSyncService = null;
          // Quality scaling state
          this.currentQualityLevel = null;
          this.qualityCapabilities = [];
          // Cross-system consciousness coordination
          this.consciousnessCoordinationCallbacks = /* @__PURE__ */ new Set();
          this.config = config;
          this.utils = utils;
          this.cssBatcher = cssBatcher;
          this.performanceAnalyzer = performanceAnalyzer2;
          this.settingsManager = settingsManager2;
          this.isSupported = this.detectBackdropFilterSupport();
          this.currentIntensity = "balanced";
          this.emotionalMapper = new EmotionalTemperatureMapper(true);
          this.oklabProcessor = new OKLABColorProcessor(true);
          this.cinematicPreset = OKLABColorProcessor.getPreset("STANDARD");
          this.consciousnessState = {
            currentEmotion: "neutral",
            emotionalIntensity: 0.5,
            beatPhase: 0,
            lastBeatTime: 0,
            cinematicDramaLevel: 0,
            dynamicAccentHex: "#cba6f7",
            // Catppuccin mauve fallback
            dynamicAccentRgb: "203,166,247",
            consciousnessLevel: 0.5,
            genreStyle: "organic",
            breathingRate: 1
          };
        }
        static getInstance() {
          if (!_GlassmorphismManager.instance) {
            throw new Error("GlassmorphismManager instance not initialized");
          }
          return _GlassmorphismManager.instance;
        }
        // Implement abstract methods from ViewportAwareSystem
        async initializeSystem() {
          const year3000System2 = globalThis.year3000System;
          this.cssController = year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
          const initialIntensity = this.settingsManager.get("sn-glassmorphism-level");
          this.applyGlassmorphismSettings(initialIntensity);
          await this.initializeConsciousnessIntegration();
        }
        async performHealthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "GlassmorphismManager is operational.",
            issues: [],
            system: "GlassmorphismManager"
          };
        }
        performAnimationUpdate(deltaTime) {
        }
        performDestroy() {
          this.observers.forEach((observer) => observer.disconnect());
          this.observers = [];
        }
        performSettingsUpdate(event) {
          const customEvent = event;
          const { key, value } = customEvent.detail || {};
          if (key === GLASS_LEVEL_KEY) {
            this.applyGlassmorphismSettings(value);
            this.updateGlassVariables(this.currentIntensity);
          }
        }
        // Override viewport awareness hooks for glassmorphism-specific behavior
        onBecomingVisible() {
          if (this.currentIntensity !== "disabled") {
            const root = document.documentElement;
            const computedStyle = getComputedStyle(root);
            const accentRgb = computedStyle.getPropertyValue("--spice-rgb-accent").trim();
            if (accentRgb && accentRgb !== "") {
              this.updateGlassColors(`rgb(${accentRgb})`, `rgb(${accentRgb})`);
            }
          }
        }
        onBecomingHidden() {
        }
        // Settings change handling is now managed by ViewportAwareSystem base class
        detectBackdropFilterSupport() {
          try {
            return CSS.supports("backdrop-filter", "blur(1px)") || CSS.supports("-webkit-backdrop-filter", "blur(1px)");
          } catch (error) {
            console.warn(
              "StarryNight: CSS.supports not available, assuming no backdrop-filter support",
              error
            );
            return false;
          }
        }
        applyGlassmorphismSettings(intensity) {
          const body = document.body;
          body.classList.remove(
            "sn-glass-disabled",
            "sn-glass-minimal",
            "sn-glass-balanced",
            "sn-glass-intense"
          );
          body.classList.add(`sn-glass-${intensity}`);
          this.currentIntensity = intensity;
          this.updateGlassVariables(intensity);
        }
        updateGlassVariables(intensity) {
          const root = document.documentElement;
          const shouldReduceQuality = this.performanceAnalyzer?.shouldReduceQuality() || false;
          let blurValue, opacityValue, saturationValue;
          switch (intensity) {
            case "disabled":
              root.style.removeProperty("--glass-blur");
              root.style.removeProperty("--glass-opacity");
              root.style.removeProperty("--glass-saturation");
              return;
            case "minimal":
              blurValue = shouldReduceQuality ? "2px" : "3px";
              opacityValue = "0.05";
              saturationValue = "1.05";
              break;
            case "moderate":
              blurValue = shouldReduceQuality ? "3px" : "5px";
              opacityValue = "0.08";
              saturationValue = "1.15";
              break;
            case "intense":
              blurValue = shouldReduceQuality ? "6px" : "8px";
              opacityValue = "0.15";
              saturationValue = "1.4";
              break;
            case "balanced":
            default:
              blurValue = shouldReduceQuality ? "4px" : "6px";
              opacityValue = "0.1";
              saturationValue = "1.2";
              break;
          }
          const consciousnessModulations = this.calculateConsciousnessModulations();
          const finalBlur = this.modulateBlurValue(blurValue, consciousnessModulations);
          const finalOpacity = this.modulateOpacityValue(opacityValue, consciousnessModulations);
          const finalSaturation = this.modulateSaturationValue(saturationValue, consciousnessModulations);
          const glassPropertiesVariables = {
            "--glass-blur": finalBlur,
            "--glass-opacity": finalOpacity,
            "--glass-saturation": finalSaturation,
            "--glass-breathing-rate": `${this.consciousnessState.breathingRate}s`,
            "--glass-consciousness-level": this.consciousnessState.consciousnessLevel.toString()
          };
          this.cssController.batchSetVariables(
            "GlassmorphismManager",
            glassPropertiesVariables,
            "high",
            // High priority for glass effect properties - affects visual perception
            "glass-properties-update"
          );
        }
        updateGlassColors(primaryColor, secondaryColor) {
          if (this.currentIntensity === "disabled") return;
          const glassPrimary = this.convertToGlassColor(primaryColor, 0.1);
          const glassSecondary = this.convertToGlassColor(secondaryColor, 0.08);
          const glassColorVariables = {
            "--glass-background": glassPrimary,
            "--glass-border": glassSecondary
          };
          this.cssController.batchSetVariables(
            "GlassmorphismManager",
            glassColorVariables,
            "high",
            // High priority for glass color updates - affects visual aesthetics
            "glass-color-update"
          );
        }
        convertToGlassColor(color3, opacity) {
          try {
            if (typeof color3 !== "string") {
              return this.getThemeAwareFallback(opacity);
            }
            if (color3.startsWith("rgb")) {
              const values = color3.match(/\d+/g);
              if (values && values.length >= 3) {
                return `rgba(${values[0]}, ${values[1]}, ${values[2]}, ${opacity})`;
              }
            }
            if (color3.startsWith("#")) {
              const hex = color3.slice(1);
              const r = parseInt(hex.substring(0, 2), 16);
              const g = parseInt(hex.substring(2, 4), 16);
              const b = parseInt(hex.substring(4, 6), 16);
              if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                return `rgba(${r}, ${g}, ${b}, ${opacity})`;
              }
            }
            return this.getThemeAwareFallback(opacity);
          } catch (error) {
            return this.getThemeAwareFallback(opacity);
          }
        }
        /**
         * Get theme-aware fallback color using Year 3000 dynamic accent cascade
         * Falls back through: --sn-dynamic-accent-rgb  --sn-color-accent-rgb  --spice-rgb-accent  Catppuccin mauve
         */
        getThemeAwareFallback(opacity) {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          if (this.consciousnessState.dynamicAccentRgb && this.consciousnessState.dynamicAccentRgb !== "203,166,247") {
            return `rgba(${this.consciousnessState.dynamicAccentRgb}, ${opacity})`;
          }
          const dynamicAccentRgb = computedStyle.getPropertyValue("--sn-dynamic-accent-rgb").trim() || computedStyle.getPropertyValue("--sn-color-accent-rgb").trim() || computedStyle.getPropertyValue("--spice-rgb-accent").trim();
          if (dynamicAccentRgb && dynamicAccentRgb !== "" && !dynamicAccentRgb.includes("undefined")) {
            return `rgba(${dynamicAccentRgb}, ${opacity})`;
          }
          const textRgb = computedStyle.getPropertyValue("--spice-rgb-text").trim();
          if (textRgb && textRgb !== "" && !textRgb.includes("undefined")) {
            return `rgba(${textRgb}, ${opacity})`;
          }
          return `rgba(203, 166, 247, ${opacity})`;
        }
        // ===================================================================
        // Year 3000 Consciousness Integration Methods
        // ===================================================================
        /**
         * Initialize consciousness integration with music sync and emotional systems
         */
        async initializeConsciousnessIntegration() {
          try {
            unifiedEventBus.subscribe("colors:extracted", (event) => {
              this.onColorsExtracted(event);
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("colors:harmonized", (event) => {
              this.onColorsHarmonized(event);
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("music:beat", (event) => {
              this.onMusicBeat(event);
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("consciousness:dramatic-moment", (event) => {
              this.onCinematicDramaEvent(event);
            }, "GlassmorphismManager");
            this.updateDynamicAccentColor();
            this.initializeCrossSystemCoordination();
            console.log("[GlassmorphismManager] \u2705 Year 3000 consciousness integration initialized");
          } catch (error) {
            console.error("[GlassmorphismManager] Failed to initialize consciousness integration:", error);
          }
        }
        /**
         * Calculate consciousness modulations for glass properties
         */
        calculateConsciousnessModulations() {
          const { emotionalIntensity, beatPhase, cinematicDramaLevel, consciousnessLevel } = this.consciousnessState;
          const emotionalModulation = 1 + (emotionalIntensity - 0.5) * 0.4;
          const beatModulation = 1 + Math.sin(beatPhase) * consciousnessLevel * 0.15;
          const cinematicModulation = 1 + cinematicDramaLevel * 0.3;
          const breathingModulation = 1 + Math.sin(Date.now() * this.consciousnessState.breathingRate * 1e-3) * 0.08;
          return {
            emotionalModulation,
            beatModulation,
            cinematicModulation,
            breathingModulation
          };
        }
        /**
         * Modulate blur value with consciousness awareness
         */
        modulateBlurValue(baseBlur, modulations) {
          const blurValue = parseFloat(baseBlur.replace("px", ""));
          const { emotionalModulation, beatModulation, breathingModulation } = modulations;
          const finalBlur = blurValue * emotionalModulation * beatModulation * breathingModulation;
          return `${Math.max(1, Math.round(finalBlur))}px`;
        }
        /**
         * Modulate opacity value with consciousness awareness
         */
        modulateOpacityValue(baseOpacity, modulations) {
          const opacityValue = parseFloat(baseOpacity);
          const { emotionalModulation, cinematicModulation, breathingModulation } = modulations;
          const finalOpacity = opacityValue * (1 + (emotionalModulation - 1) * 0.5) * cinematicModulation * breathingModulation;
          return Math.max(0.01, Math.min(1, finalOpacity)).toFixed(3);
        }
        /**
         * Modulate saturation value with consciousness awareness
         */
        modulateSaturationValue(baseSaturation, modulations) {
          const saturationValue = parseFloat(baseSaturation);
          const { emotionalModulation, beatModulation, cinematicModulation } = modulations;
          const finalSaturation = saturationValue * emotionalModulation * beatModulation * cinematicModulation;
          return Math.max(1, Math.min(3, finalSaturation)).toFixed(2);
        }
        /**
         * Handle color extraction events
         */
        onColorsExtracted(event) {
          const { rawColors, musicData } = event;
          if (musicData) {
            const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
            this.updateEmotionalState(emotionalResult);
          }
        }
        /**
         * Handle color harmonization events
         */
        onColorsHarmonized(event) {
          const { processedColors, coordinationMetrics } = event;
          if (processedColors.VIBRANT) {
            const oklabResult = this.oklabProcessor.processColor(processedColors.VIBRANT, this.cinematicPreset);
            this.consciousnessState.dynamicAccentHex = oklabResult.enhancedHex;
            this.consciousnessState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            this.updateGlassColors(oklabResult.enhancedHex, oklabResult.enhancedHex);
          }
          if (coordinationMetrics?.consciousnessLevel !== void 0) {
            this.consciousnessState.consciousnessLevel = coordinationMetrics.consciousnessLevel;
          }
        }
        /**
         * Handle music beat events for rhythm-responsive glass effects
         */
        onMusicBeat(event) {
          const { beat, intensity, timestamp } = event;
          this.consciousnessState.beatPhase += Math.PI * 2 * 0.5;
          this.consciousnessState.lastBeatTime = timestamp || Date.now();
          if (intensity > 0.8 && this.currentIntensity !== "disabled") {
            this.applyBeatSyncGlassPulse(intensity);
          }
        }
        /**
         * Handle cinematic drama events for intense glass effects
         */
        onCinematicDramaEvent(event) {
          const { intensity, type } = event;
          this.consciousnessState.cinematicDramaLevel = intensity;
          if (intensity > 0.7 && this.currentIntensity !== "disabled") {
            this.applyDramaticGlassDistortion(intensity);
          }
        }
        /**
         * Update emotional state from music analysis
         */
        updateEmotionalState(emotionalResult) {
          this.consciousnessState.currentEmotion = emotionalResult.primaryEmotion;
          this.consciousnessState.emotionalIntensity = emotionalResult.intensity;
          switch (emotionalResult.primaryEmotion) {
            case "energetic":
            case "aggressive":
              this.consciousnessState.breathingRate = 1.5;
              this.cinematicPreset = OKLABColorProcessor.getPreset("COSMIC");
              break;
            case "calm":
            case "ambient":
              this.consciousnessState.breathingRate = 0.7;
              this.cinematicPreset = OKLABColorProcessor.getPreset("SUBTLE");
              break;
            default:
              this.consciousnessState.breathingRate = 1;
              this.cinematicPreset = OKLABColorProcessor.getPreset("STANDARD");
          }
        }
        /**
         * Apply beat-synchronized glass pulse effect (respects user setting)
         */
        applyBeatSyncGlassPulse(intensity) {
          if (!this.cssBatcher) return;
          const beatPulseEnabled = false;
          if (!beatPulseEnabled) {
            return;
          }
          const currentIntensityValue = this.getIntensityValue(this.currentIntensity);
          const pulseBlur = intensity * 2 * (currentIntensityValue.opacity * 10);
          const pulseOpacity = intensity * 0.05 * currentIntensityValue.opacity;
          this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-blur", `${pulseBlur}px`);
          this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-opacity", pulseOpacity.toString());
          setTimeout(() => {
            if (this.cssBatcher) {
              this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-blur", "0px");
              this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-opacity", "0");
            }
          }, 150);
        }
        /**
         * Apply dramatic glass distortion for cinematic moments
         */
        applyDramaticGlassDistortion(intensity) {
          if (!this.cssBatcher) return;
          const dramaticBlur = intensity * 4;
          const dramaticSaturation = 1 + intensity * 0.5;
          this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-blur", `${dramaticBlur}px`);
          this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-saturation", dramaticSaturation.toString());
          setTimeout(() => {
            if (this.cssBatcher) {
              this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-blur", "0px");
              this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-saturation", "1");
            }
          }, 1200);
        }
        /**
         * Update dynamic accent color from CSS variables
         */
        updateDynamicAccentColor() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const dynamicAccentHex = computedStyle.getPropertyValue("--sn-dynamic-accent-hex").trim() || computedStyle.getPropertyValue("--sn-color-accent-hex").trim() || computedStyle.getPropertyValue("--spice-accent").trim();
          const dynamicAccentRgb = computedStyle.getPropertyValue("--sn-dynamic-accent-rgb").trim() || computedStyle.getPropertyValue("--sn-color-accent-rgb").trim() || computedStyle.getPropertyValue("--spice-rgb-accent").trim();
          if (dynamicAccentHex && dynamicAccentHex !== "") {
            this.consciousnessState.dynamicAccentHex = dynamicAccentHex;
          }
          if (dynamicAccentRgb && dynamicAccentRgb !== "") {
            this.consciousnessState.dynamicAccentRgb = dynamicAccentRgb;
          }
        }
        /**
         * Get current consciousness state for debugging
         */
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        // ===================================================================
        // Quality Scaling Implementation (QualityScalingCapable)
        // ===================================================================
        /**
         * Set quality level for glass effects
         */
        setQualityLevel(level) {
          this.adjustQuality(level);
        }
        /**
         * Adjust quality level (QualityScalingCapable interface)
         */
        adjustQuality(level) {
          this.currentQualityLevel = level;
          let adjustedIntensity;
          switch (level) {
            case "low":
              adjustedIntensity = "minimal";
              break;
            case "medium":
              adjustedIntensity = "balanced";
              break;
            case "high":
              adjustedIntensity = "intense";
              break;
            default:
              adjustedIntensity = "balanced";
              break;
          }
          this.applyGlassmorphismSettings(adjustedIntensity);
          console.log(`[GlassmorphismManager] Quality level set to: ${level} (intensity: ${adjustedIntensity})`);
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const intensityImpact = this.currentIntensity === "disabled" ? 0 : this.currentIntensity === "minimal" ? 0.1 : this.currentIntensity === "balanced" ? 0.3 : this.currentIntensity === "intense" ? 0.5 : 0.2;
          const consciousnessImpact = this.consciousnessState.consciousnessLevel * 0.1;
          const breathingImpact = this.consciousnessState.breathingRate > 1 ? 0.05 : 0;
          return {
            fps: 60,
            frameTime: intensityImpact + consciousnessImpact + breathingImpact,
            memoryUsage: intensityImpact * 2,
            // Minimal memory impact
            cpuUsage: (intensityImpact + consciousnessImpact) * 50
          };
        }
        /**
         * Reduce quality level
         */
        reduceQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.consciousnessState.consciousnessLevel = Math.max(0.1, this.consciousnessState.consciousnessLevel - amount);
          this.consciousnessState.breathingRate = Math.max(0.5, this.consciousnessState.breathingRate - amount * 0.5);
          if (amount > 0.5) {
            switch (this.currentIntensity) {
              case "intense":
                this.applyGlassmorphismSettings("balanced");
                break;
              case "balanced":
                this.applyGlassmorphismSettings("minimal");
                break;
              case "minimal":
                this.applyGlassmorphismSettings("disabled");
                break;
            }
          }
          console.log(`[GlassmorphismManager] Quality reduced by ${amount}`);
        }
        /**
         * Increase quality level
         */
        increaseQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.consciousnessState.consciousnessLevel = Math.min(1, this.consciousnessState.consciousnessLevel + amount);
          this.consciousnessState.breathingRate = Math.min(2, this.consciousnessState.breathingRate + amount * 0.5);
          if (amount > 0.5) {
            switch (this.currentIntensity) {
              case "disabled":
                this.applyGlassmorphismSettings("minimal");
                break;
              case "minimal":
                this.applyGlassmorphismSettings("balanced");
                break;
              case "balanced":
                this.applyGlassmorphismSettings("intense");
                break;
            }
          }
          console.log(`[GlassmorphismManager] Quality increased by ${amount}`);
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          if (this.qualityCapabilities.length === 0) {
            this.qualityCapabilities = [
              {
                name: "Backdrop Filter Blur",
                enabled: this.isSupported && this.currentIntensity !== "disabled",
                qualityLevel: "high"
              },
              {
                name: "Glass Saturation",
                enabled: this.currentIntensity !== "disabled",
                qualityLevel: "low"
              },
              {
                name: "Consciousness Breathing",
                enabled: true,
                qualityLevel: "low"
              },
              {
                name: "Beat Sync Pulse",
                enabled: true,
                qualityLevel: "low"
              },
              {
                name: "Dramatic Distortion",
                enabled: true,
                qualityLevel: "medium"
              }
            ];
          }
          return this.qualityCapabilities;
        }
        /**
         * Refresh color state for efficient color system updates
         */
        async refreshColorState(trigger) {
          try {
            this.updateDynamicAccentColor();
            if (this.consciousnessState.dynamicAccentHex) {
              const oklabResult = this.oklabProcessor.processColor(
                this.consciousnessState.dynamicAccentHex,
                this.cinematicPreset
              );
              this.consciousnessState.dynamicAccentHex = oklabResult.enhancedHex;
              this.consciousnessState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
              this.updateGlassColors(oklabResult.enhancedHex, oklabResult.enhancedHex);
            }
            console.log(`[GlassmorphismManager] Color state refreshed for trigger: ${trigger}`);
          } catch (error) {
            console.error("[GlassmorphismManager] Error refreshing color state:", error);
          }
        }
        // ===================================================================
        // Cross-System Consciousness Coordination
        // ===================================================================
        /**
         * Register for consciousness coordination updates
         */
        onConsciousnessCoordination(callback) {
          this.consciousnessCoordinationCallbacks.add(callback);
          return () => {
            this.consciousnessCoordinationCallbacks.delete(callback);
          };
        }
        /**
         * Synchronize consciousness state with other systems
         */
        synchronizeConsciousnessState(sharedState) {
          if (sharedState.currentEmotion) {
            this.consciousnessState.currentEmotion = sharedState.currentEmotion;
          }
          if (sharedState.emotionalIntensity !== void 0) {
            this.consciousnessState.emotionalIntensity = sharedState.emotionalIntensity;
          }
          if (sharedState.beatPhase !== void 0) {
            this.consciousnessState.beatPhase = sharedState.beatPhase;
          }
          if (sharedState.cinematicDramaLevel !== void 0) {
            this.consciousnessState.cinematicDramaLevel = sharedState.cinematicDramaLevel;
          }
          if (sharedState.consciousnessLevel !== void 0) {
            this.consciousnessState.consciousnessLevel = sharedState.consciousnessLevel;
          }
          if (sharedState.dynamicAccentHex) {
            this.consciousnessState.dynamicAccentHex = sharedState.dynamicAccentHex;
          }
          if (sharedState.dynamicAccentRgb) {
            this.consciousnessState.dynamicAccentRgb = sharedState.dynamicAccentRgb;
          }
          if (sharedState.genreStyle) {
            this.consciousnessState.genreStyle = sharedState.genreStyle;
          }
          if (sharedState.breathingRate !== void 0) {
            this.consciousnessState.breathingRate = sharedState.breathingRate;
          }
          this.updateGlassVariables(this.currentIntensity);
          this.broadcastConsciousnessState();
        }
        /**
         * Broadcast consciousness state to coordinated systems
         */
        broadcastConsciousnessState() {
          this.consciousnessCoordinationCallbacks.forEach((callback) => {
            try {
              callback(this.consciousnessState);
            } catch (error) {
              console.error("[GlassmorphismManager] Error in consciousness coordination callback:", error);
            }
          });
        }
        /**
         * Enhanced emotional state update with coordination
         */
        updateEmotionalStateWithCoordination(emotionalResult) {
          this.updateEmotionalState(emotionalResult);
          this.broadcastConsciousnessState();
          unifiedEventBus.emit("consciousness:coordination", {
            source: "GlassmorphismManager",
            state: this.consciousnessState,
            timestamp: Date.now()
          });
        }
        /**
         * Enhanced beat event with coordination
         */
        onMusicBeatWithCoordination(event) {
          this.onMusicBeat(event);
          this.broadcastConsciousnessState();
          unifiedEventBus.subscribe("consciousness:beat-sync", (syncEvent) => {
            if (syncEvent.source !== "GlassmorphismManager") {
              this.consciousnessState.beatPhase = syncEvent.beatPhase;
              this.consciousnessState.lastBeatTime = syncEvent.lastBeatTime;
            }
          }, "GlassmorphismManager");
        }
        /**
         * Enhanced dramatic event with coordination
         */
        onCinematicDramaEventWithCoordination(event) {
          this.onCinematicDramaEvent(event);
          this.broadcastConsciousnessState();
          unifiedEventBus.subscribe("consciousness:dramatic-sync", (syncEvent) => {
            if (syncEvent.source !== "GlassmorphismManager") {
              this.consciousnessState.cinematicDramaLevel = syncEvent.dramaticLevel;
              if (syncEvent.dramaticLevel > 0.7) {
                this.applyDramaticGlassDistortion(syncEvent.dramaticLevel);
              }
            }
          }, "GlassmorphismManager");
        }
        /**
         * Initialize cross-system consciousness coordination
         */
        initializeCrossSystemCoordination() {
          try {
            unifiedEventBus.subscribe("consciousness:coordination", (event) => {
              if (event.source !== "GlassmorphismManager") {
                this.synchronizeConsciousnessState(event.state);
              }
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("consciousness:beat-sync", (event) => {
              if (event.source !== "GlassmorphismManager") {
                this.consciousnessState.beatPhase = event.beatPhase;
                this.consciousnessState.lastBeatTime = event.lastBeatTime;
                this.applyCoordinatedBeatPulse(event.beatPhase);
              }
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("consciousness:dramatic-sync", (event) => {
              if (event.source !== "GlassmorphismManager") {
                this.consciousnessState.cinematicDramaLevel = event.dramaticLevel;
                this.applyCoordinatedDramaticEffects(event.dramaticLevel, event.type || "unknown");
              }
            }, "GlassmorphismManager");
            console.log("[GlassmorphismManager] \u2705 Cross-system consciousness coordination initialized");
          } catch (error) {
            console.error("[GlassmorphismManager] Failed to initialize cross-system coordination:", error);
          }
        }
        checkPerformanceAndAdjust() {
          if (this.performanceAnalyzer?.shouldReduceQuality() || false) {
            if (this.currentIntensity === "intense") {
              this.applyGlassmorphismSettings("balanced");
            } else if (this.currentIntensity === "balanced" || this.currentIntensity === "moderate") {
              this.applyGlassmorphismSettings("minimal");
            }
          }
        }
        applyGlassmorphism(level) {
          const glassConfig = this.config.glassmorphism[level];
          if (!this.cssBatcher) return;
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-display",
            level === "disabled" ? "none" : "block"
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-blur",
            `${glassConfig.blur}px`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-saturation",
            `${glassConfig.saturation}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-brightness",
            `${glassConfig.brightness}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-noise-opacity",
            `${glassConfig.noiseOpacity}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-border-opacity",
            `${glassConfig.borderOpacity}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-shadow-opacity",
            `${glassConfig.shadowOpacity}`
          );
          this.cssBatcher.flushCSSVariableBatch();
          if (this.config.enableDebug) {
            console.log(`\u{1F48E} [GlassmorphismManager] Applied level: ${level}`);
          }
        }
        // --------------------------------------------------------------------
        // Year3000System central settings broadcast hook
        // --------------------------------------------------------------------
        applyUpdatedSettings(key, value) {
          if (key === "sn-glassmorphism-level") {
            this.applyGlassmorphismSettings(value);
            this.updateGlassVariables(this.currentIntensity);
          }
        }
        // ===================================================================
        // Cross-System Consciousness Coordination Methods
        // ===================================================================
        /**
         * Apply coordinated beat pulse to glass effects
         */
        applyCoordinatedBeatPulse(beatPhase) {
          const modulations = this.calculateConsciousnessModulations();
          const baseIntensity = this.getIntensityValue(this.currentIntensity);
          const beatPulse = 1 + Math.sin(beatPhase) * 0.15 * modulations.beatModulation;
          const pulseOpacity = baseIntensity.opacity * beatPulse;
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-opacity", pulseOpacity.toString());
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-accent-opacity", (pulseOpacity * 0.8).toString());
          this.cssBatcher?.flushCSSVariableBatch();
        }
        /**
         * Apply coordinated dramatic effects to glass systems
         */
        applyCoordinatedDramaticEffects(dramaticLevel, type) {
          const modulations = this.calculateConsciousnessModulations();
          const baseIntensity = this.getIntensityValue(this.currentIntensity);
          const dramaticMultiplier = 1 + dramaticLevel * 0.4;
          const dramaticOpacity = Math.min(1, baseIntensity.opacity * dramaticMultiplier);
          const dramaticBlur = Math.min(20, baseIntensity.blur * (1 + dramaticLevel * 0.3));
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-opacity", dramaticOpacity.toString());
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-blur", `${dramaticBlur}px`);
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-accent-opacity", (dramaticOpacity * 0.9).toString());
          this.cssBatcher?.flushCSSVariableBatch();
          setTimeout(() => {
            this.updateGlassVariables(this.currentIntensity);
          }, 1500);
        }
        /**
         * Get intensity values for glass effects
         */
        getIntensityValue(intensity) {
          switch (intensity) {
            case "disabled":
              return { opacity: 0, blur: 0, saturation: 1 };
            case "minimal":
              return { opacity: 0.05, blur: 3, saturation: 1.05 };
            case "balanced":
              return { opacity: 0.1, blur: 6, saturation: 1.2 };
            case "intense":
              return { opacity: 0.15, blur: 8, saturation: 1.4 };
            case "moderate":
              return { opacity: 0.08, blur: 5, saturation: 1.15 };
            default:
              return { opacity: 0.1, blur: 6, saturation: 1.2 };
          }
        }
      };
      __name(_GlassmorphismManager, "GlassmorphismManager");
      GlassmorphismManager = _GlassmorphismManager;
    }
  });

  // src-js/core/base/UnifiedSystemBase.ts
  var _UnifiedSystemBase, UnifiedSystemBase;
  var init_UnifiedSystemBase = __esm({
    "src-js/core/base/UnifiedSystemBase.ts"() {
      "use strict";
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_EnhancedMasterAnimationCoordinator();
      init_UnifiedPerformanceCoordinator();
      init_globalConfig();
      _UnifiedSystemBase = class _UnifiedSystemBase {
        constructor(config = YEAR3000_CONFIG) {
          // Core lifecycle state
          this.initialized = false;
          this.destroyed = false;
          // Event management
          this.eventUnsubscribers = [];
          // Performance tracking
          this.initializationStartTime = null;
          this.frameStartTime = 0;
          this.frameCount = 0;
          this.lastFPSCalculation = 0;
          this.currentFPS = 60;
          this.config = config;
          this.systemName = this.constructor.name;
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] UnifiedSystemBase constructor`);
          }
        }
        // =========================================================================
        // UNIFIED LIFECYCLE MANAGEMENT
        // =========================================================================
        /**
         * Base initialization - sets up shared utilities and calls system-specific init
         */
        async _baseInitialize() {
          if (this.initialized) {
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Already initialized`);
            }
            return;
          }
          try {
            this.initializationStartTime = performance.now();
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Starting unified initialization`);
            }
            const globalSystem = globalThis.year3000System;
            if (globalSystem) {
              this.performanceAnalyzer = globalSystem.performanceAnalyzer || globalSystem.facadeCoordinator?.getCachedNonVisualSystem?.("SimplePerformanceCoordinator") || globalSystem.facadeCoordinator?.getCachedNonVisualSystem?.("PerformanceAnalyzer");
              this.cssConsciousnessController = globalSystem.cssConsciousnessController || getGlobalOptimizedCSSController();
              this.eventBus = unifiedEventBus;
              this.performanceCoordinator = globalSystem.performanceCoordinator || (this.performanceAnalyzer ? UnifiedPerformanceCoordinator.getInstance(this.config, this.performanceAnalyzer) : null);
              this.animationCoordinator = globalSystem.enhancedMasterAnimationCoordinator || (this.performanceCoordinator ? EnhancedMasterAnimationCoordinator.getInstance(this.config, this.performanceCoordinator) : null);
              this.unifiedCSSManager = globalSystem.unifiedCSSManager || getGlobalOptimizedCSSController();
            } else {
              this.cssConsciousnessController = getGlobalOptimizedCSSController();
              this.eventBus = unifiedEventBus;
              this.performanceCoordinator = UnifiedPerformanceCoordinator.getInstance(this.config, this.performanceAnalyzer);
              this.animationCoordinator = EnhancedMasterAnimationCoordinator.getInstance(this.config, this.performanceCoordinator);
              this.unifiedCSSManager = getGlobalOptimizedCSSController();
            }
            if (this.unifiedCSSManager && this.performanceAnalyzer && this.cssConsciousnessController) {
            }
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.recordMetric === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_registered`, 1);
            }
            await this.trackPerformanceAsync("initialize", async () => {
              await this._performSystemSpecificInitialization();
            });
            this.initialized = true;
            this.publishEvent("system:initialized", {
              systemName: this.systemName,
              timestamp: Date.now(),
              metadata: {
                initializationTime: this.initializationStartTime ? performance.now() - this.initializationStartTime : 0
              }
            });
            if (this.config.enableDebug) {
              const duration = this.initializationStartTime ? performance.now() - this.initializationStartTime : 0;
              console.log(`[${this.systemName}] Unified initialization complete (${duration.toFixed(2)}ms)`);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Initialization failed:`, error);
            this.publishEvent("system:initialization-failed", {
              systemName: this.systemName,
              error: error instanceof Error ? error.message : String(error),
              timestamp: Date.now()
            });
            throw error;
          }
        }
        /**
         * Base destruction - handles cleanup and calls system-specific destroy
         */
        _baseDestroy() {
          if (this.destroyed) {
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Already destroyed`);
            }
            return;
          }
          try {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Starting unified destruction`);
            }
            this.eventUnsubscribers.forEach((unsubscribe) => {
              try {
                unsubscribe();
              } catch (error) {
                console.warn(`[${this.systemName}] Error during event unsubscription:`, error);
              }
            });
            this.eventUnsubscribers = [];
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.recordMetric === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_unregistered`, 1);
            }
            this.destroy();
            this.destroyed = true;
            this.publishEvent("system:destroyed", {
              systemName: this.systemName,
              timestamp: Date.now()
            });
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Unified destruction complete`);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Destruction failed:`, error);
          }
        }
        // =========================================================================
        // SHARED UTILITY METHODS
        // =========================================================================
        /**
         * Update a single CSS variable with priority support
         */
        updateCSSVariable(property, value, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueUpdate(property, value, priority, this.systemName);
          } else if (this.cssConsciousnessController) {
            this.cssConsciousnessController.queueCSSVariableUpdate(property, value);
          } else {
            console.warn(`[${this.systemName}] CSS variable management not initialized`);
          }
        }
        /**
         * Update multiple CSS variables efficiently with priority support
         */
        updateCSSVariables(updates, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueTransaction(updates, priority, this.systemName);
          } else if (this.cssConsciousnessController) {
            Object.entries(updates).forEach(([property, value]) => {
              this.cssConsciousnessController.queueCSSVariableUpdate(property, value);
            });
          } else {
            console.warn(`[${this.systemName}] CSS variable management not initialized`);
          }
        }
        /**
         * Subscribe to events with automatic cleanup and retry logic
         */
        subscribeToEvent(event, callback) {
          if (!this.eventBus) {
            console.warn(`[${this.systemName}] Event bus not initialized - attempting to initialize`);
            try {
              this.eventBus = unifiedEventBus;
              if (!this.eventBus) {
                console.error(`[${this.systemName}] Failed to get unified event bus - event subscription deferred`);
                return () => {
                };
              }
            } catch (error) {
              console.error(`[${this.systemName}] Error accessing unified event bus:`, error);
              return () => {
              };
            }
          }
          try {
            const subscriptionId = this.eventBus.subscribe(event, callback, this.systemName);
            const unsubscribe = /* @__PURE__ */ __name(() => {
              this.eventBus.unsubscribe(subscriptionId);
            }, "unsubscribe");
            this.eventUnsubscribers.push(unsubscribe);
            return unsubscribe;
          } catch (error) {
            console.error(`[${this.systemName}] Failed to subscribe to event ${event}:`, error);
            return () => {
            };
          }
        }
        /**
         * Publish events to the global event bus
         */
        publishEvent(event, payload) {
          if (!this.eventBus) {
            console.warn(`[${this.systemName}] Event bus not initialized - attempting to initialize`);
            try {
              this.eventBus = unifiedEventBus;
              if (!this.eventBus) {
                console.error(`[${this.systemName}] Failed to get unified event bus - event publication skipped`);
                return;
              }
            } catch (error) {
              console.error(`[${this.systemName}] Error accessing unified event bus:`, error);
              return;
            }
          }
          try {
            this.eventBus.emitSync(event, payload);
          } catch (error) {
            console.error(`[${this.systemName}] Failed to publish event ${event}:`, error);
          }
        }
        /**
         * Track performance of synchronous operations
         */
        trackPerformance(operation, fn) {
          const startTime = performance.now();
          try {
            fn();
          } finally {
            const endTime = performance.now();
            const frameTime = endTime - startTime;
            this.trackSystemPerformance(frameTime);
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.timeOperation === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_${operation}`, frameTime);
            }
          }
        }
        /**
         * Track performance of asynchronous operations
         */
        async trackPerformanceAsync(operation, fn) {
          if (!this.performanceAnalyzer || typeof this.performanceAnalyzer.timeOperationAsync !== "function") {
            await fn();
            return;
          }
          await this.performanceAnalyzer.timeOperationAsync(`${this.systemName}_${operation}`, fn);
        }
        /**
         * Track system performance metrics
         */
        trackSystemPerformance(frameTime) {
          if (!this.performanceCoordinator) return;
          this.frameCount++;
          const currentTime = performance.now();
          if (currentTime - this.lastFPSCalculation >= 1e3) {
            this.currentFPS = this.frameCount;
            this.frameCount = 0;
            this.lastFPSCalculation = currentTime;
          }
          const memoryUsage = performance.memory?.usedJSHeapSize || 0;
          this.performanceCoordinator.trackSubsystem(this.systemName, {
            frameTime,
            memoryUsage,
            fps: this.currentFPS,
            cpuUsage: frameTime > 16.67 ? Math.min(100, frameTime / 16.67 * 5) : 0
            // Rough estimate
          });
        }
        /**
         * Register with animation coordinator
         */
        registerAnimation(priority = 60) {
          if (!this.animationCoordinator) {
            console.warn(`[${this.systemName}] Animation coordinator not initialized, attempting lazy initialization`);
            try {
              this.animationCoordinator = EnhancedMasterAnimationCoordinator.getInstance(this.config, this.performanceCoordinator);
            } catch (error) {
              console.error(`[${this.systemName}] Failed to initialize animation coordinator:`, error);
              return;
            }
          }
          try {
            this.animationCoordinator.registerAnimationSystem(
              this.systemName,
              this,
              "normal",
              priority
            );
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Successfully registered with animation coordinator`);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Failed to register with animation coordinator:`, error);
          }
        }
        /**
         * Force a repaint - useful for settings changes
         */
        forceRepaint(reason) {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Force repaint: ${reason || "unknown"}`);
          }
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.forceFlush();
          }
          document.documentElement.style.transform = "translateZ(0)";
          requestAnimationFrame(() => {
            document.documentElement.style.transform = "";
          });
        }
        // =========================================================================
        // UTILITY GETTERS AND STATUS
        // =========================================================================
        /**
         * Check if system is initialized
         */
        get isInitialized() {
          return this.initialized;
        }
        /**
         * Check if system is destroyed
         */
        get isDestroyed() {
          return this.destroyed;
        }
        /**
         * Get system name
         */
        get name() {
          return this.systemName;
        }
        /**
         * Get system configuration
         */
        get systemConfig() {
          return this.config;
        }
        /**
         * Register a CSS variable group for this system
         */
        registerCSSVariableGroup(groupName, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.registerVariableGroup(`${this.systemName}-${groupName}`, priority);
          }
        }
        /**
         * Update variables in a CSS variable group
         */
        updateCSSVariableGroup(groupName, variables) {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.updateVariableGroup(`${this.systemName}-${groupName}`, variables, this.systemName);
          } else {
            this.updateCSSVariables(variables);
          }
        }
        // =========================================================================
        // COMPATIBILITY METHODS
        // =========================================================================
        /**
         * Legacy compatibility method for IManagedSystem
         * @deprecated Use onAnimate instead
         */
        updateAnimation(deltaTime) {
          this.onAnimate(deltaTime);
        }
        /**
         * Legacy compatibility method for BaseVisualSystem
         * @deprecated Override initialize() directly
         */
        async _performSystemSpecificInitialization() {
        }
        /**
         * Legacy compatibility method for BaseVisualSystem
         * @deprecated Override destroy() directly
         */
        _performSystemSpecificCleanup() {
          this.destroy();
        }
      };
      __name(_UnifiedSystemBase, "UnifiedSystemBase");
      UnifiedSystemBase = _UnifiedSystemBase;
    }
  });

  // src-js/visual/ui-effects/SidebarInteractiveFlowSystem.ts
  var _SidebarInteractiveFlowSystem, SidebarInteractiveFlowSystem;
  var init_SidebarInteractiveFlowSystem = __esm({
    "src-js/visual/ui-effects/SidebarInteractiveFlowSystem.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_globalConfig();
      _SidebarInteractiveFlowSystem = class _SidebarInteractiveFlowSystem extends UnifiedSystemBase {
        constructor(config = YEAR3000_CONFIG) {
          super(config);
          this.interactionPatterns = /* @__PURE__ */ new Map();
          // Performance optimization
          this.proximityObserver = null;
          this.interactionElements = /* @__PURE__ */ new Map();
          this.activeDisturbances = [];
          // Animation state
          this.animationPhase = 0;
          this.lastUpdateTime = 0;
          // Note: frameCount is inherited from UnifiedSystemBase, using localFrameCount instead
          this.localFrameCount = 0;
          // Music integration
          this.musicBeatIntensity = 0;
          this.musicEnergyLevel = 0;
          // Proximity tracking
          this.cursorPosition = { x: 0, y: 0 };
          this.cursorVelocity = { x: 0, y: 0 };
          this.lastCursorUpdate = 0;
          // Performance parameters
          this.MAX_FLOW_VECTORS = 50;
          this.DISTURBANCE_DECAY_RATE = 0.05;
          this.PROXIMITY_THRESHOLD = 100;
          // pixels
          this.INTERACTION_COOLDOWN = 16;
          // ms (~60fps)
          // Flow dynamics
          this.FLOW_LERP = 0.08;
          this.VISCOSITY_LERP = 0.12;
          this.INTENSITY_LERP = 0.15;
          this.flowState = {
            direction: "radial",
            intensity: 0.3,
            velocity: 50,
            viscosity: 0.7,
            flowField: []
          };
          this.liquidConsciousnessState = {
            globalFlowIntensity: 0,
            dominantFlowDirection: 0,
            interactionCount: 0,
            lastInteractionTime: 0,
            proximityElements: []
          };
          this.initializeFlowField();
          if (config.enableDebug) {
            console.log(`[${this.systemName}] Initialized liquid consciousness flow system`);
          }
        }
        /**
         * Initialize the interactive flow system
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing liquid consciousness interactions`);
          }
          this.initializeInteractionPatterns();
          this.setupProximityDetection();
          this.setupCursorTracking();
          this.subscribeToEvent("music:beat", (payload) => {
            this.musicBeatIntensity = payload.intensity;
            this.updateMusicFlowEffects();
          });
          this.subscribeToEvent("music:energy", (payload) => {
            this.musicEnergyLevel = payload.energy;
            this.updateMusicFlowEffects();
          });
          this.subscribeToEvent("sidebar:bilateral-beat", (payload) => {
            this.handleBilateralFlowSync(payload);
          });
          this.subscribeToEvent("sidebar:consciousness-level-changed", (payload) => {
            this.handleConsciousnessFlowChange(payload);
          });
          this.subscribeToEvent("sidebar:interaction", (payload) => {
            this.handleInteractionTrigger(payload);
          });
          this.registerAnimation(50);
          this.initializeFlowCSSVariables();
          this.publishEvent("sidebar:interactive-flow-ready", {
            systemName: this.systemName,
            flowPatterns: this.interactionPatterns.size,
            proximityThreshold: this.PROXIMITY_THRESHOLD,
            timestamp: Date.now()
          });
        }
        /**
         * Initialize flow field with vectors
         */
        initializeFlowField() {
          this.flowState.flowField = [];
          const gridSize = 8;
          const spacing = 20;
          for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
              const vector = {
                x: x * spacing,
                y: y * spacing,
                magnitude: 0.5 + Math.random() * 0.5,
                direction: Math.random() * Math.PI * 2,
                influence: 0.3 + Math.random() * 0.4
              };
              this.flowState.flowField.push(vector);
            }
          }
        }
        /**
         * Initialize interaction patterns
         */
        initializeInteractionPatterns() {
          this.interactionPatterns.set("hover", {
            id: "hover",
            type: "hover",
            response: {
              intensityChange: 0.2,
              velocityChange: 0.1,
              viscosityChange: -0.1,
              // Less viscous on hover
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                // Will be updated on interaction
                radius: 30,
                strength: 0.3,
                decay: 0.05,
                type: "wave"
              }],
              rippleEffect: false,
              // Performance-optimized
              glowEffect: true
            },
            duration: 300,
            easing: "liquid",
            priority: 3
          });
          this.interactionPatterns.set("click", {
            id: "click",
            type: "click",
            response: {
              intensityChange: 0.5,
              velocityChange: 0.3,
              viscosityChange: -0.2,
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 50,
                strength: 0.7,
                decay: 0.08,
                type: "pulse"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 500,
            easing: "liquid",
            priority: 8
          });
          this.interactionPatterns.set("focus", {
            id: "focus",
            type: "focus",
            response: {
              intensityChange: 0.3,
              velocityChange: 0.05,
              viscosityChange: 0.1,
              // More viscous for focus
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 40,
                strength: 0.4,
                decay: 0.02,
                // Slower decay for sustained effect
                type: "spiral"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 1e3,
            easing: "liquid",
            priority: 6
          });
          this.interactionPatterns.set("proximity", {
            id: "proximity",
            type: "proximity",
            response: {
              intensityChange: 0.1,
              velocityChange: 0.05,
              viscosityChange: -0.05,
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 20,
                strength: 0.2,
                decay: 0.03,
                type: "wave"
              }],
              rippleEffect: false,
              glowEffect: false
            },
            duration: 200,
            easing: "liquid",
            priority: 2
          });
          this.interactionPatterns.set("gesture", {
            id: "gesture",
            type: "gesture",
            response: {
              intensityChange: 0.4,
              velocityChange: 0.2,
              viscosityChange: -0.15,
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 60,
                strength: 0.6,
                decay: 0.06,
                type: "vortex"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 400,
            easing: "liquid",
            priority: 7
          });
        }
        /**
         * Set up proximity detection using Intersection Observer
         */
        setupProximityDetection() {
          if (typeof IntersectionObserver !== "undefined") {
            this.proximityObserver = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  const element = entry.target;
                  const elementId = element.id || element.className;
                  if (entry.isIntersecting) {
                    this.interactionElements.set(elementId, element);
                    this.handleProximityEnter(element);
                  } else {
                    this.interactionElements.delete(elementId);
                    this.handleProximityExit(element);
                  }
                });
              },
              {
                threshold: [0, 0.1, 0.5, 1],
                rootMargin: `${this.PROXIMITY_THRESHOLD}px`
              }
            );
            this.observeSidebarElements();
          }
        }
        /**
         * Set up cursor tracking for proximity awareness
         */
        setupCursorTracking() {
          if (this.config.enableDebug) {
            setInterval(() => {
              this.simulateCursorMovement();
            }, 50);
          }
        }
        /**
         * Observe sidebar elements for proximity detection
         */
        observeSidebarElements() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Observing sidebar elements for proximity`);
          }
        }
        /**
         * Handle interaction trigger
         */
        handleInteractionTrigger(trigger) {
          const pattern = this.interactionPatterns.get(trigger.type);
          if (!pattern) return;
          const currentTime = Date.now();
          if (currentTime - this.liquidConsciousnessState.lastInteractionTime < this.INTERACTION_COOLDOWN) {
            return;
          }
          this.liquidConsciousnessState.lastInteractionTime = currentTime;
          this.liquidConsciousnessState.interactionCount++;
          this.applyFlowResponse(pattern.response, trigger.position);
          this.updateGlobalFlowState(pattern);
          this.publishEvent("sidebar:flow-interaction", {
            type: trigger.type,
            position: trigger.position,
            pattern: pattern.id,
            timestamp: currentTime
          });
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Flow interaction: ${trigger.type} at (${trigger.position.x}, ${trigger.position.y})`);
          }
        }
        /**
         * Apply flow response to the system
         */
        applyFlowResponse(response, position) {
          this.flowState.intensity = Math.max(0, Math.min(
            1,
            this.flowState.intensity + response.intensityChange
          ));
          this.flowState.velocity = Math.max(0, Math.min(
            200,
            this.flowState.velocity + response.velocityChange * 50
          ));
          this.flowState.viscosity = Math.max(0, Math.min(
            1,
            this.flowState.viscosity + response.viscosityChange
          ));
          response.flowFieldDisturbance.forEach((disturbance) => {
            const positionedDisturbance = {
              ...disturbance,
              center: position
            };
            this.activeDisturbances.push(positionedDisturbance);
          });
          if (this.activeDisturbances.length > 10) {
            this.activeDisturbances = this.activeDisturbances.slice(-10);
          }
        }
        /**
         * Update global flow state based on interaction pattern
         */
        updateGlobalFlowState(pattern) {
          const priorityWeight = pattern.priority / 10;
          this.liquidConsciousnessState.dominantFlowDirection = (this.liquidConsciousnessState.dominantFlowDirection + Math.random() * Math.PI * 2) * priorityWeight;
          this.liquidConsciousnessState.globalFlowIntensity = Math.max(0, Math.min(
            1,
            this.liquidConsciousnessState.globalFlowIntensity + pattern.response.intensityChange * 0.5
          ));
        }
        /**
         * Handle proximity enter
         */
        handleProximityEnter(element) {
          const rect = element.getBoundingClientRect();
          const center = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          };
          const distance2 = Math.sqrt(
            Math.pow(center.x - this.cursorPosition.x, 2) + Math.pow(center.y - this.cursorPosition.y, 2)
          );
          this.liquidConsciousnessState.proximityElements.push({
            element,
            distance: distance2,
            influence: Math.max(0, 1 - distance2 / this.PROXIMITY_THRESHOLD)
          });
          this.handleInteractionTrigger({
            type: "proximity",
            position: center,
            element,
            timestamp: Date.now(),
            proximityData: {
              distance: distance2,
              angle: Math.atan2(center.y - this.cursorPosition.y, center.x - this.cursorPosition.x),
              velocity: this.cursorVelocity,
              pressure: 0.5
            }
          });
        }
        /**
         * Handle proximity exit
         */
        handleProximityExit(element) {
          this.liquidConsciousnessState.proximityElements = this.liquidConsciousnessState.proximityElements.filter((item) => item.element !== element);
        }
        /**
         * Update music flow effects
         */
        updateMusicFlowEffects() {
          const musicFlowIntensity = this.musicBeatIntensity * 0.3;
          this.flowState.intensity = Math.max(this.flowState.intensity, musicFlowIntensity);
          const musicVelocityBoost = this.musicEnergyLevel * 30;
          this.flowState.velocity = Math.min(200, this.flowState.velocity + musicVelocityBoost);
          const musicViscosityAdjustment = (1 - this.musicEnergyLevel) * 0.2;
          this.flowState.viscosity = Math.max(0.1, this.flowState.viscosity - musicViscosityAdjustment);
          this.updateFlowFieldWithMusic();
        }
        /**
         * Update flow field with music influence
         */
        updateFlowFieldWithMusic() {
          const musicInfluence = this.musicBeatIntensity * 0.5;
          this.flowState.flowField.forEach((vector) => {
            vector.direction += (Math.random() - 0.5) * musicInfluence * 0.1;
            vector.magnitude = Math.max(0.1, Math.min(
              1,
              vector.magnitude + (this.musicEnergyLevel - 0.5) * 0.2
            ));
          });
        }
        /**
         * Handle bilateral flow synchronization
         */
        handleBilateralFlowSync(payload) {
          if (payload.source === "left") {
            const consciousnessFlow = payload.intensity * 0.2;
            this.flowState.intensity = Math.max(this.flowState.intensity, consciousnessFlow);
            const flowDirectionAdjustment = payload.intensity * 0.3;
            this.liquidConsciousnessState.dominantFlowDirection += flowDirectionAdjustment;
          }
        }
        /**
         * Handle consciousness flow changes
         */
        handleConsciousnessFlowChange(payload) {
          const consciousnessLevels = {
            dormant: 0.1,
            aware: 0.3,
            focused: 0.6,
            transcendent: 1
          };
          const targetIntensity = consciousnessLevels[payload.newLevel] || 0.3;
          this.flowState.intensity = this.lerp(this.flowState.intensity, targetIntensity, 0.1);
          const viscosityTarget = 0.8 - targetIntensity * 0.3;
          this.flowState.viscosity = this.lerp(this.flowState.viscosity, viscosityTarget, 0.05);
        }
        /**
         * Simulate cursor movement for testing
         */
        simulateCursorMovement() {
          if (!this.config.enableDebug) return;
          const currentTime = Date.now();
          const deltaTime = currentTime - this.lastCursorUpdate;
          const time = currentTime * 1e-3;
          const newX = 200 + Math.sin(time * 0.5) * 100;
          const newY = 300 + Math.cos(time * 0.3) * 80;
          if (this.lastCursorUpdate > 0) {
            this.cursorVelocity.x = (newX - this.cursorPosition.x) / deltaTime * 1e3;
            this.cursorVelocity.y = (newY - this.cursorPosition.y) / deltaTime * 1e3;
          }
          this.cursorPosition.x = newX;
          this.cursorPosition.y = newY;
          this.lastCursorUpdate = currentTime;
        }
        /**
         * Update flow field disturbances
         */
        updateFlowDisturbances() {
          this.activeDisturbances = this.activeDisturbances.filter((disturbance) => {
            disturbance.strength *= 1 - disturbance.decay;
            return disturbance.strength > 0.01;
          });
          this.activeDisturbances.forEach((disturbance) => {
            this.flowState.flowField.forEach((vector) => {
              const distance2 = Math.sqrt(
                Math.pow(vector.x - disturbance.center.x, 2) + Math.pow(vector.y - disturbance.center.y, 2)
              );
              if (distance2 < disturbance.radius) {
                const influence = disturbance.strength * (1 - distance2 / disturbance.radius);
                switch (disturbance.type) {
                  case "wave":
                    vector.magnitude += influence * 0.3;
                    break;
                  case "spiral":
                    vector.direction += influence * 0.5;
                    break;
                  case "pulse":
                    vector.magnitude += influence * 0.5;
                    vector.direction += influence * 0.2;
                    break;
                  case "vortex":
                    const angle = Math.atan2(
                      vector.y - disturbance.center.y,
                      vector.x - disturbance.center.x
                    );
                    vector.direction = angle + influence * Math.PI * 0.5;
                    break;
                }
              }
            });
          });
        }
        /**
         * Initialize flow CSS variables
         */
        initializeFlowCSSVariables() {
          this.updateCSSVariables({
            "--sn-flow-intensity": this.flowState.intensity.toFixed(3),
            "--sn-flow-velocity": `${this.flowState.velocity}px`,
            "--sn-flow-viscosity": this.flowState.viscosity.toFixed(3),
            "--sn-flow-direction": `${this.liquidConsciousnessState.dominantFlowDirection}rad`,
            "--sn-flow-global-intensity": this.liquidConsciousnessState.globalFlowIntensity.toFixed(3),
            "--sn-flow-interaction-count": this.liquidConsciousnessState.interactionCount.toString(),
            "--sn-flow-proximity-elements": this.liquidConsciousnessState.proximityElements.length.toString(),
            "--sn-flow-disturbances": this.activeDisturbances.length.toString(),
            "--sn-flow-music-beat": this.musicBeatIntensity.toFixed(3),
            "--sn-flow-music-energy": this.musicEnergyLevel.toFixed(3)
          });
        }
        /**
         * Update flow CSS variables
         */
        updateFlowCSSVariables() {
          this.updateCSSVariables({
            "--sn-flow-intensity": this.flowState.intensity.toFixed(3),
            "--sn-flow-velocity": `${this.flowState.velocity}px`,
            "--sn-flow-viscosity": this.flowState.viscosity.toFixed(3),
            "--sn-flow-direction": `${this.liquidConsciousnessState.dominantFlowDirection}rad`,
            "--sn-flow-global-intensity": this.liquidConsciousnessState.globalFlowIntensity.toFixed(3)
          });
        }
        /**
         * Linear interpolation helper
         */
        lerp(from, to, alpha) {
          return from + (to - from) * alpha;
        }
        /**
         * Animation frame callback
         */
        onAnimate(deltaTime) {
          this.lastUpdateTime = performance.now();
          this.animationPhase += deltaTime * 1e-3;
          this.localFrameCount++;
          this.updateFlowDisturbances();
          this.flowState.intensity = this.lerp(
            this.flowState.intensity,
            this.liquidConsciousnessState.globalFlowIntensity,
            this.INTENSITY_LERP
          );
          this.flowState.intensity *= 0.995;
          this.flowState.velocity *= 0.98;
          if (this.localFrameCount % 10 === 0) {
            this.updateFlowFieldNaturalTurbulence();
          }
          this.updateProximityElements();
          this.updateFlowCSSVariables();
          this.updateMusicFlowEffects();
        }
        /**
         * Update flow field with natural turbulence
         */
        updateFlowFieldNaturalTurbulence() {
          this.flowState.flowField.forEach((vector) => {
            vector.direction += (Math.random() - 0.5) * 0.02;
            vector.magnitude += (Math.random() - 0.5) * 0.01;
            vector.magnitude = Math.max(0.1, Math.min(1, vector.magnitude));
          });
        }
        /**
         * Update proximity elements
         */
        updateProximityElements() {
          this.liquidConsciousnessState.proximityElements.forEach((item) => {
            const rect = item.element.getBoundingClientRect();
            const center = {
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2
            };
            item.distance = Math.sqrt(
              Math.pow(center.x - this.cursorPosition.x, 2) + Math.pow(center.y - this.cursorPosition.y, 2)
            );
            item.influence = Math.max(0, 1 - item.distance / this.PROXIMITY_THRESHOLD);
          });
        }
        /**
         * Get current flow state
         */
        getFlowState() {
          return { ...this.flowState };
        }
        /**
         * Get liquid consciousness state
         */
        getLiquidConsciousnessState() {
          return { ...this.liquidConsciousnessState };
        }
        /**
         * Get active disturbances
         */
        getActiveDisturbances() {
          return [...this.activeDisturbances];
        }
        /**
         * System health check
         */
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: `Interactive flow system healthy - ${this.interactionPatterns.size} patterns, ${this.activeDisturbances.length} disturbances, ${this.liquidConsciousnessState.interactionCount} interactions`,
            issues: [],
            system: "SidebarInteractiveFlowSystem"
          };
        }
        /**
         * Clean up resources
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying liquid consciousness flow system`);
          }
          if (this.proximityObserver) {
            this.proximityObserver.disconnect();
            this.proximityObserver = null;
          }
          this.interactionPatterns.clear();
          this.interactionElements.clear();
          this.activeDisturbances = [];
          this.flowState = {
            direction: "radial",
            intensity: 0,
            velocity: 0,
            viscosity: 0.5,
            flowField: []
          };
          this.liquidConsciousnessState = {
            globalFlowIntensity: 0,
            dominantFlowDirection: 0,
            interactionCount: 0,
            lastInteractionTime: 0,
            proximityElements: []
          };
          this.publishEvent("sidebar:interactive-flow-destroyed", {
            timestamp: Date.now()
          });
        }
      };
      __name(_SidebarInteractiveFlowSystem, "SidebarInteractiveFlowSystem");
      SidebarInteractiveFlowSystem = _SidebarInteractiveFlowSystem;
    }
  });

  // src-js/utils/dom/domCache.ts
  function $$(selector, options = {}) {
    if (!SUPPORTS_WEAKREF) {
      return Array.from(document.querySelectorAll(selector));
    }
    let entry = CACHE.get(selector);
    let elements = entry?.ref?.deref();
    if (options.force || !elements) {
      elements = Array.from(document.querySelectorAll(selector));
      const ref = new WeakRef(elements);
      entry = { ref, lastUpdate: Date.now() };
      CACHE.set(selector, entry);
      registry?.register(elements, selector);
    }
    return elements;
  }
  var CACHE, SUPPORTS_WEAKREF, SUPPORTS_REGISTRY, registry;
  var init_domCache = __esm({
    "src-js/utils/dom/domCache.ts"() {
      "use strict";
      CACHE = /* @__PURE__ */ new Map();
      SUPPORTS_WEAKREF = typeof WeakRef !== "undefined";
      SUPPORTS_REGISTRY = typeof FinalizationRegistry !== "undefined";
      registry = SUPPORTS_REGISTRY ? (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore  lib dom may not include FinalizationRegistry in older TS bundlers
        new FinalizationRegistry((selector) => {
          CACHE.delete(selector);
        })
      ) : null;
      __name($$, "$$");
    }
  });

  // src-js/debug/SpotifyDOMSelectors.ts
  function elementExists(selector) {
    return $$(selector).length > 0;
  }
  function findElementsWithFallback(modernSelector, legacySelector, options) {
    let elements = $$(modernSelector, options);
    if (elements.length === 0 && legacySelector) {
      elements = $$(legacySelector, options);
      if (elements.length > 0) {
        console.warn(
          `\u{1F30C} [SpotifyDOMSelectors] Using legacy selector: ${legacySelector}. Consider updating to: ${modernSelector}`
        );
      }
    }
    return elements;
  }
  function validateSpotifyDOM() {
    console.group("\u{1F30C} [SpotifyDOMSelectors] DOM Validation");
    const results = {
      found: 0,
      missing: 0,
      details: {}
    };
    Object.entries(MODERN_SELECTORS).forEach(([key, selector]) => {
      const exists = elementExists(selector);
      results.details[key] = {
        selector,
        exists,
        element: exists ? $$(selector)[0] || null : null
      };
      if (exists) {
        results.found++;
        console.log(`\u2705 ${key}: ${selector}`);
      } else {
        results.missing++;
        console.warn(`\u274C ${key}: ${selector}`);
      }
    });
    console.log(`\u{1F4CA} Summary: ${results.found} found, ${results.missing} missing`);
    console.groupEnd();
    return results;
  }
  function testGravitySystemSelectors() {
    console.group("\u{1F30C} [Phase 1] Testing Gravity System Selectors");
    console.log("\u{1F3AF} Primary gravity well targets:");
    if (GRAVITY_WELL_TARGETS["primary"]) {
      GRAVITY_WELL_TARGETS["primary"].forEach((selector) => {
        const element = $$(selector)[0] || null;
        console.log(`${element ? "\u2705" : "\u274C"} ${selector}`, element);
      });
    }
    console.log("\u{1F3AF} Secondary gravity well targets:");
    if (GRAVITY_WELL_TARGETS["secondary"]) {
      GRAVITY_WELL_TARGETS["secondary"].forEach((selector) => {
        const element = $$(selector)[0] || null;
        console.log(`${element ? "\u2705" : "\u274C"} ${selector}`, element);
      });
    }
    console.log("\u{1F6F8} Orbital elements:");
    Object.entries(ORBITAL_ELEMENTS).forEach(([key, selector]) => {
      const elements = $$(selector);
      console.log(
        `${elements.length > 0 ? "\u2705" : "\u274C"} ${key} (${selector}): ${elements.length} found`
      );
    });
    console.groupEnd();
  }
  function validatePredictionTargets() {
    console.group(
      "\u{1F52E} [SpotifyDOMSelectors] Phase 2 - Prediction Target Validation"
    );
    const testSelectors = [
      { name: "Track Rows", selector: ORBITAL_ELEMENTS["trackRows"] },
      { name: "Progress Bar", selector: MODERN_SELECTORS["progressBar"] },
      { name: "Play Button", selector: MODERN_SELECTORS["playButton"] },
      { name: "Heart Button", selector: MODERN_SELECTORS["heartButton"] },
      { name: "Album Cover", selector: MODERN_SELECTORS["albumCover"] },
      {
        name: "Now Playing Widget",
        selector: MODERN_SELECTORS["nowPlayingWidget"]
      },
      { name: "Now Playing Left", selector: MODERN_SELECTORS["nowPlayingLeft"] },
      { name: "Left Sidebar", selector: MODERN_SELECTORS["leftSidebar"] },
      { name: "Library Items", selector: ORBITAL_ELEMENTS["libraryItems"] }
    ];
    const results = {
      found: 0,
      missing: 0,
      details: {}
    };
    testSelectors.forEach(({ name, selector }) => {
      if (!selector) return;
      const elements = findElementsWithFallback(selector);
      const count = elements.length;
      results.details[name] = {
        selector,
        count,
        exists: count > 0
      };
      if (count > 0) {
        results.found++;
        console.log(`\u2705 ${name}: ${count} elements found (${selector})`);
      } else {
        results.missing++;
        console.warn(`\u274C ${name}: No elements found (${selector})`);
      }
    });
    console.log(
      `\u{1F4CA} Prediction Targets Summary: ${results.found} types found, ${results.missing} missing`
    );
    console.groupEnd();
    return results;
  }
  function testPhase2Systems() {
    console.group("\u{1F30C} [SpotifyDOMSelectors] Phase 2 - System Integration Test");
    const systemTests = {
      behavioralPrediction: validatePredictionTargets(),
      dimensionalNexus: {
        sidebarElement: MODERN_SELECTORS["leftSidebar"] ? elementExists(MODERN_SELECTORS["leftSidebar"]) : false
      },
      dataGlyph: {
        navLinks: MODERN_SELECTORS["navBarLink"] ? elementExists(MODERN_SELECTORS["navBarLink"]) : false,
        trackRows: ORBITAL_ELEMENTS["trackRows"] ? elementExists(ORBITAL_ELEMENTS["trackRows"]) : false,
        cards: ORBITAL_ELEMENTS["cards"] ? elementExists(ORBITAL_ELEMENTS["cards"]) : false
      }
    };
    let totalIssues = 0;
    Object.values(systemTests).forEach((tests) => {
      if (typeof tests === "object" && tests.missing) {
        totalIssues += tests.missing;
      }
    });
    console.log(
      `\u{1F3AF} Phase 2 Integration Health: ${totalIssues === 0 ? "\u2705 All systems operational" : `\u26A0\uFE0F ${totalIssues} issues detected`}`
    );
    console.groupEnd();
    return systemTests;
  }
  var MODERN_SELECTORS, SELECTOR_MAPPINGS, ORBITAL_ELEMENTS, GRAVITY_WELL_TARGETS, ANTI_GRAVITY_ZONES;
  var init_SpotifyDOMSelectors = __esm({
    "src-js/debug/SpotifyDOMSelectors.ts"() {
      "use strict";
      init_domCache();
      MODERN_SELECTORS = {
        // Main Layout Structure
        nowPlayingBar: ".Root__now-playing-bar",
        leftSidebar: ".Root__nav-bar",
        mainView: ".Root__main-view",
        rightSidebar: ".Root__right-sidebar",
        // Now Playing Components
        nowPlayingWidget: "[data-testid='now-playing-widget']",
        nowPlayingLeft: ".main-nowPlayingBar-left",
        nowPlayingCenter: ".main-nowPlayingBar-center",
        nowPlayingRight: ".main-nowPlayingBar-right",
        coverArt: ".main-coverSlotCollapsed-container",
        trackInfo: ".main-trackInfo-container",
        // Navigation & Library
        navMain: "nav[aria-label='Main']",
        yourLibrary: ".main-yourLibraryX-libraryContainer",
        libraryItems: ".main-yourLibraryX-listItem",
        libraryHeader: ".main-yourLibraryX-header",
        playlistList: ".main-rootlist-wrapper",
        // Track Lists & Content
        trackListContainer: "[role='grid'][aria-label*='tracks']",
        trackRow: ".main-trackList-trackListRow",
        trackListHeader: ".main-trackList-trackListHeaderRow",
        trackNumber: ".main-trackList-rowSectionIndex",
        trackTitle: ".main-trackList-rowTitle",
        trackArtist: ".main-trackList-rowSubTitle",
        // Entity Headers (Playlist/Album/Artist Pages)
        entityHeader: ".main-entityHeader-container",
        entityTitle: ".main-entityHeader-title",
        entityMetadata: ".main-entityHeader-metaData",
        entityImage: ".main-entityHeader-imageContainer",
        // Action Bar & Controls
        actionBar: ".main-actionBar-ActionBarRow",
        actionBarInner: ".main-actionBar-ActionBar",
        playButton: "[data-testid='play-button']",
        pauseButton: "[data-testid='pause-button']",
        shuffleButton: "[data-testid='shuffle-button']",
        likeButton: ".control-button-heart",
        // Queue & Right Sidebar
        queue: ".main-queue-trackList",
        queueContainer: "[aria-label='Next in queue']",
        aboutArtist: "[aria-label='About the artist']",
        credits: "[aria-label='Credits']",
        // Search & Filtering
        searchInput: "[data-testid='search-input']",
        searchPage: "[data-testid='search-container']",
        filterPills: ".main-genre-chip",
        sortButton: "[data-testid='sort-button']",
        // Cards & Media
        card: ".main-card-card",
        cardImage: ".main-cardImage-image",
        albumArt: ".main-trackList-albumArt",
        // Modal & Overlay
        modal: ".main-modal-container",
        overlay: ".main-overlay-container"
      };
      SELECTOR_MAPPINGS = Object.entries({
        // Migration mapping: legacy  modern
        ".main-nowPlayingWidget-nowPlaying": MODERN_SELECTORS["nowPlayingBar"],
        ".main-navBar-navBar": MODERN_SELECTORS["leftSidebar"],
        ".main-search-searchBar": MODERN_SELECTORS["searchInput"],
        ".main-topBar-topBar": MODERN_SELECTORS["actionBar"],
        ".main-queue-queue": MODERN_SELECTORS["queue"],
        ".main-trackList-trackList": MODERN_SELECTORS["trackListContainer"]
      }).reduce((acc, [key, value]) => {
        if (typeof value === "string") {
          acc[key] = value;
        }
        return acc;
      }, {});
      ORBITAL_ELEMENTS = {
        // Elements that can have orbital gravity effects
        trackRows: MODERN_SELECTORS["trackRow"] ?? "",
        libraryItems: MODERN_SELECTORS["libraryItems"] ?? "",
        cards: MODERN_SELECTORS["card"] ?? "",
        navLinks: ".main-navBar-navBarLink"
        // This one still works
      };
      GRAVITY_WELL_TARGETS = {
        // Major UI elements that should have gravity wells
        primary: [
          MODERN_SELECTORS["nowPlayingBar"],
          MODERN_SELECTORS["leftSidebar"],
          MODERN_SELECTORS["entityHeader"]
        ].filter((s) => !!s),
        secondary: [
          MODERN_SELECTORS["actionBar"],
          MODERN_SELECTORS["queue"],
          MODERN_SELECTORS["searchInput"]
        ].filter((s) => !!s),
        tertiary: [
          MODERN_SELECTORS["playButton"],
          MODERN_SELECTORS["trackListHeader"]
        ].filter((s) => !!s)
      };
      ANTI_GRAVITY_ZONES = {
        // Areas where anti-gravity effects should be applied
        searchAreas: [
          MODERN_SELECTORS["searchInput"],
          MODERN_SELECTORS["searchPage"]
        ].filter((s) => !!s),
        notifications: [
          "[data-testid='notification-bar']",
          ".main-topBar-notifications"
        ],
        dropdowns: [".main-dropdown-menu", "[role='menu']", "[role='listbox']"]
      };
      __name(elementExists, "elementExists");
      __name(findElementsWithFallback, "findElementsWithFallback");
      __name(validateSpotifyDOM, "validateSpotifyDOM");
      __name(testGravitySystemSelectors, "testGravitySystemSelectors");
      __name(validatePredictionTargets, "validatePredictionTargets");
      __name(testPhase2Systems, "testPhase2Systems");
      if (typeof window !== "undefined") {
        window.SpotifyDOMSelectors = {
          validate: validateSpotifyDOM,
          testGravity: testGravitySystemSelectors,
          validatePredictionTargets,
          testPhase2Systems,
          selectors: MODERN_SELECTORS,
          targets: GRAVITY_WELL_TARGETS,
          orbital: ORBITAL_ELEMENTS,
          antiGravity: ANTI_GRAVITY_ZONES
        };
        console.log("\u{1F3AF} [SpotifyDOMSelectors] Debug functions available:");
        console.log("  window.SpotifyDOMSelectors.validate() - Test all selectors");
        console.log(
          "  window.SpotifyDOMSelectors.testGravity() - Test gravity selectors"
        );
      }
    }
  });

  // src-js/visual/ui-effects/SidebarPerformanceCoordinator.ts
  var SidebarPerformanceCoordinator_exports = {};
  __export(SidebarPerformanceCoordinator_exports, {
    SidebarPerformanceCoordinator: () => SidebarPerformanceCoordinator,
    getSidebarPerformanceCoordinator: () => getSidebarPerformanceCoordinator
  });
  function getSidebarPerformanceCoordinator(config) {
    return SidebarPerformanceCoordinator.getInstance(config);
  }
  var _SidebarPerformanceCoordinator, SidebarPerformanceCoordinator;
  var init_SidebarPerformanceCoordinator = __esm({
    "src-js/visual/ui-effects/SidebarPerformanceCoordinator.ts"() {
      "use strict";
      init_OptimizedCSSVariableManager();
      init_PerformanceBudgetManager();
      init_SpotifyDOMSelectors();
      init_UnifiedEventBus();
      _SidebarPerformanceCoordinator = class _SidebarPerformanceCoordinator {
        constructor(config = {}) {
          this.pendingUpdates = /* @__PURE__ */ new Map();
          this.isFlushScheduled = false;
          this.rafId = null;
          this.performanceAnalyzer = null;
          // Harmonic variable mapping for Year 3000 convergence
          this.harmonicVariableMap = /* @__PURE__ */ new Map([
            ["--sn-rs-beat-intensity", "--sn-beat-pulse-intensity"],
            ["--sn-rs-glow-alpha", "--sn-rhythm-phase"],
            ["--sn-rs-hue-shift", "--sn-spectrum-phase"]
          ]);
          // Performance tracking
          this.flushCount = 0;
          this.totalFlushTime = 0;
          this.lastFlushTimestamp = 0;
          this.budgetManager = null;
          // DOM observation for reactive refresh and temporal play
          this.domObserver = null;
          this.sidebarElement = null;
          this.visibilityObserver = null;
          this.observationThrottleTimer = null;
          this.lastObservationTime = 0;
          this.OBSERVATION_THROTTLE_MS = 200;
          // Throttle observations to 5 Hz for better performance
          this.isFirstOpen = true;
          this.lastScrollUpdate = 0;
          // Timeout tracking for proper cleanup
          this.activeTimeouts = /* @__PURE__ */ new Set();
          this.domObservationRetryTimeout = null;
          // Event-driven coordination for music changes
          this.musicChangeUnsubscribe = null;
          this.config = {
            enableDebug: config.enableDebug ?? false,
            maxBatchSize: config.maxBatchSize ?? 50,
            ...config
          };
          this.performanceAnalyzer = config.performanceAnalyzer || null;
          const year3000System2 = globalThis.year3000System;
          this.cssController = year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
          if (this.performanceAnalyzer) {
            this.budgetManager = PerformanceBudgetManager.getInstance(void 0, this.performanceAnalyzer);
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceCoordinator] Initialized with RAF-based batching"
            );
          }
        }
        /**
         * Singleton accessor for global coordination
         */
        static getInstance(config) {
          if (!_SidebarPerformanceCoordinator.instance) {
            _SidebarPerformanceCoordinator.instance = new _SidebarPerformanceCoordinator(config);
          }
          return _SidebarPerformanceCoordinator.instance;
        }
        /**
         * Queue a CSS variable update for atomic application at next animation frame
         */
        queueUpdate(property, value) {
          const criticalVars = [
            "--sn-rs-glow-alpha",
            "--sn-rs-beat-intensity",
            "--sn-rs-hue-shift"
          ];
          if (criticalVars.includes(property)) {
            this.applyCriticalUpdate(property, value);
            return;
          }
          try {
            const cssController = getGlobalOptimizedCSSController();
            cssController.queueCSSVariableUpdate(
              property,
              value,
              this.getSidebarElement()
            );
          } catch (error) {
            this.pendingUpdates.set(property, {
              property,
              value,
              timestamp: performance.now()
            });
            if (this.config.enableDebug && this.pendingUpdates.size === 1) {
              console.log(
                `\u{1F30C} [SidebarPerformanceCoordinator] Queuing first update (fallback): ${property}`
              );
            }
            this.scheduleFlush();
          }
        }
        /**
         * Apply critical updates immediately to the sidebar element
         */
        applyCriticalUpdate(property, value) {
          try {
            this.cssController.setVariable(
              "SidebarPerformanceCoordinator",
              property,
              value,
              "critical",
              // Critical priority for performance-critical sidebar updates
              "sidebar-critical-update"
            );
          } catch (error) {
            console.error(
              `\u{1F30C} [SidebarPerformanceCoordinator] Failed to apply critical ${property}:`,
              error
            );
          }
        }
        /**
         * Get the sidebar element with fallback to document root
         * Extensible to support multiple sidebar locations in the future
         */
        getSidebarElement() {
          if (!this.sidebarElement) {
            this.sidebarElement = document.querySelector(
              MODERN_SELECTORS.rightSidebar
            );
          }
          return this.sidebarElement || document.documentElement;
        }
        /**
         * Schedule atomic flush at next animation frame
         */
        scheduleFlush() {
          if (this.isFlushScheduled) {
            return;
          }
          this.isFlushScheduled = true;
          this.rafId = requestAnimationFrame(() => {
            this.flushUpdates();
          });
        }
        /**
         * Atomically apply all pending updates
         */
        flushUpdates() {
          if (this.pendingUpdates.size === 0) {
            this.isFlushScheduled = false;
            return;
          }
          const startTime = performance.now();
          const targetElement = this.getSidebarElement();
          const updateCount = this.pendingUpdates.size;
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [SidebarPerformanceCoordinator] Flushing ${updateCount} updates atomically`
            );
          }
          if (updateCount > (this.config.maxBatchSize || 50)) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceCoordinator] Large batch detected (${updateCount} updates), may impact performance`
            );
          }
          try {
            const sidebarVariables = {};
            const globalHarmonicVariables = {};
            for (const update of this.pendingUpdates.values()) {
              sidebarVariables[update.property] = update.value;
              const harmonicVar = this.harmonicVariableMap.get(update.property);
              if (harmonicVar) {
                globalHarmonicVariables[harmonicVar] = update.value;
                if (this.config.enableDebug) {
                  console.log(
                    `\u{1F30C} [SidebarPerformanceCoordinator] Mapped ${update.property} \u2192 ${harmonicVar} = ${update.value}`
                  );
                }
              }
            }
            if (Object.keys(sidebarVariables).length > 0) {
              const sidebarElement = targetElement;
              for (const [property, value] of Object.entries(sidebarVariables)) {
                sidebarElement.style.setProperty(property, value);
              }
            }
            if (Object.keys(globalHarmonicVariables).length > 0) {
              this.cssController.batchSetVariables(
                "SidebarPerformanceCoordinator",
                globalHarmonicVariables,
                "high",
                // High priority for harmonic variable mapping
                "harmonic-variable-mapping"
              );
            }
          } catch (error) {
            console.error(
              `\u{1F30C} [SidebarPerformanceCoordinator] Failed to apply batched updates:`,
              error
            );
          }
          this.pendingUpdates.clear();
          this.isFlushScheduled = false;
          this.rafId = null;
          if (this.config.onFlushComplete) {
            try {
              this.config.onFlushComplete();
            } catch (error) {
              console.error(
                "\u{1F30C} [SidebarPerformanceCoordinator] Error in flush completion callback:",
                error
              );
            }
          }
          const endTime = performance.now();
          const flushTime = endTime - startTime;
          this.flushCount++;
          this.totalFlushTime += flushTime;
          this.lastFlushTimestamp = endTime;
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.emitTrace?.(
              `[SidebarPerformanceCoordinator] Flushed ${updateCount} updates in ${flushTime.toFixed(
                2
              )}ms`
            );
          }
          const avgFlushTime = this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0;
          if (avgFlushTime > 3) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceCoordinator] Performance threshold exceeded: average ${avgFlushTime.toFixed(
                2
              )}ms per flush (target: <3ms)`
            );
          }
          if (this.config.enableDebug && flushTime > 4) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceCoordinator] Slow flush detected: ${flushTime.toFixed(
                2
              )}ms for ${updateCount} updates`
            );
          }
        }
        /**
         * Setup event-driven music change coordination
         * This replaces pure DOM watching to prevent cascade loops
         */
        setupMusicChangeCoordination() {
          if (this.musicChangeUnsubscribe) {
            return;
          }
          this.musicChangeUnsubscribe = () => {
            unifiedEventBus.unsubscribeAll("SidebarPerformanceCoordinator");
          };
          unifiedEventBus.subscribe("music:track-changed", (data) => {
            this.handleMusicChange({
              timestamp: data.timestamp,
              source: "track-changed",
              reason: "music:track-changed event"
            });
          }, "SidebarPerformanceCoordinator");
          if (this.config.enableDebug) {
            console.log("\u{1F30C} [SidebarPerformanceCoordinator] Event-driven music coordination active");
          }
        }
        /**
         * Handle music change events from the global event bus
         */
        handleMusicChange(eventData) {
          if (this.sidebarElement) {
            this.handleVisibilityChange();
            if (this.config.enableDebug) {
              console.log("\u{1F30C} [SidebarPerformanceCoordinator] Music change coordinated via event", {
                source: eventData.source,
                reason: eventData.reason,
                timestamp: eventData.timestamp
              });
            }
          }
        }
        /**
         * Setup DOM observation for reactive refresh and temporal play
         */
        setupDOMObservation() {
          if (this.domObserver) {
            return;
          }
          this.setupMusicChangeCoordination();
          this.sidebarElement = document.querySelector(
            MODERN_SELECTORS.rightSidebar
          );
          if (!this.sidebarElement) {
            if (this.config.enableDebug) {
              console.warn(
                "\u{1F30C} [SidebarPerformanceCoordinator] Sidebar not found, deferring DOM observation"
              );
            }
            if (this.domObservationRetryTimeout) {
              clearTimeout(this.domObservationRetryTimeout);
              this.activeTimeouts.delete(this.domObservationRetryTimeout);
            }
            this.domObservationRetryTimeout = setTimeout(() => {
              this.setupDOMObservation();
              this.domObservationRetryTimeout = null;
            }, 1e3);
            this.activeTimeouts.add(this.domObservationRetryTimeout);
            return;
          }
          this.domObserver = new MutationObserver((mutations) => {
            const relevantMutations = mutations.filter((mutation) => this.isRelevantMutation(mutation));
            if (relevantMutations.length === 0) {
              return;
            }
            this.throttleObservationUpdate(() => {
              for (const mutation of relevantMutations) {
                if (mutation.type === "attributes" && (mutation.attributeName === "aria-hidden" || mutation.attributeName === "style")) {
                  this.handleVisibilityChange();
                }
              }
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F30C} [SidebarPerformanceCoordinator] Relevant DOM change detected - visibility/structure only",
                  { mutationCount: relevantMutations.length, types: relevantMutations.map((m) => m.type) }
                );
              }
            });
          });
          this.domObserver.observe(this.sidebarElement, {
            childList: true,
            subtree: false,
            // Optimize: Only observe direct children to reduce mutation volume
            attributes: true,
            // Watch for visibility and style changes
            attributeFilter: ["aria-hidden", "style", "class"],
            // Only observe attributes we care about
            attributeOldValue: false,
            // Optimize: Don't observe attribute old values
            characterData: false
            // Don't observe text changes
          });
          this.setupVisibilityObserver();
          this.setupScrollObservation();
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceCoordinator] DOM observation active on sidebar"
            );
          }
        }
        /**
         * Setup visibility observer for temporal echo effects
         */
        setupVisibilityObserver() {
          if (!this.sidebarElement || this.visibilityObserver) return;
          this.visibilityObserver = new IntersectionObserver(
            (entries) => {
              const entry = entries[0];
              if (entry && entry.isIntersecting && this.isFirstOpen) {
                if (window.requestIdleCallback) {
                  window.requestIdleCallback(() => {
                    this.triggerTemporalEcho();
                    this.isFirstOpen = false;
                  });
                } else {
                  setTimeout(() => {
                    this.triggerTemporalEcho();
                    this.isFirstOpen = false;
                  }, 0);
                }
              }
            },
            { threshold: 0.1 }
          );
          this.visibilityObserver.observe(this.sidebarElement);
        }
        /**
         * Setup scroll observation with throttling for performance
         */
        setupScrollObservation() {
          if (!this.sidebarElement) return;
          const queueElement = this.sidebarElement.querySelector(
            ".main-nowPlayingView-queue"
          );
          if (!queueElement) return;
          queueElement.addEventListener(
            "scroll",
            this.throttledScrollHandler.bind(this),
            {
              passive: true
            }
          );
        }
        /**
         * Throttled scroll handler (30 Hz as specified)
         */
        throttledScrollHandler() {
          const now = performance.now();
          if (now - this.lastScrollUpdate < 33) return;
          this.lastScrollUpdate = now;
          if (window.requestIdleCallback) {
            window.requestIdleCallback(() => {
              this.queueUpdate("--sn-rs-scroll-ratio", Math.random().toString());
            }, { timeout: 100 });
          } else {
            this.queueUpdate("--sn-rs-scroll-ratio", Math.random().toString());
          }
        }
        /**
         * Filter mutations to only process changes that actually affect UI structure or visibility
         * Prevents cascade loops from CSS variable updates and other non-visual changes
         */
        isRelevantMutation(mutation) {
          if (mutation.type === "attributes") {
            const attrName = mutation.attributeName;
            if (attrName === "aria-hidden" || attrName === "style") {
              return true;
            }
            if (attrName === "class") {
              return true;
            }
            if (attrName?.startsWith("--") || attrName === "data-style") {
              return false;
            }
            return false;
          }
          if (mutation.type === "childList") {
            const hasElementChanges = mutation.addedNodes && Array.from(mutation.addedNodes).some((node) => node.nodeType === Node.ELEMENT_NODE) || mutation.removedNodes && Array.from(mutation.removedNodes).some((node) => node.nodeType === Node.ELEMENT_NODE);
            return hasElementChanges;
          }
          return false;
        }
        /**
         * Throttle DOM observation updates to reduce CPU overhead
         */
        throttleObservationUpdate(callback) {
          const now = performance.now();
          if (now - this.lastObservationTime < this.OBSERVATION_THROTTLE_MS) {
            if (this.observationThrottleTimer) {
              clearTimeout(this.observationThrottleTimer);
            }
            this.observationThrottleTimer = window.setTimeout(() => {
              callback();
              this.lastObservationTime = performance.now();
              this.observationThrottleTimer = null;
            }, this.OBSERVATION_THROTTLE_MS);
          } else {
            callback();
            this.lastObservationTime = now;
          }
        }
        /**
         * Handle visibility changes for temporal effects
         */
        handleVisibilityChange() {
          if (!this.sidebarElement) return;
          const isVisible = !this.sidebarElement.hasAttribute("aria-hidden") && !this.sidebarElement.style.display?.includes(
            "none"
          );
          if (isVisible && this.isFirstOpen) {
            this.triggerTemporalEcho();
            this.isFirstOpen = false;
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [SidebarPerformanceCoordinator] Visibility changed: ${isVisible ? "visible" : "hidden"}`
            );
          }
        }
        /**
         * Trigger one-time temporal echo effect
         */
        triggerTemporalEcho() {
          if (!this.sidebarElement) return;
          this.sidebarElement.classList.add("sn-future-preview");
          this.queueUpdate("--sn-kinetic-intensity", "1");
          this.queueUpdate("--sn-echo-hue-shift", "15deg");
          this.queueUpdate("--sn-echo-radius-multiplier", "1.2");
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceCoordinator] Triggering temporal echo effect"
            );
          }
          const cleanupTimeout = setTimeout(() => {
            this.sidebarElement?.classList.remove("sn-future-preview");
            this.queueUpdate("--sn-kinetic-intensity", "0");
            this.activeTimeouts.delete(cleanupTimeout);
          }, 2e3);
          this.activeTimeouts.add(cleanupTimeout);
        }
        /**
         * Get performance metrics for monitoring
         */
        getPerformanceMetrics() {
          return {
            flushCount: this.flushCount,
            averageFlushTime: this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0,
            lastFlushTimestamp: this.lastFlushTimestamp,
            pendingUpdates: this.pendingUpdates.size
          };
        }
        /**
         * Force immediate flush for critical scenarios
         */
        forceFlush() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
          this.flushUpdates();
        }
        /**
         * Cleanup and destroy coordinator
         */
        destroy() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
          this.activeTimeouts.forEach((timeout) => {
            clearTimeout(timeout);
          });
          this.activeTimeouts.clear();
          if (this.domObservationRetryTimeout) {
            clearTimeout(this.domObservationRetryTimeout);
            this.domObservationRetryTimeout = null;
          }
          if (this.observationThrottleTimer) {
            clearTimeout(this.observationThrottleTimer);
            this.observationThrottleTimer = null;
          }
          if (this.domObserver) {
            this.domObserver.disconnect();
            this.domObserver = null;
          }
          if (this.visibilityObserver) {
            this.visibilityObserver.disconnect();
            this.visibilityObserver = null;
          }
          if (this.musicChangeUnsubscribe) {
            this.musicChangeUnsubscribe();
            this.musicChangeUnsubscribe = null;
          }
          this.pendingUpdates.clear();
          this.isFlushScheduled = false;
          this.sidebarElement = null;
          if (_SidebarPerformanceCoordinator.instance === this) {
            _SidebarPerformanceCoordinator.instance = null;
          }
          if (this.config.enableDebug) {
            const avgFlushTime = this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0;
            console.log(
              `\u{1F30C} [SidebarPerformanceCoordinator] Destroyed. Performance: ${this.flushCount} flushes, ${avgFlushTime.toFixed(2)}ms avg`
            );
          }
        }
      };
      __name(_SidebarPerformanceCoordinator, "SidebarPerformanceCoordinator");
      _SidebarPerformanceCoordinator.instance = null;
      SidebarPerformanceCoordinator = _SidebarPerformanceCoordinator;
      __name(getSidebarPerformanceCoordinator, "getSidebarPerformanceCoordinator");
    }
  });

  // src-js/core/integration/SidebarSystemsIntegration.ts
  var _MockLeftSidebarConsciousnessSystem, MockLeftSidebarConsciousnessSystem, _MockRightSidebarConsciousnessSystem, MockRightSidebarConsciousnessSystem, _MockSidebarSystemsOrchestrator, MockSidebarSystemsOrchestrator, _SidebarSystemsIntegration, SidebarSystemsIntegration;
  var init_SidebarSystemsIntegration = __esm({
    "src-js/core/integration/SidebarSystemsIntegration.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_SidebarInteractiveFlowSystem();
      init_SidebarPerformanceCoordinator();
      init_globalConfig();
      _MockLeftSidebarConsciousnessSystem = class _MockLeftSidebarConsciousnessSystem extends UnifiedSystemBase {
        async initialize() {
          console.log("[MockLeftSidebarConsciousnessSystem] Initialized");
        }
        destroy() {
          console.log("[MockLeftSidebarConsciousnessSystem] Destroyed");
        }
        onAnimate(deltaTime) {
        }
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "Mock left sidebar consciousness healthy",
            issues: [],
            system: "MockLeftSidebarConsciousnessSystem"
          };
        }
        getConsciousnessState() {
          return { level: "aware", intensity: 0.5 };
        }
        getAnimationMetrics() {
          return { beatIntensity: 0.5, explorationLevel: 0.3 };
        }
      };
      __name(_MockLeftSidebarConsciousnessSystem, "MockLeftSidebarConsciousnessSystem");
      MockLeftSidebarConsciousnessSystem = _MockLeftSidebarConsciousnessSystem;
      _MockRightSidebarConsciousnessSystem = class _MockRightSidebarConsciousnessSystem extends UnifiedSystemBase {
        async initialize() {
          console.log("[MockRightSidebarConsciousnessSystem] Right sidebar now handled by facade pattern");
        }
        destroy() {
          console.log("[MockRightSidebarConsciousnessSystem] Destroyed");
        }
        onAnimate(deltaTime) {
        }
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "Right sidebar consciousness managed by facade pattern",
            issues: [],
            system: "MockRightSidebarConsciousnessSystem"
          };
        }
        getConsciousnessState() {
          const year3000System2 = globalThis.year3000System;
          if (year3000System2?.sidebarConsciousnessController) {
            return year3000System2.sidebarConsciousnessController.getConsciousnessState();
          }
          return { level: "aware", intensity: 0.5 };
        }
        getAnimationMetrics() {
          return { beatIntensity: 0.5, explorationLevel: 0.3 };
        }
      };
      __name(_MockRightSidebarConsciousnessSystem, "MockRightSidebarConsciousnessSystem");
      MockRightSidebarConsciousnessSystem = _MockRightSidebarConsciousnessSystem;
      _MockSidebarSystemsOrchestrator = class _MockSidebarSystemsOrchestrator extends UnifiedSystemBase {
        constructor() {
          super(...arguments);
          this.synchronizationEnabled = true;
          this.rightSidebarSystem = null;
        }
        async initialize() {
          console.log("[MockSidebarSystemsOrchestrator] Initialized");
        }
        destroy() {
          console.log("[MockSidebarSystemsOrchestrator] Destroyed");
        }
        onAnimate(deltaTime) {
        }
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "Mock sidebar orchestrator healthy",
            issues: [],
            system: "MockBilateralSidebarOrchestrator"
          };
        }
        getBilateralState() {
          return {
            leftSidebar: { active: true, level: "aware" },
            rightSidebar: { active: !!this.rightSidebarSystem, level: "aware" },
            synchronization: { enabled: this.synchronizationEnabled }
          };
        }
        getPerformanceMetrics() {
          return {
            bilateralSyncMetrics: { syncEvents: 100, avgSyncLatency: 5 },
            performanceMetrics: { totalCSSUpdates: 200, avgUpdateTime: 2 }
          };
        }
        setSynchronizationEnabled(enabled) {
          this.synchronizationEnabled = enabled;
        }
        setRightSidebarSystem(system) {
          this.rightSidebarSystem = system;
        }
      };
      __name(_MockSidebarSystemsOrchestrator, "MockSidebarSystemsOrchestrator");
      MockSidebarSystemsOrchestrator = _MockSidebarSystemsOrchestrator;
      _SidebarSystemsIntegration = class _SidebarSystemsIntegration extends UnifiedSystemBase {
        constructor(config = YEAR3000_CONFIG) {
          super(config);
          // System registry
          this.sidebarSystems = /* @__PURE__ */ new Map();
          // Integration state
          this.integrationEnabled = false;
          // Animation frame tracking
          this.lastFrameTime = 0;
          this.sharedCoordinator = SidebarPerformanceCoordinator.getInstance({
            enableDebug: config.enableDebug,
            performanceAnalyzer: this.performanceAnalyzer,
            onFlushComplete: /* @__PURE__ */ __name(() => this.handlePerformanceFlush(), "onFlushComplete")
          });
          this.leftSidebarConsciousness = new MockLeftSidebarConsciousnessSystem(config);
          this.rightSidebarConsciousness = new MockRightSidebarConsciousnessSystem(config);
          this.sidebarOrchestrator = new MockSidebarSystemsOrchestrator(config);
          this.interactiveFlow = new SidebarInteractiveFlowSystem(config);
          this.performanceMetrics = {
            totalSystems: 4,
            activeSystems: 0,
            bilateralSyncEnabled: false,
            averageFrameTime: 0,
            totalMemoryUsage: 0,
            healthStatus: "healthy"
          };
          if (config.enableDebug) {
            console.log(`[${this.systemName}] Initialized sidebar systems integration`);
          }
        }
        /**
         * Initialize all sidebar systems in proper order
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing sidebar systems integration`);
          }
          try {
            this.registerSidebarSystems();
            await this.registerWithUnifiedRegistry();
            await this.initializeSystemsInOrder();
            this.setupBilateralCoordination();
            this.connectToEventBus();
            this.integrateWithPerformanceSystems();
            this.registerAnimation(70);
            this.integrationEnabled = true;
            this.updatePerformanceMetrics();
            this.publishEvent("sidebar:integration-ready", {
              systemName: this.systemName,
              totalSystems: this.sidebarSystems.size,
              activeSystems: this.performanceMetrics.activeSystems,
              bilateralSync: this.performanceMetrics.bilateralSyncEnabled,
              timestamp: Date.now()
            });
          } catch (error) {
            console.error(`[${this.systemName}] Integration initialization failed:`, error);
            throw error;
          }
        }
        /**
         * Register all sidebar system definitions
         */
        registerSidebarSystems() {
          this.sidebarSystems.set("leftSidebarConsciousness", {
            name: "leftSidebarConsciousness",
            system: this.leftSidebarConsciousness,
            priority: "normal",
            enabled: true,
            dependencies: []
          });
          this.sidebarSystems.set("rightSidebarConsciousness", {
            name: "rightSidebarConsciousness",
            system: this.rightSidebarConsciousness,
            priority: "normal",
            enabled: true,
            dependencies: []
          });
          this.sidebarSystems.set("sidebarOrchestrator", {
            name: "sidebarOrchestrator",
            system: this.sidebarOrchestrator,
            priority: "critical",
            enabled: true,
            dependencies: ["leftSidebarConsciousness", "rightSidebarConsciousness"]
          });
          this.sidebarSystems.set("interactiveFlow", {
            name: "interactiveFlow",
            system: this.interactiveFlow,
            priority: "background",
            enabled: true,
            dependencies: ["sidebarOrchestrator"]
          });
        }
        /**
         * Initialize systems in dependency order
         */
        async initializeSystemsInOrder() {
          const initializationOrder = this.calculateInitializationOrder();
          for (const systemName of initializationOrder) {
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.enabled) {
              try {
                await systemDef.system._baseInitialize();
                this.performanceMetrics.activeSystems++;
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Initialized ${systemName}`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to initialize ${systemName}:`, error);
              }
            }
          }
        }
        /**
         * Calculate system initialization order based on dependencies
         */
        calculateInitializationOrder() {
          const visited = /* @__PURE__ */ new Set();
          const visiting = /* @__PURE__ */ new Set();
          const order = [];
          const visit = /* @__PURE__ */ __name((systemName) => {
            if (visiting.has(systemName)) {
              throw new Error(`Circular dependency detected: ${systemName}`);
            }
            if (visited.has(systemName)) return;
            visiting.add(systemName);
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.dependencies) {
              for (const dep of systemDef.dependencies) {
                visit(dep);
              }
            }
            visiting.delete(systemName);
            visited.add(systemName);
            order.push(systemName);
          }, "visit");
          for (const systemName of this.sidebarSystems.keys()) {
            visit(systemName);
          }
          return order;
        }
        /**
         * Set up bilateral consciousness coordination
         */
        setupBilateralCoordination() {
          this.sidebarOrchestrator.setRightSidebarSystem(this.rightSidebarConsciousness);
          this.sidebarOrchestrator.setSynchronizationEnabled(true);
          this.performanceMetrics.bilateralSyncEnabled = true;
          this.subscribeToEvent("sidebar:bilateral-sync", (payload) => {
            this.handleBilateralSync(payload);
          });
          this.subscribeToEvent("sidebar:consciousness-level-changed", (payload) => {
            this.handleConsciousnessChange(payload);
          });
        }
        /**
         * Handle bilateral synchronization events
         */
        handleBilateralSync(payload) {
          if (payload.source === "orchestrator") {
            this.updatePerformanceMetrics();
          }
        }
        /**
         * Handle consciousness level changes
         */
        handleConsciousnessChange(payload) {
          const consciousnessLevels = {
            dormant: 0.5,
            aware: 0.7,
            focused: 0.9,
            transcendent: 1
          };
          const performanceLevel = consciousnessLevels[payload.newLevel] || 0.7;
          this.adjustPerformanceBudgets(performanceLevel);
        }
        /**
         * Adjust performance budgets based on consciousness level
         */
        adjustPerformanceBudgets(level) {
          const baseBudget = 16;
          const adjustedBudget = Math.floor(baseBudget * level);
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Adjusted performance budget to ${adjustedBudget} based on consciousness level`);
          }
        }
        /**
         * Handle performance flush completion
         */
        handlePerformanceFlush() {
          const currentTime = performance.now();
          if (this.lastFrameTime > 0) {
            const frameTime = currentTime - this.lastFrameTime;
            this.performanceMetrics.averageFrameTime = (this.performanceMetrics.averageFrameTime + frameTime) / 2;
          }
          this.lastFrameTime = currentTime;
          this.updateHealthStatus();
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics() {
          this.performanceMetrics.totalSystems = this.sidebarSystems.size;
          let activeSystems = 0;
          for (const [, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              activeSystems++;
            }
          }
          this.performanceMetrics.activeSystems = activeSystems;
          this.performanceMetrics.bilateralSyncEnabled = this.sidebarOrchestrator.getBilateralState().synchronization.enabled;
        }
        /**
         * Update health status based on performance metrics
         */
        updateHealthStatus() {
          if (this.performanceMetrics.averageFrameTime > 20) {
            this.performanceMetrics.healthStatus = "critical";
          } else if (this.performanceMetrics.averageFrameTime > 16.67) {
            this.performanceMetrics.healthStatus = "degraded";
          } else {
            this.performanceMetrics.healthStatus = "healthy";
          }
        }
        /**
         * Animation frame callback
         */
        onAnimate(deltaTime) {
          if (!this.integrationEnabled) return;
          this.updatePerformanceMetrics();
          this.updateHealthStatus();
          const currentTime = performance.now();
          if (currentTime - this.lastFrameTime > 1e3) {
            this.publishEvent("sidebar:integration-metrics", {
              metrics: this.performanceMetrics,
              timestamp: Date.now()
            });
          }
        }
        /**
         * Register all sidebar systems with Year3000System animation coordinator
         */
        registerWithAnimationCoordinator(animationCoordinator) {
          if (!animationCoordinator) {
            console.warn(`[${this.systemName}] Animation coordinator not available`);
            return;
          }
          for (const [systemName, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              try {
                animationCoordinator.registerAnimationSystem(
                  systemName,
                  systemDef.system,
                  systemDef.priority,
                  60
                  // Default FPS
                );
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Registered ${systemName} with animation coordinator`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to register ${systemName}:`, error);
              }
            }
          }
        }
        /**
         * Get all sidebar systems for external access
         */
        getSidebarSystems() {
          return new Map(this.sidebarSystems);
        }
        /**
         * Get performance metrics
         */
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Enable/disable specific sidebar system
         */
        setSidebarSystemEnabled(systemName, enabled) {
          const systemDef = this.sidebarSystems.get(systemName);
          if (systemDef) {
            systemDef.enabled = enabled;
            if (!enabled && systemDef.system.isInitialized) {
              systemDef.system._baseDestroy();
              this.performanceMetrics.activeSystems--;
            } else if (enabled && !systemDef.system.isInitialized) {
              systemDef.system._baseInitialize().catch((error) => {
                console.error(`[${this.systemName}] Failed to re-enable ${systemName}:`, error);
              });
            }
            this.publishEvent("sidebar:system-toggled", {
              systemName,
              enabled,
              timestamp: Date.now()
            });
          }
        }
        /**
         * System health check
         */
        async healthCheck() {
          const systemHealthChecks = {};
          for (const [systemName, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              try {
                systemHealthChecks[systemName] = await systemDef.system.healthCheck();
              } catch (error) {
                systemHealthChecks[systemName] = {
                  healthy: false,
                  ok: false,
                  details: `Health check failed: ${error.message}`,
                  issues: [`Health check failed: ${error.message}`],
                  system: systemName
                };
              }
            }
          }
          const unhealthySystems = Object.values(systemHealthChecks).filter((check) => !check.ok);
          const isHealthy = unhealthySystems.length === 0;
          return {
            healthy: isHealthy,
            ok: isHealthy,
            details: `Sidebar integration ${isHealthy ? "healthy" : "degraded"} - ${this.performanceMetrics.activeSystems}/${this.performanceMetrics.totalSystems} systems active, bilateral sync: ${this.performanceMetrics.bilateralSyncEnabled}`,
            issues: unhealthySystems.map((check) => check.details || "Unknown issue"),
            system: "SidebarSystemsIntegration"
          };
        }
        /**
         * Phase 3: Register sidebar systems with facade (UnifiedSystemRegistry is deprecated)
         */
        async registerWithUnifiedRegistry() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Sidebar systems are now managed by VisualSystemFacade`);
          }
        }
        /**
         * Phase 3: Connect to EventBus for system-wide communication
         */
        connectToEventBus() {
          this.subscribeToEvent("music:beat", (payload) => {
            this.handleMusicBeat(payload);
          });
          this.subscribeToEvent("music:energy", (payload) => {
            this.handleMusicEnergy(payload);
          });
          this.subscribeToEvent("performance:threshold-exceeded", (payload) => {
            this.handlePerformanceThreshold(payload);
          });
          this.subscribeToEvent("user:navigation", (payload) => {
            this.handleUserNavigation(payload);
          });
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Connected to EventBus for system-wide communication`);
          }
        }
        /**
         * Phase 3: Integrate with TimerConsolidationSystem and MasterAnimationCoordinator
         */
        integrateWithPerformanceSystems() {
          const year3000System2 = globalThis.year3000System;
          if (!year3000System2) {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Year3000System not available, skipping performance integration`);
            }
            return;
          }
          try {
            const timerSystem = year3000System2.timerConsolidationSystem;
            if (timerSystem) {
              timerSystem.registerTimer("sidebar-performance-monitor", 1e3, () => {
                this.updatePerformanceMetrics();
              });
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Integrated with TimerConsolidationSystem`);
              }
            }
            const animationCoordinator = year3000System2.enhancedMasterAnimationCoordinator;
            if (animationCoordinator) {
              animationCoordinator.registerFrameCallback(
                (deltaTime, timestamp) => {
                  this.bilateralConsciousnessFrameUpdate(deltaTime, timestamp);
                },
                "critical",
                "sidebar-bilateral-consciousness"
              );
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Integrated with EnhancedMasterAnimationCoordinator`);
              }
            }
          } catch (error) {
            console.error(`[${this.systemName}] Failed to integrate with performance systems:`, error);
          }
        }
        /**
         * Handle music beat events for consciousness synchronization
         */
        handleMusicBeat(payload) {
          if (!this.integrationEnabled) return;
          const beatData = {
            intensity: payload.intensity || 0.5,
            timestamp: payload.timestamp || Date.now(),
            bpm: payload.bpm || 120
          };
          this.sidebarOrchestrator.getBilateralState();
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Processed music beat:`, beatData);
          }
        }
        /**
         * Handle music energy changes for adaptive consciousness
         */
        handleMusicEnergy(payload) {
          if (!this.integrationEnabled) return;
          const energyLevel = payload.energy || 0.5;
          this.adjustPerformanceBudgets(0.5 + energyLevel * 0.5);
          if (this.interactiveFlow.isInitialized) {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Adapted consciousness to energy level: ${energyLevel}`);
            }
          }
        }
        /**
         * Handle performance threshold events
         */
        handlePerformanceThreshold(payload) {
          if (!this.integrationEnabled) return;
          if (payload.severity === "critical") {
            this.setSidebarSystemEnabled("interactiveFlow", false);
            this.performanceMetrics.healthStatus = "critical";
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Activated emergency performance mode`);
            }
          } else if (payload.severity === "warning" && this.performanceMetrics.healthStatus === "critical") {
            setTimeout(() => {
              this.setSidebarSystemEnabled("interactiveFlow", true);
            }, 2e3);
            this.performanceMetrics.healthStatus = "degraded";
          }
        }
        /**
         * Handle user navigation events for predictive consciousness
         */
        handleUserNavigation(payload) {
          if (!this.integrationEnabled) return;
          const navigationContext = {
            action: payload.action || "navigate",
            target: payload.target || "unknown",
            timestamp: payload.timestamp || Date.now()
          };
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Processing navigation context:`, navigationContext);
          }
        }
        /**
         * Bilateral consciousness frame update callback
         */
        bilateralConsciousnessFrameUpdate(deltaTime, timestamp) {
          if (!this.integrationEnabled) return;
          const leftState = this.leftSidebarConsciousness.getConsciousnessState();
          const rightState = this.rightSidebarConsciousness.getConsciousnessState();
          const leftTimestamp = timestamp;
          const rightTimestamp = timestamp;
          const syncMetrics = {
            leftLevel: leftState.level,
            rightLevel: rightState.level,
            timingDelta: Math.abs(leftTimestamp - rightTimestamp),
            frameTime: deltaTime
          };
          if (syncMetrics.timingDelta > 16.67) {
            this.publishEvent("sidebar:bilateral-desync-warning", {
              delta: syncMetrics.timingDelta,
              frameTime: deltaTime,
              timestamp
            });
          }
        }
        /**
         * Clean up all sidebar systems
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying sidebar systems integration`);
          }
          this.integrationEnabled = false;
          const year3000System2 = globalThis.year3000System;
          if (year3000System2?.timerConsolidationSystem) {
            year3000System2.timerConsolidationSystem.unregisterTimer("sidebar-performance-monitor");
          }
          const destructionOrder = this.calculateInitializationOrder().reverse();
          for (const systemName of destructionOrder) {
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.system.isInitialized) {
              try {
                systemDef.system._baseDestroy();
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Destroyed ${systemName}`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to destroy ${systemName}:`, error);
              }
            }
          }
          this.sidebarSystems.clear();
          this.performanceMetrics = {
            totalSystems: 0,
            activeSystems: 0,
            bilateralSyncEnabled: false,
            averageFrameTime: 0,
            totalMemoryUsage: 0,
            healthStatus: "healthy"
          };
          this.publishEvent("sidebar:integration-destroyed", {
            timestamp: Date.now()
          });
        }
      };
      __name(_SidebarSystemsIntegration, "SidebarSystemsIntegration");
      SidebarSystemsIntegration = _SidebarSystemsIntegration;
    }
  });

  // src-js/types/systemCreationStrategy.ts
  var _SystemCreationError, SystemCreationError, _DependencyValidationError, DependencyValidationError, _StrategySelectionError, StrategySelectionError;
  var init_systemCreationStrategy = __esm({
    "src-js/types/systemCreationStrategy.ts"() {
      "use strict";
      _SystemCreationError = class _SystemCreationError extends Error {
        constructor(message, systemKey, strategy, context, cause) {
          super(message);
          this.systemKey = systemKey;
          this.strategy = strategy;
          this.context = context;
          this.cause = cause;
          this.name = "SystemCreationError";
        }
      };
      __name(_SystemCreationError, "SystemCreationError");
      SystemCreationError = _SystemCreationError;
      _DependencyValidationError = class _DependencyValidationError extends SystemCreationError {
        constructor(systemKey, strategy, missingDependencies, context) {
          super(
            `Missing required dependencies for ${systemKey}: ${missingDependencies.join(", ")}`,
            systemKey,
            strategy,
            context
          );
          this.missingDependencies = missingDependencies;
          this.name = "DependencyValidationError";
        }
      };
      __name(_DependencyValidationError, "DependencyValidationError");
      DependencyValidationError = _DependencyValidationError;
      _StrategySelectionError = class _StrategySelectionError extends Error {
        constructor(systemKey, criteria, message = `No suitable creation strategy found for system: ${systemKey}`) {
          super(message);
          this.systemKey = systemKey;
          this.criteria = criteria;
          this.name = "StrategySelectionError";
        }
      };
      __name(_StrategySelectionError, "StrategySelectionError");
      StrategySelectionError = _StrategySelectionError;
    }
  });

  // src-js/core/creation/SystemCreationStrategies.ts
  var _BaseCreationStrategy, BaseCreationStrategy, _StandardConstructorStrategy, StandardConstructorStrategy, _EventDrivenCreationStrategy, EventDrivenCreationStrategy, _ObjectDependenciesStrategy, ObjectDependenciesStrategy, _SystemCreationStrategyRegistry, SystemCreationStrategyRegistry, globalSystemCreationRegistry;
  var init_SystemCreationStrategies = __esm({
    "src-js/core/creation/SystemCreationStrategies.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_systemCreationStrategy();
      _BaseCreationStrategy = class _BaseCreationStrategy {
        constructor() {
          this.systemConfigs = /* @__PURE__ */ new Map();
        }
        /**
         * Validate dependencies before creation
         */
        validateDependencies(context) {
          const required = this.getRequiredDependencies(context.systemKey);
          const optional = this.getOptionalDependencies(context.systemKey);
          const missing = [];
          const warnings = [];
          for (const dep of required) {
            if (!(dep in context.dependencies) || !context.dependencies[dep]) {
              missing.push(dep);
            }
          }
          for (const dep of optional) {
            if (!(dep in context.dependencies) || !context.dependencies[dep]) {
              warnings.push(`Optional dependency missing: ${dep}`);
            }
          }
          return {
            valid: missing.length === 0,
            missing,
            warnings
          };
        }
        /**
         * Get required dependencies for system
         */
        getRequiredDependencies(systemKey) {
          const config = this.systemConfigs.get(systemKey);
          return config?.requiredDependencies || [];
        }
        /**
         * Get optional dependencies for system
         */
        getOptionalDependencies(systemKey) {
          const config = this.systemConfigs.get(systemKey);
          return config?.optionalDependencies || [];
        }
        /**
         * Register system configuration
         */
        registerSystemConfig(config) {
          this.systemConfigs.set(config.systemKey, config);
        }
        /**
         * Create base result structure
         */
        createBaseResult(system, context, startTime, error) {
          const endTime = performance.now();
          const creationTime = endTime - startTime;
          return {
            system,
            success: !error && system !== null,
            creationTime,
            strategy: this.getStrategyName(),
            injectedDependencies: Object.keys(context.dependencies),
            warnings: [],
            error: error || void 0,
            metadata: {
              requiresInitialization: true,
              pendingDependencies: [],
              context
            }
          };
        }
      };
      __name(_BaseCreationStrategy, "BaseCreationStrategy");
      BaseCreationStrategy = _BaseCreationStrategy;
      _StandardConstructorStrategy = class _StandardConstructorStrategy extends BaseCreationStrategy {
        constructor() {
          super();
          this.registerKnownSystems();
        }
        getStrategyName() {
          return "StandardConstructor";
        }
        canCreate(context) {
          const config = this.systemConfigs.get(context.systemKey);
          return config !== void 0 && !config.creationPreferences.eventDriven;
        }
        getEstimatedCreationTime(context) {
          return 10;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const validation = this.validateDependencies(context);
            if (!validation.valid && context.preferences.validateDependencies !== false) {
              throw new DependencyValidationError(
                context.systemKey,
                this.getStrategyName(),
                validation.missing,
                context
              );
            }
            const params = this.getConstructorParameters(context);
            const system = new SystemClass(...params);
            const result = this.createBaseResult(system, context, startTime);
            result.warnings = validation.warnings;
            Y3KDebug?.debug?.log(
              "StandardConstructorStrategy",
              `Created ${context.systemKey}`,
              {
                creationTime: result.creationTime,
                parametersUsed: params.length
              }
            );
            return result;
          } catch (error) {
            const result = this.createBaseResult(
              null,
              context,
              startTime,
              error
            );
            Y3KDebug?.debug?.error(
              "StandardConstructorStrategy",
              `Failed to create ${context.systemKey}:`,
              error
            );
            return result;
          }
        }
        /**
         * Get constructor parameters based on system configuration
         */
        getConstructorParameters(context) {
          const config = this.systemConfigs.get(context.systemKey);
          if (!config?.constructorMapping) {
            return this.getStandardParameters(context);
          }
          const params = [];
          const { parameterNames, dependencyMapping } = config.constructorMapping;
          for (const paramName of parameterNames) {
            const depKey = dependencyMapping[paramName] || paramName;
            switch (depKey) {
              case "config":
                params.push(context.config);
                break;
              case "utils":
                params.push(context.utils);
                break;
              case "performanceAnalyzer":
              case "simplePerformanceCoordinator":
                params.push(context.dependencies.simplePerformanceCoordinator || context.dependencies.performanceAnalyzer);
                break;
              case "settingsManager":
                params.push(context.dependencies.settingsManager);
                break;
              case "musicSyncService":
                params.push(context.dependencies.musicSyncService);
                break;
              case "year3000System":
                params.push(context.dependencies.year3000System);
                break;
              case "cssConsciousnessController":
                params.push(context.dependencies.cssConsciousnessController);
                break;
              case "performanceCoordinator":
                params.push(context.dependencies.performanceCoordinator);
                break;
              case "enhancedDeviceTierDetector":
                params.push(context.dependencies.enhancedDeviceTierDetector);
                break;
              case "webglSystemsIntegration":
                params.push(context.dependencies.webglSystemsIntegration);
                break;
              case "deviceCapabilityDetector":
                params.push(context.dependencies.deviceCapabilityDetector);
                break;
              default:
                params.push(void 0);
            }
          }
          return params;
        }
        /**
         * Get standard parameters for systems without explicit configuration
         */
        getStandardParameters(context) {
          return [
            context.config,
            context.utils,
            context.dependencies.simplePerformanceCoordinator || context.dependencies.performanceAnalyzer,
            context.dependencies.musicSyncService,
            context.dependencies.settingsManager,
            context.dependencies.year3000System
          ];
        }
        /**
         * Register known system configurations
         */
        registerKnownSystems() {
          this.registerSystemConfig({
            systemKey: "ColorHarmonyEngine",
            requiredDependencies: [
              "config",
              "utils",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "EnhancedMasterAnimationCoordinator",
            requiredDependencies: ["config", "performanceCoordinator"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "performanceCoordinator"],
              dependencyMapping: {
                config: "config",
                performanceCoordinator: "performanceCoordinator"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedPerformanceCoordinator",
            requiredDependencies: ["config"],
            optionalDependencies: ["simplePerformanceCoordinator"],
            constructorMapping: {
              parameterNames: ["config", "simplePerformanceCoordinator"],
              dependencyMapping: {
                config: "config",
                simplePerformanceCoordinator: "simplePerformanceCoordinator"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          const simpleSystemKeys = [
            "DeviceCapabilityDetector",
            "SettingsManager"
            // NOTE: SimplePerformanceCoordinator removed - replaced with SimplePerformanceCoordinator (see below)
          ];
          for (const systemKey of simpleSystemKeys) {
            this.registerSystemConfig({
              systemKey,
              requiredDependencies: [],
              optionalDependencies: [],
              constructorMapping: {
                parameterNames: [],
                dependencyMapping: {}
              },
              creationPreferences: {
                useSingleton: false,
                lazyInit: false,
                eventDriven: false,
                builderPattern: false
              }
            });
          }
          this.registerSystemConfig({
            systemKey: "TimerConsolidationSystem",
            requiredDependencies: [],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [],
              dependencyMapping: {}
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "GlassmorphismManager",
            requiredDependencies: [
              "config",
              "utils",
              "cssConsciousnessController",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "cssConsciousnessController",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                cssConsciousnessController: "cssConsciousnessController",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "Card3DManager",
            requiredDependencies: ["simplePerformanceCoordinator", "settingsManager", "utils"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["simplePerformanceCoordinator", "settingsManager", "utils"],
              dependencyMapping: {
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager",
                utils: "utils"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedCSSVariableManager",
            requiredDependencies: ["config", "performanceCoordinator"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "performanceCoordinator"],
              dependencyMapping: {
                config: "config",
                performanceCoordinator: "performanceCoordinator"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "SidebarSystemsIntegration",
            requiredDependencies: ["cssConsciousnessController"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["cssConsciousnessController"],
              dependencyMapping: {
                cssConsciousnessController: "cssConsciousnessController"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedSystemIntegration",
            requiredDependencies: ["year3000System"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["year3000System"],
              dependencyMapping: {
                year3000System: "year3000System"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "GenreGradientEvolution",
            requiredDependencies: [
              "config",
              "utils",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "MusicEmotionAnalyzer",
            requiredDependencies: [
              "config",
              "utils",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
          this.registerNewSimplifiedSystems();
        }
        /**
         * Register new simplified performance system configurations
         */
        registerNewSimplifiedSystems() {
          this.registerSystemConfig({
            systemKey: "SimplePerformanceCoordinator",
            requiredDependencies: ["enhancedDeviceTierDetector", "webglSystemsIntegration"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["enhancedDeviceTierDetector", "webglSystemsIntegration"],
              dependencyMapping: {
                enhancedDeviceTierDetector: "enhancedDeviceTierDetector",
                webglSystemsIntegration: "webglSystemsIntegration"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "SimpleTierBasedPerformanceSystem",
            requiredDependencies: ["enhancedDeviceTierDetector"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["enhancedDeviceTierDetector"],
              dependencyMapping: {
                enhancedDeviceTierDetector: "enhancedDeviceTierDetector"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "EnhancedDeviceTierDetector",
            requiredDependencies: [],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [],
              dependencyMapping: {}
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "WebGLSystemsIntegration",
            requiredDependencies: ["deviceCapabilityDetector"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["deviceCapabilityDetector"],
              dependencyMapping: {
                deviceCapabilityDetector: "deviceCapabilityDetector"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
        }
      };
      __name(_StandardConstructorStrategy, "StandardConstructorStrategy");
      StandardConstructorStrategy = _StandardConstructorStrategy;
      _EventDrivenCreationStrategy = class _EventDrivenCreationStrategy extends BaseCreationStrategy {
        constructor() {
          super();
          this.registerEventDrivenSystems();
        }
        getStrategyName() {
          return "EventDriven";
        }
        canCreate(context) {
          const config = this.systemConfigs.get(context.systemKey);
          return config?.creationPreferences.eventDriven === true;
        }
        getEstimatedCreationTime(context) {
          return 50;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const standardStrategy = new StandardConstructorStrategy();
            const standardResult = await standardStrategy.createSystem(
              SystemClass,
              context
            );
            if (!standardResult.success) {
              return standardResult;
            }
            this.setupEventSubscriptions(standardResult.system, context);
            const result = this.createBaseResult(
              standardResult.system,
              context,
              startTime
            );
            result.warnings = standardResult.warnings;
            Y3KDebug?.debug?.log(
              "EventDrivenCreationStrategy",
              `Created ${context.systemKey} with event subscriptions`
            );
            return result;
          } catch (error) {
            const result = this.createBaseResult(
              null,
              context,
              startTime,
              error
            );
            Y3KDebug?.debug?.error(
              "EventDrivenCreationStrategy",
              `Failed to create ${context.systemKey}:`,
              error
            );
            return result;
          }
        }
        /**
         * Setup event subscriptions during creation
         */
        setupEventSubscriptions(system, context) {
          const eventSubscriptions = this.getEventSubscriptions(context.systemKey);
          for (const eventType of eventSubscriptions) {
            const mappedEventType = this.mapEventType(eventType);
            if (typeof system.handleEvent === "function") {
              unifiedEventBus.subscribe(mappedEventType, (event) => {
                system.handleEvent(event);
              }, `SystemCreation-${context.systemKey}`);
            } else if (typeof system.handleColorExtraction === "function" && (eventType === "colors/extracted" || mappedEventType === "colors:extracted")) {
              unifiedEventBus.subscribe(
                mappedEventType,
                system.handleColorExtraction.bind(system),
                `SystemCreation-${context.systemKey}`
              );
            }
          }
          Y3KDebug?.debug?.log(
            "EventDrivenCreationStrategy",
            `Setup event subscriptions for ${context.systemKey}:`,
            eventSubscriptions
          );
        }
        /**
         * Map old event types to new unified event types
         */
        mapEventType(eventType) {
          const eventMap = {
            "colors/extracted": "colors:extracted",
            "colors/harmonized": "colors:harmonized",
            "music/beat": "music:beat",
            "music/energy": "music:energy",
            "music/track-changed": "music:track-changed",
            "performance/mode-changed": "performance:tier-changed",
            "performance/thermal-warning": "performance:frame",
            "settings/changed": "settings:changed"
          };
          return eventMap[eventType] || eventType;
        }
        /**
         * Get events that system will subscribe to
         */
        getEventSubscriptions(systemKey) {
          const eventSubscriptions = {
            ColorHarmonyEngine: ["colors:extracted", "music:track-changed"],
            GenreGradientEvolution: ["music:beat", "music:energy", "music:track-changed"],
            MusicEmotionAnalyzer: ["music:beat", "music:energy", "music:track-changed"]
          };
          return eventSubscriptions[systemKey] || [];
        }
        /**
         * Register event-driven systems with their configurations
         */
        registerEventDrivenSystems() {
          this.registerSystemConfig({
            systemKey: "ColorHarmonyEngine",
            requiredDependencies: [
              "config",
              "utils",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "GenreGradientEvolution",
            requiredDependencies: [
              "config",
              "utils",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "MusicEmotionAnalyzer",
            requiredDependencies: [
              "config",
              "utils",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
        }
      };
      __name(_EventDrivenCreationStrategy, "EventDrivenCreationStrategy");
      EventDrivenCreationStrategy = _EventDrivenCreationStrategy;
      _ObjectDependenciesStrategy = class _ObjectDependenciesStrategy extends BaseCreationStrategy {
        constructor() {
          super();
          this.registerObjectDependencySystems();
        }
        getStrategyName() {
          return "ObjectDependencies";
        }
        canCreate(context) {
          return context.systemKey === "MusicSyncService";
        }
        getEstimatedCreationTime(context) {
          return 30;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const validation = this.validateDependencies(context);
            if (!validation.valid && context.preferences.validateDependencies !== false) {
              throw new DependencyValidationError(
                context.systemKey,
                this.getStrategyName(),
                validation.missing,
                context
              );
            }
            const dependencies = {
              YEAR3000_CONFIG: context.config,
              Year3000Utilities: context.utils,
              settingsManager: context.dependencies.settingsManager,
              year3000System: context.dependencies.year3000System
              // NOTE: colorHarmonyEngine deliberately omitted - using event-driven pattern instead
            };
            const system = new SystemClass(dependencies);
            const result = this.createBaseResult(system, context, startTime);
            result.warnings = validation.warnings;
            result.metadata.pendingDependencies = [];
            Y3KDebug?.debug?.log(
              "ObjectDependenciesStrategy",
              `Created ${context.systemKey} with event-driven dependencies`
            );
            return result;
          } catch (error) {
            const result = this.createBaseResult(
              null,
              context,
              startTime,
              error
            );
            Y3KDebug?.debug?.error(
              "ObjectDependenciesStrategy",
              `Failed to create ${context.systemKey}:`,
              error
            );
            return result;
          }
        }
        /**
         * Register systems that use object dependencies
         */
        registerObjectDependencySystems() {
          this.registerSystemConfig({
            systemKey: "MusicSyncService",
            requiredDependencies: ["config", "utils"],
            optionalDependencies: ["settingsManager", "year3000System"],
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
        }
      };
      __name(_ObjectDependenciesStrategy, "ObjectDependenciesStrategy");
      ObjectDependenciesStrategy = _ObjectDependenciesStrategy;
      _SystemCreationStrategyRegistry = class _SystemCreationStrategyRegistry {
        constructor() {
          this.strategies = /* @__PURE__ */ new Map();
          this.registerDefaultStrategies();
        }
        /**
         * Register a creation strategy
         */
        register(strategy) {
          this.strategies.set(strategy.getStrategyName(), strategy);
          Y3KDebug?.debug?.log(
            "SystemCreationStrategyRegistry",
            `Registered strategy: ${strategy.getStrategyName()}`
          );
        }
        /**
         * Select best strategy for given criteria
         */
        selectStrategy(systemKey, criteria) {
          const candidateStrategies = this.getStrategiesForSystem(systemKey);
          if (candidateStrategies.length === 0) {
            return null;
          }
          let bestStrategy = candidateStrategies[0];
          if (!bestStrategy) {
            return null;
          }
          let bestScore = this.scoreStrategy(bestStrategy, systemKey, criteria);
          for (let i = 1; i < candidateStrategies.length; i++) {
            const strategy = candidateStrategies[i];
            if (!strategy) continue;
            const score = this.scoreStrategy(strategy, systemKey, criteria);
            if (score > bestScore) {
              bestStrategy = strategy;
              bestScore = score;
            }
          }
          return bestStrategy;
        }
        /**
         * Get all registered strategies
         */
        getStrategies() {
          return Array.from(this.strategies.values());
        }
        /**
         * Get strategy by name
         */
        getStrategy(name) {
          return this.strategies.get(name) || null;
        }
        /**
         * Get strategies that can create a specific system
         */
        getStrategiesForSystem(systemKey) {
          const context = {
            systemKey,
            config: {},
            utils: {},
            dependencies: {},
            preferences: {},
            metadata: {
              timestamp: Date.now(),
              reason: "startup",
              priority: "medium"
            }
          };
          return this.getStrategies().filter(
            (strategy) => strategy.canCreate(context)
          );
        }
        /**
         * Score strategy based on selection criteria
         */
        scoreStrategy(strategy, systemKey, criteria) {
          let score = 0;
          score += 10;
          if (criteria.dependencyRequirements === "event-driven") {
            if (strategy.getStrategyName() === "EventDriven") score += 20;
            if (strategy.getStrategyName() === "ObjectDependencies") score += 15;
          } else if (criteria.dependencyRequirements === "basic") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 20;
          }
          if (criteria.performance === "lightweight") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 15;
          } else if (criteria.performance === "optimized") {
            if (strategy.getStrategyName() === "EventDriven") score += 10;
          }
          if (criteria.creationContext === "startup") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 5;
          }
          return score;
        }
        /**
         * Register default strategies
         */
        registerDefaultStrategies() {
          this.register(new StandardConstructorStrategy());
          this.register(new EventDrivenCreationStrategy());
          this.register(new ObjectDependenciesStrategy());
        }
        /**
         * Get registry status
         */
        getStatus() {
          return {
            strategyCount: this.strategies.size,
            strategies: Array.from(this.strategies.keys())
          };
        }
      };
      __name(_SystemCreationStrategyRegistry, "SystemCreationStrategyRegistry");
      SystemCreationStrategyRegistry = _SystemCreationStrategyRegistry;
      globalSystemCreationRegistry = new SystemCreationStrategyRegistry();
    }
  });

  // src-js/core/creation/StrategyBasedFactory.ts
  var _StrategyBasedFactory, StrategyBasedFactory, globalStrategyBasedFactory;
  var init_StrategyBasedFactory = __esm({
    "src-js/core/creation/StrategyBasedFactory.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_systemCreationStrategy();
      init_SystemCreationStrategies();
      _StrategyBasedFactory = class _StrategyBasedFactory {
        constructor(strategyRegistry) {
          this.systemConfigs = /* @__PURE__ */ new Map();
          this.creationMetrics = {
            totalCreations: 0,
            successfulCreations: 0,
            averageCreationTime: 0,
            strategyUsage: {}
          };
          this.strategyRegistry = strategyRegistry || globalSystemCreationRegistry;
          Y3KDebug?.debug?.log(
            "StrategyBasedFactory",
            "Factory initialized with strategy registry"
          );
        }
        /**
         * Create system using best available strategy
         */
        async createSystem(systemKey, SystemClass, context) {
          const startTime = performance.now();
          try {
            this.creationMetrics.totalCreations++;
            const systemConfig = this.getSystemConfig(systemKey);
            const criteria = this.buildSelectionCriteria(
              systemKey,
              systemConfig,
              context
            );
            const strategy = this.strategyRegistry.selectStrategy(
              systemKey,
              criteria
            );
            if (!strategy) {
              throw new StrategySelectionError(systemKey, criteria);
            }
            const strategyName = strategy.getStrategyName();
            this.creationMetrics.strategyUsage[strategyName] = (this.creationMetrics.strategyUsage[strategyName] || 0) + 1;
            const result = await strategy.createSystem(SystemClass, context);
            if (result.success) {
              this.creationMetrics.successfulCreations++;
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            this.updateAverageCreationTime(totalTime);
            Y3KDebug?.debug?.log(
              "StrategyBasedFactory",
              `Created ${systemKey} using ${strategyName}`,
              {
                success: result.success,
                creationTime: result.creationTime,
                totalTime
              }
            );
            return result;
          } catch (error) {
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            Y3KDebug?.debug?.error(
              "StrategyBasedFactory",
              `Failed to create ${systemKey}:`,
              error
            );
            return {
              system: null,
              success: false,
              creationTime: totalTime,
              strategy: "unknown",
              injectedDependencies: [],
              warnings: [],
              error,
              metadata: {
                requiresInitialization: false,
                pendingDependencies: [],
                context
              }
            };
          }
        }
        /**
         * Register system creation configuration
         */
        registerSystemConfig(config) {
          this.systemConfigs.set(config.systemKey, config);
          Y3KDebug?.debug?.log(
            "StrategyBasedFactory",
            `Registered config for ${config.systemKey}`
          );
        }
        /**
         * Get system creation configuration
         */
        getSystemConfig(systemKey) {
          return this.systemConfigs.get(systemKey) || null;
        }
        /**
         * Update creation strategy registry
         */
        setStrategyRegistry(registry2) {
          this.strategyRegistry = registry2;
          Y3KDebug?.debug?.log("StrategyBasedFactory", "Strategy registry updated");
        }
        /**
         * Get factory performance metrics
         */
        getMetrics() {
          return { ...this.creationMetrics };
        }
        /**
         * Reset performance metrics
         */
        resetMetrics() {
          this.creationMetrics = {
            totalCreations: 0,
            successfulCreations: 0,
            averageCreationTime: 0,
            strategyUsage: {}
          };
        }
        // ============================================================================
        // Private Helper Methods
        // ============================================================================
        /**
         * Build selection criteria based on system key and context
         * No longer relies on factory's own systemConfig - strategies manage their own configurations
         */
        buildSelectionCriteria(systemKey, systemConfig, context) {
          let complexity = "medium";
          const simpleSystems = [
            "DeviceCapabilityDetector",
            "PerformanceAnalyzer",
            "UnifiedCSSVariableManager",
            "SettingsManager",
            "TimerConsolidationSystem"
          ];
          const complexSystems = [
            "GlassmorphismManager",
            "Card3DManager",
            "UnifiedCSSVariableManager",
            "EnhancedMasterAnimationCoordinator"
          ];
          if (simpleSystems.includes(systemKey)) {
            complexity = "simple";
          } else if (complexSystems.includes(systemKey)) {
            complexity = "complex";
          }
          let dependencyRequirements = "basic";
          if (systemKey === "MusicSyncService" || systemKey === "ColorHarmonyEngine") {
            dependencyRequirements = "event-driven";
          } else if (simpleSystems.includes(systemKey)) {
            dependencyRequirements = "none";
          }
          let performance2 = "standard";
          if (context.metadata.priority === "critical") {
            performance2 = "optimized";
          } else if (context.preferences.monitorCreation) {
            performance2 = "optimized";
          } else if (complexity === "simple") {
            performance2 = "lightweight";
          }
          return {
            complexity,
            dependencyRequirements,
            performance: performance2,
            resourceConstraints: {
              memoryLimited: context.metadata.resourceConstraints?.maxMemoryMB !== void 0,
              timeLimited: context.metadata.resourceConstraints?.maxInitTimeMs !== void 0,
              cpuLimited: context.metadata.priority === "low"
            },
            creationContext: context.metadata.reason
          };
        }
        /**
         * Update running average creation time
         */
        updateAverageCreationTime(newTime) {
          const totalCreations = this.creationMetrics.totalCreations;
          const currentAverage = this.creationMetrics.averageCreationTime;
          this.creationMetrics.averageCreationTime = (currentAverage * (totalCreations - 1) + newTime) / totalCreations;
        }
        /**
         * Register default system configurations for known systems
         * DEPRECATED: System configurations are now managed by individual strategies
         */
        registerDefaultSystemConfigs() {
        }
      };
      __name(_StrategyBasedFactory, "StrategyBasedFactory");
      StrategyBasedFactory = _StrategyBasedFactory;
      globalStrategyBasedFactory = new StrategyBasedFactory();
    }
  });

  // src-js/core/integration/FacadeAdapter.ts
  var _NonVisualSystemFacadeAdapter, NonVisualSystemFacadeAdapter, globalFacadeAdapter;
  var init_FacadeAdapter = __esm({
    "src-js/core/integration/FacadeAdapter.ts"() {
      "use strict";
      init_StrategyBasedFactory();
      init_UnifiedDebugManager();
      _NonVisualSystemFacadeAdapter = class _NonVisualSystemFacadeAdapter {
        constructor(strategyBasedFactory) {
          this.adapted = false;
          this.originalFacade = null;
          this.migrationProgress = 0;
          this.systemsUsingStrategy = /* @__PURE__ */ new Set();
          this.systemsUsingLegacy = /* @__PURE__ */ new Set();
          this.strategyBasedFactory = strategyBasedFactory || globalStrategyBasedFactory;
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacadeAdapter",
            "Facade adapter initialized"
          );
        }
        /**
         * Adapt facade to use strategy-based creation
         */
        adaptToStrategyPattern(factory) {
          this.strategyBasedFactory = factory;
          this.adapted = true;
          this.migrationProgress = 1;
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacadeAdapter",
            "Facade adapted to strategy pattern"
          );
        }
        /**
         * Get migration status
         */
        getMigrationStatus() {
          return {
            adapted: this.adapted,
            systemsUsingStrategyPattern: Array.from(this.systemsUsingStrategy),
            systemsUsingLegacyPattern: Array.from(this.systemsUsingLegacy),
            migrationProgress: this.migrationProgress
          };
        }
        /**
         * Complete migration to strategy pattern
         */
        async completeMigration() {
          if (!this.adapted) {
            this.adaptToStrategyPattern(this.strategyBasedFactory);
          }
          this.migrationProgress = 1;
          this.systemsUsingLegacy.clear();
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacadeAdapter",
            "Migration to strategy pattern completed"
          );
        }
        /**
         * Create system using strategy-based factory (replaces hardcoded constructor logic)
         */
        async createSystemWithStrategy(systemKey, SystemClass, context) {
          const creationContext = {
            systemKey,
            config: context.config,
            utils: context.utils,
            dependencies: context.dependencies,
            preferences: {
              lazyInit: false,
              validateDependencies: true,
              creationTimeout: 5e3,
              monitorCreation: true
            },
            metadata: {
              timestamp: Date.now(),
              reason: "startup",
              priority: "medium",
              resourceConstraints: {
                maxMemoryMB: 50,
                maxInitTimeMs: 1e3
              }
            }
          };
          try {
            const result = await this.strategyBasedFactory.createSystem(
              systemKey,
              SystemClass,
              creationContext
            );
            if (result.success) {
              this.systemsUsingStrategy.add(systemKey);
              this.systemsUsingLegacy.delete(systemKey);
            } else {
              this.systemsUsingLegacy.add(systemKey);
            }
            this.updateMigrationProgress();
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacadeAdapter",
              `Created ${systemKey} via strategy pattern`,
              {
                strategy: result.strategy,
                success: result.success,
                creationTime: result.creationTime
              }
            );
            return result;
          } catch (error) {
            this.systemsUsingLegacy.add(systemKey);
            this.updateMigrationProgress();
            Y3KDebug?.debug?.error(
              "NonVisualSystemFacadeAdapter",
              `Failed to create ${systemKey} via strategy pattern:`,
              error
            );
            return {
              system: null,
              success: false,
              creationTime: 0,
              strategy: "adapter-fallback",
              injectedDependencies: [],
              warnings: [`Strategy creation failed: ${error}`],
              error,
              metadata: {
                requiresInitialization: false,
                pendingDependencies: [],
                context: creationContext
              }
            };
          }
        }
        /**
         * Legacy compatibility method - creates system using old hardcoded logic
         * This should be gradually phased out as systems migrate to strategy pattern
         */
        createSystemLegacy(systemKey, SystemClass, context) {
          this.systemsUsingLegacy.add(systemKey);
          this.updateMigrationProgress();
          Y3KDebug?.debug?.warn(
            "NonVisualSystemFacadeAdapter",
            `Using legacy creation for ${systemKey} - should migrate to strategy pattern`
          );
          switch (systemKey) {
            case "DeviceCapabilityDetector":
            case "PerformanceAnalyzer":
            case "SettingsManager":
            case "TimerConsolidationSystem":
              return new SystemClass();
            case "SidebarSystemsIntegration":
              return new SystemClass(
                context.dependencies.cssConsciousnessController
              );
            case "OptimizedCSSVariableManager":
              return new SystemClass(
                context.config,
                context.dependencies.performanceCoordinator
              );
            case "ColorHarmonyEngine":
              return new SystemClass(
                context.config,
                context.utils,
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager
              );
            case "EnhancedMasterAnimationCoordinator":
              return new SystemClass(
                context.config,
                context.dependencies.performanceCoordinator
              );
            case "UnifiedPerformanceCoordinator":
              return new SystemClass(
                context.config,
                context.dependencies.performanceAnalyzer
              );
            case "GlassmorphismManager":
              return new SystemClass(
                context.config,
                context.utils,
                context.dependencies.cssConsciousnessController,
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager
              );
            case "Card3DManager":
              return new SystemClass(
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager,
                context.utils
              );
            case "MusicSyncService":
              return new SystemClass({
                YEAR3000_CONFIG: context.config,
                Year3000Utilities: context.utils,
                settingsManager: context.dependencies.settingsManager,
                year3000System: context.year3000System
                // NOTE: colorHarmonyEngine deliberately omitted - using event-driven pattern
              });
            case "EnhancedDeviceTierDetector":
              return SystemClass;
            case "WebGLSystemsIntegration":
              const deviceCapabilityDetector = context.dependencies.deviceCapabilityDetector;
              if (!deviceCapabilityDetector) {
                throw new Error("WebGLSystemsIntegration requires DeviceCapabilityDetector");
              }
              return new SystemClass(deviceCapabilityDetector);
            case "SimplePerformanceCoordinator":
              const enhancedTierDetector = context.dependencies.enhancedDeviceTierDetector;
              const webglIntegration = context.dependencies.webglSystemsIntegration;
              if (!enhancedTierDetector || !webglIntegration) {
                throw new Error("SimplePerformanceCoordinator requires EnhancedDeviceTierDetector and WebGLSystemsIntegration");
              }
              return new SystemClass(enhancedTierDetector, webglIntegration);
            case "SimpleTierBasedPerformanceSystem":
              const tierDetector = context.dependencies.enhancedDeviceTierDetector;
              if (!tierDetector) {
                throw new Error("SimpleTierBasedPerformanceSystem requires EnhancedDeviceTierDetector");
              }
              return new SystemClass(tierDetector);
            default:
              try {
                return new SystemClass();
              } catch (error) {
                return new SystemClass(
                  context.config,
                  context.utils,
                  context.dependencies.performanceAnalyzer,
                  context.dependencies.settingsManager
                );
              }
          }
        }
        /**
         * Update migration progress based on strategy vs legacy usage
         */
        updateMigrationProgress() {
          const totalSystems = this.systemsUsingStrategy.size + this.systemsUsingLegacy.size;
          if (totalSystems === 0) {
            this.migrationProgress = 0;
          } else {
            this.migrationProgress = this.systemsUsingStrategy.size / totalSystems;
          }
        }
        /**
         * Get adapter performance metrics
         */
        getAdapterMetrics() {
          const totalSystems = this.systemsUsingStrategy.size + this.systemsUsingLegacy.size;
          return {
            totalSystemsAdapted: this.systemsUsingStrategy.size,
            strategySuccessRate: totalSystems > 0 ? this.systemsUsingStrategy.size / totalSystems : 0,
            migrationProgress: this.migrationProgress,
            systemBreakdown: {
              strategy: Array.from(this.systemsUsingStrategy),
              legacy: Array.from(this.systemsUsingLegacy)
            }
          };
        }
        /**
         * Force migration of specific system to strategy pattern
         */
        async migrateSystemToStrategy(systemKey) {
          try {
            this.systemsUsingLegacy.delete(systemKey);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacadeAdapter",
              `Migrated ${systemKey} to strategy pattern`
            );
            return true;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "NonVisualSystemFacadeAdapter",
              `Failed to migrate ${systemKey} to strategy pattern:`,
              error
            );
            return false;
          }
        }
        /**
         * Get recommended migration order for systems
         */
        getRecommendedMigrationOrder() {
          const migrationOrder = [
            // Simple systems (no dependencies)
            "PerformanceAnalyzer",
            "OptimizedCSSVariableManager",
            "DeviceCapabilityDetector",
            "SettingsManager",
            // Event-driven systems
            "ColorHarmonyEngine",
            "MusicSyncService",
            // Complex systems
            "UnifiedPerformanceCoordinator",
            "EnhancedMasterAnimationCoordinator",
            // Integration systems
            "UnifiedSystemIntegration",
            // UI systems
            "GlassmorphismManager",
            "Card3DManager"
          ];
          return migrationOrder.filter(
            (system) => this.systemsUsingLegacy.has(system)
          );
        }
      };
      __name(_NonVisualSystemFacadeAdapter, "NonVisualSystemFacadeAdapter");
      NonVisualSystemFacadeAdapter = _NonVisualSystemFacadeAdapter;
      globalFacadeAdapter = new NonVisualSystemFacadeAdapter();
    }
  });

  // src-js/core/integration/NonVisualSystemFacade.ts
  var _NonVisualSystemFacade, NonVisualSystemFacade;
  var init_NonVisualSystemFacade = __esm({
    "src-js/core/integration/NonVisualSystemFacade.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_EnhancedMasterAnimationCoordinator();
      init_OptimizedCSSVariableManager();
      init_TimerConsolidationSystem();
      init_PerformanceAwareLerpCoordinator();
      init_SimplePerformanceCoordinator();
      init_SimpleTierBasedPerformanceSystem();
      init_EnhancedDeviceTierDetector();
      init_WebGLSystemsIntegration();
      init_DeviceCapabilityDetector();
      init_UnifiedPerformanceCoordinator();
      init_PerformanceBudgetManager();
      init_ColorHarmonyEngine();
      init_MusicSyncService();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_GenreGradientEvolution();
      init_VisualEffectsCoordinator();
      init_MusicEmotionAnalyzer();
      init_UnifiedColorProcessingEngine();
      init_ColorOrchestrator();
      init_Card3DManager();
      init_GlassmorphismManager();
      init_SidebarSystemsIntegration();
      init_FacadeAdapter();
      _NonVisualSystemFacade = class _NonVisualSystemFacade {
        constructor(config, utils, year3000System2) {
          // Reference to main system
          // Core shared dependencies (will be injected from main system)
          this.cssConsciousnessController = null;
          this.musicSyncService = null;
          this.settingsManager = null;
          // New simplified performance system dependencies
          this.simplePerformanceCoordinator = null;
          this.webglSystemsIntegration = null;
          this.enhancedDeviceTierDetector = null;
          // Legacy performance system dependencies (deprecated, for backward compatibility)
          this.performanceAnalyzer = null;
          this.performanceCoordinator = null;
          this.performanceOrchestrator = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Monitoring intervals
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Event callbacks
          this.onSystemCreated = null;
          this.onSystemFailed = null;
          this.onHealthChange = null;
          // Strategy-based creation adapter
          this.facadeAdapter = globalFacadeAdapter;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System2;
          if (year3000System2 && typeof year3000System2 === "object" && "performanceAnalyzer" in year3000System2) {
            this.performanceAnalyzer = year3000System2.performanceAnalyzer || null;
            this.cssConsciousnessController = year3000System2.unifiedCSSConsciousnessController || null;
            this.performanceCoordinator = year3000System2.unifiedPerformanceCoordinator || null;
            this.performanceOrchestrator = year3000System2.performanceOrchestrator || null;
            this.musicSyncService = year3000System2.musicSyncService || null;
            this.settingsManager = year3000System2.settingsManager || null;
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Shared dependencies injected from SystemCoordinator",
              {
                performanceAnalyzer: !!this.performanceAnalyzer,
                cssConsciousnessController: !!this.cssConsciousnessController,
                performanceOrchestrator: !!this.performanceOrchestrator,
                musicSyncService: !!this.musicSyncService,
                settingsManager: !!this.settingsManager
              }
            );
          }
          this.systemRegistry = /* @__PURE__ */ new Map();
          this.systemCache = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.facadeConfig = {
            mode: "progressive",
            enablePerformanceMonitoring: true,
            enableDependencyInjection: true,
            enableSystemHealthMonitoring: true,
            performanceThresholds: {
              maxInitTime: 5e3,
              // 5 seconds
              maxMemoryMB: 100,
              maxCPUPercent: 15
            },
            systemPreferences: {
              lazyInitialization: true,
              aggressiveCaching: true,
              performanceOptimization: true
            }
          };
          this.currentMetrics = this.createInitialMetrics();
          this.registerNonVisualSystems();
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacade",
            "Non-visual systems facade initialized"
          );
        }
        registerNonVisualSystems() {
          this.systemRegistry.set(
            "EnhancedMasterAnimationCoordinator",
            EnhancedMasterAnimationCoordinator
          );
          this.systemDependencies.set("EnhancedMasterAnimationCoordinator", [
            "performanceAnalyzer",
            "cssConsciousnessController"
          ]);
          this.systemRegistry.set(
            "TimerConsolidationSystem",
            TimerConsolidationSystem
          );
          this.systemDependencies.set("TimerConsolidationSystem", [
            "performanceAnalyzer"
          ]);
          this.systemRegistry.set(
            "OptimizedCSSVariableManager",
            OptimizedCSSVariableManager
          );
          this.systemDependencies.set("OptimizedCSSVariableManager", [
            "performanceCoordinator"
          ]);
          this.systemRegistry.set(
            "UnifiedCSSVariableManager",
            OptimizedCSSVariableManager
          );
          this.systemDependencies.set("UnifiedCSSVariableManager", [
            "performanceCoordinator"
          ]);
          this.systemRegistry.set(
            "UnifiedPerformanceCoordinator",
            UnifiedPerformanceCoordinator
          );
          this.systemDependencies.set("UnifiedPerformanceCoordinator", []);
          this.systemRegistry.set(
            "DeviceCapabilityDetector",
            DeviceCapabilityDetector
          );
          this.systemDependencies.set("DeviceCapabilityDetector", []);
          this.systemRegistry.set(
            "PerformanceBudgetManager",
            PerformanceBudgetManager
          );
          this.systemDependencies.set("PerformanceBudgetManager", [
            "performanceAnalyzer"
          ]);
          this.systemRegistry.set("SimplePerformanceCoordinator", SimplePerformanceCoordinator);
          this.systemDependencies.set("SimplePerformanceCoordinator", [
            "performanceAnalyzer",
            "performanceCoordinator",
            "deviceCapabilityDetector",
            "performanceBudgetManager"
          ]);
          this.systemRegistry.set(
            "PerformanceAwareLerpCoordinator",
            PerformanceAwareLerpCoordinator
          );
          this.systemDependencies.set("PerformanceAwareLerpCoordinator", [
            "performanceOrchestrator"
          ]);
          this.systemRegistry.set("SimplePerformanceCoordinator", SimplePerformanceCoordinator);
          this.systemDependencies.set("SimplePerformanceCoordinator", [
            "enhancedDeviceTierDetector",
            "webglSystemsIntegration"
          ]);
          this.systemRegistry.set("SimpleTierBasedPerformanceSystem", SimpleTierBasedPerformanceSystem);
          this.systemDependencies.set("SimpleTierBasedPerformanceSystem", [
            "enhancedDeviceTierDetector"
          ]);
          this.systemRegistry.set("EnhancedDeviceTierDetector", EnhancedDeviceTierDetector);
          this.systemDependencies.set("EnhancedDeviceTierDetector", []);
          this.systemRegistry.set("WebGLSystemsIntegration", WebGLSystemsIntegration);
          this.systemDependencies.set("WebGLSystemsIntegration", [
            "deviceCapabilityDetector"
            // WebGLSystemsIntegration needs DeviceCapabilityDetector, not EnhancedDeviceTierDetector
          ]);
          this.systemDependencies.set("UnifiedDebugManager", []);
          this.systemRegistry.set("SettingsManager", SettingsManager);
          this.systemDependencies.set("SettingsManager", []);
          this.systemRegistry.set("ColorHarmonyEngine", ColorHarmonyEngine);
          this.systemDependencies.set("ColorHarmonyEngine", ["musicSyncService"]);
          this.systemRegistry.set("MusicSyncService", MusicSyncService);
          this.systemDependencies.set("MusicSyncService", []);
          this.systemDependencies.set("ColorOrchestrator", []);
          this.systemRegistry.set(
            "UnifiedColorProcessingEngine",
            UnifiedColorProcessingEngine
          );
          this.systemDependencies.set("UnifiedColorProcessingEngine", [
            "settingsManager",
            "performanceAnalyzer"
          ]);
          this.systemRegistry.set("GenreGradientEvolution", GenreGradientEvolution);
          this.systemDependencies.set("GenreGradientEvolution", [
            "cssConsciousnessController",
            "musicSyncService",
            "settingsManager"
          ]);
          this.systemRegistry.set("MusicEmotionAnalyzer", MusicEmotionAnalyzer);
          this.systemDependencies.set("MusicEmotionAnalyzer", [
            "musicSyncService",
            "settingsManager"
          ]);
          this.systemRegistry.set(
            "VisualEffectsCoordinator",
            VisualEffectsCoordinator
          );
          this.systemDependencies.set("VisualEffectsCoordinator", [
            "settingsManager"
          ]);
          this.systemRegistry.set("GlassmorphismManager", GlassmorphismManager);
          this.systemDependencies.set("GlassmorphismManager", [
            "cssConsciousnessController",
            "performanceAnalyzer",
            "settingsManager"
          ]);
          this.systemRegistry.set("Card3DManager", Card3DManager);
          this.systemDependencies.set("Card3DManager", [
            "performanceAnalyzer",
            "settingsManager"
          ]);
          this.systemRegistry.set(
            "SidebarSystemsIntegration",
            SidebarSystemsIntegration
          );
          this.systemDependencies.set("SidebarSystemsIntegration", [
            "cssConsciousnessController"
          ]);
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3KDebug?.debug?.warn("NonVisualSystemFacade", "Already initialized");
            return;
          }
          try {
            const startTime = performance.now();
            this.facadeConfig = { ...this.facadeConfig, ...config };
            await this.initializeSharedDependencies();
            await this.applyConfiguration();
            this.startMonitoring();
            await this.performHealthCheck();
            const endTime = performance.now();
            this.currentMetrics.systemInitializationTime = endTime - startTime;
            this.isInitialized = true;
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Non-visual systems facade fully initialized",
              {
                mode: this.facadeConfig.mode,
                systemsRegistered: this.systemRegistry.size,
                initTime: this.currentMetrics.systemInitializationTime
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "NonVisualSystemFacade",
              "Initialization failed:",
              error
            );
            await this.cleanup();
            throw error;
          }
        }
        async initializeSharedDependencies() {
          const coreSystemsOrder = [
            // Core dependency systems first
            "DeviceCapabilityDetector",
            // Needed by WebGL integration
            "EnhancedDeviceTierDetector",
            // Needed by simplified performance systems
            // New simplified performance systems (primary) - order matters for dependencies
            "WebGLSystemsIntegration",
            // Depends on DeviceCapabilityDetector
            "SimplePerformanceCoordinator",
            // Depends on EnhancedDeviceTierDetector and WebGLSystemsIntegration
            // Legacy performance systems (for backward compatibility)
            "PerformanceAnalyzer",
            "UnifiedPerformanceCoordinator",
            "SimplePerformanceCoordinator",
            // Shared systems
            "OptimizedCSSVariableManager",
            "SettingsManager",
            "UnifiedDebugManager",
            "MusicSyncService"
          ];
          for (const systemKey of coreSystemsOrder) {
            try {
              const system = await this.getSystem(systemKey);
              if (system && typeof system.initialize === "function") {
                await system.initialize();
              }
              switch (systemKey) {
                case "DeviceCapabilityDetector":
                  if (this.year3000System) {
                    this.year3000System.deviceCapabilityDetector = system;
                  }
                  break;
                case "EnhancedDeviceTierDetector":
                  this.enhancedDeviceTierDetector = system;
                  break;
                case "WebGLSystemsIntegration":
                  this.webglSystemsIntegration = system;
                  break;
                case "SimplePerformanceCoordinator":
                  this.simplePerformanceCoordinator = system;
                  this.performanceOrchestrator = system;
                  break;
                case "PerformanceAnalyzer":
                  this.performanceAnalyzer = system;
                  break;
                case "UnifiedPerformanceCoordinator":
                  this.performanceCoordinator = system;
                  break;
                case "OptimizedCSSVariableManager":
                  this.cssConsciousnessController = system;
                  break;
                case "SettingsManager":
                  this.settingsManager = system;
                  break;
                case "UnifiedDebugManager":
                  break;
                case "MusicSyncService":
                  this.musicSyncService = system;
                  break;
              }
            } catch (error) {
              Y3KDebug?.debug?.error(
                "NonVisualSystemFacade",
                `Failed to initialize ${systemKey}:`,
                error
              );
            }
          }
        }
        /**
         * Get system from cache (synchronous) - returns null if not cached
         * Use this for scenarios where the system should already be initialized
         */
        getCachedSystem(key) {
          const cached = this.systemCache.get(key);
          if (cached) {
            return cached;
          }
          if (key === "DeviceCapabilityDetector" && this.year3000System?.deviceCapabilityDetector) {
            const deviceCapabilityDetector = this.year3000System.deviceCapabilityDetector;
            this.systemCache.set(key, deviceCapabilityDetector);
            return deviceCapabilityDetector;
          }
          if (key === "EnhancedDeviceTierDetector" && this.enhancedDeviceTierDetector) {
            this.systemCache.set(key, this.enhancedDeviceTierDetector);
            return this.enhancedDeviceTierDetector;
          }
          if (key === "WebGLSystemsIntegration" && this.webglSystemsIntegration) {
            this.systemCache.set(key, this.webglSystemsIntegration);
            return this.webglSystemsIntegration;
          }
          if (key === "SimplePerformanceCoordinator" && this.simplePerformanceCoordinator) {
            this.systemCache.set(key, this.simplePerformanceCoordinator);
            return this.simplePerformanceCoordinator;
          }
          if (key === "PerformanceAnalyzer" && this.performanceAnalyzer) {
            this.systemCache.set(key, this.performanceAnalyzer);
            return this.performanceAnalyzer;
          }
          if (key === "SimplePerformanceCoordinator" && this.performanceOrchestrator) {
            this.systemCache.set(key, this.performanceOrchestrator);
            return this.performanceOrchestrator;
          }
          if ((key === "OptimizedCSSVariableManager" || key === "UnifiedCSSVariableManager") && this.cssConsciousnessController) {
            this.systemCache.set(key, this.cssConsciousnessController);
            return this.cssConsciousnessController;
          }
          if (key === "MusicSyncService" && this.musicSyncService) {
            this.systemCache.set(key, this.musicSyncService);
            return this.musicSyncService;
          }
          if (key === "SettingsManager" && this.settingsManager) {
            this.systemCache.set(key, this.settingsManager);
            return this.settingsManager;
          }
          return null;
        }
        /**
         * Factory method to create and return non-visual systems
         * This is the main interface for the facade pattern
         */
        async getSystem(key) {
          if (this.systemCache.has(key)) {
            return this.systemCache.get(key);
          }
          if (key === "DeviceCapabilityDetector" && this.year3000System?.deviceCapabilityDetector) {
            const deviceCapabilityDetector = this.year3000System.deviceCapabilityDetector;
            this.systemCache.set(key, deviceCapabilityDetector);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared DeviceCapabilityDetector instance from SystemCoordinator"
            );
            return deviceCapabilityDetector;
          }
          if (key === "EnhancedDeviceTierDetector" && this.enhancedDeviceTierDetector) {
            this.systemCache.set(key, this.enhancedDeviceTierDetector);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared EnhancedDeviceTierDetector instance from SystemCoordinator"
            );
            return this.enhancedDeviceTierDetector;
          }
          if (key === "WebGLSystemsIntegration" && this.webglSystemsIntegration) {
            this.systemCache.set(key, this.webglSystemsIntegration);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared WebGLSystemsIntegration instance from SystemCoordinator"
            );
            return this.webglSystemsIntegration;
          }
          if (key === "SimplePerformanceCoordinator" && this.simplePerformanceCoordinator) {
            this.systemCache.set(key, this.simplePerformanceCoordinator);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared SimplePerformanceCoordinator instance from SystemCoordinator"
            );
            return this.simplePerformanceCoordinator;
          }
          if (key === "PerformanceAnalyzer" && this.performanceAnalyzer) {
            this.systemCache.set(key, this.performanceAnalyzer);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared PerformanceAnalyzer instance from SystemCoordinator"
            );
            return this.performanceAnalyzer;
          }
          if ((key === "OptimizedCSSVariableManager" || key === "UnifiedCSSVariableManager") && this.cssConsciousnessController) {
            this.systemCache.set(key, this.cssConsciousnessController);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              `Using shared OptimizedCSSVariableManager instance from SystemCoordinator (requested as ${key})`
            );
            return this.cssConsciousnessController;
          }
          if (key === "SimplePerformanceCoordinator" && this.performanceOrchestrator) {
            this.systemCache.set(key, this.performanceOrchestrator);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared SimplePerformanceCoordinator instance from SystemCoordinator"
            );
            return this.performanceOrchestrator;
          }
          if (key === "MusicSyncService" && this.musicSyncService) {
            this.systemCache.set(key, this.musicSyncService);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared MusicSyncService instance from SystemCoordinator"
            );
            return this.musicSyncService;
          }
          if (key === "SettingsManager" && this.settingsManager) {
            this.systemCache.set(key, this.settingsManager);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared SettingsManager instance from SystemCoordinator"
            );
            return this.settingsManager;
          }
          const system = await this.createSystem(key);
          this.systemCache.set(key, system);
          this.currentMetrics.activeSystems.push(key);
          this.currentMetrics.initializedSystems++;
          if (this.onSystemCreated) {
            this.onSystemCreated(key, system);
          }
          return system;
        }
        /**
         * Create a new non-visual system instance with strategy-based dependency injection
         */
        async createSystem(key) {
          const startTime = performance.now();
          try {
            if (key === "UnifiedDebugManager") {
              const system2 = UnifiedDebugManager_default.getInstance();
              this.injectDependencies(system2, key);
              this.integratePerformanceMonitoring(system2, key);
              const endTime2 = performance.now();
              this.currentMetrics.dependencyResolutionTime += endTime2 - startTime;
              return system2;
            }
            if (key === "ColorOrchestrator") {
              const system2 = globalColorOrchestrator;
              this.injectDependencies(system2, key);
              this.integratePerformanceMonitoring(system2, key);
              const endTime2 = performance.now();
              this.currentMetrics.dependencyResolutionTime += endTime2 - startTime;
              return system2;
            }
            const SystemClass = this.systemRegistry.get(key);
            if (!SystemClass) {
              throw new Error(`Non-visual system '${key}' not found in registry`);
            }
            const context = {
              systemKey: key,
              config: this.config,
              utils: this.utils,
              dependencies: {
                config: this.config,
                utils: this.utils,
                performanceAnalyzer: this.performanceAnalyzer,
                settingsManager: this.settingsManager,
                musicSyncService: this.musicSyncService,
                year3000System: this.year3000System,
                cssConsciousnessController: this.cssConsciousnessController,
                performanceCoordinator: this.performanceCoordinator,
                performanceOrchestrator: this.performanceOrchestrator,
                // New simplified performance system dependencies
                enhancedDeviceTierDetector: this.enhancedDeviceTierDetector,
                webglSystemsIntegration: this.webglSystemsIntegration,
                simplePerformanceCoordinator: this.simplePerformanceCoordinator,
                // Need DeviceCapabilityDetector from SystemCoordinator for WebGL integration
                deviceCapabilityDetector: this.year3000System?.deviceCapabilityDetector || null
              },
              preferences: {
                lazyInit: false,
                validateDependencies: true,
                creationTimeout: 5e3,
                monitorCreation: true
              },
              metadata: {
                timestamp: Date.now(),
                reason: "startup",
                priority: "medium",
                resourceConstraints: {
                  maxMemoryMB: 50,
                  maxInitTimeMs: 1e3
                }
              },
              year3000System: this.year3000System
            };
            const result = await this.facadeAdapter.createSystemWithStrategy(
              key,
              SystemClass,
              context
            );
            if (!result.success) {
              Y3KDebug?.debug?.warn(
                "NonVisualSystemFacade",
                `Strategy creation failed for ${key}, falling back to legacy pattern`
              );
              const system2 = this.facadeAdapter.createSystemLegacy(
                key,
                SystemClass,
                context
              );
              this.injectDependencies(system2, key);
              this.integratePerformanceMonitoring(system2, key);
              const endTime2 = performance.now();
              this.currentMetrics.dependencyResolutionTime += endTime2 - startTime;
              return system2;
            }
            const system = result.system;
            this.injectDependencies(system, key);
            this.integratePerformanceMonitoring(system, key);
            const endTime = performance.now();
            this.currentMetrics.dependencyResolutionTime += endTime - startTime;
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              `Created ${key} using strategy: ${result.strategy}`,
              {
                creationTime: result.creationTime,
                totalTime: endTime - startTime,
                injectedDependencies: result.injectedDependencies
              }
            );
            return system;
          } catch (error) {
            this.currentMetrics.failedSystems++;
            this.currentMetrics.failedSystemsList.push(key);
            this.currentMetrics.systemErrors++;
            if (this.onSystemFailed) {
              this.onSystemFailed(key, error);
            }
            Y3KDebug?.debug?.error(
              "NonVisualSystemFacade",
              `Failed to create system ${key}:`,
              error
            );
            throw error;
          }
        }
        /**
         * Inject dependencies into non-visual systems
         */
        injectDependencies(system, key) {
          if (!this.facadeConfig.enableDependencyInjection) return;
          const dependencies = this.systemDependencies.get(key) || [];
          if (dependencies.includes("performanceAnalyzer") && this.performanceAnalyzer && system.setPerformanceAnalyzer) {
            system.setPerformanceAnalyzer(this.performanceAnalyzer);
          }
          if (dependencies.includes("cssConsciousnessController") && this.cssConsciousnessController && system.setCSSConsciousnessController) {
            system.setCSSConsciousnessController(this.cssConsciousnessController);
          }
          if (dependencies.includes("musicSyncService") && this.musicSyncService && system.setMusicSyncService) {
            system.setMusicSyncService(this.musicSyncService);
          }
          if (dependencies.includes("settingsManager") && this.settingsManager && system.setSettingsManager) {
            system.setSettingsManager(this.settingsManager);
          }
          if (dependencies.includes("year3000System") && system.setYear3000System) {
            system.setYear3000System(this.year3000System);
          }
          if (dependencies.includes("performanceOrchestrator") && this.performanceOrchestrator && system.setSimplePerformanceCoordinator) {
            system.setSimplePerformanceCoordinator(this.performanceOrchestrator);
          }
        }
        /**
         * Integrate performance monitoring for non-visual systems
         */
        integratePerformanceMonitoring(system, key) {
          if (!this.facadeConfig.enablePerformanceMonitoring || !this.performanceAnalyzer)
            return;
          const originalInitialize = system.initialize;
          if (typeof originalInitialize === "function") {
            system.initialize = async (...args) => {
              const startTime = performance.now();
              const result = await originalInitialize.call(system, ...args);
              const endTime = performance.now();
              this.performanceAnalyzer?.recordMetric(
                `NonVisual_${key}_Initialize`,
                endTime - startTime
              );
              return result;
            };
          }
          const originalUpdateAnimation = system.updateAnimation;
          if (typeof originalUpdateAnimation === "function") {
            system.updateAnimation = (deltaTime) => {
              const startTime = performance.now();
              originalUpdateAnimation.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer?.recordMetric(
                `NonVisual_${key}_Animation`,
                endTime - startTime
              );
            };
          }
        }
        /**
         * Initialize all cached non-visual systems
         */
        async initializeAllSystems() {
          const initPromises = Array.from(this.systemCache.entries()).map(
            async ([key, system]) => {
              try {
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                }
                Y3KDebug?.debug?.log(
                  "NonVisualSystemFacade",
                  `Initialized system: ${key}`
                );
                return { key, success: true };
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "NonVisualSystemFacade",
                  `Failed to initialize ${key}:`,
                  error
                );
                return { key, success: false, error };
              }
            }
          );
          const results = await Promise.allSettled(initPromises);
          const successCount = results.filter(
            (r) => r.status === "fulfilled" && r.value.success
          ).length;
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacade",
            `Non-visual systems initialized: ${successCount}/${results.length}`
          );
        }
        /**
         * Perform health check on all non-visual systems
         */
        async performHealthCheck() {
          const healthCheck = {
            overall: "good",
            systems: /* @__PURE__ */ new Map(),
            recommendations: [],
            timestamp: performance.now(),
            metrics: { ...this.currentMetrics }
          };
          let healthyCount = 0;
          let totalCount = 0;
          for (const [key, system] of this.systemCache) {
            totalCount++;
            try {
              const systemHealth = system.healthCheck ? await system.healthCheck() : { status: "unknown", message: "No health check available" };
              const isHealthy = systemHealth.status === "healthy" || systemHealth.status === "good";
              if (isHealthy) healthyCount++;
              healthCheck.systems.set(key, {
                ok: isHealthy,
                details: systemHealth.message || systemHealth.details || "System operational"
              });
            } catch (error) {
              healthCheck.systems.set(key, {
                ok: false,
                details: `Health check failed: ${error}`
              });
            }
          }
          const healthPercentage = totalCount > 0 ? healthyCount / totalCount : 1;
          if (healthPercentage >= 0.9) {
            healthCheck.overall = "excellent";
          } else if (healthPercentage >= 0.7) {
            healthCheck.overall = "good";
          } else if (healthPercentage >= 0.5) {
            healthCheck.overall = "degraded";
            healthCheck.recommendations.push(
              "Some non-visual systems are experiencing issues"
            );
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push(
              "Multiple non-visual system failures detected"
            );
          }
          if (this.currentMetrics.systemInitializationTime > 3e3) {
            healthCheck.recommendations.push(
              "High initialization time - consider optimizing system startup"
            );
          }
          if (this.currentMetrics.memoryUsageMB > 80) {
            healthCheck.recommendations.push(
              "High memory usage - consider optimizing system memory usage"
            );
          }
          this.lastHealthCheck = healthCheck;
          this.currentMetrics.lastHealthCheckTime = performance.now();
          if (this.onHealthChange) {
            this.onHealthChange(healthCheck);
          }
          return healthCheck;
        }
        // Utility methods
        createInitialMetrics() {
          return {
            systemCount: this.systemRegistry.size,
            initializedSystems: 0,
            failedSystems: 0,
            totalInitTime: 0,
            averageInitTime: 0,
            memoryUsageMB: 0,
            systemHealth: "good",
            activeSystems: [],
            failedSystemsList: [],
            dependencyInjection: this.facadeConfig.enableDependencyInjection,
            performanceMonitoring: this.facadeConfig.enablePerformanceMonitoring,
            healthMonitoring: this.facadeConfig.enableSystemHealthMonitoring,
            systemInitializationTime: 0,
            dependencyResolutionTime: 0,
            lastHealthCheckTime: 0,
            systemErrors: 0
          };
        }
        async applyConfiguration() {
          switch (this.facadeConfig.mode) {
            case "performance-first":
              this.facadeConfig.systemPreferences.lazyInitialization = true;
              this.facadeConfig.systemPreferences.aggressiveCaching = true;
              break;
            case "quality-first":
              this.facadeConfig.systemPreferences.lazyInitialization = false;
              this.facadeConfig.systemPreferences.performanceOptimization = true;
              break;
            case "battery-optimized":
              this.facadeConfig.performanceThresholds.maxCPUPercent = 5;
              this.facadeConfig.systemPreferences.lazyInitialization = true;
              break;
          }
        }
        startMonitoring() {
          if (this.facadeConfig.enableSystemHealthMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performHealthCheck();
            }, 3e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 5e3);
          }
        }
        updateMetrics() {
          this.currentMetrics.systemCount = this.systemRegistry.size;
          this.currentMetrics.initializedSystems = this.systemCache.size;
          this.currentMetrics.averageInitTime = this.currentMetrics.totalInitTime / Math.max(1, this.currentMetrics.initializedSystems);
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.memoryUsageMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          const failureRate = this.currentMetrics.failedSystems / Math.max(1, this.currentMetrics.systemCount);
          if (failureRate === 0) {
            this.currentMetrics.systemHealth = "excellent";
          } else if (failureRate < 0.1) {
            this.currentMetrics.systemHealth = "good";
          } else if (failureRate < 0.3) {
            this.currentMetrics.systemHealth = "degraded";
          } else {
            this.currentMetrics.systemHealth = "critical";
          }
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          this.cssConsciousnessController = null;
          this.performanceAnalyzer = null;
          this.performanceOrchestrator = null;
          this.musicSyncService = null;
          this.settingsManager = null;
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.facadeConfig };
        }
        async setConfiguration(config) {
          this.facadeConfig = { ...this.facadeConfig, ...config };
          await this.applyConfiguration();
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        setOnSystemFailed(callback) {
          this.onSystemFailed = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            systemsActive: this.systemCache.size,
            healthy: this.currentMetrics.systemHealth === "excellent" || this.currentMetrics.systemHealth === "good"
          };
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          this.systemCache.clear();
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacade",
            "Non-visual systems facade destroyed"
          );
        }
      };
      __name(_NonVisualSystemFacade, "NonVisualSystemFacade");
      NonVisualSystemFacade = _NonVisualSystemFacade;
    }
  });

  // src-js/core/animation/CSSAnimationManager.ts
  var _CSSAnimationManager, CSSAnimationManager;
  var init_CSSAnimationManager = __esm({
    "src-js/core/animation/CSSAnimationManager.ts"() {
      "use strict";
      init_UnifiedEventBus();
      _CSSAnimationManager = class _CSSAnimationManager {
        constructor(config, cssConsciousnessController, animationCoordinator) {
          this.systemName = "CSSAnimationManager";
          // Animation state tracking
          this.animationStates = /* @__PURE__ */ new Map();
          this.activeAnimations = /* @__PURE__ */ new Map();
          this.animationObservers = /* @__PURE__ */ new Map();
          // Performance tracking
          this.frameCount = 0;
          this.lastFrameTime = 0;
          this.avgFrameTime = 0;
          this.performanceMode = "quality";
          // Beat sync state
          this.beatSyncState = {
            intensity: 0,
            tempo: 120,
            phase: 0,
            lastBeatTime: 0,
            avgBeatInterval: 500
          };
          // Consciousness breathing state for Year 3000 integration with LERP smoothing
          this.breathingState = {
            currentType: "gentle",
            activeElements: /* @__PURE__ */ new Set(),
            currentAnimation: null,
            lastEnergyLevel: 0.5,
            lastTempoChange: 0,
            // LERP smoothing for breathing transitions
            targetEnergyLevel: 0.5,
            smoothedEnergyLevel: 0.5,
            targetTempo: 120,
            smoothedTempo: 120,
            lastFrameTime: 0,
            energyHalfLife: 0.3,
            // 300ms half-life for energy transitions
            tempoHalfLife: 0.8
            // 800ms half-life for tempo transitions
          };
          // Animation configuration
          this.ANIMATION_CONFIGS = {
            // Consciousness breathing animations for Year 3000 performance revolution
            consciousnessGentleBreathing: {
              name: "consciousness-gentle-breathing",
              duration: 4e3,
              easing: "ease-in-out",
              iterations: "infinite",
              fillMode: "none",
              playState: "running",
              delay: 0,
              direction: "normal"
            },
            consciousnessEnergeticBreathing: {
              name: "consciousness-energetic-breathing",
              duration: 2500,
              easing: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
              iterations: "infinite",
              fillMode: "none",
              playState: "running",
              delay: 0,
              direction: "normal"
            },
            consciousnessMeditativeBreathing: {
              name: "consciousness-meditative-breathing",
              duration: 6e3,
              easing: "cubic-bezier(0.4, 0, 0.6, 1)",
              iterations: "infinite",
              fillMode: "none",
              playState: "running",
              delay: 0,
              direction: "normal"
            },
            consciousnessCosmicBreathing: {
              name: "consciousness-cosmic-breathing",
              duration: 3e3,
              easing: "cubic-bezier(0.25, 0.1, 0.25, 1)",
              iterations: "infinite",
              fillMode: "none",
              playState: "running",
              delay: 0,
              direction: "normal"
            },
            bloom: {
              name: "year3000-bloom",
              duration: 1500,
              easing: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
              iterations: 1,
              fillMode: "forwards",
              playState: "running",
              delay: 0,
              direction: "normal"
            },
            ripple: {
              name: "year3000-ripple",
              duration: 1200,
              easing: "ease-out",
              iterations: 1,
              fillMode: "forwards",
              playState: "running",
              delay: 0,
              direction: "normal"
            },
            oscillate: {
              name: "year3000-oscillate",
              duration: 4e3,
              easing: "ease-in-out",
              iterations: "infinite",
              fillMode: "none",
              playState: "running",
              delay: 0,
              direction: "normal"
            },
            harmonize: {
              name: "year3000-harmonize-flow",
              duration: 8e3,
              easing: "linear",
              iterations: "infinite",
              fillMode: "none",
              playState: "running",
              delay: 0,
              direction: "normal"
            },
            refract: {
              name: "year3000-refract",
              duration: 800,
              easing: "ease-in-out",
              iterations: 1,
              fillMode: "forwards",
              playState: "running",
              delay: 0,
              direction: "normal"
            },
            temporalEcho: {
              name: "year3000-echo-core",
              duration: 800,
              easing: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
              iterations: 1,
              fillMode: "forwards",
              playState: "running",
              delay: 0,
              direction: "normal"
            },
            gravity: {
              name: "year3000-gravity-pull",
              duration: 1e3,
              easing: "ease-in-out",
              iterations: "infinite",
              fillMode: "none",
              playState: "running",
              delay: 0,
              direction: "normal"
            }
          };
          this.config = config;
          this.cssConsciousnessController = cssConsciousnessController;
          this.animationCoordinator = animationCoordinator;
          this.eventBus = unifiedEventBus;
          this.initializeDefaultState();
          this.subscribeToEvents();
          this.animationCoordinator.registerVisualSystem(this, "normal");
          this.breathingState.lastFrameTime = performance.now();
          if (this.config.enableDebug) {
            console.log("[CSSAnimationManager] Initialized with CSS animation coordination and LERP-smoothed breathing transitions");
          }
        }
        /**
         * Update CSS animation variables based on beat sync
         */
        onAnimate(deltaMs, context) {
          this.frameCount++;
          this.lastFrameTime = deltaMs;
          this.avgFrameTime = this.avgFrameTime * 0.9 + deltaMs * 0.1;
          this.updatePerformanceMode(context.performanceMode);
          if (context.beatIntensity !== void 0) {
            this.updateBeatSyncState(context.beatIntensity, context.timestamp);
          }
          const deltaTimeSeconds = deltaMs / 1e3;
          this.updateBreathingLerpValues(deltaTimeSeconds);
          this.updateAnimationVariables(context);
          this.updateActiveAnimations(context);
          if (this.frameCount % 60 === 0) {
            this.reportPerformanceMetrics();
          }
        }
        /**
         * Handle performance mode changes
         */
        onPerformanceModeChange(mode) {
          this.performanceMode = mode;
          this.updateAnimationQuality(mode);
          if (this.config.enableDebug) {
            console.log(`[CSSAnimationManager] Performance mode changed to: ${mode}`);
          }
        }
        /**
         * Trigger a kinetic animation on elements
         */
        triggerKineticAnimation(elements, animationType, options) {
          const config = { ...this.ANIMATION_CONFIGS[animationType], ...options };
          Array.from(elements).forEach((element, index) => {
            const staggeredDelay = (config.delay || 0) + index * 50;
            const animationOptions = {
              duration: config.duration || 1e3,
              easing: config.easing || "ease-in-out",
              iterations: config.iterations === "infinite" ? Infinity : config.iterations || 1,
              fill: config.fillMode || "forwards",
              delay: staggeredDelay,
              direction: config.direction || "normal"
            };
            const animation = element.animate([], animationOptions);
            const animationId = `${animationType}_${Date.now()}_${index}`;
            this.activeAnimations.set(animationId, animation);
            animation.addEventListener("finish", () => {
              this.activeAnimations.delete(animationId);
              element.classList.remove(`sn-${animationType}-active`);
            });
            element.classList.add(`sn-${animationType}-active`);
          });
          if (this.config.enableDebug) {
            console.log(`[CSSAnimationManager] Triggered ${animationType} animation on ${elements.length} elements`);
          }
        }
        /**
         * Enable beat-synchronized animations
         */
        enableBeatSync(enable = true) {
          for (const [elementId, state] of this.animationStates) {
            state.beatSyncEnabled = enable;
            this.animationStates.set(elementId, state);
          }
          this.cssConsciousnessController.updateMusicVariables({
            "beat.pulse.intensity": enable ? this.beatSyncState.intensity : 0
          });
          if (this.config.enableDebug) {
            console.log(`[CSSAnimationManager] Beat sync ${enable ? "enabled" : "disabled"}`);
          }
        }
        /**
         * Set global animation intensity
         */
        setAnimationIntensity(intensity) {
          const clampedIntensity = Math.max(0, Math.min(1, intensity));
          for (const [elementId, state] of this.animationStates) {
            state.intensityLevel = clampedIntensity;
            this.animationStates.set(elementId, state);
          }
          this.cssConsciousnessController.updateAnimationVariables({
            "motion.scale": clampedIntensity
          });
          this.cssConsciousnessController.updateMusicVariables({
            "beat.pulse.intensity": clampedIntensity
          });
          if (this.config.enableDebug) {
            console.log(`[CSSAnimationManager] Animation intensity set to: ${clampedIntensity}`);
          }
        }
        /**
         * Pause all CSS animations
         */
        pauseAllAnimations() {
          for (const animation of this.activeAnimations.values()) {
            animation.pause();
          }
          this.cssConsciousnessController.updateAnimationVariables({
            "motion.scale": 0
          });
          if (this.config.enableDebug) {
            console.log("[CSSAnimationManager] All animations paused");
          }
        }
        /**
         * Resume all CSS animations
         */
        resumeAllAnimations() {
          for (const animation of this.activeAnimations.values()) {
            animation.play();
          }
          this.cssConsciousnessController.updateAnimationVariables({
            "motion.scale": 1
          });
          if (this.config.enableDebug) {
            console.log("[CSSAnimationManager] All animations resumed");
          }
        }
        /**
         * LERP smoothing utility for framerate-independent breathing transitions
         * Based on Rory Driscoll's frame rate independent damping using lerp
         */
        lerpSmooth(current, target, deltaTime, halfLife) {
          const EPSILON = 1e-5;
          if (halfLife <= EPSILON || deltaTime <= 0) {
            return target;
          }
          return target + (current - target) * Math.pow(2, -deltaTime / halfLife);
        }
        /**
         * Update LERP-smoothed breathing values for seamless transitions
         */
        updateBreathingLerpValues(deltaTime) {
          this.breathingState.smoothedEnergyLevel = this.lerpSmooth(
            this.breathingState.smoothedEnergyLevel,
            this.breathingState.targetEnergyLevel,
            deltaTime,
            this.breathingState.energyHalfLife
          );
          this.breathingState.smoothedTempo = this.lerpSmooth(
            this.breathingState.smoothedTempo,
            this.breathingState.targetTempo,
            deltaTime,
            this.breathingState.tempoHalfLife
          );
        }
        /**
         * Trigger consciousness breathing animation based on music energy
         * Year 3000 CSS-first breathing performance revolution with LERP smoothing
         */
        triggerConsciousnessBreathing(elements, energyLevel = 0.5, tempo = 120) {
          this.breathingState.targetEnergyLevel = energyLevel;
          this.breathingState.targetTempo = tempo;
          const smoothedEnergy = this.breathingState.smoothedEnergyLevel;
          const smoothedTempo = this.breathingState.smoothedTempo;
          const breathingType = this.selectBreathingType(smoothedEnergy, smoothedTempo);
          if (this.breathingState.currentAnimation) {
            this.breathingState.currentAnimation.cancel();
          }
          this.breathingState.activeElements.forEach((element) => {
            element.classList.remove(
              "consciousness-gentle-breathing",
              "consciousness-energetic-breathing",
              "consciousness-meditative-breathing",
              "consciousness-cosmic-breathing"
            );
          });
          this.breathingState.currentType = breathingType;
          this.breathingState.lastEnergyLevel = smoothedEnergy;
          this.breathingState.lastTempoChange = Date.now();
          this.breathingState.activeElements.clear();
          Array.from(elements).forEach((element) => {
            this.breathingState.activeElements.add(element);
            element.classList.add(`consciousness-${breathingType}-breathing`);
          });
          this.updateBreathingVariables(breathingType, smoothedEnergy, smoothedTempo);
          if (this.config.enableDebug) {
            console.log(`[CSSAnimationManager] LERP-smoothed breathing: ${breathingType} (raw: ${energyLevel.toFixed(2)}\u2192${smoothedEnergy.toFixed(2)}, tempo: ${tempo}\u2192${smoothedTempo.toFixed(1)})`);
          }
        }
        /**
         * Select breathing type based on music energy and tempo
         */
        selectBreathingType(energyLevel, tempo) {
          if (this.performanceMode === "performance" && energyLevel > 0.7) {
            return energyLevel > 0.8 ? "gentle" : "meditative";
          }
          if (energyLevel < 0.3) {
            return "meditative";
          } else if (energyLevel > 0.7 && tempo > 140) {
            return "cosmic";
          } else if (energyLevel > 0.6) {
            return "energetic";
          } else {
            return "gentle";
          }
        }
        /**
         * Update CSS variables for breathing coordination
         */
        updateBreathingVariables(breathingType, energyLevel, tempo) {
          const duration = this.calculateBreathingDuration(breathingType, tempo);
          const intensity = Math.max(0.05, Math.min(1, energyLevel));
          this.cssConsciousnessController.updateConsciousnessVariables({
            "breathing.type": breathingType,
            "breathing.duration": `${duration}ms`,
            "breathing.intensity": intensity,
            "breathing.energy": energyLevel
          });
          this.cssConsciousnessController.updateMusicVariables({
            "tempo.bpm": tempo,
            "energy.level": energyLevel,
            "breathing.sync": 1
            // Enable breathing synchronization
          });
        }
        /**
         * Calculate breathing duration based on type and tempo
         */
        calculateBreathingDuration(breathingType, tempo) {
          const baseDurations = {
            gentle: 4e3,
            energetic: 2500,
            meditative: 6e3,
            cosmic: 3e3
          };
          const baseDuration = baseDurations[breathingType] || 4e3;
          const tempoMultiplier = Math.max(0.5, Math.min(2, 120 / tempo));
          return Math.round(baseDuration * tempoMultiplier);
        }
        /**
         * Stop consciousness breathing animations
         */
        stopConsciousnessBreathing() {
          if (this.breathingState.currentAnimation) {
            this.breathingState.currentAnimation.cancel();
            this.breathingState.currentAnimation = null;
          }
          this.breathingState.activeElements.forEach((element) => {
            element.classList.remove(
              "consciousness-gentle-breathing",
              "consciousness-energetic-breathing",
              "consciousness-meditative-breathing",
              "consciousness-cosmic-breathing"
            );
          });
          this.breathingState.activeElements.clear();
          this.cssConsciousnessController.updateConsciousnessVariables({
            "breathing.sync": 0
          });
          if (this.config.enableDebug) {
            console.log("[CSSAnimationManager] Consciousness breathing stopped");
          }
        }
        /**
         * Get animation performance metrics
         */
        getPerformanceMetrics() {
          return {
            frameCount: this.frameCount,
            avgFrameTime: this.avgFrameTime,
            activeAnimations: this.activeAnimations.size,
            performanceMode: this.performanceMode
          };
        }
        /**
         * Clean up resources
         */
        destroy() {
          for (const animation of this.activeAnimations.values()) {
            animation.cancel();
          }
          this.activeAnimations.clear();
          this.animationStates.clear();
          this.animationObservers.clear();
          if (this.config.enableDebug) {
            console.log("[CSSAnimationManager] Destroyed");
          }
        }
        // =========================================================================
        // PRIVATE METHODS
        // =========================================================================
        /**
         * Initialize default animation state
         */
        initializeDefaultState() {
          const defaultState = {
            rippleActive: false,
            bloomActive: false,
            refractActive: false,
            oscillateActive: false,
            harmonizeActive: false,
            temporalEchoActive: false,
            gravityActive: false,
            beatSyncEnabled: true,
            intensityLevel: 1,
            tempoMultiplier: 1
          };
          this.animationStates.set("default", defaultState);
        }
        /**
         * Subscribe to relevant events
         */
        subscribeToEvents() {
          this.eventBus.subscribe("music:beat", (payload) => {
            this.handleBeatEvent(payload);
          }, "CSSAnimationManager");
          this.eventBus.subscribe("music:energy", (payload) => {
            this.handleTempoChange({ bpm: payload.tempo });
          }, "CSSAnimationManager");
          this.eventBus.subscribe("settings:changed", (event) => {
            if (event.settingKey === "sn-animation-quality") {
              this.handleAnimationQualityChange(event.newValue);
            }
          }, "CSSAnimationManager");
          this.eventBus.subscribe("performance:frame", (payload) => {
            const mode = payload.fps < 45 ? "performance" : "quality";
            this.onPerformanceModeChange(mode);
          }, "CSSAnimationManager");
        }
        /**
         * Handle beat events for synchronization
         */
        handleBeatEvent(payload) {
          const currentTime = performance.now();
          const timeSinceLastBeat = currentTime - this.beatSyncState.lastBeatTime;
          this.beatSyncState.intensity = payload.intensity || 0;
          this.beatSyncState.phase = payload.phase || 0;
          this.beatSyncState.lastBeatTime = currentTime;
          if (timeSinceLastBeat > 0 && timeSinceLastBeat < 2e3) {
            this.beatSyncState.avgBeatInterval = this.beatSyncState.avgBeatInterval * 0.9 + timeSinceLastBeat * 0.1;
          }
          this.cssConsciousnessController.updateMusicVariables({
            "beat.pulse.intensity": this.beatSyncState.intensity,
            "beat.phase": this.beatSyncState.phase
          });
          if (payload.energy !== void 0) {
            const energyLevel = payload.energy;
            const tempo = this.beatSyncState.tempo;
            const energyDelta = Math.abs(energyLevel - this.breathingState.lastEnergyLevel);
            const timeSinceTempoChange = currentTime - this.breathingState.lastTempoChange;
            if (energyDelta > 0.15 || timeSinceTempoChange > 5e3) {
              const consciousnessElements = document.querySelectorAll(".Root__main-view::before, .Root__main-view, [data-consciousness-breathing]");
              if (consciousnessElements.length > 0) {
                this.triggerConsciousnessBreathing(consciousnessElements, energyLevel, tempo);
              }
            }
          }
        }
        /**
         * Handle tempo changes
         */
        handleTempoChange(payload) {
          const newTempo = payload.bpm || 120;
          this.beatSyncState.tempo = newTempo;
          const tempoMultiplier = newTempo / 120;
          this.cssConsciousnessController.updateMusicVariables({
            "tempo.bpm": newTempo
          });
          this.cssConsciousnessController.updateAnimationVariables({
            "motion.scale": tempoMultiplier
          });
          for (const [elementId, state] of this.animationStates) {
            state.tempoMultiplier = tempoMultiplier;
            this.animationStates.set(elementId, state);
          }
        }
        /**
         * Update beat sync state
         */
        updateBeatSyncState(intensity, timestamp) {
          this.beatSyncState.intensity = intensity;
          this.beatSyncState.lastBeatTime = timestamp;
          this.cssConsciousnessController.updateMusicVariables({
            "beat.pulse.intensity": intensity
          });
        }
        /**
         * Update animation variables based on frame context
         */
        updateAnimationVariables(context) {
          this.cssConsciousnessController.updateAnimationVariables({
            "frame.fps": Math.round(1e3 / context.deltaMs),
            "frame.budget": `${context.frameBudget}ms`
          });
          if (context.tiltXY) {
            this.cssConsciousnessController.updateConsciousnessVariables({
              "hover.pull": `${Math.abs(context.tiltXY.x) + Math.abs(context.tiltXY.y)}px`
            });
          }
        }
        /**
         * Update active animations based on context
         */
        updateActiveAnimations(context) {
          if (context.timestamp - this.lastFrameTime < 16) return;
          const playbackRate = this.performanceMode === "performance" ? 0.7 : 1;
          for (const animation of this.activeAnimations.values()) {
            if (animation.playbackRate !== playbackRate) {
              animation.playbackRate = playbackRate;
            }
          }
        }
        /**
         * Handle animation quality setting changes from user
         */
        handleAnimationQualityChange(qualitySetting) {
          let qualityLevel;
          switch (qualitySetting) {
            case "low":
              qualityLevel = 0.4;
              break;
            case "high":
              qualityLevel = 1;
              break;
            case "auto":
            default:
              qualityLevel = this.performanceMode === "performance" ? 0.6 : 1;
              break;
          }
          this.applyQualityLevel(qualityLevel);
          if (this.config.enableDebug) {
            console.log(`[CSSAnimationManager] Animation quality set to: ${qualitySetting} (level: ${qualityLevel})`);
          }
        }
        /**
         * Update animation quality based on performance mode (legacy method for auto mode)
         */
        updateAnimationQuality(mode) {
          const qualityLevel = mode === "performance" ? 0.6 : 1;
          this.applyQualityLevel(qualityLevel);
        }
        /**
         * Apply quality level to animations (layered enhancement approach)
         */
        applyQualityLevel(qualityLevel) {
          const effectiveMode = qualityLevel < 0.5 ? "performance" : "quality";
          this.cssConsciousnessController.updatePerformanceVariables({
            "quality.level": qualityLevel,
            "mode": effectiveMode
          });
          this.cssConsciousnessController.updateAnimationVariables({
            "motion.scale": qualityLevel
          });
          if (qualityLevel < 0.5) {
            this.cssConsciousnessController.updateUtilityVariables({
              "feature.animations.enabled": false
            });
          } else {
            this.cssConsciousnessController.updateUtilityVariables({
              "feature.animations.enabled": true
            });
          }
        }
        /**
         * Update performance mode
         */
        updatePerformanceMode(mode) {
          if (this.performanceMode !== mode) {
            this.performanceMode = mode;
            this.updateAnimationQuality(mode);
          }
        }
        /**
         * Report performance metrics
         */
        reportPerformanceMetrics() {
          const metrics = this.getPerformanceMetrics();
          this.eventBus.emit("performance:frame", {
            deltaTime: metrics.avgFrameTime,
            fps: Math.round(1e3 / metrics.avgFrameTime),
            memoryUsage: 0,
            // Would need actual memory measurement
            timestamp: Date.now()
          });
          if (this.config.enableDebug) {
            console.log(`[CSSAnimationManager] Performance - FPS: ${Math.round(1e3 / metrics.avgFrameTime)}, Active: ${metrics.activeAnimations}`);
          }
        }
      };
      __name(_CSSAnimationManager, "CSSAnimationManager");
      CSSAnimationManager = _CSSAnimationManager;
    }
  });

  // src-js/types/colorStubs.ts
  var _VisualEffectsManager, VisualEffectsManager, _StubBreathingEngine, StubBreathingEngine, _StubSymbioticCore, StubSymbioticCore;
  var init_colorStubs = __esm({
    "src-js/types/colorStubs.ts"() {
      "use strict";
      _VisualEffectsManager = class _VisualEffectsManager {
        constructor() {
          this.breathingEngine = new StubBreathingEngine();
          this.symbioticCore = new StubSymbioticCore();
        }
        getConsciousnessState() {
          return {
            cellularGrowthRate: 1,
            breathingCycle: 2,
            emotionalTemperature: 6e3,
            membraneFluidityIndex: 0.5,
            symbioticResonance: 0.5,
            cinematicIntensity: 0.5
          };
        }
      };
      __name(_VisualEffectsManager, "VisualEffectsManager");
      VisualEffectsManager = _VisualEffectsManager;
      _StubBreathingEngine = class _StubBreathingEngine {
        updateBreathing(intensity) {
        }
        getBreathingPhase() {
          return 0.5;
        }
        initialize() {
        }
        updateBreathingCycle(cycle) {
        }
        calculateBreathingCycle(bpm) {
          return 2;
        }
        adjustRhythm(intensity) {
        }
        synchronizeWithBeat(beatData) {
        }
      };
      __name(_StubBreathingEngine, "StubBreathingEngine");
      StubBreathingEngine = _StubBreathingEngine;
      _StubSymbioticCore = class _StubSymbioticCore {
        processAudioData(data) {
        }
        getEmotionalState() {
          return { intensity: 0.5, valence: 0.5, arousal: 0.5, energy: 0.5 };
        }
        initialize() {
        }
        updateSymbioticResonance(resonance) {
        }
        calculateResonance(musicData) {
          return 0.5;
        }
        updateSymbioticEffects(effects) {
        }
      };
      __name(_StubSymbioticCore, "StubSymbioticCore");
      StubSymbioticCore = _StubSymbioticCore;
    }
  });

  // src-js/visual/effects/ConsolidatedShaderLibrary.ts
  var STANDARD_CONSCIOUSNESS_VERTEX_SHADER, SHARED_NOISE_FUNCTIONS, CONSCIOUSNESS_MODULATION_FUNCTIONS, CORRIDOR_SDF_FUNCTIONS, STANDARD_CONSCIOUSNESS_UNIFORMS, _ShaderTemplate, ShaderTemplate, _ShaderLogicPatterns, ShaderLogicPatterns, _ConsciousnessShaderFragments, ConsciousnessShaderFragments, _ShaderOptimizationUtils, ShaderOptimizationUtils, CONSCIOUSNESS_SHADER_LIBRARY;
  var init_ConsolidatedShaderLibrary = __esm({
    "src-js/visual/effects/ConsolidatedShaderLibrary.ts"() {
      "use strict";
      STANDARD_CONSCIOUSNESS_VERTEX_SHADER = `#version 300 es
in vec2 a_position;
void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;
      SHARED_NOISE_FUNCTIONS = `
// Shared simplex noise implementation for consciousness effects
vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
  vec2 i = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);
  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod289(i);
  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m;
  m = m*m;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
  vec3 g;
  g.x = a0.x * x0.x + h.x * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}`;
      CONSCIOUSNESS_MODULATION_FUNCTIONS = `
// Enhanced consciousness-aware breathing effect with multi-phase patterns
float consciousnessBreathing(float time, float phase, float intensity) {
  return sin(time * 0.05 + phase) * intensity;
}

// Deep consciousness breathing with emotional resonance
float deepConsciousnessBreathing(float time, float phase, float emotionalIntensity) {
  float primaryBreath = sin(time * 0.04 + phase) * 0.6;
  float secondaryBreath = sin(time * 0.07 + phase * 1.3) * 0.3;
  float emotionalBreath = sin(time * 0.02 + phase * 0.7) * 0.2;
  return (primaryBreath + secondaryBreath + emotionalBreath) * emotionalIntensity;
}

// Rhythmic pulse modulation from consciousness field
float rhythmicPulseModulation(float baseValue, float rhythmicPulse, float intensity) {
  return baseValue * (1.0 + rhythmicPulse * intensity);
}

// Musical flow direction calculation
vec2 calculateMusicalFlow(vec2 baseDirection, vec2 musicFlow, float sensitivity) {
  return baseDirection + musicFlow * sensitivity;
}

// Energy resonance modulation
float energyResonanceModulation(float baseValue, float energyResonance, float minMult, float maxMult) {
  return baseValue * (minMult + energyResonance * (maxMult - minMult));
}

// Membrane fluidity effect
float membraneFluidityEffect(float value, float fluidityIndex) {
  return mix(value, value * 1.2, fluidityIndex);
}

// === ADVANCED CONSCIOUSNESS FIELD PATTERNS ===

// Multi-dimensional consciousness field intensity calculation
float consciousnessFieldIntensity(vec2 position, float time, float musicEnergy) {
  // Primary consciousness wave
  float primaryField = snoise(position * 2.0 + time * 0.1) * 0.6;
  
  // Secondary awareness resonance
  float secondaryField = snoise(position * 4.0 + time * 0.05) * 0.3;
  
  // Musical consciousness enhancement
  float musicalField = snoise(position * 6.0 + time * 0.15) * 0.2;
  
  // Combine consciousness layers
  float combinedField = primaryField + secondaryField + (musicalField * musicEnergy);
  return clamp(combinedField * 0.5 + 0.5, 0.0, 1.0);
}

// Multi-dimensional awareness patterns for color modulation
vec3 awarenessResonance(vec3 baseColor, float consciousnessLevel, float musicIntensity) {
  // Consciousness-aware color temperature shift
  float temperatureShift = consciousnessLevel * 0.3;
  vec3 warmShift = vec3(1.0 + temperatureShift, 1.0 + temperatureShift * 0.5, 1.0);
  vec3 coolShift = vec3(1.0, 1.0 + temperatureShift * 0.3, 1.0 + temperatureShift);
  
  // Musical intensity affects color saturation
  float saturationBoost = 1.0 + musicIntensity * 0.4;
  
  // Apply consciousness-aware color modulation
  vec3 temperatureColor = mix(coolShift, warmShift, consciousnessLevel);
  return baseColor * temperatureColor * saturationBoost;
}

// Temporal flow patterns for Year 3000 streaming effects
vec2 temporalFlowDirection(vec2 position, float time, vec2 musicFlow) {
  // Primary temporal stream
  vec2 primaryFlow = vec2(
    sin(time * 0.08 + position.x * 3.0),
    cos(time * 0.06 + position.y * 2.5)
  ) * 0.02;
  
  // Secondary consciousness flow
  vec2 consciousnessFlow = vec2(
    sin(time * 0.05 + position.y * 4.0),
    cos(time * 0.04 + position.x * 3.5)
  ) * 0.015;
  
  // Musical synchronization flow
  vec2 musicalSync = musicFlow * 0.01;
  
  return primaryFlow + consciousnessFlow + musicalSync;
}

// Membrane consciousness dynamics for organic boundaries
float membraneConsciousnessFlow(vec2 position, float fluidityIndex, float awarenessLevel) {
  // Base membrane oscillation
  float membraneBase = sin(position.x * 8.0 + position.y * 6.0) * 0.1;
  
  // Consciousness-driven membrane flexibility
  float consciousnessFlex = awarenessLevel * fluidityIndex * 0.2;
  
  // Organic membrane breathing
  float membraneBreath = sin(position.x * 3.0 + position.y * 4.0) * 0.05;
  
  return membraneBase + consciousnessFlex + membraneBreath;
}

// Advanced consciousness breathing patterns
float consciousnessMemoryBreathing(float time, float phase, float memoryIntensity) {
  // Primary consciousness rhythm
  float primaryRhythm = sin(time * 0.03 + phase) * 0.5;
  
  // Memory echo patterns
  float memoryEcho = sin(time * 0.08 + phase * 1.7) * 0.3 * memoryIntensity;
  
  // Deep awareness pulse
  float awarenessePulse = sin(time * 0.015 + phase * 0.5) * 0.2;
  
  return primaryRhythm + memoryEcho + awarenessePulse;
}`;
      CORRIDOR_SDF_FUNCTIONS = `
// Convert screen coordinates to polar coordinates for radial flow
vec2 toPolar(vec2 uv) {
  vec2 centered = uv - 0.5;
  float angle = atan(centered.y, centered.x);
  float radius = length(centered);
  return vec2(angle, radius);
}

// Convert polar coordinates back to cartesian
vec2 fromPolar(vec2 polar) {
  float angle = polar.x;
  float radius = polar.y;
  return vec2(cos(angle) * radius, sin(angle) * radius) + 0.5;
}

// Signed distance field for a circle
float circleSDF(vec2 uv, vec2 center, float radius) {
  return length(uv - center) - radius;
}

// Smooth minimum for blending SDFs
float smin(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

// Enhanced multiple bubble corridors with organic consciousness-aware animations
float bubbleCorridors(vec2 uv, float time, float intensity) {
  // ===== ENHANCED PRIMARY BUBBLE APERTURES =====
  // Create 6 main circular apertures arranged in a ring with dynamic bubble count
  float baseBubbleCount = 6.0;
  float dynamicBubbleCount = baseBubbleCount + floor(intensity * 2.0); // 6-8 bubbles based on intensity
  float ringRadius = 0.28 + sin(time * 0.15) * 0.08; // Breathing ring radius (0.20-0.36)
  
  float minBubbleDistance = 2.0; // Track closest bubble distance
  
  // Calculate distance to each bubble position with enhanced organic movement
  for(float i = 0.0; i < dynamicBubbleCount; i += 1.0) {
    // Enhanced organic rotation with breathing rhythm
    float bubbleAngle = (i / dynamicBubbleCount) * 2.0 * 3.14159 + time * 0.08;
    
    // Add organic spiral motion for consciousness effect
    float spiralOffset = sin(time * 0.25 + i * 0.6) * 0.15;
    float dynamicRingRadius = ringRadius + spiralOffset;
    
    // Bubble center position with enhanced organic movement
    vec2 bubbleCenter = vec2(0.5) + vec2(
      cos(bubbleAngle) * dynamicRingRadius,
      sin(bubbleAngle) * dynamicRingRadius
    );
    
    // Enhanced breathing/pulsing animation with multi-frequency modulation
    float breathingPhase = sin(time * 0.6 + i * 0.8) * 0.04;
    float organicPhase = sin(time * 0.35 + i * 1.2) * 0.03;
    float consciousnessPhase = sin(time * 0.18 + i * 0.5) * 0.025;
    
    vec2 organicMovement = vec2(
      sin(time * 0.3 + i * 0.7) * (breathingPhase + organicPhase),
      cos(time * 0.4 + i * 0.9) * (breathingPhase + consciousnessPhase)
    );
    
    vec2 animatedCenter = bubbleCenter + organicMovement;
    
    // Calculate distance from current pixel to this bubble center
    float distanceToBubble = length(uv - animatedCenter);
    minBubbleDistance = min(minBubbleDistance, distanceToBubble);
  }
  
  // ===== ENHANCED BUBBLE APERTURE SIZING =====
  // Enhanced bubble size with multi-wave expansion patterns
  float baseBubbleSize = 0.08 * intensity;
  float primaryPulse = sin(time * 1.5) * 0.35;
  float organicPulse = sin(time * 0.8) * 0.25;
  float consciousnessPulse = sin(time * 2.2) * 0.15;
  
  float expandedBubbleSize = baseBubbleSize * (1.0 + primaryPulse + organicPulse + consciousnessPulse);
  
  // Create clean circular apertures with enhanced soft edges
  float primaryBubbleMask = 1.0 - smoothstep(expandedBubbleSize * 0.6, expandedBubbleSize * 1.1, minBubbleDistance);
  
  // ===== ENHANCED SECONDARY BUBBLE LAYER =====
  // Add smaller secondary bubbles with organic movement
  float secondaryBubbleCount = 4.0 + floor(intensity * 1.0); // 4-5 secondary bubbles
  float baseSecondaryRadius = 0.15;
  float secondaryRingRadius = baseSecondaryRadius * (1.0 + sin(time * 0.12) * 0.3);
  float minSecondaryDistance = 2.0;
  
  for(float i = 0.0; i < secondaryBubbleCount; i += 1.0) {
    // Counter-rotating secondary bubbles with organic offset
    float secondaryAngle = (i / secondaryBubbleCount) * 2.0 * 3.14159 - time * 0.15 + 1.57;
    
    // Add organic wobble to secondary bubble positions
    float wobbleX = sin(time * 0.45 + i * 1.1) * 0.02;
    float wobbleY = cos(time * 0.55 + i * 0.8) * 0.02;
    
    vec2 secondaryCenter = vec2(0.5) + vec2(
      cos(secondaryAngle) * secondaryRingRadius + wobbleX,
      sin(secondaryAngle) * secondaryRingRadius + wobbleY
    );
    
    float distanceToSecondary = length(uv - secondaryCenter);
    minSecondaryDistance = min(minSecondaryDistance, distanceToSecondary);
  }
  
  float secondaryBubbleSize = baseBubbleSize * 0.5 * (1.0 + sin(time * 1.8) * 0.3);
  float secondaryBubbleMask = 1.0 - smoothstep(secondaryBubbleSize * 0.6, secondaryBubbleSize * 1.0, minSecondaryDistance);
  secondaryBubbleMask *= 0.75; // Make secondary bubbles dimmer for depth
  
  // ===== ENHANCED CENTER SPOTLIGHT BUBBLE =====
  // Enhanced central bubble with complex pulsing patterns
  float centerDistance = length(uv - vec2(0.5));
  float centerPrimaryPulse = sin(time * 2.0) * 0.4;
  float centerSecondaryPulse = sin(time * 3.5) * 0.2;
  float centerBreathingPulse = sin(time * 0.6) * 0.3;
  
  float centerBubbleSize = 0.06 * intensity * (1.0 + centerPrimaryPulse + centerSecondaryPulse + centerBreathingPulse);
  float centerBubbleMask = 1.0 - smoothstep(centerBubbleSize * 0.4, centerBubbleSize * 0.9, centerDistance);
  
  // ===== ENHANCED COMBINATION AND BLENDING =====
  // Use smooth maximum for organic blending instead of hard max
  float corridorMask = primaryBubbleMask;
  corridorMask = max(corridorMask, secondaryBubbleMask * 0.9);
  corridorMask = max(corridorMask, centerBubbleMask * 1.1); // Center bubble slightly stronger
  
  // Enhanced radial falloff with organic variation
  vec2 center = uv - vec2(0.5);
  float radialDistance = length(center);
  float organicVariation = sin(time * 0.3 + radialDistance * 8.0) * 0.05;
  float radialFalloff = 1.0 - smoothstep(0.0, 0.65 + organicVariation, radialDistance);
  corridorMask *= radialFalloff;
  
  // Enhanced organic breathing pattern with consciousness harmonics
  float primaryBreathing = sin(time * 0.4) * 0.15;
  float secondaryBreathing = sin(time * 0.25) * 0.08;
  float consciousnessBreathing = sin(time * 0.6) * 0.05;
  float breathingCycle = 0.85 + primaryBreathing + secondaryBreathing + consciousnessBreathing;
  corridorMask *= breathingCycle;
  
  // Add subtle noise variation for organic consciousness texture
  float noisePattern = sin(radialDistance * 12.0 + time * 0.5) * cos(radialDistance * 8.0 - time * 0.3) * 0.03;
  corridorMask += noisePattern * intensity * 0.5;
  
  return clamp(corridorMask, 0.0, 1.0);
}

// Perspective depth calculation for inward flow
float calculatePerspectiveDepth(vec2 uv, float time, float flowStrength) {
  vec2 polar = toPolar(uv);
  float radius = polar.y;
  
  // Create perspective tunnel effect
  float depth = 1.0 - radius;
  depth = pow(depth, 2.2); // Gamma correction for natural falloff
  
  // Add inward flow animation
  float flowPhase = time * flowStrength + radius * 8.0;
  depth += sin(flowPhase) * 0.05 * (1.0 - radius);
  
  return clamp(depth, 0.0, 1.0);
}

// Dynamic aperture sizing based on music response
float musicResponsiveAperture(float baseMask, float beatIntensity, float bassResponse) {
  // Beat response expands apertures
  float beatExpansion = 1.0 + beatIntensity * 0.3;
  
  // Bass response adds pulsing
  float bassPulse = sin(bassResponse * 10.0) * 0.1;
  
  // Apply modulations
  float responsiveMask = baseMask * beatExpansion + bassPulse;
  
  return clamp(responsiveMask, 0.0, 1.0);
}

// ===================================================================
// DUNGEON CORRIDOR TUNNEL FUNCTIONS
// ===================================================================

// Signed distance field for rounded rectangle (corridor tunnel shape)
float roundedRectangleSDF(vec2 uv, vec2 center, vec2 size, float radius) {
  vec2 d = abs(uv - center) - size;
  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius;
}

// Apply perspective transformation for 3D tunnel illusion
vec2 perspectiveTunnelTransform(vec2 uv, float depth, float focalLength) {
  // Transform to centered coordinates
  vec2 centered = uv - 0.5;
  
  // Apply perspective projection with vanishing point at center
  float perspectiveFactor = focalLength / (focalLength + depth);
  vec2 perspective = centered * perspectiveFactor;
  
  // Return to UV space
  return perspective + 0.5;
}

// Calculate surface normal from SDF for lighting
vec2 tunnelNormalFromSDF(vec2 uv, vec2 center, vec2 size, float radius) {
  const float epsilon = 0.001;
  
  float centerSDF = roundedRectangleSDF(uv, center, size, radius);
  float rightSDF = roundedRectangleSDF(uv + vec2(epsilon, 0.0), center, size, radius);
  float upSDF = roundedRectangleSDF(uv + vec2(0.0, epsilon), center, size, radius);
  
  return normalize(vec2(rightSDF - centerSDF, upSDF - centerSDF));
}

// Advanced lighting system for dungeon corridors
vec3 calculateTunnelLighting(vec2 uv, float tunnelMask, vec2 normal, float depth, float time, float intensity) {
  // ===== AMBIENT SHADOW LAYER =====
  // Create dark base for corridor walls
  float ambientShadow = 0.15; // Base darkness level
  vec3 shadowColor = vec3(0.05, 0.08, 0.12); // Cool blue-gray shadows
  
  // ===== EDGE HIGHLIGHT LAYER =====
  // Bright rim lighting along corridor edges using surface normals
  float edgeIntensity = 1.0 - smoothstep(0.0, 0.3, tunnelMask);
  float edgeHighlight = pow(edgeIntensity, 2.0) * 0.8;
  
  // Edge lighting color shifts with music (warmer for high energy)
  vec3 edgeLightColor = mix(
    vec3(0.4, 0.5, 0.8), // Cool blue edge light
    vec3(0.8, 0.6, 0.3), // Warm orange edge light
    intensity * 0.7
  );
  
  // ===== END LIGHT SOURCE =====
  // Dynamic light at tunnel end that pulses with music
  float distanceFromCenter = length(uv - vec2(0.5));
  float endLightFalloff = 1.0 / (1.0 + distanceFromCenter * 4.0); // Inverse square falloff
  
  // Music-responsive light intensity with breathing effect
  float lightPulse = sin(time * 2.0) * 0.3 + 0.7;
  float endLightIntensity = intensity * lightPulse * endLightFalloff;
  
  // End light color temperature (cooler when distant, warmer when close)
  vec3 endLightColor = mix(
    vec3(0.3, 0.4, 0.9), // Cool distant light
    vec3(0.9, 0.7, 0.4), // Warm close light  
    endLightIntensity
  );
  
  // ===== FRESNEL EFFECT =====
  // Edge lighting intensity based on viewing angle
  vec2 viewDirection = normalize(uv - vec2(0.5));
  float fresnel = pow(1.0 - abs(dot(normal, viewDirection)), 2.0);
  
  // ===== COMBINE LIGHTING LAYERS =====
  vec3 ambientLayer = shadowColor * ambientShadow;
  vec3 edgeLayer = edgeLightColor * edgeHighlight * fresnel;
  vec3 endLayer = endLightColor * endLightIntensity * tunnelMask;
  
  // Apply depth-based attenuation
  float depthAttenuation = 1.0 - smoothstep(0.0, 1.0, depth);
  
  return (ambientLayer + edgeLayer + endLayer) * depthAttenuation;
}

// Create multiple dungeon corridor tunnels with realistic lighting
float dungeonCorridorTunnels(vec2 uv, float time, float intensity) {
  // ===== MAIN CORRIDOR TUNNELS =====
  float corridorCount = 4.0;
  float minCorridorDistance = 2.0;
  
  for(float i = 0.0; i < corridorCount; i += 1.0) {
    float corridorAngle = (i / corridorCount) * 2.0 * 3.14159 + time * 0.05;
    
    // Corridor center position with slight offset for organic feel
    vec2 corridorOffset = vec2(
      cos(corridorAngle) * 0.25,
      sin(corridorAngle) * 0.25
    );
    vec2 corridorCenter = vec2(0.5) + corridorOffset;
    
    // Apply perspective transformation for depth illusion
    float depth = 0.3 + sin(time * 0.3 + i) * 0.1;
    vec2 perspectiveUV = perspectiveTunnelTransform(uv, depth, 2.0);
    
    // Create elongated corridor tunnel shape
    vec2 corridorSize = vec2(0.15, 0.04) * (1.0 + intensity * 0.3); // Width varies with music
    float cornerRadius = 0.01;
    
    // Calculate distance to this corridor tunnel
    float corridorDistance = roundedRectangleSDF(perspectiveUV, corridorCenter, corridorSize, cornerRadius);
    minCorridorDistance = min(minCorridorDistance, corridorDistance);
  }
  
  // ===== SECONDARY TUNNEL LAYER =====
  // Add smaller secondary tunnels for depth complexity
  float secondaryCount = 2.0;
  float minSecondaryDistance = 2.0;
  
  for(float i = 0.0; i < secondaryCount; i += 1.0) {
    float secondaryAngle = (i / secondaryCount) * 2.0 * 3.14159 + time * 0.08 + 1.57;
    
    vec2 secondaryOffset = vec2(
      cos(secondaryAngle) * 0.15,
      sin(secondaryAngle) * 0.15  
    );
    vec2 secondaryCenter = vec2(0.5) + secondaryOffset;
    
    // Deeper perspective for secondary tunnels
    float secondaryDepth = 0.5 + sin(time * 0.2 + i) * 0.1;
    vec2 secondaryPerspectiveUV = perspectiveTunnelTransform(uv, secondaryDepth, 2.5);
    
    vec2 secondarySize = vec2(0.08, 0.025) * (1.0 + intensity * 0.2);
    float secondaryDistance = roundedRectangleSDF(secondaryPerspectiveUV, secondaryCenter, secondarySize, 0.005);
    minSecondaryDistance = min(minSecondaryDistance, secondaryDistance);
  }
  
  // ===== COMBINE TUNNEL LAYERS =====
  float primaryMask = 1.0 - smoothstep(0.0, 0.02, minCorridorDistance);
  float secondaryMask = 1.0 - smoothstep(0.0, 0.015, minSecondaryDistance);
  secondaryMask *= 0.7; // Dimmer secondary tunnels
  
  float combinedMask = max(primaryMask, secondaryMask);
  
  // ===== RADIAL FALLOFF FOR FOCUS =====
  vec2 center = uv - vec2(0.5);
  float radialDistance = length(center);
  float radialFalloff = 1.0 - smoothstep(0.2, 0.8, radialDistance);
  
  // ===== ORGANIC BREATHING PATTERN =====
  float breathingCycle = 0.9 + sin(time * 0.4) * 0.1;
  
  return clamp(combinedMask * radialFalloff * breathingCycle, 0.0, 1.0);
}

// Enhanced corridor gradient reveal with advanced dual-layer blending
vec4 corridorGradientReveal(vec2 uv, sampler2D gradientTex, float corridorMask, float time, float intensity) {
  // ===== ENHANCED BASE LAYER: Musical flow with consciousness awareness =====
  vec2 baseFlowUV = uv;
  vec2 flowDirection = normalize(vec2(1.0, 0.0));
  
  // Enhanced musical flow with multi-frequency modulation
  #ifdef HAS_FLOW_UNIFORMS
    flowDirection = normalize(u_musicalFlow.xy + vec2(0.001, 0.0));
  #endif
  
  // Multi-layered flow animation with consciousness patterns
  float primaryFlow = sin(time * 0.1) * 0.02;
  float organicFlow = sin(time * 0.07) * 0.015;
  float consciousnessFlow = sin(time * 0.13) * 0.008;
  
  baseFlowUV += flowDirection * (primaryFlow + organicFlow + consciousnessFlow);
  vec4 baseGradient = texture(gradientTex, vec2(baseFlowUV.x, 0.5));
  
  // Enhanced base layer with depth awareness
  vec2 polar = toPolar(uv);
  float baseDepthModulation = 1.0 + polar.y * 0.2; // Subtle depth variation
  baseGradient.rgb *= baseDepthModulation;
  
  // ===== ENHANCED CORRIDOR LAYER: Multi-dimensional inward flow =====
  float angle = polar.x;
  float radius = polar.y;
  
  // Advanced inward flow with multi-phase animation
  float primaryInwardPhase = time * 0.15 + radius * 6.0;
  float secondaryInwardPhase = time * 0.08 + radius * 4.5;
  float consciousnessInwardPhase = time * 0.22 + radius * 8.0;
  
  // Multi-layered inward flow combining multiple patterns
  float primaryInwardFlow = radius - (sin(primaryInwardPhase) * 0.1);
  float secondaryInwardFlow = radius - (cos(secondaryInwardPhase) * 0.06);
  float consciousnessInwardFlow = radius - (sin(consciousnessInwardPhase) * 0.04);
  
  float combinedInwardFlow = mix(
    mix(primaryInwardFlow, secondaryInwardFlow, 0.3),
    consciousnessInwardFlow, 0.2
  );
  
  // Enhanced gradient sampling with dual-layer coordination
  vec2 corridorFlowUV = vec2(
    fract(angle / (2.0 * 3.14159) + time * 0.02), // Slow rotation for organic feel
    clamp(combinedInwardFlow, 0.0, 1.0)
  );
  vec4 corridorGradient = texture(gradientTex, corridorFlowUV);
  
  // ===== ADVANCED DEPTH AND PERSPECTIVE =====
  float depth = calculatePerspectiveDepth(uv, time, intensity);
  
  // Enhanced tunnel brightness with organic variation
  float organicBrightnessVariation = sin(angle * 3.0 + time * 0.3) * 0.1;
  float tunnelBrightness = 1.0 + depth * 0.9 + organicBrightnessVariation;
  corridorGradient.rgb *= tunnelBrightness;
  
  // Advanced color shift with consciousness-aware color temperature
  vec3 warmShift = vec3(1.15, 1.05, 0.85); // Warm center
  vec3 coolShift = vec3(0.9, 1.0, 1.1);    // Cool edges
  vec3 colorTemperature = mix(coolShift, warmShift, depth);
  corridorGradient.rgb = mix(corridorGradient.rgb, corridorGradient.rgb * colorTemperature, depth * 0.4);
  
  // ===== ENHANCED DUAL-LAYER BLENDING =====
  // Multi-stage aperture masking for organic blending
  float softApertureMask = smoothstep(0.2, 0.8, corridorMask);
  float sharpApertureMask = smoothstep(0.4, 0.6, corridorMask);
  float organicApertureMask = mix(softApertureMask, sharpApertureMask, 0.6);
  
  // Enhanced blending with consciousness-aware mixing
  float consciousnessBlendFactor = 0.7 + sin(time * 0.4 + radius * 4.0) * 0.2;
  float dynamicIntensity = intensity * consciousnessBlendFactor;
  
  // Primary blend: base and corridor layers
  vec4 primaryBlend = mix(baseGradient, corridorGradient, organicApertureMask * dynamicIntensity);
  
  // ===== ADVANCED APERTURE EFFECTS =====
  // Enhanced rim lighting with organic variation 
  float rimLightBase = corridorMask * (1.0 - organicApertureMask);
  float rimLightVariation = sin(angle * 4.0 + time * 0.5) * 0.3 + 0.7;
  float enhancedRimLight = rimLightBase * rimLightVariation * 0.6;
  
  // Aperture glow effect for depth illusion
  float apertureGlow = softApertureMask * (1.0 - sharpApertureMask) * 0.4;
  vec3 glowColor = corridorGradient.rgb * 1.2;
  
  // ===== CONSCIOUSNESS-AWARE COLOR HARMONIZATION =====
  // Harmonize colors between layers for organic consciousness effect
  vec3 harmonizedColor = mix(
    primaryBlend.rgb,
    (primaryBlend.rgb + corridorGradient.rgb) * 0.5,
    organicApertureMask * 0.3
  );
  
  // Final composition with enhanced rim and glow effects
  vec4 finalColor = vec4(harmonizedColor, primaryBlend.a);
  finalColor.rgb += vec3(enhancedRimLight) * dynamicIntensity;
  finalColor.rgb += glowColor * apertureGlow * dynamicIntensity;
  
  // Organic breathing effect for consciousness integration
  float breathingCycle = 0.95 + sin(time * 0.3) * 0.05;
  finalColor.rgb *= breathingCycle;
  
  return finalColor;
}

// Advanced dungeon corridor gradient reveal with realistic lighting
vec4 dungeonCorridorGradientReveal(vec2 uv, sampler2D gradientTex, float corridorMask, float time, float intensity) {
  // ===== BASE LAYER: Dark stone/metal corridor walls =====
  vec4 baseWallColor = vec4(0.1, 0.12, 0.15, 1.0); // Dark stone base
  
  // ===== CORRIDOR TUNNEL CALCULATION =====
  // Use dungeon corridor tunnels instead of simple bubbles
  float tunnelMask = dungeonCorridorTunnels(uv, time, intensity);
  
  // ===== LIGHTING CALCULATION =====
  // Calculate lighting for tunnel areas
  vec2 tunnelCenter = vec2(0.5); // Simplified center for normal calculation
  vec2 tunnelSize = vec2(0.15, 0.04);
  vec2 surfaceNormal = tunnelNormalFromSDF(uv, tunnelCenter, tunnelSize, 0.01);
  
  float depth = length(uv - vec2(0.5)) * 0.5; // Distance-based depth
  vec3 tunnelLighting = calculateTunnelLighting(uv, tunnelMask, surfaceNormal, depth, time, intensity);
  
  // ===== CORRIDOR LAYER: Inward flowing magical light =====
  // Convert to polar coordinates for inward flow calculation
  vec2 polar = toPolar(uv);
  float angle = polar.x;
  float radius = polar.y;
  
  // Create magical inward flow animation - light streams toward center
  float magicalFlowPhase = time * 0.2 + radius * 8.0; // Faster flow for magical effect
  float inwardFlow = radius - (sin(magicalFlowPhase) * 0.15); // More dramatic flow
  
  // Sample gradient using inward flow for magical light colors
  vec2 corridorFlowUV = vec2(
    angle / (2.0 * 3.14159), // Normalize angle for gradient sampling
    clamp(inwardFlow, 0.0, 1.0) // Use inward flow for magical color variation
  );
  vec4 magicalLightGradient = texture(gradientTex, corridorFlowUV);
  
  // ===== ENHANCE MAGICAL LIGHT WITH MUSIC RESPONSIVENESS =====
  // Enhance magical light colors based on music intensity
  magicalLightGradient.rgb *= 1.5 + intensity * 0.8; // Brighter with music
  
  // Add magical shimmer effect
  float shimmerPhase = time * 4.0 + uv.x * 10.0 + uv.y * 8.0;
  float shimmer = sin(shimmerPhase) * 0.1 + 0.9;
  magicalLightGradient.rgb *= shimmer;
  
  // ===== DEPTH AND PERSPECTIVE EFFECTS =====
  float perspectiveDepth = calculatePerspectiveDepth(uv, time, intensity * 1.2);
  
  // Enhance magical light with depth - brighter toward tunnel end
  float tunnelEndBrightness = 1.0 + perspectiveDepth * 1.5;
  magicalLightGradient.rgb *= tunnelEndBrightness;
  
  // ===== CORRIDOR WALL TEXTURING =====
  // Add stone/metal texture to walls using noise-like patterns
  float wallTexturePhase = uv.x * 20.0 + uv.y * 15.0;
  float wallTexture = sin(wallTexturePhase) * 0.1 + 0.9;
  baseWallColor.rgb *= wallTexture;
  
  // ===== ADVANCED APERTURE BLENDING =====
  // Smooth tunnel aperture with realistic falloff
  float apertureMask = smoothstep(0.1, 0.8, tunnelMask);
  
  // ===== LIGHTING INTEGRATION =====
  // Apply calculated lighting to both wall and magical light
  vec4 litWallColor = baseWallColor;
  litWallColor.rgb += tunnelLighting; // Add ambient shadows, edge highlights, end illumination
  
  // Blend wall color with magical light streaming through tunnels
  vec4 finalColor = mix(litWallColor, magicalLightGradient, apertureMask * intensity);
  
  // ===== RIM LIGHTING FOR DEPTH ILLUSION =====
  // Enhanced rim lighting around tunnel apertures
  float rimIntensity = tunnelMask * (1.0 - apertureMask) * 0.8;
  vec3 rimColor = mix(
    vec3(0.3, 0.4, 0.8), // Cool rim light
    vec3(0.8, 0.5, 0.2), // Warm rim light
    intensity
  );
  finalColor.rgb += rimColor * rimIntensity;
  
  // ===== ATMOSPHERIC PERSPECTIVE =====
  // Add slight fog/haze effect for distance illusion
  float atmosphericHaze = depth * 0.2;
  vec3 hazeColor = vec3(0.15, 0.18, 0.25);
  finalColor.rgb = mix(finalColor.rgb, hazeColor, atmosphericHaze);
  
  return finalColor;
}`;
      STANDARD_CONSCIOUSNESS_UNIFORMS = `
// Time and resolution (universal)
uniform float u_time;
uniform vec2 u_resolution;

// Enhanced consciousness field uniforms
uniform float u_rhythmicPulse;
uniform vec2 u_musicalFlow;
uniform float u_energyResonance;
uniform float u_breathingCycle;
uniform float u_membraneFluidityIndex;

// Advanced consciousness control uniforms
uniform float u_consciousnessLevel;        // 0-1 current consciousness intensity
uniform float u_awarenessLevel;           // 0-1 current awareness depth
uniform float u_emotionalIntensity;       // 0-1 emotional resonance strength
uniform float u_memoryIntensity;          // 0-1 consciousness memory patterns
uniform vec2 u_temporalFlowDirection;     // Year 3000 temporal stream direction
uniform float u_consciousnessTemperature; // Color temperature shift from consciousness

// Enhanced music sync uniforms
uniform float u_musicEnergy;
uniform float u_musicValence;
uniform float u_beatIntensity;
uniform float u_bassResponse;
uniform float u_musicalConsciousnessSync; // Music-consciousness synchronization level
uniform float u_genreConsciousnessShift;  // Genre-specific consciousness adjustments

// Corridor-specific uniforms
uniform float u_corridorIntensity;
uniform float u_corridorFlowStrength;
uniform float u_corridorDepthEffect;
uniform float u_corridorBubbleScale;

// Dungeon corridor uniforms
uniform float u_dungeonEnabled;
uniform float u_tunnelWidth;
uniform float u_lightingIntensity;
uniform float u_atmosphericHaze;
uniform vec3 u_wallColor;`;
      _ShaderTemplate = class _ShaderTemplate {
        /**
         * Build a complete fragment shader from components
         */
        static buildFragmentShader(options) {
          const {
            precision = "precision mediump float;",
            additionalUniforms = "",
            additionalFunctions = "",
            mainShaderLogic,
            includeNoiseFunctions = true,
            includeConsciousnessFunctions = true,
            includeCorridorFunctions = false
          } = options;
          let shader = `#version 300 es
${precision}

`;
          shader += STANDARD_CONSCIOUSNESS_UNIFORMS + "\n\n";
          if (additionalUniforms) {
            shader += additionalUniforms + "\n\n";
          }
          shader += "out vec4 fragColor;\n\n";
          if (includeNoiseFunctions) {
            shader += SHARED_NOISE_FUNCTIONS + "\n\n";
          }
          if (includeConsciousnessFunctions) {
            shader += CONSCIOUSNESS_MODULATION_FUNCTIONS + "\n\n";
          }
          if (includeCorridorFunctions) {
            shader += CORRIDOR_SDF_FUNCTIONS + "\n\n";
          }
          if (additionalFunctions) {
            shader += additionalFunctions + "\n\n";
          }
          shader += "void main() {\n";
          shader += "  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n\n";
          shader += mainShaderLogic;
          shader += "\n}";
          return shader;
        }
        /**
         * Generate enhanced standard uniform names list for consciousness systems
         */
        static getStandardUniformNames() {
          return [
            "u_time",
            "u_resolution",
            "u_rhythmicPulse",
            "u_musicalFlow",
            "u_energyResonance",
            "u_breathingCycle",
            "u_membraneFluidityIndex",
            "u_consciousnessLevel",
            "u_awarenessLevel",
            "u_emotionalIntensity",
            "u_memoryIntensity",
            "u_temporalFlowDirection",
            "u_consciousnessTemperature",
            "u_musicEnergy",
            "u_musicValence",
            "u_beatIntensity",
            "u_bassResponse",
            "u_musicalConsciousnessSync",
            "u_genreConsciousnessShift"
          ];
        }
        /**
         * Generate WebGL-specific uniform names (for WebGL system)
         */
        static getWebGLUniformNames() {
          return [
            ...this.getStandardUniformNames(),
            "u_gradientTex",
            "u_flowStrength",
            "u_noiseScale",
            "u_colorIntensity",
            "u_patternScale",
            "u_animationSpeed"
          ];
        }
        /**
         * Generate liquid-specific uniform names (for Liquid system)
         */
        static getLiquidUniformNames() {
          return [
            ...this.getStandardUniformNames(),
            "u_gradientTex",
            "u_flowStrength",
            "u_noiseScale",
            "u_liquidPhase",
            "u_breathingIntensity",
            "u_auroraFlow",
            "u_flowDirection",
            "u_liquidTurbulence",
            "u_consciousnessDepth",
            "u_waveY",
            "u_waveHeight",
            "u_waveOffset",
            "u_blurExp",
            "u_blurMax"
          ];
        }
        /**
         * Get corridor-specific uniform names for system coordination
         * @returns Array of uniform names used in corridor shaders
         */
        static getCorridorUniformNames() {
          return [
            // Standard consciousness uniforms
            "u_time",
            "u_resolution",
            "u_gradientTex",
            "u_rhythmicPulse",
            "u_musicalFlow",
            "u_energyResonance",
            "u_breathingCycle",
            "u_membraneFluidityIndex",
            "u_musicEnergy",
            "u_musicValence",
            "u_beatIntensity",
            "u_bassResponse",
            // Corridor-specific uniforms
            "u_corridorIntensity",
            "u_corridorFlowStrength",
            "u_corridorDepthEffect",
            "u_corridorBubbleScale"
          ];
        }
        /**
         * Get dungeon corridor-specific uniform names for advanced tunnel effects
         * @returns Array of uniform names used in dungeon corridor shaders
         */
        static getDungeonCorridorUniformNames() {
          return [
            // Include all corridor uniforms
            ...this.getCorridorUniformNames(),
            // Dungeon-specific uniforms
            "u_dungeonEnabled",
            "u_tunnelWidth",
            "u_lightingIntensity",
            "u_atmosphericHaze",
            "u_wallColor"
          ];
        }
      };
      __name(_ShaderTemplate, "ShaderTemplate");
      ShaderTemplate = _ShaderTemplate;
      _ShaderLogicPatterns = class _ShaderLogicPatterns {
        /**
         * Enhanced consciousness-driven flow calculation with Year 3000 patterns
         */
        static consciousnessFlowLogic() {
          return `
  // Calculate enhanced consciousness-driven flow
  vec2 flowDirection = calculateMusicalFlow(vec2(1.0, 0.5), u_musicalFlow, 0.5);
  float flowStrength = rhythmicPulseModulation(0.5, u_rhythmicPulse, 0.3);
  
  // Add temporal flow patterns for Year 3000 effects
  vec2 temporalFlow = temporalFlowDirection(uv, u_time, u_temporalFlowDirection);
  flowDirection += temporalFlow;
  
  // Apply enhanced breathing modulation with emotional resonance
  float breathingMod = deepConsciousnessBreathing(u_time, 0.0, u_emotionalIntensity);
  flowStrength *= (1.0 + breathingMod);
  
  // Apply consciousness field intensity
  float fieldIntensity = consciousnessFieldIntensity(uv, u_time, u_musicEnergy);
  flowStrength *= (0.5 + fieldIntensity * 0.5);`;
        }
        /**
         * Enhanced noise-based texture sampling with advanced consciousness patterns
         */
        static consciousnessNoiseSampling() {
          return `
  // Generate enhanced consciousness-modulated noise
  vec2 noiseUV = uv + flowDirection * u_time * 0.03;
  
  // Multi-layered consciousness noise patterns
  float noise1 = snoise(noiseUV * 2.0);
  float noise2 = snoise(noiseUV * 4.0) * 0.5;
  float memoryNoise = snoise(noiseUV * 1.5 + u_time * 0.01) * u_memoryIntensity * 0.3;
  
  // Apply consciousness field modulation
  float consciousnessModulation = consciousnessFieldIntensity(noiseUV, u_time, u_musicEnergy);
  
  // Combine noise with enhanced consciousness influence
  float t = (noise1 + noise2 + memoryNoise) * energyResonanceModulation(1.0, u_energyResonance, 0.5, 1.5);
  t *= consciousnessModulation;
  t = clamp(t * 0.5 + 0.5, 0.0, 1.0);`;
        }
        /**
         * Enhanced consciousness-aware vignette with membrane dynamics
         */
        static consciousnessVignette() {
          return `
  // Apply enhanced consciousness-aware vignette
  vec2 center = uv - 0.5;
  float breathing = deepConsciousnessBreathing(u_time, u_breathingCycle, u_emotionalIntensity);
  
  // Add membrane consciousness flow for organic boundaries
  float membraneFlow = membraneConsciousnessFlow(uv, u_membraneFluidityIndex, u_awarenessLevel);
  
  // Calculate consciousness-aware vignette with membrane dynamics
  float vignette = (0.9 + breathing + membraneFlow) - dot(center, center) * 0.3;
  
  // Apply awareness resonance to color
  color.rgb = awarenessResonance(color.rgb, u_consciousnessLevel, u_musicEnergy);
  color.rgb *= vignette;`;
        }
        /**
         * Standard music-responsive alpha modulation
         */
        static musicResponsiveAlpha() {
          return `
  // Music-responsive alpha modulation
  float musicAlpha = 0.8 + u_beatIntensity * 0.2 + u_bassResponse * 0.1;
  color.a *= musicAlpha;`;
        }
        /**
         * Standard shimmer/aurora effect
         */
        static auroraShimmerEffect() {
          return `
  // Aurora shimmer overlay
  float shimmerPhase = u_time * 3.0 + uv.x * 15.0 + uv.y * 10.0;
  float shimmer = sin(shimmerPhase) * 0.03 + 0.97;
  color.rgb *= shimmer;`;
        }
      };
      __name(_ShaderLogicPatterns, "ShaderLogicPatterns");
      ShaderLogicPatterns = _ShaderLogicPatterns;
      _ConsciousnessShaderFragments = class _ConsciousnessShaderFragments {
        /**
         * WebGL gradient consciousness fragment
         * Optimized version of WebGL gradient shader logic
         */
        static webglGradientFragment() {
          return `
  ${ShaderLogicPatterns.consciousnessFlowLogic()}
  
  // WebGL-specific gradient sampling
  ${ShaderLogicPatterns.consciousnessNoiseSampling()}
  
  // Sample gradient texture
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));
  
  // Apply consciousness effects
  ${ShaderLogicPatterns.consciousnessVignette()}
  ${ShaderLogicPatterns.musicResponsiveAlpha()}
  
  fragColor = color;`;
        }
        /**
         * Liquid consciousness fragment
         * Core liquid effects with consciousness integration
         */
        static liquidConsciousnessFragment() {
          return `
  ${ShaderLogicPatterns.consciousnessFlowLogic()}
  
  // Liquid-specific turbulence and phase
  float liquidPhase = u_liquidPhase + u_rhythmicPulse * 0.5;
  vec2 turbulenceUV = uv * u_liquidTurbulence;
  float turbulence = snoise(turbulenceUV + u_time * 0.01);
  
  // Liquid consciousness noise
  vec2 liquidUV = uv + flowDirection * u_time * 0.03;
  liquidUV += vec2(sin(u_time * 0.04 + liquidPhase), cos(u_time * 0.03 + liquidPhase)) * 0.02;
  float liquidNoise = snoise(liquidUV * 2.0 + turbulence * 0.1);
  
  float t = clamp(liquidNoise * 0.5 + 0.5, 0.0, 1.0);
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));
  
  ${ShaderLogicPatterns.consciousnessVignette()}
  ${ShaderLogicPatterns.auroraShimmerEffect()}
  ${ShaderLogicPatterns.musicResponsiveAlpha()}
  
  fragColor = color;`;
        }
        /**
         * Corridor bubble consciousness fragment
         * Inward-flowing corridor effect with bubble apertures
         */
        static corridorBubbleFragment() {
          return `
  ${ShaderLogicPatterns.consciousnessFlowLogic()}
  
  // Calculate corridor bubble mask
  float corridorMask = bubbleCorridors(uv, u_time, u_corridorIntensity * u_corridorBubbleScale);
  
  // Apply music-responsive aperture modulation
  corridorMask = musicResponsiveAperture(corridorMask, u_beatIntensity, u_bassResponse);
  
  // Generate corridor gradient reveal effect
  vec4 color = corridorGradientReveal(uv, u_gradientTex, corridorMask, u_time, u_corridorIntensity);
  
  // Apply consciousness effects
  ${ShaderLogicPatterns.consciousnessVignette()}
  
  // Enhanced music responsiveness for corridor effects
  float corridorMusicAlpha = 0.85 + u_beatIntensity * 0.15 + u_bassResponse * 0.05;
  color.a *= corridorMusicAlpha;
  
  // Apply corridor depth effect for enhanced dimensionality
  float depth = calculatePerspectiveDepth(uv, u_time, u_corridorFlowStrength);
  color.rgb = mix(color.rgb, color.rgb * (1.0 + depth * 0.3), u_corridorDepthEffect);
  
  fragColor = color;`;
        }
        /**
         * Dungeon corridor consciousness fragment
         * Advanced tunnel corridors with realistic lighting and magical light sources  
         */
        static dungeonCorridorFragment() {
          return `
  ${ShaderLogicPatterns.consciousnessFlowLogic()}
  
  // Calculate dungeon corridor tunnel mask
  float corridorMask = dungeonCorridorTunnels(uv, u_time, u_corridorIntensity * u_corridorBubbleScale);
  
  // Apply music-responsive corridor modulation  
  corridorMask = musicResponsiveAperture(corridorMask, u_beatIntensity, u_bassResponse);
  
  // Generate advanced dungeon corridor gradient reveal effect with realistic lighting
  vec4 color = dungeonCorridorGradientReveal(uv, u_gradientTex, corridorMask, u_time, u_corridorIntensity);
  
  // Apply consciousness effects for organic integration
  ${ShaderLogicPatterns.consciousnessVignette()}
  
  // Enhanced music responsiveness for dungeon atmosphere
  float dungeonMusicAlpha = 0.9 + u_beatIntensity * 0.1 + u_bassResponse * 0.05;
  color.a *= dungeonMusicAlpha;
  
  // Apply corridor depth effect for enhanced dimensionality
  float depth = calculatePerspectiveDepth(uv, u_time, u_corridorFlowStrength);
  color.rgb = mix(color.rgb, color.rgb * (1.0 + depth * 0.4), u_corridorDepthEffect);
  
  // Add subtle magical shimmer for mystical atmosphere
  float magicalShimmer = sin(u_time * 5.0 + uv.x * 12.0 + uv.y * 8.0) * 0.05 + 0.95;
  color.rgb *= magicalShimmer;
  
  fragColor = color;`;
        }
        /**
         * Advanced consciousness field fragment
         * Multi-dimensional consciousness patterns with Year 3000 temporal effects
         */
        static advancedConsciousnessFieldFragment() {
          return `
  ${ShaderLogicPatterns.consciousnessFlowLogic()}
  
  // Calculate multi-dimensional consciousness field
  float consciousnessField = consciousnessFieldIntensity(uv, u_time, u_musicEnergy);
  
  // Apply temporal flow effects for Year 3000 streaming
  vec2 temporalUV = uv + temporalFlowDirection(uv, u_time, u_temporalFlowDirection);
  
  // Enhanced consciousness noise sampling with memory patterns
  ${ShaderLogicPatterns.consciousnessNoiseSampling()}
  
  // Sample gradient with consciousness field modulation
  vec4 color = texture(u_gradientTex, vec2(t * consciousnessField, 0.5));
  
  // Apply awareness resonance for consciousness-aware color
  color.rgb = awarenessResonance(color.rgb, u_consciousnessLevel, u_musicEnergy);
  
  // Enhanced membrane consciousness effects
  float membraneEffect = membraneConsciousnessFlow(temporalUV, u_membraneFluidityIndex, u_awarenessLevel);
  color.rgb *= (1.0 + membraneEffect * 0.3);
  
  // Apply consciousness memory breathing
  float memoryBreathing = consciousnessMemoryBreathing(u_time, u_breathingCycle, u_memoryIntensity);
  color.a *= (0.8 + memoryBreathing * 0.2 + u_beatIntensity * 0.1);
  
  // Enhanced consciousness vignette
  ${ShaderLogicPatterns.consciousnessVignette()}
  
  fragColor = color;`;
        }
        /**
         * Membrane consciousness dynamics fragment
         * Organic boundary system with consciousness-aware membrane behavior
         */
        static membraneConsciousnessDynamicsFragment() {
          return `
  ${ShaderLogicPatterns.consciousnessFlowLogic()}
  
  // Calculate membrane consciousness position with flow
  vec2 membraneUV = uv;
  membraneUV += temporalFlowDirection(uv, u_time, u_temporalFlowDirection);
  
  // Apply membrane consciousness flow for organic boundaries
  float membraneFlow = membraneConsciousnessFlow(membraneUV, u_membraneFluidityIndex, u_awarenessLevel);
  membraneUV += vec2(membraneFlow * 0.02);
  
  // Enhanced noise sampling with membrane distortion
  vec2 noiseUV = membraneUV + flowDirection * u_time * 0.03;
  float membraneNoise = snoise(noiseUV * 3.0 + membraneFlow);
  float consciousnessNoise = snoise(noiseUV * 1.5) * u_consciousnessLevel;
  
  // Combine membrane and consciousness noise
  float t = (membraneNoise * 0.6 + consciousnessNoise * 0.4) * 0.5 + 0.5;
  t = clamp(t, 0.0, 1.0);
  
  // Sample gradient with membrane consciousness modulation
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));
  
  // Apply consciousness field influence to membrane
  float fieldInfluence = consciousnessFieldIntensity(membraneUV, u_time, u_musicEnergy);
  color.rgb = awarenessResonance(color.rgb, fieldInfluence, u_musicEnergy);
  
  // Enhanced membrane breathing with emotional resonance
  float membraneBreathing = deepConsciousnessBreathing(u_time, u_breathingCycle, u_emotionalIntensity);
  color.rgb *= (0.9 + membraneBreathing * 0.2 + membraneFlow * 0.1);
  
  // Musical consciousness synchronization
  color.a *= (0.85 + u_musicalConsciousnessSync * 0.15 + u_beatIntensity * 0.1);
  
  // Apply enhanced vignette with membrane dynamics
  ${ShaderLogicPatterns.consciousnessVignette()}
  
  fragColor = color;`;
        }
      };
      __name(_ConsciousnessShaderFragments, "ConsciousnessShaderFragments");
      ConsciousnessShaderFragments = _ConsciousnessShaderFragments;
      _ShaderOptimizationUtils = class _ShaderOptimizationUtils {
        /**
         * Generate optimized shader based on performance level
         */
        static generateOptimizedShader(baseShaderLogic, performanceLevel) {
          switch (performanceLevel) {
            case "high":
              return baseShaderLogic;
            case "medium":
              return baseShaderLogic.replace(/snoise\(.*?\)/g, "snoise($1)").replace(/\* 0\.0[1-9]/g, "* 0.02");
            case "low":
              return baseShaderLogic.replace(/snoise\(.*?\) \* 0\.[0-9]+/g, "0.5").replace(/sin\(.*?\) \* 0\.[0-9]+/g, "0.0");
            default:
              return baseShaderLogic;
          }
        }
        /**
         * Calculate shader complexity score for performance monitoring
         */
        static calculateShaderComplexity(shaderSource) {
          let complexity = 0;
          complexity += (shaderSource.match(/snoise/g) || []).length * 10;
          complexity += (shaderSource.match(/sin|cos|tan/g) || []).length * 2;
          complexity += (shaderSource.match(/texture/g) || []).length * 3;
          complexity += (shaderSource.match(/mix|smoothstep/g) || []).length * 1;
          return complexity;
        }
        /**
         * Generate fallback shader for low-performance situations
         */
        static generateFallbackShader() {
          return ShaderTemplate.buildFragmentShader({
            includeNoiseFunctions: false,
            includeConsciousnessFunctions: false,
            additionalUniforms: "uniform sampler2D u_gradientTex;",
            mainShaderLogic: `
  // Minimal fallback consciousness shader
  float t = uv.x + sin(u_time * 0.5 + u_rhythmicPulse) * 0.1;
  t = clamp(t, 0.0, 1.0);
  
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));
  color.a *= 0.8 + u_beatIntensity * 0.2;
  
  fragColor = color;`
          });
        }
      };
      __name(_ShaderOptimizationUtils, "ShaderOptimizationUtils");
      ShaderOptimizationUtils = _ShaderOptimizationUtils;
      CONSCIOUSNESS_SHADER_LIBRARY = {
        // Templates and builders
        Template: ShaderTemplate,
        // Shared components
        VERTEX_SHADER: STANDARD_CONSCIOUSNESS_VERTEX_SHADER,
        NOISE_FUNCTIONS: SHARED_NOISE_FUNCTIONS,
        CONSCIOUSNESS_FUNCTIONS: CONSCIOUSNESS_MODULATION_FUNCTIONS,
        CORRIDOR_FUNCTIONS: CORRIDOR_SDF_FUNCTIONS,
        STANDARD_UNIFORMS: STANDARD_CONSCIOUSNESS_UNIFORMS,
        // Logic patterns
        LogicPatterns: ShaderLogicPatterns,
        // Enhanced consciousness fragments
        Fragments: ConsciousnessShaderFragments,
        // Optimization utilities
        Optimization: ShaderOptimizationUtils,
        // Advanced consciousness effects
        AdvancedEffects: {
          CONSCIOUSNESS_FIELD_PATTERNS: [
            "consciousnessFieldIntensity",
            "awarenessResonance",
            "temporalFlowDirection",
            "membraneConsciousnessFlow",
            "consciousnessMemoryBreathing"
          ],
          YEAR_3000_PATTERNS: [
            "temporalFlowDirection",
            "consciousnessMemoryBreathing",
            "deepConsciousnessBreathing"
          ],
          MEMBRANE_DYNAMICS: [
            "membraneConsciousnessFlow",
            "membraneFluidityEffect"
          ]
        }
      };
    }
  });

  // src-js/visual/backgrounds/WebGLGradientBackgroundSystem.ts
  var webglConsciousnessShader, corridorBubbleShader, _WebGLGradientBackgroundSystem, WebGLGradientBackgroundSystem;
  var init_WebGLGradientBackgroundSystem = __esm({
    "src-js/visual/backgrounds/WebGLGradientBackgroundSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_ShaderLoader();
      init_BaseVisualSystem();
      init_ConsolidatedShaderLibrary();
      webglConsciousnessShader = ShaderTemplate.buildFragmentShader({
        additionalUniforms: `
// WebGL-specific uniforms
uniform sampler2D u_gradientTex;
uniform float u_flowStrength;
uniform float u_noiseScale;
uniform float u_colorIntensity;
uniform float u_patternScale;
uniform float u_animationSpeed;

// Wave stack uniforms
uniform float u_waveY[2];
uniform float u_waveHeight[2];
uniform float u_waveOffset[2];
uniform float u_blurExp;
uniform float u_blurMax;`,
        additionalFunctions: `
// Octave noise for richer detail
float octaveNoise(vec2 uv, float octaves, float persistence, float scale) {
  float value = 0.0;
  float amplitude = 1.0;
  float frequency = scale;
  float maxValue = 0.0;

  for(float i = 0.0; i < octaves; i++) {
    value += snoise(uv * frequency) * amplitude;
    maxValue += amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return value / maxValue;
}

// Wave alpha calculation
float waveAlpha(vec2 uv, int waveIndex) {
  float y = uv.y;
  float waveCenter = u_waveY[waveIndex];
  float waveHeight = u_waveHeight[waveIndex];

  float distance = abs(y - waveCenter);
  return 1.0 - smoothstep(0.0, waveHeight * 0.5, distance);
}

// Dynamic blur calculation
float calculateBlur(vec2 uv) {
  vec2 center = vec2(0.5, 0.5);
  float distance = length(uv - center);
  float blur = pow(distance, u_blurExp);
  return clamp(blur, 0.0, u_blurMax);
}`,
        mainShaderLogic: CONSCIOUSNESS_SHADER_LIBRARY.Fragments.webglGradientFragment()
      });
      corridorBubbleShader = ShaderTemplate.buildFragmentShader({
        additionalUniforms: `
// WebGL-specific uniforms
uniform sampler2D u_gradientTex;
uniform float u_flowStrength;
uniform float u_noiseScale;`,
        includeCorridorFunctions: true,
        mainShaderLogic: CONSCIOUSNESS_SHADER_LIBRARY.Fragments.corridorBubbleFragment()
      });
      _WebGLGradientBackgroundSystem = class _WebGLGradientBackgroundSystem extends BaseVisualSystem {
        constructor(config = YEAR3000_CONFIG, utils, performanceMonitor, musicSyncService = null, settingsManager2 = null, year3000System2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this.canvas = null;
          this.wrapper = null;
          this.gl = null;
          this.shaderProgram = null;
          this.corridorShaderProgram = null;
          this.uniforms = {};
          this.corridorUniforms = {};
          this.gradientTexture = null;
          this.vertexBuffer = null;
          this.vao = null;
          this.settings = {
            enabled: true,
            intensity: "balanced",
            webglPersistenceMode: "adaptive",
            // Default to current behavior, user can change to "persistent"
            flowStrength: 0.7,
            noiseScale: 1.2,
            waveY: [0.25, 0.75],
            // Wave positions from theme metrics
            waveHeight: [0.4, 0.3],
            // Wave heights for smooth blending
            waveOffset: [2.5, -1.8],
            // Time offsets for wave independence
            blurExp: 1.2,
            // Blur power function exponent
            blurMax: 0.6,
            // Maximum blur amount
            // Corridor bubble settings
            corridorEnabled: false,
            // Start disabled for smooth transition
            corridorIntensity: 0.8,
            corridorFlowStrength: 1.2,
            corridorDepthEffect: 0.6,
            corridorBubbleScale: 1
          };
          this.isWebGLAvailable = false;
          this.animationId = null;
          this.startTime = 0;
          this.lastFrameTime = 0;
          this.frameThrottleInterval = 1e3 / 45;
          // 45 FPS target
          this.colorHarmonyEngine = null;
          this.cssConsciousnessController = null;
          this.eventSubscriptionIds = [];
          this.prefersReducedMotion = false;
          // Consciousness choreographer integration
          this.consciousnessChoreographer = null;
          this.currentConsciousnessField = null;
          this.webglReady = false;
          // Texture creation throttling and debouncing
          this.textureUpdatePending = false;
          this.lastTextureUpdate = 0;
          this.textureUpdateDebounceTimer = null;
          this.textureUpdateThrottleMs = 50;
          // Minimum time between texture updates (made mutable for quality scaling)
          this.textureUpdateDebounceMs = 300;
          // Debounce time for rapid events
          this.textureCreationInProgress = false;
          // WebGL context management (Enhanced Context Recovery with Exponential Backoff)
          this.contextLost = false;
          this.pendingContextRestore = false;
          this.contextLossCount = 0;
          // Track consecutive context losses
          this.maxContextLossRetries = 10;
          // Allow up to 10 attempts over 30 seconds
          this.lastSuccessfulRender = 0;
          // Track successful renders for context loss reset
          this.contextRecoveryTimeouts = [100, 200, 400, 800, 1600, 3200, 5e3, 5e3, 5e3, 5e3];
          // Exponential backoff in ms
          this.currentRecoveryAttempt = 0;
          // Quality scaling properties
          this.currentQualityLevel = null;
          this.qualityCapabilities = [
            { name: "webgl-rendering", enabled: true, qualityLevel: "high" },
            {
              name: "shader-complexity",
              enabled: true,
              qualityLevel: "high"
            },
            { name: "noise-octaves", enabled: true, qualityLevel: "medium" },
            { name: "wave-layers", enabled: true, qualityLevel: "medium" },
            { name: "blur-effects", enabled: true, qualityLevel: "low" },
            { name: "flow-strength", enabled: true, qualityLevel: "low" },
            // Corridor-specific quality capabilities
            { name: "corridor-effects", enabled: true, qualityLevel: "high" },
            { name: "corridor-sdf-complexity", enabled: true, qualityLevel: "medium" },
            { name: "corridor-bubble-layers", enabled: true, qualityLevel: "medium" },
            { name: "corridor-depth-effects", enabled: true, qualityLevel: "low" }
          ];
          this.qualityAdjustments = {};
          // Required BackgroundSystemParticipant implementation
          this.systemName = "WebGLGradientBackgroundSystem";
          // Event deduplication tracking
          this.lastColorHarmonizedData = null;
          this.lastColorHarmonizedTime = 0;
          this.animate = /* @__PURE__ */ __name(() => {
            if (!this.isActive || !this.gl || !this.canvas) return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.lastFrameTime;
            if (deltaTime < this.frameThrottleInterval) {
              this.animationId = requestAnimationFrame(this.animate);
              return;
            }
            this.lastFrameTime = currentTime;
            this.render(currentTime);
            this.animationId = requestAnimationFrame(this.animate);
          }, "animate");
          this.resize = /* @__PURE__ */ __name(() => {
            if (!this.canvas) return;
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            this.canvas.width = displayWidth * dpr;
            this.canvas.height = displayHeight * dpr;
            this.canvas.style.width = displayWidth + "px";
            this.canvas.style.height = displayHeight + "px";
          }, "resize");
          this.colorHarmonyEngine = year3000System2?.colorHarmonyEngine || null;
          this.consciousnessChoreographer = year3000System2?.backgroundConsciousnessChoreographer || null;
          this.prefersReducedMotion = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;
        }
        get systemPriority() {
          return "high";
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          const year3000System2 = globalThis.year3000System;
          this.cssController = year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
          this.isWebGLAvailable = this.checkWebGL2Support();
          if (!this.isWebGLAvailable) {
            if (this.shouldAttemptWebGLRecovery()) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "WebGL2 not available but persistence mode enabled - attempting WebGL1 compatibility mode"
              );
              this.isWebGLAvailable = this.checkWebGL1Support();
              if (!this.isWebGLAvailable) {
                Y3KDebug?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "Neither WebGL2 nor WebGL1 available despite persistence mode"
                );
                this.fallbackToCSSGradient();
                return;
              }
            } else {
              this.fallbackToCSSGradient();
              return;
            }
          }
          const deviceDetector = new DeviceCapabilityDetector();
          await deviceDetector.initialize();
          const performanceQuality = deviceDetector.recommendPerformanceQuality();
          const capabilities = deviceDetector.getCapabilities();
          if (performanceQuality === "low") {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Low performance device detected - trying minimal WebGL quality",
              {
                performanceQuality,
                deviceCapabilities: capabilities?.overall,
                memoryLevel: capabilities?.memory.level,
                gpuLevel: capabilities?.gpu.level
              }
            );
            this.frameThrottleInterval = 1e3 / 20;
            this.textureUpdateThrottleMs = 1e3;
            this.settings.corridorEnabled = false;
            this.settings.intensity = "minimal";
            this.settings.flowStrength = 0.3;
          } else {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Device capabilities acceptable for WebGL",
              {
                performanceQuality,
                deviceCapabilities: capabilities?.overall
              }
            );
          }
          this.loadSettings();
          if (!this.settings.enabled) {
            this.fallbackToCSSGradient();
            return;
          }
          try {
            await this.initializeWebGL();
            this.subscribeToEvents();
            this.registerWithConsciousnessChoreographer();
            this.startAnimation();
            const webglInitVariables = {
              "--sn.bg.webgl.ready": "1",
              "--sn.bg.webgl.enabled": "1",
              "--sn.bg.active-backend": "hybrid",
              "--sn-gradient-crossfade-opacity": "0.5"
              // 50% blend
            };
            this.cssController.batchSetVariables(
              "WebGLGradientBackgroundSystem",
              webglInitVariables,
              "high",
              // High priority for WebGL initialization
              "webgl-initialization"
            );
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL gradient system initialized successfully"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Failed to initialize WebGL gradient:",
              error
            );
            this.fallbackToCSSGradient();
          }
        }
        checkWebGL2Support() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl2");
            if (!gl) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "WebGL2 context creation failed"
              );
              return false;
            }
            const requiredExtensions = ["EXT_color_buffer_float"];
            const missingExtensions = [];
            for (const ext of requiredExtensions) {
              if (!gl.getExtension(ext)) {
                missingExtensions.push(ext);
              }
            }
            if (missingExtensions.length > 0) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "Missing WebGL2 extensions:",
                missingExtensions
              );
            }
            const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            const maxRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL2 capability check:",
              {
                maxTextureSize,
                maxRenderbufferSize,
                missingExtensions: missingExtensions.length > 0 ? missingExtensions : "none"
              }
            );
            return true;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "WebGL2 support check failed:",
              error
            );
            return false;
          }
        }
        checkWebGL1Support() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "WebGL1 context creation failed"
              );
              return false;
            }
            const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            const maxRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL1 fallback capability check:",
              {
                maxTextureSize,
                maxRenderbufferSize
              }
            );
            return true;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "WebGL1 support check failed:",
              error
            );
            return false;
          }
        }
        findSpotifyContainer() {
          const containers = [
            ".Root__main-view",
            ".main-view-container",
            ".main-gridContainer-gridContainer",
            ".Root__top-container",
            "body"
          ];
          for (const selector of containers) {
            const element = document.querySelector(selector);
            if (element) {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                `Found container: ${selector}`
              );
              return element;
            }
          }
          Y3KDebug?.debug?.warn(
            "WebGLGradientBackgroundSystem",
            "No Spotify container found, falling back to body"
          );
          return document.body;
        }
        loadSettings() {
          if (!this.settingsManager) return;
          try {
            const webglEnabled = this.settingsManager.get("sn-webgl-enabled");
            const webglForceEnabled = this.settingsManager.get("sn-webgl-force-enabled");
            const persistenceMode = this.settingsManager.get("sn-webgl-persistence-mode");
            const intensitySetting = this.settingsManager.get("sn-gradient-intensity");
            if (webglEnabled === "false" && webglForceEnabled !== "true") {
              this.settings.enabled = false;
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "WebGL disabled by user setting"
              );
              return;
            }
            this.settings.webglPersistenceMode = persistenceMode || "adaptive";
            if (intensitySetting === "disabled") {
              this.settings.enabled = false;
              return;
            }
            this.settings.intensity = intensitySetting || "balanced";
            switch (this.settings.intensity) {
              case "minimal":
                this.settings.flowStrength = 0.4;
                this.settings.noiseScale = 0.8;
                this.settings.waveHeight = [0.3, 0.2];
                this.settings.waveOffset = [1.5, -1];
                this.settings.blurExp = 1;
                this.settings.blurMax = 0.4;
                break;
              case "balanced":
                this.settings.flowStrength = 0.7;
                this.settings.noiseScale = 1.2;
                this.settings.waveHeight = [0.4, 0.3];
                this.settings.waveOffset = [2.5, -1.8];
                this.settings.blurExp = 1.2;
                this.settings.blurMax = 0.6;
                break;
              case "intense":
                this.settings.flowStrength = 1;
                this.settings.noiseScale = 1.6;
                this.settings.waveHeight = [0.5, 0.4];
                this.settings.waveOffset = [3.5, -2.5];
                this.settings.blurExp = 1.4;
                this.settings.blurMax = 0.8;
                break;
            }
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Settings loaded:",
              {
                webglEnabled,
                webglForceEnabled,
                persistenceMode: this.settings.webglPersistenceMode,
                intensity: this.settings.intensity,
                enabled: this.settings.enabled
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "Failed to load settings, using defaults:",
              error
            );
          }
        }
        /**
         * Handle runtime setting changes (implements ISettingsResponsiveSystem pattern)
         */
        applyUpdatedSettings(key, value) {
          if (!this.settingsManager) return;
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Runtime setting changed: ${key} = ${value}`
          );
          try {
            switch (key) {
              case "sn-webgl-enabled":
                if (value === "false") {
                  this.settings.enabled = false;
                  this.destroy();
                } else if (value === "true" && !this.settings.enabled) {
                  this.settings.enabled = true;
                  if (!this.gl && this.canvas) {
                    this.initialize();
                  }
                }
                break;
              case "sn-webgl-force-enabled":
                const webglEnabled = this.settingsManager.get("sn-webgl-enabled");
                if (webglEnabled === "false" && value !== "true") {
                  this.settings.enabled = false;
                  this.destroy();
                }
                break;
              case "sn-webgl-persistence-mode":
                this.settings.webglPersistenceMode = value || "adaptive";
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `Persistence mode changed to: ${this.settings.webglPersistenceMode}`
                );
                break;
              case "sn-gradient-intensity":
                if (value === "disabled") {
                  this.settings.enabled = false;
                } else {
                  this.settings.enabled = true;
                  this.settings.intensity = value || "balanced";
                  switch (this.settings.intensity) {
                    case "minimal":
                      this.settings.flowStrength = 0.4;
                      this.settings.noiseScale = 0.8;
                      this.settings.waveHeight = [0.3, 0.2];
                      this.settings.waveOffset = [1.5, -1];
                      this.settings.blurExp = 1;
                      this.settings.blurMax = 0.4;
                      break;
                    case "balanced":
                      this.settings.flowStrength = 0.7;
                      this.settings.noiseScale = 1.2;
                      this.settings.waveHeight = [0.4, 0.3];
                      this.settings.waveOffset = [2.5, -1.8];
                      this.settings.blurExp = 1.2;
                      this.settings.blurMax = 0.6;
                      break;
                    case "intense":
                      this.settings.flowStrength = 1;
                      this.settings.noiseScale = 1.6;
                      this.settings.waveHeight = [0.5, 0.4];
                      this.settings.waveOffset = [3.5, -2.5];
                      this.settings.blurExp = 1.4;
                      this.settings.blurMax = 0.8;
                      break;
                  }
                }
                break;
              default:
                return;
            }
            this.forceRepaint?.(`setting-change:${key}`);
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              `Failed to apply runtime setting ${key}:`,
              error
            );
          }
        }
        async initializeWebGL() {
          this.wrapper = document.createElement("div");
          this.wrapper.className = "sn-gradient-effects-wrapper";
          this.wrapper.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -11;
      pointer-events: none;
      overflow: hidden;
    `;
          this.canvas = document.createElement("canvas");
          this.canvas.id = "sn-webgl-gradient";
          this.canvas.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    `;
          this.wrapper.appendChild(this.canvas);
          try {
            this.gl = this.canvas.getContext("webgl2", {
              alpha: true,
              antialias: false,
              depth: false,
              stencil: false,
              powerPreference: "default"
            });
            if (!this.gl) {
              throw new Error(
                "WebGL2 context creation returned null - likely unsupported"
              );
            }
            this.setupContextLossHandlers();
            const testResult = this.gl.getParameter(this.gl.VERSION);
            if (!testResult) {
              throw new Error(
                "WebGL2 context appears non-functional - getParameter failed"
              );
            }
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL2 context created successfully:",
              {
                version: testResult,
                renderer: this.gl.getParameter(this.gl.RENDERER),
                vendor: this.gl.getParameter(this.gl.VENDOR)
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "WebGL2 context creation failed:",
              error
            );
            throw new Error(
              `Failed to create WebGL2 context: ${error instanceof Error ? error.message : "Unknown error"}`
            );
          }
          await this.compileShaders();
          this.createGeometry();
          await this.updateGradientTexture();
          this.setupUniforms();
          this.resize();
          const targetContainer = this.findSpotifyContainer();
          targetContainer.appendChild(this.wrapper);
          window.addEventListener("resize", this.resize.bind(this));
        }
        async compileShaders() {
          if (!this.gl) throw new Error("WebGL context not available");
          let vertexShader = null;
          let fragmentShader = null;
          let shaderVariant = "full";
          vertexShader = ShaderLoader.loadVertex(this.gl, DEFAULT_VERTEX_SHADER);
          if (!vertexShader) {
            throw new Error("Failed to compile vertex shader - even basic vertex shader failed");
          }
          const fragmentShaderVariants = [
            {
              name: "full",
              shader: webglConsciousnessShader,
              description: "Full consciousness shader with all features"
            },
            {
              name: "simplified",
              shader: this.getSimplifiedFragmentShader(),
              description: "Simplified shader without complex noise functions"
            },
            {
              name: "basic",
              shader: this.getBasicFragmentShader(),
              description: "Basic gradient shader with minimal features"
            },
            {
              name: "emergency",
              shader: this.getEmergencyFragmentShader(),
              description: "Emergency shader for maximum hardware compatibility"
            }
          ];
          for (const variant of fragmentShaderVariants) {
            try {
              fragmentShader = ShaderLoader.loadFragment(this.gl, variant.shader);
              if (fragmentShader) {
                shaderVariant = variant.name;
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `Successfully compiled shader variant: ${variant.name}`,
                  { description: variant.description }
                );
                break;
              }
            } catch (error) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                `Failed to compile ${variant.name} shader variant:`,
                error
              );
              continue;
            }
          }
          if (!fragmentShader) {
            throw new Error("Failed to compile any fragment shader variant");
          }
          this.shaderProgram = ShaderLoader.createProgram(
            this.gl,
            vertexShader,
            fragmentShader
          );
          if (!this.shaderProgram) {
            throw new Error("Failed to create shader program");
          }
          const corridorFragmentShader = ShaderLoader.loadFragment(
            this.gl,
            corridorBubbleShader
          );
          if (!corridorFragmentShader) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "Failed to compile corridor shader - corridor effects disabled"
            );
            this.settings.corridorEnabled = false;
            return;
          }
          this.corridorShaderProgram = ShaderLoader.createProgram(
            this.gl,
            vertexShader,
            // Reuse vertex shader
            corridorFragmentShader
          );
          if (!this.corridorShaderProgram) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "Failed to create corridor shader program - corridor effects disabled"
            );
            this.settings.corridorEnabled = false;
          }
        }
        createGeometry() {
          if (!this.gl || !this.shaderProgram) return;
          const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
          this.vertexBuffer = this.gl.createBuffer();
          this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
          this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
          this.vao = this.gl.createVertexArray();
          this.gl.bindVertexArray(this.vao);
          const positionLocation = this.gl.getAttribLocation(
            this.shaderProgram,
            "a_position"
          );
          this.gl.enableVertexAttribArray(positionLocation);
          this.gl.vertexAttribPointer(
            positionLocation,
            2,
            this.gl.FLOAT,
            false,
            0,
            0
          );
          this.gl.bindVertexArray(null);
        }
        setupUniforms() {
          if (!this.gl || !this.shaderProgram) return;
          this.uniforms.u_time = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_time"
          );
          this.uniforms.u_gradientTex = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_gradientTex"
          );
          this.uniforms.u_resolution = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_resolution"
          );
          this.uniforms.u_flowStrength = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_flowStrength"
          );
          this.uniforms.u_noiseScale = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_noiseScale"
          );
          this.uniforms.u_waveY = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveY"
          );
          this.uniforms.u_waveHeight = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveHeight"
          );
          this.uniforms.u_waveOffset = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveOffset"
          );
          this.uniforms.u_blurExp = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_blurExp"
          );
          this.uniforms.u_blurMax = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_blurMax"
          );
          if (this.corridorShaderProgram) {
            this.setupCorridorUniforms();
          }
        }
        setupCorridorUniforms() {
          if (!this.gl || !this.corridorShaderProgram) return;
          const corridorUniformNames = ShaderTemplate.getCorridorUniformNames();
          for (const uniformName of corridorUniformNames) {
            this.corridorUniforms[uniformName] = this.gl.getUniformLocation(
              this.corridorShaderProgram,
              uniformName
            );
          }
        }
        updateConsciousnessUniforms(uniforms, time) {
          if (!this.gl) return;
          const consciousnessField = this.currentConsciousnessField;
          const rhythmicPulse = consciousnessField?.rhythmicPulse ?? 0.5;
          if (uniforms.u_rhythmicPulse) {
            this.gl.uniform1f(uniforms.u_rhythmicPulse, rhythmicPulse);
          }
          const musicalFlow = consciousnessField?.musicalFlow ?? [0, 0];
          if (uniforms.u_musicalFlow && Array.isArray(musicalFlow)) {
            const flowArray = musicalFlow;
            this.gl.uniform2f(uniforms.u_musicalFlow, flowArray[0] ?? 0, flowArray[1] ?? 0);
          }
          const energyResonance = consciousnessField?.energyResonance ?? 0.5;
          if (uniforms.u_energyResonance) {
            this.gl.uniform1f(uniforms.u_energyResonance, energyResonance);
          }
          const breathingCycle = Math.sin(time * 0.05) * 0.5 + 0.5;
          if (uniforms.u_breathingCycle) {
            this.gl.uniform1f(uniforms.u_breathingCycle, breathingCycle);
          }
          const membraneFluidityIndex = consciousnessField?.membraneFluidityIndex ?? 0.3;
          if (uniforms.u_membraneFluidityIndex) {
            this.gl.uniform1f(uniforms.u_membraneFluidityIndex, membraneFluidityIndex);
          }
          if (this.musicSyncService) {
            const musicState = this.musicSyncService.getCurrentMusicState();
            if (musicState) {
              const musicEnergy = musicState.beat?.energy ?? 0.5;
              const musicValence = musicState.emotion?.valence ?? 0.5;
              const beatIntensity = musicState.intensity ?? 0;
              const bassResponse = musicState.beat?.energy ?? 0;
              if (uniforms.u_musicEnergy) {
                this.gl.uniform1f(uniforms.u_musicEnergy, musicEnergy);
              }
              if (uniforms.u_musicValence) {
                this.gl.uniform1f(uniforms.u_musicValence, musicValence);
              }
              if (uniforms.u_beatIntensity) {
                this.gl.uniform1f(uniforms.u_beatIntensity, beatIntensity);
              }
              if (uniforms.u_bassResponse) {
                this.gl.uniform1f(uniforms.u_bassResponse, bassResponse);
              }
            }
          }
        }
        async updateGradientTexture() {
          if (!this.gl) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "No WebGL context available"
            );
            return;
          }
          if (!this.isContextValid()) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "WebGL context invalid, attempting recovery"
            );
            if (this.contextLost && !this.pendingContextRestore) {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "Attempting WebGL context recovery"
              );
              this.fallbackToCSSGradient();
            }
            return;
          }
          const preError = this.gl.getError();
          if (preError !== this.gl.NO_ERROR) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              `WebGL error detected before texture update: ${preError}`
            );
            while (this.gl.getError() !== this.gl.NO_ERROR) {
            }
          }
          if (this.textureCreationInProgress) {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Texture creation already in progress, skipping update"
            );
            return;
          }
          this.textureCreationInProgress = true;
          try {
            let colorStops = this.getDefaultGradientStops();
            let colorSource = "default";
            if (this.colorHarmonyEngine) {
              try {
                const currentGradient = this.colorHarmonyEngine.getCurrentGradient(5);
                if (currentGradient && currentGradient.length > 0) {
                  colorStops = currentGradient.map((color3, index) => ({
                    r: color3.r / 255,
                    g: color3.g / 255,
                    b: color3.b / 255,
                    a: 1,
                    position: index / (currentGradient.length - 1)
                  }));
                  colorSource = "ColorHarmonyEngine";
                  Y3KDebug?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    `Updated gradient texture with ${colorStops.length} stops from ColorHarmonyEngine`
                  );
                } else {
                  const cssColorStops = this.getCSSGradientStops();
                  if (cssColorStops && cssColorStops.length > 0) {
                    colorStops = cssColorStops;
                    colorSource = "CSS variables";
                    Y3KDebug?.debug?.log(
                      "WebGLGradientBackgroundSystem",
                      `ColorHarmonyEngine returned empty, using CSS gradient fallback with ${colorStops.length} stops`
                    );
                  }
                }
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  "Failed to get gradient from ColorHarmonyEngine, trying CSS fallback:",
                  error
                );
                const cssColorStops = this.getCSSGradientStops();
                if (cssColorStops && cssColorStops.length > 0) {
                  colorStops = cssColorStops;
                  colorSource = "CSS variables (engine failed)";
                  Y3KDebug?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    `Using CSS gradient fallback after ColorHarmonyEngine error with ${colorStops.length} stops`
                  );
                }
              }
            } else {
              const cssColorStops = this.getCSSGradientStops();
              if (cssColorStops && cssColorStops.length > 0) {
                colorStops = cssColorStops;
                colorSource = "CSS variables (no engine)";
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `No ColorHarmonyEngine available, using CSS gradient fallback with ${colorStops.length} stops`
                );
              }
            }
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Final color source: ${colorSource}, stops: ${colorStops.length}`
            );
            if (this.gl.isContextLost()) {
              throw new Error("WebGL context was lost during gradient preparation");
            }
            if (this.gradientTexture) {
              try {
                this.gl.deleteTexture(this.gradientTexture);
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  "Error deleting old texture:",
                  error
                );
              }
              this.gradientTexture = null;
            }
            if (!colorStops || colorStops.length === 0) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "No valid color stops, using defaults"
              );
              colorStops = this.getDefaultGradientStops();
            }
            let newTexture = null;
            let attempts = 0;
            const maxAttempts = 3;
            while (!newTexture && attempts < maxAttempts) {
              attempts++;
              try {
                if (this.gl.isContextLost()) {
                  throw new Error(
                    "WebGL context lost during texture creation attempt"
                  );
                }
                newTexture = createGradientTexture(this.gl, colorStops);
                if (newTexture) {
                  Y3KDebug?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    `Gradient texture created successfully on attempt ${attempts}`
                  );
                  break;
                }
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  `Texture creation attempt ${attempts} failed:`,
                  error
                );
                if (attempts < maxAttempts) {
                  await new Promise((resolve) => setTimeout(resolve, attempts * 10));
                }
              }
            }
            if (!newTexture) {
              Y3KDebug?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Failed to create gradient texture after all attempts - trying default colors"
              );
              try {
                const defaultStops = this.getDefaultGradientStops();
                const fallbackTexture = createGradientTexture(this.gl, defaultStops);
                if (!fallbackTexture) {
                  throw new Error(
                    "Failed to create gradient texture even with default colors"
                  );
                }
                this.gradientTexture = fallbackTexture;
                colorStops = defaultStops;
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  "Using default gradient fallback after all attempts failed"
                );
              } catch (fallbackError) {
                Y3KDebug?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "Default gradient fallback failed, attempting emergency solid color:",
                  fallbackError
                );
                try {
                  const emergencySolidStops = [
                    { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 0 },
                    // Catppuccin base
                    { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 1 }
                    // Same color
                  ];
                  const emergencyTexture = createGradientTexture(this.gl, emergencySolidStops);
                  if (emergencyTexture) {
                    this.gradientTexture = emergencyTexture;
                    colorStops = emergencySolidStops;
                    Y3KDebug?.debug?.warn(
                      "WebGLGradientBackgroundSystem",
                      "Using emergency solid color texture as final fallback"
                    );
                  } else {
                    throw new Error("Emergency solid color texture creation failed");
                  }
                } catch (emergencyError) {
                  Y3KDebug?.debug?.error(
                    "WebGLGradientBackgroundSystem",
                    "Emergency solid color texture failed:",
                    emergencyError
                  );
                  throw new Error(
                    `All gradient texture creation methods failed: ${emergencyError}`
                  );
                }
              }
            } else {
              this.gradientTexture = newTexture;
            }
            this.lastTextureUpdate = performance.now();
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Gradient texture updated successfully using ${colorSource}`,
              {
                colorStops: colorStops.length,
                source: colorSource,
                firstColor: colorStops[0] ? `rgb(${Math.round(colorStops[0].r * 255)},${Math.round(
                  colorStops[0].g * 255
                )},${Math.round(colorStops[0].b * 255)})` : "none"
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Critical error in updateGradientTexture:",
              error
            );
            if (error instanceof Error && error.message.includes("context")) {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "WebGL context-related error detected, switching to CSS fallback"
              );
              this.fallbackToCSSGradient();
            } else {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "Attempting simple texture recovery with default colors"
              );
              try {
                this.gradientTexture = null;
                const defaultStops = this.getDefaultGradientStops();
                if (this.gl && !this.gl.isContextLost()) {
                  this.gradientTexture = createGradientTexture(this.gl, defaultStops);
                  if (this.gradientTexture) {
                    Y3KDebug?.debug?.log(
                      "WebGLGradientBackgroundSystem",
                      "Successfully recovered with default gradient"
                    );
                  } else {
                    throw new Error("Recovery attempt failed");
                  }
                } else {
                  throw new Error("WebGL context unavailable for recovery");
                }
              } catch (recoveryError) {
                Y3KDebug?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "Recovery attempt failed, falling back to CSS:",
                  recoveryError
                );
                this.fallbackToCSSGradient();
              }
            }
          } finally {
            this.textureCreationInProgress = false;
          }
        }
        /**
         * Throttled texture update to prevent rapid-fire texture creation
         */
        async updateGradientTextureThrottled() {
          const now = performance.now();
          if (now - this.lastTextureUpdate < this.textureUpdateThrottleMs) {
            if (!this.textureUpdatePending) {
              this.textureUpdatePending = true;
              const timeToWait = this.textureUpdateThrottleMs - (now - this.lastTextureUpdate);
              setTimeout(() => {
                this.textureUpdatePending = false;
                this.updateGradientTexture().catch((error) => {
                  Y3KDebug?.debug?.error(
                    "WebGLGradientBackgroundSystem",
                    "Throttled texture update failed:",
                    error
                  );
                });
              }, timeToWait);
            }
            return;
          }
          await this.updateGradientTexture();
        }
        /**
         * Debounced texture update to handle rapid event sequences
         */
        debouncedUpdateGradientTexture() {
          if (this.textureUpdateDebounceTimer) {
            clearTimeout(this.textureUpdateDebounceTimer);
          }
          this.textureUpdateDebounceTimer = window.setTimeout(() => {
            this.textureUpdateDebounceTimer = null;
            this.updateGradientTextureThrottled().catch((error) => {
              Y3KDebug?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Debounced texture update failed:",
                error
              );
            });
          }, this.textureUpdateDebounceMs);
        }
        /**
         * Setup WebGL context loss and restore event handlers
         */
        setupContextLossHandlers() {
          if (!this.canvas) return;
          this.canvas.addEventListener(
            "webglcontextlost",
            async (event) => {
              this.contextLossCount++;
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "WebGL context lost - Enhanced Recovery",
                {
                  lossCount: this.contextLossCount,
                  maxRetries: this.maxContextLossRetries
                }
              );
              event.preventDefault();
              this.contextLost = true;
              this.textureCreationInProgress = false;
              if (this.contextLossCount <= this.maxContextLossRetries) {
                const attemptIndex = Math.min(this.contextLossCount - 1, this.contextRecoveryTimeouts.length - 1);
                const backoffDelay = this.contextRecoveryTimeouts[attemptIndex] || 5e3;
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `Preparing for context recovery attempt ${this.contextLossCount}/${this.maxContextLossRetries} with ${backoffDelay}ms backoff`,
                  { shouldPersist: this.shouldPersistWebGL() }
                );
                if (this.gl) {
                  try {
                    const { ShaderLoader: ShaderLoader2 } = await Promise.resolve().then(() => (init_ShaderLoader(), ShaderLoader_exports));
                    ShaderLoader2.clearContextCache(this.gl);
                  } catch (e) {
                  }
                }
                if (this.textureUpdateDebounceTimer) {
                  clearTimeout(this.textureUpdateDebounceTimer);
                  this.textureUpdateDebounceTimer = null;
                }
                this.textureUpdatePending = false;
                if (this.animationId) {
                  cancelAnimationFrame(this.animationId);
                  this.animationId = null;
                }
              } else {
                if (this.shouldPersistWebGL()) {
                  Y3KDebug?.debug?.warn(
                    "WebGLGradientBackgroundSystem",
                    `Context lost ${this.contextLossCount} times but persistence mode enabled - resetting retry count and continuing`
                  );
                  this.contextLossCount = Math.max(1, this.maxContextLossRetries - 3);
                  this.currentRecoveryAttempt = 0;
                } else {
                  Y3KDebug?.debug?.error(
                    "WebGLGradientBackgroundSystem",
                    `Context lost ${this.contextLossCount} times - falling back to CSS gradient`
                  );
                  this.fallbackToCSSGradient();
                }
              }
            },
            false
          );
          const attemptContextRecovery = /* @__PURE__ */ __name(async () => {
            if (!this.contextLost || this.pendingContextRestore) {
              return;
            }
            const attemptIndex = Math.min(this.currentRecoveryAttempt, this.contextRecoveryTimeouts.length - 1);
            const backoffDelay = this.contextRecoveryTimeouts[attemptIndex] || 5e3;
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Attempting context recovery in ${backoffDelay}ms (attempt ${this.currentRecoveryAttempt + 1})`
            );
            setTimeout(async () => {
              if (!this.contextLost) {
                return;
              }
              this.currentRecoveryAttempt++;
              try {
                if (this.gl && this.gl.isContextLost()) {
                  this.gl.getError();
                }
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  "Error during context recovery attempt:",
                  error
                );
              }
              if (this.contextLost && this.currentRecoveryAttempt < this.maxContextLossRetries) {
                attemptContextRecovery();
              }
            }, backoffDelay);
          }, "attemptContextRecovery");
          this.canvas.addEventListener("webglcontextlost", () => {
            this.currentRecoveryAttempt = 0;
            attemptContextRecovery();
          });
          this.canvas.addEventListener(
            "webglcontextrestored",
            async () => {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "WebGL context restored - Enhanced Recovery",
                {
                  lossCount: this.contextLossCount,
                  maxRetries: this.maxContextLossRetries
                }
              );
              this.contextLost = false;
              this.pendingContextRestore = true;
              try {
                if (!this.gl || this.gl.isContextLost()) {
                  throw new Error("Context is still lost after restore event");
                }
                await this.reinitializeWebGLResources();
                if (this.contextLossCount >= 2) {
                  Y3KDebug?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    "Reducing quality after multiple context losses"
                  );
                  this.adjustQualityForTier("low");
                } else if (this.contextLossCount >= 1) {
                  Y3KDebug?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    "Reducing quality after context loss"
                  );
                  this.adjustQualityForTier("medium");
                }
                this.startAnimation();
                this.pendingContextRestore = false;
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  "WebGL context restore completed successfully",
                  {
                    lossCount: this.contextLossCount,
                    qualityReduced: this.contextLossCount > 0
                  }
                );
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "Failed to restore WebGL context:",
                  error
                );
                this.pendingContextRestore = false;
                this.contextLossCount++;
                if (this.contextLossCount > this.maxContextLossRetries) {
                  Y3KDebug?.debug?.error(
                    "WebGLGradientBackgroundSystem",
                    "Context restoration failed too many times - falling back to CSS"
                  );
                  this.fallbackToCSSGradient();
                }
              }
            },
            false
          );
        }
        /**
         * Reinitialize WebGL resources after context restore
         */
        async reinitializeWebGLResources() {
          if (!this.gl) throw new Error("WebGL context not available");
          this.shaderProgram = null;
          this.vertexBuffer = null;
          this.vao = null;
          this.gradientTexture = null;
          const { ShaderLoader: ShaderLoader2 } = await Promise.resolve().then(() => (init_ShaderLoader(), ShaderLoader_exports));
          ShaderLoader2.clearContextCache(this.gl);
          await this.compileShaders();
          this.createGeometry();
          await this.updateGradientTexture();
          this.setupUniforms();
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "WebGL resources reinitialized after context restore"
          );
        }
        /**
         * Check if WebGL context is available and functional
         */
        isContextValid() {
          if (!this.gl) return false;
          if (this.contextLost) return false;
          if (this.gl.isContextLost()) {
            this.contextLost = true;
            return false;
          }
          return true;
        }
        getDefaultGradientStops() {
          return [
            { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 0 },
            // Base
            { r: 0.549, g: 0.408, b: 0.878, a: 1, position: 0.3 },
            // Mauve
            { r: 0.788, g: 0.557, b: 0.902, a: 1, position: 0.6 },
            // Pink
            { r: 0.957, g: 0.761, b: 0.494, a: 1, position: 1 }
            // Peach
          ];
        }
        /**
         * Get gradient color stops from CSS variables that inherit from ColorHarmonyEngine
         * These variables are set by OKLAB processing and represent the actual background gradient colors
         */
        getCSSGradientStops() {
          try {
            const root = document.documentElement;
            const computedStyle = getComputedStyle(root);
            const gradientVariables = [
              "--sn-bg-gradient-primary-rgb",
              "--sn-bg-gradient-secondary-rgb",
              "--sn-bg-gradient-tertiary-rgb"
            ];
            const colorStops = [];
            for (let i = 0; i < gradientVariables.length; i++) {
              const variableName = gradientVariables[i] || "--sn-bg-gradient-primary-rgb";
              const rgbStr = computedStyle.getPropertyValue(variableName).trim();
              if (!rgbStr) {
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `CSS variable ${variableName} not set, trying without CSS fallback`
                );
                continue;
              }
              const rgbValues = rgbStr.split(",").map((v) => parseInt(v.trim(), 10));
              if (rgbValues.length !== 3 || rgbValues.some((v) => isNaN(v) || v < 0 || v > 255)) {
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  `Invalid RGB values in ${variableName}: ${rgbStr}, skipping this color`
                );
                continue;
              }
              colorStops.push({
                r: (rgbValues[0] ?? 0) / 255,
                g: (rgbValues[1] ?? 0) / 255,
                b: (rgbValues[2] ?? 0) / 255,
                a: 1,
                position: i / (gradientVariables.length - 1)
              });
            }
            if (colorStops.length < 2) {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                `Only ${colorStops.length} valid CSS colors found, need at least 2 for gradient`
              );
              return null;
            }
            const opacityStr = computedStyle.getPropertyValue("--sn-bg-gradient-opacity").trim();
            const opacity = opacityStr ? parseFloat(opacityStr) : 1;
            if (opacity !== 1 && opacity > 0 && opacity <= 1) {
              colorStops.forEach((stop) => {
                stop.a = opacity;
              });
            }
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Successfully parsed ${colorStops.length} CSS background gradient stops from OKLAB inheritance`,
              {
                colors: colorStops.map(
                  (stop) => `rgba(${Math.round(stop.r * 255)},${Math.round(
                    stop.g * 255
                  )},${Math.round(stop.b * 255)},${stop.a})`
                ),
                opacity: opacity !== 1 ? opacity : "default"
              }
            );
            return colorStops;
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "Failed to parse CSS background gradient variables:",
              error
            );
            return null;
          }
        }
        subscribeToEvents() {
          const colorHarmonizedSub = unifiedEventBus.subscribe(
            "colors:harmonized",
            this.handleColorHarmonized.bind(this),
            "WebGLGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(colorHarmonizedSub);
          const colorAppliedSub = unifiedEventBus.subscribe(
            "colors:applied",
            this.handleColorApplied.bind(this),
            "WebGLGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(colorAppliedSub);
          const performanceTierSub = unifiedEventBus.subscribe(
            "performance:tier-changed",
            this.handlePerformanceTierChanged.bind(this),
            "WebGLGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(performanceTierSub);
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Subscribed to unified events",
            {
              subscriptionCount: this.eventSubscriptionIds.length,
              events: ["colors:harmonized", "colors:applied", "performance:tier-changed"]
            }
          );
        }
        handleColorHarmonized(data) {
          const currentTime = performance.now();
          const dataHash = `${data.accentHex}-${data.processingTime}-${data.strategies.join(",")}`;
          if (this.lastColorHarmonizedData === dataHash && currentTime - this.lastColorHarmonizedTime < 100) {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Duplicate color harmonization event detected, skipping"
            );
            return;
          }
          this.lastColorHarmonizedData = dataHash;
          this.lastColorHarmonizedTime = currentTime;
          this.debouncedUpdateGradientTexture();
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Color harmonization processed",
            {
              strategies: data.strategies,
              processingTime: data.processingTime,
              accentHex: data.accentHex,
              deduplicationHash: dataHash.substring(0, 16) + "..."
            }
          );
        }
        handleColorApplied(data) {
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Color application coordinated",
            {
              accentHex: data.accentHex,
              appliedAt: data.appliedAt
            }
          );
        }
        /**
         * Handle performance tier changes for quality scaling (High Priority Fix)
         * Implements progressive quality reduction instead of immediate fallback
         */
        handlePerformanceTierChanged(data) {
          if (!this.isActive || !this.gl) {
            return;
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Performance tier changed",
            {
              previousTier: data.previousTier,
              newTier: data.tier,
              timestamp: data.timestamp
            }
          );
          switch (data.tier) {
            case "excellent":
              this.adjustQualityForTier("high");
              break;
            case "good":
              this.adjustQualityForTier("medium");
              break;
            case "degraded":
              this.adjustQualityForTier("low");
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "Performance degraded - reducing WebGL quality instead of fallback"
              );
              break;
            case "critical":
              if (data.previousTier === "degraded") {
                if (this.shouldPersistWebGL()) {
                  Y3KDebug?.debug?.warn(
                    "WebGLGradientBackgroundSystem",
                    "Critical performance but persistence mode enabled - reducing to absolute minimum WebGL quality"
                  );
                  this.adjustQualityForTier("emergency");
                } else {
                  Y3KDebug?.debug?.warn(
                    "WebGLGradientBackgroundSystem",
                    "Critical performance detected - falling back to CSS gradient"
                  );
                  this.fallbackToCSSGradient();
                }
              } else {
                this.adjustQualityForTier("minimal");
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  "Critical performance - using minimal WebGL quality"
                );
              }
              break;
          }
        }
        /**
         * Adjust WebGL quality based on performance tier
         */
        adjustQualityForTier(qualityTier) {
          if (!this.gl || !this.canvas) return;
          switch (qualityTier) {
            case "high":
              this.frameThrottleInterval = 1e3 / 60;
              break;
            case "medium":
              this.frameThrottleInterval = 1e3 / 45;
              break;
            case "low":
              this.frameThrottleInterval = 1e3 / 30;
              break;
            case "minimal":
              this.frameThrottleInterval = 1e3 / 15;
              break;
            case "emergency":
              this.frameThrottleInterval = 1e3 / 10;
              break;
          }
          switch (qualityTier) {
            case "high":
              this.textureUpdateThrottleMs = 100;
              break;
            case "medium":
              this.textureUpdateThrottleMs = 200;
              break;
            case "low":
              this.textureUpdateThrottleMs = 500;
              break;
            case "minimal":
              this.textureUpdateThrottleMs = 1e3;
              break;
            case "emergency":
              this.textureUpdateThrottleMs = 2e3;
              break;
          }
          const container = this.findSpotifyContainer();
          if (container) {
            const containerRect = container.getBoundingClientRect();
            let scaleFactor = 1;
            switch (qualityTier) {
              case "high":
                scaleFactor = 1;
                break;
              case "medium":
                scaleFactor = 0.8;
                break;
              case "low":
                scaleFactor = 0.6;
                break;
              case "minimal":
                scaleFactor = 0.4;
                break;
              case "emergency":
                scaleFactor = 0.1;
                break;
            }
            const newWidth = Math.floor(containerRect.width * scaleFactor);
            const newHeight = Math.floor(containerRect.height * scaleFactor);
            this.canvas.width = newWidth;
            this.canvas.height = newHeight;
            if (this.gl) {
              this.gl.viewport(0, 0, newWidth, newHeight);
            }
          }
          const wasCorridorEnabled = this.settings.corridorEnabled;
          switch (qualityTier) {
            case "high":
              this.settings.intensity = "intense";
              this.settings.flowStrength = Math.max(this.settings.flowStrength, 0.7);
              break;
            case "medium":
              this.settings.intensity = "balanced";
              this.settings.flowStrength = Math.min(this.settings.flowStrength, 0.6);
              break;
            case "low":
              this.settings.corridorEnabled = false;
              this.settings.intensity = "minimal";
              this.settings.flowStrength = Math.min(this.settings.flowStrength, 0.4);
              break;
            case "minimal":
              this.settings.corridorEnabled = false;
              this.settings.intensity = "minimal";
              this.settings.flowStrength = 0.2;
              break;
          }
          if (wasCorridorEnabled !== this.settings.corridorEnabled) {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Corridor shader ${this.settings.corridorEnabled ? "enabled" : "disabled"} for ${qualityTier} quality`
            );
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Quality adjusted for ${qualityTier} performance tier`,
            {
              frameFPS: Math.round(1e3 / this.frameThrottleInterval),
              textureFPS: Math.round(1e3 / this.textureUpdateThrottleMs),
              canvasResolution: `${this.canvas.width}x${this.canvas.height}`,
              corridorEnabled: this.settings.corridorEnabled
            }
          );
        }
        startAnimation() {
          this.startTime = performance.now();
          this.lastFrameTime = this.startTime;
          this.animate();
        }
        render(currentTime) {
          if (!this.gl || !this.vao) return;
          if (!this.gradientTexture) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "No gradient texture during render - creating emergency texture"
            );
            try {
              const emergencyTextures = [
                () => {
                  const cssStops = this.getCSSGradientStops();
                  return cssStops ? createGradientTexture(this.gl, cssStops) : null;
                },
                () => {
                  const defaultStops = this.getDefaultGradientStops();
                  return createGradientTexture(this.gl, defaultStops);
                },
                () => {
                  const solidStops = [
                    { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 0 },
                    // Catppuccin base
                    { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 1 }
                    // Same color
                  ];
                  return createGradientTexture(this.gl, solidStops);
                }
              ];
              for (let i = 0; i < emergencyTextures.length; i++) {
                try {
                  this.gradientTexture = emergencyTextures[i]();
                  if (this.gradientTexture) {
                    Y3KDebug?.debug?.log(
                      "WebGLGradientBackgroundSystem",
                      `Emergency texture created using method ${i + 1}`
                    );
                    break;
                  }
                } catch (error) {
                  Y3KDebug?.debug?.warn(
                    "WebGLGradientBackgroundSystem",
                    `Emergency texture method ${i + 1} failed:`,
                    error
                  );
                }
              }
              if (!this.gradientTexture) {
                Y3KDebug?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "All emergency texture creation methods failed - skipping render"
                );
                return;
              }
            } catch (error) {
              Y3KDebug?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Emergency texture creation failed completely:",
                error
              );
              return;
            }
          }
          this.lastSuccessfulRender = currentTime;
          if (this.contextLossCount > 0 && currentTime - this.lastSuccessfulRender > 3e4) {
            const oldCount = this.contextLossCount;
            this.contextLossCount = Math.max(0, this.contextLossCount - 1);
            if (oldCount !== this.contextLossCount) {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "Context loss count reduced due to successful renders",
                {
                  oldCount,
                  newCount: this.contextLossCount
                }
              );
            }
          }
          const useCorridorShader = this.settings.corridorEnabled && this.corridorShaderProgram && this.currentQualityLevel !== "low";
          const currentShaderProgram = useCorridorShader ? this.corridorShaderProgram : this.shaderProgram;
          const currentUniforms = useCorridorShader ? this.corridorUniforms : this.uniforms;
          if (!currentShaderProgram) return;
          this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
          this.gl.clearColor(0, 0, 0, 0);
          this.gl.clear(this.gl.COLOR_BUFFER_BIT);
          this.gl.useProgram(currentShaderProgram);
          this.gl.bindVertexArray(this.vao);
          if (!this.webglReady) {
            this.webglReady = true;
            const webglReadyVariables = {
              "--sn.bg.webgl.ready": "1",
              "--sn.bg.webgl.enabled": "1",
              "--sn.bg.active-backend": "hybrid",
              "--sn-gradient-crossfade-opacity": "0.5"
              // Balanced hybrid blend
            };
            this.cssController.batchSetVariables(
              "WebGLGradientBackgroundSystem",
              webglReadyVariables,
              "critical",
              // Critical priority for first draw
              "webgl-first-draw"
            );
          }
          const time = this.prefersReducedMotion ? 0 : (currentTime - this.startTime) / 1e3;
          if (currentUniforms.u_time) {
            this.gl.uniform1f(currentUniforms.u_time, time);
          }
          if (currentUniforms.u_resolution) {
            this.gl.uniform2f(
              currentUniforms.u_resolution,
              this.canvas.width,
              this.canvas.height
            );
          }
          if (currentUniforms.u_flowStrength) {
            let flowStrength = this.settings.flowStrength;
            try {
              const computedStyle = getComputedStyle(document.documentElement);
              const flowStrengthValue = computedStyle.getPropertyValue("--sn-flow-strength").trim();
              if (flowStrengthValue) {
                flowStrength = parseFloat(flowStrengthValue);
              }
            } catch (error) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "Failed to read flow strength CSS variable, using settings value"
              );
            }
            this.gl.uniform1f(currentUniforms.u_flowStrength, flowStrength);
          }
          if (currentUniforms.u_noiseScale) {
            this.gl.uniform1f(currentUniforms.u_noiseScale, this.settings.noiseScale);
          }
          if (!useCorridorShader) {
            if (currentUniforms.u_waveY) {
              this.gl.uniform1fv(currentUniforms.u_waveY, this.settings.waveY);
            }
            if (currentUniforms.u_waveHeight) {
              this.gl.uniform1fv(currentUniforms.u_waveHeight, this.settings.waveHeight);
            }
            if (currentUniforms.u_waveOffset) {
              this.gl.uniform1fv(currentUniforms.u_waveOffset, this.settings.waveOffset);
            }
            if (currentUniforms.u_blurExp) {
              this.gl.uniform1f(currentUniforms.u_blurExp, this.settings.blurExp);
            }
            if (currentUniforms.u_blurMax) {
              this.gl.uniform1f(currentUniforms.u_blurMax, this.settings.blurMax);
            }
          }
          if (useCorridorShader) {
            if (currentUniforms.u_corridorIntensity) {
              this.gl.uniform1f(currentUniforms.u_corridorIntensity, this.settings.corridorIntensity);
            }
            if (currentUniforms.u_corridorFlowStrength) {
              this.gl.uniform1f(currentUniforms.u_corridorFlowStrength, this.settings.corridorFlowStrength);
            }
            if (currentUniforms.u_corridorDepthEffect) {
              this.gl.uniform1f(currentUniforms.u_corridorDepthEffect, this.settings.corridorDepthEffect);
            }
            if (currentUniforms.u_corridorBubbleScale) {
              this.gl.uniform1f(currentUniforms.u_corridorBubbleScale, this.settings.corridorBubbleScale);
            }
            this.updateConsciousnessUniforms(currentUniforms, time);
          }
          this.gl.activeTexture(this.gl.TEXTURE0);
          this.gl.bindTexture(this.gl.TEXTURE_2D, this.gradientTexture);
          if (currentUniforms.u_gradientTex) {
            this.gl.uniform1i(currentUniforms.u_gradientTex, 0);
          }
          this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
          this.gl.bindVertexArray(null);
        }
        fallbackToCSSGradient() {
          const cssFallbackVariables = {
            "--sn.bg.webgl.ready": "0",
            "--sn.bg.webgl.enabled": "0",
            "--sn.bg.active-backend": "css",
            "--sn-gradient-crossfade-opacity": "0"
            // Full CSS opacity
          };
          this.cssController.batchSetVariables(
            "WebGLGradientBackgroundSystem",
            cssFallbackVariables,
            "critical",
            // Critical priority for fallback
            "webgl-css-fallback"
          );
          if (this.cssConsciousnessController) {
            this.startCSSFallbackAnimation();
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Using CSS gradient fallback"
          );
        }
        startCSSFallbackAnimation() {
          if (!this.cssConsciousnessController) return;
          const animateCSS = /* @__PURE__ */ __name(() => {
            if (!this.isActive) return;
            const time = performance.now() / 1e3;
            const flowX = Math.sin(time * 0.04) * 20 + Math.sin(time * 0.07) * 8;
            const flowY = Math.cos(time * 0.05) * 20 + Math.cos(time * 0.09) * 6;
            const scale = 1.15 + Math.sin(time * 0.03) * 0.2;
            const fallbackAnimationVariables = {
              "--sn-gradient-flow-x": `${flowX}%`,
              "--sn-gradient-flow-y": `${flowY}%`,
              "--sn-gradient-flow-scale": scale.toString()
            };
            this.cssController.batchSetVariables(
              "WebGLGradientBackgroundSystem",
              fallbackAnimationVariables,
              "normal",
              // Normal priority for animation
              "css-fallback-animation"
            );
            setTimeout(animateCSS, this.frameThrottleInterval);
          }, "animateCSS");
          animateCSS();
        }
        handleSettingsChange(event) {
          super.handleSettingsChange(event);
          const customEvent = event;
          const { key, value } = customEvent.detail;
          if (key === "sn-gradient-intensity") {
            const wasEnabled = this.settings.enabled;
            this.settings.intensity = value;
            this.loadSettings();
            if (value === "disabled" && wasEnabled) {
              this.settings.enabled = false;
              this.destroy();
              this.fallbackToCSSGradient();
            } else if (this.settings.enabled && !wasEnabled && this.isWebGLAvailable) {
              this.initialize();
            }
          }
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.consciousnessChoreographer) {
            try {
              this.consciousnessChoreographer.unregisterConsciousnessParticipant(
                "WebGLGradientBackgroundSystem"
              );
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "Unregistered from consciousness choreographer"
              );
            } catch (error) {
              Y3KDebug?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Error unregistering from consciousness choreographer:",
                error
              );
            }
          }
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
          if (this.textureUpdateDebounceTimer) {
            clearTimeout(this.textureUpdateDebounceTimer);
            this.textureUpdateDebounceTimer = null;
          }
          this.textureUpdatePending = false;
          this.textureCreationInProgress = false;
          this.lastColorHarmonizedData = null;
          if (this.gl) {
            if (this.gradientTexture) {
              this.gl.deleteTexture(this.gradientTexture);
              this.gradientTexture = null;
            }
            if (this.vertexBuffer) {
              this.gl.deleteBuffer(this.vertexBuffer);
              this.vertexBuffer = null;
            }
            if (this.vao) {
              this.gl.deleteVertexArray(this.vao);
              this.vao = null;
            }
            if (this.shaderProgram) {
              this.gl.deleteProgram(this.shaderProgram);
              this.shaderProgram = null;
            }
            ShaderLoader.clearCache(this.gl);
          }
          if (this.wrapper && this.wrapper.parentNode) {
            this.wrapper.parentNode.removeChild(this.wrapper);
            this.wrapper = null;
          }
          this.canvas = null;
          this.eventSubscriptionIds.forEach((subscriptionId) => {
            unifiedEventBus.unsubscribe(subscriptionId);
          });
          this.eventSubscriptionIds = [];
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Unified event subscriptions cleaned up"
          );
          window.removeEventListener("resize", this.resize);
          this.gl = null;
          const cleanupVariables = {
            "--sn.bg.webgl.ready": "0",
            "--sn.bg.webgl.enabled": "0",
            "--sn.bg.active-backend": "css",
            "--sn-gradient-crossfade-opacity": "0"
          };
          this.cssController.batchSetVariables(
            "WebGLGradientBackgroundSystem",
            cleanupVariables,
            "critical",
            // Critical priority for system cleanup
            "webgl-system-cleanup"
          );
        }
        forceRepaint(_reason = "settings-change") {
          if (this.isActive && this.gradientTexture) {
            this.updateGradientTexture().catch((error) => {
              Y3KDebug?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Failed to repaint gradient:",
                error
              );
            });
          }
        }
        // Public setters for wave parameters
        setWaveY(waveY) {
          this.settings.waveY = waveY;
        }
        setWaveHeight(waveHeight) {
          this.settings.waveHeight = waveHeight;
        }
        setWaveOffset(waveOffset) {
          this.settings.waveOffset = waveOffset;
        }
        setBlurSettings(blurExp, blurMax) {
          this.settings.blurExp = blurExp;
          this.settings.blurMax = blurMax;
        }
        getMetrics() {
          return {
            fps: this.performanceMonitor?.getMedianFPS?.() || 0,
            compileErrors: 0,
            // TODO: Track compilation errors
            isActive: this.isActive,
            settings: { ...this.settings }
          };
        }
        /**
         * Gracefully stop the animation loop.  Exposed for backplane adapters.
         */
        stopAnimation() {
          if (this.animationId !== null) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
        }
        /**
         * Animation update method called by the master animation coordinator
         * This is the missing method that was causing the white background issue
         */
        updateAnimation(timestamp, deltaTime) {
          if (!this.isActive || !this.gl || !this.isWebGLAvailable) {
            return;
          }
          if (this.shouldSkipFrame(timestamp)) {
            return;
          }
          if (this.shouldUpdateTexture()) {
            if (this.currentQualityLevel !== "low") {
              this.updateGradientTextureThrottled();
            }
          }
          if (this.webglReady) {
            this.render(timestamp);
          } else {
            this.ensureBasicResources();
          }
        }
        /**
         * Check if we should skip this frame based on quality settings
         */
        shouldSkipFrame(timestamp) {
          if (!this.frameThrottleInterval) return false;
          const timeSinceLastFrame = timestamp - (this.lastFrameTime || 0);
          const shouldSkip = timeSinceLastFrame < this.frameThrottleInterval;
          if (!shouldSkip) {
            this.lastFrameTime = timestamp;
          }
          return shouldSkip;
        }
        /**
         * Check if texture should be updated based on throttling settings
         */
        shouldUpdateTexture() {
          const currentTime = performance.now();
          return currentTime - this.lastTextureUpdate >= this.textureUpdateThrottleMs;
        }
        /**
         * Ensure basic WebGL resources exist for rendering
         */
        ensureBasicResources() {
          if (!this.gl || this.contextLost) return;
          if (!this.gradientTexture) {
            try {
              const defaultStops = this.getDefaultGradientStops();
              this.gradientTexture = createGradientTexture(this.gl, defaultStops);
              if (this.gradientTexture) {
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  "Emergency gradient texture created during animation update"
                );
              }
            } catch (error) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "Failed to create emergency gradient texture:",
                error
              );
            }
          }
        }
        /**
         * Lightweight health check used by adapters; returns OK if WebGL is ready.
         */
        async healthCheck() {
          return {
            ok: this.webglReady,
            details: this.webglReady ? "WebGL system nominal" : "WebGL not initialized"
          };
        }
        /**
         * Alternative resize helper that allows explicit dimensions while leaving
         * the original `resize` listener (no-arg) intact.
         */
        resizeTo(width, height) {
          if (!this.canvas) return;
          this.canvas.width = width;
          this.canvas.height = height;
          this.resize?.();
        }
        // ===================================================================
        // CONSCIOUSNESS CHOREOGRAPHER INTEGRATION
        // ===================================================================
        /**
         * Register this WebGL system as a consciousness participant
         */
        registerWithConsciousnessChoreographer() {
          if (!this.consciousnessChoreographer) {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Consciousness choreographer not available, skipping registration"
            );
            return;
          }
          try {
            this.consciousnessChoreographer.registerConsciousnessParticipant(this);
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Successfully registered with consciousness choreographer"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Failed to register with consciousness choreographer:",
              error
            );
          }
        }
        // ===================================================================
        // BACKGROUND SYSTEM PARTICIPANT INTERFACE IMPLEMENTATION
        // ===================================================================
        // SystemName and systemPriority already declared above
        getConsciousnessContribution() {
          return {
            webglLuminosity: this.settings.flowStrength || 0.5,
            shaderComplexity: this.isWebGLAvailable ? 0.8 : 0,
            gpuUtilization: this.isWebGLAvailable ? 0.6 : 0,
            renderingPipeline: "forward",
            textureResolution: 1
          };
        }
        onConsciousnessFieldUpdate(field) {
          if (!this.isWebGLAvailable || !this.webglReady) return;
          try {
            this.currentConsciousnessField = field;
            this.updateShaderFromConsciousness(field);
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Updated from consciousness field:",
              {
                rhythmicPulse: field.rhythmicPulse,
                webglLuminosity: field.webglLuminosity,
                emotionalTemperature: field.emotionalTemperature
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Error updating from consciousness field:",
              error
            );
          }
        }
        onChoreographyEvent(eventType, payload) {
          if (!this.isWebGLAvailable || !this.webglReady) return;
          try {
            switch (eventType) {
              case "choreography:rhythm-shift":
                this.frameThrottleInterval = 1e3 / Math.max(30, Math.min(60, payload.newRhythm?.bpm / 2 || 45));
                break;
              case "choreography:energy-surge":
                const surgeIntensity = payload.intensity || 1;
                this.cssController.setVariable(
                  "WebGLGradientBackgroundSystem",
                  "--sn-webgl-energy-surge",
                  surgeIntensity.toString(),
                  "high",
                  // High priority for energy surges
                  "choreography-energy-surge"
                );
                break;
              case "consciousness:breathing-cycle":
                const breathingPhase = payload.phase || 0;
                this.cssController.setVariable(
                  "WebGLGradientBackgroundSystem",
                  "--sn-webgl-breathing-sync",
                  breathingPhase.toString(),
                  "normal",
                  // Normal priority for breathing sync
                  "consciousness-breathing-cycle"
                );
                break;
            }
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Handled choreography event: ${eventType}`,
              payload
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              `Error handling choreography event ${eventType}:`,
              error
            );
          }
        }
        /**
         * Update WebGL shader parameters based on consciousness field
         */
        updateShaderFromConsciousness(field) {
          if (!this.gl || !this.shaderProgram) return;
          const consciousFlowStrength = this.settings.flowStrength * (0.5 + field.rhythmicPulse * 0.5);
          const flowStrengthLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_flowStrength"
          );
          if (flowStrengthLocation) {
            this.gl.uniform1f(flowStrengthLocation, consciousFlowStrength);
          }
          const consciousNoiseScale = this.settings.noiseScale * (0.8 + field.musicalFlow.x * 0.4);
          const noiseScaleLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_noiseScale"
          );
          if (noiseScaleLocation) {
            this.gl.uniform1f(noiseScaleLocation, consciousNoiseScale);
          }
          const breathingModulation = Math.sin(Date.now() * 1e-3 * field.breathingCycle) * 0.1;
          const waveYLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveY"
          );
          if (waveYLocation) {
            const modulatedWaveY = [
              this.settings.waveY[0] + breathingModulation,
              this.settings.waveY[1] - breathingModulation
            ];
            this.gl.uniform1fv(waveYLocation, modulatedWaveY);
          }
          const consciousnessWebglVariables = {
            "--sn-webgl-consciousness-flow": consciousFlowStrength.toString(),
            "--sn-webgl-consciousness-noise": consciousNoiseScale.toString(),
            "--sn-webgl-breathing-phase": breathingModulation.toString()
          };
          this.cssController.batchSetVariables(
            "WebGLGradientBackgroundSystem",
            consciousnessWebglVariables,
            "normal",
            // Normal priority for consciousness coordination
            "consciousness-shader-update"
          );
        }
        // ========================================================================
        // QUALITY SCALING INTERFACE IMPLEMENTATION
        // ========================================================================
        /**
         * Set quality level for WebGL rendering
         */
        /**
         * Adjust quality level (QualityScalingCapable interface)
         */
        adjustQuality(level) {
          this.setQualityLevel(level);
        }
        setQualityLevel(level) {
          this.currentQualityLevel = level;
          switch (level) {
            case "low":
              this.settings.flowStrength = 0.5;
              this.settings.noiseScale = 1;
              this.settings.waveHeight = [0.3, 0.2];
              this.settings.blurExp = 1;
              this.settings.blurMax = 0.4;
              this.frameThrottleInterval = 1e3 / 30;
              break;
            case "medium":
              this.settings.flowStrength = 0.7;
              this.settings.noiseScale = 1.2;
              this.settings.waveHeight = [0.4, 0.3];
              this.settings.blurExp = 1.2;
              this.settings.blurMax = 0.6;
              this.frameThrottleInterval = 1e3 / 45;
              break;
            case "high":
              this.settings.flowStrength = 0.9;
              this.settings.noiseScale = 1.4;
              this.settings.waveHeight = [0.5, 0.4];
              this.settings.blurExp = 1.3;
              this.settings.blurMax = 0.7;
              this.frameThrottleInterval = 1e3 / 60;
              break;
            default:
              this.settings.flowStrength = 0.7;
              this.settings.noiseScale = 1.2;
              this.settings.waveHeight = [0.4, 0.3];
              this.settings.blurExp = 1.2;
              this.settings.blurMax = 0.6;
              this.frameThrottleInterval = 1e3 / 45;
              break;
          }
          this.updateQualityCapabilities(level);
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Quality level set to: ${level}`,
            {
              flowStrength: this.settings.flowStrength,
              frameRate: 1e3 / this.frameThrottleInterval
            }
          );
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const currentFPS = this.lastFrameTime > 0 ? 1e3 / this.lastFrameTime : 60;
          const memoryUsage = this.estimateMemoryUsage();
          return {
            fps: currentFPS,
            frameTime: this.lastFrameTime,
            memoryUsage,
            cpuUsage: this.estimateCPUUsage()
          };
        }
        /**
         * Reduce quality by specified amount
         */
        reduceQuality(amount) {
          this.qualityAdjustments["flow-reduction"] = (this.qualityAdjustments["flow-reduction"] || 0) + amount;
          this.qualityAdjustments["noise-reduction"] = (this.qualityAdjustments["noise-reduction"] || 0) + amount * 0.8;
          this.qualityAdjustments["wave-reduction"] = (this.qualityAdjustments["wave-reduction"] || 0) + amount * 0.6;
          this.settings.flowStrength = Math.max(
            0.1,
            this.settings.flowStrength * (1 - amount)
          );
          this.settings.noiseScale = Math.max(
            0.5,
            this.settings.noiseScale * (1 - amount * 0.8)
          );
          this.settings.waveHeight = [
            Math.max(0.1, this.settings.waveHeight[0] * (1 - amount * 0.6)),
            Math.max(0.1, this.settings.waveHeight[1] * (1 - amount * 0.6))
          ];
          if (amount > 0.5) {
            this.frameThrottleInterval = Math.min(
              1e3 / 15,
              this.frameThrottleInterval * (1 + amount)
            );
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Quality reduced by ${amount}`,
            this.settings
          );
        }
        /**
         * Increase quality by specified amount
         */
        increaseQuality(amount) {
          Object.keys(this.qualityAdjustments).forEach((key) => {
            this.qualityAdjustments[key] = Math.max(
              0,
              (this.qualityAdjustments[key] || 0) - amount
            );
          });
          if (this.currentQualityLevel) {
            const baseSettings = this.getBaseSettingsForLevel(this.currentQualityLevel) || this.settings;
            this.settings.flowStrength = Math.min(
              baseSettings.flowStrength,
              this.settings.flowStrength * (1 + amount * 0.5)
            );
            this.settings.noiseScale = Math.min(
              baseSettings.noiseScale,
              this.settings.noiseScale * (1 + amount * 0.3)
            );
            const targetFPS = this.currentQualityLevel === "high" ? 60 : this.currentQualityLevel === "medium" ? 45 : 30;
            this.frameThrottleInterval = Math.max(
              1e3 / targetFPS,
              this.frameThrottleInterval * (1 - amount * 0.3)
            );
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Quality increased by ${amount}`,
            this.settings
          );
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          return [...this.qualityCapabilities];
        }
        // ========================================================================
        // QUALITY SCALING HELPER METHODS
        // ========================================================================
        updateQualityCapabilities(level) {
          this.qualityCapabilities.forEach((capability) => {
            switch (capability.name) {
              case "webgl-rendering":
                capability.enabled = true;
                break;
              case "shader-complexity":
                capability.enabled = level === "high" || level === "medium";
                break;
              case "blur-effects":
                capability.enabled = level !== "low";
                break;
              case "corridor-effects":
                capability.enabled = level !== "low";
                if (level === "low" && this.settings.corridorEnabled) {
                  this.settings.corridorEnabled = false;
                }
                break;
              case "corridor-sdf-complexity":
                const sdfAdjustment = level === "high" ? 1 : level === "medium" ? 0.8 : 0.6;
                this.settings.corridorBubbleScale = Math.max(0.5, 1 * sdfAdjustment);
                capability.enabled = level !== "low";
                break;
              case "corridor-bubble-layers":
                const layerAdjustment = level === "high" ? 1 : level === "medium" ? 0.8 : 0.6;
                this.settings.corridorIntensity = Math.max(0.3, 0.8 * layerAdjustment);
                capability.enabled = level === "high" || level === "medium";
                break;
              case "corridor-depth-effects":
                const depthAdjustment = level === "high" ? 1 : level === "medium" ? 0.7 : 0.4;
                this.settings.corridorDepthEffect = Math.max(0.1, 0.6 * depthAdjustment);
                capability.enabled = level !== "low";
                break;
              default:
                capability.enabled = level !== "low";
            }
          });
        }
        getBaseSettingsForLevel(level) {
          const baseSettings = { ...this.settings };
          switch (level) {
            case "minimal":
              return {
                ...baseSettings,
                flowStrength: 0.3,
                noiseScale: 0.8,
                corridorEnabled: false,
                corridorIntensity: 0.3,
                corridorFlowStrength: 0.5,
                corridorDepthEffect: 0.2,
                corridorBubbleScale: 0.5
              };
            case "low":
              return {
                ...baseSettings,
                flowStrength: 0.5,
                noiseScale: 1,
                corridorEnabled: false,
                corridorIntensity: 0.4,
                corridorFlowStrength: 0.8,
                corridorDepthEffect: 0.3,
                corridorBubbleScale: 0.6
              };
            case "medium":
              return {
                ...baseSettings,
                flowStrength: 0.7,
                noiseScale: 1.2,
                corridorEnabled: true,
                corridorIntensity: 0.6,
                corridorFlowStrength: 1,
                corridorDepthEffect: 0.5,
                corridorBubbleScale: 0.8
              };
            case "high":
              return {
                ...baseSettings,
                flowStrength: 0.9,
                noiseScale: 1.4,
                corridorEnabled: true,
                corridorIntensity: 0.8,
                corridorFlowStrength: 1.2,
                corridorDepthEffect: 0.6,
                corridorBubbleScale: 1
              };
            case "ultra":
              return {
                ...baseSettings,
                flowStrength: 1,
                noiseScale: 1.6,
                corridorEnabled: true,
                corridorIntensity: 1,
                corridorFlowStrength: 1.4,
                corridorDepthEffect: 0.8,
                corridorBubbleScale: 1.2
              };
            default:
              return baseSettings;
          }
        }
        // ========================================================================
        // PUBLIC CORRIDOR CONTROL METHODS
        // ========================================================================
        /**
         * Enable or disable corridor bubble effects
         * @param enabled Whether to enable corridor effects
         */
        setCorridorEffectsEnabled(enabled) {
          this.settings.corridorEnabled = enabled && this.corridorShaderProgram !== null;
          this.cssController.setVariable(
            "WebGLGradientBackgroundSystem",
            "--sn-corridor-enabled",
            enabled ? "1" : "0",
            "normal",
            // Normal priority for corridor settings
            "corridor-settings-update"
          );
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Corridor effects ${enabled ? "enabled" : "disabled"}`
          );
        }
        /**
         * Update corridor settings for runtime adjustment
         * @param settings Partial corridor settings to update
         */
        updateCorridorSettings(settings2) {
          if (settings2.corridorIntensity !== void 0) {
            this.settings.corridorIntensity = Math.max(0, Math.min(1, settings2.corridorIntensity));
          }
          if (settings2.corridorFlowStrength !== void 0) {
            this.settings.corridorFlowStrength = Math.max(0, Math.min(2, settings2.corridorFlowStrength));
          }
          if (settings2.corridorDepthEffect !== void 0) {
            this.settings.corridorDepthEffect = Math.max(0, Math.min(1, settings2.corridorDepthEffect));
          }
          if (settings2.corridorBubbleScale !== void 0) {
            this.settings.corridorBubbleScale = Math.max(0.1, Math.min(2, settings2.corridorBubbleScale));
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Corridor settings updated",
            settings2
          );
        }
        estimateMemoryUsage() {
          let usage = 5;
          if (this.canvas && this.gl) {
            const pixels = this.canvas.width * this.canvas.height;
            usage += pixels * 4 / (1024 * 1024);
            if (this.gradientTexture) usage += 1;
            if (this.vertexBuffer) usage += 0.1;
          }
          return usage;
        }
        estimateCPUUsage() {
          const baseUsage = this.isWebGLAvailable ? 5 : 15;
          const qualityMultiplier = this.settings.flowStrength + this.settings.noiseScale / 2;
          return Math.min(50, baseUsage * qualityMultiplier);
        }
        /**
         * Get simplified fragment shader without complex noise functions
         * Falls back to simpler gradient calculations for better compatibility
         */
        getSimplifiedFragmentShader() {
          return `#version 300 es
      precision highp float;

      in vec2 vTextureCoords;
      out vec4 fragColor;

      uniform sampler2D u_gradientTexture;
      uniform float u_time;
      uniform float u_intensity;
      uniform float u_flowStrength;
      uniform vec2 u_resolution;

      // Simplified noise function - uses basic sin/cos instead of complex noise
      float simpleNoise(vec2 st) {
        return sin(st.x * 12.9898 + st.y * 78.233) * 43758.5453;
      }

      void main() {
        vec2 uv = vTextureCoords;
        
        // Simple flow effect without complex noise
        vec2 flow = vec2(
          sin(u_time * 0.5 + uv.y * 3.0) * 0.1,
          cos(u_time * 0.3 + uv.x * 2.0) * 0.1
        ) * u_flowStrength;
        
        // Apply flow offset
        vec2 flowUV = uv + flow;
        
        // Simple gradient lookup with basic distortion
        vec4 gradientColor = texture(u_gradientTexture, flowUV);
        
        // Simple intensity modulation
        float intensity = u_intensity * (0.8 + 0.2 * sin(u_time + uv.x + uv.y));
        
        fragColor = vec4(gradientColor.rgb * intensity, gradientColor.a);
      }`;
        }
        /**
         * Get basic fragment shader with minimal features
         * Fallback for very limited GPU capabilities
         */
        getBasicFragmentShader() {
          return `#version 300 es
      precision mediump float;

      in vec2 vTextureCoords;
      out vec4 fragColor;

      uniform sampler2D u_gradientTexture;
      uniform float u_intensity;

      void main() {
        vec2 uv = vTextureCoords;
        
        // Basic gradient lookup without any effects
        vec4 gradientColor = texture(u_gradientTexture, uv);
        
        // Simple intensity scaling
        fragColor = vec4(gradientColor.rgb * u_intensity, gradientColor.a);
      }`;
        }
        /**
         * Get emergency fragment shader - absolute minimum for hardware compatibility
         * Ultra-basic solid color with minimal gradient interpolation
         */
        getEmergencyFragmentShader() {
          return `#version 300 es
      precision lowp float;

      in vec2 vTextureCoords;
      out vec4 fragColor;

      uniform sampler2D u_gradientTexture;

      void main() {
        // Ultra-simple gradient lookup with minimal processing
        // Use lowp precision for maximum compatibility
        vec2 uv = vTextureCoords;
        
        // Simple gradient sample - no effects, no animations
        vec4 color = texture(u_gradientTexture, uv);
        
        // Emergency mode: ensure we always output something visible
        // Fallback to magenta if texture fails (indicates shader compilation success)
        if (color.a < 0.01) {
          fragColor = vec4(0.2, 0.1, 0.3, 1.0); // Dark purple fallback
        } else {
          fragColor = color;
        }
      }`;
        }
        /**
         * Check if WebGL should persist based on settings and never fallback to CSS
         */
        shouldPersistWebGL() {
          if (this.settings.webglPersistenceMode === "persistent") {
            return true;
          }
          if (this.settings.webglPersistenceMode === "fallback") {
            return false;
          }
          return this.settings.webglPersistenceMode === "adaptive" && this.settings.enabled && this.isWebGLAvailable;
        }
        /**
         * Determine if we should attempt WebGL recovery vs CSS fallback
         */
        shouldAttemptWebGLRecovery() {
          return this.shouldPersistWebGL();
        }
        // ============================================================================
        // CONTINUOUS QUALITY SCALING IMPLEMENTATION
        // ============================================================================
        /**
         * Apply continuous quality level (0-100) to WebGL system
         * Implements ContinuousQualityScalingCapable interface
         */
        applyContinuousQuality(qualityLevel) {
          try {
            const level = qualityLevel;
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Applying simplified quality level: ${level}`
            );
            this.setQualityLevel(level);
            this.cssController.batchSetVariables(
              "WebGLGradientBackgroundSystem",
              {
                "--sn-webgl-quality-level": level,
                "--sn-webgl-corridor-enabled": this.settings.corridorEnabled ? "1" : "0"
              },
              "high",
              "continuous-quality-update"
            );
            if (this.initialized && this.gl) {
              this.forceRepaint("quality-level-changed");
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Failed to apply continuous quality:",
              error
            );
          }
        }
        /**
         * Get current performance impact of the WebGL system
         * Implements ContinuousQualityScalingCapable interface
         */
        getCurrentQualityImpact() {
          const isWebGLActive = this.gl !== null && this.isWebGLAvailable;
          const hasCorridorEffects = this.settings.corridorEnabled && this.corridorShaderProgram !== null;
          const baseCPU = isWebGLActive ? 0.15 : 0.05;
          const baseMemory = isWebGLActive ? 0.1 : 0.03;
          const baseGPU = isWebGLActive ? 0.2 : 0;
          const corridorCPU = hasCorridorEffects ? 0.1 : 0;
          const corridorMemory = hasCorridorEffects ? 0.05 : 0;
          const corridorGPU = hasCorridorEffects ? 0.15 : 0;
          const animationMultiplier = Math.max(0.5, this.settings.flowStrength / 2);
          let estimatedFPS = 60;
          if (hasCorridorEffects) estimatedFPS -= 10;
          if (this.settings.intensity === "intense") estimatedFPS -= 5;
          estimatedFPS = Math.max(30, estimatedFPS);
          return {
            cpu: Math.min(1, (baseCPU + corridorCPU) * animationMultiplier),
            memory: Math.min(1, (baseMemory + corridorMemory) * animationMultiplier),
            gpu: Math.min(1, (baseGPU + corridorGPU) * animationMultiplier),
            estimatedFPS
          };
        }
      };
      __name(_WebGLGradientBackgroundSystem, "WebGLGradientBackgroundSystem");
      WebGLGradientBackgroundSystem = _WebGLGradientBackgroundSystem;
    }
  });

  // src-js/visual/css-fallbacks/CSSBlobFallbackSystem.ts
  var _CSSBlobFallbackSystem, CSSBlobFallbackSystem;
  var init_CSSBlobFallbackSystem = __esm({
    "src-js/visual/css-fallbacks/CSSBlobFallbackSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_UnifiedDebugManager();
      init_BaseVisualSystem();
      _CSSBlobFallbackSystem = class _CSSBlobFallbackSystem extends BaseVisualSystem {
        constructor(config = YEAR3000_CONFIG, utils, performanceMonitor, musicSyncService = null, settingsManager2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this.systemName = "CSSBlobFallbackSystem";
          this.blobContainer = null;
          this.blobElements = [];
          this.isActive = false;
          this.settings = {
            enabled: true,
            blobCount: 6,
            musicResponsive: true,
            performanceMode: false,
            debugMode: false,
            // Enhanced organic pattern defaults
            organicFlow: true,
            membraneElasticity: 0.7,
            musicSync: true,
            emotionalTemperature: 0.5,
            cellularGrowth: true,
            organicBreathing: true,
            fluidDynamics: true
          };
          this.handleBeatEvent = /* @__PURE__ */ __name((event) => {
            if (!this.isActive || !this.settings.musicResponsive) return;
            const customEvent = event;
            const { intensity = 0.5 } = customEvent.detail || {};
            this.blobElements.forEach((blob) => {
              blob.classList.add("sn-beat-active");
            });
            setTimeout(() => {
              this.blobElements.forEach((blob) => {
                blob.classList.remove("sn-beat-active");
              });
            }, 500);
            const beatScale = 1 + intensity * 0.15;
            document.documentElement.style.setProperty("--css-blob-beat-scale", beatScale.toString());
          }, "handleBeatEvent");
          this.handleEnergyChange = /* @__PURE__ */ __name((event) => {
            if (!this.isActive || !this.settings.musicResponsive) return;
            const customEvent = event;
            const { energy = 0.5 } = customEvent.detail || {};
            document.documentElement.style.setProperty("--css-blob-music-response", energy.toString());
            document.documentElement.style.setProperty("--css-blob-energy-opacity", (0.4 + energy * 0.4).toString());
            const speedMultiplier = 0.8 + energy * 0.4;
            const movementSpeed = Math.round(8e3 / speedMultiplier);
            const breathingSpeed = Math.round(4e3 / speedMultiplier);
            document.documentElement.style.setProperty("--css-blob-movement-speed", `${movementSpeed}ms`);
            document.documentElement.style.setProperty("--css-blob-breathing-speed", `${breathingSpeed}ms`);
          }, "handleEnergyChange");
          this.handleGenreChange = /* @__PURE__ */ __name((event) => {
            if (!this.isActive || !this.settings.musicResponsive) return;
            const customEvent = event;
            const { genre = "unknown" } = customEvent.detail || {};
            this.blobElements.forEach((blob, index) => {
              blob.classList.remove("genre-electronic", "genre-ambient", "genre-classical");
              let genreClass = "genre-electronic";
              if (genre.includes("ambient") || genre.includes("chill")) {
                genreClass = "genre-ambient";
              } else if (genre.includes("classical") || genre.includes("orchestral")) {
                genreClass = "genre-classical";
              } else if (genre.includes("electronic") || genre.includes("techno") || genre.includes("house")) {
                genreClass = "genre-electronic";
              }
              const genreVariations = ["genre-electronic", "genre-ambient", "genre-classical"];
              const variantIndex = (index + genreVariations.indexOf(genreClass)) % genreVariations.length;
              const selectedGenre = genreVariations[variantIndex];
              if (selectedGenre) {
                blob.classList.add(selectedGenre);
              }
            });
            Y3KDebug?.debug?.log(
              "CSSBlobFallbackSystem",
              `Updated blob genres for: ${genre}`
            );
          }, "handleGenreChange");
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          this.loadSettings();
          const webglAvailable = this.checkWebGLAvailability();
          if (webglAvailable && !this.settings.debugMode) {
            Y3KDebug?.debug?.log(
              "CSSBlobFallbackSystem",
              "WebGL available - CSS blob fallback not needed"
            );
            return;
          }
          if (!this.settings.enabled) {
            Y3KDebug?.debug?.log(
              "CSSBlobFallbackSystem",
              "CSS blob fallback disabled in settings"
            );
            return;
          }
          const shouldReduceQuality = this.performanceMonitor?.shouldReduceQuality?.() || false;
          if (shouldReduceQuality) {
            this.settings.performanceMode = true;
            this.settings.blobCount = Math.min(this.settings.blobCount, 3);
          }
          try {
            this.createBlobContainer();
            this.createBlobElements();
            if (this.settings.musicResponsive) {
              this.subscribeToEvents();
            }
            this.updateCSSVariables();
            this.isActive = true;
            Y3KDebug?.debug?.log(
              "CSSBlobFallbackSystem",
              `CSS blob fallback activated with ${this.settings.blobCount} blobs`,
              {
                performanceMode: this.settings.performanceMode,
                musicResponsive: this.settings.musicResponsive
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "CSSBlobFallbackSystem",
              "Failed to initialize:",
              error
            );
          }
        }
        loadSettings() {
          if (!this.settingsManager) return;
          try {
            const gradientIntensity = this.settingsManager?.get("sn-gradient-intensity");
            const performanceMode = this.settingsManager?.get("sn-performance-mode");
            switch (gradientIntensity) {
              case "disabled":
                this.settings.enabled = false;
                break;
              case "minimal":
                this.settings.blobCount = 3;
                this.settings.musicResponsive = false;
                break;
              case "balanced":
                this.settings.blobCount = 6;
                this.settings.musicResponsive = true;
                break;
              case "intense":
                this.settings.blobCount = 8;
                this.settings.musicResponsive = true;
                break;
            }
            if (performanceMode === "enabled") {
              this.settings.performanceMode = true;
              this.settings.blobCount = Math.min(this.settings.blobCount, 4);
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "CSSBlobFallbackSystem",
              "Failed to load settings:",
              error
            );
          }
        }
        checkWebGLAvailability() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            return !!gl;
          } catch (error) {
            return false;
          }
        }
        createBlobContainer() {
          const targetContainer = this.findTargetContainer();
          this.blobContainer = document.createElement("div");
          this.blobContainer.className = "sn-css-blob-container";
          if (this.settings.debugMode) {
            this.blobContainer.classList.add("css-blob-debug");
          }
          if (this.settings.performanceMode) {
            this.blobContainer.classList.add("css-blob-performance");
          }
          targetContainer.appendChild(this.blobContainer);
          Y3KDebug?.debug?.log(
            "CSSBlobFallbackSystem",
            "Blob container created and inserted"
          );
        }
        createBlobElements() {
          if (!this.blobContainer) return;
          this.blobElements.forEach((blob) => blob.remove());
          this.blobElements = [];
          for (let i = 0; i < this.settings.blobCount; i++) {
            const blob = document.createElement("div");
            blob.className = "sn-css-blob";
            blob.setAttribute("data-blob-index", i.toString());
            const genreClasses = ["genre-electronic", "genre-ambient", "genre-classical"];
            const genreClass = genreClasses[i % genreClasses.length];
            if (genreClass) {
              blob.classList.add(genreClass);
            }
            this.blobContainer.appendChild(blob);
            this.blobElements.push(blob);
          }
          Y3KDebug?.debug?.log(
            "CSSBlobFallbackSystem",
            `Created ${this.settings.blobCount} blob elements`
          );
        }
        findTargetContainer() {
          const containers = [
            ".Root__main-view",
            ".main-view-container",
            ".Root__top-container",
            "body"
          ];
          for (const selector of containers) {
            const element = document.querySelector(selector);
            if (element) {
              return element;
            }
          }
          return document.body;
        }
        updateCSSVariables() {
          document.documentElement.style.setProperty("--css-blob-enabled", "1");
          document.documentElement.style.setProperty("--css-blob-count", this.settings.blobCount.toString());
          if (this.settings.performanceMode) {
            document.documentElement.style.setProperty("--css-blob-quality", "0");
            document.documentElement.style.setProperty("--css-blob-filter-quality", "0");
          }
          document.documentElement.style.setProperty("--sn-consciousness-organic-mode", this.settings.organicFlow ? "1" : "0");
          document.documentElement.style.setProperty("--sn-consciousness-membrane-elasticity", this.settings.membraneElasticity.toString());
          document.documentElement.style.setProperty("--sn-consciousness-musical-emotion", this.settings.emotionalTemperature.toString());
          document.documentElement.style.setProperty("--sn-consciousness-cellular-growth", this.settings.cellularGrowth ? "1" : "0");
          document.documentElement.style.setProperty("--sn-consciousness-breathing-intensity", this.settings.organicBreathing ? "1" : "0");
          document.documentElement.style.setProperty("--sn-consciousness-viscosity", this.settings.fluidDynamics ? "0.4" : "0");
          document.documentElement.style.setProperty("--sn-consciousness-css-fallback", "1.0");
          document.documentElement.style.setProperty("--sn-consciousness-webgl-coordination", "0");
        }
        subscribeToEvents() {
          if (!this.settings.musicResponsive) return;
          document.addEventListener("music-sync:beat-detected", this.handleBeatEvent);
          document.addEventListener("music-sync:energy-changed", this.handleEnergyChange);
          document.addEventListener("music-sync:genre-changed", this.handleGenreChange);
          document.addEventListener("year3000SystemSettingsChanged", this.handleSettingsChange.bind(this));
          Y3KDebug?.debug?.log(
            "CSSBlobFallbackSystem",
            "Subscribed to music and settings events"
          );
        }
        handleSettingsChange(event) {
          const customEvent = event;
          const { key } = customEvent.detail || {};
          if (key.startsWith("sn-gradient-") || key.startsWith("sn-performance-")) {
            this.loadSettings();
            if (this.isActive && this.blobContainer) {
              this.createBlobElements();
              this.updateCSSVariables();
            }
          }
        }
        updateAnimation(deltaTime) {
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.settings.musicResponsive) {
            document.removeEventListener("music-sync:beat-detected", this.handleBeatEvent);
            document.removeEventListener("music-sync:energy-changed", this.handleEnergyChange);
            document.removeEventListener("music-sync:genre-changed", this.handleGenreChange);
            document.removeEventListener("year3000SystemSettingsChanged", this.handleSettingsChange.bind(this));
          }
          this.blobElements.forEach((blob) => blob.remove());
          this.blobElements = [];
          if (this.blobContainer && this.blobContainer.parentNode) {
            this.blobContainer.parentNode.removeChild(this.blobContainer);
          }
          this.blobContainer = null;
          document.documentElement.style.removeProperty("--css-blob-enabled");
          document.documentElement.style.removeProperty("--css-blob-count");
          document.documentElement.style.removeProperty("--css-blob-quality");
          this.isActive = false;
          Y3KDebug?.debug?.log(
            "CSSBlobFallbackSystem",
            "CSS blob fallback system cleanup completed"
          );
        }
        // Public API methods
        /**
         * Enable or disable the CSS blob system
         */
        setEnabled(enabled) {
          this.settings.enabled = enabled;
          if (this.blobContainer) {
            this.blobContainer.style.display = enabled ? "" : "none";
          }
          document.documentElement.style.setProperty("--css-blob-enabled", enabled ? "1" : "0");
        }
        /**
         * Set performance mode
         */
        setPerformanceMode(enabled) {
          this.settings.performanceMode = enabled;
          if (this.blobContainer) {
            this.blobContainer.classList.toggle("css-blob-performance", enabled);
          }
          document.documentElement.style.setProperty("--css-blob-quality", enabled ? "0" : "1");
          document.documentElement.style.setProperty("--css-blob-filter-quality", enabled ? "0" : "1");
        }
        /**
         * Enhanced organic pattern control methods - using existing consciousness variables
         */
        setOrganicFlow(enabled) {
          this.settings.organicFlow = enabled;
          document.documentElement.style.setProperty("--sn-consciousness-organic-mode", enabled ? "1" : "0");
        }
        setMembraneElasticity(elasticity) {
          this.settings.membraneElasticity = Math.max(0, Math.min(1, elasticity));
          document.documentElement.style.setProperty("--sn-consciousness-membrane-elasticity", this.settings.membraneElasticity.toString());
        }
        setConsciousnessSync(enabled) {
          this.settings.musicSync = enabled;
        }
        setEmotionalTemperature(temperature) {
          this.settings.emotionalTemperature = Math.max(0, Math.min(1, temperature));
          document.documentElement.style.setProperty("--sn-consciousness-musical-emotion", this.settings.emotionalTemperature.toString());
        }
        setCellularGrowth(enabled) {
          this.settings.cellularGrowth = enabled;
          document.documentElement.style.setProperty("--sn-consciousness-cellular-growth", enabled ? "1" : "0");
        }
        setOrganicBreathing(enabled) {
          this.settings.organicBreathing = enabled;
          document.documentElement.style.setProperty("--sn-consciousness-breathing-intensity", enabled ? "1" : "0");
        }
        setFluidDynamics(enabled) {
          this.settings.fluidDynamics = enabled;
          document.documentElement.style.setProperty("--sn-consciousness-viscosity", enabled ? "0.4" : "0");
        }
        /**
         * Get current system status
         */
        getStatus() {
          return {
            isActive: this.isActive,
            settings: { ...this.settings },
            blobCount: this.blobElements.length,
            hasContainer: !!this.blobContainer
          };
        }
      };
      __name(_CSSBlobFallbackSystem, "CSSBlobFallbackSystem");
      CSSBlobFallbackSystem = _CSSBlobFallbackSystem;
    }
  });

  // src-js/visual/effects/UIVisualEffectsController.ts
  var _ConsciousnessUIEffectsController, ConsciousnessUIEffectsController;
  var init_UIVisualEffectsController = __esm({
    "src-js/visual/effects/UIVisualEffectsController.ts"() {
      "use strict";
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_BaseVisualSystem();
      _ConsciousnessUIEffectsController = class _ConsciousnessUIEffectsController extends BaseVisualSystem {
        constructor(config, utils, performanceAnalyzer2, musicSyncService, settingsManager2) {
          super(
            config,
            utils,
            performanceAnalyzer2,
            musicSyncService,
            settingsManager2
          );
          // BackgroundSystemParticipant implementation
          this.systemName = "ConsciousnessUIEffectsController";
          // Initialized in initializeCSSConsciousness
          this.consciousnessChoreographer = null;
          this.currentConsciousnessField = null;
          // Element management
          this.shimmerElements = /* @__PURE__ */ new Map();
          this.mutationObserver = null;
          this.intersectionObserver = null;
          // Animation and timing
          this.animationFrameId = null;
          this.lastFrameTime = 0;
          this.frameTimeHistory = [];
          // Event subscriptions
          this.eventUnsubscribeFunctions = [];
          // Performance monitoring (override base performance monitor with custom metrics)
          this.customPerformanceMonitor = {
            frameCount: 0,
            totalFrameTime: 0,
            lastPerformanceCheck: 0,
            adaptiveQualityLevel: 1
          };
          // Diagnostic state
          this.diagnosticTimerId = null;
          this.lastDiagnosticRun = 0;
          this.uiEffectsConfig = {
            enabled: true,
            consciousnessThreshold: 0.3,
            // Shimmer defaults (from IridescentShimmerEffectsSystem)
            shimmerEnabled: true,
            shimmerIntensity: 0.6,
            shimmerType: "mixed",
            shimmerPerformanceLevel: "balanced",
            // Interaction defaults (from InteractionTrackingSystem)
            interactionTrackingEnabled: true,
            digitalMeditationThreshold: 3e4,
            // 30 seconds
            scrollVelocityTracking: true,
            // Diagnostic defaults (from WhiteLayerDiagnosticSystem)
            diagnosticEnabled: true,
            autoFixWhiteLayer: true,
            diagnosticInterval: 5e3,
            // 5 seconds
            // Audio-visual defaults (from AudioVisualController) - connected to user settings
            audioVisualEnabled: true,
            beatSynchronization: true,
            nebulaEffectIntensity: this.getNebulaIntensityFromSettings(),
            // Scroll effects defaults (from PrismaticScrollSheenSystem)
            scrollEffectsEnabled: true,
            prismaticSheenIntensity: 0.5,
            // Performance defaults
            maxFrameTime: 1,
            // <1ms budget
            adaptiveQuality: true,
            debugMode: config.enableDebug || false
          };
          this.consciousnessState = this.createInitialConsciousnessState();
          Y3KDebug?.debug?.log(
            "ConsciousnessUIEffectsController",
            "Unified UI effects consciousness controller created"
          );
        }
        get systemPriority() {
          return "normal";
        }
        /**
         * Get nebula effect intensity from user settings with layered enhancement
         */
        getNebulaIntensityFromSettings() {
          if (!this.settingsManager) {
            return 0.7;
          }
          const setting = this.settingsManager.get("sn-gradient-intensity");
          switch (setting) {
            case "disabled":
              return 0;
            case "minimal":
              return 0.3;
            case "balanced":
              return 0.7;
            case "intense":
              return 1;
            default:
              return 0.7;
          }
        }
        createInitialConsciousnessState() {
          return {
            consciousnessLevel: "dormant",
            shimmer: {
              intensity: 0,
              effectType: "mixed",
              activeElements: /* @__PURE__ */ new Set(),
              performanceLevel: this.uiEffectsConfig.shimmerPerformanceLevel
            },
            interaction: {
              isActive: false,
              lastInteractionTime: 0,
              digitalMeditationDetected: false,
              scrollVelocity: { x: 0, y: 0, direction: "none" },
              nexusState: "idle"
            },
            diagnostic: {
              whiteLayerIssues: [],
              webglContextHealthy: true,
              lastDiagnosticTime: 0,
              autoFixEnabled: this.uiEffectsConfig.autoFixWhiteLayer,
              criticalIssuesDetected: 0
            },
            audioVisual: {
              beatIntensity: 0,
              genreChangeDetected: false,
              nebulaEffectIntensity: 0,
              lastBeatTime: 0,
              performanceAdaptive: this.uiEffectsConfig.adaptiveQuality
            },
            scroll: {
              sheenIntensity: 0,
              scrollRatio: 0,
              prismaticEffectActive: false,
              lastScrollTime: 0
            },
            performance: {
              frameTime: 0,
              avgFrameTime: 0,
              maxFrameTime: 0,
              healthStatus: "excellent",
              adaptiveQualityEnabled: this.uiEffectsConfig.adaptiveQuality
            }
          };
        }
        // BaseVisualSystem implementation
        async initialize() {
          try {
            Y3KDebug?.debug?.log(
              "ConsciousnessUIEffectsController",
              "Starting unified UI effects initialization..."
            );
            await this.initializeCSSConsciousness();
            await this.initializeConsciousnessIntegration();
            this.subscribeToUnifiedEvents();
            if (this.uiEffectsConfig.shimmerEnabled) {
              await this.initializeShimmerEffects();
            }
            if (this.uiEffectsConfig.interactionTrackingEnabled) {
              await this.initializeInteractionTracking();
            }
            if (this.uiEffectsConfig.diagnosticEnabled) {
              await this.initializeDiagnosticSystem();
            }
            if (this.uiEffectsConfig.audioVisualEnabled) {
              await this.initializeAudioVisualEffects();
            }
            if (this.uiEffectsConfig.scrollEffectsEnabled) {
              await this.initializeScrollEffects();
            }
            this.startUnifiedAnimationLoop();
            this.initialized = true;
            Y3KDebug?.debug?.log(
              "ConsciousnessUIEffectsController",
              "Unified UI effects consciousness initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Failed to initialize:",
              error
            );
            throw error;
          }
        }
        async initializeCSSConsciousness() {
          try {
            this.cssController = globalThis.unifiedCSSConsciousnessController || null;
            this.cssController = getGlobalOptimizedCSSController();
            if (!this.cssController) {
              Y3KDebug?.debug?.warn(
                "ConsciousnessUIEffectsController",
                "CSS consciousness not available, using coordinator fallback"
              );
            } else {
              Y3KDebug?.debug?.log(
                "ConsciousnessUIEffectsController",
                "Connected to unified CSS consciousness"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "ConsciousnessUIEffectsController",
              "CSS consciousness initialization failed:",
              error
            );
          }
        }
        async initializeConsciousnessIntegration() {
          try {
            this.consciousnessChoreographer = globalThis.backgroundConsciousnessChoreographer || null;
            if (this.consciousnessChoreographer) {
              this.consciousnessChoreographer.registerConsciousnessParticipant(this);
              Y3KDebug?.debug?.log(
                "ConsciousnessUIEffectsController",
                "Registered with consciousness choreographer"
              );
            } else {
              Y3KDebug?.debug?.log(
                "ConsciousnessUIEffectsController",
                "Operating without consciousness choreographer integration"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "ConsciousnessUIEffectsController",
              "Consciousness integration failed:",
              error
            );
          }
        }
        subscribeToUnifiedEvents() {
          const musicBeatUnsubscribe = unifiedEventBus.subscribe(
            "music:beat",
            this.handleMusicBeat.bind(this),
            "ConsciousnessUIEffectsController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(musicBeatUnsubscribe)
          );
          const musicEnergyUnsubscribe = unifiedEventBus.subscribe(
            "music:energy",
            this.handleMusicEnergy.bind(this),
            "ConsciousnessUIEffectsController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(musicEnergyUnsubscribe)
          );
          const settingsUnsubscribe = unifiedEventBus.subscribe(
            "settings:changed",
            this.handleSettingsChange.bind(this),
            "ConsciousnessUIEffectsController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(settingsUnsubscribe)
          );
          Y3KDebug?.debug?.log(
            "ConsciousnessUIEffectsController",
            `Subscribed to ${this.eventUnsubscribeFunctions.length} unified events`
          );
        }
        async initializeShimmerEffects() {
          try {
            this.setupElementObservers();
            await this.discoverShimmerElements();
            Y3KDebug?.debug?.log(
              "ConsciousnessUIEffectsController",
              `Shimmer effects initialized with ${this.shimmerElements.size} elements`
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Shimmer effects initialization failed:",
              error
            );
          }
        }
        async initializeInteractionTracking() {
          try {
            this.setupInteractionListeners();
            Y3KDebug?.debug?.log(
              "ConsciousnessUIEffectsController",
              "Interaction tracking initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Interaction tracking initialization failed:",
              error
            );
          }
        }
        async initializeDiagnosticSystem() {
          try {
            this.startDiagnosticMonitoring();
            Y3KDebug?.debug?.log(
              "ConsciousnessUIEffectsController",
              "Diagnostic system initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Diagnostic system initialization failed:",
              error
            );
          }
        }
        async initializeAudioVisualEffects() {
          try {
            Y3KDebug?.debug?.log(
              "ConsciousnessUIEffectsController",
              "Audio-visual effects initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Audio-visual effects initialization failed:",
              error
            );
          }
        }
        async initializeScrollEffects() {
          try {
            Y3KDebug?.debug?.log(
              "ConsciousnessUIEffectsController",
              "Scroll effects initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Scroll effects initialization failed:",
              error
            );
          }
        }
        setupElementObservers() {
          if (typeof MutationObserver !== "undefined") {
            this.mutationObserver = new MutationObserver((mutations) => {
              let hasNewElements = false;
              mutations.forEach((mutation) => {
                if (mutation.type === "childList") {
                  mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                      hasNewElements = true;
                    }
                  });
                }
              });
              if (hasNewElements) {
                this.discoverShimmerElements();
              }
            });
            this.mutationObserver.observe(document.body, {
              childList: true,
              subtree: true
            });
          }
          if (typeof IntersectionObserver !== "undefined") {
            this.intersectionObserver = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  const elementId = entry.target.getAttribute("data-shimmer-id");
                  if (elementId) {
                    if (entry.isIntersecting) {
                      this.consciousnessState.shimmer.activeElements.add(elementId);
                    } else {
                      this.consciousnessState.shimmer.activeElements.delete(
                        elementId
                      );
                    }
                  }
                });
              },
              { threshold: [0, 0.1, 0.5, 1] }
            );
          }
        }
        async discoverShimmerElements() {
          const selectors = [
            ".main-card-card",
            ".main-trackList-trackListRow",
            ".main-button-primary",
            ".main-playButton-button",
            '[data-testid="card-click-handler"]'
          ];
          let elementCount = 0;
          selectors.forEach((selector) => {
            const elements = document.querySelectorAll(selector);
            elements.forEach((element, index) => {
              const elementId = `shimmer-${selector.replace(/[^\w]/g, "_")}-${index}`;
              const htmlElement = element;
              htmlElement.setAttribute("data-shimmer-id", elementId);
              this.shimmerElements.set(elementId, htmlElement);
              if (this.intersectionObserver) {
                this.intersectionObserver.observe(htmlElement);
              }
              elementCount++;
            });
          });
          if (this.uiEffectsConfig.debugMode && elementCount > 0) {
            Y3KDebug?.debug?.log(
              "ConsciousnessUIEffectsController",
              `Discovered ${elementCount} shimmer elements`
            );
          }
        }
        setupInteractionListeners() {
          const interactionEvents = [
            "click",
            "keydown",
            "mousemove",
            "scroll",
            "touchstart"
          ];
          interactionEvents.forEach((eventType) => {
            document.addEventListener(
              eventType,
              () => {
                this.consciousnessState.interaction.isActive = true;
                this.consciousnessState.interaction.lastInteractionTime = Date.now();
                this.consciousnessState.interaction.digitalMeditationDetected = false;
                this.updateNexusState();
              },
              { passive: true }
            );
          });
        }
        startDiagnosticMonitoring() {
          this.diagnosticTimerId = window.setInterval(() => {
            this.runDiagnosticCheck();
          }, this.uiEffectsConfig.diagnosticInterval);
        }
        startUnifiedAnimationLoop() {
          const animate = /* @__PURE__ */ __name((currentTime) => {
            if (!this.initialized) return;
            const deltaTime = currentTime - this.lastFrameTime;
            this.lastFrameTime = currentTime;
            const frameStartTime = performance.now();
            try {
              this.updateConsciousnessState(deltaTime);
              if (this.uiEffectsConfig.shimmerEnabled) {
                this.updateShimmerEffects(deltaTime);
              }
              if (this.uiEffectsConfig.interactionTrackingEnabled) {
                this.updateInteractionTracking(deltaTime);
              }
              if (this.uiEffectsConfig.audioVisualEnabled) {
                this.updateAudioVisualEffects(deltaTime);
              }
              if (this.uiEffectsConfig.scrollEffectsEnabled) {
                this.updateScrollEffects(deltaTime);
              }
              this.applyCSSUpdates();
              const frameTime = performance.now() - frameStartTime;
              this.updatePerformanceMetrics(frameTime);
              if (frameTime > this.uiEffectsConfig.maxFrameTime) {
                this.handlePerformanceIssue(frameTime);
              }
            } catch (error) {
              Y3KDebug?.debug?.error(
                "ConsciousnessUIEffectsController",
                "Animation loop error:",
                error
              );
            }
            this.animationFrameId = requestAnimationFrame(animate);
          }, "animate");
          this.animationFrameId = requestAnimationFrame(animate);
        }
        updateConsciousnessState(deltaTime) {
          const state = this.consciousnessState;
          const totalActivity = state.shimmer.intensity * 0.2 + (state.interaction.isActive ? 0.3 : 0) + state.audioVisual.beatIntensity * 0.3 + state.scroll.sheenIntensity * 0.2;
          if (totalActivity > 0.8) {
            state.consciousnessLevel = "transcendent";
          } else if (totalActivity > 0.5) {
            state.consciousnessLevel = "focused";
          } else if (totalActivity > 0.2) {
            state.consciousnessLevel = "aware";
          } else {
            state.consciousnessLevel = "dormant";
          }
        }
        updateShimmerEffects(deltaTime) {
          const shimmerState = this.consciousnessState.shimmer;
          const musicInfluence = this.consciousnessState.audioVisual.beatIntensity * 0.3;
          const interactionInfluence = this.consciousnessState.interaction.isActive ? 0.2 : 0;
          shimmerState.intensity = Math.min(
            this.uiEffectsConfig.shimmerIntensity + musicInfluence + interactionInfluence,
            1
          );
          if (this.consciousnessState.performance.healthStatus === "degraded") {
            shimmerState.intensity *= 0.7;
          } else if (this.consciousnessState.performance.healthStatus === "critical") {
            shimmerState.intensity *= 0.3;
          }
        }
        updateInteractionTracking(deltaTime) {
          const interactionState = this.consciousnessState.interaction;
          const now = Date.now();
          const inactiveTime = now - interactionState.lastInteractionTime;
          if (inactiveTime > this.uiEffectsConfig.digitalMeditationThreshold) {
            if (!interactionState.digitalMeditationDetected) {
              interactionState.digitalMeditationDetected = true;
              Y3KDebug?.debug?.log(
                "ConsciousnessUIEffectsController",
                "Digital meditation detected",
                { inactiveTime }
              );
            }
          }
          this.updateNexusState();
        }
        updateNexusState() {
          const state = this.consciousnessState.interaction;
          const now = Date.now();
          const timeSinceInteraction = now - state.lastInteractionTime;
          if (state.digitalMeditationDetected) {
            state.nexusState = "meditation";
          } else if (timeSinceInteraction < 1e3) {
            state.nexusState = "active";
          } else if (timeSinceInteraction < 1e4) {
            state.nexusState = "flow";
          } else {
            state.nexusState = "idle";
          }
        }
        updateAudioVisualEffects(deltaTime) {
          const audioState = this.consciousnessState.audioVisual;
          const consciousnessBoost = this.consciousnessState.consciousnessLevel === "transcendent" ? 0.2 : 0;
          audioState.nebulaEffectIntensity = Math.min(
            this.uiEffectsConfig.nebulaEffectIntensity + audioState.beatIntensity * 0.3 + consciousnessBoost,
            1
          );
        }
        updateScrollEffects(deltaTime) {
          const scrollState = this.consciousnessState.scroll;
          const timeSinceScroll = Date.now() - scrollState.lastScrollTime;
          if (timeSinceScroll < 1e3) {
            scrollState.prismaticEffectActive = true;
            scrollState.sheenIntensity = Math.min(
              scrollState.scrollRatio * this.uiEffectsConfig.prismaticSheenIntensity,
              1
            );
          } else {
            scrollState.prismaticEffectActive = false;
            scrollState.sheenIntensity *= 0.95;
          }
        }
        applyCSSUpdates() {
          const state = this.consciousnessState;
          const updates = {
            // Core consciousness
            "--sn-ui-consciousness-level": state.consciousnessLevel,
            // Shimmer effects
            "--sn-shimmer-intensity": state.shimmer.intensity.toFixed(3),
            "--sn-shimmer-effect-type": state.shimmer.effectType,
            "--sn-shimmer-performance": state.shimmer.performanceLevel,
            // Interaction tracking
            "--sn-interaction-nexus-state": state.interaction.nexusState,
            "--sn-interaction-meditation": state.interaction.digitalMeditationDetected ? "1" : "0",
            "--sn-scroll-velocity-x": state.interaction.scrollVelocity.x.toFixed(2),
            "--sn-scroll-velocity-y": state.interaction.scrollVelocity.y.toFixed(2),
            // Audio-visual effects
            "--sn-beat-intensity": state.audioVisual.beatIntensity.toFixed(3),
            "--sn-nebula-intensity": state.audioVisual.nebulaEffectIntensity.toFixed(3),
            "--sn-genre-change": state.audioVisual.genreChangeDetected ? "1" : "0",
            // Scroll effects
            "--sn-scroll-sheen-intensity": state.scroll.sheenIntensity.toFixed(3),
            "--sn-scroll-ratio": state.scroll.scrollRatio.toFixed(3),
            "--sn-prismatic-active": state.scroll.prismaticEffectActive ? "1" : "0",
            // Diagnostic status
            "--sn-white-layer-issues": state.diagnostic.whiteLayerIssues.length.toString(),
            "--sn-webgl-healthy": state.diagnostic.webglContextHealthy ? "1" : "0"
          };
          try {
            this.cssController.batchSetVariables(
              "ConsciousnessUIEffectsController",
              updates,
              "normal",
              "ui-consciousness-update"
            );
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "ConsciousnessUIEffectsController",
              "CSS coordination error:",
              error
            );
          }
        }
        updatePerformanceMetrics(frameTime) {
          const perf = this.consciousnessState.performance;
          perf.frameTime = frameTime;
          this.frameTimeHistory.push(frameTime);
          if (this.frameTimeHistory.length > 60) {
            this.frameTimeHistory.shift();
          }
          perf.avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
          perf.maxFrameTime = Math.max(...this.frameTimeHistory);
          if (perf.avgFrameTime > 2) {
            perf.healthStatus = "critical";
          } else if (perf.avgFrameTime > 1.5) {
            perf.healthStatus = "degraded";
          } else if (perf.avgFrameTime > 1) {
            perf.healthStatus = "good";
          } else {
            perf.healthStatus = "excellent";
          }
        }
        handlePerformanceIssue(frameTime) {
          if (this.uiEffectsConfig.adaptiveQuality) {
            this.customPerformanceMonitor.adaptiveQualityLevel *= 0.9;
            if (this.customPerformanceMonitor.adaptiveQualityLevel < 0.5) {
              this.consciousnessState.shimmer.performanceLevel = "minimal";
            }
            if (this.uiEffectsConfig.debugMode) {
              Y3KDebug?.debug?.warn(
                "ConsciousnessUIEffectsController",
                `Performance issue: ${frameTime.toFixed(
                  2
                )}ms, reduced quality to ${this.customPerformanceMonitor.adaptiveQualityLevel.toFixed(
                  2
                )}`
              );
            }
          }
        }
        runDiagnosticCheck() {
          const diagnosticState = this.consciousnessState.diagnostic;
          const now = Date.now();
          diagnosticState.lastDiagnosticTime = now;
          diagnosticState.whiteLayerIssues = [];
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            diagnosticState.webglContextHealthy = !!gl;
            const elements = document.querySelectorAll(
              '[style*="background"], [style*="color"]'
            );
            let whiteLayerCount = 0;
            elements.forEach((element) => {
              const style = window.getComputedStyle(element);
              if (style.backgroundColor === "rgb(255, 255, 255)" || style.color === "rgb(255, 255, 255)") {
                whiteLayerCount++;
              }
            });
            if (whiteLayerCount > 10) {
              diagnosticState.whiteLayerIssues.push(
                `Excessive white layers detected: ${whiteLayerCount}`
              );
              if (diagnosticState.autoFixEnabled) {
                this.autoFixWhiteLayerIssues();
              }
            }
            diagnosticState.criticalIssuesDetected = diagnosticState.whiteLayerIssues.length;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Diagnostic check failed:",
              error
            );
          }
        }
        autoFixWhiteLayerIssues() {
          try {
            this.cssController.batchSetVariables(
              "ConsciousnessUIEffectsController",
              {
                "--spice-text": "var(--spice-main)",
                "--spice-subtext": "var(--catppuccin-text)"
              },
              "critical",
              "white-layer-autofix"
            );
            if (this.uiEffectsConfig.debugMode) {
              Y3KDebug?.debug?.log(
                "ConsciousnessUIEffectsController",
                "Applied white layer auto-fix"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Auto-fix failed:",
              error
            );
          }
        }
        // Event handlers (consolidated from all systems)
        handleMusicBeat(event) {
          const audioState = this.consciousnessState.audioVisual;
          audioState.beatIntensity = event.intensity || 0.5;
          audioState.lastBeatTime = Date.now();
          if (this.uiEffectsConfig.shimmerEnabled) {
            const beatBoost = audioState.beatIntensity * 0.2;
            this.consciousnessState.shimmer.intensity = Math.min(
              this.consciousnessState.shimmer.intensity + beatBoost,
              1
            );
          }
        }
        handleMusicEnergy(event) {
          const audioState = this.consciousnessState.audioVisual;
          if (event.energy !== void 0) {
            audioState.beatIntensity = Math.max(
              audioState.beatIntensity,
              event.energy * 0.8
            );
          }
        }
        handleGenreChange(event) {
          const audioState = this.consciousnessState.audioVisual;
          audioState.genreChangeDetected = true;
          setTimeout(() => {
            audioState.genreChangeDetected = false;
          }, 2e3);
        }
        handleUserScroll(event) {
          const scrollState = this.consciousnessState.scroll;
          const interactionState = this.consciousnessState.interaction;
          scrollState.lastScrollTime = Date.now();
          scrollState.scrollRatio = event.scrollRatio || 0;
          if (event.velocity) {
            interactionState.scrollVelocity = {
              x: event.velocity.x || 0,
              y: event.velocity.y || 0,
              direction: event.direction || "none"
            };
          }
          this.handleUserInteraction({ type: "scroll", timestamp: Date.now() });
        }
        handleUserInteraction(event) {
          const interactionState = this.consciousnessState.interaction;
          interactionState.isActive = true;
          interactionState.lastInteractionTime = event.timestamp || Date.now();
          interactionState.digitalMeditationDetected = false;
          this.updateNexusState();
        }
        handleSettingsChange(event) {
          const { key, value } = event;
          if (key.startsWith("sn-ui-effects-")) {
            this.updateConfigFromSettings(key, value);
          } else if (key === "sn-gradient-intensity") {
            this.uiEffectsConfig.nebulaEffectIntensity = this.getNebulaIntensityFromSettings();
            Y3KDebug?.debug?.log(
              "ConsciousnessUIEffectsController",
              `Updated nebula intensity to: ${this.uiEffectsConfig.nebulaEffectIntensity} from consolidated gradient setting: ${value}`
            );
          }
        }
        updateConfigFromSettings(key, value) {
          switch (key) {
            case "sn-ui-effects-shimmer-intensity":
              this.uiEffectsConfig.shimmerIntensity = parseFloat(value) || 0.6;
              break;
            case "sn-ui-effects-diagnostic-enabled":
              this.uiEffectsConfig.diagnosticEnabled = value === "true" || value === true;
              break;
            case "sn-ui-effects-adaptive-quality":
              this.uiEffectsConfig.adaptiveQuality = value === "true" || value === true;
              break;
          }
        }
        // BackgroundSystemParticipant interface implementation
        getConsciousnessContribution() {
          return {
            systemName: this.systemName,
            consciousnessLevel: this.consciousnessState.consciousnessLevel,
            shimmerIntensity: this.consciousnessState.shimmer.intensity,
            interactionState: this.consciousnessState.interaction.nexusState,
            audioVisualIntensity: this.consciousnessState.audioVisual.nebulaEffectIntensity,
            scrollActivity: this.consciousnessState.scroll.sheenIntensity,
            timestamp: Date.now()
          };
        }
        onConsciousnessFieldUpdate(field) {
          try {
            this.currentConsciousnessField = field;
            const fieldInfluence = field.rhythmicPulse * 0.2;
            this.consciousnessState.shimmer.intensity = Math.min(
              this.consciousnessState.shimmer.intensity + fieldInfluence,
              1
            );
            this.consciousnessState.audioVisual.nebulaEffectIntensity = Math.min(
              this.consciousnessState.audioVisual.nebulaEffectIntensity + fieldInfluence * 0.3,
              1
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Error updating from consciousness field:",
              error
            );
          }
        }
        onChoreographyEvent(eventType, data) {
          if (eventType === "transition:start") {
            this.consciousnessState.shimmer.intensity = Math.min(
              this.consciousnessState.shimmer.intensity + 0.2,
              1
            );
            this.consciousnessState.audioVisual.nebulaEffectIntensity = Math.min(
              this.consciousnessState.audioVisual.nebulaEffectIntensity + 0.15,
              1
            );
          }
          if (this.uiEffectsConfig.debugMode) {
            Y3KDebug?.debug?.log(
              "ConsciousnessUIEffectsController",
              `Choreography event: ${eventType}`,
              data
            );
          }
        }
        // Health check implementation
        async healthCheck() {
          const state = this.consciousnessState;
          const isHealthy = this.initialized && state.performance.healthStatus !== "critical" && state.diagnostic.criticalIssuesDetected === 0;
          return {
            healthy: isHealthy,
            ok: isHealthy,
            details: `UI Effects Consciousness: ${state.consciousnessLevel}, Shimmer: ${state.shimmer.activeElements.size} elements, Interaction: ${state.interaction.nexusState}, Performance: ${state.performance.healthStatus}, Diagnostics: ${state.diagnostic.criticalIssuesDetected} issues`,
            system: "ConsciousnessUIEffectsController"
          };
        }
        // Configuration API
        updateConfiguration(updates) {
          Object.assign(this.uiEffectsConfig, updates);
          if (updates.shimmerEnabled !== void 0) {
            if (updates.shimmerEnabled && !this.consciousnessState.shimmer.activeElements.size) {
              this.discoverShimmerElements();
            }
          }
          if (updates.diagnosticEnabled !== void 0) {
            if (updates.diagnosticEnabled && !this.diagnosticTimerId) {
              this.startDiagnosticMonitoring();
            } else if (!updates.diagnosticEnabled && this.diagnosticTimerId) {
              clearInterval(this.diagnosticTimerId);
              this.diagnosticTimerId = null;
            }
          }
          Y3KDebug?.debug?.log(
            "ConsciousnessUIEffectsController",
            "Configuration updated:",
            updates
          );
        }
        getConfiguration() {
          return { ...this.uiEffectsConfig };
        }
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        // Legacy compatibility methods (for migration)
        getShimmerElements() {
          return new Map(this.shimmerElements);
        }
        getInteractionState() {
          return this.consciousnessState.interaction;
        }
        getDiagnosticState() {
          return this.consciousnessState.diagnostic;
        }
        async destroy() {
          Y3KDebug?.debug?.log(
            "ConsciousnessUIEffectsController",
            "Destroying unified UI effects controller..."
          );
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
          if (this.diagnosticTimerId) {
            clearInterval(this.diagnosticTimerId);
            this.diagnosticTimerId = null;
          }
          if (this.mutationObserver) {
            this.mutationObserver.disconnect();
            this.mutationObserver = null;
          }
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            this.intersectionObserver = null;
          }
          for (const unsubscribe of this.eventUnsubscribeFunctions) {
            unsubscribe();
          }
          this.eventUnsubscribeFunctions = [];
          this.shimmerElements.clear();
          if (this.consciousnessChoreographer) {
          }
          this.initialized = false;
          Y3KDebug?.debug?.log(
            "ConsciousnessUIEffectsController",
            "Unified UI effects controller destroyed"
          );
        }
      };
      __name(_ConsciousnessUIEffectsController, "ConsciousnessUIEffectsController");
      ConsciousnessUIEffectsController = _ConsciousnessUIEffectsController;
    }
  });

  // src-js/visual/effects/HeaderVisualEffectsController.ts
  var _HeaderConsciousnessController, HeaderConsciousnessController;
  var init_HeaderVisualEffectsController = __esm({
    "src-js/visual/effects/HeaderVisualEffectsController.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      _HeaderConsciousnessController = class _HeaderConsciousnessController extends UnifiedSystemBase {
        constructor(config) {
          super(config);
          this.consciousnessState = {
            energy: 0.5,
            valence: 0.5,
            tempo: 120,
            harmonyHue: 0,
            intensity: 0.8,
            lastUpdateTime: 0,
            animationActive: true,
            preferredMotion: true,
            frameRate: 60,
            lastFrameTime: 0
          };
          this.animationFrameId = 0;
          this.updateInterval = 0;
          // Performance optimization
          this.eventDebounceTimers = {
            musicEnergy: 0,
            colorHarmony: 0,
            beatSync: 0,
            cssUpdate: 0
          };
          this.eventDebounceMs = 100;
          // Reduced from 33ms to 100ms for better performance
          this.frameThrottleMs = 16;
          // 60fps target
          this.lastCSSUpdateTime = 0;
          // Change detection for CSS variables
          this.previousCSSValues = {
            energy: 0,
            valence: 0,
            harmonyHue: 0,
            intensity: 0,
            depth: 0
          };
          this.cssChangeThreshold = 0.01;
        }
        // =========================================================================
        // PERFORMANCE OPTIMIZATION HELPERS
        // =========================================================================
        /**
         * Debounced event handler to prevent excessive processing
         */
        debouncedEventHandler(eventType, handler) {
          const now = performance.now();
          if (now - this.eventDebounceTimers[eventType] >= this.eventDebounceMs) {
            handler();
            this.eventDebounceTimers[eventType] = now;
          }
        }
        /**
         * Check if CSS values have changed significantly
         */
        hasSignificantCSSChange() {
          const state = this.consciousnessState;
          const depthMultiplier = 1 + state.energy * 0.5;
          const currentValues = {
            energy: state.energy,
            valence: state.valence,
            harmonyHue: state.harmonyHue,
            intensity: state.intensity,
            depth: depthMultiplier
          };
          for (const [key, value] of Object.entries(currentValues)) {
            const previous = this.previousCSSValues[key];
            if (Math.abs(value - previous) >= this.cssChangeThreshold) {
              return true;
            }
          }
          return false;
        }
        /**
         * Update previous CSS values for change detection
         */
        updatePreviousCSSValues() {
          const state = this.consciousnessState;
          const depthMultiplier = 1 + state.energy * 0.5;
          this.previousCSSValues.energy = state.energy;
          this.previousCSSValues.valence = state.valence;
          this.previousCSSValues.harmonyHue = state.harmonyHue;
          this.previousCSSValues.intensity = state.intensity;
          this.previousCSSValues.depth = depthMultiplier;
        }
        /**
         * Batch apply CSS updates using coordination
         */
        batchApplyCSSUpdates(updates, priority = "normal", source = "header-consciousness") {
          const variables = {};
          for (const [property, value] of updates) {
            variables[property] = value;
          }
          this.cssController.batchSetVariables(
            "HeaderConsciousnessController",
            variables,
            priority,
            source
          );
        }
        /**
         * Schedule consciousness variable update with change detection
         */
        scheduleConsciousnessUpdate() {
          this.debouncedEventHandler("cssUpdate", () => {
            if (this.hasSignificantCSSChange()) {
              this.updateHeaderConsciousnessVariables();
              this.updatePreviousCSSValues();
            }
          });
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            const year3000System2 = globalThis.year3000System;
            this.cssController = year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
            this.consciousnessState.preferredMotion = !window.matchMedia(
              "(prefers-reduced-motion: reduce)"
            ).matches;
            this.setupMusicEventListeners();
            this.setupColorHarmonyListeners();
            this.updateHeaderConsciousnessVariables();
            if (this.consciousnessState.preferredMotion) {
              this.startAnimationLoop();
            }
            this.setupPerformanceMonitoring();
            Y3KDebug?.debug?.log(
              "HeaderConsciousnessController",
              "Header consciousness initialization complete"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HeaderConsciousnessController",
              "Initialization failed:",
              error
            );
          }
        }
        setupMusicEventListeners() {
          unifiedEventBus.subscribe(
            "music:energy",
            (data) => {
              this.debouncedEventHandler("musicEnergy", () => {
                if (typeof data.energy === "number") {
                  this.consciousnessState.energy = Math.max(
                    0,
                    Math.min(1, data.energy)
                  );
                  this.scheduleConsciousnessUpdate();
                }
                if (typeof data.tempo === "number") {
                  this.consciousnessState.tempo = Math.max(
                    60,
                    Math.min(200, data.tempo)
                  );
                  this.updateAnimationSpeed();
                }
                if (typeof data.valence === "number") {
                  this.consciousnessState.valence = Math.max(
                    0,
                    Math.min(1, data.valence)
                  );
                  this.scheduleConsciousnessUpdate();
                }
              });
            },
            "HeaderConsciousnessController"
          );
          unifiedEventBus.subscribe(
            "consciousness:beat-sync",
            (data) => {
              this.debouncedEventHandler("beatSync", () => {
                if (this.consciousnessState.animationActive) {
                  const intensity = data.beatPhase || 0.8;
                  this.onBeatDetected(intensity);
                }
              });
            },
            "HeaderConsciousnessController"
          );
          unifiedEventBus.subscribe(
            "music:energy-changed",
            (data) => {
              this.debouncedEventHandler("musicEnergy", () => {
                if (typeof data.energy === "number") {
                  this.consciousnessState.energy = Math.max(
                    0,
                    Math.min(1, data.energy)
                  );
                  this.scheduleConsciousnessUpdate();
                }
              });
            },
            "HeaderConsciousnessController"
          );
        }
        setupColorHarmonyListeners() {
          unifiedEventBus.subscribe(
            "colors:harmonized",
            (data) => {
              this.debouncedEventHandler("colorHarmony", () => {
                if (data.coordinationMetrics?.coordinationStrategy) {
                  this.updateHarmonyHue(
                    data.coordinationMetrics.coordinationStrategy
                  );
                }
              });
            },
            "HeaderConsciousnessController"
          );
          unifiedEventBus.subscribe(
            "colors:extracted",
            (data) => {
              this.debouncedEventHandler("colorHarmony", () => {
                if (data.musicData && typeof data.musicData.energy === "number") {
                  const hue = data.musicData.energy * 360;
                  this.consciousnessState.harmonyHue = hue;
                  this.scheduleConsciousnessUpdate();
                }
              });
            },
            "HeaderConsciousnessController"
          );
        }
        updateHarmonyHue(harmonicMode) {
          const harmonyHueMap = {
            monochromatic: 0,
            complementary: 180,
            triadic: 120,
            analogous: 30,
            tetradic: 90,
            "split-complementary": 150
          };
          const baseHue = harmonyHueMap[harmonicMode] || 0;
          this.consciousnessState.harmonyHue = baseHue;
          this.scheduleConsciousnessUpdate();
        }
        onBeatDetected(intensity) {
          const beatEnergy = Math.min(
            1,
            this.consciousnessState.energy + intensity * 0.3
          );
          this.batchApplyCSSUpdates([
            ["--header-consciousness-energy", beatEnergy.toString()]
          ], "high", "beat-sync");
          const resetTime = performance.now() + 150;
          const resetBeatEffect = /* @__PURE__ */ __name(() => {
            if (performance.now() >= resetTime && this.initialized) {
              this.batchApplyCSSUpdates([
                [
                  "--header-consciousness-energy",
                  this.consciousnessState.energy.toString()
                ]
              ], "normal", "beat-reset");
            } else if (this.initialized) {
              requestAnimationFrame(resetBeatEffect);
            }
          }, "resetBeatEffect");
          requestAnimationFrame(resetBeatEffect);
        }
        updateAnimationSpeed() {
          const tempoMultiplier = this.consciousnessState.tempo / 120;
          const baseSpeed = 8;
          const newSpeed = baseSpeed / tempoMultiplier;
          this.batchApplyCSSUpdates([
            [
              "--header-consciousness-flow-speed",
              `${Math.max(2, Math.min(16, newSpeed))}s`
            ]
          ], "high", "tempo-sync");
        }
        updateHeaderConsciousnessVariables() {
          if (!this.initialized) return;
          const state = this.consciousnessState;
          const dynamicIntensity = state.intensity * (0.6 + state.valence * 0.4) * (0.8 + state.energy * 0.2);
          const depthMultiplier = 1 + state.energy * 0.5;
          this.batchApplyCSSUpdates([
            ["--header-consciousness-energy", state.energy.toString()],
            ["--header-consciousness-harmony", `${state.harmonyHue}deg`],
            ["--header-soul-intensity", dynamicIntensity.toString()],
            ["--header-consciousness-depth", depthMultiplier.toString()]
          ], "normal", "consciousness-update");
          this.consciousnessState.lastUpdateTime = Date.now();
        }
        startAnimationLoop() {
          const animate = /* @__PURE__ */ __name((currentTime) => {
            if (!this.initialized || !this.consciousnessState.animationActive) return;
            if (currentTime - this.lastCSSUpdateTime < this.frameThrottleMs) {
              this.animationFrameId = requestAnimationFrame(animate);
              return;
            }
            const deltaTime = currentTime - this.consciousnessState.lastFrameTime;
            this.consciousnessState.frameRate = 1e3 / deltaTime;
            this.consciousnessState.lastFrameTime = currentTime;
            if (currentTime - this.consciousnessState.lastUpdateTime > 100) {
              if (this.hasSignificantCSSChange()) {
                this.updateHeaderConsciousnessVariables();
                this.updatePreviousCSSValues();
              }
            }
            this.lastCSSUpdateTime = currentTime;
            this.animationFrameId = requestAnimationFrame(animate);
          }, "animate");
          this.animationFrameId = requestAnimationFrame(animate);
        }
        setupPerformanceMonitoring() {
          this.updateInterval = window.setInterval(() => {
            if (!this.initialized) return;
            if (this.consciousnessState.frameRate < 30) {
              Y3KDebug?.debug?.warn(
                "HeaderConsciousnessController",
                "Performance degradation detected, reducing update frequency"
              );
            }
            this.cssController.setVariable(
              "HeaderConsciousnessController",
              "--header-consciousness-performance",
              this.consciousnessState.frameRate > 50 ? "1" : "0.5",
              "low",
              // Low priority for performance monitoring updates
              "performance-monitor"
            );
          }, 2e3);
        }
        /**
         * Manually update header consciousness intensity
         */
        setConsciousnessIntensity(intensity) {
          this.consciousnessState.intensity = Math.max(0, Math.min(1, intensity));
          this.updateHeaderConsciousnessVariables();
        }
        /**
         * Enable or disable header consciousness animations
         */
        setAnimationActive(active) {
          this.consciousnessState.animationActive = active;
          if (!active && this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = 0;
          } else if (active && this.consciousnessState.preferredMotion) {
            this.startAnimationLoop();
          }
        }
        /**
         * Get current consciousness state for debugging
         */
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        async healthCheck() {
          const isHealthy = this.initialized && this.consciousnessState.frameRate > 20 && Date.now() - this.consciousnessState.lastUpdateTime < 5e3;
          return {
            healthy: isHealthy,
            issues: isHealthy ? [] : [
              this.consciousnessState.frameRate <= 20 ? "Low frame rate detected" : "",
              Date.now() - this.consciousnessState.lastUpdateTime >= 5e3 ? "No recent updates" : ""
            ].filter((issue) => issue),
            metrics: {
              frameRate: this.consciousnessState.frameRate,
              energy: this.consciousnessState.energy,
              intensity: this.consciousnessState.intensity,
              animationActive: this.consciousnessState.animationActive,
              lastUpdate: this.consciousnessState.lastUpdateTime
            }
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = 0;
          }
          if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = 0;
          }
          unifiedEventBus.unsubscribeAll("HeaderConsciousnessController");
          Y3KDebug?.debug?.log(
            "HeaderConsciousnessController",
            "Header consciousness system cleaned up"
          );
        }
        // Required abstract method implementations
        async initialize() {
          await this._baseInitialize();
        }
        async destroy() {
          this._performSystemSpecificCleanup();
        }
        onAnimate(deltaTime) {
          if (this.consciousnessState.animationActive) {
            this.updateHeaderConsciousnessVariables();
          }
        }
      };
      __name(_HeaderConsciousnessController, "HeaderConsciousnessController");
      HeaderConsciousnessController = _HeaderConsciousnessController;
    }
  });

  // src-js/utils/graphics/NoiseField.ts
  function sample(u, v) {
    const x = Math.max(0, Math.min(0.9999, u)) * (GRID_SIZE - 1);
    const y = Math.max(0, Math.min(0.9999, v)) * (GRID_SIZE - 1);
    const x0 = Math.floor(x);
    const y0 = Math.floor(y);
    const x1 = x0 + 1;
    const y1 = y0 + 1;
    const sx = x - x0;
    const sy = y - y0;
    const v00 = vectors[y0 * GRID_SIZE + x0];
    const v10 = vectors[y0 * GRID_SIZE + x1 % GRID_SIZE];
    const v01 = vectors[y1 % GRID_SIZE * GRID_SIZE + x0];
    const v11 = vectors[y1 % GRID_SIZE * GRID_SIZE + x1 % GRID_SIZE];
    const lerp2 = /* @__PURE__ */ __name((a, b, t) => a + (b - a) * t, "lerp");
    const ix0x = lerp2(v00.x, v10.x, sx);
    const ix0y = lerp2(v00.y, v10.y, sx);
    const ix1x = lerp2(v01.x, v11.x, sx);
    const ix1y = lerp2(v01.y, v11.y, sx);
    return {
      x: lerp2(ix0x, ix1x, sy),
      y: lerp2(ix0y, ix1y, sy)
    };
  }
  var GRID_SIZE, vectors;
  var init_NoiseField = __esm({
    "src-js/utils/graphics/NoiseField.ts"() {
      "use strict";
      GRID_SIZE = 64;
      vectors = new Array(GRID_SIZE * GRID_SIZE);
      (/* @__PURE__ */ __name(function init() {
        for (let i = 0; i < vectors.length; i++) {
          const angle = Math.random() * Math.PI * 2;
          vectors[i] = {
            x: Math.cos(angle),
            y: Math.sin(angle)
          };
        }
      }, "init"))();
      __name(sample, "sample");
    }
  });

  // src-js/visual/effects/UnifiedSidebarEffectsController.ts
  var _UnifiedSidebarConsciousnessController, UnifiedSidebarConsciousnessController;
  var init_UnifiedSidebarEffectsController = __esm({
    "src-js/visual/effects/UnifiedSidebarEffectsController.ts"() {
      "use strict";
      init_globalConfig();
      init_UnifiedSystemBase();
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_NoiseField();
      _UnifiedSidebarConsciousnessController = class _UnifiedSidebarConsciousnessController extends UnifiedSystemBase {
        constructor(config) {
          super(config);
          // BackgroundSystemParticipant implementation
          this.systemName = "UnifiedSidebarConsciousnessController";
          // Infrastructure dependencies
          this.sidebarPerformanceCoordinator = null;
          this.consciousnessChoreographer = null;
          this.currentConsciousnessField = null;
          // Animation and timing
          this.animationFrameId = null;
          this.lastFrameTime = 0;
          this.frameTimeHistory = [];
          // Event subscriptions
          this.eventUnsubscribeFunctions = [];
          // Bilateral coordination (for enhanced functionality)
          this.bilateralState = null;
          // NEW: Enhanced properties (from SidebarConsciousnessSystem)
          this.rootNavBar = null;
          this.overlayContainer = null;
          this.consciousnessVisualizer = null;
          this.harmonicModeIndicator = null;
          this.resizeObserver = null;
          this.masterAnimationRegistered = false;
          this.isUsingMasterAnimation = false;
          // Performance monitoring (enhanced)
          this._lastMotionDisabled = false;
          this._navInteractionHandler = null;
          this.sidebarConfig = {
            enabled: true,
            bilateralMode: false,
            // Can be enabled for enhanced functionality
            consciousnessThreshold: 0.3,
            musicResponsiveness: 0.8,
            beatSensitivity: 0.7,
            energySmoothing: 0.85,
            animationIntensity: 0.6,
            smoothingFactor: 0.85,
            maxFrameTime: 1,
            // <1ms budget from original systems
            bilateralOffset: 150,
            // Enhanced system's 150ms offset
            crossChannelBleed: 0.15,
            enablePerformanceMonitoring: true,
            adaptiveQuality: true,
            debugMode: config.enableDebug || false,
            // NEW: Enhanced features
            echoIntensity: 2,
            // Default medium echo intensity
            enableTemporalEcho: true,
            enableHarmonicModes: true,
            enableDeviceDetection: true
          };
          this.consciousnessState = this.createInitialConsciousnessState();
          Y3KDebug?.debug?.log(
            "UnifiedSidebarConsciousnessController",
            "Enhanced unified sidebar consciousness controller created (Phase 2.5)"
          );
        }
        get systemPriority() {
          return "normal";
        }
        createInitialConsciousnessState() {
          return {
            consciousnessLevel: "dormant",
            bilateralCoordination: false,
            musicSync: {
              energy: 0,
              valence: 0.5,
              beat: false,
              tempo: 120,
              lastBeatTime: 0
            },
            animation: {
              intensity: 0,
              phase: 0,
              lastFrameTime: 0,
              targetIntensity: 0,
              smoothingFactor: this.sidebarConfig.smoothingFactor,
              // NEW: Enhanced animation properties
              currentScale: 1,
              baseOpacity: 0.7,
              pulseDirection: 1,
              lastPulse: 0
            },
            performance: {
              frameTime: 0,
              avgFrameTime: 0,
              maxFrameTime: 0,
              healthStatus: "excellent"
            },
            // NEW: Device capabilities
            deviceCapabilities: {
              supportsCSSFilter: this._detectCSSFilterSupport(),
              supportsTransforms: this._detectTransformSupport(),
              performanceLevel: this._detectPerformanceLevel(),
              reducedMotion: this._detectReducedMotion(),
              memory: navigator.deviceMemory || 4,
              cores: navigator.hardwareConcurrency || 4
            },
            // NEW: Temporal echo system
            temporalEcho: {
              echoPool: [],
              currentEchoCount: 0,
              maxEchoes: this._getMaxEchoes(),
              echoTimerCounter: 0,
              activeEchoElements: /* @__PURE__ */ new Set()
            },
            // NEW: Harmonic mode system
            harmonicMode: {
              currentModeKey: "artist-vision",
              currentModeClass: "",
              currentEnergyClass: "",
              modeConfig: null
            }
          };
        }
        // UnifiedSystemBase implementation
        async initialize() {
          return this._baseInitialize();
        }
        onAnimate(deltaTime) {
        }
        async _baseInitialize() {
          try {
            Y3KDebug?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              "Starting enhanced unified initialization..."
            );
            const year3000System2 = globalThis.year3000System;
            this.cssController = year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
            await this.initializeDOMElements();
            await this.initializePerformanceCoordinator();
            await this.initializeConsciousnessIntegration();
            if (this.sidebarConfig.enableHarmonicModes) {
              this.createOverlayContainer();
              this.createConsciousnessVisualizer();
              this.createHarmonicModeDisplay();
              this.updateColors();
            }
            if (this.sidebarConfig.enableTemporalEcho) {
              this.setupInteractionHandling();
            }
            this.setupResizeObserver();
            this.subscribeToUnifiedEvents();
            if (this.sidebarConfig.bilateralMode) {
              this.initializeBilateralCoordination();
            }
            this.startUnifiedAnimationLoop();
            this.initialized = true;
            Y3KDebug?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              `Enhanced unified sidebar consciousness initialized (bilateral: ${this.sidebarConfig.bilateralMode}, echo: ${this.sidebarConfig.enableTemporalEcho}, harmonic: ${this.sidebarConfig.enableHarmonicModes})`
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to initialize:",
              error
            );
            throw error;
          }
        }
        async initializePerformanceCoordinator() {
          try {
            this.sidebarPerformanceCoordinator = globalThis.sidebarPerformanceCoordinator || null;
            if (!this.sidebarPerformanceCoordinator) {
              Y3KDebug?.debug?.warn(
                "UnifiedSidebarConsciousnessController",
                "SidebarPerformanceCoordinator not available, CSS updates may be less efficient"
              );
            } else {
              Y3KDebug?.debug?.log(
                "UnifiedSidebarConsciousnessController",
                "Connected to shared SidebarPerformanceCoordinator"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "UnifiedSidebarConsciousnessController",
              "Performance coordinator initialization failed:",
              error
            );
          }
        }
        async initializeConsciousnessIntegration() {
          try {
            this.consciousnessChoreographer = globalThis.backgroundConsciousnessChoreographer || null;
            if (this.consciousnessChoreographer) {
              this.consciousnessChoreographer.registerConsciousnessParticipant(this);
              Y3KDebug?.debug?.log(
                "UnifiedSidebarConsciousnessController",
                "Registered with consciousness choreographer"
              );
            } else {
              Y3KDebug?.debug?.log(
                "UnifiedSidebarConsciousnessController",
                "Operating without consciousness choreographer integration"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "UnifiedSidebarConsciousnessController",
              "Consciousness integration failed:",
              error
            );
          }
        }
        subscribeToUnifiedEvents() {
          const musicBeatUnsubscribe = unifiedEventBus.subscribe(
            "music:beat",
            this.handleMusicBeat.bind(this),
            "UnifiedSidebarConsciousnessController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(musicBeatUnsubscribe)
          );
          const musicEnergyUnsubscribe = unifiedEventBus.subscribe(
            "music:energy",
            this.handleMusicEnergy.bind(this),
            "UnifiedSidebarConsciousnessController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(musicEnergyUnsubscribe)
          );
          const settingsUnsubscribe = unifiedEventBus.subscribe(
            "settings:visual-guide-changed",
            this.handleSettingsChange.bind(this),
            "UnifiedSidebarConsciousnessController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(settingsUnsubscribe)
          );
          const colorHarmonizedUnsubscribe = unifiedEventBus.subscribe(
            "colors:harmonized",
            this.handleColorsHarmonized.bind(this),
            "UnifiedSidebarConsciousnessController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(colorHarmonizedUnsubscribe)
          );
          const colorExtractedUnsubscribe = unifiedEventBus.subscribe(
            "colors:extracted",
            this.handleColorsExtracted.bind(this),
            "UnifiedSidebarConsciousnessController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(colorExtractedUnsubscribe)
          );
          const colorConsciousnessUnsubscribe = unifiedEventBus.subscribe(
            "emotionalColorContext:updated",
            this.handleColorConsciousnessUpdate.bind(this),
            "UnifiedSidebarConsciousnessController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(colorConsciousnessUnsubscribe)
          );
          Y3KDebug?.debug?.log(
            "UnifiedSidebarConsciousnessController",
            `Subscribed to ${this.eventUnsubscribeFunctions.length} unified events (including color consciousness)`
          );
        }
        initializeBilateralCoordination() {
          this.bilateralState = {
            leftSide: this.createInitialConsciousnessState(),
            rightSide: this.createInitialConsciousnessState(),
            coordinationOffset: this.sidebarConfig.bilateralOffset,
            lastCoordinationTime: 0
          };
          this.consciousnessState.bilateralCoordination = true;
          Y3KDebug?.debug?.log(
            "UnifiedSidebarConsciousnessController",
            `Bilateral coordination initialized with ${this.sidebarConfig.bilateralOffset}ms offset`
          );
        }
        startUnifiedAnimationLoop() {
          const animate = /* @__PURE__ */ __name((currentTime) => {
            if (!this.initialized) return;
            const deltaTime = currentTime - this.lastFrameTime;
            this.lastFrameTime = currentTime;
            const frameStartTime = performance.now();
            try {
              this.updateConsciousnessState(deltaTime);
              if (this.sidebarConfig.bilateralMode && this.bilateralState) {
                this.updateBilateralCoordination(deltaTime);
              }
              this.applyCSSUpdates();
              const frameTime = performance.now() - frameStartTime;
              this.updatePerformanceMetrics(frameTime);
              if (frameTime > this.sidebarConfig.maxFrameTime) {
                Y3KDebug?.debug?.warn(
                  "UnifiedSidebarConsciousnessController",
                  `Frame time exceeded budget: ${frameTime.toFixed(2)}ms`
                );
              }
            } catch (error) {
              Y3KDebug?.debug?.error(
                "UnifiedSidebarConsciousnessController",
                "Animation loop error:",
                error
              );
            }
            this.animationFrameId = requestAnimationFrame(animate);
          }, "animate");
          this.animationFrameId = requestAnimationFrame(animate);
        }
        updateConsciousnessState(deltaTime) {
          const state = this.consciousnessState;
          const energyInfluence = state.musicSync.energy * this.sidebarConfig.musicResponsiveness;
          state.animation.targetIntensity = Math.min(energyInfluence, 1);
          state.animation.intensity = this.lerp(
            state.animation.intensity,
            state.animation.targetIntensity,
            state.animation.smoothingFactor
          );
          state.animation.phase += deltaTime * 1e-3;
          if (state.animation.phase > Math.PI * 2) {
            state.animation.phase -= Math.PI * 2;
          }
          this.updateConsciousnessLevel();
        }
        updateConsciousnessLevel() {
          const state = this.consciousnessState;
          const totalActivity = state.animation.intensity + (state.musicSync.beat ? 0.3 : 0);
          if (totalActivity > 0.8) {
            state.consciousnessLevel = "transcendent";
          } else if (totalActivity > 0.5) {
            state.consciousnessLevel = "focused";
          } else if (totalActivity > 0.2) {
            state.consciousnessLevel = "aware";
          } else {
            state.consciousnessLevel = "dormant";
          }
          if (this.sidebarConfig.bilateralMode) {
            unifiedEventBus.emit("consciousness:coordination", {
              source: "UnifiedSidebarConsciousnessController",
              state: {
                type: "bilateral-consciousness-level",
                level: state.consciousnessLevel,
                intensity: state.animation.intensity
              },
              timestamp: Date.now()
            });
          }
        }
        updateBilateralCoordination(deltaTime) {
          if (!this.bilateralState) return;
          const now = Date.now();
          if (now - this.bilateralState.lastCoordinationTime > this.bilateralState.coordinationOffset) {
            const leftIntensity = this.bilateralState.leftSide.animation.intensity;
            const rightIntensity = this.bilateralState.rightSide.animation.intensity;
            this.bilateralState.rightSide.animation.targetIntensity = leftIntensity * (1 - this.sidebarConfig.crossChannelBleed) + rightIntensity * this.sidebarConfig.crossChannelBleed;
            this.bilateralState.lastCoordinationTime = now;
            unifiedEventBus.emit("consciousness:coordination", {
              source: "UnifiedSidebarConsciousnessController",
              state: {
                type: "bilateral-coordination",
                leftIntensity,
                rightIntensity,
                offset: this.bilateralState.coordinationOffset
              },
              timestamp: Date.now()
            });
          }
        }
        applyCSSUpdates() {
          if (!this.sidebarPerformanceCoordinator) {
            this.applyDirectCSSUpdates();
            return;
          }
          const state = this.consciousnessState;
          const updates = {
            "--sn-sidebar-consciousness-level": state.consciousnessLevel,
            "--sn-sidebar-intensity": state.animation.intensity.toFixed(3),
            "--sn-sidebar-phase": state.animation.phase.toFixed(3),
            "--sn-sidebar-energy": state.musicSync.energy.toFixed(3),
            "--sn-sidebar-valence": state.musicSync.valence.toFixed(3)
          };
          if (this.sidebarConfig.bilateralMode && this.bilateralState) {
            updates["--sn-sidebar-bilateral-left"] = this.bilateralState.leftSide.animation.intensity.toFixed(3);
            updates["--sn-sidebar-bilateral-right"] = this.bilateralState.rightSide.animation.intensity.toFixed(3);
          }
          try {
            for (const [variable, value] of Object.entries(updates)) {
              this.sidebarPerformanceCoordinator.queueUpdate(variable, value);
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "UnifiedSidebarConsciousnessController",
              "CSS update error:",
              error
            );
            this.applyDirectCSSUpdates();
          }
        }
        applyDirectCSSUpdates() {
          const state = this.consciousnessState;
          const sidebarConsciousnessVariables = {
            "--sn-sidebar-consciousness-level": state.consciousnessLevel,
            "--sn-sidebar-intensity": state.animation.intensity.toFixed(3),
            "--sn-sidebar-phase": state.animation.phase.toFixed(3),
            "--sn-sidebar-energy": state.musicSync.energy.toFixed(3),
            "--sn-sidebar-valence": state.musicSync.valence.toFixed(3)
          };
          this.cssController.batchSetVariables(
            "UnifiedSidebarConsciousnessController",
            sidebarConsciousnessVariables,
            "high",
            // High priority for sidebar consciousness state updates
            "sidebar-consciousness-fallback-update"
          );
        }
        updatePerformanceMetrics(frameTime) {
          const perf = this.consciousnessState.performance;
          perf.frameTime = frameTime;
          this.frameTimeHistory.push(frameTime);
          if (this.frameTimeHistory.length > 60) {
            this.frameTimeHistory.shift();
          }
          perf.avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
          perf.maxFrameTime = Math.max(...this.frameTimeHistory);
          if (perf.avgFrameTime > 2) {
            perf.healthStatus = "critical";
          } else if (perf.avgFrameTime > 1.5) {
            perf.healthStatus = "degraded";
          } else if (perf.avgFrameTime > 1) {
            perf.healthStatus = "good";
          } else {
            perf.healthStatus = "excellent";
          }
        }
        // Event handlers (consolidated from all systems)
        handleMusicBeat(event) {
          const state = this.consciousnessState.musicSync;
          state.beat = true;
          state.lastBeatTime = Date.now();
          setTimeout(() => {
            state.beat = false;
          }, 100);
          if (this.sidebarConfig.debugMode) {
            Y3KDebug?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              "Music beat received"
            );
          }
        }
        handleMusicEnergy(event) {
          const state = this.consciousnessState.musicSync;
          if (event.energy !== void 0) {
            state.energy = this.lerp(
              state.energy,
              event.energy,
              1 - this.sidebarConfig.energySmoothing
            );
          }
          if (event.valence !== void 0) {
            state.valence = this.lerp(
              state.valence,
              event.valence,
              1 - this.sidebarConfig.energySmoothing
            );
          }
          if (event.tempo !== void 0) {
            state.tempo = event.tempo;
          }
        }
        handleSettingsChange(event) {
          const { key, value } = event;
          if (key.startsWith("sn-sidebar-")) {
            this.updateConfigFromSettings(key, value);
          }
        }
        updateConfigFromSettings(key, value) {
          switch (key) {
            case "sn-sidebar-intensity":
              this.sidebarConfig.animationIntensity = parseFloat(value) || 0.6;
              break;
            case "sn-sidebar-bilateral":
              const enableBilateral = value === "true" || value === true;
              if (enableBilateral !== this.sidebarConfig.bilateralMode) {
                this.sidebarConfig.bilateralMode = enableBilateral;
                if (enableBilateral) {
                  this.initializeBilateralCoordination();
                } else {
                  this.bilateralState = null;
                  this.consciousnessState.bilateralCoordination = false;
                }
              }
              break;
            case "sn-sidebar-responsiveness":
              this.sidebarConfig.musicResponsiveness = parseFloat(value) || 0.8;
              break;
          }
        }
        //  COLOR CONSCIOUSNESS EVENT HANDLERS (NEW - Phase 3.5)
        handleColorsHarmonized(event) {
          const { processedColors, coordinationMetrics } = event;
          try {
            this.updateSidebarColorsFromOKLAB(processedColors);
            if (coordinationMetrics?.emotionalState) {
              this.adjustConsciousnessForColorState(coordinationMetrics);
            }
            Y3KDebug?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              "\u{1F3A8} Updated sidebar colors from harmonized OKLAB data",
              {
                colorCount: Object.keys(processedColors).length,
                emotionalState: coordinationMetrics?.emotionalState
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to handle colors:harmonized event:",
              error
            );
          }
        }
        handleColorsExtracted(event) {
          const { rawColors, musicData } = event;
          try {
            if (rawColors?.DOMINANT) {
              this.updateSidebarAccentColor(rawColors.DOMINANT);
            }
            if (musicData) {
              this.adjustMusicResponsivenessForColors(musicData);
            }
            Y3KDebug?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              "\u{1F3A8} Applied immediate color feedback from extracted colors"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to handle colors:extracted event:",
              error
            );
          }
        }
        handleColorConsciousnessUpdate(event) {
          const { palette, consciousnessLevel, emotionalTemperature } = event;
          try {
            const colorInfluence = consciousnessLevel * 0.4;
            if (colorInfluence > 0.8) {
              this.consciousnessState.consciousnessLevel = "transcendent";
            } else if (colorInfluence > 0.5) {
              this.consciousnessState.consciousnessLevel = "focused";
            } else if (colorInfluence > 0.2) {
              this.consciousnessState.consciousnessLevel = "aware";
            } else {
              this.consciousnessState.consciousnessLevel = "dormant";
            }
            if (emotionalTemperature !== void 0) {
              const temp = typeof emotionalTemperature === "string" ? parseFloat(emotionalTemperature) : emotionalTemperature;
              if (!isNaN(temp)) {
                this.updateSidebarTemperature(temp);
              }
            }
            Y3KDebug?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              "\u{1F3A8} Synchronized sidebar consciousness with color state",
              {
                consciousnessLevel: colorInfluence,
                emotionalTemperature
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to handle colorConsciousnessUpdate event:",
              error
            );
          }
        }
        // BackgroundSystemParticipant interface implementation
        getConsciousnessContribution() {
          return {
            systemName: this.systemName,
            consciousnessLevel: this.consciousnessState.consciousnessLevel,
            intensity: this.consciousnessState.animation.intensity,
            musicSync: this.consciousnessState.musicSync,
            bilateral: this.sidebarConfig.bilateralMode ? this.bilateralState : null,
            timestamp: Date.now()
          };
        }
        onConsciousnessFieldUpdate(field) {
          try {
            this.currentConsciousnessField = field;
            const fieldInfluence = field.rhythmicPulse * 0.3;
            this.consciousnessState.animation.targetIntensity = Math.min(
              this.consciousnessState.animation.targetIntensity + fieldInfluence,
              1
            );
            if (this.sidebarConfig.debugMode) {
              Y3KDebug?.debug?.log(
                "UnifiedSidebarConsciousnessController",
                "Updated from consciousness field:",
                {
                  rhythmicPulse: field.rhythmicPulse,
                  sidebarIntensity: this.consciousnessState.animation.intensity
                }
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Error updating from consciousness field:",
              error
            );
          }
        }
        onChoreographyEvent(eventType, data) {
          if (eventType === "transition:start") {
            this.consciousnessState.animation.targetIntensity = Math.min(
              this.consciousnessState.animation.targetIntensity + 0.2,
              1
            );
          }
          if (this.sidebarConfig.debugMode) {
            Y3KDebug?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              `Choreography event: ${eventType}`,
              data
            );
          }
        }
        // Utility methods
        lerp(current, target, factor) {
          return current + (target - current) * factor;
        }
        // Health check implementation
        async healthCheck() {
          const state = this.consciousnessState;
          const isHealthy = this.initialized && state.performance.healthStatus !== "critical" && state.performance.avgFrameTime < 2;
          return {
            healthy: isHealthy,
            ok: isHealthy,
            details: `Consciousness: ${state.consciousnessLevel}, Intensity: ${state.animation.intensity.toFixed(2)}, Avg Frame: ${state.performance.avgFrameTime.toFixed(2)}ms, Status: ${state.performance.healthStatus}` + (this.sidebarConfig.bilateralMode ? ", Bilateral: enabled" : ""),
            system: "UnifiedSidebarConsciousnessController"
          };
        }
        // NEW: Device capability detection methods (from SidebarConsciousnessSystem)
        _detectCSSFilterSupport() {
          try {
            const testElement = document.createElement("div");
            testElement.style.filter = "blur(1px)";
            return testElement.style.filter === "blur(1px)";
          } catch (error) {
            return false;
          }
        }
        _detectTransformSupport() {
          try {
            const testElement = document.createElement("div");
            testElement.style.transform = "translateX(1px)";
            return testElement.style.transform === "translateX(1px)";
          } catch (error) {
            return false;
          }
        }
        _detectPerformanceLevel() {
          const memory = navigator.deviceMemory || 4;
          const cores = navigator.hardwareConcurrency || 4;
          if (memory >= 8 && cores >= 8) {
            return "high";
          } else if (memory >= 4 && cores >= 4) {
            return "medium";
          } else {
            return "low";
          }
        }
        _detectReducedMotion() {
          if (typeof window !== "undefined" && window.matchMedia) {
            return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
          }
          return false;
        }
        _getMaxEchoes() {
          const deviceCapabilities = {
            memory: navigator.deviceMemory || 4,
            cores: navigator.hardwareConcurrency || 4
          };
          if (deviceCapabilities.memory >= 8 && deviceCapabilities.cores >= 8) {
            return 12;
          } else if (deviceCapabilities.memory >= 4 && deviceCapabilities.cores >= 4) {
            return 8;
          } else {
            return 4;
          }
        }
        // NEW: DOM initialization methods (from SidebarConsciousnessSystem)
        async initializeDOMElements() {
          try {
            this.rootNavBar = document.querySelector(".Root__nav-bar") || document.querySelector('[data-testid="rootlist-container"]') || document.querySelector(".main-navBar-navBar");
            if (!this.rootNavBar) {
              Y3KDebug?.debug?.warn(
                "UnifiedSidebarConsciousnessController",
                "Root navigation bar not found"
              );
              return;
            }
            Y3KDebug?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              "DOM elements initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "DOM initialization error:",
              error
            );
            throw error;
          }
        }
        createOverlayContainer() {
          if (!this.rootNavBar || this.overlayContainer) return;
          this.overlayContainer = document.createElement("div");
          this.overlayContainer.className = "sn-consciousness-overlay";
          this.overlayContainer.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 1;
      overflow: hidden;
    `;
          this.rootNavBar.style.position = "relative";
          this.rootNavBar.appendChild(this.overlayContainer);
        }
        createConsciousnessVisualizer() {
          if (!this.overlayContainer || this.consciousnessVisualizer) return;
          this.consciousnessVisualizer = document.createElement("div");
          this.consciousnessVisualizer.className = "sn-consciousness-visualizer";
          this.consciousnessVisualizer.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at var(--sn-consciousness-x, 50%) var(--sn-consciousness-y, 50%),
                                  hsla(var(--sn-consciousness-hue, 280), 70%, 60%, var(--sn-consciousness-alpha, 0.1)) 0%,
                                  hsla(var(--sn-consciousness-hue, 280), 50%, 40%, var(--sn-consciousness-alpha, 0.05)) 30%,
                                  transparent 70%);
      mix-blend-mode: overlay;
      transition: all 0.3s ease;
      opacity: var(--sn-consciousness-intensity, 0);
    `;
          this.overlayContainer.appendChild(this.consciousnessVisualizer);
        }
        createHarmonicModeDisplay() {
          if (!this.overlayContainer || this.harmonicModeIndicator) return;
          this.harmonicModeIndicator = document.createElement("div");
          this.harmonicModeIndicator.className = "sn-harmonic-mode-indicator";
          this.harmonicModeIndicator.style.cssText = `
      position: absolute;
      top: 8px;
      right: 8px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--sn-harmonic-color, #a855f7);
      opacity: var(--sn-harmonic-intensity, 0);
      transition: all 0.3s ease;
      pointer-events: none;
    `;
          this.overlayContainer.appendChild(this.harmonicModeIndicator);
        }
        updateColors() {
          if (!this.sidebarPerformanceCoordinator) {
            this.applyDirectColorUpdates();
            return;
          }
          const state = this.consciousnessState;
          const harmonicMode = state.harmonicMode;
          try {
            const modeConfig = HARMONIC_MODES2[harmonicMode.currentModeKey] || HARMONIC_MODES2["artist-vision"];
            this.sidebarPerformanceCoordinator.queueUpdate(
              "--sn-consciousness-hue",
              "280"
            );
            this.sidebarPerformanceCoordinator.queueUpdate(
              "--sn-harmonic-color",
              "#a855f7"
            );
            this.sidebarPerformanceCoordinator.queueUpdate(
              "--sn-consciousness-intensity",
              state.animation.intensity.toFixed(3)
            );
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "UnifiedSidebarConsciousnessController",
              "Color update error:",
              error
            );
            this.applyDirectColorUpdates();
          }
        }
        applyDirectColorUpdates() {
          const state = this.consciousnessState;
          const sidebarColorVariables = {
            "--sn-consciousness-hue": "280",
            "--sn-harmonic-color": "#a855f7",
            "--sn-consciousness-intensity": state.animation.intensity.toFixed(3)
          };
          this.cssController.batchSetVariables(
            "UnifiedSidebarConsciousnessController",
            sidebarColorVariables,
            "high",
            // High priority for consciousness color updates
            "sidebar-color-fallback-update"
          );
        }
        setupInteractionHandling() {
          if (!this.rootNavBar) return;
          this._navInteractionHandler = (evt) => {
            if (this.sidebarConfig.enableTemporalEcho) {
              this._spawnNavEcho(evt);
            }
          };
          this.rootNavBar.addEventListener("click", this._navInteractionHandler, {
            passive: true
          });
          this.rootNavBar.addEventListener("mouseover", this._navInteractionHandler, {
            passive: true
          });
        }
        setupResizeObserver() {
          if (typeof ResizeObserver === "undefined" || !this.rootNavBar) return;
          this.resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
              this.updateConsciousnessVisualizerSize(entry.contentRect);
            }
          });
          this.resizeObserver.observe(this.rootNavBar);
        }
        updateConsciousnessVisualizerSize(rect) {
          if (!this.consciousnessVisualizer) return;
          const updates = {
            "--sn-sidebar-width": `${rect.width}px`,
            "--sn-sidebar-height": `${rect.height}px`
          };
          if (this.sidebarPerformanceCoordinator) {
            for (const [variable, value] of Object.entries(updates)) {
              this.sidebarPerformanceCoordinator.queueUpdate(variable, value);
            }
          } else {
            this.cssController.batchSetVariables(
              "UnifiedSidebarConsciousnessController",
              updates,
              "normal",
              // Normal priority for sidebar size updates
              "sidebar-size-fallback-update"
            );
          }
        }
        // NEW: Temporal echo system methods (from SidebarConsciousnessSystem)
        _spawnNavEcho(evt) {
          const state = this.consciousnessState;
          if (state.deviceCapabilities.reducedMotion || state.temporalEcho.currentEchoCount >= state.temporalEcho.maxEchoes) {
            return;
          }
          const target = evt.target;
          if (!target) return;
          const echoElement = this._acquireEchoElement();
          if (!echoElement) return;
          const rect = target.getBoundingClientRect();
          const parentRect = this.rootNavBar?.getBoundingClientRect();
          if (parentRect) {
            const x = rect.left - parentRect.left + rect.width / 2;
            const y = rect.top - parentRect.top + rect.height / 2;
            const noiseVector1 = sample(x * 0.01, Date.now() * 1e-3);
            const noiseVector2 = sample(y * 0.01, Date.now() * 1e-3 + 100);
            const noiseX = noiseVector1.x * 10;
            const noiseY = noiseVector2.y * 10;
            echoElement.style.left = `${x + noiseX}px`;
            echoElement.style.top = `${y + noiseY}px`;
          }
          const intensity = this.sidebarConfig.echoIntensity / 3;
          echoElement.style.opacity = intensity.toString();
          echoElement.classList.add("sn-echo-active");
          setTimeout(() => {
            this._releaseEchoElement(echoElement);
          }, 1500 + Math.random() * 1e3);
          state.temporalEcho.currentEchoCount++;
          state.temporalEcho.echoTimerCounter++;
        }
        _acquireEchoElement() {
          const state = this.consciousnessState;
          if (state.temporalEcho.echoPool.length > 0) {
            return state.temporalEcho.echoPool.pop() || null;
          }
          if (state.temporalEcho.currentEchoCount < state.temporalEcho.maxEchoes) {
            return this._createEchoElement();
          }
          return null;
        }
        _createEchoElement() {
          const echo = document.createElement("div");
          echo.className = "sn-temporal-echo";
          echo.style.cssText = `
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: radial-gradient(circle, var(--sn-harmonic-color, #a855f7) 0%, transparent 70%);
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: all 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      opacity: 0;
    `;
          if (this.overlayContainer) {
            this.overlayContainer.appendChild(echo);
          }
          const state = this.consciousnessState;
          state.temporalEcho.activeEchoElements.add(echo);
          return echo;
        }
        _releaseEchoElement(echo) {
          const state = this.consciousnessState;
          state.temporalEcho.activeEchoElements.delete(echo);
          echo.classList.remove("sn-echo-active");
          echo.style.opacity = "0";
          if (state.temporalEcho.echoPool.length < state.temporalEcho.maxEchoes) {
            state.temporalEcho.echoPool.push(echo);
          } else {
            echo.remove();
          }
          state.temporalEcho.currentEchoCount = Math.max(
            0,
            state.temporalEcho.currentEchoCount - 1
          );
        }
        // NEW: Harmonic mode management (from SidebarConsciousnessSystem)
        updateHarmonicModeDisplay() {
          const state = this.consciousnessState;
          const harmonicMode = state.harmonicMode;
          const modeConfig = HARMONIC_MODES2[harmonicMode.currentModeKey] || HARMONIC_MODES2["artist-vision"];
          harmonicMode.modeConfig = modeConfig;
          if (this.rootNavBar) {
            if (harmonicMode.currentModeClass) {
              this.rootNavBar.classList.remove(harmonicMode.currentModeClass);
            }
            const newModeClass = `sn-harmonic-${harmonicMode.currentModeKey}`;
            this.rootNavBar.classList.add(newModeClass);
            harmonicMode.currentModeClass = newModeClass;
          }
          this.updateColors();
          Y3KDebug?.debug?.log(
            "UnifiedSidebarConsciousnessController",
            `Harmonic mode updated to: ${harmonicMode.currentModeKey}`
          );
        }
        // Configuration API
        updateConfiguration(updates) {
          Object.assign(this.sidebarConfig, updates);
          if (updates.bilateralMode !== void 0) {
            if (updates.bilateralMode && !this.bilateralState) {
              this.initializeBilateralCoordination();
            } else if (!updates.bilateralMode && this.bilateralState) {
              this.bilateralState = null;
              this.consciousnessState.bilateralCoordination = false;
            }
          }
          if (updates.enableHarmonicModes !== void 0) {
            if (updates.enableHarmonicModes && this.overlayContainer) {
              this.updateHarmonicModeDisplay();
            }
          }
          if (updates.enableTemporalEcho !== void 0) {
            if (updates.enableTemporalEcho && this.rootNavBar && !this._navInteractionHandler) {
              this.setupInteractionHandling();
            }
          }
          Y3KDebug?.debug?.log(
            "UnifiedSidebarConsciousnessController",
            "Configuration updated:",
            updates
          );
        }
        getConfiguration() {
          return { ...this.sidebarConfig };
        }
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        // Legacy compatibility methods (for migration)
        getBilateralState() {
          return this.bilateralState;
        }
        async destroy() {
          Y3KDebug?.debug?.log(
            "UnifiedSidebarConsciousnessController",
            "Destroying enhanced unified consciousness controller..."
          );
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
          if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
          }
          if (this.rootNavBar && this._navInteractionHandler) {
            this.rootNavBar.removeEventListener("click", this._navInteractionHandler);
            this.rootNavBar.removeEventListener(
              "mouseover",
              this._navInteractionHandler
            );
            this._navInteractionHandler = null;
          }
          const state = this.consciousnessState;
          if (state.temporalEcho) {
            state.temporalEcho.activeEchoElements.forEach((echo) => {
              echo.remove();
            });
            state.temporalEcho.activeEchoElements.clear();
            for (const echo of state.temporalEcho.echoPool) {
              echo.remove();
            }
            state.temporalEcho.echoPool = [];
            state.temporalEcho.currentEchoCount = 0;
          }
          if (this.overlayContainer) {
            this.overlayContainer.remove();
            this.overlayContainer = null;
          }
          this.consciousnessVisualizer = null;
          this.harmonicModeIndicator = null;
          this.rootNavBar = null;
          for (const unsubscribe of this.eventUnsubscribeFunctions) {
            unsubscribe();
          }
          this.eventUnsubscribeFunctions = [];
          if (this.consciousnessChoreographer) {
          }
          this.bilateralState = null;
          this.initialized = false;
          Y3KDebug?.debug?.log(
            "UnifiedSidebarConsciousnessController",
            "Enhanced unified consciousness controller destroyed"
          );
        }
        //  COLOR CONSCIOUSNESS HELPER METHODS (NEW - Phase 3.5)
        updateSidebarColorsFromOKLAB(processedColors) {
          if (!this.sidebarPerformanceCoordinator) return;
          try {
            const accentColor = processedColors.VIBRANT || processedColors.PROMINENT || processedColors.DOMINANT;
            const secondaryColor = processedColors.LIGHT_VIBRANT || processedColors.LIGHT_MUTED || accentColor;
            const shadowColor = processedColors.DARK_VIBRANT || processedColors.DARK_MUTED || accentColor;
            if (accentColor) {
              this.sidebarPerformanceCoordinator.queueUpdate(
                "--sn-sidebar-accent-color",
                accentColor
              );
              this.sidebarPerformanceCoordinator.queueUpdate(
                "--sn-sidebar-dynamic-accent",
                accentColor
              );
              const accentRgb = this.hexToRgb(accentColor);
              if (accentRgb !== null) {
                this.sidebarPerformanceCoordinator.queueUpdate(
                  "--sn-sidebar-accent-rgb",
                  accentRgb
                );
                this.sidebarPerformanceCoordinator.queueUpdate(
                  "--sn-sidebar-entanglement-color-rgb",
                  accentRgb
                );
              }
            }
            if (secondaryColor) {
              this.sidebarPerformanceCoordinator.queueUpdate(
                "--sn-sidebar-secondary-color",
                secondaryColor
              );
              const secondaryRgb = this.hexToRgb(secondaryColor);
              if (secondaryRgb !== null) {
                this.sidebarPerformanceCoordinator.queueUpdate(
                  "--sn-sidebar-secondary-rgb",
                  secondaryRgb
                );
              }
            }
            if (shadowColor) {
              this.sidebarPerformanceCoordinator.queueUpdate(
                "--sn-sidebar-shadow-color",
                shadowColor
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to update sidebar colors from OKLAB:",
              error
            );
          }
        }
        updateSidebarAccentColor(dominantColor) {
          if (!this.sidebarPerformanceCoordinator) return;
          try {
            this.sidebarPerformanceCoordinator.queueUpdate(
              "--sn-sidebar-accent-color",
              dominantColor
            );
            this.sidebarPerformanceCoordinator.queueUpdate(
              "--sn-sidebar-dynamic-accent",
              dominantColor
            );
            const rgbValue = this.hexToRgb(dominantColor);
            if (rgbValue !== null) {
              this.sidebarPerformanceCoordinator.queueUpdate(
                "--sn-sidebar-accent-rgb",
                rgbValue
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to update sidebar accent color:",
              error
            );
          }
        }
        adjustConsciousnessForColorState(coordinationMetrics) {
          const { emotionalState, detectedGenre, oklabPreset } = coordinationMetrics;
          try {
            if (emotionalState) {
              switch (emotionalState) {
                case "energetic":
                case "aggressive":
                  this.consciousnessState.animation.intensity = Math.min(
                    1,
                    this.consciousnessState.animation.intensity * 1.3
                  );
                  break;
                case "calm":
                case "ambient":
                  this.consciousnessState.animation.intensity = Math.max(
                    0.2,
                    this.consciousnessState.animation.intensity * 0.7
                  );
                  break;
                case "mysterious":
                  this.consciousnessState.animation.intensity = Math.min(
                    0.8,
                    this.consciousnessState.animation.intensity * 1.1
                  );
                  break;
              }
            }
            if (detectedGenre) {
              switch (detectedGenre) {
                case "electronic":
                case "dance":
                  this.sidebarConfig.musicResponsiveness = Math.min(
                    1,
                    this.sidebarConfig.musicResponsiveness * 1.2
                  );
                  break;
                case "classical":
                case "ambient":
                  this.sidebarConfig.musicResponsiveness = Math.max(
                    0.3,
                    this.sidebarConfig.musicResponsiveness * 0.8
                  );
                  break;
              }
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to adjust consciousness for color state:",
              error
            );
          }
        }
        adjustMusicResponsivenessForColors(musicData) {
          try {
            if (musicData.tempo) {
              const tempoFactor = Math.max(0.5, Math.min(1.5, musicData.tempo / 120));
              this.sidebarConfig.musicResponsiveness = Math.min(
                1,
                this.sidebarConfig.musicResponsiveness * tempoFactor
              );
            }
            if (musicData.energy !== void 0) {
              const energyInfluence = musicData.energy * 0.3;
              this.consciousnessState.animation.intensity = Math.max(
                0.1,
                Math.min(
                  1,
                  this.consciousnessState.animation.intensity + energyInfluence
                )
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to adjust music responsiveness for colors:",
              error
            );
          }
        }
        updateSidebarTemperature(emotionalTemperature) {
          if (!this.sidebarPerformanceCoordinator || !emotionalTemperature) return;
          try {
            let hueShift = 0;
            if (emotionalTemperature < 3e3) {
              hueShift = 180 + (3e3 - emotionalTemperature) / 100;
            } else if (emotionalTemperature > 6e3) {
              hueShift = (emotionalTemperature - 6e3) / 100;
            } else {
              hueShift = (emotionalTemperature - 4500) / 50;
            }
            this.sidebarPerformanceCoordinator.queueUpdate(
              "--sn-sidebar-hue-shift",
              `${hueShift}deg`
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to update sidebar temperature:",
              error
            );
          }
        }
        hexToRgb(hex) {
          try {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (!result || result.length < 4) return null;
            const r = parseInt(result[1], 16);
            const g = parseInt(result[2], 16);
            const b = parseInt(result[3], 16);
            return `${r}, ${g}, ${b}`;
          } catch (error) {
            return null;
          }
        }
      };
      __name(_UnifiedSidebarConsciousnessController, "UnifiedSidebarConsciousnessController");
      UnifiedSidebarConsciousnessController = _UnifiedSidebarConsciousnessController;
    }
  });

  // src-js/visual/backbone/GradientConductor.ts
  var _BackendSelector, BackendSelector, _GradientConductor, GradientConductor;
  var init_GradientConductor = __esm({
    "src-js/visual/backbone/GradientConductor.ts"() {
      "use strict";
      init_UnifiedEventBus();
      _BackendSelector = class _BackendSelector {
        static selectOptimalBackend(registrations) {
          const sorted = registrations.filter((reg) => reg.backend.isReady && reg.backend.capabilities).sort((a, b) => b.priority - a.priority);
          for (const registration of sorted) {
            const caps = registration.capabilities;
            if (caps.webgl2 && caps.maxTextureSize >= 2048) {
              return registration.backend;
            }
            if (caps.webgl && caps.maxTextureSize >= 1024) {
              return registration.backend;
            }
            if (registration.backend.backendId === "css") {
              return registration.backend;
            }
          }
          return null;
        }
      };
      __name(_BackendSelector, "BackendSelector");
      BackendSelector = _BackendSelector;
      _GradientConductor = class _GradientConductor {
        // Removed: Dimensional Breathing State (breathing animations completely removed)
        constructor(eventBus, cssConsciousnessController, colorHarmonyEngine, musicSyncService, performanceAnalyzer2, config = {}) {
          this.initialized = false;
          this.registeredBackends = /* @__PURE__ */ new Map();
          this.activeBackend = null;
          this.rootElement = null;
          this.currentPalette = [];
          this.currentMusicMetrics = null;
          // Performance monitoring
          this.lastFrameTime = 0;
          this.frameCount = 0;
          this.performanceCheckInterval = null;
          this.eventBus = eventBus || unifiedEventBus;
          this.cssConsciousnessController = cssConsciousnessController;
          this.colorHarmonyEngine = colorHarmonyEngine;
          this.musicSyncService = musicSyncService;
          this.performanceAnalyzer = performanceAnalyzer2;
          this.config = {
            enabledBackends: ["webgl", "css"],
            defaultQuality: "high",
            transitionDuration: 500,
            performanceMonitoring: true,
            autoQualityScaling: true,
            ...config
          };
          this.currentConstraints = {
            targetFPS: 60,
            maxMemoryMB: 50,
            cpuBudgetPercent: 10,
            gpuBudgetPercent: 25,
            qualityLevel: this.config.defaultQuality
          };
        }
        /**
         * Initialize the GradientConductor and set up event listeners
         */
        async initialize() {
          try {
            this.setupEventListeners();
            this.setupCSSVariableUpdates();
            if (this.config.performanceMonitoring) {
              this.startPerformanceMonitoring();
            }
            this.updateGlobalStatus();
            this.initialized = true;
            console.log("[GradientConductor] Initialized successfully", {
              enabledBackends: this.config.enabledBackends,
              registeredBackends: Array.from(this.registeredBackends.keys())
            });
          } catch (error) {
            console.error("[GradientConductor] Initialization failed:", error);
            throw error;
          }
        }
        /**
         * Register a visual backend with the conductor
         */
        registerBackend(backend, priority = 0) {
          const registration = {
            backend,
            priority,
            capabilities: backend.capabilities,
            lastHealthCheck: /* @__PURE__ */ new Date(),
            isActive: false
          };
          this.registeredBackends.set(backend.backendId, registration);
          console.log(
            `[GradientConductor] Registered backend: ${backend.backendId}`,
            {
              priority,
              capabilities: backend.capabilities
            }
          );
          this.evaluateActiveBackend();
        }
        /**
         * Unregister a visual backend
         */
        unregisterBackend(backendId) {
          const registration = this.registeredBackends.get(backendId);
          if (registration) {
            registration.backend.setEnabled(false);
            this.registeredBackends.delete(backendId);
            if (this.activeBackend?.backendId === backendId) {
              this.activeBackend = null;
              this.evaluateActiveBackend();
            }
            console.log(`[GradientConductor] Unregistered backend: ${backendId}`);
          }
        }
        /**
         * Initialize all backends with the root element
         */
        async initializeBackends(rootElement) {
          this.rootElement = rootElement;
          const initPromises = Array.from(this.registeredBackends.values()).map(
            async (registration) => {
              try {
                await registration.backend.init(rootElement, this.currentConstraints);
                console.log(
                  `[GradientConductor] Backend ${registration.backend.backendId} initialized`
                );
              } catch (error) {
                console.error(
                  `[GradientConductor] Failed to initialize backend ${registration.backend.backendId}:`,
                  error
                );
              }
            }
          );
          await Promise.allSettled(initPromises);
          this.evaluateActiveBackend();
          if (this.activeBackend) {
            if (this.currentPalette.length > 0) {
              this.activeBackend.setPalette(this.currentPalette);
            }
            if (this.currentMusicMetrics) {
              this.activeBackend.setMusicMetrics(this.currentMusicMetrics);
            }
          }
        }
        /**
         * Update the color palette across all systems
         */
        setPalette(stops, transition = this.config.transitionDuration) {
          this.currentPalette = [...stops];
          this.updateCSSGradientVariables(stops);
          if (this.activeBackend) {
            this.activeBackend.setPalette(stops, transition);
          }
          this.updateGlobalStatus();
          console.log("[GradientConductor] Palette updated", {
            stops: stops.length,
            activeBackend: this.activeBackend?.backendId,
            transition
          });
        }
        /**
         * Update music synchronization metrics
         */
        setMusicMetrics(metrics) {
          this.currentMusicMetrics = metrics;
          this.updateCSSMusicVariables(metrics);
          if (this.activeBackend) {
            this.activeBackend.setMusicMetrics(metrics);
          }
          this.eventBus.emit("music:energy", {
            energy: metrics.energy,
            valence: metrics.valence,
            tempo: metrics.bpm,
            timestamp: Date.now()
          });
        }
        /**
         * Update performance constraints and trigger quality scaling
         */
        setPerformanceConstraints(constraints) {
          this.currentConstraints = { ...constraints };
          for (const registration of this.registeredBackends.values()) {
            registration.backend.setPerformanceConstraints(constraints);
          }
          if (constraints.qualityLevel !== this.currentConstraints.qualityLevel) {
            this.evaluateActiveBackend();
          }
          console.log(
            "[GradientConductor] Performance constraints updated",
            constraints
          );
        }
        /**
         * Get the currently active backend
         */
        getActiveBackend() {
          return this.activeBackend;
        }
        /**
         * Trigger music emotion analysis through ColorHarmonyEngine
         * This completes the Music  Emotion  Color  Visual flow
         */
        async triggerMusicEmotionAnalysis(audioFeatures, audioData) {
          try {
            if (this.colorHarmonyEngine && typeof this.colorHarmonyEngine.analyzeMusicEmotion === "function") {
              const emotion = await this.colorHarmonyEngine.analyzeMusicEmotion(audioFeatures, audioData);
              if (emotion && this.config.performanceMonitoring) {
                console.log(`[GradientConductor] Music emotion analysis triggered: ${emotion.primary} (${emotion.intensity.toFixed(2)} intensity)`);
              }
            } else {
              console.warn("[GradientConductor] ColorHarmonyEngine not available for music emotion analysis");
            }
          } catch (error) {
            console.error("[GradientConductor] Error triggering music emotion analysis:", error);
          }
        }
        /**
         * Get all registered backends
         */
        getRegisteredBackends() {
          return Array.from(this.registeredBackends.values());
        }
        /**
         * Force a specific backend to be active (for testing/debugging)
         */
        setActiveBackend(backendId) {
          const registration = this.registeredBackends.get(backendId);
          if (!registration || !registration.backend.isReady) {
            return false;
          }
          if (this.activeBackend) {
            this.activeBackend.setEnabled(false);
            const currentReg = this.registeredBackends.get(
              this.activeBackend.backendId
            );
            if (currentReg) currentReg.isActive = false;
          }
          this.activeBackend = registration.backend;
          registration.isActive = true;
          registration.backend.setEnabled(true, this.config.transitionDuration);
          this.updateGlobalStatus();
          console.log(`[GradientConductor] Forced backend switch to: ${backendId}`);
          return true;
        }
        /**
         * Perform health checks on all backends
         */
        async healthCheck() {
          const issues = [];
          for (const [backendId, registration] of this.registeredBackends) {
            try {
              const result = await registration.backend.healthCheck();
              registration.lastHealthCheck = /* @__PURE__ */ new Date();
              if (!result.ok) {
                issues.push(
                  `Backend ${backendId}: ${result.details || "Health check failed"}`
                );
              }
            } catch (error) {
              issues.push(`Backend ${backendId}: Health check error - ${error}`);
            }
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: issues.length > 0 ? `${issues.length} backend issues detected` : "All backends healthy",
            issues,
            system: "GradientConductor"
          };
        }
        /**
         * Animation update tick for performance monitoring
         */
        updateAnimation(deltaTime) {
          this.frameCount++;
          this.lastFrameTime = deltaTime;
          if (this.activeBackend) {
            this.activeBackend.updateAnimation(deltaTime);
          }
        }
        // Removed: updateDimensionalBreathing method (breathing animations completely removed)
        // Removed: applyDimensionalBreathingToCSS method (breathing animations completely removed)
        // Removed: onBeatDetected method (breathing animations completely removed)
        // Removed: onEnergyChanged method (breathing animations completely removed)
        /**
         * Clean up resources and event listeners
         */
        destroy() {
          if (this.performanceCheckInterval) {
            clearInterval(this.performanceCheckInterval);
            this.performanceCheckInterval = null;
          }
          for (const registration of this.registeredBackends.values()) {
            registration.backend.destroy();
          }
          this.registeredBackends.clear();
          this.activeBackend = null;
          this.initialized = false;
          console.log("[GradientConductor] Destroyed");
        }
        // ========================================================================
        // PRIVATE METHODS
        // ========================================================================
        setupEventListeners() {
          this.eventBus.subscribe("colors:harmonized", (data) => {
            if (data && data.processedColors) {
              const stops = Object.entries(data.processedColors).map(([key, value], index, arr) => {
                const color3 = value;
                let r = 128, g = 128, b = 128;
                if (color3.startsWith("#")) {
                  const hex = color3.slice(1);
                  r = parseInt(hex.slice(0, 2), 16);
                  g = parseInt(hex.slice(2, 4), 16);
                  b = parseInt(hex.slice(4, 6), 16);
                }
                return {
                  r,
                  g,
                  b,
                  position: index / (arr.length - 1)
                };
              });
              this.setPalette(stops);
            }
          }, "GradientConductor");
          this.eventBus.subscribe("music:energy", (data) => {
            const metrics = {
              energy: data.energy,
              valence: data.valence,
              bpm: data.tempo,
              beatIntensity: data.energy,
              rhythmPhase: 0,
              breathingScale: 1 + data.energy * 0.2
            };
            this.setMusicMetrics(metrics);
          }, "GradientConductor");
          this.eventBus.subscribe("music:beat", (data) => {
            const metrics = {
              energy: data.intensity,
              valence: 0.5,
              bpm: data.bpm,
              beatIntensity: data.intensity,
              rhythmPhase: Date.now() / 16.67 % 360,
              // Rough phase calculation
              breathingScale: 1 + data.intensity * 0.1
            };
            this.setMusicMetrics(metrics);
          }, "GradientConductor");
          this.eventBus.subscribe("performance:tier-changed", (data) => {
            const constraints = {
              targetFPS: 60,
              maxMemoryMB: 50,
              cpuBudgetPercent: 10,
              gpuBudgetPercent: 25,
              qualityLevel: data.tier === "excellent" ? "ultra" : data.tier === "good" ? "high" : data.tier === "degraded" ? "medium" : "low"
            };
            this.setPerformanceConstraints(constraints);
          }, "GradientConductor");
          this.eventBus.subscribe("settings:changed", (data) => {
            if (data.settingKey.includes("accessibility") || data.settingKey.includes("motion")) {
              const preferences = {
                reducedMotion: data.settingKey.includes("motion") && data.newValue === "reduce",
                highContrast: data.settingKey.includes("contrast") && data.newValue === "high",
                prefersTransparency: data.settingKey.includes("transparency") && data.newValue === "reduce"
              };
              for (const registration of this.registeredBackends.values()) {
                registration.backend.applyAccessibilityPreferences?.(preferences);
              }
            }
          }, "GradientConductor");
          this.eventBus.subscribe("emotion:analyzed", (emotionData) => {
            this.handleEmotionUpdate(emotionData);
          }, "GradientConductor");
          this.eventBus.subscribe("emotionalColorContext:updated", (context) => {
            this.handleEmotionalColorContext(context);
          }, "GradientConductor");
        }
        setupCSSVariableUpdates() {
          const criticalVariables = [
            "--sn.music.beat.pulse.intensity",
            "--sn.music.rhythm.phase",
            "--sn.music.breathing.scale",
            "--sn.bg.webgl.ready",
            "--sn.bg.active-backend",
            // Year 3000 consciousness variables (emotion-aware)
            "--sn-emotion-primary",
            "--sn-emotion-intensity",
            "--sn-color-temperature",
            "--sn-consciousness-level",
            "--sn-organic-flow",
            "--sn-cinematic-depth"
          ];
          criticalVariables.forEach((variable) => {
            this.cssConsciousnessController.addCriticalVariable(variable);
          });
        }
        /**
         * Handle emotion analysis updates from ColorHarmonyEngine
         * Part of the Year 3000 consciousness-aware flow
         */
        handleEmotionUpdate(emotionData) {
          try {
            const { emotion, colorTemperature, consciousnessLevel, organicFlow, cinematicDepth } = emotionData;
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-primary",
              emotion.primary || "neutral"
            );
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-intensity",
              (emotion.intensity || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-confidence",
              (emotion.confidence || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-color-temperature",
              (colorTemperature || 6500).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-consciousness-level",
              (consciousnessLevel || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-organic-flow",
              (organicFlow || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-cinematic-depth",
              (cinematicDepth || 0.5).toString()
            );
            for (const registration of this.registeredBackends.values()) {
              if (registration.backend.setEmotionalState) {
                registration.backend.setEmotionalState(emotion);
              }
            }
            console.log(`[GradientConductor] Emotion updated: ${emotion.primary} (intensity: ${emotion.intensity?.toFixed(2) || "N/A"})`);
          } catch (error) {
            console.error("[GradientConductor] Error handling emotion update:", error);
          }
        }
        /**
         * Handle emotional color context updates
         * Triggers consciousness-aware color processing across all backends
         */
        handleEmotionalColorContext(context) {
          try {
            const {
              primaryEmotion,
              emotionIntensity,
              colorTemperature,
              valence,
              arousal,
              dominance,
              organicFlow,
              cinematicDepth,
              consciousnessResonance
            } = context;
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-valence",
              (valence || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-arousal",
              (arousal || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-dominance",
              (dominance || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-consciousness-resonance",
              (consciousnessResonance || 0.5).toString()
            );
            for (const registration of this.registeredBackends.values()) {
              if (registration.backend.setEmotionalContext) {
                registration.backend.setEmotionalContext(context);
              }
            }
            console.log(`[GradientConductor] Emotional context updated: ${primaryEmotion} (temp: ${colorTemperature}K)`);
          } catch (error) {
            console.error("[GradientConductor] Error handling emotional color context:", error);
          }
        }
        updateCSSGradientVariables(stops) {
          if (stops.length === 0) return;
          const primary = stops[0];
          const secondary = stops[Math.floor(stops.length / 2)];
          const accent = stops[stops.length - 1];
          this.cssConsciousnessController.setProperty(
            "--sn.bg.gradient.primary.rgb",
            `${primary.r}, ${primary.g}, ${primary.b}`
          );
          this.cssConsciousnessController.setProperty(
            "--sn.bg.gradient.secondary.rgb",
            `${secondary.r}, ${secondary.g}, ${secondary.b}`
          );
          this.cssConsciousnessController.setProperty(
            "--sn.bg.gradient.accent.rgb",
            `${accent.r}, ${accent.g}, ${accent.b}`
          );
          this.cssConsciousnessController.setProperty(
            "--sn.color.accent.rgb",
            `${accent.r}, ${accent.g}, ${accent.b}`
          );
          this.cssConsciousnessController.setProperty(
            "--sn.color.accent.hex",
            `#${Math.round(accent.r).toString(16).padStart(2, "0")}${Math.round(
              accent.g
            ).toString(16).padStart(2, "0")}${Math.round(accent.b).toString(16).padStart(2, "0")}`
          );
        }
        updateCSSMusicVariables(metrics) {
          if (metrics.beatIntensity !== void 0) {
            this.cssConsciousnessController.setProperty(
              "--sn.music.beat.pulse.intensity",
              metrics.beatIntensity.toString()
            );
          }
          if (metrics.rhythmPhase !== void 0) {
            this.cssConsciousnessController.setProperty(
              "--sn.music.rhythm.phase",
              `${metrics.rhythmPhase}deg`
            );
          }
          if (metrics.breathingScale !== void 0) {
            this.cssConsciousnessController.setProperty(
              "--sn.music.breathing.scale",
              metrics.breathingScale.toString()
            );
          }
          this.cssConsciousnessController.setProperty(
            "--sn.music.energy.level",
            metrics.energy.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn.music.valence",
            metrics.valence.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn.music.tempo.bpm",
            metrics.bpm.toString()
          );
        }
        updateGlobalStatus() {
          this.cssConsciousnessController.setProperty(
            "--sn.bg.webgl.ready",
            this.registeredBackends.has("webgl") ? "1" : "0"
          );
          this.cssConsciousnessController.setProperty(
            "--sn.bg.active-backend",
            this.activeBackend?.backendId || "none"
          );
          if (typeof window !== "undefined") {
            window.snActiveBackend = this.activeBackend?.backendId || "none";
          }
        }
        evaluateActiveBackend() {
          const optimal = BackendSelector.selectOptimalBackend(
            Array.from(this.registeredBackends.values())
          );
          if (optimal && optimal !== this.activeBackend) {
            if (this.activeBackend) {
              this.activeBackend.setEnabled(false, this.config.transitionDuration);
              const currentReg = this.registeredBackends.get(
                this.activeBackend.backendId
              );
              if (currentReg) currentReg.isActive = false;
            }
            this.activeBackend = optimal;
            const newReg = this.registeredBackends.get(optimal.backendId);
            if (newReg) {
              newReg.isActive = true;
              optimal.setEnabled(true, this.config.transitionDuration);
            }
            this.updateGlobalStatus();
            console.log(
              `[GradientConductor] Switched to backend: ${optimal.backendId}`
            );
            this.eventBus.emit("system:initialized", {
              systemName: `GradientConductor-${optimal.backendId}`,
              timestamp: Date.now(),
              metadata: {
                previousBackend: this.activeBackend?.backendId,
                newBackend: optimal.backendId,
                capabilities: optimal.capabilities
              }
            });
          }
        }
        startPerformanceMonitoring() {
          this.performanceCheckInterval = window.setInterval(() => {
            if (!this.activeBackend) return;
            try {
              const metrics = this.activeBackend.getPerformanceMetrics();
              if (this.config.autoQualityScaling) {
                this.evaluateQualityScaling(metrics);
              }
              this.performanceAnalyzer.recordMetric(
                "gradientConductor.fps",
                metrics.fps
              );
              this.performanceAnalyzer.recordMetric(
                "gradientConductor.memory",
                metrics.memoryUsageMB
              );
            } catch (error) {
              console.warn(
                "[GradientConductor] Performance monitoring error:",
                error
              );
            }
          }, 2e3);
        }
        evaluateQualityScaling(metrics) {
          const constraints = this.currentConstraints;
          if (metrics.fps < constraints.targetFPS * 0.8 || metrics.memoryUsageMB > constraints.maxMemoryMB * 1.2) {
            let newQuality = constraints.qualityLevel;
            switch (constraints.qualityLevel) {
              case "ultra":
                newQuality = "high";
                break;
              case "high":
                newQuality = "medium";
                break;
              case "medium":
                newQuality = "low";
                break;
              case "low":
                this.evaluateActiveBackend();
                return;
            }
            console.log(
              `[GradientConductor] Auto-scaling quality: ${constraints.qualityLevel} \u2192 ${newQuality}`
            );
            this.setPerformanceConstraints({
              ...constraints,
              qualityLevel: newQuality
            });
          }
        }
      };
      __name(_GradientConductor, "GradientConductor");
      GradientConductor = _GradientConductor;
    }
  });

  // src-js/visual/music-sync/MusicSyncVisualEffects.ts
  var _OrganicBeatSyncConsciousness, OrganicBeatSyncConsciousness;
  var init_MusicSyncVisualEffects = __esm({
    "src-js/visual/music-sync/MusicSyncVisualEffects.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_Year3000Utilities();
      init_MusicalLerpOrchestrator();
      _OrganicBeatSyncConsciousness = class _OrganicBeatSyncConsciousness extends UnifiedSystemBase {
        constructor(config) {
          super(config);
          // =========================================================================
          // ORGANIC CONSCIOUSNESS STATE
          // =========================================================================
          // Core organic properties (current values)
          this.organicIntensity = 0;
          this.cellularGrowth = 1;
          this.breathingPhase = 0;
          this.emotionalTemperature = 4e3;
          // 1000K-20000K range
          this.membraneFluidityLevel = 0.5;
          // Target values for smooth LERP interpolation
          this.targetOrganicIntensity = 0;
          this.targetCellularGrowth = 1;
          this.targetEmotionalTemperature = 4e3;
          this.targetMembraneFluidityLevel = 0.5;
          // LERP smoothing half-life values (in seconds)
          this.lerpHalfLifeValues = {
            intensityAttack: 0.05,
            // Fast attack for beat response
            intensityDecay: 0.15,
            // Smooth decay
            cellularGrowth: 0.08,
            // Organic cellular response  
            emotionalTemperature: 0.3,
            // Gradual temperature shifts
            membraneFluidty: 0.12
            // Fluid membrane transitions
          };
          // Timing and rhythm
          this.lastBeatTime = 0;
          this.currentBPM = 120;
          this.breathingCycleDuration = 2e3;
          // 2 seconds default
          // Removed: Breathing integration (breathing animations completely removed)
          // Musical consciousness integration
          this.musicSyncService = null;
          this.currentMusicalContext = null;
          this.lastBeatPhaseUpdate = 0;
          // Performance metrics
          this.performanceMetrics = {
            organicUpdates: 0,
            cellularGrowthEvents: 0,
            breathingCycles: 0,
            emotionalShifts: 0,
            averageFrameTime: 0,
            memoryUsage: 0
          };
          // Organic consciousness configuration
          this.organicConfig = {
            cellularResponseSensitivity: 0.7,
            breathingRhythmIntensity: 0.8,
            emotionalTemperatureRange: { min: 1e3, max: 2e4 },
            membraneFluidityEnabled: true,
            atmosphericParticlesEnabled: true,
            cinematicEffectsEnabled: true
          };
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F30A} Organic consciousness awakening...");
          }
        }
        /**
         * Inject MusicSyncService for musical consciousness integration
         */
        setMusicSyncService(musicSyncService) {
          this.musicSyncService = musicSyncService;
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F3B5} Musical consciousness integration activated");
          }
        }
        // =========================================================================
        // UNIFIED SYSTEM LIFECYCLE
        // =========================================================================
        /**
         * Initialize organic consciousness system
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F9EC} Initializing organic consciousness...");
          }
          this.registerCSSVariableGroup("organic-core", "critical");
          this.registerCSSVariableGroup("cellular-growth", "high");
          this.registerCSSVariableGroup("emotional-temperature", "normal");
          this.registerCSSVariableGroup("membrane-fluidity", "normal");
          this.subscribeToEvent("music:beat", (payload) => this.onBeatConsciousness(payload));
          this.subscribeToEvent("music:energy", (payload) => this.onEnergyConsciousness(payload));
          this.subscribeToEvent("music:emotion", (payload) => this.onEmotionalConsciousness(payload));
          this.subscribeToEvent("music:bpm-change", (payload) => this.onTempoConsciousness(payload));
          this.registerAnimation(60);
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F31F} Organic consciousness fully awakened");
          }
        }
        /**
         * Clean up organic consciousness
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F343} Dissolving organic consciousness...");
          }
          this.organicIntensity = 0;
          this.cellularGrowth = 1;
          this.breathingPhase = 0;
          this.emotionalTemperature = 4e3;
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F30C} Organic consciousness peacefully dissolved");
          }
        }
        /**
         * Organic consciousness animation frame
         */
        onAnimate(deltaTime) {
          const startTime = performance.now();
          this.updateMusicalContext();
          this.updateOrganicConsciousness(deltaTime);
          this.processCellularGrowth(deltaTime);
          this.updateEmotionalTemperature(deltaTime);
          this.animateMembraneFluidty(deltaTime);
          this.applyOrganicCSSVariables();
          const frameTime = performance.now() - startTime;
          this.performanceMetrics.averageFrameTime = this.performanceMetrics.averageFrameTime * 0.9 + frameTime * 0.1;
          this.performanceMetrics.organicUpdates++;
          if (frameTime > 2 && this.config.enableDebug) {
            console.warn(`[OrganicBeatSyncConsciousness] \u{1F40C} Organic consciousness frame took ${frameTime.toFixed(2)}ms (target: <2ms)`);
          }
        }
        /**
         * Health check for organic consciousness
         */
        async healthCheck() {
          const issues = [];
          if (!this.eventBus) {
            issues.push("EventBus not connected for breathing coordination");
          }
          if (this.performanceMetrics.averageFrameTime > 2) {
            issues.push(`Average frame time ${this.performanceMetrics.averageFrameTime.toFixed(2)}ms exceeds 2ms target`);
          }
          if (this.organicIntensity === 0 && Date.now() - this.lastBeatTime > 1e4) {
            issues.push("No organic consciousness activity detected in last 10 seconds");
          }
          if (this.emotionalTemperature < 1e3 || this.emotionalTemperature > 2e4) {
            issues.push(`Emotional temperature ${this.emotionalTemperature}K outside 1000K-20000K range`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Organic consciousness health: ${issues.length === 0 ? "thriving" : "needs attention"}`,
            issues,
            system: "OrganicBeatSyncConsciousness"
          };
        }
        // =========================================================================
        // ORGANIC CONSCIOUSNESS BEHAVIORS
        // =========================================================================
        /**
         * Handle beat consciousness - organic response to music beats
         */
        onBeatConsciousness(payload) {
          const { intensity, bpm, energy, timestamp } = payload;
          this.lastBeatTime = timestamp || Date.now();
          this.currentBPM = bpm || this.currentBPM;
          this.targetOrganicIntensity = Math.min(1, intensity * this.organicConfig.cellularResponseSensitivity);
          this.targetCellularGrowth = 1 + (energy || 0.5) * 0.3;
          this.performanceMetrics.cellularGrowthEvents++;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F3B5} Beat consciousness: intensity=${intensity}, energy=${energy}, bpm=${bpm}`);
          }
        }
        /**
         * Handle energy consciousness - organic response to music energy
         */
        onEnergyConsciousness(payload) {
          const { energy, valence } = payload;
          this.targetCellularGrowth = 1 + energy * 0.3;
          this.targetMembraneFluidityLevel = 0.3 + valence * 0.4;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u26A1 Energy consciousness: energy=${energy}, valence=${valence}`);
          }
        }
        /**
         * Handle emotional consciousness - organic response to music emotion
         */
        onEmotionalConsciousness(payload) {
          const { valence, energy } = payload;
          const baseTemp = 4e3;
          const energyModulation = (energy - 0.5) * 8e3;
          const valenceModulation = (valence - 0.5) * 6e3;
          this.targetEmotionalTemperature = Math.max(1e3, Math.min(
            2e4,
            baseTemp + energyModulation + valenceModulation
          ));
          this.performanceMetrics.emotionalShifts++;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F308} Emotional consciousness: ${this.emotionalTemperature}K temperature`);
          }
        }
        /**
         * Handle tempo consciousness - organic response to BPM changes
         */
        onTempoConsciousness(payload) {
          const { bpm, tempo, enhancedBPM } = payload;
          this.currentBPM = enhancedBPM || bpm || tempo || 120;
          const bpmFactor = Math.max(0.3, Math.min(3, this.currentBPM / 120));
          this.breathingCycleDuration = 2e3 / bpmFactor;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F3B6} Tempo consciousness: ${this.currentBPM} BPM, ${this.breathingCycleDuration.toFixed(0)}ms breathing cycle`);
          }
        }
        // =========================================================================
        // REMOVED: BREATHING INTEGRATION METHODS
        // =========================================================================
        // =========================================================================
        // ANIMATION UPDATE METHODS
        // =========================================================================
        /**
         * Update organic consciousness state using framerate-independent LERP smoothing
         */
        updateOrganicConsciousness(deltaTime) {
          this.breathingPhase += deltaTime / this.breathingCycleDuration * 2 * Math.PI;
          if (this.breathingPhase > 2 * Math.PI) {
            this.breathingPhase -= 2 * Math.PI;
          }
          const deltaTimeSeconds = deltaTime / 1e3;
          const halfLife = this.targetOrganicIntensity > this.organicIntensity ? this.lerpHalfLifeValues.intensityAttack : this.lerpHalfLifeValues.intensityDecay;
          this.organicIntensity = lerpSmooth(
            this.organicIntensity,
            this.targetOrganicIntensity,
            deltaTimeSeconds,
            halfLife
          );
          const timeSinceLastBeat = Date.now() - this.lastBeatTime;
          if (timeSinceLastBeat > 2e3) {
            this.targetOrganicIntensity = lerpSmooth(
              this.targetOrganicIntensity,
              0,
              // Decay to zero
              deltaTimeSeconds,
              this.lerpHalfLifeValues.intensityDecay
            );
          }
        }
        /**
         * Process cellular growth using framerate-independent LERP smoothing
         */
        processCellularGrowth(deltaTime) {
          const deltaTimeSeconds = deltaTime / 1e3;
          this.cellularGrowth = lerpSmooth(
            this.cellularGrowth,
            this.targetCellularGrowth,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.cellularGrowth
          );
          this.targetCellularGrowth = lerpSmooth(
            this.targetCellularGrowth,
            1,
            // Baseline growth
            deltaTimeSeconds,
            this.lerpHalfLifeValues.cellularGrowth * 2
            // Slower decay
          );
        }
        /**
         * Update emotional temperature using framerate-independent LERP smoothing
         */
        updateEmotionalTemperature(deltaTime) {
          const deltaTimeSeconds = deltaTime / 1e3;
          this.emotionalTemperature = lerpSmooth(
            this.emotionalTemperature,
            this.targetEmotionalTemperature,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.emotionalTemperature
          );
          const neutral = 4e3;
          this.targetEmotionalTemperature = lerpSmooth(
            this.targetEmotionalTemperature,
            neutral,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.emotionalTemperature * 3
            // Slower neutral decay
          );
        }
        /**
         * Animate membrane fluidity using framerate-independent LERP smoothing
         */
        animateMembraneFluidty(deltaTime) {
          if (!this.organicConfig.membraneFluidityEnabled) return;
          const deltaTimeSeconds = deltaTime / 1e3;
          this.membraneFluidityLevel = lerpSmooth(
            this.membraneFluidityLevel,
            this.targetMembraneFluidityLevel,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.membraneFluidty
          );
        }
        /**
         * Apply organic CSS variables
         */
        applyOrganicCSSVariables() {
          this.updateCSSVariableGroup("organic-core", {
            "--organic-intensity": this.organicIntensity.toFixed(3),
            "--organic-bpm": this.currentBPM.toString(),
            "--organic-breathing-phase": this.breathingPhase.toFixed(4)
          });
          this.updateCSSVariableGroup("cellular-growth", {
            "--cellular-growth-scale": this.cellularGrowth.toFixed(3),
            "--cellular-response-sensitivity": this.organicConfig.cellularResponseSensitivity.toFixed(2)
          });
          this.updateCSSVariableGroup("emotional-temperature", {
            "--emotional-temperature": `${this.emotionalTemperature.toFixed(0)}K`,
            "--emotional-temperature-normalized": ((this.emotionalTemperature - 1e3) / 19e3).toFixed(3)
          });
          this.updateCSSVariableGroup("membrane-fluidity", {
            "--membrane-fluidity-level": this.membraneFluidityLevel.toFixed(3),
            "--membrane-fluidity-enabled": this.organicConfig.membraneFluidityEnabled ? "1" : "0"
          });
        }
        // =========================================================================
        // CLEANUP METHODS
        // =========================================================================
        // =========================================================================
        // PUBLIC API METHODS
        // =========================================================================
        /**
         * Get organic consciousness metrics
         */
        getOrganicMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Update organic consciousness configuration
         */
        updateOrganicConfig(config) {
          this.organicConfig = { ...this.organicConfig, ...config };
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F527} Organic configuration updated:", this.organicConfig);
          }
        }
        /**
         * Get current organic consciousness state
         */
        getOrganicState() {
          return {
            organicIntensity: this.organicIntensity,
            cellularGrowth: this.cellularGrowth,
            breathingPhase: this.breathingPhase,
            emotionalTemperature: this.emotionalTemperature,
            membraneFluidityLevel: this.membraneFluidityLevel,
            lastBeatTime: this.lastBeatTime,
            currentBPM: this.currentBPM
          };
        }
        /**
         * Force organic consciousness repaint
         */
        forceRepaint(reason) {
          super.forceRepaint(reason);
          this.organicIntensity = 0;
          this.cellularGrowth = 1;
          this.breathingPhase = 0;
          this.applyOrganicCSSVariables();
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F504} Organic consciousness repaint: ${reason}`);
          }
        }
        // =========================================================================
        // MUSICAL CONSCIOUSNESS INTEGRATION
        // =========================================================================
        /**
         * Update musical consciousness context for music-aware LERP calculations
         */
        updateMusicalContext() {
          if (!this.musicSyncService) {
            this.currentMusicalContext = null;
            return;
          }
          const now = Date.now();
          if (now - this.lastBeatPhaseUpdate < 16) {
            return;
          }
          this.lastBeatPhaseUpdate = now;
          this.currentMusicalContext = musicalLerpOrchestrator.createMusicalContext(
            this.musicSyncService,
            this.lastBeatTime
          );
          if (this.config.enableDebug && this.currentMusicalContext) {
            const ctx = this.currentMusicalContext;
            console.log(`[OrganicBeatSyncConsciousness] \u{1F3B5} Musical context: tempo=${ctx.tempo}, energy=${ctx.energy.toFixed(2)}, phase=${ctx.beatPhase}`);
          }
        }
      };
      __name(_OrganicBeatSyncConsciousness, "OrganicBeatSyncConsciousness");
      OrganicBeatSyncConsciousness = _OrganicBeatSyncConsciousness;
    }
  });

  // src-js/visual/music-sync/ui/HolographicUISystem.ts
  var _HolographicUISystem, HolographicUISystem;
  var init_HolographicUISystem = __esm({
    "src-js/visual/music-sync/ui/HolographicUISystem.ts"() {
      "use strict";
      init_MusicSyncService();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_OptimizedCSSVariableManager();
      init_GenreProfileManager();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      _HolographicUISystem = class _HolographicUISystem {
        constructor(manager, settingsManager2, musicSyncService) {
          this.holographicElements = /* @__PURE__ */ new Map();
          this.interfaceContainer = null;
          // Removed scanlineOverlay, chromaticCanvas and dataStreamCanvas - converted to CSS-only implementations
          this.isInitialized = false;
          this.isEnabled = true;
          // Performance metrics
          this.performanceMetrics = {
            elementsProcessed: 0,
            effectsApplied: 0,
            averageProcessingTime: 0,
            memoryUsage: 0,
            lastUpdate: 0
          };
          // Animation state
          this.animationState = {
            lastFrameTime: 0,
            flickerPhase: 0,
            scanlinePhase: 0,
            chromaticPhase: 0,
            dataStreamPhase: 0,
            interferencePhase: 0,
            organicPhase: 0,
            isAnimating: false
          };
          // Holographic presets
          this.holographicPresets = {
            "star-wars": {
              flickerIntensity: 0.4,
              transparency: 0.8,
              chromatic: 0.3,
              scanlineIntensity: 0.6,
              dataStreamFlow: 0.5,
              interferenceLevel: 0.2,
              energyStability: 0.7,
              projectionDistance: 0.8
            },
            "blade-runner": {
              flickerIntensity: 0.6,
              transparency: 0.7,
              chromatic: 0.5,
              scanlineIntensity: 0.8,
              dataStreamFlow: 0.8,
              interferenceLevel: 0.4,
              energyStability: 0.6,
              projectionDistance: 0.6
            },
            "organic-consciousness": {
              flickerIntensity: 0.3,
              transparency: 0.9,
              chromatic: 0.2,
              scanlineIntensity: 0.4,
              dataStreamFlow: 0.6,
              interferenceLevel: 0.3,
              energyStability: 0.8,
              projectionDistance: 0.9
            }
          };
          this.lastMusicalContext = null;
          this.eventSubscriptionIds = [];
          // User interaction tracking for content-aware effects
          this.lastScrollPosition = 0;
          this.lastMouseMovement = 0;
          this.lastUIClick = 0;
          // Required by IManagedSystem
          this.initialized = false;
          // Quality scaling properties
          this.currentQualityLevel = null;
          this.qualityCapabilities = [
            {
              name: "holographic-effects",
              enabled: true,
              qualityLevel: "medium"
            },
            { name: "scanline-overlay", enabled: true, qualityLevel: "low" },
            {
              name: "chromatic-aberration",
              enabled: true,
              qualityLevel: "low"
            },
            { name: "data-streams", enabled: true, qualityLevel: "medium" },
            {
              name: "interference-patterns",
              enabled: true,
              qualityLevel: "low"
            },
            {
              name: "organic-integration",
              enabled: true,
              qualityLevel: "high"
            }
          ];
          this.qualityAdjustments = {};
          this.manager = manager;
          this.settingsManager = settingsManager2 || new SettingsManager();
          this.musicSyncService = musicSyncService || new MusicSyncService();
          this.oklabProcessor = new OKLABColorProcessor(true);
          this.emotionalMapper = new EmotionalTemperatureMapper(true);
          this.genreManager = new GenreProfileManager();
          this.holographicPreset = OKLABColorProcessor.getPreset("COSMIC");
          this.holographicState = {
            flickerIntensity: 0.4,
            transparency: 0.8,
            chromatic: 0.3,
            scanlineIntensity: 0.6,
            dataStreamFlow: 0.5,
            interferenceLevel: 0.2,
            energyStability: 0.7,
            projectionDistance: 0.8
          };
          this.scanlineEffect = {
            frequency: 4,
            opacity: 0.1,
            animation: true,
            speed: 0.5,
            organic: false
          };
          this.chromaticAberration = {
            offsetX: 2,
            offsetY: 1,
            redChannel: 0.5,
            greenChannel: 0,
            blueChannel: -0.5,
            intensity: 0.3
          };
          this.dataStream = {
            characters: [
              "0",
              "1",
              "A",
              "B",
              "C",
              "D",
              "E",
              "F",
              "G",
              "H",
              "I",
              "J",
              "K",
              "L",
              "M",
              "N",
              "O",
              "P",
              "Q",
              "R",
              "S",
              "T",
              "U",
              "V",
              "W",
              "X",
              "Y",
              "Z"
            ],
            speed: 0.5,
            density: 0.3,
            organic: false,
            consciousness: true,
            musicalSync: true
          };
          this.interferencePattern = {
            frequency: 0.1,
            amplitude: 0.05,
            phase: 0,
            organic: false,
            type: "wave"
          };
        }
        // Initialize holographic UI system
        async initialize() {
          if (this.initialized) return;
          try {
            const year3000System2 = globalThis.year3000System;
            this.cssController = year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
            await this.createInterfaceContainer();
            await this.initializeHolographicElements();
            this.setupOKLABEventSubscriptions();
            this.setupUserInteractionTracking();
            this.startHolographicAnimation();
            this.initialized = true;
            this.isInitialized = true;
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Initialized holographic interface system with OKLAB integration"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to initialize:",
              error
            );
            throw error;
          }
        }
        // Update holographic effects from music
        async updateFromMusic(emotion, beat, palette) {
          if (!this.isInitialized || !this.isEnabled) return;
          const startTime = performance.now();
          try {
            this.updateHolographicState(emotion, beat);
            this.updateHolographicEffects(emotion, beat, palette);
            await this.updateElementAppearances();
            const processingTime = performance.now() - startTime;
            this.updatePerformanceMetrics(processingTime);
          } catch (error) {
            console.error("[HolographicUISystem] Error updating from music:", error);
          }
        }
        // Update holographic state from music
        updateHolographicState(emotion, beat) {
          const targetFlicker = 0.2 + emotion.intensity * 0.5 + beat.strength * 0.3;
          this.holographicState.flickerIntensity = this.smoothTransition(
            this.holographicState.flickerIntensity,
            targetFlicker,
            0.1
          );
          const targetTransparency = 0.6 + emotion.valence * 0.4;
          this.holographicState.transparency = this.smoothTransition(
            this.holographicState.transparency,
            targetTransparency,
            0.05
          );
          const targetChromatic = 0.1 + (emotion.arousal || 0.5) * 0.4;
          this.holographicState.chromatic = this.smoothTransition(
            this.holographicState.chromatic,
            targetChromatic,
            0.08
          );
          const targetScanlines = 0.3 + emotion.intensity * 0.5;
          this.holographicState.scanlineIntensity = this.smoothTransition(
            this.holographicState.scanlineIntensity,
            targetScanlines,
            0.06
          );
          const consciousnessState = this.manager.getConsciousnessState();
          const targetDataFlow = 0.3 + consciousnessState.symbioticResonance * 0.7;
          this.holographicState.dataStreamFlow = this.smoothTransition(
            this.holographicState.dataStreamFlow,
            targetDataFlow,
            0.04
          );
          const targetInterference = 0.1 + consciousnessState.membraneFluidityIndex * 0.3;
          this.holographicState.interferenceLevel = this.smoothTransition(
            this.holographicState.interferenceLevel,
            targetInterference,
            0.03
          );
          const targetStability = 1 - emotion.intensity * 0.4;
          this.holographicState.energyStability = this.smoothTransition(
            this.holographicState.energyStability,
            targetStability,
            0.02
          );
        }
        // Update holographic effects
        updateHolographicEffects(emotion, beat, palette) {
          this.scanlineEffect.frequency = 2 + this.holographicState.scanlineIntensity * 6;
          this.scanlineEffect.opacity = this.holographicState.scanlineIntensity * 0.15;
          this.scanlineEffect.speed = 0.3 + this.holographicState.dataStreamFlow * 0.7;
          this.scanlineEffect.organic = this.holographicState.energyStability > 0.7;
          this.chromaticAberration.intensity = this.holographicState.chromatic;
          this.chromaticAberration.offsetX = this.holographicState.chromatic * 3;
          this.chromaticAberration.offsetY = this.holographicState.chromatic * 2;
          this.dataStream.speed = 0.2 + this.holographicState.dataStreamFlow * 0.8;
          this.dataStream.density = 0.2 + this.holographicState.dataStreamFlow * 0.6;
          this.dataStream.organic = this.holographicState.energyStability > 0.6;
          this.interferencePattern.frequency = 0.05 + this.holographicState.interferenceLevel * 0.15;
          this.interferencePattern.amplitude = this.holographicState.interferenceLevel * 0.1;
          this.interferencePattern.organic = this.holographicState.energyStability > 0.5;
          if (emotion.type === "ambient") {
            this.interferencePattern.type = "organic";
          } else if (emotion.intensity > 0.7) {
            this.interferencePattern.type = "noise";
          } else {
            this.interferencePattern.type = "wave";
          }
        }
        // Update element appearances
        async updateElementAppearances() {
          const updatePromises = [];
          for (const [id, element] of this.holographicElements) {
            if (element.isActive) {
              updatePromises.push(this.updateElementAppearance(element));
            }
          }
          await Promise.allSettled(updatePromises);
        }
        // Update single element appearance
        async updateElementAppearance(holographicElement) {
          const {
            element,
            holographicType,
            intensity,
            consciousnessLevel,
            organicIntegration
          } = holographicElement;
          try {
            this.applyHolographicBase(element, intensity);
            switch (holographicType) {
              case "translucent_panel":
                this.applyTranslucentPanel(element, intensity);
                break;
              case "data_stream":
                this.applyDataStream(element, intensity);
                break;
              case "energy_barrier":
                this.applyEnergyBarrier(element, intensity);
                break;
              case "consciousness_interface":
                this.applyConsciousnessInterface(
                  element,
                  intensity,
                  consciousnessLevel
                );
                break;
              case "organic_hologram":
                this.applyOrganicHologram(element, intensity, organicIntegration);
                break;
              case "musical_visualization":
                this.applyMusicalVisualization(element, intensity);
                break;
              case "scanline_overlay":
                this.applyScanlineOverlay(element, intensity);
                break;
              case "chromatic_ghost":
                this.applyChromaticGhost(element, intensity);
                break;
            }
            if (consciousnessLevel > 0.5) {
              this.applyConsciousnessModifiers(element, consciousnessLevel);
            }
            if (organicIntegration) {
              this.applyOrganicModifiers(element, intensity);
            }
            holographicElement.lastUpdate = performance.now();
          } catch (error) {
            console.warn(
              `[HolographicUISystem] Failed to update element ${holographicElement.id}:`,
              error
            );
          }
        }
        // Apply holographic base effects
        applyHolographicBase(element, intensity) {
          const transparency = this.holographicState.transparency * intensity;
          const flicker = this.holographicState.flickerIntensity * intensity;
          const chromatic = this.holographicState.chromatic * intensity;
          element.style.opacity = transparency.toString();
          if (flicker > 0.3) {
            const flickerAmount = Math.sin(this.animationState.flickerPhase * 10) * flicker * 0.3;
            element.style.opacity = Math.max(
              0.1,
              transparency + flickerAmount
            ).toString();
          }
          if (chromatic > 0.2) {
            const chromaticOffset = chromatic * 2;
            element.style.filter = `
        drop-shadow(${chromaticOffset}px 0 0 rgba(255, 0, 0, 0.5))
        drop-shadow(-${chromaticOffset}px 0 0 rgba(0, 255, 255, 0.5))
      `;
          }
          const glowIntensity = intensity * 0.3;
          element.style.boxShadow = `
      0 0 ${glowIntensity * 20}px rgba(var(--spice-rgb-holographic-glow, var(--organic-holographic-rgb, 100, 255, 200)), ${glowIntensity}),
      inset 0 0 ${glowIntensity * 10}px rgba(var(--spice-rgb-holographic-accent, var(--organic-holographic-rgb, 100, 255, 200)), ${glowIntensity * 0.5})
    `;
        }
        // Apply translucent panel effect
        applyTranslucentPanel(element, intensity) {
          const transparency = this.holographicState.transparency * intensity;
          element.style.background = `
      rgba(var(--spice-rgb-holographic-primary, var(--organic-holographic-rgb, 100, 255, 200)), ${transparency * 0.1}),
      linear-gradient(45deg,
        transparent 0%,
        rgba(var(--spice-rgb-holographic-accent, var(--organic-holographic-rgb, 100, 255, 200)), ${transparency * 0.05}) 50%,
        transparent 100%)
    `;
          element.style.backdropFilter = `blur(${Math.min(intensity * 2, 3)}px)`;
          element.style.border = `1px solid rgba(var(--spice-rgb-holographic-glow, var(--organic-holographic-rgb, 100, 255, 200)), ${transparency * 0.6})`;
        }
        // Apply data stream effect
        applyDataStream(element, intensity) {
          const streamSpeed = this.dataStream.speed * intensity;
          const streamDensity = this.dataStream.density * intensity;
          const streamGradient = this.generateDataStreamGradient(
            streamSpeed,
            streamDensity
          );
          element.style.background = streamGradient;
          element.style.backgroundSize = "100% 20px";
          element.style.animation = `dataStream ${2 / streamSpeed}s linear infinite`;
          if (!document.getElementById("dataStreamAnimation")) {
            const style = document.createElement("style");
            style.id = "dataStreamAnimation";
            style.textContent = `
        @keyframes dataStream {
          0% { background-position: 0 0; }
          100% { background-position: 0 20px; }
        }
      `;
            document.head.appendChild(style);
          }
        }
        // Apply energy barrier effect
        applyEnergyBarrier(element, intensity) {
          const energyStability = this.holographicState.energyStability;
          const interference = this.holographicState.interferenceLevel * intensity;
          const shimmerIntensity = (1 - energyStability) * intensity;
          element.style.background = `
      linear-gradient(90deg,
        rgba(var(--organic-neon-glow-rgb, 0, 255, 255), ${shimmerIntensity * 0.3}) 0%,
        rgba(var(--organic-neon-glow-rgb, 0, 255, 255), ${shimmerIntensity * 0.1}) 50%,
        rgba(var(--organic-neon-glow-rgb, 0, 255, 255), ${shimmerIntensity * 0.3}) 100%)
    `;
          element.style.backgroundSize = "200% 100%";
          element.style.animation = `energyBarrier ${1 / shimmerIntensity}s ease-in-out infinite`;
          if (!document.getElementById("energyBarrierAnimation")) {
            const style = document.createElement("style");
            style.id = "energyBarrierAnimation";
            style.textContent = `
        @keyframes energyBarrier {
          0% { background-position: 0% 0%; }
          50% { background-position: 100% 0%; }
          100% { background-position: 0% 0%; }
        }
      `;
            document.head.appendChild(style);
          }
        }
        // Apply consciousness interface effect
        applyConsciousnessInterface(element, intensity, consciousnessLevel) {
          const consciousnessState = this.manager.getConsciousnessState();
          const resonance = consciousnessState.symbioticResonance * consciousnessLevel;
          const glowIntensity = resonance * intensity * 0.5;
          element.style.boxShadow = `
      0 0 ${glowIntensity * 30}px rgba(var(--organic-accent-rgb, 203, 166, 247), ${glowIntensity}),
      inset 0 0 ${glowIntensity * 15}px rgba(var(--organic-accent-rgb, 203, 166, 247), ${glowIntensity * 0.3})
    `;
          const consciousnessTransparency = 0.7 + resonance * 0.3;
          element.style.opacity = consciousnessTransparency.toString();
          if (resonance > 0.6) {
            const pulsePhase = this.animationState.organicPhase * 2;
            const pulseIntensity = 1 + Math.sin(pulsePhase) * resonance * 0.2;
            element.style.transform = `scale(${pulseIntensity})`;
          }
        }
        // Apply organic hologram effect
        applyOrganicHologram(element, intensity, organicIntegration) {
          if (!organicIntegration) return;
          const organicPhase = this.animationState.organicPhase;
          const organicIntensity = this.holographicState.energyStability * intensity;
          const morphX = Math.sin(organicPhase * 1.5) * organicIntensity * 2;
          const morphY = Math.cos(organicPhase * 2) * organicIntensity * 1.5;
          element.style.transform = `translate(${morphX}px, ${morphY}px)`;
          const colorPhase = organicPhase * 0.5;
          const hueShift = Math.sin(colorPhase) * organicIntensity * 30;
          element.style.filter = `hue-rotate(${hueShift}deg)`;
          const breathingPhase = organicPhase * 0.8;
          const breathingScale = 1 + Math.sin(breathingPhase) * organicIntensity * 0.05;
          element.style.transform += ` scale(${breathingScale})`;
        }
        // Apply musical visualization effect
        applyMusicalVisualization(element, intensity) {
          const consciousnessState = this.manager.getConsciousnessState();
          const musicalIntensity = consciousnessState.symbioticResonance * intensity;
          const visualPhase = this.animationState.dataStreamPhase * 3;
          const visualIntensity = musicalIntensity * 0.8;
          const barHeight = Math.sin(visualPhase) * visualIntensity * 20;
          element.style.background = `
      linear-gradient(0deg,
        rgba(var(--organic-primary-rgb, 205, 214, 244), ${visualIntensity * 0.8}) 0%,
        rgba(var(--organic-primary-rgb, 205, 214, 244), ${visualIntensity * 0.4}) ${50 + barHeight}%,
        transparent ${50 + barHeight}%)
    `;
          const pulseIntensity = 1 + Math.sin(visualPhase * 2) * musicalIntensity * 0.1;
          element.style.transform = `scaleY(${pulseIntensity})`;
        }
        // Apply scanline overlay effect
        applyScanlineOverlay(element, intensity) {
          const scanlineIntensity = this.holographicState.scanlineIntensity * intensity;
          const scanlineFrequency = this.scanlineEffect.frequency;
          element.style.background = `
      repeating-linear-gradient(
        0deg,
        transparent 0px,
        transparent ${scanlineFrequency - 1}px,
        rgba(var(--spice-rgb-holographic-accent, var(--organic-holographic-rgb, 100, 255, 200)), ${scanlineIntensity * 0.1}) ${scanlineFrequency}px,
        rgba(var(--spice-rgb-holographic-accent, var(--organic-holographic-rgb, 100, 255, 200)), ${scanlineIntensity * 0.1}) ${scanlineFrequency}px
      )
    `;
          if (this.scanlineEffect.animation) {
            element.style.animation = `scanlines ${1 / this.scanlineEffect.speed}s linear infinite`;
          }
          if (!document.getElementById("scanlineAnimation")) {
            const style = document.createElement("style");
            style.id = "scanlineAnimation";
            style.textContent = `
        @keyframes scanlines {
          0% { background-position: 0 0; }
          100% { background-position: 0 ${scanlineFrequency}px; }
        }
      `;
            document.head.appendChild(style);
          }
        }
        // Apply chromatic ghost effect
        applyChromaticGhost(element, intensity) {
          const chromaticIntensity = this.holographicState.chromatic * intensity;
          const redOffset = chromaticIntensity * 3;
          const greenOffset = chromaticIntensity * 1.5;
          const blueOffset = chromaticIntensity * 2;
          element.style.filter = `
      drop-shadow(${redOffset}px 0 0 rgba(255, 0, 0, 0.4))
      drop-shadow(-${greenOffset}px 0 0 rgba(0, 255, 0, 0.4))
      drop-shadow(0 ${blueOffset}px 0 rgba(0, 0, 255, 0.4))
    `;
          const chromaticPhase = this.animationState.chromaticPhase;
          const offsetAnimation = Math.sin(chromaticPhase * 5) * chromaticIntensity;
          element.style.transform = `translate(${offsetAnimation}px, 0)`;
        }
        // Apply consciousness modifiers
        applyConsciousnessModifiers(element, consciousnessLevel) {
          const consciousnessState = this.manager.getConsciousnessState();
          const resonance = consciousnessState.symbioticResonance * consciousnessLevel;
          const brightness = 1 + resonance * 0.3;
          element.style.filter = (element.style.filter || "") + ` brightness(${brightness})`;
          const saturation = 1 + resonance * 0.5;
          element.style.filter = (element.style.filter || "") + ` saturate(${saturation})`;
        }
        // Apply organic modifiers
        applyOrganicModifiers(element, intensity) {
          const organicPhase = this.animationState.organicPhase;
          const organicIntensity = this.holographicState.energyStability * intensity;
          const blurPhase = organicPhase * 1.2;
          const organicBlurAmount = Math.sin(blurPhase) * organicIntensity * 2;
          const currentFilter = element.style.filter || "";
          const hasExistingBlur = currentFilter.includes("blur(");
          if (!hasExistingBlur && organicBlurAmount > 0) {
            element.style.filter = currentFilter + ` blur(${Math.max(0, organicBlurAmount)}px)`;
          }
          const opacityPhase = organicPhase * 0.7;
          const opacityModifier = 1 + Math.sin(opacityPhase) * organicIntensity * 0.2;
          const currentOpacity = parseFloat(element.style.opacity) || 1;
          element.style.opacity = Math.max(
            0.1,
            Math.min(1, currentOpacity * opacityModifier)
          ).toString();
        }
        // Generate data stream gradient
        generateDataStreamGradient(speed, density) {
          const characters = this.dataStream.characters;
          const characterCount = Math.floor(density * 20);
          let gradient = "linear-gradient(90deg, ";
          for (let i = 0; i < characterCount; i++) {
            const position = i / characterCount * 100;
            const character = characters[Math.floor(Math.random() * characters.length)];
            const opacity = 0.1 + Math.random() * 0.3;
            const streamColor = this.getOKLABEnhancedDataStreamColor(
              opacity,
              this.lastMusicalContext
            );
            gradient += `${streamColor} ${position}%, `;
          }
          gradient = gradient.slice(0, -2) + ")";
          return gradient;
        }
        // Create interface container
        async createInterfaceContainer() {
          this.interfaceContainer = document.createElement("div");
          this.interfaceContainer.id = "holographic-interface-container";
          this.interfaceContainer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
      mix-blend-mode: normal;
    `;
          document.body.appendChild(this.interfaceContainer);
        }
        // Scanline overlay removed - effects now applied directly to elements via CSS classes
        // Canvas methods removed - effects now implemented via CSS-only approach for better text clarity
        // Initialize holographic elements
        async initializeHolographicElements() {
          const elementSelectors = [
            { selector: ".main-view-container", type: "translucent_panel" },
            { selector: ".Root__nav-bar", type: "data_stream" },
            { selector: ".Root__now-playing-bar", type: "consciousness_interface" },
            {
              selector: ".main-view-container__scroll-node",
              type: "organic_hologram"
            },
            { selector: ".root-now-playing-view", type: "energy_barrier" },
            {
              selector: ".main-view-container__scroll-node-child",
              type: "scanline_overlay"
            }
          ];
          for (const config of elementSelectors) {
            const elements = document.querySelectorAll(config.selector);
            for (const element of elements) {
              const holographicElement = {
                id: `holographic-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                element,
                originalStyles: getComputedStyle(element),
                holographicType: config.type,
                intensity: 0.7,
                isActive: true,
                lastUpdate: 0,
                animation: null,
                consciousnessLevel: 0.8,
                organicIntegration: true
              };
              this.holographicElements.set(holographicElement.id, holographicElement);
            }
          }
        }
        // Update holographic animation
        updateHolographicAnimation(deltaMs) {
          if (!this.isInitialized || !this.isEnabled) return;
          const deltaSeconds = deltaMs / 1e3;
          this.animationState.flickerPhase += deltaSeconds * 2;
          this.animationState.scanlinePhase += deltaSeconds * this.scanlineEffect.speed;
          this.animationState.chromaticPhase += deltaSeconds * 1.5;
          this.animationState.dataStreamPhase += deltaSeconds * this.dataStream.speed;
          this.animationState.interferencePhase += deltaSeconds * this.interferencePattern.frequency;
          this.animationState.organicPhase += deltaSeconds * 0.5;
          this.performanceMetrics.lastUpdate = performance.now();
        }
        // Scanline overlay update method removed - effects now applied via CSS classes to individual elements
        // Data stream canvas method removed - now implemented via CSS-only per-element effects
        // Start holographic animation
        startHolographicAnimation() {
          this.animationState.isAnimating = true;
          this.animationState.lastFrameTime = performance.now();
          const animate = /* @__PURE__ */ __name((currentTime) => {
            if (!this.animationState.isAnimating) return;
            const deltaTime = currentTime - this.animationState.lastFrameTime;
            this.animationState.lastFrameTime = currentTime;
            this.updateHolographicAnimation(deltaTime);
            requestAnimationFrame(animate);
          }, "animate");
          requestAnimationFrame(animate);
        }
        // Utility methods
        smoothTransition(current, target, speed) {
          return current + (target - current) * speed;
        }
        // Update performance metrics
        updatePerformanceMetrics(processingTime) {
          this.performanceMetrics.averageProcessingTime = this.performanceMetrics.averageProcessingTime * 0.9 + processingTime * 0.1;
          this.performanceMetrics.elementsProcessed = this.holographicElements.size;
          this.performanceMetrics.memoryUsage = this.holographicElements.size * 256;
        }
        // Public API methods
        getHolographicState() {
          return { ...this.holographicState };
        }
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        getElementCount() {
          return this.holographicElements.size;
        }
        setEnabled(enabled) {
          this.isEnabled = enabled;
          if (!enabled) {
            for (const [id, element] of this.holographicElements) {
              element.element.style.opacity = "1";
              element.element.style.filter = "";
              element.element.style.background = "";
              element.element.style.boxShadow = "";
              element.element.style.transform = "";
            }
          }
        }
        setHolographicPreset(presetName) {
          const preset = this.holographicPresets[presetName];
          if (preset) {
            this.holographicState = { ...preset };
          }
        }
        setFlickerIntensity(intensity) {
          this.holographicState.flickerIntensity = Math.max(
            0,
            Math.min(1, intensity)
          );
        }
        /**
         * Enable volumetric depth effects for 3D holographic consciousness
         */
        enableVolumetricDepth(depthLevel = 0.8) {
          const perspectiveDepth = 800 + depthLevel * 1200;
          if (this.interfaceContainer) {
            this.interfaceContainer.style.perspective = `${perspectiveDepth}px`;
            this.interfaceContainer.style.transformStyle = "preserve-3d";
          }
          for (const [id, holographicElement] of this.holographicElements) {
            this.applyVolumetricLayers(
              holographicElement.element,
              depthLevel,
              holographicElement.intensity
            );
          }
          console.log(
            `[HolographicUISystem] \u{1F30A} Volumetric depth enabled: ${perspectiveDepth}px perspective`
          );
        }
        /**
         * Update volumetric layers for 3D consciousness depth
         */
        updateVolumetricLayers(consciousnessLevel, emotionalTemperature) {
          const depthIntensity = consciousnessLevel * 0.8;
          const temperatureDepth = (emotionalTemperature - 4e3) / 4e3;
          for (const [id, holographicElement] of this.holographicElements) {
            this.applyVolumetricLayers(
              holographicElement.element,
              depthIntensity,
              holographicElement.intensity,
              temperatureDepth
            );
          }
        }
        /**
         * Apply volumetric 3D layers to holographic element
         */
        applyVolumetricLayers(element, depthLevel, intensity, temperatureDepth = 0.5) {
          const baseDepth = depthLevel * 100;
          const temperatureOffset = temperatureDepth * 50;
          const finalDepth = baseDepth + temperatureOffset;
          const currentTransform = element.style.transform || "";
          const volumetricTransform = `translateZ(${finalDepth}px)`;
          if (currentTransform.includes("translateZ")) {
            element.style.transform = currentTransform.replace(
              /translateZ\([^)]*\)/,
              volumetricTransform
            );
          } else {
            element.style.transform = `${currentTransform} ${volumetricTransform}`.trim();
          }
          const shadowIntensity = Math.abs(finalDepth) / 100 * intensity;
          const shadowBlur = shadowIntensity * 30;
          const shadowOffset = finalDepth > 0 ? shadowIntensity * 5 : -shadowIntensity * 3;
          const existingShadow = element.style.boxShadow || "";
          const volumetricShadow = `0 ${shadowOffset}px ${shadowBlur}px rgba(var(--spice-rgb-holographic-glow, var(--organic-holographic-rgb, 100, 255, 200)), ${shadowIntensity * 0.3})`;
          if (existingShadow) {
            element.style.boxShadow = `${existingShadow}, ${volumetricShadow}`;
          } else {
            element.style.boxShadow = volumetricShadow;
          }
          this.applyVolumetricAtmosphere(element, depthLevel, intensity);
        }
        /**
         * Apply volumetric atmosphere effects for depth perception
         */
        applyVolumetricAtmosphere(element, depthLevel, intensity) {
          const atmosphereIntensity = depthLevel * intensity;
          const blurAmount = Math.max(0, (depthLevel - 0.5) * 4);
          const brightnessAdjust = 1 + (depthLevel - 0.5) * 0.3;
          const currentFilter = element.style.filter || "";
          const hasExistingBlur = currentFilter.includes("blur(");
          const atmosphericFilters = [
            // Only add blur if no existing blur effect
            blurAmount > 0 && !hasExistingBlur ? `blur(${blurAmount}px)` : "",
            `brightness(${brightnessAdjust})`,
            `saturate(${1 + atmosphereIntensity * 0.2})`
          ].filter((f) => f).join(" ");
          const hasBrightness = currentFilter.includes("brightness");
          const hasSaturate = currentFilter.includes("saturate");
          if (currentFilter && !hasBrightness && !hasSaturate) {
            element.style.filter = `${currentFilter} ${atmosphericFilters}`;
          } else if (!currentFilter) {
            element.style.filter = atmosphericFilters;
          }
          const baseOpacity = parseFloat(element.style.opacity || "1");
          const atmosphericOpacity = Math.max(
            0.3,
            baseOpacity - (1 - depthLevel) * 0.3
          );
          element.style.opacity = atmosphericOpacity.toString();
        }
        /**
         * Consciousness data stream functionality converted to CSS-only implementation
         * Data is now integrated into element-native effects for better text clarity
         */
        // Canvas-based consciousness data stream methods removed - now handled via CSS-only implementations
        /**
         * Organic consciousness atmospheric effects system
         * Phase 4.2c: Advanced Atmospheric Enhancement - flowing, seamless, organic
         * Now updates CSS variables for element-native consciousness effects
         */
        updateConsciousnessScanlines(consciousnessLevel, emotionalTemperature, musicalIntensity) {
          const consciousnessDensity = Math.max(0.2, consciousnessLevel * 1.5);
          const temperatureFrequency = this.mapTemperatureToFrequency(emotionalTemperature);
          const musicalPulse = Math.sin(performance.now() * 5e-3 * musicalIntensity) * 0.3 + 0.7;
          const consciousnessScanlineVariables = {
            "--consciousness-scanline-density": consciousnessDensity.toString(),
            "--consciousness-scanline-frequency": `${temperatureFrequency}px`,
            "--consciousness-scanline-opacity": (consciousnessLevel * 0.15).toString(),
            "--musical-scanline-pulse": musicalPulse.toString(),
            "--temperature-scanline-color-shift": `${(emotionalTemperature - 5e3) / 3e3 * 30}deg`
          };
          this.cssController.batchSetVariables(
            "HolographicUISystem",
            consciousnessScanlineVariables,
            "high",
            // High priority for consciousness scanline effects
            "consciousness-scanline-update"
          );
        }
        /**
         * Update enhanced aberration system CSS variables based on consciousness and musical data
         * Phase 4.2g: Enhanced CSS-Only Aberration Integration
         */
        updateAberrationEffects(consciousnessLevel, emotionalTemperature, musicalIntensity, beatDetected = false) {
          const root = document.documentElement;
          const baseIntensity = Math.min(1, consciousnessLevel * 1.2);
          const musicalSync = Math.min(1, musicalIntensity * 1.5);
          const colorSeparation = 2 + musicalSync * 3;
          const tempNormalized = Math.max(3e3, Math.min(8e3, emotionalTemperature));
          const tempRatio = (tempNormalized - 5500) / 2500;
          const redShift = 1.5 + tempRatio * 2;
          const blueShift = -1.5 - tempRatio * 2;
          const greenShift = tempRatio * 0.5;
          const musicalPulse = Math.sin(performance.now() * 3e-3 * musicalIntensity) * 0.4 + 0.6;
          const beatBoost = beatDetected ? 1.5 : 1;
          const waveFrequency = 1e3 + consciousnessLevel * 2e3 + musicalIntensity * 1e3;
          const aberrationEffectVariables = {
            "--aberration-intensity": (baseIntensity * beatBoost).toString(),
            "--aberration-color-separation": `${colorSeparation}px`,
            "--aberration-musical-sync": musicalSync.toString(),
            "--aberration-emotional-temperature": `${emotionalTemperature}K`,
            "--aberration-consciousness-level": consciousnessLevel.toString(),
            "--aberration-red-shift": `${redShift}px`,
            "--aberration-green-shift": `${greenShift}px`,
            "--aberration-blue-shift": `${blueShift}px`,
            "--aberration-wave-frequency": `${waveFrequency}ms`,
            "--aberration-pulse-intensity": (musicalPulse * beatBoost).toString()
          };
          this.cssController.batchSetVariables(
            "HolographicUISystem",
            aberrationEffectVariables,
            "high",
            // High priority for aberration effects - affects visual perception
            "aberration-effects-update"
          );
          const readingModeActive = parseFloat(
            root.style.getPropertyValue("--reading-mode-active") || "0"
          );
          const readingModeReduction = Math.min(0.8, readingModeActive * 0.6);
          this.cssController.setVariable(
            "HolographicUISystem",
            "--aberration-reading-mode-reduction",
            readingModeReduction.toString(),
            "critical",
            // Critical priority for reading mode accessibility
            "aberration-reading-mode-update"
          );
        }
        /**
         * Map emotional temperature to scanline frequency
         */
        mapTemperatureToFrequency(temperature) {
          const normalizedTemp = Math.max(3e3, Math.min(8e3, temperature));
          const tempRatio = (normalizedTemp - 3e3) / 5e3;
          return 2 + tempRatio * 10;
        }
        // applySophisticatedScanlines method removed - converted to CSS-only implementation
        /**
         * Update CSS variables for scanline system integration
         */
        updateScanlineCSSVariables(consciousnessLevel, emotionalTemperature, musicalIntensity) {
          const scanlineCoreVariables = {
            "--consciousness-scanline-density": consciousnessLevel.toString(),
            "--consciousness-scanline-frequency": `${this.scanlineEffect.frequency}px`,
            "--consciousness-scanline-opacity": this.scanlineEffect.opacity.toString(),
            "--consciousness-scanline-speed": `${this.scanlineEffect.speed}s`,
            "--temperature-scanline-color-shift": `${(emotionalTemperature - 5e3) / 2e3 * 30}deg`,
            "--musical-scanline-pulse": musicalIntensity.toString()
          };
          this.cssController.batchSetVariables(
            "HolographicUISystem",
            scanlineCoreVariables,
            "high",
            // High priority for scanline consciousness effects
            "scanline-consciousness-update"
          );
          const advancedScanlineVariables = {
            "--consciousness-scanline-interference": consciousnessLevel > 0.7 ? "visible" : "none",
            "--consciousness-scanline-complexity": consciousnessLevel > 0.7 ? Math.min(1, (consciousnessLevel - 0.7) * 3.33).toString() : "0"
          };
          this.cssController.batchSetVariables(
            "HolographicUISystem",
            advancedScanlineVariables,
            "high",
            // High priority for advanced consciousness scanline effects
            "scanline-complexity-update"
          );
        }
        /**
         * Detect reading mode based on user activity and content area
         * Updates CSS variables for reading-mode-aware holographic effects
         */
        detectReadingMode() {
          const root = document.documentElement;
          const isTextSelected = (window.getSelection()?.toString() || "").length > 0;
          const isUserScrolling = this.isUserCurrentlyScrolling();
          const isHoveringTextContent = this.isHoveringTextContent();
          let readingModeActive = 0;
          if (isTextSelected) readingModeActive += 0.6;
          if (isUserScrolling) readingModeActive += 0.3;
          if (isHoveringTextContent) readingModeActive += 0.4;
          readingModeActive = Math.min(1, readingModeActive);
          this.cssController.setVariable(
            "HolographicUISystem",
            "--reading-mode-active",
            readingModeActive.toString(),
            "critical",
            // Critical priority for reading mode - affects accessibility
            "reading-mode-detection-update"
          );
        }
        /**
         * Track user interaction patterns for content-aware holographic effects
         */
        trackUserInteraction() {
          const root = document.documentElement;
          const isMouseMoving = this.isMouseCurrentlyMoving();
          const isClickingUI = this.wasRecentUIClick();
          const isFocusedOnInput = this.isFocusedOnInputElement();
          let interactionIntensity = 0;
          if (isMouseMoving) interactionIntensity += 0.4;
          if (isClickingUI) interactionIntensity += 0.5;
          if (isFocusedOnInput) interactionIntensity += 0.6;
          interactionIntensity = Math.min(1, interactionIntensity);
          this.cssController.setVariable(
            "HolographicUISystem",
            "--user-interaction-detected",
            interactionIntensity.toString(),
            "high",
            // High priority for user interaction detection - affects responsiveness
            "user-interaction-update"
          );
        }
        /**
         * Check if user is currently scrolling (used for reading mode detection)
         */
        isUserCurrentlyScrolling() {
          const scrollContainer = document.querySelector(
            ".main-view-container__scroll-node"
          );
          if (!scrollContainer) return false;
          const currentScrollTop = scrollContainer.scrollTop;
          const lastScrollTop = this.lastScrollPosition || 0;
          this.lastScrollPosition = currentScrollTop;
          return Math.abs(currentScrollTop - lastScrollTop) > 5;
        }
        /**
         * Check if user is hovering over text content
         */
        isHoveringTextContent() {
          const hoveredElement = document.querySelector(":hover");
          if (!hoveredElement) return false;
          const textContent = hoveredElement.textContent?.trim() || "";
          return textContent.length > 20;
        }
        /**
         * Check if mouse is currently moving
         */
        isMouseCurrentlyMoving() {
          const now = performance.now();
          const lastMovement = this.lastMouseMovement || 0;
          return now - lastMovement < 2e3;
        }
        /**
         * Check if there was a recent UI click
         */
        wasRecentUIClick() {
          const now = performance.now();
          const lastClick = this.lastUIClick || 0;
          return now - lastClick < 1e3;
        }
        /**
         * Check if user is focused on an input element
         */
        isFocusedOnInputElement() {
          const activeElement = document.activeElement;
          if (!activeElement) return false;
          const inputElements = ["input", "textarea", "select"];
          return inputElements.includes(activeElement.tagName.toLowerCase()) || activeElement.getAttribute("contenteditable") === "true";
        }
        setTransparency(transparency) {
          this.holographicState.transparency = Math.max(0, Math.min(1, transparency));
        }
        setChromaticAberration(chromatic) {
          this.holographicState.chromatic = Math.max(0, Math.min(1, chromatic));
        }
        // Cleanup
        destroy() {
          console.log("[HolographicUISystem] Destroying holographic UI system...");
          this.animationState.isAnimating = false;
          for (const [id, element] of this.holographicElements) {
            element.element.style.opacity = "1";
            element.element.style.filter = "";
            element.element.style.background = "";
            element.element.style.boxShadow = "";
            element.element.style.transform = "";
            if (element.animation) {
              element.animation.cancel();
            }
          }
          this.holographicElements.clear();
          if (this.interfaceContainer && this.interfaceContainer.parentNode) {
            this.interfaceContainer.parentNode.removeChild(this.interfaceContainer);
          }
          const animations = [
            "dataStreamAnimation",
            "energyBarrierAnimation",
            "scanlineAnimation"
          ];
          animations.forEach((animationId) => {
            const style = document.getElementById(animationId);
            if (style) {
              style.remove();
            }
          });
          this.isInitialized = false;
          this.initialized = false;
          this.eventSubscriptionIds.forEach((id) => {
            unifiedEventBus.unsubscribe(id);
          });
          this.eventSubscriptionIds = [];
        }
        // ========================================================================
        // QUALITY SCALING INTERFACE IMPLEMENTATION
        // ========================================================================
        /**
         * Set quality level for holographic effects
         */
        setQualityLevel(level) {
          this.currentQualityLevel = level;
          switch (level) {
            case "low":
              this.holographicState.flickerIntensity = 0.1;
              this.holographicState.transparency = 0.9;
              this.holographicState.chromatic = 0.1;
              this.holographicState.scanlineIntensity = 0.2;
              this.holographicState.dataStreamFlow = 0.2;
              this.holographicState.interferenceLevel = 0;
              this.scanlineEffect.animation = false;
              break;
            case "low":
              this.holographicState.flickerIntensity = 0.2;
              this.holographicState.transparency = 0.85;
              this.holographicState.chromatic = 0.2;
              this.holographicState.scanlineIntensity = 0.3;
              this.holographicState.dataStreamFlow = 0.3;
              this.holographicState.interferenceLevel = 0.1;
              this.scanlineEffect.animation = true;
              this.scanlineEffect.speed = 0.3;
              break;
            case "medium":
              this.holographicState.flickerIntensity = 0.4;
              this.holographicState.transparency = 0.8;
              this.holographicState.chromatic = 0.3;
              this.holographicState.scanlineIntensity = 0.6;
              this.holographicState.dataStreamFlow = 0.5;
              this.holographicState.interferenceLevel = 0.2;
              this.scanlineEffect.animation = true;
              this.scanlineEffect.speed = 0.5;
              break;
            case "high":
              this.holographicState.flickerIntensity = 0.6;
              this.holographicState.transparency = 0.7;
              this.holographicState.chromatic = 0.5;
              this.holographicState.scanlineIntensity = 0.8;
              this.holographicState.dataStreamFlow = 0.8;
              this.holographicState.interferenceLevel = 0.4;
              this.scanlineEffect.animation = true;
              this.scanlineEffect.speed = 0.8;
              break;
            case "high":
              this.holographicState.flickerIntensity = 0.8;
              this.holographicState.transparency = 0.6;
              this.holographicState.chromatic = 0.7;
              this.holographicState.scanlineIntensity = 1;
              this.holographicState.dataStreamFlow = 1;
              this.holographicState.interferenceLevel = 0.6;
              this.scanlineEffect.animation = true;
              this.scanlineEffect.speed = 1;
              break;
          }
          this.updateQualityCapabilities(level);
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const activeElements = this.holographicElements.size;
          const averageProcessingTime = this.calculateProcessingTime();
          return {
            fps: 60,
            // Holographic effects typically maintain 60fps
            frameTime: averageProcessingTime,
            memoryUsage: this.estimateMemoryUsage(),
            cpuUsage: this.estimateCPUUsage(activeElements)
          };
        }
        /**
         * Reduce quality by specified amount
         */
        reduceQuality(amount) {
          this.qualityAdjustments["flicker-reduction"] = (this.qualityAdjustments["flicker-reduction"] || 0) + amount;
          this.qualityAdjustments["effect-reduction"] = (this.qualityAdjustments["effect-reduction"] || 0) + amount * 0.8;
          this.holographicState.flickerIntensity = Math.max(
            0.1,
            this.holographicState.flickerIntensity * (1 - amount * 0.8)
          );
          this.holographicState.chromatic = Math.max(
            0,
            this.holographicState.chromatic * (1 - amount)
          );
          this.holographicState.scanlineIntensity = Math.max(
            0.1,
            this.holographicState.scanlineIntensity * (1 - amount * 0.6)
          );
          this.holographicState.dataStreamFlow = Math.max(
            0.1,
            this.holographicState.dataStreamFlow * (1 - amount * 0.4)
          );
          this.holographicState.interferenceLevel = Math.max(
            0,
            this.holographicState.interferenceLevel * (1 - amount)
          );
          if (amount > 0.5) {
            this.scanlineEffect.animation = false;
          }
        }
        /**
         * Increase quality by specified amount
         */
        increaseQuality(amount) {
          Object.keys(this.qualityAdjustments).forEach((key) => {
            this.qualityAdjustments[key] = Math.max(
              0,
              (this.qualityAdjustments[key] || 0) - amount
            );
          });
          if (this.currentQualityLevel) {
            const preset = this.getPresetForLevel(this.currentQualityLevel);
            this.holographicState.flickerIntensity = Math.min(
              preset.flickerIntensity,
              this.holographicState.flickerIntensity * (1 + amount * 0.3)
            );
            this.holographicState.chromatic = Math.min(
              preset.chromatic,
              this.holographicState.chromatic * (1 + amount * 0.4)
            );
            this.holographicState.scanlineIntensity = Math.min(
              preset.scanlineIntensity,
              this.holographicState.scanlineIntensity * (1 + amount * 0.2)
            );
            this.holographicState.dataStreamFlow = Math.min(
              preset.dataStreamFlow,
              this.holographicState.dataStreamFlow * (1 + amount * 0.2)
            );
            if (amount > 0.3) {
              this.scanlineEffect.animation = true;
            }
          }
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          return [...this.qualityCapabilities];
        }
        // ========================================================================
        // QUALITY SCALING HELPER METHODS
        // ========================================================================
        updateQualityCapabilities(level) {
          this.qualityCapabilities.forEach((capability) => {
            switch (capability.name) {
              case "holographic-effects":
                capability.enabled = this.holographicState.flickerIntensity > 0.2;
                break;
              case "scanline-overlay":
                capability.enabled = this.holographicState.scanlineIntensity > 0.3;
                break;
              case "chromatic-aberration":
                capability.enabled = this.holographicState.chromatic > 0.2;
                break;
              case "data-streams":
                capability.enabled = this.holographicState.dataStreamFlow > 0.3;
                break;
              case "interference-patterns":
                capability.enabled = this.holographicState.interferenceLevel > 0.1;
                break;
              case "organic-integration":
                capability.enabled = level !== "low";
                break;
            }
          });
        }
        getPresetForLevel(level) {
          switch (level) {
            case "low":
              return this.holographicPresets["organic-consciousness"];
            case "medium":
              return this.holographicPresets["star-wars"];
            case "high":
              return this.holographicPresets["blade-runner"];
            default:
              return this.holographicPresets["star-wars"];
          }
        }
        calculateProcessingTime() {
          const activeElements = this.holographicElements.size;
          const complexityFactor = (this.holographicState.flickerIntensity + this.holographicState.chromatic + this.holographicState.scanlineIntensity) / 3;
          return Math.max(2, activeElements * complexityFactor * 0.5);
        }
        estimateMemoryUsage() {
          const activeElements = this.holographicElements.size;
          const baseMemoryPerElement = 0.3;
          const canvasMemory = 0;
          return baseMemoryPerElement * activeElements + canvasMemory;
        }
        estimateCPUUsage(activeElements) {
          const baseUsage = 2;
          const complexityFactor = (this.holographicState.flickerIntensity + this.holographicState.chromatic + this.holographicState.scanlineIntensity) / 3;
          const animationMultiplier = this.scanlineEffect.animation ? 1.5 : 1;
          return Math.min(
            30,
            baseUsage * activeElements * complexityFactor * animationMultiplier
          );
        }
        /**
         * Convert hex color to RGB string for CSS variables
         */
        hexToRgb(hex) {
          try {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (result && result[1] && result[2] && result[3]) {
              return `${parseInt(result[1], 16)}, ${parseInt(
                result[2],
                16
              )}, ${parseInt(result[3], 16)}`;
            }
            return "100, 255, 200";
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "HolographicUISystem",
              "Failed to convert hex to RGB:",
              error
            );
            return "100, 255, 200";
          }
        }
        /**
         * Setup OKLAB event subscriptions for holographic consciousness
         */
        setupOKLABEventSubscriptions() {
          try {
            const oklabColorId = unifiedEventBus.subscribe(
              "colors:oklab-enhanced",
              this.handleOKLABColorEvent.bind(this),
              "HolographicUISystem"
            );
            this.eventSubscriptionIds.push(oklabColorId);
            const musicalOklabId = unifiedEventBus.subscribe(
              "colors:musical-oklab-coordinated",
              this.handleMusicalOKLABEvent.bind(this),
              "HolographicUISystem"
            );
            this.eventSubscriptionIds.push(musicalOklabId);
            const emotionalTempId = unifiedEventBus.subscribe(
              "colors:emotional-temperature-mapped",
              this.handleEmotionalTemperatureEvent.bind(this),
              "HolographicUISystem"
            );
            this.eventSubscriptionIds.push(emotionalTempId);
            const genreDetectedId = unifiedEventBus.subscribe(
              "audio:genre-detected",
              this.handleGenreDetectionEvent.bind(this),
              "HolographicUISystem"
            );
            this.eventSubscriptionIds.push(genreDetectedId);
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "OKLAB event subscriptions established",
              {
                subscriptionCount: this.eventSubscriptionIds.length
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to setup OKLAB event subscriptions:",
              error
            );
          }
        }
        /**
         * Setup user interaction tracking for content-aware holographic effects
         */
        setupUserInteractionTracking() {
          try {
            document.addEventListener(
              "mousemove",
              () => {
                this.lastMouseMovement = performance.now();
              },
              { passive: true }
            );
            document.addEventListener(
              "click",
              () => {
                this.lastUIClick = performance.now();
              },
              { passive: true }
            );
            setInterval(() => {
              this.detectReadingMode();
              this.trackUserInteraction();
            }, 500);
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "User interaction tracking initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to setup user interaction tracking:",
              error
            );
          }
        }
        /**
         * Handle unified OKLAB color events
         */
        async handleOKLABColorEvent(data) {
          try {
            const { enhancedColors, oklabPreset, rawColors, trackUri } = data;
            if (oklabPreset) {
              this.holographicPreset = oklabPreset;
            }
            if (enhancedColors) {
              await this.updateHolographicColorsFromOKLAB(enhancedColors);
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Updated holographic colors from OKLAB event",
              {
                preset: oklabPreset?.name,
                trackUri,
                colorCount: Object.keys(enhancedColors || {}).length
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to handle OKLAB color event:",
              error
            );
          }
        }
        /**
         * Handle musical OKLAB coordination events
         */
        async handleMusicalOKLABEvent(data) {
          try {
            const {
              coordinatedColors,
              detectedGenre,
              emotionalResult,
              oklabPreset,
              musicInfluenceStrength,
              coordinationStrategy
            } = data;
            this.lastMusicalContext = {
              genre: detectedGenre,
              emotion: emotionalResult?.primaryEmotion,
              preset: oklabPreset,
              influence: musicInfluenceStrength,
              strategy: coordinationStrategy,
              timestamp: Date.now()
            };
            if (oklabPreset) {
              this.holographicPreset = oklabPreset;
            }
            if (coordinatedColors) {
              await this.updateHolographicColorsFromMusicalOKLAB(
                coordinatedColors,
                this.lastMusicalContext
              );
            }
            if (emotionalResult && musicInfluenceStrength !== void 0) {
              const consciousnessLevel = this.holographicState.flickerIntensity || 0.5;
              const emotionalTemperature = emotionalResult.emotionalTemperature || 6e3;
              const musicalIntensity = musicInfluenceStrength;
              const beatDetected = emotionalResult.beatDetected || false;
              this.updateAberrationEffects(
                consciousnessLevel,
                emotionalTemperature,
                musicalIntensity,
                beatDetected
              );
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Updated holographic effects from musical OKLAB coordination",
              {
                genre: detectedGenre,
                emotion: emotionalResult?.primaryEmotion,
                preset: oklabPreset?.name,
                influence: musicInfluenceStrength
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to handle musical OKLAB event:",
              error
            );
          }
        }
        /**
         * Handle emotional temperature mapping events
         */
        async handleEmotionalTemperatureEvent(data) {
          try {
            const {
              emotionalTemperature,
              primaryEmotion,
              perceptualColorHex,
              oklabPreset,
              cssVariables
            } = data;
            await this.updateHolographicEmotionalTemperature(
              emotionalTemperature,
              primaryEmotion
            );
            if (perceptualColorHex) {
              await this.updateHolographicColorFromEmotionalOKLAB(
                perceptualColorHex,
                emotionalTemperature
              );
            }
            const consciousnessLevel = this.holographicState.flickerIntensity || 0.5;
            const musicalIntensity = this.lastMusicalContext?.influence || 0.5;
            this.updateAberrationEffects(
              consciousnessLevel,
              emotionalTemperature,
              musicalIntensity,
              false
            );
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Updated holographic emotional temperature",
              {
                temperature: emotionalTemperature,
                emotion: primaryEmotion,
                color: perceptualColorHex
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to handle emotional temperature event:",
              error
            );
          }
        }
        /**
         * Handle genre detection events for preset adjustment
         */
        async handleGenreDetectionEvent(data) {
          try {
            const { detectedGenre, confidence, audioFeatures } = data;
            const genrePreset = this.genreManager.getOKLABPresetForGenre(detectedGenre);
            if (genrePreset) {
              this.holographicPreset = genrePreset;
              await this.adjustHolographicEffectsForGenre(
                detectedGenre,
                audioFeatures
              );
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Adjusted holographic effects for detected genre",
              {
                genre: detectedGenre,
                confidence,
                preset: genrePreset?.name
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to handle genre detection event:",
              error
            );
          }
        }
        /**
         * Update holographic colors from OKLAB-enhanced colors
         */
        async updateHolographicColorsFromOKLAB(enhancedColors) {
          try {
            const holographicColorVariables = {};
            Object.entries(enhancedColors).forEach(([key, hexColor]) => {
              if (hexColor && typeof hexColor === "string") {
                const oklabResult = this.oklabProcessor.processColor(
                  hexColor,
                  this.holographicPreset
                );
                if (oklabResult.enhancedHex) {
                  holographicColorVariables[`--holographic-${key.toLowerCase()}`] = oklabResult.enhancedHex;
                  holographicColorVariables[`--holographic-${key.toLowerCase()}-rgb`] = this.hexToRgb(oklabResult.enhancedHex);
                  if (oklabResult.oklabEnhanced) {
                    const { L, a, b } = oklabResult.oklabEnhanced;
                    holographicColorVariables[`--holographic-${key.toLowerCase()}-oklab`] = `${L.toFixed(3)} ${a.toFixed(3)} ${b.toFixed(3)}`;
                  }
                }
              }
            });
            if (enhancedColors["VIBRANT"] || enhancedColors["PRIMARY"]) {
              const primaryColor = enhancedColors["VIBRANT"] || enhancedColors["PRIMARY"];
              if (primaryColor) {
                const oklabResult = this.oklabProcessor.processColor(
                  primaryColor,
                  this.holographicPreset
                );
                if (oklabResult.enhancedHex) {
                  holographicColorVariables["--organic-holographic-rgb"] = this.hexToRgb(oklabResult.enhancedHex);
                  holographicColorVariables["--sn-holographic-primary"] = oklabResult.enhancedHex;
                }
              }
            }
            if (Object.keys(holographicColorVariables).length > 0) {
              this.cssController.batchSetVariables(
                "HolographicUISystem",
                holographicColorVariables,
                "critical",
                // Critical priority for holographic color updates - affects visual perception
                "oklab-holographic-colors-update"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to update holographic colors from OKLAB:",
              error
            );
          }
        }
        /**
         * Update holographic colors from musical OKLAB coordination
         */
        async updateHolographicColorsFromMusicalOKLAB(coordinatedColors, musicalContext) {
          try {
            await this.updateHolographicColorsFromOKLAB(coordinatedColors);
            if (musicalContext.influence) {
              this.adjustHolographicIntensityFromMusicalInfluence(
                musicalContext.influence
              );
            }
            if (musicalContext.genre) {
              await this.applyGenreSpecificHolographicEffects(
                musicalContext.genre,
                musicalContext.emotion
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to update holographic colors from musical OKLAB:",
              error
            );
          }
        }
        /**
         * Update holographic color from emotional OKLAB mapping
         */
        async updateHolographicColorFromEmotionalOKLAB(perceptualColorHex, emotionalTemperature) {
          try {
            const root = document.documentElement;
            const oklabResult = this.oklabProcessor.processColor(
              perceptualColorHex,
              this.holographicPreset
            );
            if (oklabResult.enhancedHex) {
              const emotionalHolographicVariables = {
                "--holographic-emotional-primary": oklabResult.enhancedHex,
                "--holographic-emotional-rgb": this.hexToRgb(oklabResult.enhancedHex),
                "--holographic-emotional-temperature": `${emotionalTemperature}K`
              };
              this.cssController.batchSetVariables(
                "HolographicUISystem",
                emotionalHolographicVariables,
                "critical",
                // Critical priority for emotional holographic colors - affects consciousness perception
                "emotional-oklab-holographic-update"
              );
              await this.updateHolographicEmotionalTemperature(
                emotionalTemperature,
                null
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to update holographic color from emotional OKLAB:",
              error
            );
          }
        }
        /**
         * Update holographic emotional temperature responsiveness
         */
        async updateHolographicEmotionalTemperature(temperature, emotion) {
          try {
            const temperatureNormalized = Math.max(3e3, Math.min(8e3, temperature));
            const tempRatio = (temperatureNormalized - 3e3) / 5e3;
            this.holographicState.flickerIntensity = 0.2 + tempRatio * 0.4;
            this.holographicState.chromatic = 0.1 + tempRatio * 0.3;
            this.holographicState.energyStability = 1 - tempRatio * 0.3;
            if (tempRatio < 0.4) {
              this.holographicState.transparency = 0.9 + tempRatio * 0.1;
              this.holographicState.dataStreamFlow = 0.3 + tempRatio * 0.2;
            } else {
              this.holographicState.transparency = 0.8 - (tempRatio - 0.4) * 0.2;
              this.holographicState.interferenceLevel = 0.1 + (tempRatio - 0.4) * 0.3;
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Updated holographic effects from emotional temperature",
              {
                temperature,
                tempRatio,
                flicker: this.holographicState.flickerIntensity,
                chromatic: this.holographicState.chromatic
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to update holographic emotional temperature:",
              error
            );
          }
        }
        /**
         * Adjust holographic effects for detected genre
         */
        async adjustHolographicEffectsForGenre(genre, audioFeatures) {
          try {
            switch (genre.toLowerCase()) {
              case "electronic":
              case "techno":
              case "edm":
                this.holographicState.dataStreamFlow = 0.8;
                this.holographicState.scanlineIntensity = 0.7;
                this.holographicState.interferenceLevel = 0.4;
                this.scanlineEffect.speed = 0.8;
                break;
              case "classical":
              case "orchestral":
                this.holographicState.transparency = 0.9;
                this.holographicState.energyStability = 0.8;
                this.holographicState.flickerIntensity = 0.2;
                this.scanlineEffect.organic = true;
                break;
              case "rock":
              case "metal":
                this.holographicState.flickerIntensity = 0.6;
                this.holographicState.chromatic = 0.5;
                this.holographicState.interferenceLevel = 0.5;
                this.scanlineEffect.animation = true;
                break;
              case "ambient":
              case "atmospheric":
                this.holographicState.transparency = 0.95;
                this.holographicState.dataStreamFlow = 0.3;
                this.holographicState.energyStability = 0.9;
                this.scanlineEffect.organic = true;
                this.scanlineEffect.speed = 0.2;
                break;
              case "jazz":
              case "blues":
                this.holographicState.flickerIntensity = 0.4;
                this.holographicState.energyStability = 0.6;
                this.interferencePattern.type = "organic";
                this.scanlineEffect.organic = true;
                break;
              default:
                this.holographicState.flickerIntensity = 0.4;
                this.holographicState.transparency = 0.8;
                this.holographicState.chromatic = 0.3;
                break;
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Adjusted holographic effects for genre",
              {
                genre,
                flicker: this.holographicState.flickerIntensity,
                transparency: this.holographicState.transparency,
                dataFlow: this.holographicState.dataStreamFlow
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to adjust holographic effects for genre:",
              error
            );
          }
        }
        /**
         * Adjust holographic intensity from musical influence strength
         */
        adjustHolographicIntensityFromMusicalInfluence(influenceStrength) {
          try {
            const influenceMultiplier = 0.5 + influenceStrength * 0.5;
            this.holographicState.flickerIntensity *= influenceMultiplier;
            this.holographicState.chromatic *= influenceMultiplier;
            this.holographicState.scanlineIntensity *= influenceMultiplier;
            this.holographicState.dataStreamFlow *= influenceMultiplier;
            this.holographicState.interferenceLevel *= influenceMultiplier;
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Adjusted holographic intensity from musical influence",
              {
                influence: influenceStrength,
                multiplier: influenceMultiplier
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to adjust holographic intensity from musical influence:",
              error
            );
          }
        }
        /**
         * Apply genre-specific holographic effects
         */
        async applyGenreSpecificHolographicEffects(genre, emotion) {
          try {
            const effectKey = `${genre.toLowerCase()}-${emotion || "neutral"}`;
            if (genre === "electronic" && emotion === "energetic") {
              this.setHolographicPreset("blade-runner");
              this.holographicState.dataStreamFlow = 1;
              this.holographicState.interferenceLevel = 0.6;
            } else if (genre === "classical" && emotion === "calm") {
              this.setHolographicPreset("organic-consciousness");
              this.holographicState.transparency = 0.95;
              this.holographicState.energyStability = 0.9;
            } else if (genre === "rock" && emotion === "aggressive") {
              this.setHolographicPreset("star-wars");
              this.holographicState.flickerIntensity = 0.8;
              this.holographicState.chromatic = 0.6;
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Applied genre-specific holographic effects",
              {
                genre,
                emotion,
                effectKey
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to apply genre-specific holographic effects:",
              error
            );
          }
        }
        /**
         * Update animation with delta time (IManagedSystem interface)
         */
        updateAnimation(deltaTime) {
          this.updateHolographicAnimation(deltaTime);
        }
        /**
         * Health check for holographic system (IManagedSystem interface)
         */
        async healthCheck() {
          try {
            const memoryUsage = this.estimateMemoryUsage();
            const cpuUsage = this.estimateCPUUsage(this.holographicElements.size);
            const activeElements = this.holographicElements.size;
            const isHealthy = this.initialized && memoryUsage < 10 && // Less than 10MB
            cpuUsage < 25 && // Less than 25% CPU
            activeElements < 100;
            return {
              healthy: isHealthy,
              message: isHealthy ? "Holographic UI system operating normally" : "Holographic UI system performance degraded",
              details: {
                initialized: this.initialized,
                activeElements,
                memoryUsageMB: memoryUsage,
                cpuUsagePercent: cpuUsage,
                oklabIntegration: this.eventSubscriptionIds.length > 0,
                lastUpdate: this.performanceMetrics.lastUpdate
              }
            };
          } catch (error) {
            return {
              healthy: false,
              message: `Holographic UI system health check failed: ${error}`,
              details: {
                error: error instanceof Error ? error.message : String(error)
              }
            };
          }
        }
        // ========================================================================
        // OKLAB COLOR HELPER METHODS
        // ========================================================================
        /**
         * Get OKLAB-enhanced glow color for holographic effects
         */
        getOKLABEnhancedGlowColor(intensity) {
          try {
            const currentColor = getComputedStyle(document.documentElement).getPropertyValue("--sn-holographic-primary")?.trim() || "#64ffcc";
            const oklabResult = this.oklabProcessor.processColor(
              currentColor,
              this.holographicPreset
            );
            if (oklabResult.enhancedHex) {
              const rgb = this.hexToRgb(oklabResult.enhancedHex);
              return `rgba(${rgb}, ${intensity})`;
            }
            return `rgba(var(--spice-rgb-holographic-glow, var(--organic-holographic-rgb, 100, 255, 200)), ${intensity})`;
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "HolographicUISystem",
              "Failed to get OKLAB enhanced glow color:",
              error
            );
            return `rgba(var(--spice-rgb-holographic-glow, var(--organic-holographic-rgb, 100, 255, 200)), ${intensity})`;
          }
        }
        /**
         * Get OKLAB-enhanced panel colors for translucent effects
         */
        getOKLABEnhancedPanelColor(transparency) {
          try {
            const currentColor = getComputedStyle(document.documentElement).getPropertyValue("--sn-holographic-primary")?.trim() || "#64ffcc";
            const oklabResult = this.oklabProcessor.processColor(
              currentColor,
              this.holographicPreset
            );
            if (oklabResult.enhancedHex) {
              const rgb = this.hexToRgb(oklabResult.enhancedHex);
              return {
                background: `rgba(${rgb}, ${transparency * 0.1})`,
                gradient: `rgba(${rgb}, ${transparency * 0.05})`,
                border: `rgba(${rgb}, ${transparency * 0.6})`
              };
            }
            return {
              background: `rgba(var(--spice-rgb-holographic-primary, var(--organic-holographic-rgb, 100, 255, 200)), ${transparency * 0.1})`,
              gradient: `rgba(var(--spice-rgb-holographic-accent, var(--organic-holographic-rgb, 100, 255, 200)), ${transparency * 0.05})`,
              border: `rgba(var(--spice-rgb-holographic-glow, var(--organic-holographic-rgb, 100, 255, 200)), ${transparency * 0.6})`
            };
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "HolographicUISystem",
              "Failed to get OKLAB enhanced panel color:",
              error
            );
            return {
              background: `rgba(var(--spice-rgb-holographic-primary, var(--organic-holographic-rgb, 100, 255, 200)), ${transparency * 0.1})`,
              gradient: `rgba(var(--spice-rgb-holographic-accent, var(--organic-holographic-rgb, 100, 255, 200)), ${transparency * 0.05})`,
              border: `rgba(var(--spice-rgb-holographic-glow, var(--organic-holographic-rgb, 100, 255, 200)), ${transparency * 0.6})`
            };
          }
        }
        /**
         * Get OKLAB consciousness-responsive glow colors
         */
        getOKLABConsciousnessGlow(intensity, resonance) {
          try {
            const accentColor = getComputedStyle(document.documentElement).getPropertyValue("--sn-accent-hex")?.trim() || "#cba6f7";
            const consciousnessPreset = {
              ...this.holographicPreset,
              chromaBoost: this.holographicPreset.chromaBoost * (1 + resonance * 0.5),
              lightnessBoost: this.holographicPreset.lightnessBoost * (1 + resonance * 0.3)
            };
            const oklabResult = this.oklabProcessor.processColor(
              accentColor,
              consciousnessPreset
            );
            if (oklabResult.enhancedHex) {
              const rgb = this.hexToRgb(oklabResult.enhancedHex);
              return {
                outer: `rgba(${rgb}, ${intensity})`,
                inner: `rgba(${rgb}, ${intensity * 0.3})`
              };
            }
            return {
              outer: `rgba(var(--organic-accent-rgb, 203, 166, 247), ${intensity})`,
              inner: `rgba(var(--organic-accent-rgb, 203, 166, 247), ${intensity * 0.3})`
            };
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "HolographicUISystem",
              "Failed to get OKLAB consciousness glow:",
              error
            );
            return {
              outer: `rgba(var(--organic-accent-rgb, 203, 166, 247), ${intensity})`,
              inner: `rgba(var(--organic-accent-rgb, 203, 166, 247), ${intensity * 0.3})`
            };
          }
        }
        /**
         * Get OKLAB-enhanced color for data streams with musical responsiveness
         */
        getOKLABEnhancedDataStreamColor(intensity, musicalContext) {
          try {
            let baseColor = "#64ffcc";
            if (musicalContext?.emotion) {
              const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature({
                energy: 0.5,
                valence: 0.5,
                tempo: 120,
                genre: musicalContext.genre || "default"
              });
              if (emotionalResult.perceptualColorHex) {
                baseColor = emotionalResult.perceptualColorHex;
              }
            }
            const oklabResult = this.oklabProcessor.processColor(
              baseColor,
              this.holographicPreset
            );
            if (oklabResult.enhancedHex) {
              const rgb = this.hexToRgb(oklabResult.enhancedHex);
              return `rgba(${rgb}, ${intensity})`;
            }
            return `rgba(var(--spice-rgb-holographic-primary, var(--organic-holographic-rgb, 100, 255, 200)), ${intensity})`;
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "HolographicUISystem",
              "Failed to get OKLAB enhanced data stream color:",
              error
            );
            return `rgba(var(--spice-rgb-holographic-primary, var(--organic-holographic-rgb, 100, 255, 200)), ${intensity})`;
          }
        }
        /**
         * Adjust quality level for performance optimization (QualityScalingCapable interface)
         */
        adjustQuality(level) {
          switch (level) {
            case "low":
              this.holographicState.energyStability = 0.3;
              this.holographicState.scanlineIntensity = 0.2;
              this.holographicState.interferenceLevel = 0.1;
              break;
            case "medium":
              this.holographicState.energyStability = 0.6;
              this.holographicState.scanlineIntensity = 0.5;
              this.holographicState.interferenceLevel = 0.3;
              break;
            case "high":
            default:
              this.holographicState.energyStability = 1;
              this.holographicState.scanlineIntensity = 0.8;
              this.holographicState.interferenceLevel = 0.6;
              break;
          }
        }
      };
      __name(_HolographicUISystem, "HolographicUISystem");
      HolographicUISystem = _HolographicUISystem;
    }
  });

  // src-js/visual/ui-effects/InteractionTrackingSystem.ts
  var _InteractionTrackingSystem, InteractionTrackingSystem;
  var init_InteractionTrackingSystem = __esm({
    "src-js/visual/ui-effects/InteractionTrackingSystem.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_BaseVisualSystem();
      init_OptimizedCSSVariableManager();
      _InteractionTrackingSystem = class _InteractionTrackingSystem extends BaseVisualSystem {
        constructor(config, utils, performanceMonitor, musicSyncService, settingsManager2, year3000System2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this._scrollContainerElements = [];
          // Stored throttled interaction handler for proper cleanup.
          this._interactionHandler = null;
          this.year3000System = year3000System2;
          this.nexusState = {
            currentNavigationScale: 1,
            targetNavigationScale: 1,
            userInfluence: 0,
            lastEnergy: 0.5,
            lastValence: 0.5,
            lastVisualIntensity: 0.5,
            lastMoodIdentifier: "neutral"
          };
          this.biometricState = {
            isMeditating: false,
            lastUserInteractionTime: Date.now(),
            meditationGracePeriod: 5e3,
            interactionCooldown: 1e3,
            lastMeditationUpdateTime: null,
            desaturation: 0,
            slowdown: 1,
            targetDesaturation: 0,
            targetSlowdown: 1
          };
          this.lastHeavyUpdateTime = 0;
          this.heavyUpdateInterval = 1e3 / 10;
          this.lastBiometricCheckTime = 0;
          this.biometricCheckInterval = 1e3;
          this.lastInteractionRecordTime = 0;
          this.interactionRecordInterval = 200;
          this._animationRegistered = false;
          this._performanceMode = "auto";
          this._frameSkipCounter = 0;
          this._maxFrameSkip = 2;
          this.systemIntegrationMetrics = {
            lastSystemsCheck: Date.now(),
            integrationHealth: "healthy",
            crossSystemErrors: 0,
            meditationTransitions: 0,
            navigationScaleUpdates: 0
          };
          const healthMonitor = this.utils.getHealthMonitor();
          if (healthMonitor) {
            healthMonitor.registerSystem("InteractionTrackingSystem", this);
          }
          this.rootElement = this.utils.getRootStyle();
          this.modalObserver = null;
          this._lastScrollTime = null;
          this._lastScrollTop = null;
        }
        /**
         * Frame callback invoked by the MasterAnimationCoordinator.
         * Delegates to the existing `updateAnimation` implementation which
         * contains the system's main per-frame logic (including internal
         * frame-skipping and heavy-update cadence).
         *
         * @param deltaMs  Milliseconds elapsed since the previous animation frame.
         */
        onAnimate(deltaMs) {
          if (!this.initialized) return;
          this.updateAnimation(performance.now(), deltaMs);
        }
        async initialize() {
          await super.initialize();
          const year3000System2 = globalThis.year3000System;
          this.cssController = year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
          this.initializeOptimizedQuantumSpace();
          this.setupModalObserver();
          this.setupOptimizedInteractionListener();
          this._registerWithAnimationCoordinator();
        }
        _registerWithAnimationCoordinator() {
          if (this.year3000System && this.year3000System.registerAnimationSystem) {
            this.year3000System.registerAnimationSystem(
              "InteractionTrackingSystem",
              this,
              "normal",
              30
            );
            this._animationRegistered = true;
          } else {
            this._startFallbackAnimationLoops();
          }
        }
        initializeOptimizedQuantumSpace() {
          const root = this.utils.getRootStyle();
          if (!root) return;
          const initialInteractionVariables = {
            "--sn-nav-item-transform-scale": "1.0",
            "--sn-sidebar-meditation-desaturation": "0",
            "--sn-sidebar-meditation-slowdown": "1"
          };
          this.cssController.batchSetVariables(
            "InteractionTrackingSystem",
            initialInteractionVariables,
            "high",
            // High priority for interaction tracking initialization
            "quantum-space-initialization"
          );
        }
        recordUserInteraction(event) {
          const eventType = event.type;
          if (eventType === "scroll") {
            const target = event.target;
            if (target) {
              const newTop = target.scrollTop;
              const now2 = performance.now();
              const velocity = this._lastScrollTime ? (newTop - (this._lastScrollTop ?? 0)) / (now2 - this._lastScrollTime) : 0;
              const direction = velocity < 0 ? "up" : "down";
              unifiedEventBus.emit("user:scroll", {
                velocity: { x: 0, y: velocity * 1e3 },
                // pixels per second, normalized to x/y format
                direction,
                element: target.tagName || "unknown",
                timestamp: now2
              });
              this._lastScrollTop = newTop;
              this._lastScrollTime = now2;
            }
          }
          const now = performance.now();
          if (now - this.lastInteractionRecordTime < this.interactionRecordInterval) {
            return;
          }
          this.lastInteractionRecordTime = now;
          this.nexusState.userInfluence += 5e-3;
          this.nexusState.userInfluence = Math.min(0.5, this.nexusState.userInfluence);
          this.biometricState.lastUserInteractionTime = Date.now();
          this.biometricState.isMeditating = false;
        }
        setupModalObserver() {
          const modalRoot = document.querySelector(".main-modal-container");
          if (!modalRoot) return;
          const observerCallback = /* @__PURE__ */ __name((mutationsList, observer) => {
            for (const mutation of mutationsList) {
              if (mutation.type === "childList") {
                const hasModal = modalRoot.children.length > 0;
                this.nexusState.targetNavigationScale = hasModal ? 0.95 : 1;
              }
            }
          }, "observerCallback");
          this.modalObserver = new MutationObserver(observerCallback);
          this.modalObserver.observe(modalRoot, { childList: true });
        }
        setupOptimizedInteractionListener() {
          this._interactionHandler = this.utils.throttle(
            (event) => this.recordUserInteraction(event),
            100
          );
          const genericEvents = ["click", "mousemove", "keydown"];
          genericEvents.forEach((eventType) => {
            document.addEventListener(
              eventType,
              this._interactionHandler,
              { passive: true }
            );
          });
          const scrollSelectors = [
            ".main-view-container__scroll-node",
            ".main-view-container__scroll-node-child",
            "section[data-testid='playlist-page']"
          ];
          const foundContainers = [];
          scrollSelectors.forEach((sel) => {
            document.querySelectorAll(sel).forEach((el) => {
              foundContainers.push(el);
            });
          });
          const targets = foundContainers.length ? foundContainers : [document];
          targets.forEach((el) => {
            el.addEventListener("scroll", this._interactionHandler, {
              passive: true
            });
          });
          this._scrollContainerElements = foundContainers;
        }
        updateFromMusicAnalysis(processedMusicData, rawFeatures, trackUri) {
          if (!this.initialized || !this.validateMusicData(processedMusicData)) {
            this.applySafeDefaults();
            return;
          }
          this.updateNexusTargets(processedMusicData);
        }
        updateNexusTargets(processedMusicData) {
          const {
            energy,
            valence,
            visualIntensity,
            moodIdentifier
          } = processedMusicData;
          this.nexusState.lastEnergy = energy;
          this.nexusState.lastValence = valence;
          this.nexusState.lastVisualIntensity = visualIntensity;
          this.nexusState.lastMoodIdentifier = moodIdentifier;
          this.nexusState.targetNavigationScale = this.calculateOptimizedNavigationScale(visualIntensity, moodIdentifier);
        }
        updateDigitalMeditationState(processedMusicData) {
          const now = Date.now();
          if (now - this.lastBiometricCheckTime < this.biometricCheckInterval) {
            return;
          }
          this.lastBiometricCheckTime = now;
          const timeSinceLastInteraction = now - this.biometricState.lastUserInteractionTime;
          if (timeSinceLastInteraction > this.biometricState.meditationGracePeriod && processedMusicData.energy < 0.3 && processedMusicData.valence > 0.6) {
            this.biometricState.isMeditating = true;
            this.biometricState.targetDesaturation = 0.6;
            this.biometricState.targetSlowdown = 0.5;
          } else {
            this.biometricState.isMeditating = false;
            this.biometricState.targetDesaturation = 0;
            this.biometricState.targetSlowdown = 1;
          }
        }
        updateAnimation(timestamp, deltaTime) {
          if (!this.initialized) return;
          this._frameSkipCounter++;
          if (this._frameSkipCounter < this._maxFrameSkip) {
            return;
          }
          this._frameSkipCounter = 0;
          this.animateOptimizedNexusFrame(deltaTime);
          if (timestamp - this.lastHeavyUpdateTime > this.heavyUpdateInterval) {
            const latestMusicData = this.musicSyncService?.getLatestProcessedData();
            if (latestMusicData) this.updateDigitalMeditationState(latestMusicData);
            this.updateIntegrationMetrics();
            this.lastHeavyUpdateTime = timestamp;
          }
        }
        onPerformanceModeChange(mode) {
          this._performanceMode = mode;
          if (mode === "performance") {
            this.heavyUpdateInterval = 1e3 / 5;
            this._maxFrameSkip = 3;
            this.interactionRecordInterval = 500;
          } else {
            this.heavyUpdateInterval = 1e3 / 10;
            this._maxFrameSkip = 2;
            this.interactionRecordInterval = 200;
          }
        }
        _startFallbackAnimationLoops() {
          const loop = /* @__PURE__ */ __name(() => {
            this.updateAnimation(performance.now(), 16.67);
            requestAnimationFrame(loop);
          }, "loop");
          requestAnimationFrame(loop);
        }
        animateOptimizedNexusFrame(deltaTimeMs) {
          const lerpFactor = Math.min((deltaTimeMs ?? 16.67) / 1e3 * 5, 1);
          this.nexusState.currentNavigationScale = this.utils.lerp(
            this.nexusState.currentNavigationScale,
            this.nexusState.targetNavigationScale,
            lerpFactor
          );
          this.biometricState.desaturation = this.utils.lerp(
            this.biometricState.desaturation,
            this.biometricState.targetDesaturation,
            lerpFactor
          );
          this.biometricState.slowdown = this.utils.lerp(
            this.biometricState.slowdown,
            this.biometricState.targetSlowdown,
            lerpFactor
          );
          this.applyOptimizedStateToCSS();
        }
        applyOptimizedStateToCSS() {
          const interactionStateVariables = {
            "--sn-nav-item-transform-scale": this.nexusState.currentNavigationScale.toFixed(3),
            "--sn-sidebar-meditation-desaturation": this.biometricState.desaturation.toFixed(3),
            "--sn-sidebar-meditation-slowdown": this.biometricState.slowdown.toFixed(3)
          };
          this.cssController.batchSetVariables(
            "InteractionTrackingSystem",
            interactionStateVariables,
            "high",
            // High priority for real-time interaction state updates
            "interaction-state-update"
          );
        }
        validateMusicData(data) {
          return data && typeof data.energy === "number" && typeof data.valence === "number" && typeof data.visualIntensity === "number";
        }
        applySafeDefaults() {
          const safeDefaultVariables = {
            "--sn-nav-item-transform-scale": "1.0",
            "--sn-sidebar-meditation-desaturation": "0",
            "--sn-sidebar-meditation-slowdown": "1"
          };
          this.cssController.batchSetVariables(
            "InteractionTrackingSystem",
            safeDefaultVariables,
            "critical",
            // Critical priority for safe defaults - ensures fallback stability
            "safe-defaults-fallback"
          );
        }
        updateIntegrationMetrics() {
        }
        calculateIntegrationComplexity() {
          let complexity = 0;
          complexity += this.nexusState.userInfluence * 10;
          complexity += this.nexusState.lastVisualIntensity * 5;
          if (this.biometricState.isMeditating) complexity += 5;
          return complexity;
        }
        performCleanup() {
          if (this.nexusState.userInfluence > 0) {
            this.nexusState.userInfluence = Math.max(
              0,
              this.nexusState.userInfluence - 0.01
            );
          }
        }
        calculateOptimizedNavigationScale(visualIntensity = 0.5, moodIdentifier = "neutral") {
          let scale = 1;
          if (visualIntensity > 0.7) scale = 1.02;
          if (moodIdentifier === "energetic") scale *= 1.01;
          return scale;
        }
        getNavigationScalingReport() {
          return {
            target: this.nexusState.targetNavigationScale,
            current: this.nexusState.currentNavigationScale,
            intensity: this.nexusState.lastVisualIntensity,
            mood: this.nexusState.lastMoodIdentifier
          };
        }
        getMeditationReport() {
          return {
            isMeditating: this.biometricState.isMeditating,
            timeSinceInteraction: (Date.now() - this.biometricState.lastUserInteractionTime) / 1e3,
            desaturation: this.biometricState.desaturation,
            slowdown: this.biometricState.slowdown
          };
        }
        destroy() {
          if (this._interactionHandler) {
            ["click", "mousemove", "keydown"].forEach((evt) => {
              document.removeEventListener(
                evt,
                this._interactionHandler
              );
            });
            this._scrollContainerElements.forEach((el) => {
              el.removeEventListener(
                "scroll",
                this._interactionHandler
              );
            });
            this._interactionHandler = null;
          }
          super.destroy();
        }
      };
      __name(_InteractionTrackingSystem, "InteractionTrackingSystem");
      InteractionTrackingSystem = _InteractionTrackingSystem;
    }
  });

  // src-js/visual/ui-effects/SpotifyUIApplicationSystem.ts
  var _SpotifyUIApplicationSystem, SpotifyUIApplicationSystem;
  var init_SpotifyUIApplicationSystem = __esm({
    "src-js/visual/ui-effects/SpotifyUIApplicationSystem.ts"() {
      "use strict";
      init_UnifiedEventBus();
      _SpotifyUIApplicationSystem = class _SpotifyUIApplicationSystem {
        constructor(year3000System2) {
          this.year3000System = year3000System2;
          this.systemName = "SpotifyUIApplicationSystem";
          this.initialized = false;
          this.effectLayers = [];
          this.observerRegistry = /* @__PURE__ */ new Map();
          // Performance optimization
          this.lastDiscoveryLogTime = 0;
          this.lastRefreshLogTime = 0;
          // Increased debounce time to reduce frequency
          this.debounceRefresh = this.debounce(() => {
            this.refreshUITargets();
          }, 2e3);
          this.targets = this.initializeEmptyTargets();
        }
        /**
         * Required by IManagedSystem - periodic animation updates
         */
        updateAnimation(deltaTime) {
        }
        /**
         * Required by IManagedSystem - health check
         */
        async healthCheck() {
          try {
            const targetStats = this.getTargetStats();
            const totalElements = Object.values(targetStats).reduce(
              (sum, count) => sum + count,
              0
            );
            const isHealthy = this.initialized && totalElements > 0;
            const issues = [];
            if (totalElements === 0) {
              issues.push("No UI elements discovered");
            }
            return {
              healthy: isHealthy,
              ok: isHealthy,
              details: `UI Application System ${this.initialized ? "active" : "inactive"}, ${totalElements} elements enhanced`,
              issues,
              system: "SpotifyUIApplicationSystem"
            };
          } catch (error) {
            return {
              healthy: false,
              ok: false,
              details: "Health check failed",
              issues: [error instanceof Error ? error.message : "Unknown error"],
              system: "SpotifyUIApplicationSystem"
            };
          }
        }
        /**
         * Force repaint - implements optional IManagedSystem method
         * Cascade Coordination - Ensures proper layering of effects
         */
        forceRepaint(reason) {
          console.log(`\u{1F3A8} Force repaint requested: ${reason || "manual trigger"}`);
          this.forceEffectCascade();
        }
        initializeEmptyTargets() {
          return {
            nowPlaying: [],
            sidebar: [],
            mainContent: [],
            buttons: [],
            cards: [],
            headers: [],
            textElements: [],
            iconElements: [],
            playbackControls: [],
            trackRows: []
          };
        }
        async initialize() {
          if (this.initialized) return;
          try {
            await this.discoverUITargets();
            this.setupEffectLayers();
            this.applyUnifiedState();
            this.setupDOMObservers();
            this.registerSystemCallbacks();
            this.initialized = true;
            console.log("\u2728 SpotifyUIApplicationSystem initialized successfully");
          } catch (error) {
            console.error("Failed to initialize SpotifyUIApplicationSystem", error);
            throw error;
          }
        }
        /**
         * DOM Intelligence Layer - Discovers current Spotify UI elements (OPTIMIZED)
         */
        async discoverUITargets() {
          const selectors = {
            nowPlaying: [
              '[data-testid="now-playing-widget"]',
              ".main-nowPlayingWidget-nowPlaying",
              ".Root__now-playing-bar"
            ],
            sidebar: [
              '[data-testid="nav-bar"]',
              ".main-navBar-navBar",
              ".Root__nav-bar"
            ],
            mainContent: [
              '[data-testid="main"]',
              ".main-view-container",
              ".Root__main-view"
            ],
            buttons: [
              'button[class*="Button"]',
              '[role="button"]',
              ".main-playButton-PlayButton"
            ],
            cards: [
              '[data-testid*="card"]',
              ".main-card-card",
              ".main-entityCard-container"
            ],
            headers: [
              "h1, h2, h3, h4, h5, h6",
              '[data-testid*="header"]',
              ".main-entityHeader-titleText"
            ],
            textElements: [
              '[data-testid="track-name"]',
              '[data-testid="artist-name"]',
              ".main-trackList-trackName",
              ".main-trackList-artistName"
            ],
            iconElements: [
              'svg[class*="Icon"]',
              '[data-testid*="icon"]',
              ".Svg-sc-ytk21e-0"
            ],
            playbackControls: [
              '[data-testid="control-button"]',
              ".main-playPauseButton-button",
              ".player-controls__buttons"
            ],
            trackRows: [
              '[data-testid="tracklist-row"]',
              ".main-trackList-trackListRow",
              ".main-rootlist-rootlistItem"
            ]
          };
          const combinedQueries = {};
          for (const [category, selectorArray] of Object.entries(selectors)) {
            combinedQueries[category] = selectorArray.join(", ");
          }
          const elementMap = /* @__PURE__ */ new Map();
          for (const [category, combinedSelector] of Object.entries(combinedQueries)) {
            try {
              const found = document.querySelectorAll(combinedSelector);
              for (const element of found) {
                if (!elementMap.has(element)) {
                  elementMap.set(element, []);
                }
                elementMap.get(element).push(category);
              }
            } catch (error) {
              continue;
            }
          }
          this.targets = this.initializeEmptyTargets();
          for (const [element, categories] of elementMap) {
            for (const category of categories) {
              this.targets[category].push(element);
            }
          }
          if (performance.now() - this.lastDiscoveryLogTime >= 5e3) {
            console.log("\u{1F3AF} UI targets discovered", {
              nowPlaying: this.targets.nowPlaying.length,
              sidebar: this.targets.sidebar.length,
              mainContent: this.targets.mainContent.length,
              buttons: this.targets.buttons.length,
              cards: this.targets.cards.length,
              headers: this.targets.headers.length,
              textElements: this.targets.textElements.length,
              iconElements: this.targets.iconElements.length,
              playbackControls: this.targets.playbackControls.length,
              trackRows: this.targets.trackRows.length
            });
            this.lastDiscoveryLogTime = performance.now();
          }
        }
        /**
         * Effect Application Pipeline - Sets up cascade layers from background to foreground
         */
        setupEffectLayers() {
          this.effectLayers = [
            // Layer 1: Background & Container Effects
            {
              name: "background-containers",
              elements: [...this.targets.mainContent, ...this.targets.sidebar],
              priority: 10,
              cssVariables: {
                "--sn-bg-primary": "var(--sn-accent-primary)",
                "--sn-bg-secondary": "var(--sn-accent-secondary)",
                "--sn-gradient-start": "var(--sn-gradient-primary-rgb)",
                "--sn-gradient-end": "var(--sn-gradient-secondary-rgb)"
              }
            },
            // Layer 2: Card & Content Effects
            {
              name: "ui-cards",
              elements: this.targets.cards,
              priority: 20,
              cssVariables: {
                "--sn-card-bg": "var(--sn-accent-primary)",
                "--sn-card-border": "var(--sn-accent-secondary)",
                "--sn-card-glow": "var(--sn-accent-tertiary)",
                "--sn-glassmorphism-intensity": "var(--sn-effect-intensity)"
              },
              interactionEffects: true
            },
            // Layer 3: Interactive Elements
            {
              name: "interactive-elements",
              elements: [...this.targets.buttons, ...this.targets.playbackControls],
              priority: 30,
              cssVariables: {
                "--sn-button-bg": "var(--sn-accent-primary)",
                "--sn-button-hover": "var(--sn-accent-secondary)",
                "--sn-button-active": "var(--sn-accent-tertiary)",
                "--sn-beat-sync-intensity": "var(--sn-music-intensity)"
              },
              interactionEffects: true
            },
            // Layer 4: Text & Icon Enhancement
            {
              name: "text-icon-effects",
              elements: [
                ...this.targets.textElements,
                ...this.targets.iconElements,
                ...this.targets.headers
              ],
              priority: 40,
              cssVariables: {
                "--sn-text-primary": "var(--sn-accent-primary)",
                "--sn-text-secondary": "var(--sn-accent-secondary)",
                "--sn-text-glow": "var(--sn-accent-tertiary)",
                "--sn-icon-color": "var(--sn-accent-primary)",
                "--sn-icon-glow": "var(--sn-accent-secondary)"
              }
            },
            // Layer 5: Now Playing Special Effects
            {
              name: "now-playing-effects",
              elements: this.targets.nowPlaying,
              priority: 50,
              cssVariables: {
                "--sn-now-playing-bg": "var(--sn-accent-primary)",
                "--sn-now-playing-glow": "var(--sn-accent-secondary)",
                "--sn-beat-pulse": "var(--sn-music-intensity)",
                "--sn-track-progress": "var(--sn-accent-tertiary)"
              },
              interactionEffects: true
            }
          ];
        }
        /**
         * Applies unified state from existing systems to discovered UI elements
         */
        applyUnifiedState() {
          this.effectLayers.forEach((layer) => {
            layer.elements.forEach((element) => {
              this.applyEffectToElement(element, layer);
            });
          });
        }
        /**
         * Helper method to safely call Year3000System's queueCSSVariableUpdate
         */
        safeQueueCSSVariableUpdate(property, value, element) {
          if (this.year3000System?.queueCSSVariableUpdate) {
            this.year3000System.queueCSSVariableUpdate(property, value, element || null);
          } else {
            const target = element || document.documentElement;
            target.style.setProperty(property, value);
          }
        }
        applyEffectToElement(element, layer) {
          if (!(element instanceof HTMLElement)) return;
          Object.entries(layer.cssVariables).forEach(([property, value]) => {
            this.safeQueueCSSVariableUpdate(property, value, element);
          });
          element.classList.add(`sn-${layer.name}`);
          element.classList.add("sn-ui-enhanced");
          if (layer.interactionEffects) {
            this.addInteractionEffects(element, layer);
          }
          element.setAttribute("data-sn-layer", layer.name);
          element.setAttribute("data-sn-priority", layer.priority.toString());
        }
        addInteractionEffects(element, layer) {
          if (layer.name === "interactive-elements" || layer.name === "now-playing-effects") {
            this.safeQueueCSSVariableUpdate(
              "--sn-beat-response",
              "var(--sn-music-intensity)",
              element
            );
            element.classList.add("sn-beat-responsive");
          }
          element.addEventListener("mouseenter", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-hover-intensity",
              "1",
              element
            );
            element.classList.add("sn-hover-active");
          });
          element.addEventListener("mouseleave", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-hover-intensity",
              "0",
              element
            );
            element.classList.remove("sn-hover-active");
          });
          element.addEventListener("click", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-click-intensity",
              "1",
              element
            );
            element.classList.add("sn-click-active");
            setTimeout(() => {
              this.safeQueueCSSVariableUpdate(
                "--sn-click-intensity",
                "0",
                element
              );
              element.classList.remove("sn-click-active");
            }, 300);
          });
        }
        /**
         * Sets up DOM mutation observers for dynamic Spotify UI updates (OPTIMIZED)
         */
        setupDOMObservers() {
          const observerConfig = {
            childList: true,
            subtree: false,
            // Reduced to immediate children only
            attributes: false
            // Disabled attribute watching for performance
          };
          const mainObserver = new MutationObserver((mutations) => {
            let significantChange = false;
            mutations.forEach((mutation) => {
              if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
                const hasSignificantNodes = Array.from(mutation.addedNodes).some((node) => {
                  if (node.nodeType === Node.ELEMENT_NODE) {
                    const element = node;
                    return element.matches('[data-testid*="card"], [data-testid*="track"], [data-testid*="header"], [role="button"]') || element.querySelector('[data-testid*="card"], [data-testid*="track"], [data-testid*="header"], [role="button"]');
                  }
                  return false;
                });
                if (hasSignificantNodes) {
                  significantChange = true;
                }
              }
            });
            if (significantChange) {
              this.debounceRefresh();
            }
          });
          const mainElement = document.querySelector('[data-testid="main"]') || document.body;
          mainObserver.observe(mainElement, observerConfig);
          this.observerRegistry.set("main", mainObserver);
        }
        // Increased from 500ms to 2000ms
        debounce(func, wait) {
          let timeout;
          return /* @__PURE__ */ __name(function executedFunction(...args) {
            const later = /* @__PURE__ */ __name(() => {
              clearTimeout(timeout);
              func(...args);
            }, "later");
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          }, "executedFunction");
        }
        async refreshUITargets() {
          try {
            const previousTargetHash = this.calculateTargetHash();
            await this.discoverUITargets();
            const currentTargetHash = this.calculateTargetHash();
            if (previousTargetHash !== currentTargetHash) {
              this.applyUnifiedState();
              if (performance.now() - this.lastRefreshLogTime >= 1e4) {
                console.log("\u{1F504} UI targets refreshed");
                this.lastRefreshLogTime = performance.now();
              }
            }
          } catch (error) {
            console.error("Failed to refresh UI targets", error);
          }
        }
        calculateTargetHash() {
          const counts = Object.values(this.targets).map((arr) => arr.length);
          return counts.join("-");
        }
        /**
         * Registers for updates from unified systems - connects to event-driven architecture
         */
        registerSystemCallbacks() {
          try {
            unifiedEventBus.subscribe("colors:harmonized", (data) => {
              this.handleColorHarmonizedEvent({
                type: "colors/harmonized",
                payload: {
                  processedColors: data.processedColors,
                  accentHex: data.accentHex || "#cba6f7",
                  accentRgb: data.accentRgb || "203,166,247",
                  context: {
                    rawColors: data.processedColors,
                    trackUri: "",
                    timestamp: Date.now()
                  },
                  cssVariables: {},
                  metadata: {
                    strategy: data.strategies[0] || "unknown",
                    accentHex: data.accentHex,
                    processingTime: data.processingTime
                  }
                }
              });
            }, "SpotifyUIApplicationSystem");
            console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Subscribed to colors:harmonized events");
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to subscribe to colors:harmonized events:", error);
            if (this.year3000System.colorHarmonyEngine) {
              const originalApplyColors = this.year3000System.applyColorsToTheme.bind(
                this.year3000System
              );
              this.year3000System.applyColorsToTheme = (extractedColors = {}) => {
                originalApplyColors(extractedColors);
                this.updateColorVariables(extractedColors);
              };
              console.warn("[SpotifyUIApplicationSystem] Using legacy color application hook as fallback");
            }
          }
          if (this.year3000System.musicSyncService) {
            const originalUpdateFromAnalysis = this.year3000System.updateFromMusicAnalysis.bind(this.year3000System);
            this.year3000System.updateFromMusicAnalysis = (processedData, rawFeatures, trackUri) => {
              originalUpdateFromAnalysis(processedData, rawFeatures, trackUri);
              this.updateMusicIntensity(processedData);
            };
          }
          if (this.year3000System.beatSyncVisualSystem) {
            if (this.year3000System.timerConsolidationSystem) {
              this.year3000System.timerConsolidationSystem.registerConsolidatedTimer(
                "SpotifyUIApplicationSystem-beatEffects",
                () => {
                  const intensity = this.getCurrentMusicIntensity();
                  if (intensity > 0.5) {
                    this.triggerBeatEffects({ intensity });
                  }
                },
                200,
                "normal"
              );
            } else {
              setInterval(() => {
                const intensity = this.getCurrentMusicIntensity();
                if (intensity > 0.5) {
                  this.triggerBeatEffects({ intensity });
                }
              }, 200);
            }
          }
        }
        getCurrentMusicIntensity() {
          const root = document.documentElement;
          const intensity = getComputedStyle(root).getPropertyValue("--sn-kinetic-energy").trim();
          return parseFloat(intensity) || 0;
        }
        /**
         * Handle colors/harmonized event from ColorOrchestrator (Event-driven architecture)
         */
        handleColorHarmonizedEvent(event) {
          if (event.type !== "colors/harmonized") return;
          const { processedColors, cssVariables, metadata } = event.payload;
          console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Received harmonized colors via event-driven pattern", {
            strategy: metadata.strategy,
            colorsCount: Object.keys(processedColors).length,
            cssVariablesCount: Object.keys(cssVariables).length
          });
          try {
            this.updateColorVariables(processedColors);
            if (cssVariables && Object.keys(cssVariables).length > 0) {
              this.applyCSSVariablesToSpotifyUI(cssVariables);
            }
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to apply harmonized colors from event:", error);
            this.updateColorVariables(processedColors);
          }
        }
        /**
         * Apply CSS variables directly to Spotify UI elements (optimization for event-driven pattern)
         */
        applyCSSVariablesToSpotifyUI(cssVariables) {
          try {
            const root = document.documentElement;
            const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
            for (const [variable, value] of Object.entries(cssVariables)) {
              if (variable && value) {
                root.style.setProperty(variable, value);
              }
            }
            enhancedElements.forEach((element) => {
              if (element instanceof HTMLElement) {
                for (const [variable, value] of Object.entries(cssVariables)) {
                  if (variable && value) {
                    element.style.setProperty(variable, value);
                  }
                }
              }
            });
            console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Applied CSS variables to Spotify UI", {
              variablesCount: Object.keys(cssVariables).length,
              enhancedElementsCount: enhancedElements.length
            });
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to apply CSS variables to Spotify UI:", error);
          }
        }
        updateColorVariables(colorData) {
          const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
          enhancedElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-primary",
                colorData.primary || "var(--spice-accent)",
                element
              );
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-secondary",
                colorData.secondary || "var(--spice-accent)",
                element
              );
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-tertiary",
                colorData.tertiary || "var(--spice-accent)",
                element
              );
            }
          });
        }
        updateMusicIntensity(processedData) {
          const intensity = processedData?.processedEnergy || 0;
          const intensityElements = document.querySelectorAll(".sn-beat-responsive");
          intensityElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-music-intensity",
                intensity.toString(),
                element
              );
            }
          });
        }
        triggerBeatEffects(beatData) {
          const beatElements = document.querySelectorAll(".sn-beat-responsive");
          beatElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-beat-pulse",
                "1",
                element
              );
              element.classList.add("sn-beat-active");
              setTimeout(() => {
                this.safeQueueCSSVariableUpdate(
                  "--sn-beat-pulse",
                  "0",
                  element
                );
                element.classList.remove("sn-beat-active");
              }, 200);
            }
          });
        }
        /**
         * Cascade Coordination - Ensures proper layering of effects
         */
        forceEffectCascade() {
          this.effectLayers.sort((a, b) => a.priority - b.priority).forEach((layer) => {
            layer.elements.forEach((element) => {
              this.applyEffectToElement(element, layer);
            });
          });
        }
        async destroy() {
          if (this.year3000System?.timerConsolidationSystem) {
            this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer("SpotifyUIApplicationSystem-beatEffects");
          }
          this.observerRegistry.forEach((observer) => {
            observer.disconnect();
          });
          this.observerRegistry.clear();
          const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
          enhancedElements.forEach((element) => {
            element.classList.remove("sn-ui-enhanced");
            element.removeAttribute("data-sn-layer");
            element.removeAttribute("data-sn-priority");
          });
          this.initialized = false;
        }
        // Debug utility
        getTargetStats() {
          return Object.fromEntries(
            Object.entries(this.targets).map(([key, elements]) => [
              key,
              elements.length
            ])
          );
        }
      };
      __name(_SpotifyUIApplicationSystem, "SpotifyUIApplicationSystem");
      SpotifyUIApplicationSystem = _SpotifyUIApplicationSystem;
    }
  });

  // src-js/visual/effects/RedEnergyBurstSystem.ts
  var _RedEnergyBurstSystem, RedEnergyBurstSystem;
  var init_RedEnergyBurstSystem = __esm({
    "src-js/visual/effects/RedEnergyBurstSystem.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      _RedEnergyBurstSystem = class _RedEnergyBurstSystem {
        constructor(holographicSystem, cssConsciousnessController, musicSyncService) {
          this.initialized = false;
          this.dramaticElements = /* @__PURE__ */ new Map();
          // Performance tracking
          this.performanceMetrics = {
            energyBurstCount: 0,
            averageProcessingTime: 0,
            lastUpdateTime: 0,
            cpuUsage: 0
          };
          // Animation state
          this.animationState = {
            energyPhase: 0,
            dramaticPhase: 0,
            interferencePhase: 0,
            lastFrameTime: 0,
            isAnimating: false
          };
          // Cinematic color presets
          this.cinematicPalettes = {
            "blade-runner": {
              primaryRed: { r: 255, g: 50, b: 50 },
              amberGlow: { r: 255, g: 140, b: 0 },
              deepBlue: { r: 0, g: 100, b: 200 },
              neonCyan: { r: 0, g: 255, b: 255 }
            },
            cyberpunk: {
              primaryRed: { r: 255, g: 0, b: 100 },
              amberGlow: { r: 255, g: 180, b: 0 },
              deepBlue: { r: 50, g: 50, b: 255 },
              neonCyan: { r: 100, g: 255, b: 255 }
            },
            "dramatic-noir": {
              primaryRed: { r: 200, g: 0, b: 0 },
              amberGlow: { r: 255, g: 120, b: 0 },
              deepBlue: { r: 0, g: 50, b: 150 },
              neonCyan: { r: 0, g: 200, b: 255 }
            }
          };
          this.holographicSystem = holographicSystem;
          this.cssConsciousnessController = cssConsciousnessController;
          this.musicSyncService = musicSyncService;
          this.oklabProcessor = new OKLABColorProcessor(true);
          this.emotionalMapper = new EmotionalTemperatureMapper(true);
          this.cinematicPreset = OKLABColorProcessor.getPreset("COSMIC");
          this.energyBurstState = {
            intensity: 0,
            frequency: 0.5,
            temperature: 2500,
            // Red-amber temperature
            interferenceLevel: 0,
            scanlineVelocity: 1,
            holographicDepth: 0,
            dramaticTension: 0,
            energyStability: 1
          };
          this.cinematicConfig = {
            redEnergyThreshold: 0.7,
            // Activate on high intensity
            holographicIntensityMax: 0.9,
            // Maximum effect strength
            crFilteringStrength: 0.8,
            // Strong CRT simulation
            bladeRunnerMode: true,
            // Authentic aesthetic
            energyBurstDuration: 1500,
            // 1.5 second bursts
            scanlineFrequency: 120
            // 120Hz base scanlines
          };
        }
        /**
         * Initialize the Cinematic Drama Engine
         */
        async initialize() {
          if (this.initialized) return;
          try {
            console.log(
              "[RedEnergyBurstSystem] Initializing red energy burst system..."
            );
            this.subscribeToColorConsciousness();
            this.subscribeToOKLABColorEvents();
            await this.initializeDramaticElements();
            this.setupCinematicCSSVariables();
            this.startCinematicAnimation();
            this.initialized = true;
            console.log(
              "[RedEnergyBurstSystem] \u2705 Ready for dramatic consciousness moments"
            );
          } catch (error) {
            console.error("[RedEnergyBurstSystem] Failed to initialize:", error);
            throw error;
          }
        }
        /**
         * Update animation frame for cinematic effects
         */
        updateAnimation(deltaTime) {
          if (!this.initialized) return;
          const deltaSeconds = deltaTime / 1e3;
          this.animationState.energyPhase += deltaSeconds * this.energyBurstState.frequency * 2;
          this.animationState.dramaticPhase += deltaSeconds * 0.8;
          this.animationState.interferencePhase += deltaSeconds * 3;
          this.updateEnergyBurstFromMusic();
          this.updateHolographicMapping();
          this.updateDramaticElements();
          this.updatePerformanceMetrics(deltaTime);
        }
        /**
         * Health check for cinematic drama system
         */
        async healthCheck() {
          const isHealthy = this.initialized && this.energyBurstState.intensity >= 0 && this.performanceMetrics.averageProcessingTime < 5;
          return {
            system: "RedEnergyBurstSystem",
            healthy: isHealthy,
            metrics: {
              energyBurstCount: this.performanceMetrics.energyBurstCount,
              processingTime: this.performanceMetrics.averageProcessingTime,
              dramaticElementCount: this.dramaticElements.size,
              cpuUsage: this.performanceMetrics.cpuUsage
            },
            issues: isHealthy ? [] : ["Performance degradation detected"]
          };
        }
        /**
         * Subscribe to ColorConsciousnessOrchestrator events
         */
        subscribeToColorConsciousness() {
          unifiedEventBus.subscribe("emotionalColorContext:updated", (event) => {
            this.onColorConsciousnessUpdate(event);
          }, "RedEnergyBurstSystem");
          unifiedEventBus.subscribe("emotion:analyzed", (event) => {
            this.onMusicIntensitySpike(event);
          }, "RedEnergyBurstSystem");
          unifiedEventBus.subscribe("emotion:analyzed", (event) => {
            this.onDramaticMoment(event);
          }, "RedEnergyBurstSystem");
        }
        /**
         * Subscribe to unified OKLAB color events
         */
        subscribeToOKLABColorEvents() {
          unifiedEventBus.subscribe(
            "colors:harmonized",
            (event) => {
              this.onOKLABColorsHarmonized(event);
            },
            "RedEnergyBurstSystem"
          );
          unifiedEventBus.subscribe(
            "colors:extracted",
            (event) => {
              this.onColorsExtracted(event);
            },
            "RedEnergyBurstSystem"
          );
        }
        /**
         * Handle color consciousness updates
         */
        onColorConsciousnessUpdate(event) {
          const { palette, consciousnessLevel, emotionalTemperature } = event;
          this.energyBurstState.dramaticTension = consciousnessLevel * 0.8;
          if (emotionalTemperature < 3e3) {
            this.energyBurstState.temperature = 2200;
          } else if (emotionalTemperature > 6e3) {
            this.energyBurstState.temperature = 2800;
          } else {
            this.energyBurstState.temperature = 2500;
          }
          const dominantColor = this.extractDominantRedColor(palette);
          this.updateHolographicColors(dominantColor);
        }
        /**
         * Handle music intensity spikes
         */
        onMusicIntensitySpike(event) {
          const { intensity, beat } = event;
          if (intensity > this.cinematicConfig.redEnergyThreshold) {
            this.triggerEnergyBurst(intensity, beat);
          }
        }
        /**
         * Handle dramatic musical moments
         */
        onDramaticMoment(event) {
          const { type, intensity } = event;
          this.energyBurstState.dramaticTension = Math.min(1, intensity * 1.2);
          this.energyBurstState.interferenceLevel = intensity * 0.6;
          this.energyBurstState.energyStability = Math.max(
            0.3,
            1 - intensity * 0.7
          );
        }
        /**
         * Handle OKLAB harmonized colors for cinematic enhancement
         */
        onOKLABColorsHarmonized(event) {
          const { processedColors, coordinationMetrics } = event;
          const cinematicColors = this.extractCinematicOKLABColors(processedColors);
          this.updateCinematicPaletteWithOKLAB(cinematicColors);
          if (coordinationMetrics?.detectedGenre || coordinationMetrics?.emotionalState) {
            this.adjustCinematicPresetForContext(coordinationMetrics);
          }
        }
        /**
         * Handle color extraction for immediate cinematic response
         */
        onColorsExtracted(event) {
          const { rawColors, musicData } = event;
          if (musicData) {
            const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
            this.adjustCinematicEffectsForEmotion(emotionalResult);
            if (emotionalResult.intensity > 0.7) {
              this.cinematicPreset = OKLABColorProcessor.getPreset("COSMIC");
            } else if (emotionalResult.intensity > 0.4) {
              this.cinematicPreset = OKLABColorProcessor.getPreset("VIBRANT");
            } else {
              this.cinematicPreset = OKLABColorProcessor.getPreset("STANDARD");
            }
          }
        }
        /**
         * Trigger red energy burst effect
         */
        triggerEnergyBurst(intensity, beat) {
          const startTime = performance.now();
          this.energyBurstState.intensity = Math.min(1, intensity * 1.1);
          this.energyBurstState.frequency = 1 + intensity * 2;
          this.energyBurstState.holographicDepth = intensity * 0.8;
          this.energyBurstState.scanlineVelocity = 1 + beat.strength * 2;
          setTimeout(() => {
            this.decayEnergyBurst();
          }, this.cinematicConfig.energyBurstDuration);
          this.performanceMetrics.energyBurstCount++;
          this.performanceMetrics.lastUpdateTime = performance.now() - startTime;
          console.log(
            `[RedEnergyBurstSystem] \u{1F525} Red energy burst triggered! Intensity: ${intensity.toFixed(
              2
            )}`
          );
        }
        /**
         * Decay energy burst over time
         */
        decayEnergyBurst() {
          const decayRate = 0.05;
          const decay = /* @__PURE__ */ __name(() => {
            this.energyBurstState.intensity *= 1 - decayRate;
            this.energyBurstState.holographicDepth *= 1 - decayRate * 0.8;
            this.energyBurstState.interferenceLevel *= 1 - decayRate * 0.6;
            if (this.energyBurstState.intensity > 0.05) {
              requestAnimationFrame(decay);
            } else {
              this.energyBurstState.intensity = 0;
              this.energyBurstState.holographicDepth = 0;
              this.energyBurstState.interferenceLevel = 0;
            }
          }, "decay");
          requestAnimationFrame(decay);
        }
        /**
         * Update energy burst from current music state
         */
        updateEnergyBurstFromMusic() {
          const musicState = this.musicSyncService.getCurrentMusicState();
          if (!musicState) return;
          const { emotion, beat, intensity } = musicState;
          if (beat && beat.tempo) {
            const tempoMultiplier = Math.max(0.5, Math.min(2, beat.tempo / 120));
            this.energyBurstState.frequency = this.energyBurstState.frequency * tempoMultiplier;
          }
          if (emotion && emotion.arousal > 0.7) {
            this.energyBurstState.interferenceLevel = Math.max(
              this.energyBurstState.interferenceLevel,
              emotion.arousal * 0.5
            );
          }
        }
        /**
         * Update holographic color mapping for cinematic effects
         */
        updateHolographicMapping() {
          const palette = this.cinematicPalettes["blade-runner"];
          const mapping = {
            dominantColor: this.blendRedColors(
              palette.primaryRed,
              palette.amberGlow,
              this.energyBurstState.temperature / 3e3
            ),
            glowIntensity: this.energyBurstState.intensity * this.cinematicConfig.holographicIntensityMax,
            flickerRate: this.energyBurstState.frequency * 2,
            scanlineColor: palette.amberGlow,
            atmosphericDepth: this.energyBurstState.holographicDepth,
            interferencePattern: this.getInterferencePattern()
          };
          this.updateCinematicCSSVariables(mapping);
        }
        /**
         * Blend red colors based on temperature using OKLAB for perceptual accuracy
         */
        blendRedColors(red, amber, blendFactor) {
          const factor = Math.max(0, Math.min(1, blendFactor));
          try {
            const redHex = `#${red.r.toString(16).padStart(2, "0")}${red.g.toString(16).padStart(2, "0")}${red.b.toString(16).padStart(2, "0")}`;
            const amberHex = `#${amber.r.toString(16).padStart(2, "0")}${amber.g.toString(16).padStart(2, "0")}${amber.b.toString(16).padStart(2, "0")}`;
            const blendedResult = this.oklabProcessor.interpolateOKLAB(
              redHex,
              amberHex,
              factor,
              this.cinematicPreset
            );
            return blendedResult.enhancedRgb;
          } catch (error) {
            return {
              r: Math.round(red.r * (1 - factor) + amber.r * factor),
              g: Math.round(red.g * (1 - factor) + amber.g * factor),
              b: Math.round(red.b * (1 - factor) + amber.b * factor)
            };
          }
        }
        /**
         * Get interference pattern based on current state
         */
        getInterferencePattern() {
          if (this.energyBurstState.energyStability < 0.4) {
            return "chaos";
          } else if (this.energyBurstState.dramaticTension > 0.7) {
            return "dramatic";
          } else if (this.energyBurstState.interferenceLevel > 0.5) {
            return "noise";
          } else {
            return "wave";
          }
        }
        /**
         * Extract dominant red color from palette
         */
        extractDominantRedColor(palette) {
          let redColor = { r: 255, g: 50, b: 50 };
          if (palette && palette.length > 0) {
            const reds = palette.filter(
              (color3) => color3.r > color3.g && color3.r > color3.b
            );
            if (reds.length > 0) {
              redColor = reds[0];
            }
          }
          return redColor;
        }
        /**
         * Extract cinematic colors from OKLAB-processed palette
         */
        extractCinematicOKLABColors(processedColors) {
          const defaultColors = this.cinematicPalettes["blade-runner"];
          const enhancedColors = { ...defaultColors };
          if (processedColors.VIBRANT) {
            const vibrantResult = this.oklabProcessor.processColor(
              processedColors.VIBRANT,
              this.cinematicPreset
            );
            enhancedColors.primaryRed = vibrantResult.enhancedRgb;
          }
          if (processedColors.PROMINENT) {
            const prominentResult = this.oklabProcessor.processColor(
              processedColors.PROMINENT,
              this.cinematicPreset
            );
            enhancedColors.amberGlow = prominentResult.enhancedRgb;
          }
          if (processedColors.DARK_VIBRANT) {
            const darkResult = this.oklabProcessor.processColor(
              processedColors.DARK_VIBRANT,
              this.cinematicPreset
            );
            enhancedColors.deepBlue = darkResult.enhancedRgb;
          }
          return enhancedColors;
        }
        /**
         * Update cinematic palette with OKLAB-enhanced colors
         */
        updateCinematicPaletteWithOKLAB(cinematicColors) {
          this.cinematicPalettes["blade-runner"] = cinematicColors;
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-red-r",
            cinematicColors.primaryRed.r.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-red-g",
            cinematicColors.primaryRed.g.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-red-b",
            cinematicColors.primaryRed.b.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-amber-r",
            cinematicColors.amberGlow.r.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-amber-g",
            cinematicColors.amberGlow.g.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-amber-b",
            cinematicColors.amberGlow.b.toString()
          );
        }
        /**
         * Adjust cinematic preset based on detected genre/emotion context
         */
        adjustCinematicPresetForContext(coordinationMetrics) {
          const { detectedGenre, emotionalState, oklabPreset } = coordinationMetrics;
          if (detectedGenre) {
            switch (detectedGenre) {
              case "electronic":
              case "dance":
              case "techno":
                this.cinematicPreset = OKLABColorProcessor.getPreset("COSMIC");
                this.cinematicConfig.bladeRunnerMode = true;
                break;
              case "rock":
              case "metal":
                this.cinematicPreset = OKLABColorProcessor.getPreset("VIBRANT");
                this.cinematicConfig.redEnergyThreshold = 0.6;
                break;
              case "ambient":
              case "classical":
                this.cinematicPreset = OKLABColorProcessor.getPreset("SUBTLE");
                this.cinematicConfig.redEnergyThreshold = 0.8;
                break;
              default:
                this.cinematicPreset = OKLABColorProcessor.getPreset("STANDARD");
            }
          }
          if (emotionalState) {
            switch (emotionalState) {
              case "aggressive":
              case "energetic":
                this.energyBurstState.frequency *= 1.5;
                this.energyBurstState.interferenceLevel = Math.min(
                  1,
                  this.energyBurstState.interferenceLevel + 0.3
                );
                break;
              case "calm":
              case "ambient":
                this.energyBurstState.frequency *= 0.7;
                this.energyBurstState.energyStability = Math.min(
                  1,
                  this.energyBurstState.energyStability + 0.2
                );
                break;
              case "mysterious":
                this.cinematicConfig.bladeRunnerMode = true;
                this.energyBurstState.interferenceLevel = Math.min(
                  1,
                  this.energyBurstState.interferenceLevel + 0.2
                );
                break;
            }
          }
        }
        /**
         * Adjust cinematic effects based on emotional temperature result
         */
        adjustCinematicEffectsForEmotion(emotionalResult) {
          const { primaryEmotion, intensity, temperature } = emotionalResult;
          this.energyBurstState.dramaticTension = intensity * 0.9;
          if (temperature < 3e3) {
            this.energyBurstState.temperature = 2200;
          } else if (temperature > 6e3) {
            this.energyBurstState.temperature = 2800;
          } else {
            this.energyBurstState.temperature = 2500;
          }
          switch (primaryEmotion) {
            case "aggressive":
              this.energyBurstState.interferenceLevel = Math.min(
                1,
                intensity * 0.8
              );
              this.energyBurstState.energyStability = Math.max(0.2, 1 - intensity);
              break;
            case "calm":
              this.energyBurstState.energyStability = Math.min(
                1,
                0.8 + intensity * 0.2
              );
              this.energyBurstState.interferenceLevel *= 0.5;
              break;
            case "mysterious":
              this.energyBurstState.interferenceLevel = intensity * 0.6;
              this.cinematicConfig.bladeRunnerMode = true;
              break;
            case "energetic":
              this.energyBurstState.frequency = Math.min(3, 1 + intensity * 2);
              break;
          }
        }
        /**
         * Update holographic colors
         */
        updateHolographicColors(dominantColor) {
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-red-r",
            dominantColor.r.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-red-g",
            dominantColor.g.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-red-b",
            dominantColor.b.toString()
          );
        }
        /**
         * Initialize dramatic UI elements
         */
        async initializeDramaticElements() {
          const dramaticSelectors = [
            { selector: ".Root__now-playing-bar", type: "energy_barrier" },
            { selector: ".main-view-container", type: "cinematic_overlay" },
            { selector: ".Root__nav-bar", type: "data_stream_red" },
            { selector: ".player-controls", type: "dramatic_interface" }
          ];
          for (const config of dramaticSelectors) {
            const elements = document.querySelectorAll(config.selector);
            for (const element of elements) {
              const dramaticElement = {
                id: `dramatic-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                element,
                originalStyles: getComputedStyle(element),
                holographicType: config.type,
                intensity: 0.8,
                isActive: true,
                lastUpdate: 0,
                animation: null,
                consciousnessLevel: 0.9,
                organicIntegration: true
              };
              this.dramaticElements.set(dramaticElement.id, dramaticElement);
            }
          }
        }
        /**
         * Setup CSS variables for cinematic effects
         */
        setupCinematicCSSVariables() {
          const baseVariables = {
            "--cinematic-red-r": "255",
            "--cinematic-red-g": "50",
            "--cinematic-red-b": "50",
            "--cinematic-amber-r": "255",
            "--cinematic-amber-g": "140",
            "--cinematic-amber-b": "0",
            "--cinematic-glow-intensity": "0",
            "--cinematic-flicker-rate": "0.5",
            "--cinematic-scanline-speed": "1.0",
            "--cinematic-interference": "0",
            "--cinematic-depth": "0"
          };
          for (const [variable, value] of Object.entries(baseVariables)) {
            this.cssConsciousnessController.queueCSSVariableUpdate(variable, value);
          }
        }
        /**
         * Update cinematic CSS variables
         */
        updateCinematicCSSVariables(mapping) {
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-glow-intensity",
            mapping.glowIntensity.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-flicker-rate",
            mapping.flickerRate.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-scanline-speed",
            this.energyBurstState.scanlineVelocity.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-interference",
            this.energyBurstState.interferenceLevel.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--cinematic-depth",
            mapping.atmosphericDepth.toString()
          );
        }
        /**
         * Update dramatic elements
         */
        updateDramaticElements() {
          for (const [id, element] of this.dramaticElements) {
            if (element.isActive) {
              this.updateDramaticElement(element);
            }
          }
        }
        /**
         * Update single dramatic element
         */
        updateDramaticElement(element) {
          const { element: htmlElement, intensity } = element;
          if (this.energyBurstState.intensity > 0.1) {
            this.applyRedEnergyBurst(htmlElement, intensity);
          }
          if (this.energyBurstState.interferenceLevel > 0.1) {
            this.applyCRTInterference(htmlElement, intensity);
          }
          this.applyDramaticScanlines(htmlElement, intensity);
        }
        /**
         * Apply red energy burst effect to element
         */
        applyRedEnergyBurst(element, intensity) {
          const burstIntensity = this.energyBurstState.intensity * intensity;
          const dramaticPulse = Math.sin(this.animationState.energyPhase * 3) * 0.5 + 0.5;
          const glowIntensity = burstIntensity * dramaticPulse * 0.8;
          element.style.boxShadow = `
      0 0 ${glowIntensity * 40}px rgba(var(--cinematic-red-r), var(--cinematic-red-g), var(--cinematic-red-b), ${glowIntensity}),
      inset 0 0 ${glowIntensity * 20}px rgba(var(--cinematic-amber-r), var(--cinematic-amber-g), var(--cinematic-amber-b), ${glowIntensity * 0.5})
    `;
          if (burstIntensity > 0.3) {
            element.style.border = `1px solid rgba(var(--cinematic-red-r), var(--cinematic-red-g), var(--cinematic-red-b), ${burstIntensity})`;
          }
        }
        /**
         * Apply CRT interference effect
         */
        applyCRTInterference(element, intensity) {
          const interferenceIntensity = this.energyBurstState.interferenceLevel * intensity;
          const interferencePhase = this.animationState.interferencePhase;
          const chromaticOffset = interferenceIntensity * 3;
          const redOffset = Math.sin(interferencePhase * 2) * chromaticOffset;
          const blueOffset = Math.cos(interferencePhase * 2.5) * chromaticOffset;
          element.style.filter = `
      drop-shadow(${redOffset}px 0 0 rgba(var(--spice-rgb-cinematic-red, 255, 0, 0), ${interferenceIntensity * 0.6}))
      drop-shadow(${blueOffset}px 0 0 rgba(var(--spice-rgb-cinematic-cyan, 0, 255, 255), ${interferenceIntensity * 0.4}))
    `;
          if (interferenceIntensity > 0.5) {
            const noiseOffset = Math.sin(interferencePhase * 10) * interferenceIntensity * 2;
            element.style.transform = `translateX(${noiseOffset}px)`;
          }
        }
        /**
         * Apply dramatic scanlines
         */
        applyDramaticScanlines(element, intensity) {
          const scanlineIntensity = this.energyBurstState.intensity * intensity * 0.6;
          if (scanlineIntensity > 0.1) {
            const scanlineFrequency = this.cinematicConfig.scanlineFrequency / 30;
            element.style.background = `
        ${element.style.background || ""},
        repeating-linear-gradient(
          0deg,
          transparent 0px,
          transparent ${scanlineFrequency - 1}px,
          rgba(var(--cinematic-amber-r), var(--cinematic-amber-g), var(--cinematic-amber-b), ${scanlineIntensity * 0.15}) ${scanlineFrequency}px
        )
      `;
          }
        }
        /**
         * Start cinematic animation loop
         */
        startCinematicAnimation() {
          this.animationState.isAnimating = true;
          this.animationState.lastFrameTime = performance.now();
          const animate = /* @__PURE__ */ __name((currentTime) => {
            if (!this.animationState.isAnimating) return;
            const deltaTime = currentTime - this.animationState.lastFrameTime;
            this.animationState.lastFrameTime = currentTime;
            this.updateAnimation(deltaTime);
            requestAnimationFrame(animate);
          }, "animate");
          requestAnimationFrame(animate);
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics(deltaTime) {
          this.performanceMetrics.averageProcessingTime = this.performanceMetrics.averageProcessingTime * 0.9 + deltaTime * 0.1;
          this.performanceMetrics.cpuUsage = Math.min(100, deltaTime / 16.67 * 100);
        }
        /**
         * Force repaint for immediate visual updates
         */
        forceRepaint(reason) {
          console.log(
            `[RedEnergyBurstSystem] Force repaint triggered: ${reason || "Unknown"}`
          );
          this.updateDramaticElements();
          this.cssConsciousnessController.flushCSSVariableBatch();
        }
        /**
         * Cleanup and destroy the engine
         */
        destroy() {
          console.log("[RedEnergyBurstSystem] Destroying cinematic drama engine...");
          this.animationState.isAnimating = false;
          this.dramaticElements.clear();
          this.energyBurstState = {
            intensity: 0,
            frequency: 0.5,
            temperature: 2500,
            interferenceLevel: 0,
            scanlineVelocity: 1,
            holographicDepth: 0,
            dramaticTension: 0,
            energyStability: 1
          };
          this.initialized = false;
        }
        // Public API methods
        getEnergyBurstState() {
          return { ...this.energyBurstState };
        }
        getCinematicConfig() {
          return { ...this.cinematicConfig };
        }
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        setRedEnergyThreshold(threshold) {
          this.cinematicConfig.redEnergyThreshold = Math.max(
            0,
            Math.min(1, threshold)
          );
        }
        setBladeRunnerMode(enabled) {
          this.cinematicConfig.bladeRunnerMode = enabled;
          if (enabled) {
            console.log("[RedEnergyBurstSystem] \u{1F3AC} Blade Runner mode activated");
          }
        }
      };
      __name(_RedEnergyBurstSystem, "RedEnergyBurstSystem");
      RedEnergyBurstSystem = _RedEnergyBurstSystem;
    }
  });

  // src-js/visual/effects/SoftGlowEffectsManager.ts
  var _SoftGlowEffectsManager, SoftGlowEffectsManager;
  var init_SoftGlowEffectsManager = __esm({
    "src-js/visual/effects/SoftGlowEffectsManager.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_Year3000Utilities();
      _SoftGlowEffectsManager = class _SoftGlowEffectsManager {
        constructor(holographicSystem, cssConsciousnessController, musicSyncService) {
          this.initialized = false;
          this.etherealElements = /* @__PURE__ */ new Map();
          // Performance tracking
          this.performanceMetrics = {
            emotionalMomentCount: 0,
            averageProcessingTime: 0,
            lastUpdateTime: 0,
            gentleTransitionCount: 0
          };
          // Animation state
          this.animationState = {
            mysticalPhase: 0,
            dreamyPhase: 0,
            flowingPhase: 0,
            emotionalPulsePhase: 0,
            lastFrameTime: 0,
            isAnimating: false
          };
          // LERP smoothing half-life values (in seconds) for framerate-independent decay
          this.lerpHalfLifeValues = {
            emotionalIntensity: 0.25,
            // Fast emotional response
            beautyLevel: 0.35,
            // Moderate beauty transitions
            mysticalShimmer: 0.2
            // Quick shimmer response
          };
          // Ethereal color palettes
          this.etherealPalettes = {
            "dreamy-pastels": {
              primarySoft: { r: 203, g: 166, b: 247 },
              // Catppuccin mauve (soft)
              mysticalGlow: { r: 148, g: 226, b: 213 },
              // Catppuccin teal (mystical)
              dreamyMist: { r: 245, g: 224, b: 220 },
              // Catppuccin rosewater
              emotionalHeart: { r: 249, g: 226, b: 175 },
              // Catppuccin yellow (warm)
              etherealHighlight: { r: 180, g: 190, b: 254 }
              // Catppuccin lavender
            },
            "mystical-moonlight": {
              primarySoft: { r: 137, g: 180, b: 250 },
              // Catppuccin blue (soft)
              mysticalGlow: { r: 166, g: 227, b: 161 },
              // Catppuccin green (mystical)
              dreamyMist: { r: 205, g: 214, b: 244 },
              // Catppuccin text (muted)
              emotionalHeart: { r: 243, g: 139, b: 168 },
              // Catppuccin pink (warm)
              etherealHighlight: { r: 137, g: 220, b: 235 }
              // Catppuccin sky
            },
            "gentle-aurora": {
              primarySoft: { r: 166, g: 227, b: 161 },
              // Catppuccin green (soft)
              mysticalGlow: { r: 137, g: 220, b: 235 },
              // Catppuccin sky (mystical)
              dreamyMist: { r: 186, g: 194, b: 222 },
              // Catppuccin subtext1
              emotionalHeart: { r: 250, g: 179, b: 135 },
              // Catppuccin peach (warm)
              etherealHighlight: { r: 203, g: 166, b: 247 }
              // Catppuccin mauve
            }
          };
          this.holographicSystem = holographicSystem;
          this.cssConsciousnessController = cssConsciousnessController;
          this.musicSyncService = musicSyncService;
          this.etherealState = {
            emotionalIntensity: 0,
            beautyLevel: 0,
            gentleness: 0.8,
            // High gentleness by default
            mysticalShimmer: 0,
            dreamyTranslucency: 0.9,
            // High translucency for dreamy effect
            flowingGradientPhase: 0,
            emotionalResonance: 0,
            softnessFactor: 1,
            // Initialize target values to current values (no animation initially)
            targetEmotionalIntensity: 0,
            targetBeautyLevel: 0,
            targetMysticalShimmer: 0
          };
          this.etherealConfig = {
            emotionalThreshold: 0.6,
            // Activate on positive valence
            maxBeautyIntensity: 0.8,
            // Gentle maximum intensity
            gentleTransitionDuration: 2e3,
            // 2 second gentle transitions
            mysticalParticleCount: 15,
            // Subtle particle count
            dreamyBlurRadius: 8,
            // Soft blur radius
            flowingGradientSpeed: 0.3
            // Slow, flowing animations
          };
        }
        /**
         * Initialize the Ethereal Beauty Engine
         */
        async initialize() {
          if (this.initialized) return;
          try {
            console.log("[SoftGlowEffectsManager] Awakening ethereal beauty consciousness...");
            this.subscribeToEmotionalConsciousness();
            await this.initializeEtherealElements();
            this.setupEtherealCSSVariables();
            this.startEtherealAnimation();
            this.initialized = true;
            console.log("[SoftGlowEffectsManager] \u2728 Ready for mystical emotional moments");
          } catch (error) {
            console.error("[SoftGlowEffectsManager] Failed to initialize:", error);
            throw error;
          }
        }
        /**
         * Update animation frame for ethereal effects
         */
        updateAnimation(deltaTime) {
          if (!this.initialized) return;
          const deltaSeconds = deltaTime / 1e3;
          this.animationState.mysticalPhase += deltaSeconds * 0.5;
          this.animationState.dreamyPhase += deltaSeconds * 0.3;
          this.animationState.flowingPhase += deltaSeconds * this.etherealConfig.flowingGradientSpeed;
          this.animationState.emotionalPulsePhase += deltaSeconds * 0.8;
          this.updateEtherealFromMusic();
          this.updateEtherealStateWithLERP(deltaSeconds);
          this.updateMysticalEffects();
          this.updateEtherealElements();
          this.updatePerformanceMetrics(deltaTime);
        }
        /**
         * Health check for ethereal beauty system
         */
        async healthCheck() {
          const isHealthy = this.initialized && this.etherealState.beautyLevel >= 0 && this.performanceMetrics.averageProcessingTime < 8;
          return {
            system: "SoftGlowEffectsManager",
            healthy: isHealthy,
            metrics: {
              emotionalMomentCount: this.performanceMetrics.emotionalMomentCount,
              processingTime: this.performanceMetrics.averageProcessingTime,
              etherealElementCount: this.etherealElements.size,
              gentleTransitionCount: this.performanceMetrics.gentleTransitionCount
            },
            issues: isHealthy ? [] : ["Performance degradation detected"]
          };
        }
        /**
         * Subscribe to emotional consciousness events
         */
        subscribeToEmotionalConsciousness() {
          unifiedEventBus.subscribe("emotionalColorContext:updated", (event) => {
            this.onColorConsciousnessUpdate(event);
          });
          unifiedEventBus.subscribe("emotion:analyzed", (event) => {
            this.onEmotionalMoment(event);
          });
          unifiedEventBus.subscribe("settings:visual-guide-changed", (event) => {
            this.onGentleTransition(event);
          });
        }
        /**
         * Handle color consciousness updates
         */
        onColorConsciousnessUpdate(event) {
          const { palette, consciousnessLevel, emotionalTemperature } = event;
          this.etherealState.emotionalResonance = consciousnessLevel * 0.9;
          if (emotionalTemperature > 5e3) {
            this.etherealState.beautyLevel = Math.min(0.8, consciousnessLevel * 1.2);
          } else {
            this.etherealState.mysticalShimmer = consciousnessLevel * 0.7;
          }
          const etherealColors = this.generateEtherealColors(palette, emotionalTemperature);
          this.updateEtherealColors(etherealColors);
        }
        /**
         * Handle emotional musical moments
         */
        onEmotionalMoment(event) {
          const { type, intensity, valence } = event;
          if (valence > this.etherealConfig.emotionalThreshold) {
            this.triggerEtherealBeauty(intensity, valence);
          }
        }
        /**
         * Handle gentle transitions
         */
        onGentleTransition(event) {
          const { fromState, toState, duration } = event;
          this.createGentleTransition(fromState, toState, duration);
          this.performanceMetrics.gentleTransitionCount++;
        }
        /**
         * Trigger ethereal beauty effect
         */
        triggerEtherealBeauty(intensity, valence) {
          const startTime = performance.now();
          this.etherealState.dreamyTranslucency = 0.8 + valence * 0.2;
          this.etherealState.targetEmotionalIntensity = Math.max(
            this.etherealState.targetEmotionalIntensity,
            intensity * 0.8
          );
          this.etherealState.targetBeautyLevel = Math.max(
            this.etherealState.targetBeautyLevel,
            valence * 0.9
          );
          this.etherealState.targetMysticalShimmer = Math.max(
            this.etherealState.targetMysticalShimmer,
            valence * 0.6
          );
          this.performanceMetrics.emotionalMomentCount++;
          this.performanceMetrics.lastUpdateTime = performance.now() - startTime;
          console.log(`[SoftGlowEffectsManager] \u2728 Ethereal beauty awakened! Intensity: ${intensity.toFixed(2)}, Valence: ${valence.toFixed(2)}`);
        }
        /**
         * Update ethereal state with LERP smoothing towards target values
         * This replaces the old frame-rate dependent decay system
         */
        updateEtherealStateWithLERP(deltaTimeSeconds) {
          this.etherealState.emotionalIntensity = lerpSmooth(
            this.etherealState.emotionalIntensity,
            this.etherealState.targetEmotionalIntensity,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.emotionalIntensity
          );
          this.etherealState.beautyLevel = lerpSmooth(
            this.etherealState.beautyLevel,
            this.etherealState.targetBeautyLevel,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.beautyLevel
          );
          this.etherealState.mysticalShimmer = lerpSmooth(
            this.etherealState.mysticalShimmer,
            this.etherealState.targetMysticalShimmer,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.mysticalShimmer
          );
          const autoDecayHalfLife = 1.5;
          this.etherealState.targetEmotionalIntensity = lerpSmooth(
            this.etherealState.targetEmotionalIntensity,
            0,
            // Decay towards zero
            deltaTimeSeconds,
            autoDecayHalfLife
          );
          this.etherealState.targetBeautyLevel = lerpSmooth(
            this.etherealState.targetBeautyLevel,
            0,
            // Decay towards zero
            deltaTimeSeconds,
            autoDecayHalfLife * 1.2
            // Slower decay for beauty
          );
          this.etherealState.targetMysticalShimmer = lerpSmooth(
            this.etherealState.targetMysticalShimmer,
            0,
            // Decay towards zero
            deltaTimeSeconds,
            autoDecayHalfLife * 0.8
            // Faster decay for shimmer
          );
        }
        /**
         * Update ethereal state from current music
         */
        updateEtherealFromMusic() {
          const musicState = this.musicSyncService.getCurrentMusicState();
          if (!musicState) return;
          const { emotion, beat, intensity } = musicState;
          if (emotion && emotion.valence > 0.5) {
            this.etherealState.mysticalShimmer = Math.max(
              this.etherealState.mysticalShimmer,
              emotion.valence * intensity * 0.5
            );
            if (beat && beat.tempo) {
              const tempoMultiplier = Math.min(1.5, beat.tempo / 100);
              this.etherealConfig.flowingGradientSpeed = 0.3 * tempoMultiplier;
            }
          }
        }
        /**
         * Update mystical effects
         */
        updateMysticalEffects() {
          const palette = this.etherealPalettes["dreamy-pastels"];
          const mapping = {
            primarySoft: this.blendSoftColors(
              palette.primarySoft,
              palette.mysticalGlow,
              this.etherealState.mysticalShimmer
            ),
            mysticalGlow: palette.mysticalGlow,
            dreamyMist: palette.dreamyMist,
            emotionalHeart: palette.emotionalHeart,
            etherealHighlight: palette.etherealHighlight,
            gentleTransparency: this.etherealState.dreamyTranslucency
          };
          this.updateEtherealCSSVariables(mapping);
        }
        /**
         * Blend soft colors for ethereal effects
         */
        blendSoftColors(soft, mystical, blendFactor) {
          const factor = Math.max(0, Math.min(1, blendFactor));
          return {
            r: Math.round(soft.r * (1 - factor) + mystical.r * factor),
            g: Math.round(soft.g * (1 - factor) + mystical.g * factor),
            b: Math.round(soft.b * (1 - factor) + mystical.b * factor)
          };
        }
        /**
         * Generate ethereal colors from consciousness palette
         */
        generateEtherealColors(palette, emotionalTemperature) {
          let selectedPalette = this.etherealPalettes["dreamy-pastels"];
          if (emotionalTemperature < 4e3) {
            selectedPalette = this.etherealPalettes["mystical-moonlight"];
          } else if (emotionalTemperature > 7e3) {
            selectedPalette = this.etherealPalettes["gentle-aurora"];
          }
          return {
            primarySoft: selectedPalette.primarySoft,
            mysticalGlow: selectedPalette.mysticalGlow,
            dreamyMist: selectedPalette.dreamyMist,
            emotionalHeart: selectedPalette.emotionalHeart,
            etherealHighlight: selectedPalette.etherealHighlight,
            gentleTransparency: this.etherealState.dreamyTranslucency
          };
        }
        /**
         * Update ethereal colors in CSS
         */
        updateEtherealColors(mapping) {
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--ethereal-soft-r",
            mapping.primarySoft.r.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--ethereal-soft-g",
            mapping.primarySoft.g.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--ethereal-soft-b",
            mapping.primarySoft.b.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--ethereal-mystical-r",
            mapping.mysticalGlow.r.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--ethereal-mystical-g",
            mapping.mysticalGlow.g.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--ethereal-mystical-b",
            mapping.mysticalGlow.b.toString()
          );
        }
        /**
         * Initialize ethereal UI elements
         */
        async initializeEtherealElements() {
          const etherealSelectors = [
            ".main-view-container",
            ".Root__now-playing-bar",
            ".main-trackInfo-container",
            ".cover-art",
            ".player-controls"
          ];
          for (const selector of etherealSelectors) {
            const elements = document.querySelectorAll(selector);
            for (const element of elements) {
              const id = `ethereal-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
              this.etherealElements.set(id, element);
            }
          }
        }
        /**
         * Setup CSS variables for ethereal effects
         */
        setupEtherealCSSVariables() {
          const baseVariables = {
            "--ethereal-soft-r": "203",
            "--ethereal-soft-g": "166",
            "--ethereal-soft-b": "247",
            "--ethereal-mystical-r": "148",
            "--ethereal-mystical-g": "226",
            "--ethereal-mystical-b": "213",
            "--ethereal-dreamy-r": "245",
            "--ethereal-dreamy-g": "224",
            "--ethereal-dreamy-b": "220",
            "--ethereal-beauty-level": "0",
            "--ethereal-mystical-shimmer": "0",
            "--ethereal-gentle-transparency": "0.9",
            "--ethereal-flowing-phase": "0",
            "--ethereal-emotional-pulse": "0"
          };
          for (const [variable, value] of Object.entries(baseVariables)) {
            this.cssConsciousnessController.queueCSSVariableUpdate(variable, value);
          }
        }
        /**
         * Update ethereal CSS variables
         */
        updateEtherealCSSVariables(mapping) {
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--ethereal-beauty-level",
            this.etherealState.beautyLevel.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--ethereal-mystical-shimmer",
            this.etherealState.mysticalShimmer.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--ethereal-gentle-transparency",
            mapping.gentleTransparency.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--ethereal-flowing-phase",
            this.animationState.flowingPhase.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--ethereal-emotional-pulse",
            Math.sin(this.animationState.emotionalPulsePhase).toString()
          );
        }
        /**
         * Update ethereal elements
         */
        updateEtherealElements() {
          for (const [id, element] of this.etherealElements) {
            this.updateEtherealElement(element);
          }
        }
        /**
         * Update single ethereal element
         */
        updateEtherealElement(element) {
          if (this.etherealState.beautyLevel > 0.1) {
            this.applyEtherealBeauty(element);
          }
          if (this.etherealState.mysticalShimmer > 0.1) {
            this.applyMysticalShimmer(element);
          }
          this.applyFlowingGradients(element);
        }
        /**
         * Apply ethereal beauty effect to element
         */
        applyEtherealBeauty(element) {
          const beautyIntensity = this.etherealState.beautyLevel;
          const emotionalPulse = Math.sin(this.animationState.emotionalPulsePhase) * 0.5 + 0.5;
          const glowIntensity = beautyIntensity * emotionalPulse * 0.6;
          element.style.boxShadow = `
      0 0 ${glowIntensity * 30}px rgba(var(--ethereal-soft-r), var(--ethereal-soft-g), var(--ethereal-soft-b), ${glowIntensity * 0.6}),
      inset 0 0 ${glowIntensity * 20}px rgba(var(--ethereal-mystical-r), var(--ethereal-mystical-g), var(--ethereal-mystical-b), ${glowIntensity * 0.3})
    `;
          const transparency = 0.9 + beautyIntensity * 0.1;
          element.style.opacity = transparency.toString();
        }
        /**
         * Apply mystical shimmer effect
         */
        applyMysticalShimmer(element) {
          const shimmerIntensity = this.etherealState.mysticalShimmer;
          const mysticalPhase = this.animationState.mysticalPhase;
          const shimmerOffset = Math.sin(mysticalPhase * 2) * shimmerIntensity * 2;
          const shimmerScale = 1 + Math.cos(mysticalPhase * 1.5) * shimmerIntensity * 0.05;
          element.style.transform = `translate(${shimmerOffset}px, 0) scale(${shimmerScale})`;
          const hueShift = Math.sin(mysticalPhase * 0.8) * shimmerIntensity * 15;
          element.style.filter = `hue-rotate(${hueShift}deg) saturate(${1 + shimmerIntensity * 0.3})`;
        }
        /**
         * Apply flowing gradients
         */
        applyFlowingGradients(element) {
          const flowingPhase = this.animationState.flowingPhase;
          const flowIntensity = this.etherealState.beautyLevel * 0.8;
          if (flowIntensity > 0.1) {
            const gradientPosition = (Math.sin(flowingPhase) + 1) * 50;
            element.style.background = `
        ${element.style.background || ""},
        linear-gradient(
          ${gradientPosition}deg,
          rgba(var(--ethereal-soft-r), var(--ethereal-soft-g), var(--ethereal-soft-b), ${flowIntensity * 0.1}) 0%,
          rgba(var(--ethereal-mystical-r), var(--ethereal-mystical-g), var(--ethereal-mystical-b), ${flowIntensity * 0.15}) 50%,
          rgba(var(--ethereal-dreamy-r), var(--ethereal-dreamy-g), var(--ethereal-dreamy-b), ${flowIntensity * 0.05}) 100%
        )
      `;
          }
        }
        /**
         * Create gentle transition between states
         */
        createGentleTransition(fromState, toState, duration) {
          const startTime = performance.now();
          const transition = /* @__PURE__ */ __name((currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(1, elapsed / duration);
            const eased = 1 - Math.pow(1 - progress, 3);
            this.etherealState.beautyLevel = fromState.beauty + (toState.beauty - fromState.beauty) * eased;
            this.etherealState.mysticalShimmer = fromState.shimmer + (toState.shimmer - fromState.shimmer) * eased;
            if (progress < 1) {
              requestAnimationFrame(transition);
            }
          }, "transition");
          requestAnimationFrame(transition);
        }
        /**
         * Start ethereal animation loop
         */
        startEtherealAnimation() {
          this.animationState.isAnimating = true;
          this.animationState.lastFrameTime = performance.now();
          const animate = /* @__PURE__ */ __name((currentTime) => {
            if (!this.animationState.isAnimating) return;
            const deltaTime = currentTime - this.animationState.lastFrameTime;
            this.animationState.lastFrameTime = currentTime;
            this.updateAnimation(deltaTime);
            requestAnimationFrame(animate);
          }, "animate");
          requestAnimationFrame(animate);
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics(deltaTime) {
          this.performanceMetrics.averageProcessingTime = this.performanceMetrics.averageProcessingTime * 0.9 + deltaTime * 0.1;
        }
        /**
         * Force repaint for immediate visual updates
         */
        forceRepaint(reason) {
          console.log(`[SoftGlowEffectsManager] Force repaint triggered: ${reason || "Unknown"}`);
          this.updateEtherealElements();
          this.cssConsciousnessController.flushCSSVariableBatch();
        }
        /**
         * Cleanup and destroy the engine
         */
        destroy() {
          console.log("[SoftGlowEffectsManager] Dissolving ethereal beauty...");
          this.animationState.isAnimating = false;
          this.etherealElements.clear();
          this.etherealState = {
            emotionalIntensity: 0,
            beautyLevel: 0,
            gentleness: 0.8,
            mysticalShimmer: 0,
            dreamyTranslucency: 0.9,
            flowingGradientPhase: 0,
            emotionalResonance: 0,
            softnessFactor: 1,
            // Reset target values too
            targetEmotionalIntensity: 0,
            targetBeautyLevel: 0,
            targetMysticalShimmer: 0
          };
          this.initialized = false;
        }
        // Public API methods
        getEtherealState() {
          return { ...this.etherealState };
        }
        getEtherealConfig() {
          return { ...this.etherealConfig };
        }
        getPerformanceMetrics() {
          return {
            ...this.performanceMetrics,
            etherealElementCount: this.etherealElements.size
          };
        }
        setEmotionalThreshold(threshold) {
          this.etherealConfig.emotionalThreshold = Math.max(0, Math.min(1, threshold));
        }
        setMaxBeautyIntensity(intensity) {
          this.etherealConfig.maxBeautyIntensity = Math.max(0, Math.min(1, intensity));
        }
        setGentleness(gentleness) {
          this.etherealState.gentleness = Math.max(0, Math.min(1, gentleness));
        }
      };
      __name(_SoftGlowEffectsManager, "SoftGlowEffectsManager");
      SoftGlowEffectsManager = _SoftGlowEffectsManager;
    }
  });

  // src-js/visual/effects/NaturalHarmonyEngine.ts
  var _NaturalHarmonyEngine, NaturalHarmonyEngine;
  var init_NaturalHarmonyEngine = __esm({
    "src-js/visual/effects/NaturalHarmonyEngine.ts"() {
      "use strict";
      init_UnifiedEventBus();
      _NaturalHarmonyEngine = class _NaturalHarmonyEngine {
        constructor(holographicSystem, cssConsciousnessController, musicSyncService) {
          this.initialized = false;
          this.naturalElements = /* @__PURE__ */ new Map();
          // Performance tracking
          this.performanceMetrics = {
            peacefulMomentCount: 0,
            averageProcessingTime: 0,
            lastUpdateTime: 0,
            breathingCycleCount: 0
          };
          // Animation state
          this.animationState = {
            breathingPhase: 0,
            // Main breathing cycle phase
            seasonalPhase: 0,
            // Seasonal transition phase
            organicPhase: 0,
            // Organic variation phase
            harmonyPhase: 0,
            // Natural harmony phase
            lastFrameTime: 0,
            isAnimating: false
          };
          // Natural color palettes for different seasons/moods
          this.naturalPalettes = {
            "spring-awakening": {
              earthyWarm: { r: 166, g: 227, b: 161 },
              // Catppuccin green (spring)
              forestGreen: { r: 64, g: 160, b: 43 },
              // Deep forest green
              skyBlue: { r: 137, g: 220, b: 235 },
              // Catppuccin sky
              sunsetGlow: { r: 250, g: 179, b: 135 },
              // Catppuccin peach
              stoneGray: { r: 108, g: 112, b: 134 }
              // Catppuccin overlay0
            },
            "summer-warmth": {
              earthyWarm: { r: 249, g: 226, b: 175 },
              // Catppuccin yellow (warm)
              forestGreen: { r: 166, g: 227, b: 161 },
              // Catppuccin green
              skyBlue: { r: 116, g: 199, b: 236 },
              // Catppuccin sapphire
              sunsetGlow: { r: 250, g: 179, b: 135 },
              // Catppuccin peach
              stoneGray: { r: 147, g: 153, b: 178 }
              // Catppuccin overlay2
            },
            "autumn-grounding": {
              earthyWarm: { r: 250, g: 179, b: 135 },
              // Catppuccin peach (autumn)
              forestGreen: { r: 148, g: 226, b: 213 },
              // Catppuccin teal
              skyBlue: { r: 137, g: 180, b: 250 },
              // Catppuccin blue
              sunsetGlow: { r: 235, g: 160, b: 172 },
              // Catppuccin flamingo
              stoneGray: { r: 127, g: 132, b: 156 }
              // Catppuccin overlay1
            },
            "winter-peace": {
              earthyWarm: { r: 186, g: 194, b: 222 },
              // Catppuccin subtext1 (cool)
              forestGreen: { r: 148, g: 226, b: 213 },
              // Catppuccin teal
              skyBlue: { r: 137, g: 220, b: 235 },
              // Catppuccin sky
              sunsetGlow: { r: 203, g: 166, b: 247 },
              // Catppuccin mauve
              stoneGray: { r: 88, g: 91, b: 112 }
              // Catppuccin surface2
            }
          };
          this.holographicSystem = holographicSystem;
          this.cssConsciousnessController = cssConsciousnessController;
          this.musicSyncService = musicSyncService;
          this.breathingState = {
            serenityLevel: 0,
            breathingFrequency: 0.4,
            // Natural resting frequency (0.4Hz = 24 breaths/min)
            organicDepth: 0.8,
            // Deep, natural breathing
            earthConnection: 0,
            naturalWarmth: 0.7,
            // Warm, grounded feeling
            forestAtmosphere: 0,
            seasonalShift: 0,
            harmonyResonance: 0
          };
          this.harmonyConfig = {
            peacefulThreshold: 0.3,
            // Activate on low intensity (peaceful music)
            maxBreathingDepth: 0.9,
            // Deep natural breathing
            naturalFrequencyRange: [0.2, 0.8],
            // 0.2Hz (12 bpm) to 0.8Hz (48 bpm)
            earthyColorStrength: 0.6,
            // Moderate earthy color influence
            naturalTransitionDuration: 3e3,
            // 3-second natural transitions
            seasonalCycleSpeed: 0.1
            // Very slow seasonal cycles
          };
        }
        /**
         * Initialize the Natural Harmony Engine
         */
        async initialize() {
          if (this.initialized) return;
          try {
            console.log("[NaturalHarmonyEngine] Awakening natural harmony consciousness...");
            this.subscribeToNaturalConsciousness();
            await this.initializeNaturalElements();
            this.setupNaturalCSSVariables();
            this.startNaturalBreathing();
            this.initialized = true;
            console.log("[NaturalHarmonyEngine] \u{1F33F} Ready for natural harmony breathing");
          } catch (error) {
            console.error("[NaturalHarmonyEngine] Failed to initialize:", error);
            throw error;
          }
        }
        /**
         * Update animation frame for natural harmony effects
         */
        updateAnimation(deltaTime) {
          if (!this.initialized) return;
          const deltaSeconds = deltaTime / 1e3;
          this.animationState.breathingPhase += deltaSeconds * this.breathingState.breathingFrequency * 2 * Math.PI;
          this.animationState.seasonalPhase += deltaSeconds * this.harmonyConfig.seasonalCycleSpeed;
          this.animationState.organicPhase += deltaSeconds * 0.4;
          this.animationState.harmonyPhase += deltaSeconds * 0.6;
          this.updateNaturalFromMusic();
          this.updateOrganicBreathing();
          this.updateNaturalElements();
          this.updatePerformanceMetrics(deltaTime);
        }
        /**
         * Health check for natural harmony system
         */
        async healthCheck() {
          const isHealthy = this.initialized && this.breathingState.serenityLevel >= 0 && this.performanceMetrics.averageProcessingTime < 10;
          return {
            system: "NaturalHarmonyEngine",
            healthy: isHealthy,
            metrics: {
              peacefulMomentCount: this.performanceMetrics.peacefulMomentCount,
              processingTime: this.performanceMetrics.averageProcessingTime,
              naturalElementCount: this.naturalElements.size,
              breathingCycleCount: this.performanceMetrics.breathingCycleCount
            },
            issues: isHealthy ? [] : ["Performance degradation detected"]
          };
        }
        /**
         * Subscribe to natural consciousness events
         */
        subscribeToNaturalConsciousness() {
          unifiedEventBus.subscribe("emotionalColorContext:updated", (event) => {
            this.onColorConsciousnessUpdate(event);
          });
          unifiedEventBus.subscribe("emotion:analyzed", (event) => {
            this.onPeacefulMoment(event);
          });
          unifiedEventBus.subscribe("settings:visual-guide-changed", (event) => {
            this.onOrganicTransition(event);
          });
        }
        /**
         * Handle color consciousness updates
         */
        onColorConsciousnessUpdate(event) {
          const { palette, consciousnessLevel, emotionalTemperature } = event;
          this.breathingState.harmonyResonance = consciousnessLevel * 0.8;
          if (emotionalTemperature < 5e3) {
            this.breathingState.earthConnection = consciousnessLevel * 0.6;
            this.breathingState.forestAtmosphere = consciousnessLevel * 0.4;
          } else {
            this.breathingState.naturalWarmth = consciousnessLevel * 0.8;
            this.breathingState.seasonalShift = consciousnessLevel * 0.5;
          }
          const naturalColors = this.generateNaturalColors(palette, emotionalTemperature);
          this.updateNaturalColors(naturalColors);
        }
        /**
         * Handle peaceful musical moments
         */
        onPeacefulMoment(event) {
          const { type, intensity, serenity } = event;
          this.triggerNaturalBreathing(intensity, serenity);
        }
        /**
         * Handle organic transitions
         */
        onOrganicTransition(event) {
          const { fromSeason, toSeason, duration } = event;
          this.createSeasonalTransition(fromSeason, toSeason, duration);
          this.performanceMetrics.breathingCycleCount++;
        }
        /**
         * Trigger natural harmony breathing effect
         */
        triggerNaturalBreathing(intensity, serenity) {
          const startTime = performance.now();
          this.breathingState.serenityLevel = serenity;
          this.breathingState.earthConnection = serenity * 0.7;
          this.breathingState.forestAtmosphere = serenity * 0.6;
          this.breathingState.naturalWarmth = 0.6 + serenity * 0.3;
          const naturalFreq = this.harmonyConfig.naturalFrequencyRange;
          this.breathingState.breathingFrequency = naturalFreq[0] + serenity * (naturalFreq[1] - naturalFreq[0]);
          setTimeout(() => {
            this.gentleDecayNaturalBreathing();
          }, this.harmonyConfig.naturalTransitionDuration);
          this.performanceMetrics.peacefulMomentCount++;
          this.performanceMetrics.lastUpdateTime = performance.now() - startTime;
          console.log(`[NaturalHarmonyEngine] \u{1F33F} Natural breathing awakened! Serenity: ${serenity.toFixed(2)}, Frequency: ${this.breathingState.breathingFrequency.toFixed(2)}Hz`);
        }
        /**
         * Gentle decay of natural breathing over time
         */
        gentleDecayNaturalBreathing() {
          const decayRate = 0.015;
          const decay = /* @__PURE__ */ __name(() => {
            this.breathingState.serenityLevel *= 1 - decayRate;
            this.breathingState.earthConnection *= 1 - decayRate * 0.8;
            this.breathingState.forestAtmosphere *= 1 - decayRate * 0.6;
            if (this.breathingState.serenityLevel > 0.05) {
              requestAnimationFrame(decay);
            } else {
              this.breathingState.serenityLevel = 0;
              this.breathingState.earthConnection = 0;
              this.breathingState.forestAtmosphere = 0;
            }
          }, "decay");
          requestAnimationFrame(decay);
        }
        /**
         * Update natural state from current music
         */
        updateNaturalFromMusic() {
          const musicState = this.musicSyncService.getCurrentMusicState();
          if (!musicState) return;
          const { emotion, beat, intensity } = musicState;
          if (emotion && intensity < this.harmonyConfig.peacefulThreshold) {
            this.breathingState.forestAtmosphere = Math.max(
              this.breathingState.forestAtmosphere,
              (1 - intensity) * 0.6
              // Higher atmosphere for lower intensity
            );
            if (beat && beat.tempo) {
              const tempoMultiplier = Math.max(0.5, Math.min(1.2, 60 / beat.tempo));
              this.breathingState.breathingFrequency = 0.4 * tempoMultiplier;
            }
          }
        }
        /**
         * Update organic breathing effects
         */
        updateOrganicBreathing() {
          const currentSeason = this.getCurrentSeason();
          const palette = this.naturalPalettes[currentSeason];
          const mapping = {
            earthyWarm: this.blendNaturalColors(
              palette.earthyWarm,
              palette.sunsetGlow,
              this.breathingState.naturalWarmth
            ),
            forestGreen: palette.forestGreen,
            skyBlue: palette.skyBlue,
            sunsetGlow: palette.sunsetGlow,
            stoneGray: palette.stoneGray,
            organicTransparency: 0.85 + this.breathingState.serenityLevel * 0.15
          };
          this.updateNaturalCSSVariables(mapping);
        }
        /**
         * Get current season based on seasonal phase
         */
        getCurrentSeason() {
          const seasonPhase = this.animationState.seasonalPhase % (2 * Math.PI);
          const normalizedPhase = seasonPhase / (2 * Math.PI);
          if (normalizedPhase < 0.25) return "spring-awakening";
          if (normalizedPhase < 0.5) return "summer-warmth";
          if (normalizedPhase < 0.75) return "autumn-grounding";
          return "winter-peace";
        }
        /**
         * Blend natural colors for organic effects
         */
        blendNaturalColors(natural, warm, blendFactor) {
          const factor = Math.max(0, Math.min(1, blendFactor));
          return {
            r: Math.round(natural.r * (1 - factor) + warm.r * factor),
            g: Math.round(natural.g * (1 - factor) + warm.g * factor),
            b: Math.round(natural.b * (1 - factor) + warm.b * factor)
          };
        }
        /**
         * Generate natural colors from consciousness palette
         */
        generateNaturalColors(palette, emotionalTemperature) {
          let selectedPalette = this.naturalPalettes["spring-awakening"];
          if (emotionalTemperature < 4e3) {
            selectedPalette = this.naturalPalettes["winter-peace"];
          } else if (emotionalTemperature > 7e3) {
            selectedPalette = this.naturalPalettes["summer-warmth"];
          } else if (emotionalTemperature > 5500) {
            selectedPalette = this.naturalPalettes["autumn-grounding"];
          }
          return {
            earthyWarm: selectedPalette.earthyWarm,
            forestGreen: selectedPalette.forestGreen,
            skyBlue: selectedPalette.skyBlue,
            sunsetGlow: selectedPalette.sunsetGlow,
            stoneGray: selectedPalette.stoneGray,
            organicTransparency: this.breathingState.harmonyResonance
          };
        }
        /**
         * Update natural colors in CSS
         */
        updateNaturalColors(mapping) {
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-earthy-r",
            mapping.earthyWarm.r.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-earthy-g",
            mapping.earthyWarm.g.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-earthy-b",
            mapping.earthyWarm.b.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-forest-r",
            mapping.forestGreen.r.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-forest-g",
            mapping.forestGreen.g.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-forest-b",
            mapping.forestGreen.b.toString()
          );
        }
        /**
         * Initialize natural UI elements
         */
        async initializeNaturalElements() {
          const naturalSelectors = [
            ".main-view-container",
            ".Root__now-playing-bar",
            ".main-trackInfo-container",
            ".progress-bar",
            ".Root__nav-bar"
          ];
          for (const selector of naturalSelectors) {
            const elements = document.querySelectorAll(selector);
            for (const element of elements) {
              const id = `natural-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
              this.naturalElements.set(id, element);
            }
          }
        }
        /**
         * Setup CSS variables for natural effects
         */
        setupNaturalCSSVariables() {
          const baseVariables = {
            "--natural-earthy-r": "166",
            "--natural-earthy-g": "227",
            "--natural-earthy-b": "161",
            "--natural-forest-r": "64",
            "--natural-forest-g": "160",
            "--natural-forest-b": "43",
            "--natural-sky-r": "137",
            "--natural-sky-g": "220",
            "--natural-sky-b": "235",
            "--natural-serenity-level": "0",
            "--natural-breathing-frequency": "0.4",
            "--natural-earth-connection": "0",
            "--natural-breathing-depth": "0.8",
            "--natural-seasonal-shift": "0"
          };
          for (const [variable, value] of Object.entries(baseVariables)) {
            this.cssConsciousnessController.queueCSSVariableUpdate(variable, value);
          }
        }
        /**
         * Update natural CSS variables
         */
        updateNaturalCSSVariables(mapping) {
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-serenity-level",
            this.breathingState.serenityLevel.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-breathing-frequency",
            this.breathingState.breathingFrequency.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-earth-connection",
            this.breathingState.earthConnection.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-breathing-depth",
            this.breathingState.organicDepth.toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-seasonal-shift",
            this.breathingState.seasonalShift.toString()
          );
          const breathingValue = Math.sin(this.animationState.breathingPhase) * this.breathingState.organicDepth;
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--natural-breathing-phase",
            breathingValue.toString()
          );
        }
        /**
         * Update natural elements
         */
        updateNaturalElements() {
          for (const [id, element] of this.naturalElements) {
            this.updateNaturalElement(element);
          }
        }
        /**
         * Update single natural element
         */
        updateNaturalElement(element) {
          if (this.breathingState.serenityLevel > 0.1) {
            this.applyNaturalBreathing(element);
          }
          if (this.breathingState.earthConnection > 0.1) {
            this.applyEarthConnection(element);
          }
          if (this.breathingState.forestAtmosphere > 0.1) {
            this.applyForestAtmosphere(element);
          }
        }
        /**
         * Apply natural breathing effect to element
         */
        applyNaturalBreathing(element) {
          const breathingIntensity = this.breathingState.serenityLevel;
          const breathingPhase = Math.sin(this.animationState.breathingPhase);
          const breathingScale = 1 + breathingPhase * breathingIntensity * 0.02;
          const breathingOpacity = 0.9 + breathingPhase * breathingIntensity * 0.1;
          element.style.transform = `scale(${breathingScale})`;
          element.style.opacity = breathingOpacity.toString();
          const glowIntensity = breathingIntensity * (breathingPhase * 0.5 + 0.5) * 0.3;
          element.style.boxShadow = `
      0 0 ${glowIntensity * 20}px rgba(var(--natural-earthy-r), var(--natural-earthy-g), var(--natural-earthy-b), ${glowIntensity * 0.5}),
      inset 0 0 ${glowIntensity * 10}px rgba(var(--natural-forest-r), var(--natural-forest-g), var(--natural-forest-b), ${glowIntensity * 0.3})
    `;
        }
        /**
         * Apply earth connection effect
         */
        applyEarthConnection(element) {
          const connectionIntensity = this.breathingState.earthConnection;
          element.style.border = `1px solid rgba(var(--natural-earthy-r), var(--natural-earthy-g), var(--natural-earthy-b), ${connectionIntensity * 0.4})`;
          element.style.background = `
      ${element.style.background || ""},
      linear-gradient(180deg,
        rgba(var(--natural-earthy-r), var(--natural-earthy-g), var(--natural-earthy-b), ${connectionIntensity * 0.05}) 0%,
        rgba(var(--natural-forest-r), var(--natural-forest-g), var(--natural-forest-b), ${connectionIntensity * 0.08}) 100%
      )
    `;
        }
        /**
         * Apply forest atmosphere effect
         */
        applyForestAtmosphere(element) {
          const atmosphereIntensity = this.breathingState.forestAtmosphere;
          const organicPhase = this.animationState.organicPhase;
          const organicOffset = Math.sin(organicPhase * 0.8) * atmosphereIntensity * 1;
          element.style.transform += ` translateY(${organicOffset}px)`;
          const forestHue = Math.sin(organicPhase * 0.5) * atmosphereIntensity * 5;
          element.style.filter = `hue-rotate(${forestHue}deg) saturate(${1 + atmosphereIntensity * 0.2})`;
        }
        /**
         * Create seasonal transition between natural states
         */
        createSeasonalTransition(fromSeason, toSeason, duration) {
          const startTime = performance.now();
          const transition = /* @__PURE__ */ __name((currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(1, elapsed / duration);
            const eased = 0.5 * (1 - Math.cos(progress * Math.PI));
            this.breathingState.seasonalShift = eased;
            if (progress < 1) {
              requestAnimationFrame(transition);
            }
          }, "transition");
          requestAnimationFrame(transition);
        }
        /**
         * Start natural breathing animation loop
         */
        startNaturalBreathing() {
          this.animationState.isAnimating = true;
          this.animationState.lastFrameTime = performance.now();
          const animate = /* @__PURE__ */ __name((currentTime) => {
            if (!this.animationState.isAnimating) return;
            const deltaTime = currentTime - this.animationState.lastFrameTime;
            this.animationState.lastFrameTime = currentTime;
            this.updateAnimation(deltaTime);
            requestAnimationFrame(animate);
          }, "animate");
          requestAnimationFrame(animate);
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics(deltaTime) {
          this.performanceMetrics.averageProcessingTime = this.performanceMetrics.averageProcessingTime * 0.9 + deltaTime * 0.1;
        }
        /**
         * Force repaint for immediate visual updates
         */
        forceRepaint(reason) {
          console.log(`[NaturalHarmonyEngine] Force repaint triggered: ${reason || "Unknown"}`);
          this.updateNaturalElements();
          this.cssConsciousnessController.flushCSSVariableBatch();
        }
        /**
         * Cleanup and destroy the engine
         */
        destroy() {
          console.log("[NaturalHarmonyEngine] Returning to natural silence...");
          this.animationState.isAnimating = false;
          this.naturalElements.clear();
          this.breathingState = {
            serenityLevel: 0,
            breathingFrequency: 0.4,
            organicDepth: 0.8,
            earthConnection: 0,
            naturalWarmth: 0.7,
            forestAtmosphere: 0,
            seasonalShift: 0,
            harmonyResonance: 0
          };
          this.initialized = false;
        }
        // Public API methods
        getBreathingState() {
          return { ...this.breathingState };
        }
        getNaturalConfig() {
          return { ...this.harmonyConfig };
        }
        getPerformanceMetrics() {
          return {
            ...this.performanceMetrics,
            naturalElementCount: this.naturalElements.size
          };
        }
        setPeacefulThreshold(threshold) {
          this.harmonyConfig.peacefulThreshold = Math.max(0, Math.min(1, threshold));
        }
        setBreathingDepth(depth) {
          this.breathingState.organicDepth = Math.max(0, Math.min(1, depth));
        }
        setEarthyColorStrength(strength) {
          this.harmonyConfig.earthyColorStrength = Math.max(0, Math.min(1, strength));
        }
      };
      __name(_NaturalHarmonyEngine, "NaturalHarmonyEngine");
      NaturalHarmonyEngine = _NaturalHarmonyEngine;
    }
  });

  // src-js/visual/integration/VisualSystemFacade.ts
  var _VisualSystemFacade, VisualSystemFacade;
  var init_VisualSystemFacade = __esm({
    "src-js/visual/integration/VisualSystemFacade.ts"() {
      "use strict";
      init_CSSAnimationManager();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_colorStubs();
      init_WebGLGradientBackgroundSystem();
      init_CSSBlobFallbackSystem();
      init_UIVisualEffectsController();
      init_HeaderVisualEffectsController();
      init_UnifiedSidebarEffectsController();
      init_GradientConductor();
      init_MusicSyncVisualEffects();
      init_HolographicUISystem();
      init_InteractionTrackingSystem();
      init_SpotifyUIApplicationSystem();
      init_RedEnergyBurstSystem();
      init_SoftGlowEffectsManager();
      init_NaturalHarmonyEngine();
      _VisualSystemFacade = class _VisualSystemFacade {
        constructor(config, utils, year3000System2, cssConsciousnessController, performanceAnalyzer2, musicSyncService, settingsManager2, colorHarmonyEngine, eventBus, animationCoordinator) {
          this.colorHarmonyEngine = null;
          this.eventBus = null;
          // EventBus when available
          this.animationCoordinator = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Event handlers
          this.boundAdaptationHandler = null;
          this.boundSettingsHandler = null;
          // Monitoring intervals
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Event callbacks
          this.onSystemAdaptation = null;
          this.onHealthChange = null;
          this.onSystemCreated = null;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System2;
          this.cssConsciousnessController = cssConsciousnessController;
          this.performanceAnalyzer = performanceAnalyzer2;
          this.musicSyncService = musicSyncService;
          this.settingsManager = settingsManager2;
          this.colorHarmonyEngine = colorHarmonyEngine || null;
          this.eventBus = eventBus || null;
          this.animationCoordinator = animationCoordinator || null;
          this.deviceDetector = new DeviceCapabilityDetector();
          this.systemRegistry = /* @__PURE__ */ new Map();
          this.systemCache = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.bridgeConfig = {
            mode: "progressive",
            enablePerformanceMonitoring: true,
            enableAdaptiveQuality: true,
            enableEventCoordination: true,
            performanceThresholds: {
              minFPS: 45,
              maxMemoryMB: 50,
              thermalLimit: 70
            },
            qualityPreferences: {
              preferHighQuality: true,
              allowDynamicScaling: true,
              batteryConservation: false
            }
          };
          this.currentMetrics = this.createInitialMetrics();
          this.boundAdaptationHandler = this.handleAdaptationEvent.bind(this);
          this.boundSettingsHandler = this.handleSettingsChange.bind(this);
          this.registerVisualSystems();
          Y3KDebug?.debug?.log(
            "VisualSystemFacade",
            "Factory facade initialized with visual systems"
          );
        }
        registerVisualSystems() {
          this.systemRegistry.set(
            "SidebarConsciousness",
            UnifiedSidebarConsciousnessController
          );
          this.systemDependencies.set("SidebarConsciousness", [
            "eventBus",
            "musicSyncService"
          ]);
          this.systemRegistry.set(
            "UIEffectsConsciousness",
            ConsciousnessUIEffectsController
          );
          this.systemDependencies.set("UIEffectsConsciousness", [
            "eventBus",
            "musicSyncService",
            "cssConsciousnessController"
          ]);
          this.systemRegistry.set(
            "HeaderConsciousness",
            HeaderConsciousnessController
          );
          this.systemDependencies.set("HeaderConsciousness", [
            "eventBus",
            "musicSyncService",
            "colorHarmonyEngine"
          ]);
          this.systemRegistry.set("WebGLBackground", WebGLGradientBackgroundSystem);
          this.systemDependencies.set("WebGLBackground", [
            "performanceAnalyzer",
            "eventBus"
          ]);
          this.systemRegistry.set("CSSBlobFallback", CSSBlobFallbackSystem);
          this.systemDependencies.set("CSSBlobFallback", [
            "performanceAnalyzer",
            "musicSyncService",
            "settingsManager"
          ]);
          this.systemRegistry.set("OrganicBeatSync", OrganicBeatSyncConsciousness);
          this.systemDependencies.set("OrganicBeatSync", [
            "performanceAnalyzer",
            "cssConsciousnessController",
            "eventBus",
            "musicSyncService",
            "colorHarmonyEngine"
          ]);
          this.systemRegistry.set("InteractionTracking", InteractionTrackingSystem);
          this.systemDependencies.set("InteractionTracking", [
            "performanceAnalyzer",
            "cssConsciousnessController"
          ]);
          this.systemRegistry.set("SpotifyUIApplication", SpotifyUIApplicationSystem);
          this.systemDependencies.set("SpotifyUIApplication", ["year3000System"]);
          this.systemRegistry.set("CinematicDrama", RedEnergyBurstSystem);
          this.systemDependencies.set("CinematicDrama", [
            "performanceAnalyzer",
            "cssConsciousnessController",
            "musicSyncService",
            "colorHarmonyEngine",
            "eventBus"
          ]);
          this.systemRegistry.set("EtherealBeauty", SoftGlowEffectsManager);
          this.systemDependencies.set("EtherealBeauty", [
            "performanceAnalyzer",
            "cssConsciousnessController",
            "musicSyncService",
            "colorHarmonyEngine",
            "eventBus"
          ]);
          this.systemRegistry.set("NaturalHarmony", NaturalHarmonyEngine);
          this.systemDependencies.set("NaturalHarmony", [
            "performanceAnalyzer",
            "cssConsciousnessController",
            "musicSyncService",
            "colorHarmonyEngine",
            "eventBus"
          ]);
          this.systemRegistry.set("GradientConductor", GradientConductor);
          this.systemDependencies.set("GradientConductor", [
            "cssConsciousnessController",
            "colorHarmonyEngine",
            "musicSyncService",
            "performanceAnalyzer",
            "eventBus"
          ]);
          this.systemRegistry.set("CSSAnimationManager", CSSAnimationManager);
          this.systemDependencies.set("CSSAnimationManager", [
            "cssConsciousnessController",
            "animationCoordinator"
          ]);
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3KDebug?.debug?.warn("VisualSystemFacade", "Already initialized");
            return;
          }
          try {
            this.bridgeConfig = { ...this.bridgeConfig, ...config };
            await this.deviceDetector.initialize();
            await this.applyConfiguration();
            this.subscribeToEvents();
            this.startMonitoring();
            await this.performVisualHealthCheck();
            this.isInitialized = true;
            this.cssConsciousnessController.queueCSSVariableUpdate(
              "--sn-visual-bridge-active",
              "1"
            );
            this.cssConsciousnessController.queueCSSVariableUpdate(
              "--sn-visual-bridge-mode",
              this.bridgeConfig.mode
            );
            Y3KDebug?.debug?.log("VisualSystemFacade", "Facade fully initialized", {
              mode: this.bridgeConfig.mode,
              systemsRegistered: this.systemRegistry.size,
              performanceMonitoring: this.bridgeConfig.enablePerformanceMonitoring
            });
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualSystemFacade",
              "Initialization failed:",
              error
            );
            await this.cleanup();
            throw error;
          }
        }
        /**
         * Factory method to create and return visual systems
         * This is the main interface for the facade pattern
         */
        getVisualSystem(key) {
          if (this.systemCache.has(key)) {
            return this.systemCache.get(key);
          }
          const system = this.createVisualSystem(key);
          this.systemCache.set(key, system);
          this.currentMetrics.activeVisualSystems.push(key);
          if (this.onSystemCreated) {
            this.onSystemCreated(key, system);
          }
          return system;
        }
        /**
         * Create a new visual system instance with proper dependency injection
         */
        createVisualSystem(key) {
          const SystemClass = this.systemRegistry.get(key);
          if (!SystemClass) {
            throw new Error(`Visual system '${key}' not found in registry`);
          }
          const testInstance = new SystemClass(this.config);
          if (typeof testInstance._baseInitialize === "function") {
            const system2 = testInstance;
            this.injectUnifiedSystemDependencies(system2, key);
            return system2;
          }
          if (key === "SpotifyUIApplication") {
            const system2 = new SystemClass(this.year3000System);
            this.injectDependencies(system2, key);
            return system2;
          }
          if (key === "GradientConductor") {
            const system2 = new SystemClass(
              this.eventBus,
              this.cssConsciousnessController,
              this.colorHarmonyEngine,
              this.musicSyncService,
              this.performanceAnalyzer,
              {}
              // Default config
            );
            this.injectDependencies(system2, key);
            return system2;
          }
          if (key === "CSSAnimationManager") {
            const system2 = new SystemClass(
              this.config,
              this.cssConsciousnessController,
              this.animationCoordinator
            );
            this.injectDependencies(system2, key);
            return system2;
          }
          if (key === "CinematicDrama" || key === "EtherealBeauty" || key === "NaturalHarmony") {
            const biologicalManager = new VisualEffectsManager();
            const holographicSystem = new HolographicUISystem(
              biologicalManager,
              this.settingsManager,
              this.musicSyncService
            );
            const system2 = new SystemClass(
              holographicSystem,
              this.cssConsciousnessController,
              this.musicSyncService
            );
            this.injectDependencies(system2, key);
            return system2;
          }
          const system = new SystemClass(
            this.config,
            this.utils,
            this.performanceAnalyzer,
            this.musicSyncService,
            this.settingsManager,
            this.year3000System
          );
          this.injectDependencies(system, key);
          return system;
        }
        /**
         * Inject dependencies into visual systems
         */
        injectDependencies(system, key) {
          const dependencies = this.systemDependencies.get(key) || [];
          if (dependencies.includes("performanceAnalyzer") && system.setPerformanceAnalyzer) {
            system.setPerformanceAnalyzer(this.performanceAnalyzer);
          }
          if (dependencies.includes("cssConsciousnessController") && system.setOptimizedCSSVariableManager) {
            system.setOptimizedCSSVariableManager(
              this.cssConsciousnessController
            );
          }
          if (dependencies.includes("eventBus") && this.eventBus && system.setEventBus) {
            system.setEventBus(this.eventBus);
          }
          if (this.colorHarmonyEngine && system.setColorHarmonyEngine) {
            system.setColorHarmonyEngine(this.colorHarmonyEngine);
          }
          if (dependencies.includes("musicSyncService") && system.setMusicSyncService) {
            system.setMusicSyncService(this.musicSyncService);
          }
          if (dependencies.includes("animationCoordinator") && this.animationCoordinator && system.setAnimationCoordinator) {
            system.setAnimationCoordinator(this.animationCoordinator);
          }
          this.integratePerformanceMonitoring(system, key);
        }
        /**
         * Inject dependencies into UnifiedSystemBase-derived systems
         */
        injectUnifiedSystemDependencies(system, key) {
          if (this.cssConsciousnessController) {
            system.cssConsciousnessController = this.cssConsciousnessController;
          }
          if (this.performanceAnalyzer) {
            system.performanceAnalyzer = this.performanceAnalyzer;
          }
          if (this.year3000System) {
            globalThis.year3000System = this.year3000System;
          }
          this.integratePerformanceMonitoring(system, key);
        }
        /**
         * Integrate performance monitoring for visual systems
         */
        integratePerformanceMonitoring(system, key) {
          if (!this.bridgeConfig.enablePerformanceMonitoring) return;
          const originalUpdateAnimation = system.updateAnimation;
          if (typeof originalUpdateAnimation === "function") {
            system.updateAnimation = (deltaTime) => {
              const startTime = performance.now();
              originalUpdateAnimation.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer.recordMetric(
                `Visual_${key}`,
                endTime - startTime
              );
            };
          }
          const originalOnAnimate = system.onAnimate;
          if (typeof originalOnAnimate === "function") {
            system.onAnimate = (deltaTime) => {
              const startTime = performance.now();
              originalOnAnimate.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer.recordMetric(
                `Visual_${key}_Animate`,
                endTime - startTime
              );
            };
          }
        }
        /**
         * Apply adaptive quality control to visual systems
         */
        adaptiveQualityControl(system, key) {
          if (!this.eventBus) return;
          this.eventBus.subscribe("performance:degradation", (event) => {
            if (system.reduceQuality) {
              system.reduceQuality(event.reductionLevel);
            }
          });
          this.eventBus.subscribe("performance:improvement", (event) => {
            if (system.increaseQuality) {
              system.increaseQuality(event.improvementLevel);
            }
          });
        }
        /**
         * Handle adaptation events from the performance system
         */
        handleAdaptationEvent(event) {
          Y3KDebug?.debug?.log(
            "VisualSystemFacade",
            `Adaptation event: ${event.type}`,
            event.reason
          );
          this.currentMetrics.currentQuality = event.newSettings;
          this.systemCache.forEach((system, key) => {
            if (system.handleAdaptationEvent) {
              system.handleAdaptationEvent(event);
            }
          });
          if (this.onSystemAdaptation) {
            this.onSystemAdaptation(this.currentMetrics);
          }
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--sn-adaptive-quality",
            (event.newSettings.gradientComplexity || 0).toString()
          );
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--sn-adaptive-fps",
            (event.newSettings.animationFPS || 60).toString()
          );
        }
        /**
         * Propagate visual events to all systems
         */
        propagateVisualEvent(event) {
          if (!this.bridgeConfig.enableEventCoordination) return;
          this.systemCache.forEach((system, key) => {
            if (system.handleVisualEvent) {
              try {
                system.handleVisualEvent(event);
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "VisualSystemFacade",
                  `Error propagating event to ${key}:`,
                  error
                );
              }
            }
          });
          this.currentMetrics.eventCount++;
          this.currentMetrics.lastEventTime = performance.now();
        }
        /**
         * Initialize all visual systems at once
         */
        async initializeVisualSystems() {
          const initPromises = Array.from(this.systemCache.entries()).map(
            async ([key, system]) => {
              try {
                if (typeof system._baseInitialize === "function") {
                  await system._baseInitialize();
                } else {
                  await system.initialize();
                }
                Y3KDebug?.debug?.log(
                  "VisualSystemFacade",
                  `Initialized visual system: ${key}`
                );
                return { key, success: true };
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "VisualSystemFacade",
                  `Failed to initialize ${key}:`,
                  error
                );
                return { key, success: false, error };
              }
            }
          );
          const results = await Promise.allSettled(initPromises);
          const successCount = results.filter(
            (r) => r.status === "fulfilled" && r.value.success
          ).length;
          Y3KDebug?.debug?.log(
            "VisualSystemFacade",
            `Visual systems initialized: ${successCount}/${results.length}`
          );
          await this.registerQualityScalingSystems();
        }
        /**
         * Register QualityScalingCapable systems with SimplePerformanceCoordinator
         */
        async registerQualityScalingSystems() {
          try {
            const performanceOrchestrator = this.year3000System?.getCachedNonVisualSystem?.(
              "SimplePerformanceCoordinator"
            );
            const qualityScalingManager = this.year3000System?.getCachedNonVisualSystem?.(
              "QualityScalingManager"
            );
            if (!performanceOrchestrator) {
              Y3KDebug?.debug?.warn(
                "VisualSystemFacade",
                "SimplePerformanceCoordinator not available for quality scaling registration"
              );
              return;
            }
            if (!qualityScalingManager) {
              Y3KDebug?.debug?.warn(
                "VisualSystemFacade",
                "QualityScalingManager not available for quality scaling registration"
              );
              return;
            }
            for (const [key, system] of this.systemCache.entries()) {
              try {
                const qualityScalingSystem = system;
                if (typeof qualityScalingSystem.setQualityLevel === "function" && typeof qualityScalingSystem.getPerformanceImpact === "function" && typeof qualityScalingSystem.getQualityCapabilities === "function") {
                  performanceOrchestrator.registerSystem(key, qualityScalingSystem);
                  qualityScalingManager.registerSystem(key, qualityScalingSystem);
                  Y3KDebug?.debug?.log(
                    "VisualSystemFacade",
                    `Registered ${key} for quality scaling and performance orchestration`
                  );
                }
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "VisualSystemFacade",
                  `Failed to register ${key} for quality scaling:`,
                  error
                );
              }
            }
            await this.initializeConsciousnessAwareAdaptation(qualityScalingManager);
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualSystemFacade",
              "Failed to register quality scaling systems:",
              error
            );
          }
        }
        /**
         * Initialize consciousness-aware quality adaptation with music sync integration
         */
        async initializeConsciousnessAwareAdaptation(qualityScalingManager) {
          try {
            const musicSyncService = this.year3000System?.getCachedNonVisualSystem?.("MusicSyncService");
            if (!musicSyncService) {
              Y3KDebug?.debug?.warn(
                "VisualSystemFacade",
                "MusicSyncService not available for consciousness-aware adaptation"
              );
              return;
            }
            const adaptationInterval = setInterval(() => {
              try {
                const consciousnessIntensity = musicSyncService.getOverallIntensity?.() || 0.5;
                const musicEnergy = musicSyncService.getBeatStrength?.() || 0.5;
                qualityScalingManager.adaptToConsciousnessState(
                  consciousnessIntensity,
                  musicEnergy
                );
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "VisualSystemFacade",
                  "Error in consciousness-aware adaptation:",
                  error
                );
              }
            }, 2e3);
            this._consciousnessAdaptationInterval = adaptationInterval;
            Y3KDebug?.debug?.log(
              "VisualSystemFacade",
              "Consciousness-aware quality adaptation initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualSystemFacade",
              "Failed to initialize consciousness-aware adaptation:",
              error
            );
          }
        }
        /**
         * Perform health check on all visual systems
         */
        async performVisualHealthCheck() {
          const healthCheck = {
            overall: "good",
            systems: /* @__PURE__ */ new Map(),
            recommendations: [],
            timestamp: performance.now()
          };
          let healthyCount = 0;
          let totalCount = 0;
          for (const [key, system] of this.systemCache) {
            totalCount++;
            try {
              const systemHealth = system.healthCheck ? await system.healthCheck() : { status: "unknown", message: "No health check available" };
              const isHealthy = systemHealth.status === "healthy" || systemHealth.status === "good";
              if (isHealthy) healthyCount++;
              healthCheck.systems.set(key, {
                ok: isHealthy,
                details: systemHealth.message || systemHealth.details || "System operational"
              });
            } catch (error) {
              healthCheck.systems.set(key, {
                ok: false,
                details: `Health check failed: ${error}`
              });
            }
          }
          const healthPercentage = totalCount > 0 ? healthyCount / totalCount : 1;
          if (healthPercentage >= 0.9) {
            healthCheck.overall = "excellent";
          } else if (healthPercentage >= 0.7) {
            healthCheck.overall = "good";
          } else if (healthPercentage >= 0.5) {
            healthCheck.overall = "degraded";
            healthCheck.recommendations.push(
              "Some visual systems are experiencing issues"
            );
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push(
              "Multiple visual system failures detected"
            );
          }
          if (this.currentMetrics.currentFPS < 30) {
            healthCheck.recommendations.push(
              "Low FPS detected - consider reducing visual quality"
            );
          }
          if (this.currentMetrics.memoryUsageMB > 40) {
            healthCheck.recommendations.push(
              "High memory usage - consider optimizing visual systems"
            );
          }
          this.lastHealthCheck = healthCheck;
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--sn-visual-health",
            healthCheck.overall
          );
          return healthCheck;
        }
        // Utility methods
        createInitialMetrics() {
          return {
            currentFPS: 0,
            averageFPS: 0,
            frameTime: 0,
            memoryUsageMB: 0,
            systemHealth: "good",
            activeVisualSystems: [],
            currentQuality: {
              gradientComplexity: 0.6,
              particleDensity: 0.6,
              shaderPrecision: "medium",
              textureResolution: 1,
              animationFPS: 60,
              transitionQuality: "smooth",
              motionBlur: false,
              bloomEnabled: true,
              shadowQuality: "medium",
              antiAliasing: "fxaa",
              postProcessing: true
            },
            adaptiveScaling: true,
            performanceMonitoring: true,
            eventCoordination: true,
            lastEventTime: 0,
            eventCount: 0
          };
        }
        async applyConfiguration() {
        }
        subscribeToEvents() {
          if (this.settingsManager && this.boundSettingsHandler) {
            document.addEventListener(
              "year3000SystemSettingsChanged",
              this.boundSettingsHandler
            );
          }
        }
        startMonitoring() {
          if (this.bridgeConfig.enablePerformanceMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performVisualHealthCheck();
            }, 1e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 1e3);
          }
        }
        updateMetrics() {
          this.currentMetrics.currentFPS = this.performanceAnalyzer.getMedianFPS() || 0;
          this.currentMetrics.frameTime = this.currentMetrics.currentFPS > 0 ? 1e3 / this.currentMetrics.currentFPS : 1e3;
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.memoryUsageMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          if (this.currentMetrics.currentFPS < 20) {
            this.currentMetrics.systemHealth = "critical";
          } else if (this.currentMetrics.currentFPS < 30) {
            this.currentMetrics.systemHealth = "degraded";
          } else if (this.currentMetrics.currentFPS > 55) {
            this.currentMetrics.systemHealth = "excellent";
          } else {
            this.currentMetrics.systemHealth = "good";
          }
        }
        handleSettingsChange(event) {
          const customEvent = event;
          const { key, value } = customEvent.detail;
          if (key.startsWith("sn-visual-")) {
            this.updateConfigurationFromSettings(key, value);
          }
        }
        updateConfigurationFromSettings(key, value) {
          switch (key) {
            case "sn-visual-quality":
              this.bridgeConfig.qualityPreferences.preferHighQuality = value === "high";
              break;
            case "sn-visual-performance":
              this.bridgeConfig.enableAdaptiveQuality = value === "adaptive";
              break;
          }
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          if (this._consciousnessAdaptationInterval) {
            clearInterval(this._consciousnessAdaptationInterval);
            this._consciousnessAdaptationInterval = null;
          }
          if (this.boundSettingsHandler) {
            document.removeEventListener(
              "year3000SystemSettingsChanged",
              this.boundSettingsHandler
            );
          }
          this.cssConsciousnessController.queueCSSVariableUpdate(
            "--sn-visual-bridge-active",
            "0"
          );
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.bridgeConfig };
        }
        async setConfiguration(config) {
          this.bridgeConfig = { ...this.bridgeConfig, ...config };
          await this.applyConfiguration();
        }
        setOnSystemAdaptation(callback) {
          this.onSystemAdaptation = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            systemsActive: this.systemCache.size,
            healthy: this.currentMetrics.systemHealth === "excellent" || this.currentMetrics.systemHealth === "good"
          };
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          this.systemCache.clear();
          Y3KDebug?.debug?.log("VisualSystemFacade", "Facade destroyed");
        }
      };
      __name(_VisualSystemFacade, "VisualSystemFacade");
      VisualSystemFacade = _VisualSystemFacade;
    }
  });

  // src-js/core/integration/SystemCoordinator.ts
  var _SystemCoordinator, SystemCoordinator;
  var init_SystemCoordinator = __esm({
    "src-js/core/integration/SystemCoordinator.ts"() {
      "use strict";
      init_ColorHarmonyEngine();
      init_MusicSyncService();
      init_OptimizedCSSVariableManager();
      init_NonVisualSystemFacade();
      init_SimplePerformanceCoordinator();
      init_EnhancedDeviceTierDetector();
      init_WebGLSystemsIntegration();
      init_DeviceCapabilityDetector();
      init_PerformanceBudgetManager();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_SemanticColorManager();
      init_VisualSystemFacade();
      _SystemCoordinator = class _SystemCoordinator {
        constructor(config, utils, year3000System2) {
          // Facade instances
          this.visualBridge = null;
          this.nonVisualFacade = null;
          // Shared dependencies (centrally managed)
          this.sharedUnifiedCSSVariableManager = null;
          // New simplified performance system
          this.sharedSimplePerformanceCoordinator = null;
          this.sharedWebGLSystemsIntegration = null;
          this.sharedEnhancedDeviceTierDetector = null;
          // Legacy systems (deprecated, maintained for compatibility during migration)
          // REMOVED: private sharedPerformanceAnalyzer: SimplePerformanceCoordinator | null = null; // Replaced with SimplePerformanceCoordinator
          this.sharedDeviceCapabilityDetector = null;
          this.sharedPerformanceBudgetManager = null;
          this.sharedMusicSyncService = null;
          this.sharedSettingsManager = null;
          this.sharedColorHarmonyEngine = null;
          this.sharedSemanticColorManager = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Color system coordination
          this.colorDependentSystems = /* @__PURE__ */ new Set();
          this.colorSystemRefreshCallbacks = /* @__PURE__ */ new Map();
          // Orchestration state
          this.currentPhase = "core";
          this.systemStates = /* @__PURE__ */ new Map();
          this.phaseCompletionPromises = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.initializationOrder = /* @__PURE__ */ new Map();
          // Event coordination
          this.eventBus = null;
          this.crossFacadeEventListeners = /* @__PURE__ */ new Map();
          // Monitoring
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Event callbacks
          this.onSystemCreated = null;
          this.onHealthChange = null;
          this.onPerformanceChange = null;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System2;
          this.coordinationConfig = {
            mode: "unified",
            enableSharedDependencies: true,
            enableCrossFacadeCommunication: true,
            enableUnifiedPerformanceMonitoring: true,
            enableResourceOptimization: true,
            orchestration: {
              enforceSequentialInitialization: true,
              dependencyValidation: true,
              enableInitializationGates: true,
              systemReadinessTimeout: 5e3,
              phaseTransitionTimeout: 1e4
            },
            performanceThresholds: {
              maxTotalMemoryMB: 150,
              maxTotalInitTime: 8e3,
              maxCrossCommLatency: 10
            },
            coordinationPreferences: {
              preferSharedResources: true,
              enableEventPropagation: true,
              enableHealthCoordination: true
            }
          };
          this.setupOrchestrationPhases();
          this.currentMetrics = this.createInitialMetrics();
          Y3KDebug?.debug?.log("SystemCoordinator", "System coordinator initialized");
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3KDebug?.debug?.warn("SystemCoordinator", "Already initialized");
            return;
          }
          try {
            const startTime = performance.now();
            this.coordinationConfig = { ...this.coordinationConfig, ...config };
            if (this.coordinationConfig.orchestration.enforceSequentialInitialization) {
              Y3KDebug?.debug?.log(
                "SystemCoordinator",
                "Starting orchestrated initialization"
              );
              await this.executeOrchestredInitialization();
            } else {
              Y3KDebug?.debug?.log(
                "SystemCoordinator",
                "Starting legacy initialization"
              );
              await this.executeLegacyInitialization();
            }
            const endTime = performance.now();
            this.currentMetrics.totalInitTime = endTime - startTime;
            this.isInitialized = true;
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "System coordination fully initialized",
              {
                mode: this.coordinationConfig.mode,
                orchestrationEnabled: this.coordinationConfig.orchestration.enforceSequentialInitialization,
                currentPhase: this.currentPhase,
                visualSystems: this.currentMetrics.visualSystems,
                nonVisualSystems: this.currentMetrics.nonVisualSystems,
                initTime: this.currentMetrics.totalInitTime
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Initialization failed:",
              error
            );
            await this.cleanup();
            throw error;
          }
        }
        async initializeSharedDependencies() {
          if (!this.coordinationConfig.enableSharedDependencies) return;
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "Initializing simplified shared dependencies"
          );
          try {
            this.sharedDeviceCapabilityDetector = new DeviceCapabilityDetector({
              enableDebug: true,
              // Enable debug for troubleshooting
              spicetifyContext: true
            });
            await this.sharedDeviceCapabilityDetector.initialize();
            this.sharedEnhancedDeviceTierDetector = new EnhancedDeviceTierDetector();
            this.sharedWebGLSystemsIntegration = new WebGLSystemsIntegration(
              this.sharedDeviceCapabilityDetector
            );
            await this.sharedWebGLSystemsIntegration.initialize();
            this.sharedDeviceCapabilityDetector = new DeviceCapabilityDetector({
              enableDebug: this.config.enableDebug || false,
              runStressTests: false
            });
            await this.sharedDeviceCapabilityDetector.initialize();
            this.sharedPerformanceBudgetManager = new PerformanceBudgetManager({
              budgets: {
                animationFrame: 16,
                cssVariableUpdate: 2,
                domObservation: 1,
                audioAnalysis: 5,
                visualEffects: 8,
                userInteraction: 100
              },
              autoOptimize: {
                enabled: true,
                violationThreshold: 3,
                recoveryThreshold: 0.8
              },
              enableDebug: this.config.enableDebug || false
            }, this.sharedSimplePerformanceCoordinator);
            this.sharedSimplePerformanceCoordinator = new SimplePerformanceCoordinator(
              this.sharedEnhancedDeviceTierDetector,
              this.sharedWebGLSystemsIntegration
            );
            await this.sharedSimplePerformanceCoordinator.initialize();
            try {
              const performanceCoordinatorCompat = this.sharedSimplePerformanceCoordinator;
              this.sharedUnifiedCSSVariableManager = new OptimizedCSSVariableManager(
                this.config,
                performanceCoordinatorCompat,
                {
                  enableAdaptiveThrottling: true,
                  batchIntervalMs: 16,
                  maxBatchSize: 50,
                  priorityMappings: {
                    critical: [
                      "--sn-rs-glow-alpha",
                      "--sn-rs-beat-intensity",
                      "--sn-rs-hue-shift",
                      "--sn-cosmic-base-hex",
                      "--sn-cosmic-accent-hex"
                    ],
                    high: [
                      "--sn-gradient-primary",
                      "--sn-gradient-secondary",
                      "--sn-gradient-accent",
                      "--sn-color-base-hex",
                      "--sn-color-accent-hex"
                    ],
                    normal: ["--sn-gradient-", "--sn-rs-", "--sn-color-"],
                    low: ["--sn-debug-", "--sn-dev-", "--sn-meta-"]
                  },
                  thresholds: {
                    excellentFPS: 55,
                    goodFPS: 45,
                    poorFPS: 30
                  }
                }
              );
              setGlobalOptimizedCSSController(this.sharedUnifiedCSSVariableManager);
              await this.sharedUnifiedCSSVariableManager.initialize();
            } catch (error) {
              Y3KDebug?.debug?.warn(
                "SystemCoordinator",
                "Failed to initialize OptimizedCSSVariableManager:",
                error
              );
              this.sharedUnifiedCSSVariableManager = null;
            }
            this.sharedSettingsManager = new SettingsManager();
            await this.sharedSettingsManager.initialize();
            this.sharedMusicSyncService = new MusicSyncService();
            await this.sharedMusicSyncService.initialize();
            this.sharedColorHarmonyEngine = new ColorHarmonyEngine(
              this.config,
              this.utils,
              this.sharedSimplePerformanceCoordinator,
              this.sharedSettingsManager
            );
            await this.sharedColorHarmonyEngine.initialize();
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "Shared dependencies initialized successfully"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Failed to initialize shared dependencies:",
              error
            );
            throw error;
          }
        }
        async initializeFacades() {
          Y3KDebug?.debug?.log("SystemCoordinator", "Initializing facades");
          try {
            const animationCoordinator = this.nonVisualFacade?.getCachedSystem("EnhancedMasterAnimationCoordinator") || null;
            this.visualBridge = new VisualSystemFacade(
              this.config,
              this.utils,
              this.year3000System,
              this.sharedUnifiedCSSVariableManager,
              this.sharedSimplePerformanceCoordinator,
              this.sharedMusicSyncService,
              this.sharedSettingsManager,
              this.sharedColorHarmonyEngine,
              this.eventBus,
              animationCoordinator
            );
            await this.visualBridge.initialize({
              mode: this.coordinationConfig.mode === "performance-optimized" ? "performance-first" : "progressive",
              enablePerformanceMonitoring: this.coordinationConfig.enableUnifiedPerformanceMonitoring,
              enableEventCoordination: this.coordinationConfig.enableCrossFacadeCommunication
            });
            this.visualBridge.setOnSystemCreated((key, system) => {
              this.handleSystemCreated("visual", key, system);
            });
            this.nonVisualFacade = new NonVisualSystemFacade(
              this.config,
              this.utils,
              this.year3000System
            );
            await this.nonVisualFacade.initialize({
              mode: this.coordinationConfig.mode === "performance-optimized" ? "performance-first" : "progressive",
              enablePerformanceMonitoring: this.coordinationConfig.enableUnifiedPerformanceMonitoring,
              enableDependencyInjection: this.coordinationConfig.enableSharedDependencies
            });
            this.nonVisualFacade.setOnSystemCreated((key, system) => {
              this.handleSystemCreated("non-visual", key, system);
            });
            this.injectSharedDependencies();
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "Facades initialized successfully"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Failed to initialize facades:",
              error
            );
            throw error;
          }
        }
        injectSharedDependencies() {
          if (!this.coordinationConfig.enableSharedDependencies || !this.nonVisualFacade)
            return;
          if (this.sharedSimplePerformanceCoordinator) {
            this.nonVisualFacade.simplePerformanceCoordinator = this.sharedSimplePerformanceCoordinator;
          }
          if (this.sharedWebGLSystemsIntegration) {
            this.nonVisualFacade.webglSystemsIntegration = this.sharedWebGLSystemsIntegration;
          }
          if (this.sharedEnhancedDeviceTierDetector) {
            this.nonVisualFacade.enhancedDeviceTierDetector = this.sharedEnhancedDeviceTierDetector;
          }
          if (this.sharedSimplePerformanceCoordinator) {
            this.nonVisualFacade.performanceAnalyzer = this.sharedSimplePerformanceCoordinator;
          }
          if (this.sharedUnifiedCSSVariableManager) {
            this.nonVisualFacade.cssConsciousnessController = this.sharedUnifiedCSSVariableManager;
          }
          if (this.sharedMusicSyncService) {
            this.nonVisualFacade.musicSyncService = this.sharedMusicSyncService;
          }
          if (this.sharedSettingsManager) {
            this.nonVisualFacade.settingsManager = this.sharedSettingsManager;
          }
          if (this.sharedColorHarmonyEngine) {
            this.nonVisualFacade.colorHarmonyEngine = this.sharedColorHarmonyEngine;
          }
          if (this.sharedSemanticColorManager) {
            this.nonVisualFacade.semanticColorManager = this.sharedSemanticColorManager;
          }
        }
        setupCrossFacadeCommunication() {
          if (!this.coordinationConfig.enableCrossFacadeCommunication) return;
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "Setting up cross-facade communication"
          );
          this.addEventListener("visual-event", (event) => {
            if (this.visualBridge) {
              this.visualBridge.propagateVisualEvent(event);
            }
          });
          this.addEventListener("performance-event", (event) => {
            if (this.visualBridge) {
              this.visualBridge.handleAdaptationEvent(event);
            }
          });
          if (this.coordinationConfig.coordinationPreferences.enableHealthCoordination) {
            this.addEventListener("health-degradation", (event) => {
              this.handleHealthDegradation(event);
            });
          }
        }
        handleSystemCreated(type, key, system) {
          if (type === "visual") {
            this.currentMetrics.visualSystems++;
          } else {
            this.currentMetrics.nonVisualSystems++;
          }
          this.currentMetrics.activeSystems++;
          if (this.onSystemCreated) {
            this.onSystemCreated(type, key, system);
          }
          Y3KDebug?.debug?.log("SystemCoordinator", `System created: ${type}/${key}`);
        }
        handleHealthDegradation(event) {
          Y3KDebug?.debug?.warn(
            "SystemCoordinator",
            "Health degradation detected:",
            event
          );
          if (this.coordinationConfig.mode === "performance-optimized") {
            this.optimizeForPerformance();
          }
        }
        optimizeForPerformance() {
          if (this.visualBridge) {
            this.visualBridge.setConfiguration({
              mode: "performance-first",
              enableAdaptiveQuality: true,
              qualityPreferences: {
                preferHighQuality: false,
                allowDynamicScaling: true,
                batteryConservation: true
              }
            });
          }
          if (this.nonVisualFacade) {
            this.nonVisualFacade.setConfiguration({
              mode: "performance-first",
              systemPreferences: {
                lazyInitialization: true,
                aggressiveCaching: true,
                performanceOptimization: true
              }
            });
          }
        }
        // Public API for facade access
        getVisualSystem(key) {
          if (!this.visualBridge) return null;
          return this.visualBridge.getVisualSystem(key);
        }
        getCachedNonVisualSystem(key) {
          if (!this.nonVisualFacade) return null;
          return this.nonVisualFacade.getCachedSystem(key);
        }
        async getNonVisualSystem(key) {
          if (!this.nonVisualFacade) return null;
          return await this.nonVisualFacade.getSystem(key);
        }
        async getSystem(key) {
          if (this.visualBridge) {
            try {
              return this.visualBridge.getVisualSystem(key);
            } catch (error) {
            }
          }
          if (this.nonVisualFacade) {
            try {
              return await this.nonVisualFacade.getSystem(
                key
              );
            } catch (error) {
            }
          }
          return null;
        }
        // Cross-facade event system
        addEventListener(eventType, listener) {
          if (!this.crossFacadeEventListeners.has(eventType)) {
            this.crossFacadeEventListeners.set(eventType, []);
          }
          this.crossFacadeEventListeners.get(eventType).push(listener);
        }
        removeEventListener(eventType, listener) {
          const listeners = this.crossFacadeEventListeners.get(eventType);
          if (listeners) {
            const index = listeners.indexOf(listener);
            if (index !== -1) {
              listeners.splice(index, 1);
            }
          }
        }
        emitEvent(eventType, event) {
          const listeners = this.crossFacadeEventListeners.get(eventType);
          if (listeners) {
            listeners.forEach((listener) => {
              try {
                listener(event);
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "SystemCoordinator",
                  `Error in event listener for ${eventType}:`,
                  error
                );
              }
            });
          }
          this.currentMetrics.crossFacadeEvents++;
        }
        // Health monitoring
        async performHealthCheck() {
          const healthCheck = {
            overall: "good",
            facades: {
              visual: {
                ok: true,
                details: "Visual systems operational",
                systemCount: 0
              },
              nonVisual: {
                ok: true,
                details: "Non-visual systems operational",
                systemCount: 0
              }
            },
            sharedResources: {
              simplePerformanceCoordinator: {
                ok: true,
                details: "Simple performance coordinator operational"
              },
              cssConsciousnessController: {
                ok: true,
                details: "CSS variable batcher operational"
              },
              musicSyncService: {
                ok: true,
                details: "Music sync service operational"
              },
              // Legacy systems (optional for backward compatibility)
              performanceAnalyzer: {
                ok: true,
                details: "Legacy performance analyzer operational"
              }
            },
            recommendations: [],
            timestamp: performance.now()
          };
          if (this.visualBridge) {
            try {
              const visualHealth = await this.visualBridge.performVisualHealthCheck();
              healthCheck.facades.visual.ok = visualHealth.overall === "excellent" || visualHealth.overall === "good";
              healthCheck.facades.visual.details = `Visual systems: ${visualHealth.overall}`;
              healthCheck.facades.visual.systemCount = visualHealth.systems.size;
            } catch (error) {
              healthCheck.facades.visual.ok = false;
              healthCheck.facades.visual.details = `Visual facade error: ${error}`;
            }
          }
          if (this.nonVisualFacade) {
            try {
              const nonVisualHealth = await this.nonVisualFacade.performHealthCheck();
              healthCheck.facades.nonVisual.ok = nonVisualHealth.overall === "excellent" || nonVisualHealth.overall === "good";
              healthCheck.facades.nonVisual.details = `Non-visual systems: ${nonVisualHealth.overall}`;
              healthCheck.facades.nonVisual.systemCount = nonVisualHealth.systems.size;
            } catch (error) {
              healthCheck.facades.nonVisual.ok = false;
              healthCheck.facades.nonVisual.details = `Non-visual facade error: ${error}`;
            }
          }
          if (this.sharedSimplePerformanceCoordinator) {
            try {
              const performanceHealth = await this.sharedSimplePerformanceCoordinator.healthCheck();
              healthCheck.sharedResources.simplePerformanceCoordinator.ok = performanceHealth.healthy;
              healthCheck.sharedResources.simplePerformanceCoordinator.details = performanceHealth.details || "Simple performance coordinator operational";
            } catch (error) {
              healthCheck.sharedResources.simplePerformanceCoordinator.ok = false;
              healthCheck.sharedResources.simplePerformanceCoordinator.details = `Simple performance coordinator error: ${error}`;
            }
          }
          if (this.sharedSimplePerformanceCoordinator) {
            try {
              const performanceHealth = await this.sharedSimplePerformanceCoordinator.healthCheck();
              healthCheck.sharedResources.performanceAnalyzer = {
                ok: performanceHealth.healthy,
                details: performanceHealth.details || "Simple performance coordinator operational"
              };
            } catch (error) {
              healthCheck.sharedResources.performanceAnalyzer = {
                ok: false,
                details: `Simple performance coordinator error: ${error}`
              };
            }
          }
          if (this.sharedUnifiedCSSVariableManager) {
            try {
              const cssHealth = await this.sharedUnifiedCSSVariableManager.healthCheck();
              healthCheck.sharedResources.cssConsciousnessController.ok = cssHealth.healthy || cssHealth.ok || false;
              healthCheck.sharedResources.cssConsciousnessController.details = cssHealth.details || "CSS consciousness controller operational";
            } catch (error) {
              healthCheck.sharedResources.cssConsciousnessController.ok = false;
              healthCheck.sharedResources.cssConsciousnessController.details = `CSS consciousness controller error: ${error}`;
            }
          }
          if (this.sharedMusicSyncService) {
            try {
              const musicHealth = await this.sharedMusicSyncService.healthCheck();
              healthCheck.sharedResources.musicSyncService.ok = musicHealth.status === "healthy";
              healthCheck.sharedResources.musicSyncService.details = musicHealth.message || "Music sync service operational";
            } catch (error) {
              healthCheck.sharedResources.musicSyncService.ok = false;
              healthCheck.sharedResources.musicSyncService.details = `Music sync service error: ${error}`;
            }
          }
          if (this.sharedSemanticColorManager) {
            try {
              const semanticColorHealth = await this.sharedSemanticColorManager.healthCheck();
              const semanticColorOk = semanticColorHealth.healthy;
              healthCheck.sharedResources.semanticColorManager = {
                ok: semanticColorOk,
                details: semanticColorHealth.details || "Semantic color manager operational"
              };
            } catch (error) {
              healthCheck.sharedResources.semanticColorManager = {
                ok: false,
                details: `Semantic color manager error: ${error}`
              };
            }
          }
          const facadeHealthy = healthCheck.facades.visual.ok && healthCheck.facades.nonVisual.ok;
          const resourcesHealthy = healthCheck.sharedResources.simplePerformanceCoordinator.ok && healthCheck.sharedResources.cssConsciousnessController.ok && healthCheck.sharedResources.musicSyncService.ok && healthCheck.sharedResources.semanticColorManager?.ok !== false && healthCheck.sharedResources.performanceAnalyzer?.ok !== false;
          if (facadeHealthy && resourcesHealthy) {
            healthCheck.overall = "excellent";
          } else if (facadeHealthy || resourcesHealthy) {
            healthCheck.overall = "good";
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push(
              "Multiple system failures detected - consider system restart"
            );
          }
          if (this.currentMetrics.totalMemoryMB > 120) {
            healthCheck.recommendations.push(
              "High memory usage - consider optimizing system memory"
            );
          }
          if (this.currentMetrics.totalInitTime > 6e3) {
            healthCheck.recommendations.push(
              "High initialization time - consider optimizing system startup"
            );
          }
          this.lastHealthCheck = healthCheck;
          if (this.onHealthChange) {
            this.onHealthChange(healthCheck);
          }
          return healthCheck;
        }
        // Utility methods
        createInitialMetrics() {
          return {
            totalSystems: 0,
            visualSystems: 0,
            nonVisualSystems: 0,
            activeSystems: 0,
            failedSystems: 0,
            totalMemoryMB: 0,
            totalInitTime: 0,
            averageSystemInitTime: 0,
            crossFacadeLatency: 0,
            overallHealth: "good",
            visualHealth: "good",
            nonVisualHealth: "good",
            sharedDependencies: 6,
            // Number of shared dependencies
            crossFacadeEvents: 0,
            resourceOptimization: 0
          };
        }
        startMonitoring() {
          if (this.coordinationConfig.enableUnifiedPerformanceMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performHealthCheck();
            }, 2e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 2e3);
          }
        }
        updateMetrics() {
          if (this.visualBridge) {
            const visualMetrics = this.visualBridge.getMetrics();
            this.currentMetrics.visualHealth = visualMetrics.systemHealth;
          }
          if (this.nonVisualFacade) {
            const nonVisualMetrics = this.nonVisualFacade.getMetrics();
            this.currentMetrics.nonVisualHealth = nonVisualMetrics.systemHealth;
          }
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.totalMemoryMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          if (this.currentMetrics.visualHealth === "excellent" && this.currentMetrics.nonVisualHealth === "excellent") {
            this.currentMetrics.overallHealth = "excellent";
          } else if (this.currentMetrics.visualHealth === "critical" || this.currentMetrics.nonVisualHealth === "critical") {
            this.currentMetrics.overallHealth = "critical";
          } else if (this.currentMetrics.visualHealth === "degraded" || this.currentMetrics.nonVisualHealth === "degraded") {
            this.currentMetrics.overallHealth = "degraded";
          } else {
            this.currentMetrics.overallHealth = "good";
          }
          if (this.onPerformanceChange) {
            this.onPerformanceChange(this.currentMetrics);
          }
        }
        // ============================================================================
        // Orchestration Methods - Enhanced Coordination Logic
        // ============================================================================
        setupOrchestrationPhases() {
          this.systemDependencies.set("MusicSyncService", []);
          this.systemDependencies.set("ColorHarmonyEngine", [
            "MusicSyncService",
            "SemanticColorManager"
          ]);
          this.systemDependencies.set("PerformanceAnalyzer", []);
          this.systemDependencies.set("UnifiedCSSVariableManager", [
            "PerformanceAnalyzer"
          ]);
          this.systemDependencies.set("SettingsManager", []);
          this.systemDependencies.set("SemanticColorManager", [
            "UnifiedCSSVariableManager"
          ]);
          this.initializationOrder.set("core", [
            "PerformanceAnalyzer",
            "UnifiedCSSVariableManager"
          ]);
          this.initializationOrder.set("services", [
            "SettingsManager",
            "MusicSyncService",
            "SemanticColorManager"
          ]);
          this.initializationOrder.set("visual-systems", ["ColorHarmonyEngine"]);
          this.initializationOrder.set("integration", [
            "VisualSystemFacade",
            "NonVisualSystemFacade"
          ]);
          for (const [phase, systems] of this.initializationOrder.entries()) {
            for (const system of systems) {
              this.systemStates.set(system, "uninitialized");
            }
          }
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "Orchestration phases configured",
            {
              phases: Array.from(this.initializationOrder.keys()),
              totalSystems: this.systemStates.size,
              dependencies: Object.fromEntries(this.systemDependencies)
            }
          );
        }
        async executeOrchestredInitialization() {
          const phases = [
            "core",
            "services",
            "visual-systems",
            "integration"
          ];
          for (const phase of phases) {
            Y3KDebug?.debug?.log("SystemCoordinator", `Starting phase: ${phase}`);
            this.currentPhase = phase;
            try {
              await this.executePhase(phase);
              Y3KDebug?.debug?.log(
                "SystemCoordinator",
                `Phase ${phase} completed successfully`
              );
            } catch (error) {
              Y3KDebug?.debug?.error(
                "SystemCoordinator",
                `Phase ${phase} failed:`,
                error
              );
              throw new Error(`Orchestration failed at phase ${phase}: ${error}`);
            }
          }
          this.currentPhase = "completed";
          this.setupCrossFacadeCommunication();
          await this.setupGradientSystemCoordination();
          this.setupDefaultColorDependentSystems();
          this.startMonitoring();
          await this.performHealthCheck();
        }
        async executePhase(phase) {
          const systems = this.initializationOrder.get(phase);
          if (!systems) {
            throw new Error(`Unknown phase: ${phase}`);
          }
          const initPromises = [];
          for (const systemName of systems) {
            initPromises.push(this.initializeSystemWithDependencies(systemName));
          }
          await Promise.all(initPromises);
          for (const systemName of systems) {
            const state = this.systemStates.get(systemName);
            if (state !== "ready") {
              throw new Error(
                `System ${systemName} not ready after phase ${phase} (state: ${state})`
              );
            }
          }
        }
        async initializeSystemWithDependencies(systemName) {
          if (this.systemStates.get(systemName) === "ready") {
            return;
          }
          this.systemStates.set(systemName, "initializing");
          try {
            const dependencies = this.systemDependencies.get(systemName) || [];
            for (const dependency of dependencies) {
              await this.waitForSystemReady(dependency);
            }
            switch (systemName) {
              case "PerformanceAnalyzer":
                await this.initializePerformanceAnalyzer();
                break;
              case "UnifiedCSSVariableManager":
                await this.initializeUnifiedCSSController();
                break;
              case "SettingsManager":
                await this.initializeSettingsManager();
                break;
              case "MusicSyncService":
                await this.initializeMusicSyncService();
                break;
              case "ColorHarmonyEngine":
                await this.initializeColorHarmonyEngine();
                break;
              case "SemanticColorManager":
                await this.initializeSemanticColorManager();
                break;
              case "VisualSystemFacade":
                await this.initializeVisualFacade();
                break;
              case "NonVisualSystemFacade":
                await this.initializeNonVisualFacade();
                break;
              default:
                throw new Error(`Unknown system: ${systemName}`);
            }
            this.systemStates.set(systemName, "ready");
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              `System ${systemName} initialized successfully`
            );
          } catch (error) {
            this.systemStates.set(systemName, "failed");
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              `System ${systemName} initialization failed:`,
              error
            );
            throw error;
          }
        }
        async waitForSystemReady(systemName) {
          const timeout = this.coordinationConfig.orchestration.systemReadinessTimeout;
          const startTime = Date.now();
          while (Date.now() - startTime < timeout) {
            const state = this.systemStates.get(systemName);
            if (state === "ready") {
              return;
            }
            if (state === "failed") {
              throw new Error(`Dependency ${systemName} failed to initialize`);
            }
            await new Promise((resolve) => setTimeout(resolve, 50));
          }
          throw new Error(`Timeout waiting for dependency ${systemName} to be ready`);
        }
        // Individual system initialization methods
        async initializePerformanceAnalyzer() {
          if (!this.sharedDeviceCapabilityDetector) {
            this.sharedDeviceCapabilityDetector = new DeviceCapabilityDetector({
              enableDebug: true,
              // Enable debug for troubleshooting
              spicetifyContext: true
            });
            await this.sharedDeviceCapabilityDetector.initialize();
          }
          this.sharedEnhancedDeviceTierDetector = new EnhancedDeviceTierDetector();
          this.sharedWebGLSystemsIntegration = new WebGLSystemsIntegration(
            this.sharedDeviceCapabilityDetector
          );
          await this.sharedWebGLSystemsIntegration.initialize();
          this.sharedSimplePerformanceCoordinator = new SimplePerformanceCoordinator(
            this.sharedEnhancedDeviceTierDetector,
            this.sharedWebGLSystemsIntegration
          );
          await this.sharedSimplePerformanceCoordinator.initialize();
        }
        async initializeUnifiedCSSController() {
          if (!this.sharedSimplePerformanceCoordinator) {
            throw new Error("SimplePerformanceCoordinator dependency not available");
          }
          try {
            this.sharedDeviceCapabilityDetector = new DeviceCapabilityDetector({
              enableDebug: this.config.enableDebug || false,
              runStressTests: false
            });
            await this.sharedDeviceCapabilityDetector.initialize();
            this.sharedPerformanceBudgetManager = new PerformanceBudgetManager({
              budgets: {
                animationFrame: 16,
                cssVariableUpdate: 2,
                domObservation: 1,
                audioAnalysis: 5,
                visualEffects: 8,
                userInteraction: 100
              },
              autoOptimize: {
                enabled: true,
                violationThreshold: 3,
                recoveryThreshold: 0.8
              },
              enableDebug: this.config.enableDebug || false
            }, this.sharedSimplePerformanceCoordinator);
            const deviceCapabilities = this.sharedDeviceCapabilityDetector.getCapabilities();
            const minimalPerformanceCoordinator = {
              getCurrentPerformanceMode: /* @__PURE__ */ __name(() => ({
                name: "balanced",
                qualityLevel: 0.8,
                animationQuality: 0.8,
                effectQuality: 0.8,
                blurQuality: 0.8,
                shadowQuality: 0.8,
                frameRate: 60,
                optimizationLevel: 1
              }), "getCurrentPerformanceMode"),
              getDeviceCapabilities: /* @__PURE__ */ __name(() => deviceCapabilities || {
                performanceTier: "mid",
                memoryGB: 8,
                isMobile: false,
                gpuAcceleration: true
              }, "getDeviceCapabilities"),
              getBatteryState: /* @__PURE__ */ __name(() => ({ level: 1, charging: false }), "getBatteryState"),
              getThermalState: /* @__PURE__ */ __name(() => ({ temperature: "normal" }), "getThermalState")
            };
            this.sharedUnifiedCSSVariableManager = new OptimizedCSSVariableManager(
              this.config,
              minimalPerformanceCoordinator,
              {
                enableAdaptiveThrottling: true,
                batchIntervalMs: 16,
                maxBatchSize: 50,
                priorityMappings: {
                  critical: [
                    "--sn-rs-glow-alpha",
                    "--sn-rs-beat-intensity",
                    "--sn-rs-hue-shift",
                    "--sn-cosmic-base-hex",
                    "--sn-cosmic-accent-hex"
                  ],
                  high: [
                    "--sn-gradient-primary",
                    "--sn-gradient-secondary",
                    "--sn-gradient-accent",
                    "--sn-color-base-hex",
                    "--sn-color-accent-hex"
                  ],
                  normal: ["--sn-gradient-", "--sn-rs-", "--sn-color-"],
                  low: ["--sn-debug-", "--sn-dev-", "--sn-meta-"]
                },
                thresholds: {
                  excellentFPS: 55,
                  goodFPS: 45,
                  poorFPS: 30
                }
              }
            );
            setGlobalOptimizedCSSController(this.sharedUnifiedCSSVariableManager);
            await this.sharedUnifiedCSSVariableManager.initialize();
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "SystemCoordinator",
              "Failed to initialize OptimizedCSSVariableManager:",
              error
            );
            this.sharedUnifiedCSSVariableManager = null;
          }
        }
        async initializeSettingsManager() {
          this.sharedSettingsManager = new SettingsManager();
          await this.sharedSettingsManager.initialize();
        }
        async initializeMusicSyncService() {
          this.sharedMusicSyncService = new MusicSyncService({
            YEAR3000_CONFIG: this.config,
            Year3000Utilities: this.utils,
            performanceMonitor: this.sharedSimplePerformanceCoordinator,
            settingsManager: this.sharedSettingsManager,
            year3000System: this.year3000System
          });
          await this.sharedMusicSyncService.initialize();
        }
        async initializeSemanticColorManager() {
          if (!this.sharedUnifiedCSSVariableManager) {
            throw new Error(
              "OptimizedCSSVariableManager dependency not available"
            );
          }
          this.sharedSemanticColorManager = new SemanticColorManager({
            enableDebug: this.config.enableDebug || false,
            fallbackToSpiceColors: true,
            cacheDuration: 5e3
          });
          await this.sharedSemanticColorManager.initialize(
            this.sharedUnifiedCSSVariableManager
          );
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "SemanticColorManager initialized successfully",
            {
              systemMetrics: this.sharedSemanticColorManager.getSystemMetrics()
            }
          );
        }
        async initializeColorHarmonyEngine() {
          if (!this.sharedMusicSyncService) {
            throw new Error("MusicSyncService dependency not available");
          }
          if (!this.sharedSemanticColorManager) {
            throw new Error("SemanticColorManager dependency not available");
          }
          this.sharedColorHarmonyEngine = new ColorHarmonyEngine(
            this.config,
            this.utils,
            this.sharedSimplePerformanceCoordinator || void 0,
            this.sharedSettingsManager || void 0
          );
          await this.sharedColorHarmonyEngine.initialize();
        }
        async initializeVisualFacade() {
          this.visualBridge = new VisualSystemFacade(
            this.config,
            this.utils,
            this,
            // year3000System
            this.sharedUnifiedCSSVariableManager,
            // cssConsciousnessController
            this.sharedSimplePerformanceCoordinator,
            this.sharedMusicSyncService,
            this.sharedSettingsManager,
            this.sharedColorHarmonyEngine || void 0,
            // optional
            this.eventBus
            // optional
          );
          await this.visualBridge.initialize();
        }
        async initializeNonVisualFacade() {
          this.nonVisualFacade = new NonVisualSystemFacade(this.config, this.utils, {
            performanceAnalyzer: this.sharedSimplePerformanceCoordinator,
            unifiedCSSConsciousnessController: this.sharedUnifiedCSSVariableManager,
            musicSyncService: this.sharedMusicSyncService,
            settingsManager: this.sharedSettingsManager,
            colorHarmonyEngine: this.sharedColorHarmonyEngine,
            performanceOrchestrator: this.sharedSimplePerformanceCoordinator,
            semanticColorManager: this.sharedSemanticColorManager
          });
          await this.nonVisualFacade.initialize();
        }
        async executeLegacyInitialization() {
          await this.initializeSharedDependencies();
          await this.initializeFacades();
          this.setupCrossFacadeCommunication();
          await this.setupGradientSystemCoordination();
          this.setupDefaultColorDependentSystems();
          this.startMonitoring();
          await this.performHealthCheck();
        }
        // Public orchestration API
        getCurrentPhase() {
          return this.currentPhase;
        }
        getSystemState(systemName) {
          return this.systemStates.get(systemName);
        }
        getAllSystemStates() {
          return new Map(this.systemStates);
        }
        isOrchestrationEnabled() {
          return this.coordinationConfig.orchestration.enforceSequentialInitialization;
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          if (this.visualBridge) {
            await this.visualBridge.destroy();
            this.visualBridge = null;
          }
          if (this.nonVisualFacade) {
            await this.nonVisualFacade.destroy();
            this.nonVisualFacade = null;
          }
          if (this.sharedSimplePerformanceCoordinator) {
            this.sharedSimplePerformanceCoordinator.destroy();
            this.sharedSimplePerformanceCoordinator = null;
          }
          if (this.sharedWebGLSystemsIntegration) {
            this.sharedWebGLSystemsIntegration.destroy();
            this.sharedWebGLSystemsIntegration = null;
          }
          if (this.sharedEnhancedDeviceTierDetector) {
            this.sharedEnhancedDeviceTierDetector = null;
          }
          if (this.sharedSemanticColorManager) {
            this.sharedSemanticColorManager.destroy();
            this.sharedSemanticColorManager = null;
          }
          if (this.sharedColorHarmonyEngine) {
            this.sharedColorHarmonyEngine.destroy();
            this.sharedColorHarmonyEngine = null;
          }
          if (this.sharedMusicSyncService) {
            this.sharedMusicSyncService.destroy();
            this.sharedMusicSyncService = null;
          }
          if (this.sharedSettingsManager) {
            this.sharedSettingsManager.destroy();
            this.sharedSettingsManager = null;
          }
          if (this.sharedUnifiedCSSVariableManager) {
            this.sharedUnifiedCSSVariableManager.destroy();
            this.sharedUnifiedCSSVariableManager = null;
          }
          if (this.sharedSimplePerformanceCoordinator) {
            this.sharedSimplePerformanceCoordinator.destroy();
            this.sharedSimplePerformanceCoordinator = null;
          }
          if (this.sharedPerformanceBudgetManager) {
            this.sharedPerformanceBudgetManager.destroy();
            this.sharedPerformanceBudgetManager = null;
          }
          if (this.sharedDeviceCapabilityDetector) {
            this.sharedDeviceCapabilityDetector.destroy();
            this.sharedDeviceCapabilityDetector = null;
          }
          this.crossFacadeEventListeners.clear();
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.coordinationConfig };
        }
        async setConfiguration(config) {
          this.coordinationConfig = { ...this.coordinationConfig, ...config };
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        setOnPerformanceChange(callback) {
          this.onPerformanceChange = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            visualSystems: this.visualBridge?.getSystemStatus().systemsActive || 0,
            nonVisualSystems: this.nonVisualFacade?.getSystemStatus().systemsActive || 0,
            healthy: this.currentMetrics.overallHealth === "excellent" || this.currentMetrics.overallHealth === "good"
          };
        }
        // ============================================================================
        // Gradient System Coordination Methods
        // ============================================================================
        /**
         * Setup comprehensive gradient system coordination
         * This method coordinates all gradient-related systems after facades are initialized
         */
        async setupGradientSystemCoordination() {
          if (!this.visualBridge) {
            Y3KDebug?.debug?.warn(
              "SystemCoordinator",
              "VisualSystemFacade not available - skipping gradient system coordination"
            );
            return;
          }
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "Setting up gradient system coordination"
          );
          const gradientCoordinationStartTime = performance.now();
          let coordinatedSystems = 0;
          try {
            await this.coordinateGradientConductor();
            coordinatedSystems++;
            await this.coordinateWebGLGradientSystem();
            coordinatedSystems++;
            this.setupGradientSystemRefreshCallbacks();
            this.setupGradientSystemCommunication();
            const coordinationDuration = performance.now() - gradientCoordinationStartTime;
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "Gradient system coordination completed",
              {
                coordinatedSystems,
                duration: `${coordinationDuration.toFixed(2)}ms`,
                systems: [
                  "GradientConductor",
                  "WebGLGradientBackgroundSystem",
                  "GradientTransitionOrchestrator"
                ]
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Failed to setup gradient system coordination:",
              error
            );
            throw error;
          }
        }
        /**
         * Coordinate GradientConductor system through VisualSystemFacade
         */
        async coordinateGradientConductor() {
          try {
            const gradientConductor = this.visualBridge.getVisualSystem("GradientConductor");
            if (!gradientConductor) {
              Y3KDebug?.debug?.warn(
                "SystemCoordinator",
                "GradientConductor not available via VisualSystemFacade"
              );
              return;
            }
            this.addEventListener("gradient-conductor-event", (event) => {
              if (gradientConductor && typeof gradientConductor.handleSystemEvent === "function") {
                gradientConductor.handleSystemEvent(event);
              }
            });
            this.registerColorDependentSystem(
              "GradientConductor",
              async (trigger) => {
                if (gradientConductor && typeof gradientConductor.refreshColorState === "function") {
                  await gradientConductor.refreshColorState(trigger);
                } else if (gradientConductor && typeof gradientConductor.setPalette === "function") {
                  const colorHarmonyEngine = this.sharedColorHarmonyEngine;
                  if (colorHarmonyEngine) {
                    try {
                      const currentGradient = await colorHarmonyEngine.getCurrentGradient();
                      if (currentGradient) {
                        gradientConductor.setPalette(currentGradient);
                      }
                    } catch (error) {
                      Y3KDebug?.debug?.warn(
                        "SystemCoordinator",
                        "Failed to refresh GradientConductor colors:",
                        error
                      );
                    }
                  }
                }
              }
            );
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "GradientConductor coordination established"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Failed to coordinate GradientConductor:",
              error
            );
          }
        }
        /**
         * Coordinate WebGL gradient background system
         */
        async coordinateWebGLGradientSystem() {
          try {
            const webglSystem = this.visualBridge.getVisualSystem("WebGLBackground");
            if (!webglSystem) {
              Y3KDebug?.debug?.warn(
                "SystemCoordinator",
                "WebGLGradientBackgroundSystem not available via VisualSystemFacade"
              );
              return;
            }
            this.addEventListener("webgl-gradient-event", (event) => {
              if (webglSystem && typeof webglSystem.handleSystemEvent === "function") {
                webglSystem.handleSystemEvent(event);
              }
            });
            this.registerColorDependentSystem(
              "WebGLGradientBackgroundSystem",
              async (trigger) => {
                if (webglSystem && typeof webglSystem.refreshColorState === "function") {
                  await webglSystem.refreshColorState(trigger);
                } else if (webglSystem && typeof webglSystem.updateGradientTexture === "function") {
                  await webglSystem.updateGradientTexture();
                }
              }
            );
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "WebGLGradientBackgroundSystem coordination established"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Failed to coordinate WebGLGradientBackgroundSystem:",
              error
            );
          }
        }
        /**
         * Setup refresh callbacks for all gradient systems
         */
        setupGradientSystemRefreshCallbacks() {
          try {
            this.registerColorDependentSystem("GradientTransitionOrchestrator");
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "GradientTransitionOrchestrator registered for color updates"
            );
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "SystemCoordinator",
              "Failed to register GradientTransitionOrchestrator:",
              error
            );
          }
        }
        /**
         * Setup communication between gradient systems
         */
        setupGradientSystemCommunication() {
          this.addEventListener("color-harmony-updated", async (event) => {
            try {
              await this.refreshColorDependentSystems("color-harmony-update");
              this.emitEvent("gradient-systems-updated", {
                trigger: "color-harmony-update",
                timestamp: Date.now(),
                systems: [
                  "GradientConductor",
                  "WebGLGradientBackgroundSystem",
                  "GradientTransitionOrchestrator"
                ]
              });
            } catch (error) {
              Y3KDebug?.debug?.error(
                "SystemCoordinator",
                "Failed to propagate color harmony update to gradient systems:",
                error
              );
            }
          });
          this.addEventListener("performance-event", (event) => {
            try {
              this.emitEvent("gradient-performance-event", {
                ...event,
                timestamp: Date.now()
              });
            } catch (error) {
              Y3KDebug?.debug?.error(
                "SystemCoordinator",
                "Failed to propagate performance event to gradient systems:",
                error
              );
            }
          });
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "Gradient system communication established"
          );
        }
        /**
         * Get gradient system coordination status
         */
        getGradientSystemStatus() {
          const gradientSystems = [
            "GradientConductor",
            "WebGLGradientBackgroundSystem",
            "GradientTransitionOrchestrator"
          ];
          const colorDependentGradientSystems = gradientSystems.filter(
            (system) => this.colorDependentSystems.has(system)
          );
          return {
            coordinatedSystems: gradientSystems,
            colorDependentGradientSystems,
            communicationActive: this.crossFacadeEventListeners.size > 0
          };
        }
        // ============================================================================
        // Color System Coordination Methods
        // ============================================================================
        /**
         * Register a system as color-dependent for targeted updates
         */
        registerColorDependentSystem(systemKey, refreshCallback) {
          this.colorDependentSystems.add(systemKey);
          if (refreshCallback) {
            this.colorSystemRefreshCallbacks.set(systemKey, refreshCallback);
          }
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            `Registered color-dependent system: ${systemKey}`
          );
        }
        /**
         * Unregister a color-dependent system
         */
        unregisterColorDependentSystem(systemKey) {
          this.colorDependentSystems.delete(systemKey);
          this.colorSystemRefreshCallbacks.delete(systemKey);
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            `Unregistered color-dependent system: ${systemKey}`
          );
        }
        /**
         * Get list of color-dependent systems
         */
        getColorDependentSystems() {
          return Array.from(this.colorDependentSystems);
        }
        /**
         * Refresh only color-dependent systems efficiently
         */
        async refreshColorDependentSystems(trigger) {
          if (this.colorDependentSystems.size === 0) {
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "No color-dependent systems to refresh"
            );
            return;
          }
          const startTime = performance.now();
          const refreshPromises = [];
          let successCount = 0;
          let failureCount = 0;
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            `Refreshing ${this.colorDependentSystems.size} color-dependent systems for trigger: ${trigger}`
          );
          for (const systemKey of this.colorDependentSystems) {
            const refreshCallback = this.colorSystemRefreshCallbacks.get(systemKey);
            if (refreshCallback) {
              refreshPromises.push(
                refreshCallback(trigger).then(() => {
                  successCount++;
                  Y3KDebug?.debug?.log(
                    "SystemCoordinator",
                    `Successfully refreshed color system: ${systemKey}`
                  );
                }).catch((error) => {
                  failureCount++;
                  Y3KDebug?.debug?.warn(
                    "SystemCoordinator",
                    `Failed to refresh color system ${systemKey}:`,
                    error
                  );
                })
              );
            } else {
              refreshPromises.push(
                this.getSystemAndRefresh(systemKey, trigger).then(() => {
                  successCount++;
                }).catch((error) => {
                  failureCount++;
                  Y3KDebug?.debug?.warn(
                    "SystemCoordinator",
                    `Failed to refresh color system ${systemKey}:`,
                    error
                  );
                })
              );
            }
          }
          await Promise.all(refreshPromises);
          const endTime = performance.now();
          const duration = endTime - startTime;
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            `Color system refresh completed`,
            {
              trigger,
              duration: `${duration.toFixed(2)}ms`,
              success: successCount,
              failures: failureCount,
              totalSystems: this.colorDependentSystems.size
            }
          );
          this.emitEvent("color-systems-refreshed", {
            trigger,
            duration,
            successCount,
            failureCount,
            totalSystems: this.colorDependentSystems.size,
            timestamp: Date.now()
          });
        }
        /**
         * Helper method to get system and call refresh method
         */
        async getSystemAndRefresh(systemKey, trigger) {
          if (this.visualBridge) {
            try {
              const system = this.visualBridge.getVisualSystem(systemKey);
              if (system && typeof system.refreshColorState === "function") {
                await system.refreshColorState(trigger);
                return;
              }
            } catch (error) {
            }
          }
          if (this.nonVisualFacade) {
            try {
              const system = await this.nonVisualFacade.getSystem(systemKey);
              if (system && typeof system.refreshColorState === "function") {
                await system.refreshColorState(trigger);
                return;
              }
            } catch (error) {
            }
          }
          Y3KDebug?.debug?.warn(
            "SystemCoordinator",
            `System ${systemKey} not found or doesn't support color refresh`
          );
        }
        /**
         * Auto-register common color-dependent systems
         */
        setupDefaultColorDependentSystems() {
          const defaultColorSystems = [
            "CinematicDrama",
            "EtherealBeauty",
            "NaturalHarmony",
            "FluidGradientBackgroundSystem",
            "WebGLGradientBackgroundSystem",
            "IridescentShimmerEffectsSystem",
            "ColorHarmonyEngine",
            "GradientTransitionOrchestrator",
            "GradientConductor",
            "SemanticColorManager",
            // UI Managers with consciousness integration
            "Card3DManager",
            "GlassmorphismManager"
          ];
          for (const systemKey of defaultColorSystems) {
            this.registerColorDependentSystem(systemKey);
          }
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            `Auto-registered ${defaultColorSystems.length} default color-dependent systems`
          );
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          Y3KDebug?.debug?.log("SystemCoordinator", "System coordinator destroyed");
        }
        // Shared service getter methods for testing and integration
        getSharedMusicSyncService() {
          return this.sharedMusicSyncService || void 0;
        }
        getSharedColorHarmonyEngine() {
          return this.sharedColorHarmonyEngine || void 0;
        }
        getSharedSettingsManager() {
          return this.sharedSettingsManager || void 0;
        }
        getSharedSemanticColorManager() {
          return this.sharedSemanticColorManager || void 0;
        }
        // New simplified performance system getter methods
        getSharedSimplePerformanceCoordinator() {
          return this.sharedSimplePerformanceCoordinator || void 0;
        }
        getSharedWebGLSystemsIntegration() {
          return this.sharedWebGLSystemsIntegration || void 0;
        }
        getSharedEnhancedDeviceTierDetector() {
          return this.sharedEnhancedDeviceTierDetector || void 0;
        }
        // Legacy performance system getter methods (deprecated, for backward compatibility)
        /** @deprecated Use getSharedSimplePerformanceCoordinator() instead */
        getSharedPerformanceAnalyzer() {
          return this.sharedSimplePerformanceCoordinator || void 0;
        }
        /** @deprecated Use getSharedSimplePerformanceCoordinator() instead */
        getSharedPerformanceOrchestrator() {
          return this.sharedSimplePerformanceCoordinator || void 0;
        }
      };
      __name(_SystemCoordinator, "SystemCoordinator");
      SystemCoordinator = _SystemCoordinator;
    }
  });

  // src-js/core/css/ColorStateManager.ts
  var _ColorStateManager, ColorStateManager, globalColorStateManager;
  var init_ColorStateManager = __esm({
    "src-js/core/css/ColorStateManager.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_OptimizedCSSVariableManager();
      init_PaletteSystemManager();
      _ColorStateManager = class _ColorStateManager {
        constructor(settingsManager2) {
          this.initialized = false;
          this.settingsManager = null;
          this.currentState = null;
          this.isUpdating = false;
          // Performance tracking
          this.updateCount = 0;
          this.lastUpdateTime = 0;
          this.settingsManager = settingsManager2 || null;
        }
        async initialize() {
          if (this.initialized) return;
          const year3000System2 = globalThis.year3000System;
          this.cssController = year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
          unifiedEventBus.subscribe("settings:changed", this.handleSettingsChange.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("colors:harmonized", this.handleProcessedColors.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("colors:extracted", this.handleExtractedColors.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("consciousness:updated", this.handleConsciousnessUpdate.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("music:energy", this.handleMusicEnergyUpdate.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("system:css-variables", this.handleSystemCSSVariables.bind(this), "ColorStateManager");
          if (!this.settingsManager) {
            this.settingsManager = globalThis.__SN_settingsManager || globalThis.Y3K?.system?.settingsManager;
          }
          if (this.settingsManager) {
            await this.applyInitialColorState();
          }
          this.initialized = true;
          console.log("\u{1F3A8} [ColorStateManager] Initialized successfully");
        }
        async healthCheck() {
          const issues = [];
          if (!this.settingsManager) {
            issues.push("SettingsManager not available");
          }
          if (!this.currentState) {
            issues.push("No current color state");
          }
          if (this.updateCount === 0) {
            issues.push("No color updates performed yet");
          }
          const timeSinceLastUpdate = Date.now() - this.lastUpdateTime;
          if (timeSinceLastUpdate > 3e5) {
            issues.push(`Last update was ${Math.round(timeSinceLastUpdate / 1e3)}s ago`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Color state manager - ${this.updateCount} updates performed`,
            issues,
            system: "ColorStateManager"
          };
        }
        updateAnimation(deltaTime) {
        }
        destroy() {
          unifiedEventBus.unsubscribeAll("ColorStateManager");
          this.currentState = null;
          this.initialized = false;
        }
        /**
         * Get current color state configuration from settings
         */
        getCurrentConfig() {
          if (!this.settingsManager) {
            const defaultFlavor = paletteSystemManager.getCurrentDefaultFlavor();
            return {
              paletteSystemFlavor: defaultFlavor,
              brightnessMode: "dark",
              // Updated to use corrected default
              accentColor: "mauve",
              preserveAlbumArt: true,
              enableTransitions: true
            };
          }
          const settingsFlavor = this.settingsManager.get("catppuccin-flavor");
          const currentFlavor = settingsFlavor || paletteSystemManager.getCurrentDefaultFlavor();
          return {
            paletteSystemFlavor: currentFlavor,
            brightnessMode: this.settingsManager.get("sn-brightness-mode"),
            accentColor: this.settingsManager.get("catppuccin-accentColor"),
            preserveAlbumArt: true,
            // TODO: Add setting for this
            enableTransitions: true
          };
        }
        /**
         * Calculate the effective color state based on current configuration
         */
        calculateColorState(config) {
          const { paletteSystemFlavor, brightnessMode, accentColor, dynamicAlbumColors } = config;
          const baseColor = getBrightnessAdjustedBaseColor3(paletteSystemFlavor, brightnessMode);
          const surfaceColor = getBrightnessAdjustedSurfaceColor3(paletteSystemFlavor, brightnessMode);
          let effectiveAccentColor;
          if (accentColor === "dynamic" && dynamicAlbumColors) {
            effectiveAccentColor = dynamicAlbumColors.accent;
          } else if (accentColor === "dynamic") {
            effectiveAccentColor = getDefaultAccentColor3(paletteSystemFlavor);
          } else {
            effectiveAccentColor = getAccentColor(accentColor, paletteSystemFlavor);
          }
          const currentPalette = paletteSystemManager.getCurrentPalette();
          const flavorPalette = currentPalette[paletteSystemFlavor];
          if (!flavorPalette) {
            throw new Error(`Flavor '${paletteSystemFlavor}' not found in current palette system`);
          }
          const textColor = flavorPalette["text"];
          return {
            baseColor,
            surfaceColor,
            accentColor: effectiveAccentColor,
            textColor,
            effectiveConfig: config,
            timestamp: Date.now()
          };
        }
        /**
         *  PHASE 2: Enhanced CSS application with batching and priority support
         * Apply color state to CSS variables with batching optimization
         */
        async applyColorStateToCSSVariables(state) {
          const startTime = performance.now();
          const cssUpdates = {
            // === CRITICAL PRIORITY: Core color variables ===
            "--sn-cosmic-base-hex": state.baseColor.hex,
            "--sn-cosmic-accent-hex": state.accentColor.hex,
            "--spice-accent": state.accentColor.hex,
            "--spice-base": state.baseColor.hex,
            // === HIGH PRIORITY: Primary gradients and surfaces ===
            "--sn-color-base-hex": state.baseColor.hex,
            "--sn-color-base-rgb": state.baseColor.rgb,
            "--sn-color-surface-hex": state.surfaceColor.hex,
            "--sn-color-surface-rgb": state.surfaceColor.rgb,
            "--sn-color-accent-hex": state.accentColor.hex,
            "--sn-color-accent-rgb": state.accentColor.rgb,
            "--sn-dynamic-accent-hex": state.accentColor.hex,
            "--sn-dynamic-accent-rgb": state.accentColor.rgb,
            // === NORMAL PRIORITY: Extended color systems ===
            "--sn-cosmic-base-rgb": state.baseColor.rgb,
            "--sn-cosmic-surface-hex": state.surfaceColor.hex,
            "--sn-cosmic-surface-rgb": state.surfaceColor.rgb,
            "--sn-cosmic-accent-rgb": state.accentColor.rgb,
            "--sn-color-text-hex": state.textColor.hex,
            "--sn-color-text-rgb": state.textColor.rgb,
            "--sn-cosmic-text-hex": state.textColor.hex,
            "--sn-cosmic-text-rgb": state.textColor.rgb,
            // === NORMAL PRIORITY: Spicetify compatibility ===
            "--spice-surface1": state.surfaceColor.hex,
            "--spice-text": state.textColor.hex,
            "--spice-rgb-base": state.baseColor.rgb,
            "--spice-rgb-surface1": state.surfaceColor.rgb,
            "--spice-rgb-accent": state.accentColor.rgb,
            "--spice-rgb-text": state.textColor.rgb,
            // === NORMAL PRIORITY: Gradient system integration ===
            "--sn-bg-gradient-primary-rgb": state.accentColor.rgb,
            "--sn-bg-gradient-secondary-rgb": state.surfaceColor.rgb,
            "--sn-bg-gradient-accent-rgb": state.accentColor.rgb,
            // === LOW PRIORITY: Meta information for debugging ===
            "--sn-color-state-flavor": `"${state.effectiveConfig.paletteSystemFlavor}"`,
            "--sn-color-state-brightness": `"${state.effectiveConfig.brightnessMode}"`,
            "--sn-color-state-accent": `"${state.effectiveConfig.accentColor}"`,
            "--sn-color-state-palette-system": `"${paletteSystemManager.getCurrentPaletteSystem()}"`,
            "--sn-color-state-timestamp": state.timestamp.toString()
          };
          await this.applyColorVariablesWithPriorities(cssUpdates);
          const endTime = performance.now();
          const updateDuration = endTime - startTime;
          console.log(`\u{1F3A8} [ColorStateManager] Applied ${Object.keys(cssUpdates).length} CSS variables in ${updateDuration.toFixed(2)}ms (via OptimizedCSSVariableManager)`);
        }
        /**
         * Apply color variables through OptimizedCSSVariableManager with intelligent priority grouping
         */
        async applyColorVariablesWithPriorities(cssUpdates) {
          const criticalVars = ["--sn-cosmic-base-hex", "--sn-cosmic-accent-hex", "--spice-accent", "--spice-base"];
          const highPriorityVars = ["--sn-color-", "--sn-dynamic-accent-"];
          const criticalUpdates = {};
          const highPriorityUpdates = {};
          const normalUpdates = {};
          const lowPriorityUpdates = {};
          Object.entries(cssUpdates).forEach(([property, value]) => {
            if (criticalVars.some((prefix) => property.includes(prefix))) {
              criticalUpdates[property] = value;
            } else if (highPriorityVars.some((prefix) => property.includes(prefix))) {
              highPriorityUpdates[property] = value;
            } else if (property.includes("state-") || property.includes("timestamp")) {
              lowPriorityUpdates[property] = value;
            } else {
              normalUpdates[property] = value;
            }
          });
          if (Object.keys(criticalUpdates).length > 0) {
            this.cssController.batchSetVariables(
              "ColorStateManager",
              criticalUpdates,
              "critical",
              "color-state-critical"
            );
          }
          if (Object.keys(highPriorityUpdates).length > 0) {
            this.cssController.batchSetVariables(
              "ColorStateManager",
              highPriorityUpdates,
              "high",
              "color-state-high"
            );
          }
          if (Object.keys(normalUpdates).length > 0) {
            this.cssController.batchSetVariables(
              "ColorStateManager",
              normalUpdates,
              "normal",
              "color-state-normal"
            );
          }
          if (Object.keys(lowPriorityUpdates).length > 0) {
            this.cssController.batchSetVariables(
              "ColorStateManager",
              lowPriorityUpdates,
              "low",
              "color-state-meta"
            );
          }
        }
        /**
         *  PHASE 2: Generic method for other systems to queue CSS updates through ColorStateManager using coordination
         * This makes ColorStateManager the single CSS authority for all color-related variables
         */
        queueCSSVariableUpdate(property, value, priority = "normal") {
          const mappedPriority = priority === "critical" ? "critical" : priority === "high" ? "high" : priority === "low" ? "low" : "normal";
          this.cssController.setVariable(
            "ColorStateManager",
            property,
            value,
            mappedPriority,
            "color-state-queue"
          );
        }
        // All CSS variable updates now handled directly through OptimizedCSSVariableManager
        /**
         * Verify that critical CSS variables were actually applied to the DOM
         */
        async verifyCSSVariablesApplied(cssUpdates) {
          const criticalVars = [
            "--sn-cosmic-base-hex",
            "--sn-cosmic-accent-hex",
            "--spice-base"
          ];
          for (const varName of criticalVars) {
            if (cssUpdates[varName]) {
              const computedValue = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
              const expectedValue = cssUpdates[varName];
              if (computedValue !== expectedValue) {
                console.warn(`\u{1F3A8} [ColorStateManager] Variable verification failed: ${varName} = "${computedValue}" (expected "${expectedValue}")`);
                return false;
              }
            }
          }
          return true;
        }
        /**
         * Update color state with change detection
         */
        async updateColorState(trigger = "settings") {
          if (this.isUpdating) return;
          this.isUpdating = true;
          try {
            const config = this.getCurrentConfig();
            const newState = this.calculateColorState(config);
            const hasChanged = !this.currentState || this.currentState.baseColor.hex !== newState.baseColor.hex || this.currentState.surfaceColor.hex !== newState.surfaceColor.hex || this.currentState.accentColor.hex !== newState.accentColor.hex || this.currentState.effectiveConfig.paletteSystemFlavor !== newState.effectiveConfig.paletteSystemFlavor || this.currentState.effectiveConfig.brightnessMode !== newState.effectiveConfig.brightnessMode;
            if (hasChanged) {
              const oldState = this.currentState;
              await this.applyColorStateToCSSVariables(newState);
              this.currentState = newState;
              this.updateCount++;
              this.lastUpdateTime = Date.now();
              unifiedEventBus.emit("colors:applied", {
                oldState,
                newState,
                trigger,
                cssVariables: {
                  "--sn-cosmic-base-hex": newState.baseColor.hex,
                  "--sn-cosmic-accent-hex": newState.accentColor.hex
                },
                accentHex: newState.accentColor.hex,
                accentRgb: newState.accentColor.rgb,
                appliedAt: Date.now()
              });
              console.log(`\u{1F3A8} [ColorStateManager] Color state updated (${trigger}):`, {
                flavor: newState.effectiveConfig.paletteSystemFlavor,
                brightness: newState.effectiveConfig.brightnessMode,
                accent: newState.effectiveConfig.accentColor,
                paletteSystem: paletteSystemManager.getCurrentPaletteSystem(),
                base: newState.baseColor.hex,
                surface: newState.surfaceColor.hex,
                accentHex: newState.accentColor.hex
              });
            }
          } finally {
            this.isUpdating = false;
          }
        }
        /**
         * Apply initial color state during system initialization
         */
        async applyInitialColorState() {
          await this.updateColorState("initialization");
        }
        /**
         * Handle settings changes
         */
        async handleSettingsChange(event) {
          const { settingKey, newValue, oldValue } = event;
          if (["catppuccin-flavor", "sn-brightness-mode", "catppuccin-accentColor"].includes(settingKey)) {
            let trigger = "settings";
            if (settingKey === "catppuccin-flavor") trigger = "flavor";
            else if (settingKey === "sn-brightness-mode") trigger = "brightness";
            else if (settingKey === "catppuccin-accentColor") trigger = "accent";
            unifiedEventBus.emit(`colorState:${trigger}Changed`, {
              settingKey,
              newValue,
              oldValue,
              timestamp: Date.now()
            });
            await this.updateColorState(trigger);
          }
        }
        /**
         *  PHASE 2: Handle processed color events from unified color processing
         * This replaces individual CSS application in ColorHarmonyEngine and orchestrators
         */
        async handleProcessedColors(event) {
          const { processedColors, accentHex, accentRgb, strategies, coordinationMetrics } = event;
          const colorVariables = {};
          Object.entries(processedColors).forEach(([key, value]) => {
            if (value) {
              const cssVar = key.startsWith("--") ? key : `--sn-${key.toLowerCase().replace(/_/g, "-")}`;
              colorVariables[cssVar] = value;
            }
          });
          if (accentHex) {
            colorVariables["--sn-accent-hex"] = accentHex;
            colorVariables["--sn-processed-accent-hex"] = accentHex;
          }
          if (accentRgb) {
            colorVariables["--sn-accent-rgb"] = accentRgb;
            colorVariables["--sn-processed-accent-rgb"] = accentRgb;
          }
          if (coordinationMetrics) {
            if (coordinationMetrics.emotionalState) {
              colorVariables["--sn-emotional-state"] = `"${coordinationMetrics.emotionalState}"`;
            }
            if (coordinationMetrics.musicInfluenceStrength !== void 0) {
              colorVariables["--sn-music-influence"] = coordinationMetrics.musicInfluenceStrength.toFixed(3);
            }
          }
          Object.entries(colorVariables).forEach(([property, value]) => {
            let priority = "normal";
            if (property.includes("accent-hex") || property.includes("accent-rgb")) {
              priority = "high";
            } else if (property.includes("debug") || property.includes("state") || property.includes("influence")) {
              priority = "low";
            }
            this.queueCSSVariableUpdate(property, value, priority);
          });
          console.log(`\u{1F3A8} [ColorStateManager] Applied ${Object.keys(colorVariables).length} processed color variables`);
        }
        /**
         *  PHASE 2: Handle extracted colors from album art
         */
        async handleExtractedColors(event) {
          const { rawColors, trackUri, musicData } = event;
          const extractedVariables = {};
          Object.entries(rawColors).forEach(([key, value]) => {
            if (value) {
              extractedVariables[`--sn-extracted-${key.toLowerCase()}`] = value;
            }
          });
          if (trackUri) {
            extractedVariables["--sn-current-track-id"] = `"${trackUri}"`;
          }
          Object.entries(extractedVariables).forEach(([property, value]) => {
            this.queueCSSVariableUpdate(property, value, "low");
          });
        }
        /**
         *  PHASE 2: Handle consciousness updates and apply consciousness CSS variables
         */
        async handleConsciousnessUpdate(event) {
          const { payload } = event;
          if (!payload) return;
          const consciousnessVariables = {
            "--sn-consciousness-level": (payload.consciousnessLevel || 0).toFixed(3),
            "--sn-emotional-temperature": (payload.emotionalTemperature || 6500).toString(),
            "--sn-transcendence-level": (payload.transcendenceLevel || 0).toFixed(3),
            "--sn-volumetric-depth": (payload.volumetricDepth || 0).toFixed(3),
            "--sn-data-stream-intensity": (payload.dataStreamIntensity || 0).toFixed(3),
            "--sn-cosmic-resonance": (payload.cosmicResonance || 0).toFixed(3)
          };
          Object.entries(consciousnessVariables).forEach(([property, value]) => {
            this.queueCSSVariableUpdate(property, value, "normal");
          });
        }
        /**
         *  PHASE 2: Handle music energy updates for dynamic CSS variables
         */
        async handleMusicEnergyUpdate(event) {
          const { energy, valence, tempo } = event;
          const musicVariables = {};
          if (energy !== void 0) {
            musicVariables["--sn-music-energy"] = energy.toFixed(3);
          }
          if (valence !== void 0) {
            musicVariables["--sn-music-valence"] = valence.toFixed(3);
          }
          if (tempo !== void 0) {
            musicVariables["--sn-music-tempo"] = tempo.toString();
          }
          Object.entries(musicVariables).forEach(([property, value]) => {
            this.queueCSSVariableUpdate(property, value, "high");
          });
        }
        /**
         *  PHASE 2: Handle CSS variable events from other systems (ColorHarmonyEngine, etc.)
         * This makes ColorStateManager the single CSS authority for all systems
         */
        async handleSystemCSSVariables(event) {
          const { source, variables, timestamp } = event;
          if (!variables || typeof variables !== "object") return;
          Object.entries(variables).forEach(([property, value]) => {
            let priority = "normal";
            if (property.includes("harmony") || property.includes("glow") || property.includes("pulse")) {
              priority = "high";
            } else if (property.includes("debug") || property.includes("breathing")) {
              priority = "low";
            }
            this.queueCSSVariableUpdate(property, value, priority);
          });
          console.log(`\u{1F3A8} [ColorStateManager] Applied ${Object.keys(variables).length} CSS variables from ${source}`);
        }
        /**
         * Get current color state (read-only)
         */
        getCurrentState() {
          return this.currentState ? { ...this.currentState } : null;
        }
        /**
         * Force refresh of color state
         */
        async refresh() {
          await this.updateColorState("settings");
        }
      };
      __name(_ColorStateManager, "ColorStateManager");
      ColorStateManager = _ColorStateManager;
      globalColorStateManager = new ColorStateManager();
    }
  });

  // src-js/utils/dom/NowPlayingDomWatcher.ts
  function startNowPlayingWatcher(onChange, enableDebug = false) {
    const bar = document.querySelector(
      MODERN_SELECTORS["nowPlayingBar"]
    );
    if (!bar) {
      if (enableDebug) {
        console.warn(
          "\u{1F3B5} [NowPlayingDomWatcher] nowPlayingBar element not found \u2013 watcher inactive"
        );
      }
      return () => {
      };
    }
    const mObserver = new MutationObserver(() => {
      onChange();
      if (enableDebug)
        console.log(
          "\u{1F3B5} [NowPlayingDomWatcher] DOM mutation detected \u2192 onChange dispatched"
        );
    });
    mObserver.observe(bar, { childList: true, subtree: true });
    if (enableDebug) console.log("\u{1F3B5} [NowPlayingDomWatcher] watcher active");
    return () => {
      mObserver.disconnect();
      if (enableDebug) console.log("\u{1F3B5} [NowPlayingDomWatcher] watcher disposed");
    };
  }
  var init_NowPlayingDomWatcher = __esm({
    "src-js/utils/dom/NowPlayingDomWatcher.ts"() {
      "use strict";
      init_SpotifyDOMSelectors();
      __name(startNowPlayingWatcher, "startNowPlayingWatcher");
    }
  });

  // src-js/visual/base/starryNightEffects.ts
  function injectStarContainer() {
    const existingContainer = document.querySelector(
      ".sn-stars-container"
    );
    if (existingContainer) {
      return existingContainer;
    }
    const starContainer = document.createElement("div");
    starContainer.className = "sn-stars-container";
    for (let i = 1; i <= 5; i++) {
      const star = document.createElement("div");
      star.className = "star";
      if (Math.random() > 0.7) star.classList.add("twinkle");
      starContainer.appendChild(star);
    }
    document.body.appendChild(starContainer);
    return starContainer;
  }
  function applyStarryNightSettings(effectIntensity, _legacyStarDensity) {
    if (YEAR3000_CONFIG.enableDebug) {
      console.log("[StarryNightEffects] Applying consolidated effect settings:", {
        effectIntensity
      });
    }
    const body = document.body;
    const gradientClasses = [
      "sn-gradient-disabled",
      "sn-gradient-minimal",
      "sn-gradient-balanced",
      "sn-gradient-intense"
    ];
    const starClasses = [
      "sn-stars-disabled",
      "sn-stars-minimal",
      "sn-stars-balanced",
      "sn-stars-intense"
    ];
    body.classList.remove(...gradientClasses, ...starClasses);
    if (effectIntensity !== "balanced") {
      body.classList.add(`sn-gradient-${effectIntensity}`);
      body.classList.add(`sn-stars-${effectIntensity}`);
    }
    const existingContainer = document.querySelector(".sn-stars-container");
    if (effectIntensity === "disabled") {
      existingContainer?.remove();
    } else {
      if (!existingContainer) {
        injectStarContainer();
      }
    }
  }
  var init_starryNightEffects = __esm({
    "src-js/visual/base/starryNightEffects.ts"() {
      "use strict";
      init_SettingsManager();
      init_globalConfig();
      __name(injectStarContainer, "injectStarContainer");
      __name(applyStarryNightSettings, "applyStarryNightSettings");
    }
  });

  // src-js/core/lifecycle/year3000System.ts
  var _Year3000System, Year3000System, year3000System, year3000System_default;
  var init_year3000System = __esm({
    "src-js/core/lifecycle/year3000System.ts"() {
      "use strict";
      init_SystemCoordinator();
      init_ColorStateManager();
      init_ColorOrchestrator();
      init_UnifiedEventBus();
      init_globalConfig();
      init_Year3000Utilities();
      init_NowPlayingDomWatcher();
      init_starryNightEffects();
      _Year3000System = class _Year3000System {
        constructor(config = YEAR3000_CONFIG) {
          this.healthCheckInterval = null;
          // Phase 4: Facade Coordination System (replaces direct system properties)
          this.facadeCoordinator = null;
          // Color State Management System
          this.colorStateManager = null;
          // Private initialization results storage
          this._initializationResults = null;
          // Private storage for dynamicCatppuccinBridge to allow setter
          this._dynamicCatppuccinBridge = null;
          // Phase 1: Loop Prevention System - Processing State Tracking
          this.processingState = {
            isProcessingSongChange: false,
            lastProcessedTrackUri: null,
            lastProcessingTime: 0,
            processingChain: [],
            eventLoopDetected: false
          };
          this.colorEventState = {
            processedEvents: /* @__PURE__ */ new Map(),
            isProcessingColorEvent: false,
            eventTimeout: null
          };
          this.PROCESSING_TIMEOUT = 5e3;
          // 5 second safety timeout
          this.MAX_CHAIN_LENGTH = 10;
          // Prevent infinite chains
          this.COLOR_EVENT_CACHE_TTL = 2e3;
          // API availability tracking
          this.availableAPIs = null;
          this._songChangeHandler = null;
          // Stats
          this._lastInitializationTime = null;
          this._initializationRetryHistory = [];
          this._systemStartTime = null;
          this._disposeNowPlayingWatcher = null;
          /**
           * Indicates whether automatic harmonic evolution is permitted. This mirrors the
           * `sn-harmonic-evolution` setting and `YEAR3000_CONFIG.harmonicEvolution`.
           * Sub-systems can read this flag instead of accessing the config directly so
           * that future scheduling logic (e.g. TimerConsolidationSystem) can rely on a
           * guaranteed field.
           */
          this.allowHarmonicEvolution = true;
          /** Global switch other systems can read to know guardrails are active */
          this.performanceGuardActive = false;
          this.YEAR3000_CONFIG = this._deepCloneConfig(config);
          if (typeof this.YEAR3000_CONFIG.init === "function") {
            this.YEAR3000_CONFIG.init();
          }
          this.utils = Year3000Utilities_exports;
          this.initialized = false;
          this._systemStartTime = Date.now();
          this._initializationResults = null;
          if (this.YEAR3000_CONFIG?.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Constructor: Instance created with Enhanced Master Animation Coordinator"
            );
          }
          this._boundExternalSettingsHandler = this._handleExternalSettingsChange.bind(this);
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this._boundExternalSettingsHandler
          );
          this._boundArtisticModeHandler = this._onArtisticModeChanged.bind(this);
          document.addEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          this._boundVisibilityChangeHandler = this._handleVisibilityChange.bind(this);
          document.addEventListener(
            "visibilitychange",
            this._boundVisibilityChangeHandler
          );
          this._disposeNowPlayingWatcher = startNowPlayingWatcher(() => {
            const timestamp = Date.now().toString();
            this.queueCSSVariableUpdate("--sn-force-refresh", timestamp);
            unifiedEventBus.emit("music:track-changed", {
              timestamp: parseInt(timestamp),
              trackUri: "unknown",
              artist: "unknown",
              title: "unknown"
            });
          }, this.YEAR3000_CONFIG.enableDebug);
          this.allowHarmonicEvolution = this.YEAR3000_CONFIG.harmonicEvolution ?? true;
          setTimeout(() => {
            this._applyPerformanceProfile();
          }, 0);
        }
        // 2 second cache
        // Phase 4: Pure Facade Access Property Getters
        // Performance Systems
        get enhancedMasterAnimationCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "EnhancedMasterAnimationCoordinator"
          ) || null;
        }
        get timerConsolidationSystem() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "TimerConsolidationSystem"
          ) || null;
        }
        get cssConsciousnessController() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "OptimizedCSSVariableManager"
          ) || null;
        }
        // New simplified performance system getters (primary)
        get simplePerformanceCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "SimplePerformanceCoordinator"
          ) || null;
        }
        get simpleTierBasedPerformanceSystem() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "SimpleTierBasedPerformanceSystem"
          ) || null;
        }
        get enhancedDeviceTierDetector() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "EnhancedDeviceTierDetector"
          ) || null;
        }
        get webglSystemsIntegration() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "WebGLSystemsIntegration"
          ) || null;
        }
        // Legacy compatibility getters
        get unifiedCSSManager() {
          return this.cssConsciousnessController || null;
        }
        /** @deprecated Use simplePerformanceCoordinator instead - legacy complex performance system */
        get performanceCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "UnifiedPerformanceCoordinator"
          ) || null;
        }
        /** @deprecated Use enhancedDeviceTierDetector instead - legacy device detection system */
        get deviceCapabilityDetector() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "DeviceCapabilityDetector"
          ) || null;
        }
        /** @deprecated Use simplePerformanceCoordinator instead - legacy complex performance system */
        get performanceAnalyzer() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("SimplePerformanceCoordinator") || null;
        }
        /** @deprecated Use simplePerformanceCoordinator instead - legacy complex performance system */
        get unifiedPerformanceCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "UnifiedPerformanceCoordinator"
          ) || null;
        }
        get performanceCSSIntegration() {
          return this.cssConsciousnessController || null;
        }
        get performanceOrchestrator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "SimplePerformanceCoordinator"
          ) || null;
        }
        get performanceBudgetManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "PerformanceBudgetManager"
          ) || null;
        }
        // Managers and Services
        get systemHealthMonitor() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedDebugManager") || null;
        }
        get settingsManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("SettingsManager") || null;
        }
        get colorHarmonyEngine() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("ColorHarmonyEngine") || null;
        }
        //  PHASE 3: Unified Color Processing Access
        get unifiedColorProcessingEngine() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "UnifiedColorProcessingEngine"
          ) || null;
        }
        get musicColorIntegrationBridge() {
          return null;
        }
        //  PHASE 3: Legacy Compatibility - Delegate to Unified Systems
        get colorEventOrchestrator() {
          const unified = this.unifiedColorProcessingEngine;
          return unified ? unified : null;
        }
        get colorOrchestrator() {
          const unified = this.unifiedColorProcessingEngine;
          return unified ? unified : null;
        }
        get enhancedColorOrchestrator() {
          const unified = this.unifiedColorProcessingEngine;
          return unified ? unified : null;
        }
        get colorConsciousnessState() {
          return this.unifiedConsciousnessCoordinator || null;
        }
        get musicSyncService() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("MusicSyncService") || null;
        }
        get glassmorphismManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "GlassmorphismManager"
          ) || null;
        }
        get card3DManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("Card3DManager") || null;
        }
        // Consciousness Systems
        get genreGradientEvolution() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "GenreGradientEvolution"
          ) || null;
        }
        get musicEmotionAnalyzer() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "MusicEmotionAnalyzer"
          ) || null;
        }
        //  PHASE 4: Unified Consciousness Coordination
        get unifiedConsciousnessCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "VisualEffectsCoordinator"
          ) || null;
        }
        //  PHASE 4: Backward compatibility delegation for consolidated consciousness systems
        get colorConsciousnessManager() {
          return this.unifiedConsciousnessCoordinator || null;
        }
        get dynamicCatppuccinBridge() {
          return this._dynamicCatppuccinBridge || this.unifiedConsciousnessCoordinator || null;
        }
        set dynamicCatppuccinBridge(bridge) {
          this._dynamicCatppuccinBridge = bridge;
        }
        // Visual Systems
        get particleConsciousnessModule() {
          return this.facadeCoordinator?.getVisualSystem("Particle") || null;
        }
        get sidebarConsciousnessController() {
          return this.facadeCoordinator?.getVisualSystem("SidebarConsciousness") || null;
        }
        get uiEffectsConsciousnessController() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get headerConsciousnessController() {
          return this.facadeCoordinator?.getVisualSystem("HeaderConsciousness") || null;
        }
        // Legacy compatibility getters
        get lightweightParticleSystem() {
          return this.facadeCoordinator?.getVisualSystem("Particle") || null;
        }
        // UI Effects systems now consolidated into ConsciousnessUIEffectsController
        get iridescentShimmerEffectsSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get interactionTrackingSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get whiteLayerDiagnosticSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get audioVisualController() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get prismaticScrollSheenSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get beatSyncVisualSystem() {
          return this.facadeCoordinator?.getVisualSystem("OrganicBeatSync") || null;
        }
        get webGLGradientBackgroundSystem() {
          return this.facadeCoordinator?.getVisualSystem("WebGLBackground") || null;
        }
        // Legacy compatibility - particleFieldSystem consolidated into particleConsciousnessModule
        get particleFieldSystem() {
          return this.facadeCoordinator?.getVisualSystem("Particle") || null;
        }
        get emergentChoreographyEngine() {
          return this.enhancedMasterAnimationCoordinator || null;
        }
        get spotifyUIApplicationSystem() {
          return this.facadeCoordinator?.getVisualSystem("SpotifyUIApplication") || null;
        }
        // Organic Consciousness System (Year 3000 Philosophy)
        get organicBeatSyncConsciousness() {
          return this.facadeCoordinator?.getVisualSystem("OrganicBeatSync") || this.beatSyncVisualSystem;
        }
        // Integration Systems Getters
        get sidebarSystemsIntegration() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "SidebarSystemsIntegration"
          ) || null;
        }
        _deepCloneConfig(config) {
          return config;
        }
        updateConfiguration(key, value) {
          if (!this.YEAR3000_CONFIG) {
            console.warn(
              "[Year3000System] Cannot update configuration - config not initialized"
            );
            return;
          }
          const keyPath = key.split(".").filter(Boolean);
          if (!keyPath.length) {
            return;
          }
          let current = this.YEAR3000_CONFIG;
          const finalKey = keyPath.pop();
          if (!finalKey) {
            return;
          }
          for (const pathKey of keyPath) {
            if (typeof current[pathKey] !== "object" || current[pathKey] === null) {
              current[pathKey] = {};
            }
            current = current[pathKey];
          }
          const oldValue = current[finalKey];
          current[finalKey] = value;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `[Year3000System] Configuration updated: ${key} = ${value} (was: ${oldValue})`
            );
          }
          this._notifyConfigurationChange(key, value, oldValue);
        }
        _notifyConfigurationChange(key, newValue, oldValue) {
        }
        async initializeAllSystems() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F30C} [Year3000System] initializeAllSystems(): Starting full system initialization..."
            );
          }
          this._systemStartTime = Date.now();
          const startTime = performance.now();
          const initializationResults = {
            success: [],
            failed: [],
            skipped: []
          };
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F30C} [Year3000System] Initializing Facade Coordination System..."
            );
          }
          try {
            this.facadeCoordinator = new SystemCoordinator(
              this.YEAR3000_CONFIG,
              this.utils,
              this
            );
            await this.facadeCoordinator.initialize({
              mode: "unified",
              enableSharedDependencies: true,
              enableCrossFacadeCommunication: true,
              enableUnifiedPerformanceMonitoring: true,
              enableResourceOptimization: true,
              orchestration: {
                enforceSequentialInitialization: true,
                dependencyValidation: true,
                enableInitializationGates: true,
                systemReadinessTimeout: 5e3,
                phaseTransitionTimeout: 1e4
              },
              performanceThresholds: {
                maxTotalMemoryMB: 100,
                maxTotalInitTime: 5e3,
                maxCrossCommLatency: 50
              },
              coordinationPreferences: {
                preferSharedResources: true,
                enableEventPropagation: true,
                enableHealthCoordination: true
              }
            });
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F30C} [Year3000System] Facade Coordination System initialized successfully"
              );
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing ColorStateManager...");
            }
            try {
              this.colorStateManager = globalColorStateManager;
              if (!this.colorStateManager.initialized) {
                await this.colorStateManager.initialize();
              }
              initializationResults.success.push("ColorStateManager");
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F30C} [Year3000System] ColorStateManager initialized successfully"
                );
              }
            } catch (error) {
              console.error(
                "\u{1F30C} [Year3000System] Failed to initialize ColorStateManager:",
                error
              );
              initializationResults.failed.push("ColorStateManager");
            }
            await this._initializeFacadeSystems();
          } catch (error) {
            console.error(
              "\u{1F30C} [Year3000System] Failed to initialize Facade Coordination System:",
              error
            );
            throw error;
          }
          initializationResults.success.push("FacadeCoordinationSystem");
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.startMonitoring();
            this.performanceGuardActive = true;
          }
          if (this.enhancedMasterAnimationCoordinator) {
            await this._registerEnhancedAnimationSystems();
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F3AC} [Year3000System] Enhanced animation system registration phase complete"
              );
            }
          } else {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for enhanced registration phase"
            );
          }
          this._initializationResults = initializationResults;
          this.initialized = true;
          const endTime = performance.now();
          this._lastInitializationTime = endTime - startTime;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `[Year3000System] System initialization complete in ${this._lastInitializationTime.toFixed(
                2
              )}ms.`
            );
            console.log(
              `[Year3000System] Results: ${initializationResults.success.length} success, ${initializationResults.failed.length} failed.`
            );
            if (initializationResults.failed.length > 0) {
              console.warn(
                `[Year3000System] Failed systems: ${initializationResults.failed.join(
                  ", "
                )}`
              );
            }
            if (initializationResults.skipped && initializationResults.skipped.length > 0) {
              console.info(
                `[Year3000System] Skipped systems: ${initializationResults.skipped.join(
                  ", "
                )}`
              );
            }
            if (initializationResults.success.length > 0) {
              console.info(
                `[Year3000System] Successful systems: ${initializationResults.success.join(
                  ", "
                )}`
              );
            }
            if (this.systemHealthMonitor) {
              this.systemHealthMonitor.logHealthReport();
            }
          }
        }
        /**
         * Initialize essential systems for degraded mode (no Spicetify APIs)
         * Phase 4: Essential system initialization for degraded mode
         */
        async _initializeEssentialFacadeSystems() {
          if (!this.facadeCoordinator) {
            throw new Error(
              "Facade coordinator not available for essential system initialization"
            );
          }
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F30C} [Year3000System] Initializing essential systems for degraded mode..."
            );
          }
          try {
            const essentialSystems = [
              "SimplePerformanceCoordinator",
              "UnifiedCSSVariableManager",
              "UnifiedDebugManager",
              "DeviceCapabilityDetector",
              "TimerConsolidationSystem"
            ];
            for (const systemKey of essentialSystems) {
              try {
                const system = await this.facadeCoordinator.getNonVisualSystem(
                  systemKey
                );
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(
                      `\u{1F30C} [Year3000System] Essential: Initialized ${systemKey} via facade`
                    );
                  }
                }
              } catch (error) {
                console.error(
                  `\u{1F30C} [Year3000System] Failed to initialize essential ${systemKey}:`,
                  error
                );
              }
            }
            if (this.performanceAnalyzer) {
              this.performanceAnalyzer.startMonitoring();
              this.performanceGuardActive = true;
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F30C} [Year3000System] Essential: Performance monitoring started"
                );
              }
            }
          } catch (error) {
            console.error(
              "\u{1F30C} [Year3000System] Essential facade system initialization failed:",
              error
            );
            throw error;
          }
        }
        /**
         * Initialize essential systems through facade pattern
         * Phase 4: Core system initialization via facades
         */
        async _initializeFacadeSystems() {
          if (!this.facadeCoordinator) {
            throw new Error(
              "Facade coordinator not available for system initialization"
            );
          }
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F30C} [Year3000System] Initializing essential systems through facades..."
            );
          }
          try {
            const foundationSystems = [
              "SimplePerformanceCoordinator",
              "UnifiedDebugManager",
              "SettingsManager",
              "DeviceCapabilityDetector",
              "TimerConsolidationSystem"
            ];
            const dependentSystems = [
              "UnifiedCSSVariableManager",
              // Depends on SimplePerformanceCoordinator
              "UnifiedPerformanceCoordinator"
              // Depends on SimplePerformanceCoordinator
            ];
            const eventDrivenSystems = [
              "MusicSyncService",
              "ColorHarmonyEngine",
              "GenreGradientEvolution",
              //  Genre-specific visual consciousness
              "MusicEmotionAnalyzer"
              //  Emotional intelligence for music analysis
            ];
            const uiSystems = [
              "GlassmorphismManager",
              //  Essential glassmorphism effects
              "Card3DManager"
              //  Essential 3D card transformations
            ];
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing foundation systems in parallel...");
            }
            const foundationPromises = foundationSystems.map(async (systemKey) => {
              try {
                if (!this.facadeCoordinator) {
                  throw new Error("Facade coordinator not available");
                }
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] \u2713 ${systemKey} initialized`);
                  }
                  return { systemKey, success: true };
                }
                return { systemKey, success: false, reason: "No initialize method" };
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] \u2717 Failed to initialize ${systemKey}:`, error);
                return { systemKey, success: false, error };
              }
            });
            await Promise.all(foundationPromises);
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing dependent systems in parallel...");
            }
            const dependentPromises = dependentSystems.map(async (systemKey) => {
              try {
                if (!this.facadeCoordinator) {
                  throw new Error("Facade coordinator not available");
                }
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] \u2713 ${systemKey} initialized`);
                  }
                  return { systemKey, success: true };
                }
                return { systemKey, success: false, reason: "No initialize method" };
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] \u2717 Failed to initialize ${systemKey}:`, error);
                return { systemKey, success: false, error };
              }
            });
            await Promise.all(dependentPromises);
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing event-driven systems in parallel...");
            }
            const eventDrivenPromises = eventDrivenSystems.map(async (systemKey) => {
              try {
                if (!this.facadeCoordinator) {
                  throw new Error("Facade coordinator not available");
                }
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] \u2713 ${systemKey} initialized`);
                  }
                  return { systemKey, success: true };
                }
                return { systemKey, success: false, reason: "No initialize method" };
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] \u2717 Failed to initialize ${systemKey}:`, error);
                return { systemKey, success: false, error };
              }
            });
            await Promise.all(eventDrivenPromises);
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing UI systems in parallel...");
            }
            const uiPromises = uiSystems.map(async (systemKey) => {
              try {
                if (!this.facadeCoordinator) {
                  throw new Error("Facade coordinator not available");
                }
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] \u2713 ${systemKey} initialized`);
                  }
                  return { systemKey, success: true };
                }
                return { systemKey, success: false, reason: "No initialize method" };
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] \u2717 Failed to initialize ${systemKey}:`, error);
                return { systemKey, success: false, error };
              }
            });
            await Promise.all(uiPromises);
            try {
              await globalColorOrchestrator.initialize();
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F3A8} [Year3000System] ColorOrchestrator initialized for strategy pattern coordination"
                );
              }
            } catch (error) {
              console.error(
                "\u{1F3A8} [Year3000System] Failed to initialize ColorOrchestrator:",
                error
              );
            }
            if (this.performanceAnalyzer) {
              this.performanceAnalyzer.startMonitoring();
              this.performanceGuardActive = true;
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] Performance monitoring started");
              }
            }
            const essentialVisualSystems = [
              "Particle",
              // ParticleField consolidated into Particle (ParticleConsciousnessModule)
              "WebGLBackground",
              //  Enable WebGL gradient backgrounds
              "SpotifyUIApplication",
              //  Core UI color application
              "OrganicBeatSync",
              "HeaderConsciousness",
              //  Music-responsive header consciousness animations
              "InteractionTracking"
              // EmergentChoreography integrated into EnhancedMasterAnimationCoordinator
            ];
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing visual systems in parallel...");
            }
            const visualPromises = essentialVisualSystems.map(async (systemKey) => {
              try {
                if (!this.facadeCoordinator) {
                  throw new Error("Facade coordinator not available");
                }
                const system = this.facadeCoordinator.getVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] \u2713 Visual ${systemKey} initialized`);
                  }
                  return { systemKey, success: true };
                }
                return { systemKey, success: false, reason: "No initialize method" };
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] \u2717 Failed to initialize visual ${systemKey}:`, error);
                return { systemKey, success: false, error };
              }
            });
            await Promise.all(visualPromises);
            await this._linkSystemDependencies();
            await this._validateFacadeIntegration();
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F30C} [Year3000System] Facade system initialization complete"
              );
            }
          } catch (error) {
            console.error(
              "\u{1F30C} [Year3000System] Facade system initialization failed:",
              error
            );
            throw error;
          }
        }
        /**
         * Phase 4: Facade Integration Validation
         * Validates that all facade integration fixes are working correctly
         */
        async _validateFacadeIntegration() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F50D} [Year3000System] Performing facade integration validation...");
          }
          const validationResults = {
            cssControllerAlias: false,
            strategyPatternSystems: false,
            parallelInitialization: false,
            facadeHealthCheck: false,
            errors: []
          };
          try {
            if (this.facadeCoordinator) {
              try {
                const cssController = await this.facadeCoordinator.getNonVisualSystem(
                  "UnifiedCSSVariableManager"
                );
                const optimizedController = await this.facadeCoordinator.getNonVisualSystem(
                  "OptimizedCSSVariableManager"
                );
                if (cssController && optimizedController) {
                  validationResults.cssControllerAlias = true;
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log("\u2713 [Validation] CSS Controller alias registration working");
                  }
                } else {
                  validationResults.errors.push("CSS Controller alias registration failed");
                }
              } catch (error) {
                validationResults.errors.push(`CSS Controller validation error: ${error}`);
              }
              const strategyPatternSystems = ["ColorHarmonyEngine", "GenreGradientEvolution", "MusicEmotionAnalyzer"];
              let strategySystemsFound = 0;
              for (const systemKey of strategyPatternSystems) {
                try {
                  const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                  if (system) {
                    strategySystemsFound++;
                  }
                } catch (error) {
                  validationResults.errors.push(`Strategy system ${systemKey} not found: ${error}`);
                }
              }
              validationResults.strategyPatternSystems = strategySystemsFound === strategyPatternSystems.length;
              if (validationResults.strategyPatternSystems && this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u2713 [Validation] Strategy pattern systems registration working");
              }
              const initStartTime = performance.now();
              try {
                const testSystem = await this.facadeCoordinator.getNonVisualSystem("PerformanceAnalyzer");
                const initEndTime = performance.now();
                const initTime = initEndTime - initStartTime;
                validationResults.parallelInitialization = initTime < 100;
                if (validationResults.parallelInitialization && this.YEAR3000_CONFIG.enableDebug) {
                  console.log(`\u2713 [Validation] Parallel initialization optimization working (${initTime.toFixed(2)}ms)`);
                } else if (this.YEAR3000_CONFIG.enableDebug) {
                  console.warn(`\u26A0 [Validation] Initialization may be slow (${initTime.toFixed(2)}ms)`);
                }
              } catch (error) {
                validationResults.errors.push(`Parallel initialization test failed: ${error}`);
              }
              try {
                const healthCheck = await this.facadeCoordinator.performHealthCheck();
                validationResults.facadeHealthCheck = healthCheck.overall === "excellent" || healthCheck.overall === "good";
                if (validationResults.facadeHealthCheck && this.YEAR3000_CONFIG.enableDebug) {
                  console.log(`\u2713 [Validation] Facade health check passed (${healthCheck.overall})`);
                } else {
                  validationResults.errors.push(`Facade health check failed: ${healthCheck.overall}`);
                  if (healthCheck.recommendations?.length > 0) {
                    console.warn("\u{1F527} [Validation] Health recommendations:", healthCheck.recommendations);
                  }
                }
              } catch (error) {
                validationResults.errors.push(`Facade health check error: ${error}`);
              }
            } else {
              validationResults.errors.push("Facade coordinator not available for validation");
            }
            const totalTests = 4;
            const passedTests = [
              validationResults.cssControllerAlias,
              validationResults.strategyPatternSystems,
              validationResults.parallelInitialization,
              validationResults.facadeHealthCheck
            ].filter(Boolean).length;
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(`\u{1F50D} [Year3000System] Facade validation complete: ${passedTests}/${totalTests} tests passed`);
              if (validationResults.errors.length > 0) {
                console.warn("\u26A0 [Year3000System] Validation errors:", validationResults.errors);
              }
              if (passedTests === totalTests) {
                console.log("\u{1F389} [Year3000System] All facade integration fixes validated successfully!");
              }
            }
            window.Y3K_FACADE_VALIDATION = validationResults;
          } catch (error) {
            console.error("\u{1F50D} [Year3000System] Facade validation failed:", error);
            validationResults.errors.push(`Validation process error: ${error}`);
          }
        }
        /**
         * Link system dependencies after facade initialization
         * Phase 4: Connect systems that need cross-references
         */
        async _linkSystemDependencies() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F30C} [Year3000System] Linking system dependencies...");
          }
          try {
            if (this.musicSyncService && this.colorHarmonyEngine) {
              this.musicSyncService.setColorHarmonyEngine(this.colorHarmonyEngine);
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F30C} [Year3000System] ColorHarmonyEngine linked to MusicSyncService"
                );
              }
            }
            if (this.colorHarmonyEngine && this.enhancedMasterAnimationCoordinator) {
              this.colorHarmonyEngine.setEmergentEngine(
                this.enhancedMasterAnimationCoordinator
              );
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F30C} [Year3000System] EnhancedMasterAnimationCoordinator (with emergent functionality) linked to ColorHarmonyEngine"
                );
              }
            }
            if (this.systemHealthMonitor) {
              const systemsToRegister = [
                { name: "MusicSyncService", system: this.musicSyncService },
                { name: "ColorHarmonyEngine", system: this.colorHarmonyEngine },
                { name: "SettingsManager", system: this.settingsManager }
              ];
              for (const { name, system } of systemsToRegister) {
                if (system) {
                  this.systemHealthMonitor.registerSystem(name, system);
                }
              }
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F30C} [Year3000System] Systems registered with health monitor"
                );
              }
            }
          } catch (error) {
            console.error(
              "\u{1F30C} [Year3000System] Failed to link system dependencies:",
              error
            );
          }
        }
        /**
         * Legacy function - removed prediction systems entirely for performance optimization
         */
        _shouldSkipPredictionSystem(systemName) {
          return false;
        }
        async _initializeVisualSystems(results) {
          if (!this.performanceAnalyzer || !this.musicSyncService || !this.settingsManager) {
            console.error(
              "[Year3000System] Cannot initialize visual systems due to missing core dependencies (SimplePerformanceCoordinator, MusicSyncService, or SettingsManager)."
            );
            const visualSystems = [
              "InteractionTrackingSystem",
              "BeatSyncVisualSystem",
              "SidebarSystemsIntegration"
              // "EmergentChoreographyEngine", // Consolidated into EnhancedMasterAnimationCoordinator
            ];
            visualSystems.forEach((s) => results.skipped.push(s));
            return;
          }
          if (this.colorHarmonyEngine && this.enhancedMasterAnimationCoordinator) {
            this.colorHarmonyEngine.setEmergentEngine(
              this.enhancedMasterAnimationCoordinator
            );
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F517} [Year3000System] EnhancedMasterAnimationCoordinator (emergent functionality) linked to ColorHarmonyEngine."
              );
            }
          }
        }
        async destroyAllSystems() {
          if (this.facadeCoordinator) {
            await this.facadeCoordinator.destroy();
            this.facadeCoordinator = null;
          }
          this._initializationResults = null;
          if (Spicetify.Player && this._songChangeHandler) {
            Spicetify.Player.removeEventListener(
              "songchange",
              this._songChangeHandler
            );
          }
          this.initialized = false;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F525} [Year3000System] All systems have been destroyed.");
          }
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this._boundExternalSettingsHandler
          );
          document.removeEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          document.removeEventListener(
            "visibilitychange",
            this._boundVisibilityChangeHandler
          );
          if (this._disposeNowPlayingWatcher) {
            this._disposeNowPlayingWatcher();
            this._disposeNowPlayingWatcher = null;
          }
        }
        async applyInitialSettings(trigger) {
          if (!this.settingsManager) {
            console.warn(
              "[Year3000System] SettingsManager not ready, cannot apply initial settings."
            );
            return;
          }
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `\u{1F3A8} [Year3000System] Inside applyInitialSettings. Trigger: ${trigger || "full"}, SettingsManager valid:`,
              !!this.settingsManager
            );
          }
          try {
            if (trigger === "flavor" || trigger === "brightness" || trigger === "accent") {
              console.log(
                `\u{1F3A8} [Year3000System] Selective update for trigger: ${trigger}`
              );
              await this.updateColorStateOnly(trigger);
              await this.refreshColorDependentSystems(trigger);
              return;
            }
            console.log(
              "\u{1F3A8} [Year3000System] applyInitialSettings: Getting initial settings..."
            );
            if (this.colorStateManager && !this.colorStateManager.initialized) {
              console.log("\u{1F3A8} [Year3000System] Initializing ColorStateManager...");
              await this.colorStateManager.initialize();
            }
            if (this.colorStateManager?.initialized) {
              console.log(
                "\u{1F3A8} [Year3000System] Applying initial color state via ColorStateManager..."
              );
              await this.colorStateManager.applyInitialColorState();
            } else {
              console.warn(
                "\u{1F3A8} [Year3000System] ColorStateManager not available, using legacy color application"
              );
              const accent = this.settingsManager.get("catppuccin-accentColor");
              if (accent !== "dynamic") {
                await this._applyCatppuccinAccent(accent);
              }
            }
            const gradient = this.settingsManager.get("sn-gradient-intensity");
            const stars = gradient;
            const intensityRaw = this.settingsManager.get("sn-harmonic-intensity");
            const evolutionRaw = this.settingsManager.get("sn-harmonic-evolution");
            const harmonicModeKey = this.settingsManager.get(
              "sn-current-harmonic-mode"
            );
            if (harmonicModeKey) {
              this.YEAR3000_CONFIG.currentHarmonicMode = String(harmonicModeKey);
            }
            console.log(
              `\u{1F3A8} [Year3000System] applyInitialSettings: Gradient=${gradient}, Stars=${stars}, ColorState=${!!this.colorStateManager?.initialized}`
            );
            await this._applyStarryNightSettings(
              gradient,
              stars
            );
            const intensity = parseFloat(intensityRaw);
            if (!Number.isNaN(intensity)) {
              if (this.colorHarmonyEngine) {
                this.colorHarmonyEngine.setIntensity?.(intensity);
              }
              this.YEAR3000_CONFIG.harmonicIntensity = intensity;
            }
            const evolutionEnabled = evolutionRaw === "true";
            this.allowHarmonicEvolution = evolutionEnabled;
            this.YEAR3000_CONFIG.harmonicEvolution = evolutionEnabled;
            console.log(
              "\u{1F3A8} [Year3000System] applyInitialSettings: Successfully applied initial settings."
            );
          } catch (error) {
            console.error("[Year3000System] Error applying initial settings:", error);
          }
        }
        /**
         * Update only color state without full settings reload
         */
        async updateColorStateOnly(trigger) {
          if (!this.colorStateManager?.initialized) {
            console.warn(
              `\u{1F3A8} [Year3000System] ColorStateManager not available for ${trigger} update`
            );
            return;
          }
          console.log(
            `\u{1F3A8} [Year3000System] Updating color state for trigger: ${trigger}`
          );
          await this.colorStateManager.updateColorState(trigger);
        }
        /**
         * Refresh only color-dependent systems efficiently
         */
        async refreshColorDependentSystems(trigger) {
          if (!this.facadeCoordinator) {
            console.warn(
              `\u{1F3A8} [Year3000System] No facade coordinator available for ${trigger} refresh`
            );
            return;
          }
          console.log(
            `\u{1F3A8} [Year3000System] Refreshing color-dependent systems for trigger: ${trigger}`
          );
          await this.facadeCoordinator.refreshColorDependentSystems(trigger);
        }
        async _applyCatppuccinAccent(selectedAccent) {
          if (selectedAccent === "dynamic") {
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F3A8} [Year3000System] _applyCatppuccinAccent: 'dynamic' accent selected \u2013 skipping static accent overrides."
              );
            }
            return;
          }
          console.log(
            `\u{1F3A8} [Year3000System] _applyCatppuccinAccent: Applying accent color '${selectedAccent}'`
          );
          const accent = selectedAccent === "none" ? "text" : selectedAccent;
          const colorScheme = Spicetify.Config.color_scheme || "mocha";
          const equalizerUrl = document.querySelector(
            "body > script.marketplaceScript"
          ) ? `url('https://github.com/catppuccin/spicetify/blob/main/catppuccin/assets/${colorScheme}/equalizer-animated-${accent}.gif?raw=true')` : `url('${colorScheme}/equalizer-animated-${accent}.gif')`;
          this.cssConsciousnessController?.queueCSSVariableUpdate(
            "--spice-text",
            `var(--spice-${accent})`
          );
          this.cssConsciousnessController?.queueCSSVariableUpdate(
            "--spice-button-active",
            `var(--spice-${accent})`
          );
          this.cssConsciousnessController?.queueCSSVariableUpdate(
            "--spice-equalizer",
            equalizerUrl
          );
          this.cssConsciousnessController?.flushCSSVariableBatch();
          console.log(
            `\u{1F3A8} [Year3000System] _applyCatppuccinAccent: Flushed CSS variables for accent color.`
          );
        }
        async _applyStarryNightSettings(gradientIntensity, starDensity) {
          try {
            applyStarryNightSettings(gradientIntensity, starDensity);
          } catch (error) {
            console.error("[Year3000System] Failed to apply starry night settings");
          }
        }
        applyColorsToTheme(extractedColors = {}) {
          let harmonizedColors = extractedColors;
          if (this.colorHarmonyEngine) {
            try {
              harmonizedColors = this.colorHarmonyEngine.blendWithCatppuccin(extractedColors);
            } catch (error) {
              console.error(
                "[Year3000System] ColorHarmonyEngine blend failed:",
                error
              );
            }
          }
          const accentHex = harmonizedColors.accentHex || harmonizedColors.VIBRANT || harmonizedColors.PROMINENT || Object.values(harmonizedColors)[0] || "#37416b";
          const accentRgb = harmonizedColors.accentRgb || (() => {
            const rgb = this.utils.hexToRgb(accentHex);
            return rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "166,173,200";
          })();
          this._applyColorsViaFacadeSystem(
            harmonizedColors,
            accentHex,
            accentRgb
          );
        }
        /**
         * Handle colors:harmonized event from ColorHarmonyEngine (Event-driven architecture)
         *  PHASE 1: Enhanced with loop prevention and recursion protection
         */
        handleColorHarmonizedEvent(data) {
          if (this.colorEventState.isProcessingColorEvent) {
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.warn(
                "\u{1F504} [Year3000System] Already processing color event - skipping to prevent recursion"
              );
            }
            return;
          }
          const eventContext = JSON.stringify(data).substring(0, 100);
          const eventHash = this._generateEventHash(eventContext);
          const now = Date.now();
          if (this.colorEventState.processedEvents.has(eventHash)) {
            const lastProcessed = this.colorEventState.processedEvents.get(eventHash);
            if (now - lastProcessed < this.COLOR_EVENT_CACHE_TTL) {
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.warn(
                  "\u{1F504} [Year3000System] Event recently processed - skipping duplicate"
                );
              }
              return;
            }
          }
          this.colorEventState.isProcessingColorEvent = true;
          this.colorEventState.processedEvents.set(eventHash, now);
          this.colorEventState.eventTimeout = window.setTimeout(() => {
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.warn(
                "\u{1F504} [Year3000System] Color event processing timeout - resetting state"
              );
            }
            this._resetColorEventState();
          }, this.PROCESSING_TIMEOUT);
          try {
            this.processingState.processingChain.push("handleColorHarmonizedEvent");
            if (this.processingState.processingChain.length > this.MAX_CHAIN_LENGTH) {
              this.processingState.eventLoopDetected = true;
              console.error(
                "\u{1F504} [Year3000System] CRITICAL: Event loop detected - chain length exceeded",
                this.processingState.processingChain
              );
              this._resetProcessingState();
              return;
            }
            let processedColors;
            let accentHex;
            let accentRgb;
            let strategies;
            let processingTime;
            if (data.processedColors && data.accentHex && data.accentRgb) {
              processedColors = data.processedColors;
              accentHex = data.accentHex;
              accentRgb = data.accentRgb;
              strategies = data.strategies || ["ColorHarmonyEngine"];
              processingTime = data.processingTime || 0;
            } else if (data.payload && data.payload.processedColors) {
              processedColors = data.payload.processedColors;
              accentHex = data.payload.accentHex || Object.values(processedColors)[0] || "#a6adc8";
              accentRgb = this.utils.hexToRgb(accentHex)?.r + "," + this.utils.hexToRgb(accentHex)?.g + "," + this.utils.hexToRgb(accentHex)?.b || "166,173,200";
              strategies = [data.payload.metadata?.strategy || "Unknown"];
              processingTime = data.payload.metadata?.processingTime || 0;
            } else if (data.type === "colors/harmonized") {
              return;
            } else {
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.warn(
                  "\u{1F3A8} [Year3000System] Unrecognized colors:harmonized event format:",
                  data
                );
              }
              return;
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Processing colors:harmonized event:", {
                strategies,
                processingTime,
                colorsCount: Object.keys(processedColors).length,
                accentHex,
                accentRgb,
                chainLength: this.processingState.processingChain.length
              });
            }
            this._applyColorsViaFacadeSystem(processedColors, accentHex, accentRgb);
          } catch (error) {
            console.error(
              "[Year3000System] Failed to handle colors:harmonized event:",
              error
            );
          } finally {
            this._resetColorEventState();
            const chainIndex = this.processingState.processingChain.indexOf(
              "handleColorHarmonizedEvent"
            );
            if (chainIndex > -1) {
              this.processingState.processingChain.splice(chainIndex, 1);
            }
          }
        }
        /**
         * Phase 1: Helper method to generate simple hash for event caching
         */
        _generateEventHash(context) {
          let hash = 0;
          for (let i = 0; i < context.length; i++) {
            const char = context.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
          }
          return hash.toString();
        }
        /**
         * Phase 1: Reset color event processing state
         */
        _resetColorEventState() {
          this.colorEventState.isProcessingColorEvent = false;
          if (this.colorEventState.eventTimeout) {
            clearTimeout(this.colorEventState.eventTimeout);
            this.colorEventState.eventTimeout = null;
          }
          const now = Date.now();
          for (const [
            hash,
            timestamp
          ] of this.colorEventState.processedEvents.entries()) {
            if (now - timestamp > this.COLOR_EVENT_CACHE_TTL) {
              this.colorEventState.processedEvents.delete(hash);
            }
          }
        }
        /**
         * Phase 1: Reset processing state after loop detection or timeout
         */
        _resetProcessingState() {
          this.processingState.isProcessingSongChange = false;
          this.processingState.processingChain = [];
          this.processingState.eventLoopDetected = false;
          this.processingState.lastProcessingTime = Date.now();
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F504} [Year3000System] Processing state reset");
          }
        }
        /**
         * Apply colors via delegation to CSS authority systems
         * Delegates Spicetify variables to ColorStateManager and DynamicCatppuccinBridge
         */
        _applyColorsViaFacadeSystem(processedColors, accentHex, accentRgb) {
          try {
            const cssVariables = {};
            Object.entries(processedColors).forEach(([key, value]) => {
              if (this.utils.isValidHexColor(value)) {
                const rgb = this.utils.hexToRgb(value);
                if (rgb) {
                  cssVariables[`--sn-processed-${key.toLowerCase()}-hex`] = value;
                  cssVariables[`--sn-processed-${key.toLowerCase()}-rgb`] = `${rgb.r},${rgb.g},${rgb.b}`;
                }
              } else if (this.YEAR3000_CONFIG.enableDebug) {
                console.debug(
                  `[Year3000System] Skipping non-hex processedColor: ${key}=${value}`
                );
              }
            });
            const musicalHarmonyMapping = {
              // Musical harmony RGB variables for OKLAB color science integration
              "--sn-musical-harmony-primary-rgb": processedColors.VIBRANT || processedColors.PRIMARY || accentRgb,
              "--sn-musical-harmony-secondary-rgb": processedColors.DARK_VIBRANT || processedColors.SECONDARY || accentRgb,
              "--sn-musical-harmony-tertiary-rgb": processedColors.VIBRANT_NON_ALARMING || processedColors.LIGHT_VIBRANT || accentRgb,
              "--sn-musical-harmony-quaternary-rgb": processedColors.DESATURATED || processedColors.EMOTIONAL_BLEND || accentRgb,
              // Musical harmony hex variables for gradient systems
              "--sn-musical-harmony-primary-hex": processedColors.VIBRANT || processedColors.PRIMARY || accentHex,
              "--sn-musical-harmony-secondary-hex": processedColors.DARK_VIBRANT || processedColors.SECONDARY || accentHex,
              "--sn-musical-harmony-tertiary-hex": processedColors.VIBRANT_NON_ALARMING || processedColors.LIGHT_VIBRANT || accentHex,
              "--sn-musical-harmony-quaternary-hex": processedColors.DESATURATED || processedColors.EMOTIONAL_BLEND || accentHex,
              // OKLAB processing results for color science systems
              "--sn-musical-oklab-primary-rgb": processedColors.VIBRANT || processedColors.PRIMARY || processedColors.PROMINENT || accentRgb,
              "--sn-musical-oklab-accent-rgb": processedColors.DARK_VIBRANT || processedColors.DESATURATED || accentRgb,
              "--sn-musical-oklab-highlight-rgb": processedColors.VIBRANT_NON_ALARMING || processedColors.LIGHT_VIBRANT || accentRgb,
              "--sn-musical-oklab-shadow-rgb": processedColors.DARK_VIBRANT || processedColors.DESATURATED || accentRgb,
              "--sn-musical-oklab-complementary-rgb": processedColors.SECONDARY || processedColors.EMOTIONAL_BLEND || accentRgb,
              "--sn-musical-oklab-triadic-rgb": processedColors.LIGHT_VIBRANT || processedColors.VIBRANT_NON_ALARMING || accentRgb
            };
            Object.entries(musicalHarmonyMapping).forEach(([cssVar, colorValue]) => {
              if (!colorValue || typeof colorValue !== "string") return;
              if (cssVar.includes("-hex")) {
                cssVariables[cssVar] = colorValue;
              } else if (cssVar.includes("-rgb")) {
                if (this.utils.isValidHexColor(colorValue)) {
                  const rgb = this.utils.hexToRgb(colorValue);
                  if (rgb) {
                    cssVariables[cssVar] = `${rgb.r},${rgb.g},${rgb.b}`;
                  }
                } else if (colorValue.includes(",")) {
                  cssVariables[cssVar] = colorValue;
                }
              }
            });
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Musical Harmony Color Processing:", {
                // ColorHarmonyEngine output
                colorHarmonyKeys: Object.keys(processedColors),
                colorHarmonyValues: processedColors,
                // Musical harmony bridge variables (specialized for OKLAB)
                musicalHarmonyVariables: musicalHarmonyMapping,
                // CSS variable chain status
                expectedCSSChain: [
                  "--sn-musical-oklab-primary-rgb",
                  "--sn-musical-harmony-primary-rgb",
                  "--sn-gradient-primary-rgb"
                ],
                // Note: Spicetify variables handled by CSS authority systems
                totalVariablesSet: Object.keys(cssVariables).length,
                cssAuthorityDelegation: "ColorStateManager + DynamicCatppuccinBridge"
              });
            }
            if (this.cssConsciousnessController && typeof this.cssConsciousnessController.batchSetVariables === "function") {
              this.cssConsciousnessController.batchSetVariables(
                "Year3000System-ColorHarmonized",
                cssVariables,
                "high",
                "color-harmony-event-application"
              );
            } else {
              this._applyCSSVariables(cssVariables);
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F527} [Year3000System] Applied musical harmony variables via CSS coordination:", {
                totalVariables: Object.keys(cssVariables).length,
                accentColor: accentHex,
                cssControllerUsed: !!this.cssConsciousnessController,
                spicetifyDelegation: "ColorStateManager + DynamicCatppuccinBridge handle --spice-* variables"
              });
            }
          } catch (error) {
            console.error(
              "[Year3000System] Failed to apply musical harmony variables:",
              error
            );
            const fallbackVariables = {
              "--sn-musical-harmony-primary-hex": accentHex,
              "--sn-musical-harmony-primary-rgb": accentRgb
            };
            this._applyCSSVariables(fallbackVariables);
          }
        }
        /**
         * Apply CSS variables directly (optimization for event-driven pattern)
         */
        _applyCSSVariables(cssVariables) {
          try {
            const root = document.documentElement;
            for (const [variable, value] of Object.entries(cssVariables)) {
              if (variable && value) {
                root.style.setProperty(variable, value);
              }
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Applied CSS variables directly", {
                variablesCount: Object.keys(cssVariables).length,
                variables: Object.keys(cssVariables)
              });
            }
          } catch (error) {
            console.error("[Year3000System] Failed to apply CSS variables:", error);
          }
        }
        // =============================================
        //  LEGACY METHOD REMOVED: _applyHarmonizedColorsToCss()
        // Replaced by comprehensive OKLAB-enabled _applyColorsViaFacadeSystem()
        // =============================================
        // =============================================
        //  PUBLIC WRAPPER  UNIFIED CSS VARIABLE BATCH API
        // =============================================
        /**
         * Queue a CSS variable update through the shared UnifiedCSSVariableManager. Falls
         * back to an immediate style mutation when the batcher is unavailable
         * (degraded mode or very early boot).
         *
         * @param property  The CSS custom property name (e.g. "--sn-nav-intensity")
         * @param value     The value to assign (raw string, keep units if needed)
         * @param element   Optional specific HTMLElement target. When omitted the
         *                  root <html> element is used so variables cascade.
         */
        queueCSSVariableUpdate(property, value, element = null) {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueUpdate(
              property,
              value,
              "normal",
              "Year3000System"
            );
          } else if (this.cssConsciousnessController) {
            this.cssConsciousnessController.queueCSSVariableUpdate(
              property,
              value,
              element || void 0
            );
          } else {
            const target = element || document.documentElement;
            target.style.setProperty(property, value);
          }
        }
        setGradientParameters() {
          if (this.colorHarmonyEngine) {
          }
        }
        async updateColorsFromCurrentTrack() {
          if (this.musicSyncService) {
            await this.musicSyncService.processSongUpdate();
          }
        }
        evolveHarmonicSignature(selectedModeKey, baseSourceHex) {
          if (this.colorHarmonyEngine) {
            const rgb = this.utils.hexToRgb(baseSourceHex);
            if (rgb) {
              const variations = this.colorHarmonyEngine.generateHarmonicVariations(rgb);
              return {
                derivedDarkVibrantHex: variations.darkVibrantHex,
                derivedLightVibrantHex: variations.lightVibrantHex
              };
            }
          }
          return null;
        }
        async waitForTrackData(maxRetries = 10, delayMs = 100) {
          for (let i = 0; i < maxRetries; i++) {
            if (Spicetify.Player.data?.track?.uri) {
              return Spicetify.Player.data;
            }
            await this.utils.sleep(delayMs);
          }
          return null;
        }
        updateHarmonicBaseColor(hexColor) {
          if (this.colorHarmonyEngine && this.cssConsciousnessController) {
            const rgb = this.utils.hexToRgb(hexColor);
            if (rgb) {
              const variations = this.colorHarmonyEngine.generateHarmonicVariations(rgb);
              this.cssConsciousnessController.queueCSSVariableUpdate(
                "--sn-harmonic-base-dark-vibrant",
                variations.darkVibrantHex
              );
              this.cssConsciousnessController.queueCSSVariableUpdate(
                "--sn-harmonic-base-light-vibrant",
                variations.lightVibrantHex
              );
              this.cssConsciousnessController.flushCSSVariableBatch();
            }
          }
        }
        /**
         * Process colors through the existing facade pattern architecture
         * Phase 1: Integration with SystemCoordinator and ColorOrchestrator
         */
        async processColorsViaFacade(context) {
          try {
            const colorOrchestrator = await this.facadeCoordinator?.getNonVisualSystem("ColorOrchestrator");
            if (colorOrchestrator && typeof colorOrchestrator.handleColorExtraction === "function") {
              await colorOrchestrator.handleColorExtraction(context);
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F3A8} [Year3000System] Color processing routed through facade pattern - ColorOrchestrator",
                  {
                    context: context?.trackUri || "unknown",
                    rawColorsCount: context?.rawColors ? Object.keys(context.rawColors).length : 0
                  }
                );
              }
            } else {
              if (this.colorHarmonyEngine && typeof this.colorHarmonyEngine.processColors === "function") {
                await this.colorHarmonyEngine.processColors(context);
                if (this.YEAR3000_CONFIG.enableDebug) {
                  console.log(
                    "\u{1F3A8} [Year3000System] Color processing fallback to direct ColorHarmonyEngine"
                  );
                }
              } else {
                console.warn(
                  "[Year3000System] No color processing system available via facade pattern"
                );
              }
            }
          } catch (error) {
            console.error(
              "[Year3000System] Failed to process colors via facade pattern:",
              error
            );
            if (context?.rawColors) {
              this.applyColorsToTheme(context.rawColors);
            }
          }
        }
        setupMusicAnalysisAndColorExtraction() {
          console.log(
            "\u{1F3B5} [Year3000System] setupMusicAnalysisAndColorExtraction called"
          );
          if (!this.musicSyncService) {
            console.error(
              "[Year3000System] MusicSyncService is not available to set up song change handler."
            );
            return;
          }
          console.log(
            "\u{1F3B5} [Year3000System] MusicSyncService available, checking Spicetify Player..."
          );
          if (!window.Spicetify?.Player) {
            console.warn(
              "[Year3000System] Spicetify.Player not available - music analysis disabled"
            );
            return;
          }
          try {
            unifiedEventBus.subscribe(
              "colors:harmonized",
              (data) => {
                this.handleColorHarmonizedEvent(data);
              },
              "Year3000System"
            );
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F3A8} [Year3000System] Subscribed to colors:harmonized events for event-driven color application"
              );
            }
          } catch (error) {
            console.error(
              "[Year3000System] Failed to subscribe to colors:harmonized events:",
              error
            );
          }
          const processSongUpdate = /* @__PURE__ */ __name(async () => {
            console.log(
              "\u{1F3B5} [Year3000System] processSongUpdate triggered - checking MusicSyncService..."
            );
            if (this.musicSyncService) {
              console.log(
                "\u{1F3B5} [Year3000System] Calling musicSyncService.processSongUpdate()"
              );
              await this.musicSyncService.processSongUpdate();
              console.log(
                "\u2705 [Year3000System] musicSyncService.processSongUpdate() completed"
              );
            } else {
              console.error(
                "\u274C [Year3000System] MusicSyncService not available in processSongUpdate"
              );
            }
          }, "processSongUpdate");
          this._songChangeHandler = processSongUpdate;
          try {
            console.log("\u{1F3B5} [Year3000System] Adding songchange event listener...");
            window.Spicetify.Player.addEventListener(
              "songchange",
              this._songChangeHandler
            );
            console.log(
              "\u2705 [Year3000System] Music analysis and color extraction set up successfully - song change listener active"
            );
            console.log("\u{1F3B5} [Year3000System] Triggering initial song processing...");
            setTimeout(processSongUpdate, 1e3);
          } catch (error) {
            console.error("[Year3000System] Failed to set up music analysis:", error);
            this._songChangeHandler = null;
          }
        }
        updateFromMusicAnalysis(processedData, rawFeatures, trackUri) {
          if (!processedData) return;
          this._updateGlobalKinetics(processedData);
        }
        _updateGlobalKinetics(data) {
          const root = this.utils.getRootStyle();
          if (!root) return;
          const safe = /* @__PURE__ */ __name((value, fallback = 0) => Number.isFinite(value) ? value : fallback, "safe");
          const processedEnergy = safe(data.processedEnergy);
          const valence = safe(data.valence);
          const enhancedBPM = safe(data.enhancedBPM);
          const beatInterval = safe(data.beatInterval);
          const animationSpeed = safe(data.animationSpeedFactor, 1);
          root.style.setProperty("--sn-kinetic-energy", processedEnergy.toFixed(3));
          root.style.setProperty("--sn-kinetic-valence", valence.toFixed(3));
          root.style.setProperty("--sn-kinetic-bpm", enhancedBPM.toFixed(2));
          root.style.setProperty(
            "--sn-kinetic-beat-interval",
            `${beatInterval.toFixed(0)}ms`
          );
          root.style.setProperty(
            "--sn-kinetic-animation-speed",
            animationSpeed.toFixed(3)
          );
        }
        // Animation System Registration Methods
        registerAnimationSystem(name, system, priority = "normal", targetFPS = 60) {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              `[Year3000System] Cannot register ${name} - EnhancedMasterAnimationCoordinator not ready`
            );
            return false;
          }
          this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
            name,
            system,
            priority,
            targetFPS
          );
          return true;
        }
        unregisterAnimationSystem(name) {
          if (!this.enhancedMasterAnimationCoordinator) {
            return false;
          }
          this.enhancedMasterAnimationCoordinator.unregisterAnimationSystem(name);
          return true;
        }
        /**
         * Public accessor that returns a subsystem instance by its constructor name or
         * by the conventional camel-cased property key. This is primarily used for
         * loose coupling between visual systems (e.g. BehaviouralPredictionEngine 
         * PredictiveMaterializationSystem). Returns `null` when the requested system
         * is not available or not yet initialised.
         */
        getSystem(name) {
          if (!name) return null;
          if (this.facadeCoordinator) {
            const visualSystem2 = this.facadeCoordinator.getVisualSystem(name);
            if (visualSystem2) return visualSystem2;
            const nonVisualSystem = this.facadeCoordinator.getCachedNonVisualSystem(
              name
            );
            if (nonVisualSystem) return nonVisualSystem;
          }
          const camel = name.charAt(0).toLowerCase() + name.slice(1);
          if (this[camel]) return this[camel];
          for (const key of Object.keys(this)) {
            const maybeInstance = this[key];
            if (maybeInstance && maybeInstance.constructor?.name === name) {
              return maybeInstance;
            }
          }
          return null;
        }
        /**
         * Get health status of all facade systems
         */
        async getFacadeSystemHealthStatus() {
          if (!this.facadeCoordinator) return null;
          return await this.facadeCoordinator.performHealthCheck();
        }
        async _registerAnimationSystems() {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for visual system registration"
            );
            return;
          }
          const visualSystems = [
            {
              name: "BeatSyncVisualSystem",
              system: this.beatSyncVisualSystem,
              priority: "critical"
            },
            // EmergentChoreographyEngine consolidated into EnhancedMasterAnimationCoordinator
            {
              name: "SidebarSystemsIntegration",
              system: this.sidebarSystemsIntegration,
              priority: "normal"
            },
            {
              name: "ParticleConsciousnessModule",
              system: this.particleConsciousnessModule,
              priority: "background"
            },
            {
              name: "InteractionTrackingSystem",
              system: this.interactionTrackingSystem,
              priority: "background"
            },
            {
              name: "SpotifyUIApplicationSystem",
              system: this.spotifyUIApplicationSystem,
              priority: "normal"
            }
          ];
          for (const { name, system, priority } of visualSystems) {
            if (system && (typeof system.onAnimate === "function" || typeof system.updateAnimation === "function")) {
              let optimizedPriority = priority;
              let targetFPS = 60;
              const currentProfile = system.currentPerformanceProfile;
              if (currentProfile?.frameRate) {
                targetFPS = currentProfile.frameRate;
              } else if (currentProfile?.quality) {
                const quality = currentProfile.quality;
                targetFPS = quality === "high" ? 60 : quality === "low" ? 30 : 45;
              }
              if (name.includes("BeatSync")) {
                optimizedPriority = "critical";
              } else if (name.includes("Particle") || name.includes("DataGlyph")) {
                optimizedPriority = "background";
                targetFPS = Math.min(targetFPS, 30);
              }
              this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
                name,
                system,
                optimizedPriority,
                targetFPS
              );
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  `\u{1F3AC} [Year3000System] Registered ${name} with Enhanced Master Animation Coordinator (${optimizedPriority} priority, ${targetFPS}fps) - using ${typeof system.onAnimate === "function" ? "onAnimate" : "updateAnimation"} hook`
                );
              }
            }
          }
        }
        /**
         * Register visual systems with the EnhancedMasterAnimationCoordinator
         * Phase 4: Animation System Consolidation
         */
        async _registerEnhancedAnimationSystems() {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for enhanced visual system registration"
            );
            return;
          }
          const enhancedVisualSystems = [
            {
              name: "BeatSyncVisualSystem",
              system: this.beatSyncVisualSystem,
              priority: "critical",
              type: "animation"
            },
            // EmergentChoreographyEngine consolidated into EnhancedMasterAnimationCoordinator
            {
              name: "SidebarSystemsIntegration",
              system: this.sidebarSystemsIntegration,
              priority: "normal",
              type: "animation"
            },
            {
              name: "ParticleConsciousnessModule",
              system: this.particleConsciousnessModule,
              priority: "background",
              type: "animation"
            },
            {
              name: "InteractionTrackingSystem",
              system: this.interactionTrackingSystem,
              priority: "background",
              type: "animation"
            },
            {
              name: "SpotifyUIApplicationSystem",
              system: this.spotifyUIApplicationSystem,
              priority: "normal",
              type: "animation"
            }
          ];
          for (const { name, system, priority, type } of enhancedVisualSystems) {
            if (system) {
              try {
                let registered = false;
                if (type === "animation" && (typeof system.onAnimate === "function" || typeof system.updateAnimation === "function")) {
                  registered = this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
                    name,
                    system,
                    priority,
                    60
                    // Default 60fps
                  );
                }
                if (registered && this.YEAR3000_CONFIG.enableDebug) {
                  console.log(
                    `\u{1F3AC} [Year3000System] Enhanced registration: ${name} (${priority} priority, ${type} type)`
                  );
                } else if (!registered) {
                  console.warn(
                    `[Year3000System] Failed to register ${name} with EnhancedMasterAnimationCoordinator`
                  );
                }
              } catch (error) {
                console.error(
                  `[Year3000System] Error registering ${name} with EnhancedMasterAnimationCoordinator:`,
                  error
                );
              }
            }
          }
        }
        // Progressive Loading Methods for Extension Support
        async initializeWithAvailableAPIs(availableAPIs) {
          this.availableAPIs = availableAPIs;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `\u{1F31F} [Year3000System] Progressive initialization mode: ${availableAPIs.degradedMode ? "DEGRADED" : "FULL"}`
            );
            console.log(`\u{1F31F} [Year3000System] Available APIs:`, {
              player: !!availableAPIs.player,
              platform: !!availableAPIs.platform,
              config: !!availableAPIs.config
            });
          }
          if (availableAPIs.degradedMode) {
            console.log(
              "\u{1F31F} [Year3000System] Initializing in degraded mode (visual-only systems)"
            );
            await this.initializeVisualOnlySystems();
          } else {
            console.log(
              "\u{1F31F} [Year3000System] Initializing in full mode (all systems)"
            );
            await this.initializeAllSystems();
          }
          if (availableAPIs.degradedMode) {
            this.setupProgressiveEnhancement();
          }
        }
        async initializeVisualOnlySystems() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Starting visual-only system initialization..."
            );
          }
          const startTime = performance.now();
          const initializationResults = {
            success: [],
            failed: [],
            skipped: []
          };
          try {
            this.facadeCoordinator = new SystemCoordinator(
              this.YEAR3000_CONFIG,
              this.utils,
              this
            );
            await this.facadeCoordinator.initialize({
              mode: "performance-optimized",
              enableSharedDependencies: true,
              enableCrossFacadeCommunication: false,
              enableUnifiedPerformanceMonitoring: true,
              enableResourceOptimization: true,
              performanceThresholds: {
                maxTotalMemoryMB: 50,
                maxTotalInitTime: 3e3,
                maxCrossCommLatency: 100
              },
              coordinationPreferences: {
                preferSharedResources: true,
                enableEventPropagation: false,
                enableHealthCoordination: true
              }
            });
            await this._initializeEssentialFacadeSystems();
            initializationResults.success.push("FacadeCoordinationSystem");
          } catch (error) {
            console.error(
              "\u{1F30C} [Year3000System] Failed to initialize degraded facade system:",
              error
            );
            initializationResults.failed.push("FacadeCoordinationSystem");
          }
          const skippedSystems = [
            "SettingsManager",
            "MusicSyncService",
            "ColorHarmonyEngine",
            "GlassmorphismManager",
            "Card3DManager",
            "All Visual Systems"
          ];
          initializationResults.skipped.push(...skippedSystems);
          this._initializationResults = initializationResults;
          this.initialized = true;
          const endTime = performance.now();
          const initTime = endTime - startTime;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `\u{1F31F} [Year3000System] Visual-only initialization complete in ${initTime.toFixed(
                2
              )}ms`
            );
            console.log(
              `\u{1F31F} [Year3000System] Results: ${initializationResults.success.length} success, ${initializationResults.failed.length} failed, ${initializationResults.skipped.length} skipped`
            );
          }
        }
        setupProgressiveEnhancement() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Setting up progressive enhancement monitoring..."
            );
          }
          let enhancementAttempts = 0;
          const maxEnhancementAttempts = 30;
          const enhancementInterval = setInterval(() => {
            enhancementAttempts++;
            const playerAvailable = !!window.Spicetify?.Player;
            const platformAvailable = !!window.Spicetify?.Platform;
            if (playerAvailable && platformAvailable && this.availableAPIs?.degradedMode) {
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F31F} [Year3000System] APIs now available! Triggering upgrade to full mode..."
                );
              }
              clearInterval(enhancementInterval);
              this.upgradeToFullMode().catch((error) => {
                console.error("[Year3000System] Upgrade to full mode failed:", error);
              });
            }
            if (enhancementAttempts >= maxEnhancementAttempts) {
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F31F} [Year3000System] Progressive enhancement monitoring stopped (timeout)"
                );
              }
              clearInterval(enhancementInterval);
            }
          }, 2e3);
        }
        async upgradeToFullMode() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Upgrading from degraded mode to full mode..."
            );
          }
          this.availableAPIs = {
            player: window.Spicetify?.Player,
            platform: window.Spicetify?.Platform,
            config: window.Spicetify?.Config,
            degradedMode: false
          };
          try {
            const upgradeResults = {
              success: [],
              failed: [],
              skipped: []
            };
            try {
              if (this.systemHealthMonitor) {
                this.systemHealthMonitor.registerSystem(
                  "SettingsManager",
                  this.settingsManager
                );
              }
              upgradeResults.success.push("SettingsManager");
            } catch (error) {
              upgradeResults.failed.push("SettingsManager");
              console.error(
                `[Year3000System] Failed to upgrade SettingsManager:`,
                error
              );
            }
            if (this.settingsManager) {
              try {
              } catch (error) {
              }
            }
            if (this.performanceAnalyzer && this.settingsManager) {
              try {
              } catch (error) {
              }
              if (this.enhancedMasterAnimationCoordinator) {
                await this._registerAnimationSystems();
              }
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "[Year3000System] Checking music analysis setup conditions:",
                {
                  musicSyncService: !!this.musicSyncService,
                  playerAPI: !!this.availableAPIs.player,
                  musicSyncInitialized: this.musicSyncService?.initialized
                }
              );
            }
            if (this.musicSyncService && this.availableAPIs.player) {
              console.log(
                "\u{1F3B5} [Year3000System] Setting up music analysis and color extraction..."
              );
              this.setupMusicAnalysisAndColorExtraction();
            } else {
              console.warn(
                "\u26A0\uFE0F [Year3000System] Music analysis setup skipped - missing dependencies:",
                {
                  musicSyncService: !!this.musicSyncService,
                  playerAPI: !!this.availableAPIs.player
                }
              );
            }
            if (this.settingsManager) {
              await this.applyInitialSettings();
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                `\u{1F31F} [Year3000System] Upgrade complete: ${upgradeResults.success.length} success, ${upgradeResults.failed.length} failed`
              );
              if (upgradeResults.failed.length > 0) {
                console.warn(
                  `\u{1F31F} [Year3000System] Upgrade failed systems: ${upgradeResults.failed.join(
                    ", "
                  )}`
                );
              }
              if (upgradeResults.skipped && upgradeResults.skipped.length > 0) {
                console.info(
                  `\u{1F31F} [Year3000System] Upgrade skipped systems: ${upgradeResults.skipped.join(
                    ", "
                  )}`
                );
              }
              if (upgradeResults.success.length > 0) {
                console.info(
                  `\u{1F31F} [Year3000System] Upgrade successful systems: ${upgradeResults.success.join(
                    ", "
                  )}`
                );
              }
            }
          } catch (error) {
            console.error(
              "[Year3000System] Error during upgrade to full mode:",
              error
            );
          }
        }
        _handleExternalSettingsChange(event) {
          const { key, value } = event.detail || {};
          if (!key) return;
          switch (key) {
            case "artisticMode": {
              try {
                if (typeof this.YEAR3000_CONFIG.safeSetArtisticMode === "function") {
                  this.YEAR3000_CONFIG.safeSetArtisticMode(value);
                }
              } catch (e) {
                console.warn("[Year3000System] Failed to apply artistic mode", e);
              }
              break;
            }
            case "harmonicIntensity": {
              const num = parseFloat(value);
              if (!Number.isNaN(num)) {
                this.YEAR3000_CONFIG.harmonicIntensity = num;
                if (this.colorHarmonyEngine) {
                  this.colorHarmonyEngine.setIntensity?.(num);
                  this.updateColorsFromCurrentTrack?.();
                }
              }
              break;
            }
            case "harmonicEvolution": {
              const enabled = value === "true" || value === true;
              this.allowHarmonicEvolution = enabled;
              this.YEAR3000_CONFIG.harmonicEvolution = enabled;
              break;
            }
            case "manualBaseColor": {
              if (typeof value === "string" && value.trim() !== "" && value.startsWith("#")) {
                this.updateHarmonicBaseColor(value);
                if (this.YEAR3000_CONFIG.enableDebug) {
                  console.log(
                    "\u{1F3A8} [Year3000System] Manual base color applied:",
                    value
                  );
                }
              } else if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F3A8} [Year3000System] Manual base color cleared - using album art colors"
                );
              }
              break;
            }
            case "harmonicMode": {
              if (value !== null && value !== void 0) {
                this.YEAR3000_CONFIG.currentHarmonicMode = String(value);
                this.updateColorsFromCurrentTrack?.();
              }
              break;
            }
            default:
              break;
          }
          this._broadcastSettingChange(key, value);
          this._refreshConditionalSystems();
        }
        /**
         * Notify all subsystems that implement applyUpdatedSettings so they can
         * adjust behaviour immediately after a SettingsManager change.
         */
        _broadcastSettingChange(key, value) {
          const systems = [
            this.colorHarmonyEngine,
            this.glassmorphismManager,
            this.card3DManager,
            this.lightweightParticleSystem,
            this.interactionTrackingSystem,
            this.beatSyncVisualSystem,
            this.sidebarSystemsIntegration,
            this.particleFieldSystem
            // contextMenuSystem removed
          ];
          systems.forEach((sys) => {
            if (sys && typeof sys.applyUpdatedSettings === "function") {
              try {
                sys.applyUpdatedSettings(key, value);
              } catch (err) {
                console.warn(
                  `[Year3000System] ${sys.systemName || sys.constructor?.name || "UnknownSystem"} failed to applyUpdatedSettings`,
                  err
                );
              }
            }
          });
        }
        // ---------------------------------------------------------------------------
        //   Placeholder implementations restored after merge conflict
        // ---------------------------------------------------------------------------
        /**
         * Apply the current performance profile to subsystems.
         * NOTE: Full implementation was lost in a previous edit; this stub preserves
         *        compile-time integrity until the original logic is reinstated.
         */
        _applyPerformanceProfile() {
        }
        /**
         * Refresh conditional visual systems (WebGL, ParticleField, etc.) depending
         * on capability and artistic mode settings.
         */
        _refreshConditionalSystems() {
        }
        /**
         * Handle artistic-mode changes by triggering a colour refresh.
         */
        _onArtisticModeChanged() {
          try {
            this.updateColorsFromCurrentTrack?.();
          } catch (e) {
            console.warn("[Year3000System] _onArtisticModeChanged stub error", e);
          }
        }
        _handleVisibilityChange() {
          if (document.visibilityState !== "hidden") return;
          try {
            this.cssConsciousnessController?.flushCSSVariableBatch?.();
            try {
            } catch {
            }
            if (this.YEAR3000_CONFIG?.enableDebug) {
              console.log(
                "\u{1F31F} [Year3000System] Visibility hidden \u2192 forced flush of pending style updates"
              );
            }
          } catch (e) {
            if (this.YEAR3000_CONFIG?.enableDebug) {
              console.warn("[Year3000System] VisibilityChange flush error", e);
            }
          }
        }
        /**
         * Destroy method for proper cleanup during testing
         */
        async destroy() {
          try {
            await this.destroyAllSystems();
            document.removeEventListener(
              "visibilitychange",
              this._handleVisibilityChange.bind(this)
            );
            this.initialized = false;
            console.log("\u{1F31F} [Year3000System] System destroyed successfully");
          } catch (error) {
            console.error("\u274C [Year3000System] Error during destroy:", error);
          }
        }
      };
      __name(_Year3000System, "Year3000System");
      Year3000System = _Year3000System;
      year3000System = new Year3000System();
      if (typeof window !== "undefined") {
        window.year3000System = year3000System;
      }
      year3000System_default = year3000System;
    }
  });

  // src-js/debug/DragCartographer.ts
  var DragCartographer_exports = {};
  __export(DragCartographer_exports, {
    enableDragCartography: () => enableDragCartography,
    getDragMap: () => getDragMap
  });
  function enableDragCartography() {
    const g = globalThis;
    if (g.__SN_dragCartographer) return;
    g.__SN_dragCartographer = new DragCartographer();
    console.info("\u{1F6F0}\uFE0F  DragCartographer enabled \u2013 logging dragstart events");
  }
  function getDragMap() {
    return DragCartographer.getDragMap();
  }
  var _DragCartographer, DragCartographer;
  var init_DragCartographer = __esm({
    "src-js/debug/DragCartographer.ts"() {
      "use strict";
      _DragCartographer = class _DragCartographer {
        constructor() {
          this.seen = /* @__PURE__ */ new WeakSet();
          this.handleDragStart = /* @__PURE__ */ __name((event) => {
            const target = event.target;
            if (!target) return;
            if (this.seen.has(target)) return;
            this.seen.add(target);
            const selector = _DragCartographer.buildSelectorPath(target);
            const detail = {
              time: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
              selector
            };
            try {
              const dt = event.dataTransfer;
              if (dt) {
                const uris = dt.getData("text/spotify") || dt.getData("text/uri-list");
                if (uris) {
                  detail.uris = uris.split(/\n|,/).filter(Boolean);
                }
                const label = dt.getData("text/plain");
                if (label) detail.label = label;
              }
            } catch {
            }
            const agg = _DragCartographer.aggregate;
            const entry = agg.get(selector);
            if (entry) {
              entry.count += 1;
              if (entry.samples.length < 3) entry.samples.push(detail);
            } else {
              agg.set(selector, { selector, count: 1, samples: [detail] });
            }
            console.groupCollapsed(
              `%c[DragCartographer] dragstart \u2192 ${selector}`,
              "color:#7dd3fc;font-weight:600"
            );
            console.table(detail);
            console.log("Event:", event);
            console.log("Target element snapshot:", target);
            console.groupEnd();
          }, "handleDragStart");
          document.addEventListener("dragstart", this.handleDragStart, true);
        }
        static buildSelectorPath(el) {
          const path = [];
          let current = el;
          let depth = 0;
          while (current && depth < _DragCartographer.MAX_PATH_DEPTH) {
            const tag = current.tagName.toLowerCase();
            const id = current.id ? `#${current.id}` : "";
            const cls = current.className && typeof current.className === "string" ? "." + current.className.split(/\s+/).slice(0, 2).join(".") : "";
            path.push(`${tag}${id}${cls}`);
            current = current.parentElement;
            depth += 1;
          }
          return path.join(" > ");
        }
        // Public helper to fetch map
        static getDragMap() {
          return Array.from(_DragCartographer.aggregate.values()).sort(
            (a, b) => b.count - a.count
          );
        }
      };
      __name(_DragCartographer, "DragCartographer");
      _DragCartographer.MAX_PATH_DEPTH = 4;
      _DragCartographer.aggregate = /* @__PURE__ */ new Map();
      DragCartographer = _DragCartographer;
      __name(enableDragCartography, "enableDragCartography");
      __name(getDragMap, "getDragMap");
    }
  });

  // src-js/utils/graphics/CanvasGhostBuilder.ts
  function buildDragGhostCanvas(label, imgSrc, opts = {}) {
    const key = `${label}|${imgSrc}|${opts.size}|${opts.dpr}`;
    const cached = cache.get(key);
    if (cached) return cached;
    const size = opts.size ?? 72;
    const dpr = opts.dpr ?? (window.devicePixelRatio || 1);
    const borderRadius = opts.borderRadius ?? 8;
    const canvas = document.createElement("canvas");
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    const ctx = canvas.getContext("2d");
    ctx.scale(dpr, dpr);
    ctx.fillStyle = "rgba(32,32,35,0.9)";
    ctx.roundRect(0, 0, size, size, borderRadius);
    ctx.fill();
    if (opts.shadow !== false) {
      ctx.shadowColor = "rgba(0,0,0,0.4)";
      ctx.shadowBlur = 6;
    }
    const inner = size - 16;
    if (imgSrc) {
      const img = new Image();
      img.src = imgSrc;
      const drawImage = /* @__PURE__ */ __name(() => {
        ctx.save();
        ctx.beginPath();
        ctx.roundRect(8, 8, inner, inner, borderRadius - 2);
        ctx.clip();
        ctx.drawImage(img, 8, 8, inner, inner);
        ctx.restore();
        drawLabel();
      }, "drawImage");
      if (img.complete) {
        drawImage();
      } else {
        img.onload = drawImage;
        img.onerror = drawLabel;
      }
    } else {
      drawLabel();
    }
    function drawLabel() {
      ctx.fillStyle = "#fff";
      ctx.font = `500 12px Inter, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const maxWidth = size - 10;
      let text = label;
      while (ctx.measureText(text).width > maxWidth && text.length > 4) {
        text = text.slice(0, -2);
      }
      if (text !== label) text = text.slice(0, -1) + "\u2026";
      ctx.fillText(text, size / 2, size - 10);
    }
    __name(drawLabel, "drawLabel");
    cache.set(key, canvas);
    return canvas;
  }
  var cache;
  var init_CanvasGhostBuilder = __esm({
    "src-js/utils/graphics/CanvasGhostBuilder.ts"() {
      "use strict";
      cache = /* @__PURE__ */ new Map();
      __name(buildDragGhostCanvas, "buildDragGhostCanvas");
    }
  });

  // src-js/ui/interactions/EnhancedDragPreview.ts
  var EnhancedDragPreview_exports = {};
  __export(EnhancedDragPreview_exports, {
    enableEnhancedDragPreview: () => enableEnhancedDragPreview
  });
  function createGhost(label, imgSrc) {
    try {
      return buildDragGhostCanvas(label, imgSrc);
    } catch {
      const div = document.createElement("div");
      div.textContent = label;
      div.style.padding = "4px 6px";
      div.style.fontSize = "12px";
      div.style.background = "rgba(32,32,35,0.9)";
      div.style.color = "#fff";
      return div;
    }
  }
  function extractImageSrc(el) {
    const img = el.querySelector("img[src]");
    if (img?.src) return img.src;
    const bg = getComputedStyle(el).backgroundImage;
    const match = bg && /url\("?([^\"]+)"?\)/.exec(bg);
    return match ? match[1] : void 0;
  }
  function findFallbackLabel(el) {
    const attrLabel = el.getAttribute("aria-label") || el.getAttribute("title");
    if (attrLabel) return attrLabel;
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
      acceptNode(node) {
        const text = node.textContent?.trim();
        return text ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    const n = walker.nextNode();
    return (n?.textContent?.trim() || "").slice(0, 60);
  }
  function getPreviewData(target) {
    if (cache2.has(target)) return cache2.get(target);
    const label = findFallbackLabel(target);
    if (!label) return null;
    const img = extractImageSrc(target);
    const data = img ? { label, img } : { label };
    cache2.set(target, data);
    return data;
  }
  function onDragStart(event) {
    try {
      if (!event.dataTransfer || typeof event.dataTransfer.setDragImage !== "function")
        return;
      const target = event.target;
      if (!target) return;
      let label = event.dataTransfer.getData("text/plain");
      let imgSrc;
      if (!label) {
        const data = getPreviewData(target);
        if (!data) return;
        label = data.label;
        imgSrc = data.img;
      } else {
        imgSrc = extractImageSrc(target);
      }
      const ghostEl = createGhost(label, imgSrc);
      document.body.appendChild(ghostEl);
      const offset = ghostEl.offsetWidth / 2;
      event.dataTransfer.setDragImage(ghostEl, offset, offset);
      const cleanup = /* @__PURE__ */ __name(() => {
        ghostEl.remove();
        window.removeEventListener("dragend", cleanup, true);
      }, "cleanup");
      window.addEventListener("dragend", cleanup, true);
    } catch (err) {
      console.debug("[StarryNight] EnhancedDragPreview failed:", err);
    }
  }
  function enableEnhancedDragPreview(opts = {}) {
    const g = globalThis;
    if (g.__SN_enhancedDragPreview) return;
    g.__SN_enhancedDragPreview = true;
    Object.assign(DEFAULT_OPTS, opts);
    document.addEventListener("dragstart", onDragStart, true);
    console.info("\u{1F320} Enhanced drag preview enabled");
  }
  var DEFAULT_OPTS, cache2;
  var init_EnhancedDragPreview = __esm({
    "src-js/ui/interactions/EnhancedDragPreview.ts"() {
      "use strict";
      init_CanvasGhostBuilder();
      DEFAULT_OPTS = {
        size: 72,
        borderRadius: 8,
        fontSize: 12
      };
      cache2 = /* @__PURE__ */ new WeakMap();
      __name(createGhost, "createGhost");
      __name(extractImageSrc, "extractImageSrc");
      __name(findFallbackLabel, "findFallbackLabel");
      __name(getPreviewData, "getPreviewData");
      __name(onDragStart, "onDragStart");
      __name(enableEnhancedDragPreview, "enableEnhancedDragPreview");
    }
  });

  // src-js/utils/animation/flipSpring.ts
  function spring(config) {
    const k = config.stiffness ?? 260;
    const d = config.damping ?? 24;
    const m = config.mass ?? 1;
    let current = {};
    let velocity = {};
    let target = {};
    let animId = null;
    function step() {
      let done = true;
      const dt = 1 / 60;
      for (const key in target) {
        const x = current[key] ?? 0;
        const v = velocity[key] ?? 0;
        const goal = target[key] ?? 0;
        const Fspring = -k * (x - goal);
        const Fdamp = -d * v;
        const a = (Fspring + Fdamp) / m;
        const newV = v + a * dt;
        const newX = x + newV * dt;
        velocity[key] = newV;
        current[key] = newX;
        if (Math.abs(newV) > 0.1 || Math.abs(newX - goal) > 0.1) done = false;
      }
      config.onUpdate(current);
      if (!done) animId = requestAnimationFrame(step);
    }
    __name(step, "step");
    return {
      to(newTarget) {
        target = newTarget;
        if (!animId) animId = requestAnimationFrame(step);
      }
    };
  }
  var init_flipSpring = __esm({
    "src-js/utils/animation/flipSpring.ts"() {
      "use strict";
      __name(spring, "spring");
      window.snFlipSpringLoaded = true;
    }
  });

  // src-js/utils/dom/sidebarDetector.ts
  function querySidebar() {
    const node = document.querySelector(SIDEBAR_SELECTOR);
    if (!node) return null;
    const rect = node.getBoundingClientRect();
    return { node, rect };
  }
  function isSidebarCloneCapable() {
    const hasSidebar = !!querySidebar();
    const canClone = typeof Element.prototype.cloneNode === "function";
    const springReady = !!window.snFlipSpringLoaded;
    return hasSidebar && canClone && springReady;
  }
  var SIDEBAR_SELECTOR;
  var init_sidebarDetector = __esm({
    "src-js/utils/dom/sidebarDetector.ts"() {
      "use strict";
      SIDEBAR_SELECTOR = '[data-testid="rootlist-container"]';
      __name(querySidebar, "querySidebar");
      __name(isSidebarCloneCapable, "isSidebarCloneCapable");
    }
  });

  // src-js/ui/interactions/SidebarCloneOverlay.ts
  var SidebarCloneOverlay_exports = {};
  __export(SidebarCloneOverlay_exports, {
    destroySidebarClone: () => destroySidebarClone,
    launchSidebarClone: () => launchSidebarClone
  });
  function launchSidebarClone(context) {
    if (animationAbortController) {
      animationAbortController.abort();
      animationAbortController = null;
    }
    if (activeClone) {
      destroySidebarClone();
    }
    animationAbortController = new AbortController();
    const { signal } = animationAbortController;
    if (activeClone) return;
    const sidebar = querySidebar();
    if (!sidebar) return;
    const clone = sidebar.node.cloneNode(true);
    clone.id = "";
    clone.setAttribute("aria-hidden", "true");
    clone.classList.add("sn-clone-overlay");
    clone.style.position = "fixed";
    clone.style.top = `${sidebar.rect.top}px`;
    clone.style.left = `${sidebar.rect.left}px`;
    clone.style.width = `${sidebar.rect.width}px`;
    clone.style.height = `${sidebar.rect.height}px`;
    clone.style.zIndex = "9999";
    clone.style.willChange = "transform, opacity";
    clone.style.contain = "paint";
    (/* @__PURE__ */ __name(function stripCloneArtefacts(root) {
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
      while (walker.nextNode()) {
        const el = walker.currentNode;
        if (el.hasAttribute("aria-label")) el.removeAttribute("aria-label");
        if (el.tabIndex >= 0) el.tabIndex = -1;
      }
    }, "stripCloneArtefacts"))(clone);
    document.body.appendChild(clone);
    activeClone = clone;
    const firstX = 0;
    const firstY = 0;
    const firstS = 1;
    const lastX = context.cursorX - sidebar.rect.left - sidebar.rect.width * 0.2;
    const lastY = context.cursorY - sidebar.rect.top - sidebar.rect.height * 0.2;
    const lastS = 0.6;
    const prefersReduced = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    if (prefersReduced) {
      clone.style.transform = `translate(${lastX}px, ${lastY}px) scale(${lastS})`;
      pruneCloneItems(clone, context);
      return;
    }
    const anim = spring({
      stiffness: 220,
      damping: 20,
      onUpdate: /* @__PURE__ */ __name((v) => {
        if (signal.aborted) return;
        clone.style.transform = `translate(${v.x}px, ${v.y}px) scale(${v.s})`;
      }, "onUpdate")
    });
    clone.style.transformOrigin = "top left";
    clone.style.transform = `translate(${firstX}px, ${firstY}px) scale(${firstS})`;
    requestAnimationFrame(() => anim.to({ x: lastX, y: lastY, s: lastS }));
    const pruneTimeout = setTimeout(() => {
      if (!signal.aborted && activeClone) pruneCloneItems(activeClone, context);
    }, 400);
    signal.addEventListener("abort", () => clearTimeout(pruneTimeout));
    signal.addEventListener("abort", () => destroySidebarClone());
  }
  function destroySidebarClone() {
    cleanupFns.forEach((fn) => fn());
    cleanupFns.length = 0;
    if (activeClone) {
      activeClone.remove();
      activeClone = null;
    }
    if (animationAbortController) {
      animationAbortController.abort();
      animationAbortController = null;
    }
  }
  function addTracksToPlaylist(uri, trackUris) {
    try {
      const Cosmos = window.Spicetify?.CosmosAsync;
      if (!Cosmos) return;
      const endpoint = `/v1/playlists/${uri.split(":").pop()}/tracks`;
      Cosmos.post(endpoint, { uris: trackUris });
    } catch {
    }
  }
  function pruneCloneItems(root, context) {
    const all = Array.from(
      root.querySelectorAll('[data-uri^="spotify:playlist:"]')
    );
    if (!all.length) return;
    const keep = all.slice(0, 5);
    all.slice(5).forEach((el) => {
      el.classList.add("sn-prune-out");
      setTimeout(() => el.remove(), 180);
    });
    keep.forEach((el, idx) => {
      el.setAttribute("data-index", String(idx + 1));
      el.setAttribute("role", "button");
      el.tabIndex = 0;
      el.style.setProperty("--sn-glow-level", "0");
      el.style.backgroundImage = "paint(sn-aura)";
      el.addEventListener(
        "mouseenter",
        () => el.style.setProperty("--sn-glow-level", "1")
      );
      el.addEventListener(
        "mouseleave",
        () => el.style.setProperty("--sn-glow-level", "0")
      );
      const uriVal = el.getAttribute("data-uri");
      if (!uriVal) {
        return;
      }
      const trackUris = context.uris;
      const clickHandler = /* @__PURE__ */ __name((ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        const img = el.querySelector("img");
        pushRecentPlaylist(
          uriVal,
          img?.src || "",
          el.textContent?.trim() || "Playlist"
        );
        addTracksToPlaylist(uriVal, trackUris);
        announce("Track added to " + (el.textContent?.trim() || "playlist"));
        destroySidebarClone();
      }, "clickHandler");
      el.addEventListener("click", clickHandler);
      el.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          clickHandler(e);
        }
      });
    });
    const keyListener = /* @__PURE__ */ __name((e) => {
      const n = parseInt(e.key, 10);
      if (n >= 1 && n <= keep.length) {
        keep[n - 1]?.click();
      }
    }, "keyListener");
    window.addEventListener("keydown", keyListener, { capture: true });
    cleanupFns.push(
      () => window.removeEventListener("keydown", keyListener, { capture: true })
    );
  }
  function pushRecentPlaylist(uri, image, name) {
    try {
      const raw = localStorage.getItem(MRU_KEY);
      const list = raw ? JSON.parse(raw) : [];
      const existing = list.findIndex((p) => p.uri === uri);
      if (existing !== -1) list.splice(existing, 1);
      list.unshift({ uri, image, name });
      localStorage.setItem(MRU_KEY, JSON.stringify(list.slice(0, 10)));
    } catch {
    }
  }
  function announce(message) {
    const live = document.getElementById("sn-live");
    if (live) live.textContent = message;
  }
  var activeClone, cleanupFns, animationAbortController, MRU_KEY;
  var init_SidebarCloneOverlay = __esm({
    "src-js/ui/interactions/SidebarCloneOverlay.ts"() {
      "use strict";
      init_flipSpring();
      init_sidebarDetector();
      activeClone = null;
      cleanupFns = [];
      animationAbortController = null;
      MRU_KEY = "sn-recent-playlists";
      __name(launchSidebarClone, "launchSidebarClone");
      __name(destroySidebarClone, "destroySidebarClone");
      __name(addTracksToPlaylist, "addTracksToPlaylist");
      __name(pruneCloneItems, "pruneCloneItems");
      __name(pushRecentPlaylist, "pushRecentPlaylist");
      __name(announce, "announce");
    }
  });

  // src-js/ui/interactions/QuickAddRadialMenu.ts
  var QuickAddRadialMenu_exports = {};
  __export(QuickAddRadialMenu_exports, {
    enableQuickAddRadialMenu: () => enableQuickAddRadialMenu
  });
  function ensureLiveRegion() {
    let live = document.getElementById(LIVE_ID);
    if (!live) {
      live = document.createElement("div");
      live.id = LIVE_ID;
      live.setAttribute("aria-live", "polite");
      live.style.position = "absolute";
      live.style.width = "1px";
      live.style.height = "1px";
      live.style.overflow = "hidden";
      live.style.clipPath = "inset(100%)";
      live.style.clip = "rect(1px,1px,1px,1px)";
      live.style.whiteSpace = "nowrap";
      document.body.appendChild(live);
    }
    return live;
  }
  function distance(x1, y1, x2, y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function fetchRecentPlaylists() {
    try {
      const raw = localStorage.getItem("sn-recent-playlists");
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr.slice(0, MAX_PLAYLISTS_SHOWN) : [];
    } catch {
      return [];
    }
  }
  function addTracksToPlaylist2(playlistUri, trackUris) {
    try {
      const endpoint = `/v1/playlists/${playlistUri.split(":").pop()}/tracks`;
      window.Spicetify?.CosmosAsync.post(endpoint, {
        uris: trackUris
      });
    } catch (e) {
      console.warn("[StarryNight] QuickAddRadial failed to add tracks:", e);
    }
  }
  function pushRecentPlaylist2(pl) {
    try {
      const list = fetchRecentPlaylists();
      const existingIdx = list.findIndex((p) => p.uri === pl.uri);
      if (existingIdx !== -1) list.splice(existingIdx, 1);
      list.unshift(pl);
      const trimmed = list.slice(0, 10);
      localStorage.setItem("sn-recent-playlists", JSON.stringify(trimmed));
    } catch {
    }
  }
  function createOverlay(x, y, playlists) {
    if (!playlists.length) return;
    destroyOverlay();
    overlayEl = document.createElement("div");
    overlayEl.className = "sn-quick-add-overlay";
    overlayEl.style.position = "fixed";
    overlayEl.style.inset = "0";
    overlayEl.style.pointerEvents = "none";
    overlayEl.style.zIndex = "9999";
    const center = document.createElement("div");
    center.className = "sn-quick-add-center";
    center.style.position = "absolute";
    center.style.left = `${x}px`;
    center.style.top = `${y}px`;
    center.style.width = "0";
    center.style.height = "0";
    overlayEl.appendChild(center);
    document.body.appendChild(overlayEl);
    const radius = 90;
    const angleStep = Math.PI * 2 / playlists.length;
    playlists.forEach((pl, idx) => {
      const angle = angleStep * idx - Math.PI / 2;
      const btn = document.createElement("button");
      btn.className = "sn-quick-add-btn";
      btn.style.position = "absolute";
      btn.style.width = "64px";
      btn.style.height = "64px";
      btn.style.borderRadius = "50%";
      btn.style.border = "2px solid rgba(255,255,255,0.4)";
      btn.style.background = `url('${pl.image}') center/cover no-repeat`;
      btn.style.cursor = "pointer";
      btn.style.pointerEvents = "auto";
      const cx = radius * Math.cos(angle);
      const cy = radius * Math.sin(angle);
      btn.style.transform = `translate(${cx - 32}px, ${cy - 32}px)`;
      btn.style.transformOrigin = "center center";
      const firstX = 0;
      const firstY = 0;
      btn.style.transform = `translate(${firstX}px, ${firstY}px) scale(0.1)`;
      requestAnimationFrame(() => {
        const animator = spring({
          stiffness: 220,
          damping: 20,
          onUpdate: /* @__PURE__ */ __name((v) => {
            btn.style.transform = `translate(${v.x}px, ${v.y}px) scale(${v.s})`;
          }, "onUpdate")
        });
        animator.to({ x: cx - 32, y: cy - 32, s: 1 });
      });
      btn.title = `Add to ${pl.name}`;
      btn.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        if (currentDragDataUris) addTracksToPlaylist2(pl.uri, currentDragDataUris);
        pushRecentPlaylist2(pl);
        destroyOverlay();
      });
      center.appendChild(btn);
    });
    const live = ensureLiveRegion();
    live.textContent = "Quick-add menu open. Press number keys 1 to 5 to pick a playlist or continue dragging.";
  }
  function destroyOverlay() {
    overlayEl?.remove();
    overlayEl = null;
    const live = document.getElementById(LIVE_ID);
    if (live) live.textContent = "";
  }
  function clearHoldTimer() {
    if (holdTimer) {
      clearTimeout(holdTimer);
      holdTimer = null;
    }
  }
  function onDragStart2(e) {
    startX = e.clientX;
    startY = e.clientY;
    currentDragDataUris = (e.dataTransfer?.getData("text/spotify") || "").split(/[\n,]/).filter(Boolean);
    const cloneCapable = isSidebarCloneCapable();
    clearHoldTimer();
    holdTimer = window.setTimeout(async () => {
      if (cloneCapable) {
        const overlay = await Promise.resolve().then(() => (init_SidebarCloneOverlay(), SidebarCloneOverlay_exports));
        overlay.launchSidebarClone({
          cursorX: currentPointer.x,
          cursorY: currentPointer.y,
          uris: currentDragDataUris ?? []
        });
      } else {
        const playlists = await getRadialPlaylists();
        createOverlay(startX, startY, playlists);
      }
    }, HOLD_MS);
  }
  function onDragEnd() {
    clearHoldTimer();
    destroyOverlay();
    currentDragDataUris = null;
  }
  function onPointerMove(e) {
    currentPointer = { x: e.clientX, y: e.clientY };
    if (!holdTimer) return;
    if (distance(startX, startY, e.clientX, e.clientY) > MOVE_THRESHOLD) {
      clearHoldTimer();
    }
  }
  async function fetchPlaylistsFromAPI() {
    try {
      const Cosmos = window.Spicetify?.CosmosAsync;
      if (!Cosmos) return [];
      const resp = await Cosmos.get(
        "https://api.spotify.com/v1/me/playlists?limit=10"
      );
      if (!resp?.items) return [];
      return resp.items.slice(0, MAX_PLAYLISTS_SHOWN).map((pl) => ({
        uri: pl.uri,
        name: pl.name,
        image: pl.images?.[0]?.url || ""
      }));
    } catch {
      return [];
    }
  }
  function scrapeSidebarPlaylists() {
    try {
      const items = Array.from(
        document.querySelectorAll('[data-testid="rootlist-card"]')
      );
      const res = [];
      for (const el of items) {
        const uri = el.getAttribute("data-uri") || el.querySelector("a")?.getAttribute("href")?.replace("/playlist/", "spotify:playlist:");
        if (!uri) continue;
        const img = el.querySelector("img");
        const image = img?.src || "";
        const name = img?.alt || el.textContent?.trim() || "Playlist";
        res.push({ uri, image, name });
        if (res.length >= MAX_PLAYLISTS_SHOWN) break;
      }
      return res;
    } catch {
      return [];
    }
  }
  async function getRadialPlaylists() {
    const local = fetchRecentPlaylists();
    if (local.length) return local;
    const sidebar = scrapeSidebarPlaylists();
    if (sidebar.length) return sidebar;
    const api = await fetchPlaylistsFromAPI();
    return api;
  }
  function enableQuickAddRadialMenu() {
    const g = globalThis;
    if (g.__SN_quickAddRadial) return;
    g.__SN_quickAddRadial = true;
    window.addEventListener("dragstart", onDragStart2, true);
    window.addEventListener("dragend", onDragEnd, true);
    window.addEventListener("pointermove", onPointerMove, true);
    console.info("\u{1F30C} Quick-Add radial menu enabled");
    console.info(
      `[StarryNight] Sidebar clone capability: ${isSidebarCloneCapable()}`
    );
  }
  var HOLD_MS, MOVE_THRESHOLD, MAX_PLAYLISTS_SHOWN, holdTimer, startX, startY, overlayEl, currentDragDataUris, currentPointer, LIVE_ID;
  var init_QuickAddRadialMenu = __esm({
    "src-js/ui/interactions/QuickAddRadialMenu.ts"() {
      "use strict";
      init_flipSpring();
      init_sidebarDetector();
      HOLD_MS = 250;
      MOVE_THRESHOLD = 8;
      MAX_PLAYLISTS_SHOWN = 5;
      holdTimer = null;
      startX = 0;
      startY = 0;
      overlayEl = null;
      currentDragDataUris = null;
      currentPointer = { x: 0, y: 0 };
      LIVE_ID = "sn-live";
      __name(ensureLiveRegion, "ensureLiveRegion");
      __name(distance, "distance");
      __name(fetchRecentPlaylists, "fetchRecentPlaylists");
      __name(addTracksToPlaylist2, "addTracksToPlaylist");
      __name(pushRecentPlaylist2, "pushRecentPlaylist");
      __name(createOverlay, "createOverlay");
      __name(destroyOverlay, "destroyOverlay");
      __name(clearHoldTimer, "clearHoldTimer");
      __name(onDragStart2, "onDragStart");
      __name(onDragEnd, "onDragEnd");
      __name(onPointerMove, "onPointerMove");
      document.addEventListener("keydown", (e) => {
        if (!overlayEl) return;
        const num = parseInt(e.key, 10);
        if (num >= 1 && num <= MAX_PLAYLISTS_SHOWN) {
          const btn = overlayEl.querySelectorAll(".sn-quick-add-btn")[num - 1];
          btn?.click();
        }
      });
      __name(fetchPlaylistsFromAPI, "fetchPlaylistsFromAPI");
      __name(scrapeSidebarPlaylists, "scrapeSidebarPlaylists");
      __name(getRadialPlaylists, "getRadialPlaylists");
      __name(enableQuickAddRadialMenu, "enableQuickAddRadialMenu");
    }
  });

  // src-js/visual/ui-effects/prismaticScrollSheen.ts
  var prismaticScrollSheen_exports = {};
  __export(prismaticScrollSheen_exports, {
    PrismaticScrollSheenSystem: () => PrismaticScrollSheenSystem,
    initializePrismaticScrollSheen: () => initializePrismaticScrollSheen
  });
  function initializePrismaticScrollSheen() {
    try {
      const sys = new PrismaticScrollSheenSystem();
      year3000System_default?.registerVisualSystem?.(sys, "background");
    } catch (err) {
      console.error("[PrismaticScrollSheen] Failed to init:", err);
    }
  }
  var DEFAULT_CYCLE_PX, _PrismaticScrollSheenSystem, PrismaticScrollSheenSystem;
  var init_prismaticScrollSheen = __esm({
    "src-js/visual/ui-effects/prismaticScrollSheen.ts"() {
      "use strict";
      init_year3000System();
      init_OptimizedCSSVariableManager();
      DEFAULT_CYCLE_PX = 6e3;
      _PrismaticScrollSheenSystem = class _PrismaticScrollSheenSystem {
        constructor(cyclePx = DEFAULT_CYCLE_PX) {
          this.cyclePx = cyclePx;
          this.systemName = "PrismaticScrollSheen";
          this._lastRatio = -1;
          const year3000System2 = globalThis.year3000System;
          this.cssController = year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
          this.cssController.setVariable(
            "PrismaticScrollSheenSystem",
            "--sn-scroll-cycle-px",
            String(cyclePx),
            "normal",
            // Normal priority for scroll cycle setup
            "scroll-cycle-init"
          );
        }
        /**
         * Called each animation frame by VisualSystemRegistry.
         */
        onAnimate(_delta, context) {
          const ratio = context.scrollRatio ?? 0;
          if (Math.abs(ratio - this._lastRatio) < 1e-3) return;
          this._lastRatio = ratio;
          const scrollRatioVariables = {
            "--sn-cdf-scroll-ratio": ratio.toFixed(4),
            "--sn-scroll-ratio": ratio.toFixed(4)
          };
          this.cssController.batchSetVariables(
            "PrismaticScrollSheenSystem",
            scrollRatioVariables,
            "high",
            // High priority for scroll ratio updates - affects visual responsiveness
            "scroll-ratio-update"
          );
        }
        onPerformanceModeChange() {
        }
        destroy() {
        }
      };
      __name(_PrismaticScrollSheenSystem, "PrismaticScrollSheenSystem");
      PrismaticScrollSheenSystem = _PrismaticScrollSheenSystem;
      __name(initializePrismaticScrollSheen, "initializePrismaticScrollSheen");
      if (window.Y3K?.system?.registerVisualSystem) {
        initializePrismaticScrollSheen();
      }
    }
  });

  // src-js/ui/components/SettingsSection.tsx
  var import_react, import_react_dom, _SettingsSection, SettingsSection;
  var init_SettingsSection = __esm({
    "src-js/ui/components/SettingsSection.tsx"() {
      "use strict";
      import_react = __toESM(__require("react"));
      import_react_dom = __toESM(__require("react-dom"));
      _SettingsSection = class _SettingsSection {
        constructor(name, settingsId, initialSettingsFields = {}) {
          this.name = name;
          this.settingsId = settingsId;
          this.initialSettingsFields = initialSettingsFields;
          this.settingsFields = this.initialSettingsFields;
          this.setRerender = null;
          /** Mounts the section when the user visits the Spotify settings route */
          this.pushSettings = /* @__PURE__ */ __name(async () => {
            Object.entries(this.settingsFields).forEach(([nameId, field]) => {
              if (field.type !== "button" && this.getFieldValue(nameId) === void 0) {
                this.setFieldValue(nameId, field.defaultValue);
              }
            });
            while (!window.Spicetify?.Platform?.History?.listen) {
              await new Promise((r) => setTimeout(r, 100));
            }
            if (this.stopHistoryListener) this.stopHistoryListener();
            this.stopHistoryListener = window.Spicetify.Platform.History.listen((e) => {
              if (e.pathname === "/preferences") this.render();
            });
            if (window.Spicetify.Platform.History.location.pathname === "/preferences") {
              await this.render();
            }
          }, "pushSettings");
          this.rerender = /* @__PURE__ */ __name(() => {
            this.setRerender?.(Math.random());
          }, "rerender");
          /* ----------------------- field creators ---------------------------- */
          this.addDropDown = /* @__PURE__ */ __name((nameId, description, options, defaultIndex, _onSelect, events) => {
            this.settingsFields[nameId] = {
              type: "dropdown",
              description,
              defaultValue: options[defaultIndex],
              options,
              events
            };
          }, "addDropDown");
          /** Toggle (checkbox) */
          this.addToggle = /* @__PURE__ */ __name((nameId, description, defaultValue, events) => {
            this.settingsFields[nameId] = {
              type: "toggle",
              description,
              defaultValue,
              events
            };
          }, "addToggle");
          /** Text / number / color input */
          this.addInput = /* @__PURE__ */ __name((nameId, description, defaultValue, inputType = "text", events) => {
            this.settingsFields[nameId] = {
              type: "input",
              description,
              defaultValue,
              inputType,
              events
            };
          }, "addInput");
          /* ----- generic storage helpers (use Spicetify.LocalStorage) -------- */
          this.getFieldValue = /* @__PURE__ */ __name((nameId) => {
            const value = window.Spicetify?.LocalStorage.get(nameId);
            if (value === null || value === void 0) {
              const legacyKey = `${this.settingsId}.${nameId}`;
              const legacyValue = window.Spicetify?.LocalStorage.get(legacyKey);
              if (legacyValue) {
                try {
                  const parsed = JSON.parse(legacyValue);
                  const extractedValue = parsed?.value ?? legacyValue;
                  window.Spicetify?.LocalStorage.set(nameId, extractedValue);
                  window.Spicetify?.LocalStorage.remove(legacyKey);
                  return extractedValue;
                } catch {
                  return legacyValue;
                }
              }
              return void 0;
            }
            return value;
          }, "getFieldValue");
          /* ---------------------- React wrappers ----------------------------- */
          this.FieldsContainer = /* @__PURE__ */ __name(() => {
            const [nonce, setNonce] = (0, import_react.useState)(0);
            this.setRerender = setNonce;
            return /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-section", key: nonce }, /* @__PURE__ */ import_react.default.createElement("h2", { className: "TypeElement-cello-textBase-type" }, this.name), Object.entries(this.settingsFields).map(([nameId, field]) => /* @__PURE__ */ import_react.default.createElement(this.Field, { key: nameId, nameId, field })));
          }, "FieldsContainer");
          this.Field = /* @__PURE__ */ __name(({
            nameId,
            field
          }) => {
            const id = `${this.settingsId}.${nameId}`;
            const initial = field.type === "button" ? field.value : this.getFieldValue(nameId) ?? field.defaultValue;
            const [value, setVal] = (0, import_react.useState)(initial);
            const setValue = /* @__PURE__ */ __name((v) => {
              setVal(v);
              this.setFieldValue(nameId, v);
              try {
                const customEvent = new CustomEvent("year3000SystemSettingsChanged", {
                  detail: { key: nameId, value: v }
                });
                document.dispatchEvent(customEvent);
              } catch (error) {
                console.warn(`[SettingsSection] Failed to emit settings change event for ${nameId}:`, error);
              }
            }, "setValue");
            if (field.type === "hidden") return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null);
            const Label = /* @__PURE__ */ import_react.default.createElement("label", { className: "TypeElement-viola-textSubdued-type", htmlFor: id }, field.description || "");
            let Control = null;
            switch (field.type) {
              case "dropdown":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "select",
                  {
                    className: "main-dropDown-dropDown",
                    id,
                    ...field.events,
                    onChange: (e) => {
                      const idx = e.currentTarget.selectedIndex;
                      const newVal = field.options[idx];
                      setValue(newVal);
                      field.events?.onChange?.(e);
                    }
                  },
                  field.options.map((opt, i) => /* @__PURE__ */ import_react.default.createElement("option", { key: opt, value: opt, selected: opt === value }, opt))
                );
                break;
              case "toggle":
                Control = /* @__PURE__ */ import_react.default.createElement("label", { className: "x-settings-secondColumn x-toggle-wrapper" }, /* @__PURE__ */ import_react.default.createElement(
                  "input",
                  {
                    id,
                    className: "x-toggle-input",
                    type: "checkbox",
                    checked: !!value,
                    ...field.events,
                    onClick: (e) => {
                      const checked = e.currentTarget.checked;
                      setValue(checked);
                      field.events?.onClick?.(e);
                    }
                  }
                ), /* @__PURE__ */ import_react.default.createElement("span", { className: "x-toggle-indicatorWrapper" }, /* @__PURE__ */ import_react.default.createElement("span", { className: "x-toggle-indicator" })));
                break;
              case "input":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "input",
                  {
                    className: "x-settings-input",
                    id,
                    dir: "ltr",
                    value,
                    type: field.inputType || "text",
                    ...field.events,
                    onChange: (e) => {
                      setValue(e.currentTarget.value);
                      field.events?.onChange?.(e);
                    }
                  }
                );
                break;
              case "button":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "button",
                  {
                    id,
                    className: "Button-sc-y0gtbx-0 Button-small-buttonSecondary-useBrowserDefaultFocusStyle x-settings-button",
                    ...field.events,
                    onClick: (e) => {
                      field.events?.onClick?.(e);
                    },
                    type: "button"
                  },
                  value
                );
                break;
              default:
                Control = null;
            }
            return /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-row" }, /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-firstColumn" }, Label), /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-secondColumn" }, Control));
          }, "Field");
        }
        /* --------------------- internal render helpers --------------------- */
        async render() {
          while (!document.getElementById("desktop.settings.selectLanguage")) {
            if (window.Spicetify.Platform.History.location.pathname !== "/preferences")
              return;
            await new Promise((r) => setTimeout(r, 100));
          }
          const container = document.querySelector(
            ".main-view-container__scroll-node-child main div"
          );
          if (!container)
            return console.error("[StarryNight] settings container not found");
          let host = Array.from(container.children).find(
            (c) => c.id === this.settingsId
          );
          if (!host) {
            host = document.createElement("div");
            host.id = this.settingsId;
            container.appendChild(host);
          }
          import_react_dom.default.render(/* @__PURE__ */ import_react.default.createElement(this.FieldsContainer, null), host);
        }
        setFieldValue(nameId, newValue) {
          window.Spicetify?.LocalStorage.set(nameId, newValue);
        }
      };
      __name(_SettingsSection, "SettingsSection");
      SettingsSection = _SettingsSection;
    }
  });

  // src-js/ui/components/StarryNightSettings.ts
  var StarryNightSettings_exports = {};
  __export(StarryNightSettings_exports, {
    initializeStarryNightSettings: () => initializeStarryNightSettings
  });
  function getCSSController2() {
    const year3000System2 = globalThis.year3000System;
    return year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
  }
  async function initializeStarryNightSettings() {
    const section = new SettingsSection(
      "StarryNight Theme",
      "starrynight-settings"
    );
    const accentOptions = [
      "dynamic",
      //  Album-based accent (Year 3000)
      "rosewater",
      "flamingo",
      "pink",
      "mauve",
      "red",
      "maroon",
      "peach",
      "yellow",
      "green",
      "teal",
      "sky",
      "sapphire",
      "blue",
      "lavender"
    ];
    function getSettingsManager() {
      const existing = window.Y3K?.system?.settingsManager;
      if (existing) return existing;
      const cached = globalThis.__SN_settingsManager;
      if (cached) return cached;
      const manager = new SettingsManager();
      globalThis.__SN_settingsManager = manager;
      return manager;
    }
    __name(getSettingsManager, "getSettingsManager");
    const settingsManager2 = getSettingsManager();
    const currentAccent = settingsManager2.get("catppuccin-accentColor");
    section.addDropDown(
      "catppuccin-accentColor",
      // settings key (nameId)
      "Accent colour (primary theme color)",
      // user-visible label
      accentOptions,
      // option list
      Math.max(0, accentOptions.indexOf(currentAccent)),
      // default index
      void 0,
      // onSelect (unused  we use onChange)
      {
        onChange: /* @__PURE__ */ __name((e) => {
          try {
            const idx = e?.currentTarget?.selectedIndex ?? 0;
            const newAccent = accentOptions[idx] ?? "mauve";
            settingsManager2.set("catppuccin-accentColor", newAccent);
            const grad = settingsManager2.get("sn-gradient-intensity");
            applyStarryNightSettings(grad, grad);
            try {
              globalThis.Y3K?.system?.applyInitialSettings?.("accent");
            } catch (applyErr) {
              console.warn(
                "[StarryNight] Unable to trigger Year3000System colour refresh",
                applyErr
              );
            }
          } catch (err) {
            console.error("[StarryNight] Failed to update accent colour", err);
          }
        }, "onChange")
      }
    );
    const intensityOptions = [
      "disabled",
      "minimal",
      "balanced",
      "intense"
    ];
    const currentGradient = settingsManager2.get("sn-gradient-intensity");
    section.addDropDown(
      "sn-gradient-intensity",
      "Background effects intensity (stars, nebula, flow gradients)",
      intensityOptions,
      Math.max(0, intensityOptions.indexOf(currentGradient)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const newGrad = intensityOptions[idx] ?? "balanced";
          settingsManager2.set("sn-gradient-intensity", newGrad);
          applyStarryNightSettings(newGrad, newGrad);
        }, "onChange")
      }
    );
    const brightnessOptions = ["bright", "balanced", "dark"];
    const currentBrightness = settingsManager2.get("sn-brightness-mode") || "dark";
    section.addDropDown(
      "sn-brightness-mode",
      "Brightness mode",
      brightnessOptions,
      Math.max(0, brightnessOptions.indexOf(currentBrightness)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const newBrightness = brightnessOptions[idx] ?? "bright";
          settingsManager2.set("sn-brightness-mode", newBrightness);
          const cssController2 = getCSSController2();
          const brightnessVariables = {
            "--sn-brightness-mode": `"${newBrightness}"`,
            "--sn-brightness-data-attr": newBrightness
          };
          cssController2.batchSetVariables(
            "StarryNightSettings",
            brightnessVariables,
            "high",
            // High priority for brightness mode changes
            "brightness-mode-change"
          );
          document.documentElement.setAttribute(
            "data-sn-brightness",
            newBrightness
          );
          try {
            globalThis.Y3K?.system?.applyInitialSettings?.("brightness");
            console.log(
              `[StarryNight] Brightness mode changed to: ${newBrightness}`
            );
          } catch (applyErr) {
            console.warn(
              "[StarryNight] Unable to trigger Year3000System brightness refresh",
              applyErr
            );
          }
        }, "onChange")
      }
    );
    const flavourOptions = ["latte", "frappe", "macchiato", "mocha"];
    const currentFlavor = settingsManager2.get("catppuccin-flavor");
    section.addDropDown(
      "catppuccin-flavor",
      "Catppuccin flavour (light/dark theme base)",
      flavourOptions,
      Math.max(0, flavourOptions.indexOf(currentFlavor)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager2.set("catppuccin-flavor", flavourOptions[idx]);
          try {
            globalThis.Y3K?.system?.applyInitialSettings?.("flavor");
          } catch (applyErr) {
            console.warn(
              "[StarryNight] Unable to trigger flavor refresh",
              applyErr
            );
          }
        }, "onChange")
      }
    );
    const paletteOptions = ["catppuccin", "year3000"];
    const paletteLabels = ["Catppuccin Classic", "Year 3000 Cinematic"];
    const currentPalette = settingsManager2.get("sn-palette-system");
    section.addDropDown(
      "sn-palette-system",
      "Palette system (color foundation vs enhancement)",
      paletteLabels,
      Math.max(0, paletteOptions.indexOf(currentPalette)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager2.set("sn-palette-system", paletteOptions[idx]);
          try {
            globalThis.Y3K?.system?.applyInitialSettings?.("palette");
          } catch (applyErr) {
            console.warn(
              "[StarryNight] Unable to trigger palette system refresh",
              applyErr
            );
          }
        }, "onChange")
      }
    );
    const glassOptions = ["disabled", "minimal", "moderate", "intense"];
    const currentGlass = settingsManager2.get("sn-glassmorphism-level");
    section.addDropDown(
      "sn-glassmorphism-level",
      "Glassmorphism",
      glassOptions,
      Math.max(0, glassOptions.indexOf(currentGlass)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager2.set("sn-glassmorphism-level", glassOptions[idx]);
        }, "onChange")
      }
    );
    const artisticOptions = [
      "corporate-safe",
      "artist-vision",
      "cosmic-maximum"
    ];
    const currentArtistic = settingsManager2.get("sn-artistic-mode");
    section.addDropDown(
      "sn-artistic-mode",
      "Artistic mode",
      artisticOptions,
      Math.max(0, artisticOptions.indexOf(currentArtistic)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const mode = artisticOptions[idx];
          settingsManager2.set("sn-artistic-mode", mode);
          globalThis.year3000System?.YEAR3000_CONFIG?.safeSetArtisticMode?.(mode);
        }, "onChange")
      }
    );
    const harmonicModes = Object.keys(HARMONIC_MODES2);
    const currentHarmMode = settingsManager2.get("sn-current-harmonic-mode");
    if (harmonicModes.length) {
      section.addDropDown(
        "sn-current-harmonic-mode",
        "Harmonic colour mode",
        harmonicModes,
        Math.max(0, harmonicModes.indexOf(currentHarmMode)),
        void 0,
        {
          onChange: /* @__PURE__ */ __name((e) => {
            const idx = e?.currentTarget?.selectedIndex ?? 0;
            const modeKey = harmonicModes[idx];
            settingsManager2.set("sn-current-harmonic-mode", modeKey);
            globalThis.Y3K?.system?.evolveHarmonicSignature?.(modeKey);
          }, "onChange")
        }
      );
    }
    const currentHarmInt = settingsManager2.get("sn-harmonic-intensity") || "0.7";
    section.addInput(
      "sn-harmonic-intensity",
      "Harmonic intensity (music-color sync strength 0-1)",
      currentHarmInt,
      "number",
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const val = e.currentTarget.value;
          settingsManager2.set("sn-harmonic-intensity", val);
        }, "onChange")
      }
    );
    const currentEvolution = settingsManager2.get("sn-harmonic-evolution") === "true";
    section.addToggle(
      "sn-harmonic-evolution",
      "Allow harmonic evolution",
      currentEvolution,
      {
        onClick: /* @__PURE__ */ __name((e) => {
          const checked = e.currentTarget.checked;
          settingsManager2.set(
            "sn-harmonic-evolution",
            checked ? "true" : "false"
          );
        }, "onClick")
      }
    );
    const enableWebGL = settingsManager2.get("sn-webgl-enabled") === "true";
    section.addToggle(
      "sn-webgl-enabled",
      "WebGL effects (master toggle for all WebGL backgrounds)",
      enableWebGL,
      {
        onClick: /* @__PURE__ */ __name((e) => {
          const checked = e.currentTarget.checked;
          settingsManager2.set(
            "sn-webgl-enabled",
            checked ? "true" : "false"
          );
        }, "onClick")
      }
    );
    const webglQualityOptions = ["low", "medium", "high"];
    const currentWebGLQ = settingsManager2.get("sn-webgl-quality") || "medium";
    section.addDropDown(
      "sn-webgl-quality",
      "WebGL quality (performance vs visual quality)",
      webglQualityOptions,
      Math.max(0, webglQualityOptions.indexOf(currentWebGLQ)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 1;
          const val = webglQualityOptions[idx] ?? "medium";
          settingsManager2.set("sn-webgl-quality", val);
        }, "onChange")
      }
    );
    const animQualityOptions = ["auto", "low", "high"];
    const currentAnimQ = settingsManager2.get("sn-animation-quality") || "auto";
    section.addDropDown(
      "sn-animation-quality",
      "Animation quality (auto/low/high performance)",
      animQualityOptions,
      Math.max(0, animQualityOptions.indexOf(currentAnimQ)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const val = animQualityOptions[idx] ?? "auto";
          settingsManager2.set("sn-animation-quality", val);
        }, "onChange")
      }
    );
    await section.pushSettings();
    console.log("\u2728 [StarryNight] spcr-settings panel initialised");
    const initialBrightness = settingsManager2.get("sn-brightness-mode") || "dark";
    const cssController = getCSSController2();
    const initialBrightnessVariables = {
      "--sn-brightness-mode": `"${initialBrightness}"`,
      "--sn-brightness-data-attr": initialBrightness
    };
    cssController.batchSetVariables(
      "StarryNightSettings",
      initialBrightnessVariables,
      "high",
      // High priority for initial brightness setup
      "brightness-mode-init"
    );
    document.documentElement.setAttribute(
      "data-sn-brightness",
      initialBrightness
    );
    console.log(
      `[StarryNight] Initial brightness mode set to: ${initialBrightness}`
    );
    const rerender = /* @__PURE__ */ __name(() => section.rerender(), "rerender");
    const history = globalThis.Spicetify?.Platform?.History;
    try {
      if (history?.listen) {
        history.listen(({ location }) => {
          if (location?.pathname === "/settings") {
            setTimeout(rerender, 100);
          }
        });
      }
    } catch (err) {
      console.warn("[StarryNight] Could not hook navigation for settings", err);
    }
    if (window.location.pathname === "/settings") {
      setTimeout(rerender, 300);
    }
  }
  var init_StarryNightSettings = __esm({
    "src-js/ui/components/StarryNightSettings.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_SettingsSection();
      init_SettingsManager();
      init_starryNightEffects();
      __name(getCSSController2, "getCSSController");
      __name(initializeStarryNightSettings, "initializeStarryNightSettings");
    }
  });

  // src-js/visual/ui-effects/RightSidebarVisualEffects.ts
  var RightSidebarVisualEffects_exports = {};
  __export(RightSidebarVisualEffects_exports, {
    RightSidebarConsciousnessSystem: () => RightSidebarConsciousnessSystem
  });
  var _RightSidebarConsciousnessSystem, RightSidebarConsciousnessSystem;
  var init_RightSidebarVisualEffects = __esm({
    "src-js/visual/ui-effects/RightSidebarVisualEffects.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_BaseVisualSystem();
      init_SidebarPerformanceCoordinator();
      _RightSidebarConsciousnessSystem = class _RightSidebarConsciousnessSystem extends BaseVisualSystem {
        constructor(config, utils, perf, musicSync, settings2, year3000System2 = null, coordinator) {
          super(config, utils, perf, musicSync, settings2);
          // Current  target state for smooth lerp
          this.currentBeatIntensity = 0;
          this.targetBeatIntensity = 0;
          this.currentHueShift = 0;
          // degrees
          this.targetHueShift = 0;
          // Lerp smoothing factors
          this.INTENSITY_LERP = 0.25;
          this.HUE_LERP = 0.05;
          // Loop control
          this.fallbackRafId = null;
          this.lastTimestamp = performance.now();
          // Unsubscribe functions
          this.unsubBeat = null;
          this.unsubEnergy = null;
          this.year3000System = year3000System2;
          this.coordinator = coordinator || SidebarPerformanceCoordinator.getInstance({
            enableDebug: config.enableDebug,
            performanceAnalyzer: perf,
            onFlushComplete: /* @__PURE__ */ __name(() => {
              perf?.emitTrace?.(
                "[RightSidebarConsciousnessSystem] Coordinator flush completed"
              );
            }, "onFlushComplete")
          });
        }
        /* ------------------------------------------------------------------ */
        /* Initialization                                                     */
        /* ------------------------------------------------------------------ */
        async _performSystemSpecificInitialization() {
          const beatSubId = unifiedEventBus.subscribe(
            "music:beat",
            (data) => this._handleBeat({ intensity: data.intensity, timestamp: data.timestamp }),
            "RightSidebarConsciousnessSystem"
          );
          this.unsubBeat = () => unifiedEventBus.unsubscribe(beatSubId);
          const energySubId = unifiedEventBus.subscribe(
            "music:energy",
            (data) => this._handleEnergy({ energy: data.energy, timestamp: data.timestamp }),
            "RightSidebarConsciousnessSystem"
          );
          this.unsubEnergy = () => unifiedEventBus.unsubscribe(energySubId);
          this._tryRegisterWithMasterAnimation();
        }
        _tryRegisterWithMasterAnimation() {
          if (this.year3000System?.registerAnimationSystem && this.year3000System.enhancedMasterAnimationCoordinator) {
            const ok = this.year3000System.registerAnimationSystem(
              "RightSidebarConsciousnessSystem",
              this,
              "background",
              60
            );
            if (ok) return;
          }
          this._startFallbackLoop();
        }
        /* ------------------------------------------------------------------ */
        /* Event Handlers                                                     */
        /* ------------------------------------------------------------------ */
        _handleBeat({ intensity }) {
          this.targetBeatIntensity = Math.min(Math.max(intensity, 0), 1);
        }
        _handleEnergy({ energy }) {
          const deg = Math.round(energy * 120);
          this.targetHueShift = deg;
        }
        /* ------------------------------------------------------------------ */
        /* Animation Loop                                                     */
        /* ------------------------------------------------------------------ */
        onAnimate(deltaMs) {
          this._tick(deltaMs);
        }
        _startFallbackLoop() {
          const loop = /* @__PURE__ */ __name((ts) => {
            const delta = ts - this.lastTimestamp;
            this.lastTimestamp = ts;
            this._tick(delta);
            this.fallbackRafId = requestAnimationFrame(loop);
          }, "loop");
          this.fallbackRafId = requestAnimationFrame(loop);
        }
        _tick(_deltaMs) {
          this.currentBeatIntensity = this._lerp(
            this.currentBeatIntensity,
            this.targetBeatIntensity,
            this.INTENSITY_LERP
          );
          this.currentHueShift = this._lerp(
            this.currentHueShift,
            this.targetHueShift,
            this.HUE_LERP
          );
          this._queueCssVar("--sn-rs-beat-intensity", this.currentBeatIntensity);
          const glowAlpha = (0.15 + this.currentBeatIntensity * 0.45).toFixed(3);
          this._queueCssVar("--sn-rs-glow-alpha", glowAlpha);
          this._queueCssVar("--sn-rs-hue-shift", `${this.currentHueShift}deg`);
        }
        _queueCssVar(property, value) {
          this.coordinator.queueUpdate(property, String(value));
        }
        _lerp(from, to, alpha) {
          return from + (to - from) * alpha;
        }
        /* ------------------------------------------------------------------ */
        /* Cleanup                                                            */
        /* ------------------------------------------------------------------ */
        destroy() {
          super.destroy();
          this.unsubBeat?.();
          this.unsubEnergy?.();
          if (this.fallbackRafId) cancelAnimationFrame(this.fallbackRafId);
        }
      };
      __name(_RightSidebarConsciousnessSystem, "RightSidebarConsciousnessSystem");
      RightSidebarConsciousnessSystem = _RightSidebarConsciousnessSystem;
    }
  });

  // src-js/visual/effects/DepthLayerController.ts
  var DepthLayerController_exports = {};
  __export(DepthLayerController_exports, {
    DepthConsciousnessController: () => DepthConsciousnessController
  });
  var _DepthConsciousnessController, DepthConsciousnessController;
  var init_DepthLayerController = __esm({
    "src-js/visual/effects/DepthLayerController.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_UnifiedDebugManager();
      init_Year3000Utilities();
      init_BaseVisualSystem();
      _DepthConsciousnessController = class _DepthConsciousnessController extends BaseVisualSystem {
        // Track time spent in areas
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, performanceMonitor = null, musicSyncService = null, settingsManager2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this.contentAreas = /* @__PURE__ */ new Map();
          this.chromeAreas = /* @__PURE__ */ new Set();
          this.userState = {
            isScrolling: false,
            isHovering: false,
            lastInteractionTime: 0,
            readingModeActive: false,
            interactionTarget: null,
            // Enhanced interaction awareness defaults
            currentMode: "browsing",
            focusDepth: 0.3,
            scrollVelocity: 0,
            dwellTime: 0,
            interactionPattern: "casual",
            contentEngagement: 0.5
          };
          this.musicalState = {
            energy: 0.5,
            valence: 0.5,
            instrumental: false,
            tempo: 120,
            // Enhanced musical consciousness defaults
            emotionalTemperature: 0.5,
            musicSyncStrength: 0.7,
            genreConsciousnessProfile: {
              ambientLevel: 0.5,
              energyResponse: 0.6,
              visualComplexity: 0.5
            },
            musicalMemoryPatterns: 0.4
          };
          this.readingModeTimer = 0;
          this.interactionTimer = 0;
          this.consciousnessUpdateInterval = 0;
          // Performance optimization and consciousness timing
          this.lastUpdate = 0;
          this.updateThreshold = 100;
          // Max 10fps for consciousness updates
          this.consciousnessIntensity = 0.7;
          // Overall consciousness system intensity
          this.adaptiveProtectionMap = /* @__PURE__ */ new Map();
          // Dynamic protection levels
          this.scrollVelocityHistory = [];
          // Track scroll patterns
          this.dwellTimeTracker = /* @__PURE__ */ new Map();
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            const year3000System2 = globalThis.year3000System;
            this.cssController = year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
            this.detectContentAndChromeAreas();
            this.setupInteractionListeners();
            this.initializeConsciousnessVariables();
            this.startConsciousnessUpdate();
            Y3KDebug?.debug?.log(
              "DepthConsciousnessController",
              "Consciousness system awakened"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DepthConsciousnessController",
              "Failed to initialize consciousness:",
              error
            );
          }
        }
        /**
         * Enhanced content detection with advanced awareness patterns
         */
        detectContentAndChromeAreas() {
          const contentSelectors = {
            text: [
              ".main-view-container__scroll-node",
              ".main-trackList-trackListRow",
              '[data-testid*="tracklist"]',
              '[data-testid*="playlist"]',
              ".main-entityHeader-titleText",
              ".main-entityHeader-subtitle",
              ".main-trackList-rowTitle",
              ".main-trackList-rowSubTitle",
              "h1, h2, h3, h4, h5, h6",
              "p",
              ".lyrics-lyricsContainer-container",
              ".main-cardSubHeader-root",
              ".main-trackList-indexNumber",
              ".main-trackInfo-name",
              ".main-trackInfo-artists"
            ],
            interactive: [
              "button",
              "a[role='button']",
              "[tabindex='0']",
              ".main-playButton-button",
              ".main-addButton-button",
              ".main-moreButton-button",
              ".main-trackList-rowPlayPause",
              ".control-button",
              "input",
              "select"
            ],
            visual: [
              ".main-image-container",
              ".main-entityHeader-image",
              ".cover-art",
              ".main-coverSlot-container",
              ".main-image-image"
            ],
            media: [
              "video",
              "audio",
              ".main-nowPlayingWidget-trackInfo",
              ".main-coverSlot-container",
              ".main-nowPlayingView-coverArt"
            ],
            navigation: [
              ".main-navBar-navBarLink",
              ".main-rootlist-rootlistItem",
              ".main-collectionLinkText-text"
            ]
          };
          const chromeSelectors = [
            ".Root__nav-bar",
            ".Root__top-bar",
            ".Root__now-playing-bar",
            ".main-topBar-container",
            ".main-navBar-navBar",
            ".main-entityHeader-container",
            ".main-actionBar-container",
            ".main-view-container",
            ".Root__main-view",
            ".main-rootlist-wrapper"
          ];
          Object.entries(contentSelectors).forEach(([type, selectors]) => {
            selectors.forEach((selector) => {
              document.querySelectorAll(selector).forEach((element) => {
                const contentArea = {
                  element,
                  type,
                  protectionLevel: this.calculateAdvancedProtectionLevel(element, type),
                  lastInteraction: 0,
                  consciousnessLevel: this.calculateConsciousnessLevel(element),
                  readingIntensity: 0,
                  contextualImportance: this.calculateContextualImportance(element),
                  adaptiveProtection: this.calculateProtectionLevel(element)
                };
                this.contentAreas.set(element, contentArea);
                element.classList.add("content-sanctuary");
                element.classList.add(`content-${type}`);
                element.setAttribute("data-consciousness-protected", "true");
                element.setAttribute("data-content-type", contentArea.type);
                element.setAttribute("data-consciousness-level", contentArea.consciousnessLevel.toString());
                element.setAttribute("data-contextual-importance", contentArea.contextualImportance.toString());
                this.adaptiveProtectionMap.set(element, contentArea.adaptiveProtection);
                this.dwellTimeTracker.set(element, 0);
              });
            });
          });
          chromeSelectors.forEach((selector) => {
            document.querySelectorAll(selector).forEach((element) => {
              this.chromeAreas.add(element);
              element.classList.add("ui-chrome-area");
              element.setAttribute("data-consciousness-enhanced", "true");
            });
          });
          const contentStats = this.analyzeContentDistribution();
          Y3KDebug?.debug?.log(
            "DepthConsciousnessController",
            `Enhanced detection: ${this.contentAreas.size} content areas, ${this.chromeAreas.size} chrome areas`,
            contentStats
          );
        }
        /**
         * Determine content type for appropriate protection level
         */
        determineContentType(element) {
          if (element.matches("h1, h2, h3, h4, h5, h6, .main-entityHeader-titleText")) {
            return "text";
          }
          if (element.matches('button, a, [role="button"], [tabindex], input, select')) {
            return "interactive";
          }
          if (element.matches(
            ".main-image-container, .main-entityHeader-image, .cover-art"
          )) {
            return "visual";
          }
          if (element.matches(".Root__nav-bar, .Root__top-bar, .main-topBar-container")) {
            return "chrome";
          }
          return "text";
        }
        /**
         * Calculate protection level based on content type and context
         */
        calculateProtectionLevel(element) {
          const contentType = this.determineContentType(element);
          switch (contentType) {
            case "text":
              return 0.95;
            case "interactive":
              return 0.9;
            case "visual":
              return 0.6;
            case "chrome":
              return 0.3;
            case "media":
              return 0.5;
            case "navigation":
              return 0.7;
            default:
              return 0.85;
          }
        }
        /**
         * Advanced protection level calculation with consciousness awareness
         */
        calculateAdvancedProtectionLevel(element, type) {
          const baseProtection = this.calculateProtectionLevel(element);
          let adjustment = 0;
          if (type === "text" && element.textContent && element.textContent.length > 50) {
            adjustment += 0.05;
          }
          const rect = element.getBoundingClientRect();
          const isInViewport = rect.top >= 0 && rect.left >= 0 && rect.bottom <= window.innerHeight && rect.right <= window.innerWidth;
          if (isInViewport) {
            adjustment += 0.02;
          }
          if (element.matches('h1, h2, .main-entityHeader-titleText, [data-testid*="title"]')) {
            adjustment += 0.03;
          }
          return Math.min(baseProtection + adjustment, 0.98);
        }
        /**
         * Calculate consciousness level - how much consciousness effects should be applied
         */
        calculateConsciousnessLevel(element) {
          const rect = element.getBoundingClientRect();
          const elementArea = rect.width * rect.height;
          const viewportArea = window.innerWidth * window.innerHeight;
          const elementVisibilityRatio = elementArea / viewportArea;
          let consciousnessLevel = Math.min(elementVisibilityRatio * 2, 0.8);
          if (element.matches(".Root__main-view, .main-view-container")) {
            consciousnessLevel += 0.3;
          }
          if (element.matches(".main-nowPlayingBar-container")) {
            consciousnessLevel += 0.4;
          }
          return Math.min(consciousnessLevel, 1);
        }
        /**
         * Calculate contextual importance based on user behavior and content significance
         */
        calculateContextualImportance(element) {
          let importance = 0.5;
          if (element.matches('button, a, [role="button"], [tabindex="0"]')) {
            importance += 0.2;
          }
          if (element.matches(".main-view-container, .main-entityHeader, .main-trackList")) {
            importance += 0.3;
          }
          if (element.matches(".main-nowPlayingWidget, .main-nowPlayingBar")) {
            importance += 0.4;
          }
          if (element.matches(":focus, :focus-within, :hover")) {
            importance += 0.2;
          }
          return Math.min(importance, 1);
        }
        /**
         * Analyze content distribution for consciousness optimization
         */
        analyzeContentDistribution() {
          const stats = {
            totalAreas: this.contentAreas.size,
            textAreas: 0,
            interactiveAreas: 0,
            visualAreas: 0,
            mediaAreas: 0,
            navigationAreas: 0,
            chromeAreas: this.chromeAreas.size,
            averageProtection: 0,
            highProtectionAreas: 0
          };
          let totalProtection = 0;
          this.contentAreas.forEach((area) => {
            switch (area.type) {
              case "text":
                stats.textAreas++;
                break;
              case "interactive":
                stats.interactiveAreas++;
                break;
              case "visual":
                stats.visualAreas++;
                break;
              case "media":
                stats.mediaAreas++;
                break;
              case "navigation":
                stats.navigationAreas++;
                break;
            }
            totalProtection += area.protectionLevel;
            if (area.protectionLevel > 0.8) {
              stats.highProtectionAreas++;
            }
          });
          stats.averageProtection = totalProtection / this.contentAreas.size || 0;
          return stats;
        }
        /**
         * Analyze scrolling behavior patterns for consciousness adaptation
         */
        analyzeScrollingBehavior() {
          if (this.scrollVelocityHistory.length < 3) return;
          const avgVelocity = this.scrollVelocityHistory.reduce((a, b) => a + b, 0) / this.scrollVelocityHistory.length;
          const velocityVariance = this.scrollVelocityHistory.reduce((variance, velocity) => {
            return variance + Math.pow(velocity - avgVelocity, 2);
          }, 0) / this.scrollVelocityHistory.length;
          if (velocityVariance < 100 && avgVelocity < 300) {
            this.userState.contentEngagement = Math.min(this.userState.contentEngagement + 0.05, 1);
            this.userState.interactionPattern = "contemplative";
          } else if (avgVelocity > 1500 && velocityVariance > 500) {
            this.userState.contentEngagement = Math.max(this.userState.contentEngagement - 0.1, 0.1);
            this.userState.interactionPattern = "rapid";
          } else {
            this.userState.interactionPattern = "casual";
          }
          if (this.userState.contentEngagement > 0.7) {
            this.consciousnessIntensity = Math.min(this.consciousnessIntensity + 0.05, 0.9);
          } else if (this.userState.contentEngagement < 0.3) {
            this.consciousnessIntensity = Math.max(this.consciousnessIntensity - 0.1, 0.3);
          }
        }
        /**
         * Calculate interaction modifier for consciousness intensity
         */
        calculateInteractionModifier() {
          let modifier = 0;
          if (this.userState.readingModeActive) {
            modifier -= 0.6;
          }
          if (this.userState.isHovering) {
            const contentArea = this.contentAreas.get(this.userState.interactionTarget);
            if (contentArea) {
              const reductionFactor = contentArea.type === "text" ? 0.4 : contentArea.type === "interactive" ? 0.3 : contentArea.type === "chrome" ? 0.1 : 0.2;
              modifier -= reductionFactor;
            }
          }
          if (this.userState.scrollVelocity > 1e3) {
            modifier -= 0.2;
          }
          if (this.userState.focusDepth > 0.7 && !this.userState.readingModeActive) {
            modifier += 0.2;
          }
          return modifier;
        }
        /**
         * Calculate contextual modifier based on current application context
         */
        calculateContextualModifier() {
          let modifier = 0;
          if (this.userState.interactionTarget?.matches(".main-nowPlayingBar, .main-nowPlayingWidget")) {
            modifier += 0.3;
          }
          if (this.userState.interactionTarget?.matches(".main-trackList, .main-entityHeader-subtitle")) {
            modifier -= this.userState.currentMode === "exploring" ? 0.1 : 0.3;
          }
          if (this.userState.currentMode === "ambient") {
            modifier += 0.4;
          }
          if (this.userState.currentMode === "navigating") {
            modifier -= 0.2;
          }
          return modifier;
        }
        /**
         * Convert interaction mode to numeric value for CSS
         */
        getModeNumericValue(mode) {
          const modes = { "reading": 0, "browsing": 1, "exploring": 2, "navigating": 3, "ambient": 4 };
          return modes[mode] / 4;
        }
        /**
         * Convert interaction pattern to numeric value for CSS
         */
        getPatternNumericValue(pattern) {
          const patterns = { "contemplative": 0, "casual": 1, "deliberate": 2, "rapid": 3 };
          return patterns[pattern] / 3;
        }
        /**
         * Calculate membrane fluidity index based on user behavior and music
         */
        calculateMembraneFluidityIndex() {
          let fluidity = 0.5;
          fluidity += this.musicalState.energy * 0.3;
          fluidity += this.userState.contentEngagement * 0.2;
          fluidity += this.musicalState.emotionalTemperature * 0.2;
          if (this.userState.interactionPattern === "contemplative") {
            fluidity -= 0.2;
          } else if (this.userState.interactionPattern === "rapid") {
            fluidity += 0.3;
          }
          return Math.max(0.1, Math.min(1, fluidity));
        }
        /**
         * Calculate genre-specific consciousness shifts
         */
        calculateGenreConsciousnessShift() {
          if (!this.musicalState.genre) return 0.5;
          const genreShifts = {
            "ambient": 0.8,
            // High consciousness for ambient music
            "electronic": 0.7,
            // Moderate-high for electronic
            "classical": 0.6,
            // Moderate for classical
            "jazz": 0.5,
            // Balanced for jazz
            "rock": 0.4,
            // Moderate-low for rock
            "pop": 0.3,
            // Lower for pop
            "hip-hop": 0.2
            // Low for hip-hop (focus on lyrics)
          };
          const baseShift = genreShifts[this.musicalState.genre.toLowerCase()] || 0.5;
          let adjustment = 0;
          if (this.musicalState.valence > 0.7) adjustment += 0.1;
          if (this.musicalState.energy > 0.8) adjustment += 0.1;
          return Math.max(0.1, Math.min(1, baseShift + adjustment));
        }
        /**
         * Enhanced interaction listeners with advanced consciousness awareness
         */
        setupInteractionListeners() {
          let scrollTimer;
          let lastScrollY = window.scrollY;
          let lastScrollTime = Date.now();
          document.addEventListener(
            "scroll",
            () => {
              const now = Date.now();
              const currentScrollY = window.scrollY;
              const timeDelta = now - lastScrollTime;
              const scrollDelta = Math.abs(currentScrollY - lastScrollY);
              this.userState.scrollVelocity = timeDelta > 0 ? scrollDelta / timeDelta * 1e3 : 0;
              this.scrollVelocityHistory.push(this.userState.scrollVelocity);
              if (this.scrollVelocityHistory.length > 10) {
                this.scrollVelocityHistory.shift();
              }
              const avgVelocity = this.scrollVelocityHistory.reduce((a, b) => a + b, 0) / this.scrollVelocityHistory.length;
              if (avgVelocity > 2e3) {
                this.userState.interactionPattern = "rapid";
                this.userState.currentMode = "browsing";
              } else if (avgVelocity > 500) {
                this.userState.interactionPattern = "deliberate";
                this.userState.currentMode = "exploring";
              } else {
                this.userState.interactionPattern = "contemplative";
              }
              this.userState.isScrolling = true;
              this.userState.lastInteractionTime = now;
              lastScrollY = currentScrollY;
              lastScrollTime = now;
              clearTimeout(scrollTimer);
              scrollTimer = window.setTimeout(() => {
                this.userState.isScrolling = false;
                this.analyzeScrollingBehavior();
              }, 150);
              this.updateUserInteractionState();
            },
            { passive: true }
          );
          this.contentAreas.forEach((contentArea, element) => {
            let enterTime = 0;
            element.addEventListener("mouseenter", () => {
              enterTime = Date.now();
              this.userState.isHovering = true;
              this.userState.interactionTarget = element;
              this.userState.lastInteractionTime = enterTime;
              contentArea.lastInteraction = enterTime;
              this.dwellTimeTracker.set(element, enterTime);
              this.userState.focusDepth = Math.min(this.userState.focusDepth + 0.1, 1);
              if (contentArea.type === "text") {
                this.userState.focusDepth = Math.min(this.userState.focusDepth + 0.2, 1);
              }
              this.updateUserInteractionState();
            });
            element.addEventListener("mouseleave", () => {
              const leaveTime = Date.now();
              const dwellTime = leaveTime - enterTime;
              this.userState.dwellTime = dwellTime;
              contentArea.readingIntensity = Math.min(dwellTime / 5e3, 1);
              if (contentArea.type === "text" && dwellTime > 1e3) {
                this.userState.contentEngagement = Math.min(this.userState.contentEngagement + 0.1, 1);
                contentArea.contextualImportance = Math.min(contentArea.contextualImportance + 0.05, 1);
              }
              if (dwellTime > 3e3) {
                const currentProtection = this.adaptiveProtectionMap.get(element) || contentArea.protectionLevel;
                this.adaptiveProtectionMap.set(element, Math.min(currentProtection + 0.05, 0.98));
              }
              this.userState.isHovering = false;
              this.userState.interactionTarget = null;
              this.userState.focusDepth = Math.max(this.userState.focusDepth - 0.05, 0.1);
              this.updateUserInteractionState();
            });
          });
          document.addEventListener("mousemove", () => {
            clearTimeout(this.readingModeTimer);
            this.userState.readingModeActive = false;
            if (this.userState.focusDepth > 0.7) {
              this.userState.currentMode = "reading";
            } else if (this.userState.scrollVelocity > 1e3) {
              this.userState.currentMode = "browsing";
            } else {
              this.userState.currentMode = "exploring";
            }
            const detectionTime = this.userState.currentMode === "reading" ? 1500 : 2e3;
            this.readingModeTimer = window.setTimeout(() => {
              if (this.userState.interactionTarget && this.contentAreas.has(this.userState.interactionTarget)) {
                this.userState.readingModeActive = true;
                this.userState.currentMode = "reading";
                this.userState.focusDepth = Math.min(this.userState.focusDepth + 0.3, 1);
                const contentArea = this.contentAreas.get(this.userState.interactionTarget);
                if (contentArea && contentArea.type === "text") {
                  const currentProtection = this.adaptiveProtectionMap.get(this.userState.interactionTarget) || contentArea.protectionLevel;
                  this.adaptiveProtectionMap.set(this.userState.interactionTarget, Math.min(currentProtection + 0.1, 0.98));
                }
                this.updateUserInteractionState();
              }
            }, detectionTime);
          });
          let ambientTimer;
          const resetAmbientTimer = /* @__PURE__ */ __name(() => {
            clearTimeout(ambientTimer);
            ambientTimer = window.setTimeout(() => {
              this.userState.currentMode = "ambient";
              this.userState.focusDepth = Math.max(this.userState.focusDepth - 0.5, 0.1);
              this.updateUserInteractionState();
            }, 3e4);
          }, "resetAmbientTimer");
          ["mousedown", "mousemove", "keydown", "scroll", "touchstart"].forEach((eventType) => {
            document.addEventListener(eventType, resetAmbientTimer, { passive: true });
          });
          resetAmbientTimer();
          document.addEventListener("music-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.syncWithMusic(customEvent.detail);
            }
          });
          document.addEventListener("beat-detected", () => {
            this.handleBeatPulse();
          });
        }
        /**
         * Initialize CSS consciousness variables
         */
        initializeConsciousnessVariables() {
          const initialVariables = {
            "--consciousness-system-active": "1",
            "--content-protection-level": "0.95",
            "--chrome-enhancement-level": "2.0",
            "--consciousness-breath-rate": "4s",
            "--musical-sync-intensity": "0.5",
            "--reading-mode-active": "0",
            "--user-interaction-detected": "0"
          };
          this.cssController.batchSetVariables(
            "DepthConsciousnessController",
            initialVariables,
            "normal",
            "consciousness-initialization"
          );
        }
        /**
         * Start consciousness update loop
         */
        startConsciousnessUpdate() {
          const updateConsciousness = /* @__PURE__ */ __name(() => {
            if (!this.isActive) return;
            const now = performance.now();
            if (now - this.lastUpdate >= this.updateThreshold) {
              this.updateConsciousnessState();
              this.lastUpdate = now;
            }
            requestAnimationFrame(updateConsciousness);
          }, "updateConsciousness");
          updateConsciousness();
        }
        /**
         * Enhanced consciousness state update with advanced awareness patterns
         */
        updateConsciousnessState() {
          const root = document.documentElement;
          const baseIntensity = this.consciousnessIntensity;
          const musicalModifier = this.musicalState.energy * this.musicalState.musicSyncStrength * 0.3;
          const interactionModifier = this.calculateInteractionModifier();
          const contextualModifier = this.calculateContextualModifier();
          const emotionalModifier = this.musicalState.emotionalTemperature * 0.2;
          const finalConsciousnessIntensity = Math.max(
            0.05,
            Math.min(1, baseIntensity + musicalModifier + interactionModifier + contextualModifier + emotionalModifier)
          );
          const consciousnessVariables = {
            "--consciousness-intensity": finalConsciousnessIntensity.toString(),
            "--consciousness-level": this.consciousnessIntensity.toString(),
            "--awareness-level": this.userState.focusDepth.toString(),
            "--musical-sync-intensity": this.musicalState.energy.toString(),
            "--musical-sync-strength": this.musicalState.musicSyncStrength.toString(),
            "--emotional-temperature": this.musicalState.emotionalTemperature.toString(),
            "--reading-mode-active": this.userState.readingModeActive ? "1" : "0",
            "--user-interaction-detected": this.userState.isScrolling || this.userState.isHovering ? "1" : "0",
            "--current-interaction-mode": this.getModeNumericValue(this.userState.currentMode).toString(),
            "--focus-depth": this.userState.focusDepth.toString(),
            "--content-engagement": this.userState.contentEngagement.toString(),
            "--scroll-velocity": Math.min(this.userState.scrollVelocity / 2e3, 1).toString(),
            "--dwell-time-factor": Math.min(this.userState.dwellTime / 5e3, 1).toString(),
            "--interaction-pattern": this.getPatternNumericValue(this.userState.interactionPattern).toString(),
            "--temporal-flow-direction-x": (Math.sin(Date.now() * 1e-4) * 0.5 + 0.5).toString(),
            "--temporal-flow-direction-y": (Math.cos(Date.now() * 1e-4) * 0.5 + 0.5).toString(),
            "--memory-intensity": this.musicalState.musicalMemoryPatterns.toString(),
            "--membrane-fluidity-index": this.calculateMembraneFluidityIndex().toString(),
            "--genre-consciousness-shift": this.calculateGenreConsciousnessShift().toString()
          };
          this.cssController.batchSetVariables(
            "DepthConsciousnessController",
            consciousnessVariables,
            "normal",
            "consciousness-state-update"
          );
          root.classList.remove("music-energy-high", "music-energy-calm");
          if (this.musicalState.energy > 0.7) {
            root.classList.add("music-energy-high");
          } else if (this.musicalState.energy < 0.3) {
            root.classList.add("music-energy-calm");
          }
          root.setAttribute(
            "data-user-interacting",
            (this.userState.isScrolling || this.userState.isHovering).toString()
          );
          root.setAttribute(
            "data-reading-mode",
            this.userState.readingModeActive.toString()
          );
        }
        /**
         * Update user interaction state
         */
        updateUserInteractionState() {
          this.updateConsciousnessState();
        }
        /**
         * Sync consciousness with musical state
         */
        syncWithMusic(musicState) {
          Object.assign(this.musicalState, musicState);
          if (musicState.tempo) {
            const breathRate = Math.max(
              2,
              Math.min(8, 60 / (musicState.tempo / 60) * 4)
            );
            this.cssController.setVariable(
              "DepthConsciousnessController",
              "--consciousness-breath-rate",
              `${breathRate}s`,
              "high",
              // High priority for musical sync
              "musical-tempo-sync"
            );
          }
          this.updateConsciousnessState();
          Y3KDebug?.debug?.log(
            "DepthConsciousnessController",
            `Musical consciousness sync: energy=${musicState.energy}, tempo=${musicState.tempo}`
          );
        }
        /**
         * Handle beat pulse for consciousness effects
         */
        handleBeatPulse() {
          if (this.userState.readingModeActive) return;
          const root = document.documentElement;
          const currentIntensity = parseFloat(
            root.style.getPropertyValue("--consciousness-intensity") || "0.5"
          );
          const pulseIntensity = Math.min(1, currentIntensity + 0.1);
          this.cssController.setVariable(
            "DepthConsciousnessController",
            "--consciousness-intensity",
            pulseIntensity.toString(),
            "high",
            "beat-pulse"
          );
          setTimeout(() => {
            if (this.isActive) {
              this.updateConsciousnessState();
            }
          }, 100);
        }
        /**
         * Dynamically add content protection to new elements
         */
        protectNewContent(element) {
          if (this.contentAreas.has(element)) return;
          const contentArea = {
            element,
            type: this.determineContentType(element),
            protectionLevel: this.calculateProtectionLevel(element),
            lastInteraction: 0,
            consciousnessLevel: 0.5,
            // Initial consciousness adaptation level
            readingIntensity: 0,
            // No reading detected initially
            contextualImportance: this.calculateProtectionLevel(element),
            // Use protection level as initial importance
            adaptiveProtection: 0.5
            // Start with moderate adaptive protection
          };
          this.contentAreas.set(element, contentArea);
          element.classList.add("content-sanctuary");
          element.setAttribute("data-consciousness-protected", "true");
          element.setAttribute("data-content-type", contentArea.type);
          Y3KDebug?.debug?.log(
            "DepthConsciousnessController",
            `Protected new content element: ${element.tagName}.${element.className}`
          );
        }
        /**
         * Enhanced chrome area
         */
        enhanceNewChrome(element) {
          if (this.chromeAreas.has(element)) return;
          this.chromeAreas.add(element);
          element.classList.add("ui-chrome-area");
          element.setAttribute("data-consciousness-enhanced", "true");
          Y3KDebug?.debug?.log(
            "DepthConsciousnessController",
            `Enhanced new chrome element: ${element.tagName}.${element.className}`
          );
        }
        /**
         * Force reading mode for accessibility
         */
        forceReadingMode(active) {
          this.userState.readingModeActive = active;
          this.updateUserInteractionState();
          Y3KDebug?.debug?.log(
            "DepthConsciousnessController",
            `Reading mode ${active ? "activated" : "deactivated"}`
          );
        }
        /**
         * Get consciousness metrics for monitoring
         */
        getConsciousnessMetrics() {
          return {
            contentAreas: this.contentAreas.size,
            chromeAreas: this.chromeAreas.size,
            consciousnessIntensity: parseFloat(
              document.documentElement.style.getPropertyValue(
                "--consciousness-intensity"
              ) || "0.5"
            ),
            readingModeActive: this.userState.readingModeActive,
            userInteracting: this.userState.isScrolling || this.userState.isHovering,
            musicalEnergy: this.musicalState.energy
          };
        }
        async healthCheck() {
          const metrics = this.getConsciousnessMetrics();
          const isHealthy = metrics.contentAreas > 0 && metrics.chromeAreas > 0;
          return {
            healthy: isHealthy,
            issues: isHealthy ? [] : ["Consciousness system not properly initialized"],
            metrics: {
              consciousnessLevel: metrics.contentAreas > 0 ? 1 : 0,
              protectedAreas: metrics.contentAreas,
              enhancedAreas: metrics.chromeAreas,
              musicalEnergy: metrics.musicalEnergy
            }
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          clearTimeout(this.readingModeTimer);
          clearTimeout(this.interactionTimer);
          this.contentAreas.forEach((_, element) => {
            element.classList.remove("content-sanctuary");
            element.removeAttribute("data-consciousness-protected");
            element.removeAttribute("data-content-type");
          });
          this.chromeAreas.forEach((element) => {
            element.classList.remove("ui-chrome-area");
            element.removeAttribute("data-consciousness-enhanced");
          });
          const resetVariables = {
            "--consciousness-system-active": "",
            "--consciousness-intensity": "",
            "--reading-mode-active": "",
            "--user-interaction-detected": "",
            "--consciousness-breath-rate": "",
            "--musical-sync-intensity": "",
            "--content-protection-level": "",
            "--chrome-enhancement-level": ""
          };
          this.cssController.batchSetVariables(
            "DepthConsciousnessController",
            resetVariables,
            "critical",
            // Critical priority for cleanup
            "system-cleanup"
          );
          const root = document.documentElement;
          root.classList.remove("music-energy-high", "music-energy-calm");
          root.removeAttribute("data-user-interacting");
          root.removeAttribute("data-reading-mode");
          Y3KDebug?.debug?.log(
            "DepthConsciousnessController",
            "Consciousness system deactivated"
          );
        }
      };
      __name(_DepthConsciousnessController, "DepthConsciousnessController");
      DepthConsciousnessController = _DepthConsciousnessController;
    }
  });

  // src-js/visual/effects/DynamicCatppuccinBridge.ts
  var DynamicCatppuccinBridge_exports = {};
  __export(DynamicCatppuccinBridge_exports, {
    DynamicCatppuccinBridge: () => DynamicCatppuccinBridge
  });
  var _DynamicCatppuccinBridge, DynamicCatppuccinBridge;
  var init_DynamicCatppuccinBridge = __esm({
    "src-js/visual/effects/DynamicCatppuccinBridge.ts"() {
      "use strict";
      init_globalConfig();
      init_UnifiedEventBus();
      init_OptimizedCSSVariableManager();
      init_UnifiedDebugManager();
      init_Year3000Utilities();
      init_BaseVisualSystem();
      _DynamicCatppuccinBridge = class _DynamicCatppuccinBridge extends BaseVisualSystem {
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, performanceMonitor = null, musicSyncService = null, settingsManager2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this.colorHarmonyEngine = null;
          this.depthConsciousnessController = null;
          this.dynamicColorState = {
            currentAccentHex: "#675c8f",
            // Default Catppuccin Mocha mauve (proper fallback)
            currentAccentRgb: "203,166,247",
            baseBackgroundHex: "#0d1117",
            // Default StarryNight deep space black
            baseBackgroundRgb: "13,17,23",
            lastUpdateTime: 0,
            musicEnergy: 0.5,
            transitionInProgress: false
          };
          this.integrationConfig = {
            accentUpdateEnabled: true,
            baseTransformationEnabled: true,
            consciousnessIntegrationEnabled: true,
            smoothTransitionDuration: 800,
            // 0.8s smooth transitions
            energyResponseMultiplier: 1.2
          };
          // Transition management
          this.transitionTimer = 0;
          this.lastTransitionStartTime = 0;
          this.transitionFromAccent = "";
          this.transitionToAccent = "";
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            const year3000System2 = globalThis.year3000System;
            this.cssController = year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
            this.setupColorExtractionListeners();
            this.setupSettingsListeners();
            this.initializeCurrentState();
            const isEnabled = this.checkDynamicAccentEnabled();
            this.integrationConfig.accentUpdateEnabled = isEnabled;
            if (isEnabled) {
              Y3KDebug?.debug?.log(
                "DynamicCatppuccinBridge",
                "Dynamic accent enabled - bridge active"
              );
            } else {
              Y3KDebug?.debug?.log(
                "DynamicCatppuccinBridge",
                "Dynamic accent disabled - bridge standby (will activate when enabled)"
              );
            }
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              "Color Extension Facade initialized successfully"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinBridge",
              "Failed to initialize facade:",
              error
            );
          }
        }
        /**
         * Check if dynamic accent is enabled in settings
         */
        checkDynamicAccentEnabled() {
          try {
            if (!this.settingsManager) return false;
            const accentSetting = this.settingsManager.get("catppuccin-accentColor");
            const isDynamic = String(accentSetting) === "dynamic";
            if (this.config.enableDebug) {
              Y3KDebug?.debug?.log(
                "DynamicCatppuccinBridge",
                `Accent setting: ${accentSetting}, Dynamic: ${isDynamic}`
              );
            }
            return isDynamic;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinBridge",
              "Error checking dynamic accent setting:",
              error
            );
            return false;
          }
        }
        /**
         * Setup listeners for color extraction events
         *  CRITICAL FIX: Enhanced with UnifiedEventBus integration
         */
        setupColorExtractionListeners() {
          unifiedEventBus.subscribe(
            "colors:extracted",
            (data) => {
              if (data.rawColors) {
                this.handleExtractedColors(data.rawColors);
              }
            },
            "DynamicCatppuccinBridge"
          );
          unifiedEventBus.subscribe(
            "colors:harmonized",
            (data) => {
              if (data.processedColors) {
                this.handleHarmonizedColors(data.processedColors);
              }
            },
            "DynamicCatppuccinBridge"
          );
          unifiedEventBus.subscribe(
            "colors:applied",
            (data) => {
              if (data.cssVariables && this.integrationConfig.accentUpdateEnabled) {
                this.handleCSSVariablesApplied(
                  data.cssVariables,
                  data.accentHex,
                  data.accentRgb
                );
              }
            },
            "DynamicCatppuccinBridge"
          );
          document.addEventListener("colors-extracted", (event) => {
            const customEvent = event;
            if (customEvent.detail && customEvent.detail.extractedColors) {
              this.handleExtractedColors(customEvent.detail.extractedColors);
            }
          });
          document.addEventListener("colors-harmonized", (event) => {
            const customEvent = event;
            if (customEvent.detail && customEvent.detail.harmonizedColors) {
              this.handleHarmonizedColors(customEvent.detail.harmonizedColors);
            }
          });
          document.addEventListener("music-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.handleMusicStateChange(customEvent.detail);
            }
          });
          document.addEventListener("spice-colors/update-request", (event) => {
            const customEvent = event;
            if (customEvent.detail && this.integrationConfig.accentUpdateEnabled) {
              this.handleSpiceColorUpdateRequest(customEvent.detail);
            }
          });
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Enhanced color extraction and coordination listeners setup complete (UnifiedEventBus + DOM)"
          );
        }
        /**
         * Handle requests from other systems to update spice colors
         */
        handleSpiceColorUpdateRequest(colorData) {
          const { accentHex, primaryHex, secondaryHex, source } = colorData;
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              `Received spice color update request from ${source}:`,
              {
                accent: accentHex,
                primary: primaryHex,
                secondary: secondaryHex
              }
            );
          }
          if (accentHex && accentHex !== this.dynamicColorState.currentAccentHex) {
            this.scheduleSmoothAccentTransition(accentHex);
          }
          if (primaryHex) {
            this.updateLivingBaseBackground(primaryHex);
          }
          document.dispatchEvent(
            new CustomEvent("spice-colors/updated", {
              detail: {
                source: "DynamicCatppuccinBridge",
                applied: {
                  accent: accentHex,
                  primary: primaryHex,
                  secondary: secondaryHex
                },
                timestamp: Date.now()
              }
            })
          );
        }
        /**
         * Setup settings change listeners
         */
        setupSettingsListeners() {
          document.addEventListener(
            "year3000SystemSettingsChanged",
            (event) => {
              const customEvent = event;
              const { key, value } = customEvent.detail || {};
              if (key === "catppuccin-accentColor") {
                const isDynamic = String(value) === "dynamic";
                this.integrationConfig.accentUpdateEnabled = isDynamic;
                if (isDynamic && !this.isActive) {
                  this.initialize();
                } else if (!isDynamic && this.isActive) {
                  this.destroy();
                }
                Y3KDebug?.debug?.log(
                  "DynamicCatppuccinBridge",
                  `Accent setting changed to: ${value}, Bridge active: ${this.isActive}`
                );
              }
            }
          );
        }
        /**
         * Initialize current state from existing CSS variables
         * Prioritizes ColorHarmonyEngine variables, then falls back to Catppuccin defaults
         */
        initializeCurrentState() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentAccent = computedStyle.getPropertyValue("--sn-accent-hex").trim() || computedStyle.getPropertyValue("--sn-musical-harmony-primary-hex").trim() || computedStyle.getPropertyValue("--sn-dynamic-accent-hex").trim() || computedStyle.getPropertyValue("--sn-cosmic-accent-hex").trim() || computedStyle.getPropertyValue("--spice-accent").trim();
          if (currentAccent) {
            this.dynamicColorState.currentAccentHex = currentAccent;
            const rgb = this.utils.hexToRgb(currentAccent);
            if (rgb) {
              this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
            }
          }
          const currentBase = computedStyle.getPropertyValue("--sn-cosmic-base-hex").trim() || computedStyle.getPropertyValue("--spice-base").trim() || "#0d1117";
          this.dynamicColorState.baseBackgroundHex = currentBase;
          const baseRgb = this.utils.hexToRgb(currentBase);
          if (baseRgb) {
            this.dynamicColorState.baseBackgroundRgb = `${baseRgb.r},${baseRgb.g},${baseRgb.b}`;
          }
          this.dynamicColorState.lastUpdateTime = Date.now();
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Current state initialized:",
            {
              accent: this.dynamicColorState.currentAccentHex,
              base: this.dynamicColorState.baseBackgroundHex
            }
          );
        }
        /**
         * Handle extracted colors from ColorHarmonyEngine
         */
        handleExtractedColors(extractedColors) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            const newAccentHex = this.selectBestAccentColor(extractedColors);
            if (newAccentHex && newAccentHex !== this.dynamicColorState.currentAccentHex) {
              this.scheduleSmoothAccentTransition(newAccentHex);
            }
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              "Processed extracted colors:",
              {
                input: Object.keys(extractedColors),
                selectedAccent: newAccentHex
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinBridge",
              "Error handling extracted colors:",
              error
            );
          }
        }
        /**
         * Handle harmonized colors (post-processing)
         * Extract accent color from ColorHarmonyEngine and apply it immediately
         */
        handleHarmonizedColors(harmonizedColors) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            const newAccentHex = harmonizedColors["VIBRANT"] || harmonizedColors["PROMINENT"] || harmonizedColors["VIBRANT_NON_ALARMING"] || harmonizedColors["LIGHT_VIBRANT"] || harmonizedColors["PRIMARY"] || Object.values(harmonizedColors)[0];
            if (newAccentHex && newAccentHex !== this.dynamicColorState.currentAccentHex) {
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F3A8} [DynamicCatppuccinBridge] Applying harmonized accent color:",
                  {
                    from: this.dynamicColorState.currentAccentHex,
                    to: newAccentHex,
                    source: "ColorHarmonyEngine harmonized colors"
                  }
                );
              }
              this.scheduleSmoothAccentTransition(newAccentHex);
            }
            this.applyHarmonizedColorsToDynamicSystem(harmonizedColors);
          } catch (error) {
            console.error(
              "\u{1F3A8} [DynamicCatppuccinBridge] Error handling harmonized colors:",
              error
            );
          }
        }
        /**
         * Handle CSS variables applied event from ColorHarmonyEngine
         *  CRITICAL FIX: New handler for colors:applied events
         */
        handleCSSVariablesApplied(cssVariables, accentHex, accentRgb) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            if (accentHex && accentHex !== this.dynamicColorState.currentAccentHex) {
              this.dynamicColorState.currentAccentHex = accentHex;
              this.dynamicColorState.currentAccentRgb = accentRgb;
              this.dynamicColorState.lastUpdateTime = Date.now();
            }
            const enhancedVariables = {};
            const accent = cssVariables["--sn-accent-hex"] || cssVariables["--spice-accent"] || accentHex;
            const accentRgbVar = cssVariables["--sn-accent-rgb"] || cssVariables["--spice-rgb-accent"] || accentRgb;
            if (accent && accentRgbVar) {
              enhancedVariables["--sn-dynamic-accent-hex"] = accent;
              enhancedVariables["--sn-dynamic-accent-rgb"] = accentRgbVar;
              enhancedVariables["--sn-dynamic-primary-hex"] = accent;
              enhancedVariables["--sn-dynamic-primary-rgb"] = accentRgbVar;
              if (Object.keys(enhancedVariables).length > 0) {
                this.cssController.batchSetVariables(
                  "DynamicCatppuccinBridge",
                  enhancedVariables,
                  "critical",
                  // Critical priority for dynamic accent coordination
                  "css-variables-applied-enhancement"
                );
              }
            }
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              "Processed colors:applied event:",
              {
                accentHex: accent,
                accentRgb: accentRgbVar,
                variablesProcessed: Object.keys(cssVariables).length,
                enhancedVariables: Object.keys(enhancedVariables).length
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinBridge",
              "Error handling CSS variables applied:",
              error
            );
          }
        }
        /**
         * Handle music state changes for energy-responsive effects
         */
        handleMusicStateChange(musicState) {
          if (musicState.energy !== void 0) {
            this.dynamicColorState.musicEnergy = musicState.energy;
            if (this.integrationConfig.consciousnessIntegrationEnabled) {
              this.updateConsciousnessWithMusicEnergy(musicState.energy);
            }
          }
        }
        /**
         * Select best accent color from extracted colors
         */
        selectBestAccentColor(colors) {
          const priorities = [
            "VIBRANT_NON_ALARMING",
            // Best for UI - vibrant but not overwhelming
            "VIBRANT",
            // Strong and lively
            "LIGHT_VIBRANT",
            // Lighter variant
            "PROMINENT",
            // Most noticeable color
            "PRIMARY",
            // Primary extracted color
            "DARK_VIBRANT"
            // Darker variant as fallback
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Schedule smooth transition between accent colors
         */
        scheduleSmoothAccentTransition(newAccentHex) {
          if (this.dynamicColorState.transitionInProgress) {
            this.transitionToAccent = newAccentHex;
            return;
          }
          this.transitionFromAccent = this.dynamicColorState.currentAccentHex;
          this.transitionToAccent = newAccentHex;
          this.dynamicColorState.transitionInProgress = true;
          this.lastTransitionStartTime = Date.now();
          this.animateAccentTransition();
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            `Accent transition scheduled: ${this.transitionFromAccent} \u2192 ${newAccentHex}`
          );
        }
        /**
         * Animate smooth accent color transitions
         */
        animateAccentTransition() {
          const animate = /* @__PURE__ */ __name(() => {
            if (!this.dynamicColorState.transitionInProgress) return;
            const elapsed = Date.now() - this.lastTransitionStartTime;
            const progress = Math.min(
              elapsed / this.integrationConfig.smoothTransitionDuration,
              1
            );
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const currentColor = this.interpolateColors(
              this.transitionFromAccent,
              this.transitionToAccent,
              easeProgress
            );
            if (currentColor) {
              this.applyDynamicAccent(currentColor);
            }
            if (progress >= 1) {
              this.dynamicColorState.transitionInProgress = false;
              this.dynamicColorState.currentAccentHex = this.transitionToAccent;
              this.dynamicColorState.lastUpdateTime = Date.now();
              const rgb = this.utils.hexToRgb(this.transitionToAccent);
              if (rgb) {
                this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
              }
              Y3KDebug?.debug?.log(
                "DynamicCatppuccinBridge",
                `Accent transition complete: ${this.transitionToAccent}`
              );
            } else {
              requestAnimationFrame(animate);
            }
          }, "animate");
          requestAnimationFrame(animate);
        }
        /**
         * Interpolate between two hex colors
         */
        interpolateColors(fromHex, toHex, progress) {
          const fromRgb = this.utils.hexToRgb(fromHex);
          const toRgb = this.utils.hexToRgb(toHex);
          if (!fromRgb || !toRgb) return null;
          const r = Math.round(fromRgb.r + (toRgb.r - fromRgb.r) * progress);
          const g = Math.round(fromRgb.g + (toRgb.g - fromRgb.g) * progress);
          const b = Math.round(fromRgb.b + (toRgb.b - fromRgb.b) * progress);
          return this.utils.rgbToHex(r, g, b);
        }
        /**
         * Apply dynamic accent using Color Extension Facade
         * Updates both core Spicetify variables AND consciousness extensions
         */
        applyDynamicAccent(accentHex) {
          console.log("\u{1F3A8} [DynamicCatppuccinBridge] Applying dynamic accent color:", {
            accentHex,
            previousAccent: this.dynamicColorState.currentAccentHex,
            timestamp: Date.now()
          });
          const root = document.documentElement;
          const rgb = this.utils.hexToRgb(accentHex);
          if (!rgb) {
            console.error(
              "\u{1F3A8} [DynamicCatppuccinBridge] Failed to convert accent hex to RGB:",
              accentHex
            );
            return;
          }
          const rgbString = `${rgb.r},${rgb.g},${rgb.b}`;
          const variablesToSet = {
            "--sn-dynamic-accent-hex": accentHex,
            "--sn-dynamic-accent-rgb": rgbString,
            "--sn-dynamic-primary-hex": accentHex,
            "--sn-dynamic-primary-rgb": rgbString,
            "--spice-accent": accentHex,
            "--spice-button": accentHex,
            "--spice-button-active": accentHex,
            "--spice-rgb-accent": rgbString,
            "--spice-rgb-button": rgbString,
            "--sn-color-extracted-primary-rgb": rgbString,
            "--sn-color-extracted-vibrant-rgb": rgbString,
            "--sn-color-extracted-dominant-rgb": rgbString
          };
          console.log(
            "\u{1F3A8} [DynamicCatppuccinBridge] Setting CSS variables:",
            variablesToSet
          );
          this.cssController.batchSetVariables(
            "DynamicCatppuccinBridge",
            variablesToSet,
            "critical",
            // Critical priority for dynamic accent system - highest priority in cascade
            "dynamic-accent-application"
          );
          if (this.integrationConfig.consciousnessIntegrationEnabled) {
            this.updateConsciousnessWithAccent(accentHex, rgbString);
          }
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              `Applied gradient colors: --sn-bg-gradient-primary=${accentHex}, --sn-bg-gradient-primary-rgb=${rgbString}`
            );
          }
        }
        /**
         * Apply harmonized colors to the dynamic system
         */
        applyHarmonizedColorsToDynamicSystem(harmonizedColors) {
          const primaryHex = harmonizedColors.VIBRANT || harmonizedColors.PRIMARY;
          if (primaryHex) {
            if (this.integrationConfig.baseTransformationEnabled) {
              this.updateLivingBaseBackground(primaryHex);
            }
          }
        }
        /**
         * Update consciousness system with new accent awareness
         */
        updateConsciousnessWithAccent(accentHex, accentRgb) {
          const root = document.documentElement;
          const consciousnessAccentVariables = {
            "--organic-holographic-rgb": accentRgb,
            "--holographic-scanline-rgb": accentRgb,
            "--consciousness-intensity": `calc(0.5 + var(--musical-sync-intensity) * ${this.integrationConfig.energyResponseMultiplier})`
          };
          this.cssController.batchSetVariables(
            "DynamicCatppuccinBridge",
            consciousnessAccentVariables,
            "high",
            // High priority for consciousness accent integration
            "consciousness-accent-update"
          );
          if (this.depthConsciousnessController) {
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              "Notifying depth consciousness of accent change"
            );
          }
        }
        /**
         * Update consciousness with music energy
         */
        updateConsciousnessWithMusicEnergy(energy) {
          const root = document.documentElement;
          const adjustedEnergy = energy * this.integrationConfig.energyResponseMultiplier;
          const musicalEnergyVariables = {
            "--musical-sync-intensity": adjustedEnergy.toString(),
            "--holographic-music-flicker-intensity": adjustedEnergy.toString()
          };
          this.cssController.batchSetVariables(
            "DynamicCatppuccinBridge",
            musicalEnergyVariables,
            "high",
            // High priority for musical energy synchronization
            "musical-energy-update"
          );
          const baseIntensity = 0.5;
          const consciousnessIntensity = Math.max(
            0.1,
            Math.min(1, baseIntensity + adjustedEnergy * 0.3)
          );
          this.cssController.setVariable(
            "DynamicCatppuccinBridge",
            "--consciousness-intensity",
            consciousnessIntensity.toString(),
            "high",
            // High priority for consciousness intensity - affects awareness levels
            "consciousness-intensity-update"
          );
        }
        /**
         * Update living base background using Color Extension Facade
         * Preserves Spicetify base while adding consciousness layers
         */
        updateLivingBaseBackground(primaryHex) {
          const root = document.documentElement;
          const primaryRgb = this.utils.hexToRgb(primaryHex);
          if (!primaryRgb) return;
          const primaryRgbString = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          const secondaryColorVariables = {
            "--sn-dynamic-secondary-hex": primaryHex,
            "--sn-dynamic-secondary-rgb": primaryRgbString,
            "--sn-color-extracted-secondary-rgb": primaryRgbString,
            "--sn-color-harmony-complementary-rgb": primaryRgbString
          };
          this.cssController.batchSetVariables(
            "DynamicCatppuccinBridge",
            secondaryColorVariables,
            "high",
            // High priority for secondary color system
            "secondary-color-update"
          );
          const consciousnessGradient = `
      linear-gradient(135deg,
        var(--spice-base) 0%,
        rgba(${primaryRgbString}, 0.08) 30%,
        var(--spice-base) 70%
      ),
      var(--spice-base)
    `;
          const livingGradientVariables = {
            "--living-base-gradient": consciousnessGradient,
            "--consciousness-base-gradient": consciousnessGradient
          };
          this.cssController.batchSetVariables(
            "DynamicCatppuccinBridge",
            livingGradientVariables,
            "normal",
            // Normal priority for living gradient background effects
            "living-gradient-update"
          );
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              `Living base updated: --sn-bg-gradient-secondary=${primaryHex}, --sn-bg-gradient-secondary-rgb=${primaryRgbString}`
            );
          }
        }
        /**
         * Link with other consciousness systems
         */
        linkWithColorHarmonyEngine(engine) {
          this.colorHarmonyEngine = engine;
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Linked with ColorHarmonyEngine"
          );
        }
        linkWithDepthConsciousness(controller) {
          this.depthConsciousnessController = controller;
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Linked with DepthLayerController"
          );
        }
        /**
         * Get current dynamic color state for debugging
         */
        getDynamicColorState() {
          return { ...this.dynamicColorState };
        }
        /**
         * Debug utility: Get current facade variable values
         */
        getFacadeVariableStatus() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          return {
            // Core Spicetify Variables
            spicetifyVars: {
              accent: computedStyle.getPropertyValue("--spice-accent").trim(),
              button: computedStyle.getPropertyValue("--spice-button").trim(),
              rgbAccent: computedStyle.getPropertyValue("--spice-rgb-accent").trim(),
              base: computedStyle.getPropertyValue("--spice-base").trim()
            },
            // Consciousness Extensions
            consciousnessVars: {
              gradientPrimary: computedStyle.getPropertyValue("--sn-bg-gradient-primary-rgb").trim(),
              accentHex: computedStyle.getPropertyValue("--sn-color-accent-hex").trim(),
              accentRgb: computedStyle.getPropertyValue("--sn-color-accent-rgb").trim(),
              extractedPrimary: computedStyle.getPropertyValue("--sn-color-extracted-primary-rgb").trim(),
              livingBaseGradient: computedStyle.getPropertyValue("--living-base-gradient").trim()
            },
            // Configuration Status
            config: {
              dynamicAccentEnabled: this.checkDynamicAccentEnabled(),
              accentUpdateEnabled: this.integrationConfig.accentUpdateEnabled,
              consciousnessEnabled: this.integrationConfig.consciousnessIntegrationEnabled,
              isActive: this.isActive
            }
          };
        }
        /**
         * Update integration configuration
         */
        updateConfig(newConfig) {
          this.integrationConfig = { ...this.integrationConfig, ...newConfig };
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Configuration updated:",
            newConfig
          );
        }
        async healthCheck() {
          const isDynamicEnabled = this.checkDynamicAccentEnabled();
          const hasRecentUpdate = Date.now() - this.dynamicColorState.lastUpdateTime < 3e4;
          return {
            healthy: this.isActive && isDynamicEnabled,
            issues: this.isActive && !isDynamicEnabled ? ["Dynamic accent not enabled in settings"] : [],
            metrics: {
              dynamicAccentEnabled: isDynamicEnabled,
              currentAccent: this.dynamicColorState.currentAccentHex,
              lastUpdateAge: Date.now() - this.dynamicColorState.lastUpdateTime,
              hasRecentUpdate,
              transitionInProgress: this.dynamicColorState.transitionInProgress,
              musicEnergy: this.dynamicColorState.musicEnergy
            }
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.transitionTimer) {
            clearTimeout(this.transitionTimer);
            this.transitionTimer = 0;
          }
          this.dynamicColorState.transitionInProgress = false;
          unifiedEventBus.unsubscribeAll("DynamicCatppuccinBridge");
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Dynamic Catppuccin bridge cleaned up (including UnifiedEventBus subscriptions)"
          );
        }
      };
      __name(_DynamicCatppuccinBridge, "DynamicCatppuccinBridge");
      DynamicCatppuccinBridge = _DynamicCatppuccinBridge;
    }
  });

  // src-js/core/performance/CDFVariableBridge.ts
  var CDFVariableBridge_exports = {};
  __export(CDFVariableBridge_exports, {
    CDFVariableBridge: () => CDFVariableBridge
  });
  var _CDFVariableBridge, CDFVariableBridge;
  var init_CDFVariableBridge = __esm({
    "src-js/core/performance/CDFVariableBridge.ts"() {
      "use strict";
      init_UnifiedEventBus();
      _CDFVariableBridge = class _CDFVariableBridge {
        constructor(batcher) {
          this.batcher = batcher;
          this.reduceMotionMQ = null;
          this._mqHandler = null;
          const subscriptionId = unifiedEventBus.subscribe(
            "performance:frame",
            (data) => {
              const ctx = {
                deltaMs: data.deltaTime || 16.67,
                timestamp: data.timestamp || Date.now(),
                performanceMode: "performance",
                frameBudget: 16.67
              };
              this._handleFrame(ctx);
            },
            "CDFVariableBridge"
          );
          this.unsubscribe = () => unifiedEventBus.unsubscribe(subscriptionId);
          if (typeof window !== "undefined" && window.matchMedia) {
            this.reduceMotionMQ = window.matchMedia(
              "(prefers-reduced-motion: reduce)"
            );
            this._syncReducedMotion(this.reduceMotionMQ.matches);
            this._mqHandler = (e) => {
              this._syncReducedMotion(e.matches);
            };
            try {
              this.reduceMotionMQ.addEventListener("change", this._mqHandler);
            } catch {
              this.reduceMotionMQ.addListener(this._mqHandler);
            }
          }
        }
        destroy() {
          this.unsubscribe?.();
          if (this.reduceMotionMQ && this._mqHandler) {
            try {
              this.reduceMotionMQ.removeEventListener("change", this._mqHandler);
            } catch {
              this.reduceMotionMQ.removeListener(this._mqHandler);
            }
          }
        }
        // -------------------------------------------------------------------------
        // Internal helpers
        // -------------------------------------------------------------------------
        _handleFrame(ctx) {
          if (typeof ctx.scrollRatio === "number") {
            this.batcher.queueCSSVariableUpdate(
              "--sn-cdf-scroll-ratio",
              ctx.scrollRatio.toFixed(3)
            );
            this.batcher.queueCSSVariableUpdate(
              "--sn-scroll-ratio",
              ctx.scrollRatio.toFixed(3)
            );
          }
          if (typeof ctx.beatIntensity === "number") {
            const val = ctx.beatIntensity.toFixed(3);
            this.batcher.queueCSSVariableUpdate("--sn-cdf-energy", val);
            this.batcher.queueCSSVariableUpdate("--sn-beat-intensity", val);
          }
        }
        _syncReducedMotion(reduce) {
          this.batcher.queueCSSVariableUpdate("--sn-cdf-enabled", reduce ? "0" : "1");
        }
      };
      __name(_CDFVariableBridge, "CDFVariableBridge");
      CDFVariableBridge = _CDFVariableBridge;
    }
  });

  // src-js/theme.entry.ts
  init_globalConfig();
  init_year3000System();
  init_UnifiedDebugManager();
  init_Year3000Utilities();

  // src-js/utils/platform/spicetifyReady.ts
  async function waitForSpicetifyReady(timeout = 1e4, checkInterval = 100) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      const spicetify = window.Spicetify;
      if (spicetify?.showNotification && spicetify?.Platform) {
        return true;
      }
      await new Promise((res) => setTimeout(res, checkInterval));
    }
    return false;
  }
  __name(waitForSpicetifyReady, "waitForSpicetifyReady");

  // src-js/visual/ui-effects/Aberration/AberrationManager.ts
  init_OptimizedCSSVariableManager();

  // src-js/visual/ui-effects/Aberration/AberrationCanvas.ts
  var _AberrationCanvas = class _AberrationCanvas {
    constructor(parent, y3k = null) {
      this.parent = parent;
      this.y3k = y3k;
      this.gl = null;
      this.program = null;
      this.tex = null;
      this.strength = 0.4;
      // default; overridden via CSS var
      this.rafId = null;
      this.frameStart = 0;
      this._defaultSize = 256;
      // Bound handlers so we can remove them in destroy()
      this._boundContextLost = /* @__PURE__ */ __name((e) => this._handleContextLost(e), "_boundContextLost");
      this._boundContextRestored = /* @__PURE__ */ __name(() => this._handleContextRestored(), "_boundContextRestored");
      this.canvas = document.createElement("canvas");
      this.canvas.width = this._defaultSize;
      this.canvas.height = this._defaultSize;
      this.canvas.style.width = "100%";
      this.canvas.style.height = "100%";
      Object.assign(this.canvas.style, {
        position: "absolute",
        inset: "0",
        pointerEvents: "none",
        mixBlendMode: "overlay",
        // Changed from "screen" to prevent white bleeding
        zIndex: "-1",
        opacity: "0.6"
        // Reduced opacity to prevent harsh effects
      });
      this.parent.appendChild(this.canvas);
      this.perf = y3k?.performanceAnalyzer ?? null;
      this.canvas.addEventListener(
        "webglcontextlost",
        this._boundContextLost,
        false
      );
      this.canvas.addEventListener(
        "webglcontextrestored",
        this._boundContextRestored,
        false
      );
      this._initGL();
    }
    _initGL() {
      const gl = this.canvas.getContext("webgl", {
        premultipliedAlpha: false,
        alpha: true,
        antialias: false
      });
      if (!gl) {
        console.warn("[AberrationCanvas] WebGL not available \u2013 effect disabled");
        return;
      }
      this.gl = gl;
      const vsSource = `attribute vec2 aPos; varying vec2 vUv; void main(){ vUv = (aPos+1.0)*0.5; gl_Position = vec4(aPos,0.0,1.0); }`;
      const fsSource = `precision mediump float; uniform sampler2D uTex; uniform float uStrength; uniform float uTime; varying vec2 vUv; void main(){ float freq = 8.0; vec2 offset = vec2(sin(vUv.y*freq+uTime)*uStrength, 0.0); vec4 c; c.r = texture2D(uTex, vUv + offset).r; c.g = texture2D(uTex, vUv).g; c.b = texture2D(uTex, vUv - offset).b; c.a = clamp(uStrength * 1.5, 0.0, 0.6); gl_FragColor = c; }`;
      const compile = /* @__PURE__ */ __name((type, src) => {
        const sh = gl.createShader(type);
        gl.shaderSource(sh, src);
        gl.compileShader(sh);
        return sh;
      }, "compile");
      const vs = compile(gl.VERTEX_SHADER, vsSource);
      const fs = compile(gl.FRAGMENT_SHADER, fsSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error("[AberrationCanvas] Shader link failed");
        return;
      }
      this.program = prog;
      gl.useProgram(prog);
      const verts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
      const loc = gl.getAttribLocation(prog, "aPos");
      gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        1,
        1,
        0,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        new Uint8Array([0, 0, 0, 0])
        // Changed from white [255,255,255,255] to transparent [0,0,0,0]
      );
      this.tex = tex;
    }
    /** Public API: update strength via CSS variable (01) */
    setStrength(value) {
      this.strength = value;
    }
    /** Uploads a bitmap (e.g., gradient snapshot) into the shader texture. */
    updateSourceBitmap(bmp) {
      if (!this.gl || !this.tex) return;
      const gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, this.tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bmp);
    }
    /**
     * Public render hook  called by AberrationVisualSystem.onAnimate().
     * All original rendering logic from the private _render loop lives here so
     * that the effect can be orchestrated by MasterAnimationCoordinator.
     */
    render(time) {
      if (!this.gl || !this.program) return;
      const gl = this.gl;
      if (this.perf) this.frameStart = performance.now();
      gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.useProgram(this.program);
      const uTexLoc = gl.getUniformLocation(this.program, "uTex");
      const uStrLoc = gl.getUniformLocation(this.program, "uStrength");
      const uTimeLoc = gl.getUniformLocation(this.program, "uTime");
      gl.uniform1i(uTexLoc, 0);
      gl.uniform1f(uStrLoc, this.strength);
      gl.uniform1f(uTimeLoc, time * 1e-3);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      if (this.perf) {
        const dur = performance.now() - this.frameStart;
        if (dur > 0.5) {
          console.warn(
            `[AberrationCanvas] Frame ${dur.toFixed(2)} ms exceeds 0.5 ms budget`
          );
        }
      }
    }
    destroy() {
      if (this.rafId) cancelAnimationFrame(this.rafId);
      if (this.gl) {
        const lose = this.gl.getExtension("WEBGL_lose_context");
        lose?.loseContext();
      }
      this.canvas.removeEventListener("webglcontextlost", this._boundContextLost);
      this.canvas.removeEventListener(
        "webglcontextrestored",
        this._boundContextRestored
      );
      this.canvas.remove();
    }
    /**
     * Dynamically adjusts the off-screen buffer resolution. Caller should use
     * powers of two (64256) to keep GPU happy. Safe to call every time
     * performance mode toggles  texture & buffers are reused.
     */
    setPixelSize(size) {
      if (size === this.canvas.width) return;
      this.canvas.width = size;
      this.canvas.height = size;
    }
    // 
    // Context-loss life-cycle helpers (Phase-5)
    // 
    _handleContextLost(e) {
      e.preventDefault();
      console.warn("[AberrationCanvas] WebGL context lost \u2013 waiting for restore");
      this.gl = null;
      this.program = null;
    }
    _handleContextRestored() {
      console.info(
        "[AberrationCanvas] WebGL context restored \u2013 re-initializing GL"
      );
      this._initGL();
    }
  };
  __name(_AberrationCanvas, "AberrationCanvas");
  var AberrationCanvas = _AberrationCanvas;

  // src-js/visual/ui-effects/Aberration/AberrationVisualSystem.ts
  var _AberrationVisualSystem = class _AberrationVisualSystem {
    constructor(canvas, perf) {
      this.systemName = "AberrationCanvas";
      this._elapsed = 0;
      this._canvas = canvas;
      this._perf = perf;
    }
    /* --------------------------------------------------------------- */
    /* MasterAnimationCoordinator hooks                                */
    /* --------------------------------------------------------------- */
    /**
     * Called by the coordinator every frame (subject to frame budgeting).
     * @param deltaMs Time in milliseconds since last call.
     * @param _context Shared FrameContext from VisualSystemRegistry (unused for now).
     */
    onAnimate(deltaMs, _context) {
      this._elapsed += deltaMs;
      let start = 0;
      if (this._perf) start = this._perf.startTiming("AberrationVisualSystem");
      this._canvas.render(this._elapsed);
      if (this._perf && start) {
        this._perf.endTiming("AberrationVisualSystem", start);
      }
    }
    /**
     * Optional hook  will be invoked when MAC toggles performance modes.
     * We keep it for future Phase-2 improvements (dynamic resolution scaling).
     */
    onPerformanceModeChange(mode) {
      if (mode === "performance") {
        this._canvas.setPixelSize(128);
        this._canvas.setStrength(0.25);
      } else {
        this._canvas.setPixelSize(256);
        this._canvas.setStrength(0.4);
      }
    }
    /* --------------------------------------------------------------- */
    /* Lifecycle helpers                                               */
    /* --------------------------------------------------------------- */
    destroy() {
      this._canvas.destroy();
    }
  };
  __name(_AberrationVisualSystem, "AberrationVisualSystem");
  var AberrationVisualSystem = _AberrationVisualSystem;

  // src-js/utils/dom/getScrollNode.ts
  var SCROLL_NODE_SELECTORS = [
    ".main-view-container__scroll-node",
    // 2023-era builds
    ".main-viewContainer-scrollNode",
    // 2024 dash variant
    ".main-viewContainer__scrollNode"
    // 2024 double-underscore variant
  ].join(", ");
  function getScrollNode() {
    return document.querySelector(SCROLL_NODE_SELECTORS);
  }
  __name(getScrollNode, "getScrollNode");

  // src-js/visual/ui-effects/Aberration/AberrationManager.ts
  var instance = null;
  var visualSystem = null;
  function getCSSController(y3k) {
    const year3000System2 = y3k || globalThis.year3000System;
    return year3000System2?.cssConsciousnessController || getGlobalOptimizedCSSController();
  }
  __name(getCSSController, "getCSSController");
  function isAberrationEnabled() {
    return false;
  }
  __name(isAberrationEnabled, "isAberrationEnabled");
  function attach(y3k) {
    if (!isAberrationEnabled()) {
      setNebulaNoiseEnabled(false, y3k);
      setCSSAberrationEnabled(false, y3k);
      return;
    }
    const node = getScrollNode();
    if (!node) return;
    if (instance && instance.parent === node) return;
    instance?.destroy();
    instance = new AberrationCanvas(node, y3k);
    if (window.__SN_DEBUG_ABERRATION) {
      console.log("[AberrationManager] canvas attached", node);
    }
    setNebulaNoiseEnabled(true, y3k);
    setCSSAberrationEnabled(true, y3k);
    if (y3k && instance) {
      visualSystem = new AberrationVisualSystem(
        instance,
        y3k.performanceAnalyzer || void 0
      );
      y3k?.registerVisualSystem?.(visualSystem, "critical");
      console.log("[AberrationManager] AberrationCanvas attached");
    }
  }
  __name(attach, "attach");
  function setNebulaNoiseEnabled(enabled, y3k) {
    const cssController = getCSSController(y3k);
    cssController.setVariable(
      "AberrationManager",
      "--sn-nebula-noise-opacity",
      enabled ? "0.03" : "0",
      "normal",
      // Normal priority for nebula noise overlay
      "nebula-noise-toggle"
    );
  }
  __name(setNebulaNoiseEnabled, "setNebulaNoiseEnabled");
  function setCSSAberrationEnabled(enabled, y3k) {
    const variables = {
      "--aberration-webgl-active": enabled ? "1" : "0",
      "--aberration-css-enabled": enabled ? "1" : "0",
      "--aberration-hybrid-mode": enabled ? "1" : "0"
    };
    const cssController = getCSSController(y3k);
    cssController.batchSetVariables(
      "AberrationManager",
      variables,
      "normal",
      // Normal priority for CSS aberration effects
      "css-aberration-toggle"
    );
  }
  __name(setCSSAberrationEnabled, "setCSSAberrationEnabled");
  function initializeAberrationManager(y3k = null) {
    attach(y3k);
    if (!instance) {
      setNebulaNoiseEnabled(false, y3k);
      setCSSAberrationEnabled(false, y3k);
    }
    const history = window.Spicetify?.Platform?.History;
    if (history?.listen) {
      history.listen(() => setTimeout(() => attach(y3k), 0));
    }
    document.addEventListener("spicetify:appchange", () => attach(y3k));
    const observer = new MutationObserver(() => {
      if (!instance) {
        attach(y3k);
        if (!instance) {
          setNebulaNoiseEnabled(false, y3k);
          setCSSAberrationEnabled(false, y3k);
        }
      } else {
        observer.disconnect();
      }
    });
    observer.observe(document.documentElement, {
      childList: true,
      subtree: true
    });
    document.addEventListener("year3000SystemSettingsChanged", (e) => {
      const { key, value } = e.detail || {};
      if (key === "sn-enable-aberration") {
        const enable = value === "true";
        if (enable && !instance) {
          attach(y3k);
        } else if (!enable && instance) {
          instance.destroy();
          instance = null;
          y3k?.unregisterAnimationSystem("AberrationCanvas");
          visualSystem?.destroy();
          visualSystem = null;
          console.log("[AberrationManager] AberrationCanvas detached");
        }
        setNebulaNoiseEnabled(enable && !!instance, y3k);
        setCSSAberrationEnabled(enable && !!instance, y3k);
      }
      if (key === "sn-nebula-aberration-strength") {
        const num = parseFloat(value);
        if (!Number.isNaN(num) && instance) {
          instance.setStrength(num);
        }
        const cssController = getCSSController(y3k);
        cssController.setVariable(
          "AberrationManager",
          "--sn-nebula-aberration-strength",
          String(value),
          "normal",
          // Normal priority for strength settings
          "aberration-strength-update"
        );
      }
    });
  }
  __name(initializeAberrationManager, "initializeAberrationManager");

  // src-js/visual/ui-effects/AudioVisualController.ts
  init_OptimizedCSSVariableManager();
  init_UnifiedEventBus();

  // src-js/utils/platform/UserHistory.ts
  var LS_KEY = "sn_seen_genres_v1";
  var _UserGenreHistory = class _UserGenreHistory {
    constructor() {
      const raw = typeof localStorage !== "undefined" ? localStorage.getItem(LS_KEY) : null;
      this.seen = new Set(raw ? JSON.parse(raw) : []);
    }
    hasSeen(genre) {
      return this.seen.has(genre.toLowerCase());
    }
    markSeen(genre) {
      const key = genre.toLowerCase();
      if (!this.seen.has(key)) {
        this.seen.add(key);
        this._persist();
      }
    }
    _persist() {
      try {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(LS_KEY, JSON.stringify([...this.seen]));
        }
      } catch (_e) {
      }
    }
  };
  __name(_UserGenreHistory, "UserGenreHistory");
  var UserGenreHistory = _UserGenreHistory;

  // src-js/visual/ui-effects/AudioVisualController.ts
  function median(values) {
    if (!values.length) return 0;
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 !== 0) {
      return sorted[mid] ?? 0;
    }
    const lower = sorted[mid - 1] ?? 0;
    const upper = sorted[mid] ?? 0;
    return (lower + upper) / 2;
  }
  __name(median, "median");
  var _AudioVisualController = class _AudioVisualController {
    constructor(y3k = null, cssController, perf) {
      // Core systems
      this.perf = null;
      // Event management
      this.unsubscribers = [];
      // Performance tracking
      this.frameDurations = [];
      // rolling window for medians
      // Configuration
      this.enabled = true;
      this.intensitySetting = "balanced";
      this.intensityFactor = 1;
      // State management
      this.genreHistory = new UserGenreHistory();
      this.activeGlowTimeout = null;
      this.interactionOffHandler = null;
      this.year3000System = y3k;
      this.cssController = cssController ?? y3k?.cssConsciousnessController ?? getGlobalOptimizedCSSController();
      this.perf = perf ? perf : y3k?.performanceAnalyzer ?? null;
      const prefersReducedMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;
      const capabilityOverall = y3k?.deviceCapabilityDetector?.deviceCapabilities?.overall;
      const settings2 = y3k?.settingsManager;
      if (settings2) {
        this.intensitySetting = settings2.get("sn-gradient-intensity") ?? "balanced";
      }
      switch (this.intensitySetting) {
        case "disabled":
          this.enabled = false;
          break;
        case "minimal":
          this.intensityFactor = 0.6;
          break;
        case "balanced":
          this.intensityFactor = 1;
          break;
        case "intense":
          this.intensityFactor = 1.4;
          break;
      }
      if (prefersReducedMotion || capabilityOverall === "low") {
        this.enabled = false;
      }
      if (this.enabled) {
        this._subscribe();
      } else {
        this.cssController.setVariable(
          "AudioVisualController",
          "--sn-nebula-beat-intensity",
          "0",
          "low",
          "disabled-initialization"
        );
      }
    }
    _subscribe() {
      const subscriptionIds = [
        unifiedEventBus.subscribe("music:beat", (data) => {
          this._handleBeat({
            energy: data.intensity,
            bpm: data.bpm
          });
        }, "AudioVisualController"),
        unifiedEventBus.subscribe("music:track-changed", (data) => {
          this._handleGenreChange({
            genre: "unknown"
            // Could be enhanced with actual genre detection
          });
        }, "AudioVisualController"),
        unifiedEventBus.subscribe("user:scroll", (data) => {
          this._handleScroll({
            velocity: data.velocity?.x || data.velocity?.y || 0,
            direction: data.direction === "up" ? "up" : "down"
          });
        }, "AudioVisualController")
      ];
      this.unsubscribers = subscriptionIds.map((id) => () => unifiedEventBus.unsubscribe(id));
    }
    // ---------------------------------------------------------------------------
    // Event Handlers  all lightweight calculations to stay under 2 ms median.
    // ---------------------------------------------------------------------------
    _handleBeat(payload) {
      const t0 = performance.now();
      const safeEnergy = typeof payload.energy === "number" ? payload.energy : 0.5;
      const intensity = (0.8 + Math.min(Math.max(safeEnergy, 0), 1) * 0.6) * this.intensityFactor;
      this._queueVar(
        "--sn-nebula-beat-intensity",
        intensity.toFixed(3),
        "high",
        "beat-sync"
      );
      const aberrationStrength = (safeEnergy * 0.6).toFixed(3);
      this._queueVar(
        "--sn-nebula-aberration-strength",
        aberrationStrength,
        "normal",
        "beat-aberration"
      );
      this._recordDuration(t0);
    }
    _handleGenreChange(payload) {
      const t0 = performance.now();
      if (this.genreHistory.hasSeen(payload.genre)) {
        return;
      }
      this.genreHistory.markSeen(payload.genre);
      const cueOpacity = 0.18 * this.intensityFactor;
      this._queueVar(
        "--sn-nebula-layer-0-opacity",
        cueOpacity.toFixed(3),
        "high",
        "genre-discovery"
      );
      const clearCue = /* @__PURE__ */ __name(() => {
        if (this.year3000System?.timerConsolidationSystem) {
          this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer(
            "AudioVisualController-glowTimeout"
          );
        } else if (this.activeGlowTimeout) {
          clearTimeout(this.activeGlowTimeout);
          this.activeGlowTimeout = null;
        }
        this._queueVar(
          "--sn-nebula-layer-0-opacity",
          "0.05",
          "normal",
          "genre-clear"
        );
        if (this.interactionOffHandler) {
          document.removeEventListener("pointerdown", this.interactionOffHandler);
          document.removeEventListener("keydown", this.interactionOffHandler);
          this.interactionOffHandler = null;
        }
      }, "clearCue");
      if (this.year3000System?.timerConsolidationSystem) {
        this.year3000System.timerConsolidationSystem.registerConsolidatedTimer(
          "AudioVisualController-glowTimeout",
          clearCue,
          4e3,
          "normal"
        );
        this.activeGlowTimeout = null;
      } else {
        this.activeGlowTimeout = setTimeout(clearCue, 4e3);
      }
      this.interactionOffHandler = () => clearCue();
      document.addEventListener("pointerdown", this.interactionOffHandler, {
        once: true
      });
      document.addEventListener("keydown", this.interactionOffHandler, {
        once: true
      });
      this._queueVar(
        "--sn-nebula-ease-t",
        "1",
        "normal",
        "ease-trigger"
      );
      this._recordDuration(t0);
    }
    _handleScroll(payload) {
      const t0 = performance.now();
      const safeVel = typeof payload.velocity === "number" ? payload.velocity : 0;
      const vel = Math.min(Math.abs(safeVel), 50);
      const blurBoost = vel / 50 * 2 * this.intensityFactor;
      this._queueVar(
        "--sn-nebula-layer-3-blur",
        `calc(var(--sn-depth-layer-3-blur) + ${blurBoost.toFixed(2)}px)`,
        "normal",
        "scroll-blur"
      );
      const baseScaleY = 150;
      let clampedVel = Math.max(Math.min(payload.velocity ?? 0, 50), -50);
      const deltaScale = clampedVel / 50 * 50;
      const noiseScale = Math.max(140, Math.min(200, baseScaleY + deltaScale));
      this._queueVar(
        "--sn-nebula-noise-scale-y",
        `${noiseScale.toFixed(1)}%`,
        "normal",
        "scroll-noise"
      );
      this._recordDuration(t0);
    }
    // ---------------------------------------------------------------------------
    // Helpers
    // ---------------------------------------------------------------------------
    _queueVar(prop, value, priority = "normal", source = "audio-visual") {
      if (!this.enabled) return;
      this.cssController.setVariable(
        "AudioVisualController",
        prop,
        value,
        priority,
        source
      );
    }
    _recordDuration(start) {
      const duration = performance.now() - start;
      this.frameDurations.push(duration);
      if (this.frameDurations.length > _AudioVisualController.FRAME_HISTORY) {
        this.frameDurations.shift();
      }
      if (this.frameDurations.length === _AudioVisualController.FRAME_HISTORY) {
        const med = median(this.frameDurations);
        if (med > 2) {
          console.warn(
            `[AudioVisualController] Median scripting cost ${med.toFixed(
              2
            )} ms exceeds 2 ms budget.`
          );
          this._queueVar(
            "--sn-nebula-blend-mode",
            "screen",
            "critical",
            "performance-fallback"
          );
        }
      }
    }
    destroy() {
      if (this.year3000System?.timerConsolidationSystem) {
        this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer(
          "AudioVisualController-glowTimeout"
        );
      }
      if (this.activeGlowTimeout) {
        clearTimeout(this.activeGlowTimeout);
        this.activeGlowTimeout = null;
      }
      if (this.interactionOffHandler) {
        document.removeEventListener("pointerdown", this.interactionOffHandler);
        document.removeEventListener("keydown", this.interactionOffHandler);
        this.interactionOffHandler = null;
      }
      this.unsubscribers.forEach((u) => u());
      this.unsubscribers = [];
    }
  };
  __name(_AudioVisualController, "AudioVisualController");
  _AudioVisualController.FRAME_HISTORY = 120;
  var AudioVisualController = _AudioVisualController;
  function initializeAudioVisualController(y3k = null) {
    const g = globalThis;
    if (g.__SN_audioVisualController)
      return g.__SN_audioVisualController;
    const instance2 = new AudioVisualController(y3k);
    g.__SN_audioVisualController = instance2;
    return instance2;
  }
  __name(initializeAudioVisualController, "initializeAudioVisualController");

  // src-js/theme.entry.ts
  async function waitForAPI(apiPath, timeout = 5e3) {
    const start = Date.now();
    let lastError = null;
    let attemptCount = 0;
    while (Date.now() - start < timeout) {
      attemptCount++;
      try {
        const api = apiPath.split(".").reduce((obj, prop) => obj?.[prop], window);
        if (api) {
          console.log(
            `\u2705 [StarryNight] API ${apiPath} available after ${attemptCount} attempts (${Date.now() - start}ms)`
          );
          return api;
        }
      } catch (e) {
        lastError = e;
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    console.warn(
      `\u274C [StarryNight] API ${apiPath} timeout after ${timeout}ms (${attemptCount} attempts)`
    );
    if (lastError) {
      console.warn(
        `\u274C [StarryNight] Last error for ${apiPath}:`,
        lastError.message
      );
    }
    const pathParts = apiPath.split(".");
    let currentObj = window;
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      if (!part || !currentObj || typeof currentObj !== "object" || currentObj[part] === void 0) {
        console.warn(
          `\u274C [StarryNight] API path ${apiPath} breaks at '${part}' (step ${i + 1}/${pathParts.length})`
        );
        break;
      }
      currentObj = currentObj[part];
    }
    return null;
  }
  __name(waitForAPI, "waitForAPI");
  async function waitForDOMElement(selector, timeout = 5e3) {
    const start = Date.now();
    let attemptCount = 0;
    while (Date.now() - start < timeout) {
      attemptCount++;
      try {
        const element = document.querySelector(selector);
        if (element) {
          console.log(
            `\u2705 [StarryNight] DOM element '${selector}' found after ${attemptCount} attempts (${Date.now() - start}ms)`
          );
          return element;
        }
      } catch (e) {
        console.warn(`\u274C [StarryNight] DOM query error for '${selector}':`, e);
      }
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
    console.warn(
      `\u274C [StarryNight] DOM element '${selector}' not found after ${timeout}ms (${attemptCount} attempts)`
    );
    return null;
  }
  __name(waitForDOMElement, "waitForDOMElement");
  async function waitForCatppuccinTheme(timeout = 5e3) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      try {
        const rootStyle = getComputedStyle(document.documentElement);
        const baseColor = rootStyle.getPropertyValue("--spice-base").trim();
        const accentColor = rootStyle.getPropertyValue("--spice-accent").trim();
        const textColor = rootStyle.getPropertyValue("--spice-text").trim();
        const isValidColor = /* @__PURE__ */ __name((color3) => {
          const normalized = color3.toLowerCase();
          return color3 && !normalized.includes("#ffffff") && !normalized.includes("#fff") && !normalized.includes("white") && normalized.match(/^#[0-9a-f]{6}$/i);
        }, "isValidColor");
        if (isValidColor(baseColor) && isValidColor(accentColor) && isValidColor(textColor)) {
          console.log(
            `\u{1F3A8} [StarryNight] Catppuccin theme loaded: base=${baseColor}, accent=${accentColor}, text=${textColor}`
          );
          return true;
        }
        console.log(
          `\u{1F3A8} [StarryNight] Waiting for Catppuccin theme... (base=${baseColor}, accent=${accentColor})`
        );
      } catch (e) {
      }
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
    console.warn(
      `\u{1F3A8} [StarryNight] Catppuccin theme not fully loaded after ${timeout}ms - proceeding with fallbacks`
    );
    return false;
  }
  __name(waitForCatppuccinTheme, "waitForCatppuccinTheme");
  function patchReactRequire() {
    const g = globalThis;
    if (g.__STARLIGHT_REACT_SHIM__) return;
    const shim = /* @__PURE__ */ __name((name) => {
      if (name === "react") return g.Spicetify?.React;
      if (name === "react-dom") return g.Spicetify?.ReactDOM;
      throw new Error(`[StarryNight shim] Module '${name}' not available`);
    }, "shim");
    if (typeof g.require === "function") {
      const original = g.require.bind(g);
      g.require = (name) => {
        if (name === "react" || name === "react-dom") return shim(name);
        return original(name);
      };
    } else {
      g.require = shim;
    }
    g.__STARLIGHT_REACT_SHIM__ = true;
  }
  __name(patchReactRequire, "patchReactRequire");
  patchReactRequire();
  (/* @__PURE__ */ __name(async function catppuccinStarryNight() {
    const startTime = Date.now();
    console.log("\u{1F31F} [Catppuccin StarryNight] Theme entry point starting...");
    const spicetifyReady = await waitForSpicetifyReady(1e4);
    if (!spicetifyReady) {
      console.error(
        "\u274C [StarryNight] CRITICAL: Spicetify not fully ready after 10s \u2013 proceeding with degraded visual-only mode."
      );
      console.error("\u274C [StarryNight] Available Spicetify objects:", {
        Spicetify: !!window.Spicetify,
        showNotification: !!window.Spicetify?.showNotification,
        Platform: !!window.Spicetify?.Platform
      });
    } else {
      console.log("\u2705 [StarryNight] Spicetify platform fully ready");
    }
    const themeReady = await waitForCatppuccinTheme(8e3);
    if (!themeReady) {
      console.error(
        "\u274C [StarryNight] CRITICAL: Catppuccin theme not fully loaded after 8s \u2013 may experience color issues"
      );
      const rootStyle = getComputedStyle(document.documentElement);
      console.error("\u274C [StarryNight] Current CSS variables:", {
        base: rootStyle.getPropertyValue("--spice-base").trim(),
        accent: rootStyle.getPropertyValue("--spice-accent").trim(),
        text: rootStyle.getPropertyValue("--spice-text").trim()
      });
    } else {
      console.log("\u2705 [StarryNight] Catppuccin theme fully loaded");
    }
    const requiredAPIs = {
      player: await waitForAPI("Spicetify.Player", 3e3),
      platform: await waitForAPI("Spicetify.Platform", 3e3),
      menu: await waitForAPI("Spicetify.Menu", 2e3),
      react: await waitForAPI("Spicetify.React", 2e3),
      reactDOM: await waitForAPI("Spicetify.ReactDOM", 2e3)
    };
    const mainContainerSelectors = [
      ".main-viewContainer-scrollNode",
      ".main-view-container__scroll-node-child",
      ".main-view-container",
      ".main-container",
      "#main",
      "[data-testid='main-container']"
    ];
    let mainContainer = null;
    for (const selector of mainContainerSelectors) {
      mainContainer = await waitForDOMElement(selector, 1e3);
      if (mainContainer) {
        console.log(
          `\u2705 [StarryNight] Found main container using selector: ${selector}`
        );
        break;
      }
    }
    if (mainContainer) {
      console.log(
        "\u2705 [StarryNight] Enhanced UI features initialized with DOM container"
      );
    } else {
      console.warn(
        "\u26A0\uFE0F [StarryNight] No suitable main container found - enhanced UI features disabled"
      );
      console.warn(
        "\u26A0\uFE0F [StarryNight] Tried selectors:",
        mainContainerSelectors.join(", ")
      );
      console.warn(
        "\u26A0\uFE0F [StarryNight] Core functionality (music sync, color extraction) will still work"
      );
    }
    const hasRequiredAPIs = requiredAPIs.player && requiredAPIs.platform;
    const degradedMode = !hasRequiredAPIs;
    if (degradedMode) {
      console.error(
        "\u274C [StarryNight] DEGRADED MODE: Initializing with limited functionality due to missing APIs"
      );
      console.error("\u274C [StarryNight] API availability status:", {
        player: !!requiredAPIs.player,
        platform: !!requiredAPIs.platform,
        menu: !!requiredAPIs.menu,
        react: !!requiredAPIs.react,
        reactDOM: !!requiredAPIs.reactDOM,
        mainContainer: !!mainContainer + " (optional)"
      });
      console.error("\u274C [StarryNight] DEGRADED MODE limitations:");
      console.error("  - Music synchronization disabled");
      console.error("  - Advanced visual effects may not function");
      console.error("  - UI integration features disabled");
      console.error("  - Color extraction from album art disabled");
    } else {
      console.log(
        "\u2705 [StarryNight] FULL MODE: All required APIs available - initializing complete functionality"
      );
    }
    const ENABLE_GLOBAL_DEBUGGING = true;
    if (ENABLE_GLOBAL_DEBUGGING) {
      YEAR3000_CONFIG.enableDebug = true;
      Promise.resolve().then(() => (init_DragCartographer(), DragCartographer_exports)).then((m) => {
        m.enableDragCartography?.();
        window.getDragMap = m.getDragMap;
      });
    }
    const year3000System2 = new Year3000System(YEAR3000_CONFIG);
    try {
      if (degradedMode) {
        await year3000System2.initializeWithAvailableAPIs({
          player: requiredAPIs.player,
          platform: requiredAPIs.platform,
          config: window.Spicetify?.Config,
          degradedMode: true
        });
        console.log(
          "\u{1F31F} [StarryNight] Initialized in degraded mode - visual systems only"
        );
        setupProgressiveEnhancement(year3000System2, requiredAPIs);
      } else {
        await year3000System2.initializeAllSystems();
        year3000System2.setupMusicAnalysisAndColorExtraction();
        console.log("\u{1F31F} [StarryNight] Full initialization complete");
        try {
          initializeAudioVisualController(year3000System2);
          initializeAberrationManager(year3000System2);
          Promise.resolve().then(() => (init_EnhancedDragPreview(), EnhancedDragPreview_exports)).then(
            (m) => m.enableEnhancedDragPreview?.()
          );
          Promise.resolve().then(() => (init_QuickAddRadialMenu(), QuickAddRadialMenu_exports)).then(
            (m) => m.enableQuickAddRadialMenu?.()
          );
          if (mainContainer) {
            Promise.resolve().then(() => (init_prismaticScrollSheen(), prismaticScrollSheen_exports)).then(
              (m) => m.initializePrismaticScrollSheen?.()
            );
          }
          console.log("\u{1F31F} [StarryNight] UI controllers initialized successfully");
        } catch (uiError) {
          console.error("[StarryNight] UI controller initialization failed:", uiError);
        }
      }
    } catch (error) {
      console.error("[StarryNight] System initialization failed:", error);
    }
    try {
      if (requiredAPIs.react && requiredAPIs.reactDOM) {
        const settingsUiModule = await Promise.resolve().then(() => (init_StarryNightSettings(), StarryNightSettings_exports));
        await settingsUiModule.initializeStarryNightSettings?.();
        console.log(
          "\u{1F31F} [StarryNight] Spicetify native settings with Year3000System integration initialized"
        );
      } else {
        console.warn(
          "\u{1F31F} [StarryNight] React APIs not available - continuing with CSS-only theme"
        );
      }
    } catch (e) {
      console.error("[StarryNight] Failed to initialize native settings:", e);
      console.warn(
        "\u{1F31F} [StarryNight] Continuing with CSS-only theme (no settings UI)"
      );
    }
    if (YEAR3000_CONFIG.enableDebug) {
      window.Y3K = {
        system: year3000System2,
        // Expose internal modules for easier debugging
        music: year3000System2.musicSyncService,
        settings: year3000System2.settingsManager,
        // Expose the superior, specialized debug tools directly
        debug: Y3KDebug.debug,
        health: year3000System2.systemHealthMonitor,
        // Add degraded mode info
        mode: degradedMode ? "degraded" : "full",
        availableAPIs: requiredAPIs
      };
    }
    try {
      const { RightSidebarConsciousnessSystem: RightSidebarConsciousnessSystem2 } = await Promise.resolve().then(() => (init_RightSidebarVisualEffects(), RightSidebarVisualEffects_exports));
      const { SidebarPerformanceCoordinator: SidebarPerformanceCoordinator2 } = await Promise.resolve().then(() => (init_SidebarPerformanceCoordinator(), SidebarPerformanceCoordinator_exports));
      if (year3000System2.performanceAnalyzer) {
        const coordinator = SidebarPerformanceCoordinator2.getInstance({
          enableDebug: YEAR3000_CONFIG.enableDebug,
          performanceAnalyzer: year3000System2.performanceAnalyzer,
          onFlushComplete: /* @__PURE__ */ __name(() => {
            year3000System2.performanceAnalyzer?.emitTrace?.(
              "[SidebarPerformanceCoordinator] Flush completed"
            );
          }, "onFlushComplete")
        });
        coordinator.setupDOMObservation();
        const rsSystem = new RightSidebarConsciousnessSystem2(
          YEAR3000_CONFIG,
          Year3000Utilities_exports,
          year3000System2.performanceAnalyzer,
          year3000System2.musicSyncService,
          year3000System2.settingsManager,
          year3000System2,
          coordinator
        );
        await rsSystem.initialize();
        year3000System2.rightSidebarConsciousnessSystem = rsSystem;
        year3000System2.rightSidebarCoordinator = coordinator;
      }
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize RightSidebarConsciousnessSystem",
        err
      );
    }
    try {
      const { DepthConsciousnessController: DepthConsciousnessController2 } = await Promise.resolve().then(() => (init_DepthLayerController(), DepthLayerController_exports));
      const depthConsciousness = new DepthConsciousnessController2(
        YEAR3000_CONFIG,
        Year3000Utilities_exports,
        year3000System2.performanceAnalyzer,
        year3000System2.musicSyncService,
        year3000System2.settingsManager
      );
      await depthConsciousness.initialize();
      year3000System2.depthConsciousnessController = depthConsciousness;
      console.log("\u{1F30A} [StarryNight] Depth Consciousness Controller awakened");
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize DepthConsciousnessController",
        err
      );
    }
    try {
      const { DynamicCatppuccinBridge: DynamicCatppuccinBridge2 } = await Promise.resolve().then(() => (init_DynamicCatppuccinBridge(), DynamicCatppuccinBridge_exports));
      const dynamicBridge = new DynamicCatppuccinBridge2(
        YEAR3000_CONFIG,
        Year3000Utilities_exports,
        year3000System2.performanceAnalyzer,
        year3000System2.musicSyncService,
        year3000System2.settingsManager
      );
      await dynamicBridge.initialize();
      if (year3000System2.colorHarmonyEngine) {
        dynamicBridge.linkWithColorHarmonyEngine(
          year3000System2.colorHarmonyEngine
        );
      }
      if (year3000System2.depthConsciousnessController) {
        dynamicBridge.linkWithDepthConsciousness(
          year3000System2.depthConsciousnessController
        );
      }
      year3000System2.dynamicCatppuccinBridge = dynamicBridge;
      console.log("\u{1F3A8} [StarryNight] Dynamic Catppuccin Bridge connected");
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize DynamicCatppuccinBridge",
        err
      );
    }
    try {
      const { LivingGradientStrategy: LivingGradientStrategy2 } = await Promise.resolve().then(() => (init_LivingGradientStrategy(), LivingGradientStrategy_exports));
      const livingGradientSystem = new LivingGradientStrategy2(
        YEAR3000_CONFIG,
        Year3000Utilities_exports,
        year3000System2.performanceAnalyzer,
        year3000System2.musicSyncService,
        year3000System2.settingsManager
      );
      await livingGradientSystem.initialize();
      if (year3000System2.dynamicCatppuccinBridge) {
        console.log(
          "\u{1F30A} [StarryNight] Consolidated Living Gradient System linked with Dynamic Catppuccin Bridge"
        );
      }
      if (year3000System2.depthConsciousnessController) {
        console.log(
          "\u{1F30A} [StarryNight] Consolidated Living Gradient System linked with Depth Consciousness"
        );
      }
      year3000System2.livingGradientSystem = livingGradientSystem;
      year3000System2.livingGradientStrategy = livingGradientSystem;
      console.log(
        "\u{1F30A} [StarryNight] Consolidated Living Gradient Strategy System awakened - unified color processing and visual system lifecycle with performance optimizations"
      );
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize Consolidated Living Gradient Strategy System",
        err
      );
    }
    try {
      const { CDFVariableBridge: CDFVariableBridge2 } = await Promise.resolve().then(() => (init_CDFVariableBridge(), CDFVariableBridge_exports));
      if (year3000System2.cssConsciousnessController) {
        new CDFVariableBridge2(year3000System2.cssConsciousnessController);
      }
    } catch (err) {
      console.error("[StarryNight] Failed to initialize CDFVariableBridge", err);
    }
    const initTime = Date.now() - startTime;
    console.log(
      `\u{1F30C} Catppuccin StarryNight Theme initialized in ${initTime}ms (${degradedMode ? "degraded" : "full"} mode). Welcome to the future of sound!`
    );
  }, "catppuccinStarryNight"))();
  function setupProgressiveEnhancement(year3000System2, requiredAPIs) {
    console.log(
      "\u{1F504} [StarryNight] Setting up progressive enhancement monitoring..."
    );
    let upgradeAttempts = 0;
    const maxUpgradeAttempts = 30;
    const upgradeCheckInterval = 1e4;
    const checkForUpgrade = /* @__PURE__ */ __name(() => {
      upgradeAttempts++;
      const currentAPIs = {
        player: window.Spicetify?.Player,
        platform: window.Spicetify?.Platform,
        menu: window.Spicetify?.Menu,
        react: window.Spicetify?.React,
        reactDOM: window.Spicetify?.ReactDOM
      };
      const hasRequiredAPIs = currentAPIs.player && currentAPIs.platform;
      if (hasRequiredAPIs) {
        console.log(
          "\u2705 [StarryNight] Required APIs now available - upgrading to full mode!"
        );
        clearInterval(upgradeInterval);
        upgradeToFullMode(year3000System2, currentAPIs).then(() => {
          console.log(
            "\u{1F31F} [StarryNight] Successfully upgraded from degraded mode to full mode!"
          );
          if (window.Y3K) {
            window.Y3K.mode = "full";
            window.Y3K.availableAPIs = currentAPIs;
          }
        }).catch((error) => {
          console.error(
            "\u274C [StarryNight] Failed to upgrade to full mode:",
            error
          );
        });
        return;
      }
      if (upgradeAttempts >= maxUpgradeAttempts) {
        console.log(
          `\u23F0 [StarryNight] Progressive enhancement monitoring ended after ${upgradeAttempts} attempts (${upgradeAttempts * upgradeCheckInterval / 1e3}s)`
        );
        clearInterval(upgradeInterval);
        return;
      }
      if (upgradeAttempts % 5 === 0) {
        console.log(
          `\u{1F504} [StarryNight] Still monitoring for API availability... (attempt ${upgradeAttempts}/${maxUpgradeAttempts})`
        );
        console.log("\u{1F504} [StarryNight] Current API status:", {
          player: !!currentAPIs.player,
          platform: !!currentAPIs.platform,
          menu: !!currentAPIs.menu,
          react: !!currentAPIs.react,
          reactDOM: !!currentAPIs.reactDOM
        });
      }
    }, "checkForUpgrade");
    const upgradeInterval = setInterval(checkForUpgrade, upgradeCheckInterval);
    const spicetifyReadyHandler = /* @__PURE__ */ __name(() => {
      console.log(
        "\u{1F3B5} [StarryNight] Spicetify ready event detected - checking for upgrade..."
      );
      checkForUpgrade();
    }, "spicetifyReadyHandler");
    if (window.Spicetify) {
      if (window.Spicetify.Player) {
        window.Spicetify.Player.addEventListener?.(
          "songchange",
          spicetifyReadyHandler
        );
      }
    }
    setTimeout(() => {
      if (window.Spicetify?.Player) {
        window.Spicetify.Player.removeEventListener?.(
          "songchange",
          spicetifyReadyHandler
        );
      }
    }, maxUpgradeAttempts * upgradeCheckInterval);
  }
  __name(setupProgressiveEnhancement, "setupProgressiveEnhancement");
  async function upgradeToFullMode(year3000System2, availableAPIs) {
    try {
      console.log("\u{1F680} [StarryNight] Beginning upgrade to full mode...");
      if (!year3000System2) {
        throw new Error("Year3000System instance not available");
      }
      if (typeof year3000System2.upgradeToFullMode === "function") {
        console.log("\u{1F527} [StarryNight] Using system's built-in upgrade method...");
        await year3000System2.upgradeToFullMode({
          player: availableAPIs.player,
          platform: availableAPIs.platform,
          config: window.Spicetify?.Config,
          degradedMode: false
        });
      } else {
        console.log(
          "\u{1F527} [StarryNight] System upgrade method not available - attempting manual initialization..."
        );
        if (year3000System2.setupMusicAnalysisAndColorExtraction) {
          console.log(
            "\u{1F3B5} [StarryNight] Setting up music analysis and color extraction..."
          );
          await year3000System2.setupMusicAnalysisAndColorExtraction();
        }
        if (availableAPIs.react && availableAPIs.reactDOM) {
          try {
            console.log("\u2699\uFE0F [StarryNight] Initializing settings UI...");
            const settingsUiModule = await Promise.resolve().then(() => (init_StarryNightSettings(), StarryNightSettings_exports));
            await settingsUiModule.initializeStarryNightSettings?.();
            console.log("\u2705 [StarryNight] Settings UI initialized successfully");
          } catch (error) {
            console.warn(
              "\u26A0\uFE0F [StarryNight] Failed to initialize settings UI during upgrade:",
              error
            );
          }
        }
      }
      if (year3000System2.eventBus?.emitSync) {
        year3000System2.eventBus.emitSync("system:upgraded-to-full-mode", {
          timestamp: Date.now(),
          availableAPIs: {
            player: !!availableAPIs.player,
            platform: !!availableAPIs.platform,
            menu: !!availableAPIs.menu,
            react: !!availableAPIs.react,
            reactDOM: !!availableAPIs.reactDOM
          }
        });
      }
      console.log(
        "\u{1F31F} [StarryNight] Upgrade to full mode completed successfully!"
      );
    } catch (error) {
      console.error("\u274C [StarryNight] Upgrade to full mode failed:", error);
      throw error;
    }
  }
  __name(upgradeToFullMode, "upgradeToFullMode");
})();
//# sourceMappingURL=theme.js.map
