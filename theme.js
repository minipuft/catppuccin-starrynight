"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src-js/utils/platform/StorageManager.ts
  var LEGACY_KEY_MAPPINGS, VALID_KEY_PREFIXES, _StorageManager, StorageManager;
  var init_StorageManager = __esm({
    "src-js/utils/platform/StorageManager.ts"() {
      "use strict";
      LEGACY_KEY_MAPPINGS = {
        "sn-starDensity": "sn-star-density",
        "year3000-artistic-mode": "sn-artistic-mode",
        "MusicSyncService-prefs": "sn-music-sync-prefs"
      };
      VALID_KEY_PREFIXES = ["sn-", "catppuccin-"];
      _StorageManager = class _StorageManager {
        /**
         * Check if Spicetify.LocalStorage is available
         */
        static isSpicetifyStorageAvailable() {
          if (this._spicetifyAvailable !== null) {
            return this._spicetifyAvailable;
          }
          try {
            this._spicetifyAvailable = typeof Spicetify !== "undefined" && typeof Spicetify.LocalStorage?.get === "function" && typeof Spicetify.LocalStorage?.set === "function";
            if (this._spicetifyAvailable) {
              Spicetify.LocalStorage.get("__test__");
            }
            return this._spicetifyAvailable;
          } catch (error) {
            console.warn(
              "[StorageManager] Spicetify.LocalStorage not available:",
              error
            );
            this._spicetifyAvailable = false;
            return false;
          }
        }
        /**
         * Validate storage key follows theme conventions
         */
        static validateKey(key) {
          if (!key || typeof key !== "string") return false;
          return VALID_KEY_PREFIXES.some((prefix) => key.startsWith(prefix));
        }
        /**
         * Get value from storage with fallback to native localStorage
         */
        static get(key) {
          try {
            if (this.isSpicetifyStorageAvailable()) {
              return Spicetify.LocalStorage.get(key);
            } else {
              console.warn(
                `[StorageManager] Using fallback localStorage for key: ${key}`
              );
              return localStorage.getItem(key);
            }
          } catch (error) {
            console.error(`[StorageManager] Error reading key ${key}:`, error);
            return null;
          }
        }
        /**
         * Set value in storage with fallback to native localStorage
         */
        static set(key, value) {
          try {
            if (this.isSpicetifyStorageAvailable()) {
              Spicetify.LocalStorage.set(key, value);
              return true;
            } else {
              console.warn(
                `[StorageManager] Using fallback localStorage for key: ${key}`
              );
              localStorage.setItem(key, value);
              return true;
            }
          } catch (error) {
            console.error(`[StorageManager] Error setting key ${key}:`, error);
            return false;
          }
        }
        /**
         * Remove value from storage
         */
        static remove(key) {
          try {
            if (this.isSpicetifyStorageAvailable()) {
              Spicetify.LocalStorage.remove?.(key) || Spicetify.LocalStorage.set(key, null);
              return true;
            } else {
              localStorage.removeItem(key);
              return true;
            }
          } catch (error) {
            console.error(`[StorageManager] Error removing key ${key}:`, error);
            return false;
          }
        }
        /**
         * Migrate values from native localStorage to Spicetify.LocalStorage
         */
        static migrateFromNativeLocalStorage(keyMappings) {
          if (!this.isSpicetifyStorageAvailable()) {
            console.warn(
              "[StorageManager] Cannot migrate - Spicetify.LocalStorage unavailable"
            );
            return;
          }
          let migratedCount = 0;
          for (const [oldKey, newKey] of Object.entries(keyMappings)) {
            try {
              const value = localStorage.getItem(oldKey);
              if (value !== null) {
                const existingValue = Spicetify.LocalStorage.get(newKey);
                if (existingValue === null) {
                  Spicetify.LocalStorage.set(newKey, value);
                  migratedCount++;
                  console.log(`[StorageManager] Migrated: ${oldKey} \u2192 ${newKey}`);
                }
              }
            } catch (error) {
              console.error(
                `[StorageManager] Migration failed for ${oldKey}:`,
                error
              );
            }
          }
          if (migratedCount > 0) {
            console.log(
              `[StorageManager] Migration completed: ${migratedCount} keys migrated`
            );
          }
        }
        /**
         * Migrate all known theme settings from localStorage
         */
        static migrateThemeSettings() {
          if (this._migrationCompleted) return;
          console.log("[StorageManager] Starting theme settings migration...");
          this.migrateFromNativeLocalStorage(LEGACY_KEY_MAPPINGS);
          try {
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith("sn-") && !Object.values(LEGACY_KEY_MAPPINGS).includes(key)) {
                const value = localStorage.getItem(key);
                if (value !== null && this.get(key) === null) {
                  this.set(key, value);
                  console.log(`[StorageManager] Auto-migrated legacy key: ${key}`);
                }
              }
            }
          } catch (error) {
            console.error("[StorageManager] Auto-migration error:", error);
          }
          this._migrationCompleted = true;
          console.log("[StorageManager] Theme settings migration completed");
        }
        /**
         * Get all keys with a specific prefix
         */
        static getKeysWithPrefix(prefix) {
          const keys = [];
          if (this.isSpicetifyStorageAvailable()) {
            const commonSuffixes = [
              "star-density",
              "gradient-intensity",
              "glassmorphism-level",
              "3d-effects-level",
              "artistic-mode",
              "current-harmonic-mode",
              "harmonic-intensity",
              "harmonic-evolution",
              "harmonic-manual-base-color"
            ];
            for (const suffix of commonSuffixes) {
              const key = `${prefix}${suffix}`;
              if (this.get(key) !== null) {
                keys.push(key);
              }
            }
          }
          return keys;
        }
        /**
         * Validate storage health and report issues
         */
        static validateStorageHealth() {
          const result = {
            isHealthy: true,
            issues: [],
            recommendations: []
          };
          if (!this.isSpicetifyStorageAvailable()) {
            result.isHealthy = false;
            result.issues.push("Spicetify.LocalStorage not available");
            result.recommendations.push(
              "Ensure theme is running in Spicetify environment"
            );
          }
          try {
            const orphanedKeys = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && (key.startsWith("sn-") || key.startsWith("catppuccin-"))) {
                orphanedKeys.push(key);
              }
            }
            if (orphanedKeys.length > 0) {
              result.issues.push(
                `Found ${orphanedKeys.length} orphaned localStorage keys`
              );
              result.recommendations.push(
                "Run StorageManager.migrateThemeSettings() to migrate them"
              );
            }
          } catch (error) {
            result.issues.push("Cannot access localStorage for health check");
          }
          return result;
        }
        /**
         * Run comprehensive integration tests
         */
        static runIntegrationTests() {
          const results = {
            storageAvailable: false,
            migrationWorking: false,
            settingsResponse: false,
            keyValidation: false,
            errorHandling: false,
            issues: [],
            summary: ""
          };
          console.log("[StorageManager] Running integration tests...");
          try {
            results.storageAvailable = this.isSpicetifyStorageAvailable();
            if (!results.storageAvailable) {
              results.issues.push("Spicetify.LocalStorage not available");
            }
          } catch (error) {
            results.issues.push(`Storage availability test failed: ${error}`);
          }
          try {
            const validKey = this.validateKey("sn-test-key");
            const invalidKey = this.validateKey("invalid-key");
            results.keyValidation = validKey && !invalidKey;
            if (!results.keyValidation) {
              results.issues.push("Key validation not working correctly");
            }
          } catch (error) {
            results.issues.push(`Key validation test failed: ${error}`);
          }
          try {
            const testKey = "sn-integration-test";
            const testValue = "test-value-" + Date.now();
            const setSuccess = this.set(testKey, testValue);
            const getValue = this.get(testKey);
            const removeSuccess = this.remove(testKey);
            results.settingsResponse = setSuccess && getValue === testValue && removeSuccess;
            if (!results.settingsResponse) {
              results.issues.push("Basic set/get/remove operations failed");
            }
          } catch (error) {
            results.issues.push(`Settings response test failed: ${error}`);
          }
          try {
            const legacyKey = "test-legacy-key";
            const newKey = "sn-migrated-key";
            const testValue = "migration-test-" + Date.now();
            localStorage.setItem(legacyKey, testValue);
            this.migrateFromNativeLocalStorage({ [legacyKey]: newKey });
            const migratedValue = this.get(newKey);
            results.migrationWorking = migratedValue === testValue;
            localStorage.removeItem(legacyKey);
            this.remove(newKey);
            if (!results.migrationWorking) {
              results.issues.push("Migration functionality not working");
            }
          } catch (error) {
            results.issues.push(`Migration test failed: ${error}`);
          }
          try {
            const nullResult = this.get("");
            const invalidSetResult = this.set("", "");
            results.errorHandling = nullResult === null && !invalidSetResult;
            if (!results.errorHandling) {
              results.issues.push("Error handling not working correctly");
            }
          } catch (error) {
            results.issues.push(`Error handling test failed: ${error}`);
          }
          const passedTests = [
            results.storageAvailable,
            results.migrationWorking,
            results.settingsResponse,
            results.keyValidation,
            results.errorHandling
          ].filter(Boolean).length;
          results.summary = `${passedTests}/5 tests passed. ${results.issues.length} issues found.`;
          console.log("[StorageManager] Integration test results:", results);
          return results;
        }
        /**
         * Get diagnostic information for debugging
         */
        static getDiagnosticInfo() {
          const legacyKeys = [];
          try {
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && Object.keys(LEGACY_KEY_MAPPINGS).includes(key)) {
                legacyKeys.push(key);
              }
            }
          } catch (error) {
          }
          return {
            spicetifyAvailable: this.isSpicetifyStorageAvailable(),
            migrationCompleted: this._migrationCompleted,
            knownKeys: this.getKeysWithPrefix("sn-"),
            legacyKeysFound: legacyKeys,
            storageHealth: this.validateStorageHealth()
          };
        }
      };
      __name(_StorageManager, "StorageManager");
      _StorageManager._migrationCompleted = false;
      _StorageManager._spicetifyAvailable = null;
      StorageManager = _StorageManager;
      if (typeof Spicetify !== "undefined") {
        setTimeout(() => {
          StorageManager.migrateThemeSettings();
        }, 100);
      }
    }
  });

  // src-js/config/globalConfig.ts
  var HARMONIC_MODES, ARTISTIC_MODE_PROFILES, YEAR3000_CONFIG;
  var init_globalConfig = __esm({
    "src-js/config/globalConfig.ts"() {
      "use strict";
      init_StorageManager();
      HARMONIC_MODES = {
        "analogous-flow": {
          rule: "analogous",
          angle: 30,
          description: "Gentle rivers of adjacent hues"
        },
        "triadic-trinity": {
          rule: "triadic",
          angle: 120,
          description: "Three-point stellar equilibrium"
        },
        "complementary-yin-yang": {
          rule: "complementary",
          angle: 180,
          description: "Opposing forces in harmony"
        },
        "tetradic-cosmic-cross": {
          rule: "tetradic",
          angle: 90,
          description: "Four-dimensional color matrix"
        },
        "split-complementary-aurora": {
          rule: "split-complementary",
          angle: 150,
          description: "Dancing polar opposites"
        },
        "monochromatic-meditation": {
          rule: "monochromatic",
          angle: 0,
          description: "Single-hue consciousness expansion"
        }
      };
      ARTISTIC_MODE_PROFILES = {
        "corporate-safe": {
          displayName: "Corporate Safe",
          description: "Elegant professional choreography with subtle Year 3000 enhancements",
          philosophy: "Refined efficiency that respects workspace harmony while providing gentle predictive assistance",
          multipliers: {
            opacity: 0.15,
            saturation: 1.05,
            brightness: 1.02,
            contrast: 1.01,
            musicEnergyBoost: 0.3,
            // Year 3000 Kinetic Parameters
            kineticIntensity: 0.2,
            temporalPlayFactor: 0.1,
            quantumEmpathyLevel: 0.3,
            aestheticGravityStrength: 0.1,
            emergentChoreography: false,
            visualIntensityBase: 0.8
          },
          features: {
            rippleEffects: false,
            temporalEcho: false,
            particleStreams: false,
            predictiveHighlights: true,
            // Subtle only
            glassEffects: true,
            // Minimal
            dataGlyphs: true,
            // Professional styling
            beatSync: false,
            colorHarmony: false,
            dimensionalEffects: false,
            quantumEmpathy: false,
            // Disabled for professional environments
            aestheticGravity: false
            // Disabled for professional environments
          },
          performance: {
            maxParticles: 0,
            animationThrottle: 32,
            // 30fps for efficiency
            enableGPUAcceleration: false,
            reducedMotion: true
          }
        },
        "artist-vision": {
          displayName: "Artist Vision",
          description: "Balanced creative expression that enhances musical experience without overwhelming",
          philosophy: "Harmonic amplification that honors artistic intent while providing musical visual synchronization",
          multipliers: {
            opacity: 0.25,
            saturation: 1.25,
            brightness: 1.15,
            contrast: 1.2,
            musicEnergyBoost: 1,
            // Year 3000 Kinetic Parameters
            kineticIntensity: 0.7,
            temporalPlayFactor: 0.5,
            quantumEmpathyLevel: 0.6,
            aestheticGravityStrength: 0.4,
            emergentChoreography: true,
            visualIntensityBase: 1
          },
          features: {
            rippleEffects: true,
            // Moderate intensity
            temporalEcho: true,
            // Subtle trails
            particleStreams: true,
            // Music-responsive
            predictiveHighlights: true,
            glassEffects: true,
            dataGlyphs: true,
            beatSync: true,
            // Musical harmony
            colorHarmony: true,
            // Respectful blending
            dimensionalEffects: true,
            // Moderate
            quantumEmpathy: true,
            // Balanced empathy assistance
            aestheticGravity: true
            // Balanced gravitational effects
          },
          performance: {
            maxParticles: 20,
            animationThrottle: 16,
            // 60fps
            enableGPUAcceleration: true,
            reducedMotion: false
          }
        },
        "cosmic-maximum": {
          displayName: "Cosmic Maximum",
          description: "Full Year 3000 emergent systems choreography with kinetic beauty and aesthetic gravity",
          philosophy: "Gravitational optimism through aesthetic attractor fields that create quantum empathy and temporal play",
          multipliers: {
            opacity: 0.45,
            saturation: 1.75,
            brightness: 1.5,
            contrast: 1.6,
            musicEnergyBoost: 2,
            // Year 3000 Kinetic Parameters
            kineticIntensity: 1.8,
            temporalPlayFactor: 2.5,
            quantumEmpathyLevel: 0.85,
            aestheticGravityStrength: 1.6,
            emergentChoreography: true,
            visualIntensityBase: 1.4
          },
          features: {
            rippleEffects: true,
            // Full intensity
            temporalEcho: true,
            // Visible trails
            particleStreams: true,
            // Attention flow
            predictiveHighlights: true,
            // Advanced prediction
            glassEffects: true,
            // Intense
            dataGlyphs: true,
            // Full animation
            beatSync: true,
            // Full synchronization
            colorHarmony: true,
            // Dynamic evolution
            dimensionalEffects: true,
            // Full 3D
            aestheticGravity: true,
            // Visual magnetism
            quantumEmpathy: true
            // Full prediction
          },
          performance: {
            maxParticles: 50,
            animationThrottle: 8,
            // 120fps for smoothness
            enableGPUAcceleration: true,
            reducedMotion: false
          }
        }
      };
      YEAR3000_CONFIG = {
        enableDebug: true,
        enableContextualIntelligence: true,
        performanceProfiles: {
          low: {
            maxParticles: 15,
            animationThrottle: 32,
            // ~30fps
            enableGPUAcceleration: false,
            enableAdvancedShaders: false,
            textureResolution: 0.5
          },
          balanced: {
            maxParticles: 40,
            animationThrottle: 16,
            // ~60fps
            enableGPUAcceleration: true,
            enableAdvancedShaders: false,
            textureResolution: 1
          },
          high: {
            maxParticles: 75,
            animationThrottle: 16,
            // ~60fps
            enableGPUAcceleration: true,
            enableAdvancedShaders: true,
            textureResolution: 1
          },
          ultra: {
            maxParticles: 150,
            animationThrottle: 8,
            // ~120fps
            enableGPUAcceleration: true,
            enableAdvancedShaders: true,
            textureResolution: 2
            // High-res textures
          }
        },
        // Enhanced logging configuration
        logging: {
          level: "info",
          // "off", "error", "warn", "info", "debug", "verbose"
          performance: {
            enableFrameBudgetWarnings: true,
            throttleWarnings: true,
            // Throttle frequent warnings
            throttleInterval: 5e3,
            // ms between repeated warnings
            enableAdaptiveDegradation: true
            // Auto-reduce quality when needed
          }
        },
        healthCheckInterval: 1e4,
        visual: {
          lightweightParticleSystem: { mode: "artist-vision" },
          dimensionalNexusSystem: { mode: "artist-vision" },
          dataGlyphSystem: { mode: "artist-vision" },
          beatSyncVisualSystem: { mode: "artist-vision" },
          behavioralPredictionEngine: { mode: "artist-vision" },
          predictiveMaterializationSystem: { mode: "artist-vision" },
          sidebarConsciousnessSystem: { mode: "artist-vision" }
        },
        enableColorExtraction: true,
        enableMusicAnalysis: true,
        enableCosmicSync: true,
        // NEW: Music-driven visual intensity
        musicModulationIntensity: 0.25,
        // Active artistic mode for UX / visual presets
        artisticMode: "artist-vision",
        // "corporate-safe" | "artist-vision" | "cosmic-maximum"
        // Context-bound method references for external calling
        boundGetCurrentMultipliers: null,
        boundGetCurrentFeatures: null,
        boundGetCurrentPerformanceSettings: null,
        // Pending artistic mode for deferred application
        _pendingArtisticMode: null,
        // Initialize bound methods to preserve context
        init() {
          this.boundGetCurrentMultipliers = this.getCurrentMultipliers.bind(this);
          this.boundGetCurrentFeatures = this.getCurrentFeatures.bind(this);
          this.boundGetCurrentPerformanceSettings = this.getCurrentPerformanceSettings.bind(this);
          if (this._pendingArtisticMode && this.isFullyInitialized()) {
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] Applying pending artistic mode: ${this._pendingArtisticMode}`
              );
            }
            this.setArtisticMode(this._pendingArtisticMode);
            this._pendingArtisticMode = null;
          }
          if (this.enableDebug) {
            console.log(
              "\u{1F527} [YEAR3000_CONFIG] Initialized with context-bound methods"
            );
          }
          return this;
        },
        currentHarmonicMode: "analogous-flow",
        harmonicBaseColor: null,
        harmonicIntensity: 0.7,
        harmonicEvolution: true,
        musicVisualSync: {
          energyScaling: {
            low: 0.6,
            medium: 1,
            high: 1.4
          },
          valenceScaling: {
            sad: 0.8,
            neutral: 1,
            happy: 1.3
          },
          danceabilityEffects: {
            enable: true,
            animationSpeedMultiplier: 1.5,
            blurVariation: 0.3
          },
          // NEW: Enhanced BPM calculation (inspired by Cat Jam extension)
          enhancedBPM: {
            enable: true,
            useSmartCalculation: true,
            // Toggle for enhanced vs basic tempo
            useRealisticData: true,
            // Use actual Spicetify-available data only
            // Tempo-based danceability estimation ranges
            danceabilityEstimation: {
              highDance: { min: 120, max: 140, value: 0.8 },
              // House/Dance music
              mediumDance: { min: 100, max: 160, value: 0.6 },
              // Pop/Electronic
              lowMediumDance: { min: 80, max: 180, value: 0.4 },
              // General music
              lowDance: { value: 0.2 }
              // Very slow/fast
            },
            // Energy estimation from tempo + loudness
            energyEstimation: {
              tempoWeight: 0.6,
              // How much tempo affects energy estimate
              loudnessWeight: 0.4,
              // How much loudness affects energy estimate
              tempoRange: { min: 60, max: 180 },
              // Expected tempo range
              loudnessRange: { min: -60, max: 0 }
              // Expected loudness range (dB)
            },
            // Enhanced BPM calculation parameters
            danceabilityThresholds: {
              high: 0.7,
              // High danceability - use full tempo
              low: 0.3
              // Low danceability - may reduce tempo
            },
            energyMultiplierRange: {
              min: 0.8,
              // Minimum energy multiplier
              max: 1.4
              // Maximum energy multiplier
            },
            tempoMultipliers: {
              highDance: 1,
              // Full tempo for danceable tracks
              mediumDance: 0.75,
              // Moderate reduction
              lowDance: 0.5
              // Significant reduction for smooth visuals
            },
            // Fallback values when audio data is unavailable
            fallbacks: {
              tempo: 120,
              loudness: -10,
              danceability: 0.5,
              energy: 0.5,
              key: 0,
              timeSignature: 4
            }
          }
        },
        // Enhanced: Get current mode profile with full Year3000 parameters
        getCurrentModeProfile() {
          const mode = this.artisticMode || "artist-vision";
          return ARTISTIC_MODE_PROFILES[mode] || ARTISTIC_MODE_PROFILES["artist-vision"];
        },
        // Enhanced: Get current multipliers from active mode profile
        getCurrentMultipliers() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[YEAR3000_CONFIG] getCurrentModeProfile method not available, using fallback multipliers"
              );
              return this["artisticMultipliers"];
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.multipliers) {
              console.warn(
                "[YEAR3000_CONFIG] Invalid profile or missing multipliers, using fallback"
              );
              return this["artisticMultipliers"];
            }
            return currentProfile.multipliers;
          } catch (error) {
            console.error("[YEAR3000_CONFIG] Error in getCurrentMultipliers:", error);
            return this["artisticMultipliers"];
          }
        },
        // Enhanced: Get current features from active mode profile
        getCurrentFeatures() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[YEAR3000_CONFIG] getCurrentModeProfile method not available, using fallback features"
              );
              return {
                enableAdvancedEffects: true,
                enableHarmony: true,
                beatSync: true,
                colorHarmony: true
              };
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.features) {
              console.warn(
                "[YEAR3000_CONFIG] Invalid profile or missing features, using fallback"
              );
              return {
                enableAdvancedEffects: true,
                enableHarmony: true,
                beatSync: true,
                colorHarmony: true
              };
            }
            return currentProfile.features;
          } catch (error) {
            console.error("[YEAR3000_CONFIG] Error in getCurrentFeatures:", error);
            return {
              enableAdvancedEffects: true,
              enableHarmony: true,
              beatSync: true,
              colorHarmony: true
            };
          }
        },
        // Enhanced: Get current performance settings from active mode profile
        getCurrentPerformanceSettings() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[YEAR3000_CONFIG] getCurrentModeProfile method not available, using fallback performance settings"
              );
              return {
                maxParticles: 20,
                animationThrottle: 16,
                enableGPUAcceleration: true,
                reducedMotion: false
              };
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.performance) {
              console.warn(
                "[YEAR3000_CONFIG] Invalid profile or missing performance settings, using fallback"
              );
              return {
                maxParticles: 20,
                animationThrottle: 16,
                enableGPUAcceleration: true,
                reducedMotion: false
              };
            }
            return currentProfile.performance;
          } catch (error) {
            console.error(
              "[YEAR3000_CONFIG] Error in getCurrentPerformanceSettings:",
              error
            );
            return {
              maxParticles: 20,
              animationThrottle: 16,
              enableGPUAcceleration: true,
              reducedMotion: false
            };
          }
        },
        // Check if YEAR3000_CONFIG is fully initialized with all required methods
        isFullyInitialized() {
          const requiredMethods = [
            "setArtisticMode",
            "getCurrentModeProfile",
            "getCurrentMultipliers",
            "getCurrentFeatures",
            "getCurrentPerformanceSettings"
          ];
          return requiredMethods.every(
            (method) => typeof this[method] === "function"
          );
        },
        // Safe setArtisticMode wrapper that validates state
        safeSetArtisticMode(mode) {
          if (!this.isFullyInitialized()) {
            console.warn(
              "[YEAR3000_CONFIG] Not fully initialized, deferring artistic mode change"
            );
            this._pendingArtisticMode = mode;
            return false;
          }
          return this.setArtisticMode(mode);
        },
        setArtisticMode(mode) {
          const validModes = Object.keys(ARTISTIC_MODE_PROFILES);
          if (validModes.includes(mode)) {
            const previousMode = this.artisticMode;
            this.artisticMode = mode;
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] Artistic mode changed: ${previousMode} \u2192 ${mode}`
              );
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] New profile:`,
                this.getCurrentModeProfile()
              );
            }
            if (typeof document !== "undefined") {
              document.dispatchEvent(
                new CustomEvent("year3000ArtisticModeChanged", {
                  detail: {
                    previousMode,
                    newMode: mode,
                    profile: this.getCurrentModeProfile()
                  }
                })
              );
            }
            if (typeof globalThis.year3000System !== "undefined" && globalThis.year3000System.setGradientParameters) {
              globalThis.year3000System.setGradientParameters(
                document.documentElement
              );
            }
            return true;
          }
          console.warn(
            `[YEAR3000_CONFIG] Invalid artistic mode: ${mode}. Valid modes:`,
            validModes
          );
          return false;
        },
        // ===========================================
        // 🔧 LOGGING & PERFORMANCE CONFIGURATION HELPERS
        // ===========================================
        // Set logging level for all Year 3000 systems
        setLoggingLevel(level) {
          const validLevels = ["off", "error", "warn", "info", "debug", "verbose"];
          if (validLevels.includes(level)) {
            this.logging.level = level;
            if (level !== "off") {
              console.log(`\u{1F527} [YEAR3000_CONFIG] Logging level set to: ${level}`);
            }
            return true;
          }
          console.warn(
            `[YEAR3000_CONFIG] Invalid logging level: ${level}. Valid levels:`,
            validLevels
          );
          return false;
        },
        // Disable performance warnings (useful for production or when performance is acceptable)
        disablePerformanceWarnings() {
          this.logging.performance.enableFrameBudgetWarnings = false;
          console.log("\u{1F527} [YEAR3000_CONFIG] Performance warnings disabled");
        },
        // Enable performance warnings
        enablePerformanceWarnings() {
          this.logging.performance.enableFrameBudgetWarnings = true;
          console.log("\u{1F527} [YEAR3000_CONFIG] Performance warnings enabled");
        },
        // Set performance warning throttle interval (ms)
        setPerformanceWarningThrottle(intervalMs) {
          if (typeof intervalMs === "number" && intervalMs >= 0) {
            this.logging.performance.throttleInterval = intervalMs;
            this.logging.performance.throttleWarnings = intervalMs > 0;
            console.log(
              `\u{1F527} [YEAR3000_CONFIG] Performance warning throttle set to: ${intervalMs}ms`
            );
            return true;
          }
          console.warn(
            "[YEAR3000_CONFIG] Invalid throttle interval. Must be a non-negative number."
          );
          return false;
        },
        // Quick setup for different environments
        setupForProduction() {
          this.setLoggingLevel("warn");
          this.disablePerformanceWarnings();
          this.logging.performance.enableAdaptiveDegradation = true;
          console.log("\u{1F527} [YEAR3000_CONFIG] Configured for production environment");
        },
        setupForDevelopment() {
          this.setLoggingLevel("debug");
          this.enablePerformanceWarnings();
          this.setPerformanceWarningThrottle(2e3);
          this.logging.performance.enableAdaptiveDegradation = true;
          console.log("\u{1F527} [YEAR3000_CONFIG] Configured for development environment");
        },
        setupForDebugging() {
          this.setLoggingLevel("verbose");
          this.enablePerformanceWarnings();
          this.setPerformanceWarningThrottle(500);
          this.logging.performance.enableAdaptiveDegradation = false;
          console.log("\u{1F527} [YEAR3000_CONFIG] Configured for debugging environment");
        },
        // Validate configuration health and functionality
        validateConfigHealth() {
          const healthReport = {
            overallStatus: "healthy",
            issues: [],
            dynamicChecks: {}
          };
          const configKeys = Object.keys(this).filter(
            (k) => typeof k === "string"
          );
          const functionProperties = configKeys.filter(
            (key) => typeof this[key] === "function"
          );
          for (const key of functionProperties) {
            if (!this.hasOwnProperty(key)) {
              healthReport.issues.push({
                key: String(key),
                severity: "warning",
                message: `Method ${key} is not an own property, may indicate prototype chain issues.`
              });
            }
          }
          const checkProfile = /* @__PURE__ */ __name((mode) => {
            if (!ARTISTIC_MODE_PROFILES[mode]) {
              healthReport.issues.push({
                key: `artisticMode:${mode}`,
                severity: "critical",
                message: `Artistic mode profile for '${mode}' is missing.`
              });
              return;
            }
            healthReport.dynamicChecks[`${mode}Profile`] = "ok";
          }, "checkProfile");
          checkProfile(this.artisticMode);
          checkProfile("artist-vision");
          checkProfile("corporate-safe");
          if (healthReport.issues.length > 0) {
            healthReport.overallStatus = healthReport.issues.some(
              (i) => i.severity === "critical"
            ) ? "critical" : "unhealthy";
          }
          if (this.enableDebug) {
            console.log("[YEAR3000_CONFIG] Health Check Report:", healthReport);
          }
          return healthReport;
        },
        loadArtisticPreference() {
          const saved = StorageManager.get("sn-artistic-mode");
          const validModes = Object.keys(ARTISTIC_MODE_PROFILES);
          if (saved && validModes.includes(saved)) {
            this.artisticMode = saved;
          } else {
            this.artisticMode = "artist-vision";
          }
          if (this.enableDebug) {
            console.log(
              `\u{1F3A8} [YEAR3000_CONFIG] Loaded artistic preference: ${this.artisticMode}`
            );
          }
        }
      };
      if (typeof YEAR3000_CONFIG.init === "function") {
        YEAR3000_CONFIG.init();
      }
    }
  });

  // src-js/config/settingKeys.ts
  var GLASS_LEVEL_KEY, GLASS_LEVEL_OLD_KEY, CARD_3D_LEVEL_KEY, HARMONIC_INTENSITY_KEY, HARMONIC_EVOLUTION_KEY, NEBULA_INTENSITY_KEY;
  var init_settingKeys = __esm({
    "src-js/config/settingKeys.ts"() {
      "use strict";
      GLASS_LEVEL_KEY = "sn-glassmorphism-level";
      GLASS_LEVEL_OLD_KEY = "sn-glassmorphismIntensity";
      CARD_3D_LEVEL_KEY = "sn-3d-effects-level";
      HARMONIC_INTENSITY_KEY = "sn-harmonic-intensity";
      HARMONIC_EVOLUTION_KEY = "sn-harmonic-evolution";
      NEBULA_INTENSITY_KEY = "sn-nebula-intensity";
    }
  });

  // src-js/debug/UnifiedDebugManager.ts
  var _UnifiedDebugManager, UnifiedDebugManager, Y3K, UnifiedDebugManager_default;
  var init_UnifiedDebugManager = __esm({
    "src-js/debug/UnifiedDebugManager.ts"() {
      "use strict";
      init_globalConfig();
      _UnifiedDebugManager = class _UnifiedDebugManager {
        constructor(config = {}) {
          this.registeredSystems = /* @__PURE__ */ new Map();
          this.reportHistory = [];
          this.monitoring = false;
          this.monitoringInterval = null;
          this.performanceMetrics = /* @__PURE__ */ new Map();
          this.config = {
            enableConsoleReporting: YEAR3000_CONFIG.enableDebug,
            reportingInterval: 3e4,
            // 30 seconds
            enablePerformanceTracking: true,
            enableSystemHealthMonitoring: true,
            maxHistoryEntries: 50,
            verboseLogging: YEAR3000_CONFIG.enableDebug,
            ...config
          };
          if (this.config.enableConsoleReporting) {
            console.log("\u{1F527} [UnifiedDebugManager] Debug system initialized");
          }
        }
        static getInstance(config) {
          if (!_UnifiedDebugManager.instance) {
            _UnifiedDebugManager.instance = new _UnifiedDebugManager(config);
          }
          return _UnifiedDebugManager.instance;
        }
        // =========================================================================
        // SYSTEM REGISTRATION & MANAGEMENT
        // =========================================================================
        /**
         * Register a system for debug monitoring
         */
        registerSystem(name, system, type = "unified") {
          const debugInfo = {
            name,
            type,
            initialized: system.initialized || false,
            healthy: true,
            lastUpdate: Date.now(),
            issues: [],
            metrics: {}
          };
          this.registeredSystems.set(name, debugInfo);
          if (this.config.verboseLogging) {
            console.log(`\u{1F527} [UnifiedDebugManager] Registered system: ${name} (${type})`);
          }
          if (this.registeredSystems.size === 1 && !this.monitoring) {
            this.startMonitoring();
          }
        }
        /**
         * Unregister a system from debug monitoring
         */
        unregisterSystem(name) {
          this.registeredSystems.delete(name);
          this.performanceMetrics.delete(name);
          if (this.config.verboseLogging) {
            console.log(`\u{1F527} [UnifiedDebugManager] Unregistered system: ${name}`);
          }
          if (this.registeredSystems.size === 0) {
            this.stopMonitoring();
          }
        }
        /**
         * Update system debug information
         */
        updateSystem(name, updates) {
          const system = this.registeredSystems.get(name);
          if (!system) return;
          Object.assign(system, updates, { lastUpdate: Date.now() });
          this.registeredSystems.set(name, system);
        }
        /**
         * Record performance metric for a system
         */
        recordMetric(systemName, metricName, value) {
          if (!this.config.enablePerformanceTracking) return;
          const system = this.registeredSystems.get(systemName);
          if (system) {
            system.metrics[metricName] = value;
            system.lastUpdate = Date.now();
          }
          const key = `${systemName}_${metricName}`;
          const history = this.performanceMetrics.get(key) || [];
          history.push(value);
          if (history.length > 100) {
            history.splice(0, history.length - 100);
          }
          this.performanceMetrics.set(key, history);
        }
        /**
         * Record system issue
         */
        recordIssue(systemName, issue) {
          const system = this.registeredSystems.get(systemName);
          if (system) {
            system.issues.push(issue);
            system.healthy = false;
            system.lastUpdate = Date.now();
            if (this.config.verboseLogging) {
              console.warn(`\u26A0\uFE0F [${systemName}] ${issue}`);
            }
          }
        }
        // =========================================================================
        // SYSTEM HEALTH CHECKING
        // =========================================================================
        /**
         * Perform health check on all registered systems
         */
        async performHealthCheck() {
          const timestamp = Date.now();
          const systemDetails = [];
          let healthySystems = 0;
          let totalIssues = 0;
          let totalFrameTime = 0;
          let totalMemory = 0;
          let frameTimeCount = 0;
          for (const [name, system] of this.registeredSystems) {
            try {
              let actualSystem = null;
              let dynamicInitializedStatus = system.initialized;
              const year3000System2 = globalThis.year3000System;
              if (year3000System2) {
                if (year3000System2.facadeCoordinator) {
                  try {
                    actualSystem = year3000System2.facadeCoordinator.getCachedNonVisualSystem?.(name) || await year3000System2.facadeCoordinator.getNonVisualSystem?.(name);
                  } catch (e) {
                  }
                  if (!actualSystem) {
                    try {
                      actualSystem = year3000System2.facadeCoordinator.getVisualSystem?.(name);
                    } catch (e) {
                    }
                  }
                }
                if (!actualSystem) {
                  const camelCaseName = name.charAt(0).toLowerCase() + name.slice(1);
                  actualSystem = year3000System2[camelCaseName] || year3000System2[name];
                }
              }
              if (!actualSystem) {
                actualSystem = globalThis[name];
              }
              if (actualSystem) {
                if (typeof actualSystem.initialized === "boolean") {
                  dynamicInitializedStatus = actualSystem.initialized;
                } else if (typeof actualSystem.isInitialized === "function") {
                  try {
                    dynamicInitializedStatus = await actualSystem.isInitialized();
                  } catch (e) {
                  }
                } else if (typeof actualSystem.getInitializationStatus === "function") {
                  try {
                    const status = await actualSystem.getInitializationStatus();
                    dynamicInitializedStatus = status?.initialized ?? status?.ready ?? false;
                  } catch (e) {
                  }
                }
              }
              const oldStatus = system.initialized;
              system.initialized = dynamicInitializedStatus;
              system.lastUpdate = timestamp;
              if (this.config.verboseLogging && oldStatus !== dynamicInitializedStatus) {
                console.log(`\u{1F527} [UnifiedDebugManager] ${name} initialization status updated: ${oldStatus} \u2192 ${dynamicInitializedStatus}`);
              }
              if (actualSystem && typeof actualSystem.healthCheck === "function") {
                const healthResult = await actualSystem.healthCheck();
                system.healthy = healthResult.healthy ?? healthResult.ok;
                if (!healthResult.ok) {
                  system.issues = [healthResult.details || "Health check failed"];
                } else {
                  system.issues = [];
                }
              } else {
                system.healthy = dynamicInitializedStatus;
                if (!dynamicInitializedStatus) {
                  system.issues = ["System not initialized"];
                } else {
                  system.issues = [];
                }
              }
              if (system.frameTime) {
                totalFrameTime += system.frameTime;
                frameTimeCount++;
              }
              if (system.memoryUsage) {
                totalMemory += system.memoryUsage;
              }
              if (system.healthy) {
                healthySystems++;
              } else {
                totalIssues += system.issues.length;
              }
              systemDetails.push({ ...system });
            } catch (error) {
              system.healthy = false;
              system.issues = [`Health check error: ${error}`];
              totalIssues++;
              if (this.config.verboseLogging) {
                console.error(`\u274C [${name}] Health check failed:`, error);
              }
            }
          }
          const healthPercentage = this.registeredSystems.size > 0 ? healthySystems / this.registeredSystems.size : 1;
          let overallHealth;
          if (healthPercentage >= 0.9) overallHealth = "excellent";
          else if (healthPercentage >= 0.7) overallHealth = "good";
          else if (healthPercentage >= 0.5) overallHealth = "degraded";
          else overallHealth = "critical";
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] System initialization status for recommendations:");
            for (const system of systemDetails) {
              console.log(`   ${system.name}: ${system.initialized ? "\u2705" : "\u274C"} initialized`);
            }
          }
          const recommendations = this.generateRecommendations(systemDetails, overallHealth);
          const report = {
            timestamp,
            overallHealth,
            systemCount: this.registeredSystems.size,
            healthySystems,
            totalIssues,
            systemDetails,
            performance: {
              avgFrameTime: frameTimeCount > 0 ? totalFrameTime / frameTimeCount : 0,
              totalMemoryMB: totalMemory,
              cpuUsageEstimate: this.estimateCPUUsage()
            },
            recommendations
          };
          this.reportHistory.push(report);
          if (this.reportHistory.length > this.config.maxHistoryEntries) {
            this.reportHistory.splice(0, this.reportHistory.length - this.config.maxHistoryEntries);
          }
          return report;
        }
        /**
         * Generate actionable recommendations based on system state
         */
        generateRecommendations(systems, overallHealth) {
          const recommendations = [];
          if (overallHealth === "critical") {
            recommendations.push("\u{1F6A8} Critical: Multiple systems failing - check console for errors");
          }
          const uninitializedSystems = systems.filter((s) => !s.initialized);
          if (uninitializedSystems.length > 0) {
            recommendations.push(`\u26A0\uFE0F ${uninitializedSystems.length} systems not initialized: ${uninitializedSystems.map((s) => s.name).join(", ")}`);
          }
          const highFrameTimes = systems.filter((s) => s.frameTime && s.frameTime > 16.67);
          if (highFrameTimes.length > 0) {
            recommendations.push(`\u{1F40C} Performance: ${highFrameTimes.length} systems exceeding 16.67ms frame time`);
          }
          const memoryIssues = systems.filter((s) => s.memoryUsage && s.memoryUsage > 50);
          if (memoryIssues.length > 0) {
            recommendations.push(`\u{1F4BE} Memory: ${memoryIssues.length} systems using >50MB`);
          }
          if (recommendations.length === 0) {
            recommendations.push("\u2705 All systems operating within normal parameters");
          }
          return recommendations;
        }
        /**
         * Estimate CPU usage based on frame times and system activity
         */
        estimateCPUUsage() {
          let totalFrameTime = 0;
          let count = 0;
          for (const system of this.registeredSystems.values()) {
            if (system.frameTime) {
              totalFrameTime += system.frameTime;
              count++;
            }
          }
          if (count === 0) return 0;
          const avgFrameTime = totalFrameTime / count;
          return Math.min(100, avgFrameTime / 16.67 * 5);
        }
        // =========================================================================
        // MONITORING & REPORTING
        // =========================================================================
        /**
         * Start automatic monitoring
         */
        startMonitoring() {
          if (this.monitoring) return;
          this.monitoring = true;
          this.monitoringInterval = window.setInterval(() => {
            this.performHealthCheck().then((report) => {
              if (this.config.enableConsoleReporting) {
                this.logHealthReport(report);
              }
            });
          }, this.config.reportingInterval);
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Monitoring started");
          }
        }
        /**
         * Stop automatic monitoring
         */
        stopMonitoring() {
          if (!this.monitoring) return;
          this.monitoring = false;
          if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
          }
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Monitoring stopped");
          }
        }
        /**
         * Log health report to console in a readable format
         */
        logHealthReport(report) {
          if (!report) {
            this.performHealthCheck().then((r) => this.logHealthReport(r));
            return;
          }
          const statusEmoji = {
            excellent: "\u{1F31F}",
            good: "\u2705",
            degraded: "\u26A0\uFE0F",
            critical: "\u{1F6A8}"
          }[report.overallHealth];
          console.group(`${statusEmoji} Year 3000 System Health Report - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}`);
          console.log(`\u{1F4CA} Overall: ${report.overallHealth.toUpperCase()} (${report.healthySystems}/${report.systemCount} healthy)`);
          if (report.totalIssues > 0) {
            console.log(`\u{1F6A8} Issues: ${report.totalIssues} total`);
          }
          console.log(`\u26A1 Performance: ${report.performance.avgFrameTime.toFixed(2)}ms avg frame, ${report.performance.totalMemoryMB.toFixed(1)}MB memory, ~${report.performance.cpuUsageEstimate.toFixed(1)}% CPU`);
          if (report.systemDetails.length > 0) {
            console.group("\u{1F527} System Details");
            report.systemDetails.forEach((system) => {
              const emoji = system.healthy ? "\u2705" : "\u274C";
              const frameInfo = system.frameTime ? ` (${system.frameTime.toFixed(2)}ms)` : "";
              console.log(`${emoji} ${system.name} [${system.type}]${frameInfo}`);
              if (system.issues.length > 0) {
                system.issues.forEach((issue) => {
                  console.log(`    \u26A0\uFE0F ${issue}`);
                });
              }
            });
            console.groupEnd();
          }
          if (report.recommendations.length > 0) {
            console.group("\u{1F4A1} Recommendations");
            report.recommendations.forEach((rec) => console.log(`  ${rec}`));
            console.groupEnd();
          }
          console.groupEnd();
        }
        // =========================================================================
        // PUBLIC API & UTILITIES
        // =========================================================================
        /**
         * Get the latest debug report
         */
        getLatestReport() {
          return this.reportHistory[this.reportHistory.length - 1] || null;
        }
        /**
         * Get all report history
         */
        getReportHistory() {
          return [...this.reportHistory];
        }
        /**
         * Get system information
         */
        getSystemInfo(name) {
          return this.registeredSystems.get(name) || null;
        }
        /**
         * Get all registered systems
         */
        getAllSystems() {
          return Array.from(this.registeredSystems.values());
        }
        /**
         * Manual health check trigger
         */
        async checkHealth() {
          const report = await this.performHealthCheck();
          this.logHealthReport(report);
        }
        /**
         * Update debug configuration
         */
        updateConfig(config) {
          this.config = { ...this.config, ...config };
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Configuration updated:", config);
          }
        }
        /**
         * Clear all data and reset
         */
        reset() {
          this.stopMonitoring();
          this.registeredSystems.clear();
          this.reportHistory = [];
          this.performanceMetrics.clear();
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] System reset");
          }
        }
        /**
         * Destroy the debug manager
         */
        destroy() {
          this.reset();
          _UnifiedDebugManager.instance = null;
        }
      };
      __name(_UnifiedDebugManager, "UnifiedDebugManager");
      UnifiedDebugManager = _UnifiedDebugManager;
      Y3K = {
        debug: {
          log: /* @__PURE__ */ __name((component, message, ...args) => {
            if (YEAR3000_CONFIG?.enableDebug) {
              console.log(`[${component}] ${message}`, ...args);
            }
          }, "log"),
          error: /* @__PURE__ */ __name((component, message, error) => {
            console.error(`[${component}] ${message}`, error);
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordIssue(component, `${message}${error ? `: ${error}` : ""}`);
          }, "error"),
          warn: /* @__PURE__ */ __name((component, message, ...args) => {
            console.warn(`[${component}] ${message}`, ...args);
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordIssue(component, message);
          }, "warn"),
          metric: /* @__PURE__ */ __name((system, metric, value) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordMetric(system, metric, value);
          }, "metric"),
          register: /* @__PURE__ */ __name((name, system, type) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.registerSystem(name, system, type);
          }, "register"),
          unregister: /* @__PURE__ */ __name((name) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.unregisterSystem(name);
          }, "unregister"),
          checkHealth: /* @__PURE__ */ __name(() => {
            const debugManager = UnifiedDebugManager.getInstance();
            return debugManager.checkHealth();
          }, "checkHealth"),
          getReport: /* @__PURE__ */ __name(() => {
            const debugManager = UnifiedDebugManager.getInstance();
            return debugManager.getLatestReport();
          }, "getReport")
        }
      };
      if (typeof window !== "undefined") {
        window.UnifiedDebugManager = UnifiedDebugManager;
        window.Y3K = Y3K;
        console.log("\u{1F527} [UnifiedDebugManager] Global debug interface available:");
        console.log("  Y3K.debug.checkHealth() - Check system health");
        console.log("  Y3K.debug.getReport() - Get latest debug report");
        console.log("  UnifiedDebugManager.getInstance() - Get debug manager");
      }
      UnifiedDebugManager_default = UnifiedDebugManager;
    }
  });

  // src-js/core/events/UnifiedEventBus.ts
  var _UnifiedEventBus, UnifiedEventBus, unifiedEventBus;
  var init_UnifiedEventBus = __esm({
    "src-js/core/events/UnifiedEventBus.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _UnifiedEventBus = class _UnifiedEventBus {
        constructor() {
          // Event subscriptions registry
          this.subscriptions = /* @__PURE__ */ new Map();
          // Event metrics and monitoring
          this.eventMetrics = {
            totalEvents: 0,
            totalSubscriptions: 0,
            activeSubscriptions: 0,
            eventsPerSecond: 0,
            topEvents: [],
            memoryUsage: 0
          };
          // Performance monitoring
          this.eventQueue = [];
          this.processingQueue = false;
          this.maxQueueSize = 1e3;
          // Cleanup management
          this.subscriptionCleanupInterval = null;
          this.metricsUpdateInterval = null;
          this.startMetricsMonitoring();
          this.startSubscriptionCleanup();
          Y3K?.debug?.log("UnifiedEventBus", "Unified event bus initialized");
        }
        /**
         * Get singleton instance
         */
        static getInstance() {
          if (!_UnifiedEventBus.instance) {
            _UnifiedEventBus.instance = new _UnifiedEventBus();
          }
          return _UnifiedEventBus.instance;
        }
        /**
         * Subscribe to an event with type safety
         */
        subscribe(eventName, handler, subscriberName = "anonymous", options = {}) {
          const subscriptionId = this.generateSubscriptionId();
          if (!this.subscriptions.has(eventName)) {
            this.subscriptions.set(eventName, /* @__PURE__ */ new Map());
          }
          const subscription = {
            id: subscriptionId,
            eventName,
            handler,
            subscriberName,
            once: options.once || false,
            createdAt: Date.now(),
            triggerCount: 0
          };
          this.subscriptions.get(eventName).set(subscriptionId, subscription);
          this.eventMetrics.totalSubscriptions++;
          this.eventMetrics.activeSubscriptions++;
          Y3K?.debug?.log("UnifiedEventBus", `Subscription added: ${subscriberName} -> ${eventName}`, {
            subscriptionId,
            totalSubscriptions: this.eventMetrics.activeSubscriptions
          });
          return subscriptionId;
        }
        /**
         * Subscribe to an event only once
         */
        once(eventName, handler, subscriberName = "anonymous") {
          return this.subscribe(eventName, handler, subscriberName, { once: true });
        }
        /**
         * Unsubscribe from an event
         */
        unsubscribe(subscriptionId) {
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            if (subscriptionMap.has(subscriptionId)) {
              const subscription = subscriptionMap.get(subscriptionId);
              subscriptionMap.delete(subscriptionId);
              if (subscriptionMap.size === 0) {
                this.subscriptions.delete(eventName);
              }
              this.eventMetrics.activeSubscriptions--;
              Y3K?.debug?.log("UnifiedEventBus", `Subscription removed: ${subscription.subscriberName} -> ${eventName}`, {
                subscriptionId,
                remainingSubscriptions: this.eventMetrics.activeSubscriptions
              });
              return true;
            }
          }
          return false;
        }
        /**
         * Unsubscribe all events for a specific subscriber
         */
        unsubscribeAll(subscriberName) {
          let removedCount = 0;
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            const toRemove = Array.from(subscriptionMap.values()).filter((sub) => sub.subscriberName === subscriberName);
            for (const subscription of toRemove) {
              subscriptionMap.delete(subscription.id);
              removedCount++;
              this.eventMetrics.activeSubscriptions--;
            }
            if (subscriptionMap.size === 0) {
              this.subscriptions.delete(eventName);
            }
          }
          if (removedCount > 0) {
            Y3K?.debug?.log("UnifiedEventBus", `Removed ${removedCount} subscriptions for: ${subscriberName}`);
          }
          return removedCount;
        }
        /**
         * Emit an event with type safety
         */
        async emit(eventName, data) {
          const timestamp = Date.now();
          if (this.processingQueue || this.eventQueue.length > 0) {
            if (this.eventQueue.length >= this.maxQueueSize) {
              Y3K?.debug?.warn("UnifiedEventBus", `Event queue full, dropping event: ${eventName}`);
              return;
            }
            this.eventQueue.push({ eventName, data, timestamp });
            this.processEventQueue();
            return;
          }
          await this.processEvent(eventName, data, timestamp);
        }
        /**
         * Emit an event synchronously (use sparingly)
         */
        emitSync(eventName, data) {
          const timestamp = Date.now();
          this.processEventSync(eventName, data, timestamp);
        }
        /**
         * Process a single event
         */
        async processEvent(eventName, data, timestamp) {
          const subscriptionMap = this.subscriptions.get(eventName);
          if (!subscriptionMap || subscriptionMap.size === 0) {
            return;
          }
          this.eventMetrics.totalEvents++;
          const handlers = [];
          const toRemove = [];
          for (const [subscriptionId, subscription] of subscriptionMap.entries()) {
            handlers.push({ subscription, handler: subscription.handler });
            if (subscription.once) {
              toRemove.push(subscriptionId);
            }
            subscription.lastTriggered = timestamp;
            subscription.triggerCount++;
          }
          const promises = handlers.map(async ({ subscription, handler }) => {
            try {
              await handler(data);
            } catch (error) {
              Y3K?.debug?.error("UnifiedEventBus", `Handler error in ${subscription.subscriberName} for ${eventName}:`, error);
              this.emitSync("system:error", {
                systemName: subscription.subscriberName,
                error: error instanceof Error ? error.message : "Unknown error",
                severity: "error",
                timestamp: Date.now()
              });
            }
          });
          await Promise.all(promises);
          for (const subscriptionId of toRemove) {
            subscriptionMap.delete(subscriptionId);
            this.eventMetrics.activeSubscriptions--;
          }
          if (subscriptionMap.size === 0) {
            this.subscriptions.delete(eventName);
          }
          Y3K?.debug?.log("UnifiedEventBus", `Event processed: ${eventName}`, {
            handlerCount: handlers.length,
            processingTime: Date.now() - timestamp
          });
        }
        /**
         * Process event synchronously
         */
        processEventSync(eventName, data, timestamp) {
          const subscriptionMap = this.subscriptions.get(eventName);
          if (!subscriptionMap || subscriptionMap.size === 0) {
            return;
          }
          this.eventMetrics.totalEvents++;
          const toRemove = [];
          for (const [subscriptionId, subscription] of subscriptionMap.entries()) {
            try {
              subscription.handler(data);
              subscription.lastTriggered = timestamp;
              subscription.triggerCount++;
              if (subscription.once) {
                toRemove.push(subscriptionId);
              }
            } catch (error) {
              Y3K?.debug?.error("UnifiedEventBus", `Sync handler error in ${subscription.subscriberName} for ${eventName}:`, error);
            }
          }
          for (const subscriptionId of toRemove) {
            subscriptionMap.delete(subscriptionId);
            this.eventMetrics.activeSubscriptions--;
          }
          if (subscriptionMap.size === 0) {
            this.subscriptions.delete(eventName);
          }
        }
        /**
         * Process queued events
         */
        async processEventQueue() {
          if (this.processingQueue) return;
          this.processingQueue = true;
          while (this.eventQueue.length > 0) {
            const queueItem = this.eventQueue.shift();
            await this.processEvent(queueItem.eventName, queueItem.data, queueItem.timestamp);
          }
          this.processingQueue = false;
        }
        /**
         * Get current event metrics
         */
        getMetrics() {
          return { ...this.eventMetrics };
        }
        /**
         * Get all active subscriptions for debugging
         */
        getActiveSubscriptions() {
          const subscriptions = [];
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            for (const [subscriptionId, subscription] of subscriptionMap.entries()) {
              subscriptions.push({
                eventName,
                subscriberName: subscription.subscriberName,
                subscriptionId,
                createdAt: subscription.createdAt,
                triggerCount: subscription.triggerCount
              });
            }
          }
          return subscriptions.sort((a, b) => b.createdAt - a.createdAt);
        }
        /**
         * Start metrics monitoring
         */
        startMetricsMonitoring() {
          this.metricsUpdateInterval = window.setInterval(() => {
            this.updateMetrics();
          }, 5e3);
        }
        /**
         * Start subscription cleanup for abandoned subscriptions
         */
        startSubscriptionCleanup() {
          this.subscriptionCleanupInterval = window.setInterval(() => {
            this.cleanupAbandonedSubscriptions();
          }, 6e4);
        }
        /**
         * Update performance metrics
         */
        updateMetrics() {
          const now = Date.now();
          const recentEvents = this.eventMetrics.totalEvents;
          const eventCounts = /* @__PURE__ */ new Map();
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            let totalTriggers = 0;
            for (const subscription of subscriptionMap.values()) {
              totalTriggers += subscription.triggerCount;
            }
            eventCounts.set(eventName, totalTriggers);
          }
          this.eventMetrics.topEvents = Array.from(eventCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 10).map(([eventName, count]) => ({ eventName, count }));
          this.eventMetrics.memoryUsage = this.eventMetrics.activeSubscriptions * 256;
        }
        /**
         * Clean up abandoned subscriptions
         */
        cleanupAbandonedSubscriptions() {
          const cutoffTime = Date.now() - 3e5;
          let cleanedCount = 0;
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            const toCleanup = Array.from(subscriptionMap.values()).filter((sub) => !sub.lastTriggered && sub.createdAt < cutoffTime);
            for (const subscription of toCleanup) {
              subscriptionMap.delete(subscription.id);
              cleanedCount++;
              this.eventMetrics.activeSubscriptions--;
            }
            if (subscriptionMap.size === 0) {
              this.subscriptions.delete(eventName);
            }
          }
          if (cleanedCount > 0) {
            Y3K?.debug?.log("UnifiedEventBus", `Cleaned up ${cleanedCount} abandoned subscriptions`);
          }
        }
        /**
         * Generate unique subscription ID
         */
        generateSubscriptionId() {
          return `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }
        /**
         * Destroy the event bus and clean up all resources
         */
        destroy() {
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          if (this.subscriptionCleanupInterval) {
            clearInterval(this.subscriptionCleanupInterval);
            this.subscriptionCleanupInterval = null;
          }
          this.subscriptions.clear();
          this.eventQueue = [];
          this.eventMetrics = {
            totalEvents: 0,
            totalSubscriptions: 0,
            activeSubscriptions: 0,
            eventsPerSecond: 0,
            topEvents: [],
            memoryUsage: 0
          };
          Y3K?.debug?.log("UnifiedEventBus", "Unified event bus destroyed");
          _UnifiedEventBus.instance = null;
        }
      };
      __name(_UnifiedEventBus, "UnifiedEventBus");
      _UnifiedEventBus.instance = null;
      UnifiedEventBus = _UnifiedEventBus;
      unifiedEventBus = UnifiedEventBus.getInstance();
    }
  });

  // src-js/core/performance/PerformanceAnalyzer.ts
  var _FPSCounter, FPSCounter, _PerformanceAnalyzer, PerformanceAnalyzer;
  var init_PerformanceAnalyzer = __esm({
    "src-js/core/performance/PerformanceAnalyzer.ts"() {
      "use strict";
      _FPSCounter = class _FPSCounter {
        constructor() {
          this.frames = 0;
          this.lastTime = performance.now();
          this.rafHandle = null;
          this.currentFPS = 0;
          this.averageFPS = 0;
          this.minFPS = Infinity;
          this.maxFPS = 0;
          this.history = [];
          this.loop = /* @__PURE__ */ __name(() => {
            this.frames++;
            const time = performance.now();
            if (time >= this.lastTime + 1e3) {
              this.currentFPS = this.frames;
              this.history.push(this.currentFPS);
              if (this.history.length > 30) {
                this.history.shift();
              }
              this.averageFPS = Math.round(
                this.history.reduce((a, b) => a + b, 0) / this.history.length
              );
              this.minFPS = Math.min(this.minFPS, this.currentFPS);
              this.maxFPS = Math.max(this.maxFPS, this.currentFPS);
              this.frames = 0;
              this.lastTime = time;
            }
            this.rafHandle = requestAnimationFrame(this.loop);
          }, "loop");
          this.stop = /* @__PURE__ */ __name(() => {
            if (this.rafHandle) {
              cancelAnimationFrame(this.rafHandle);
            }
          }, "stop");
          this.loop();
        }
        /** Returns copy of the last recorded FPS samples (1-sec granularity). */
        getHistory() {
          return [...this.history];
        }
      };
      __name(_FPSCounter, "FPSCounter");
      FPSCounter = _FPSCounter;
      _PerformanceAnalyzer = class _PerformanceAnalyzer {
        constructor(config = {}) {
          this.initialized = false;
          this.performanceHistory = [];
          this.metricsBuffer = /* @__PURE__ */ new Map();
          this.isMonitoring = false;
          this.monitoringTimer = null;
          this._fpsCounter = null;
          this.timedOperations = /* @__PURE__ */ new Map();
          this._buckets = /* @__PURE__ */ new Map();
          // -------------------------------------------------------------------
          // Performance budgets and monitoring -------------------------------
          // -------------------------------------------------------------------
          // Performance budgets (in milliseconds)
          this.performanceBudgets = {
            animationFrame: 16.67,
            // 60 FPS target
            cssVariableUpdate: 2,
            // CSS variable batching
            domObservation: 5,
            // DOM mutation handling
            audioAnalysis: 10,
            // Audio processing
            visualEffects: 8,
            // Visual system updates
            userInteraction: 100,
            // User interaction response
            longTask: 50
            // Long task detection threshold
          };
          // Budget tracking
          this.budgetViolations = /* @__PURE__ */ new Map();
          this.budgetHistory = /* @__PURE__ */ new Map();
          // Auto quality reduction
          this.qualityReductionEnabled = true;
          this.qualityReductionThresholds = {
            minor: 0.7,
            // 70% budget violation triggers minor reduction
            moderate: 0.5,
            // 50% budget violation triggers moderate reduction  
            major: 0.3
            // 30% budget violation triggers major reduction
          };
          this.currentQualityLevel = "high";
          this.lastQualityReduction = 0;
          this.lastQualityIncrease = 0;
          this.qualityRecoveryDelay = 5e3;
          // 5 seconds before attempting quality recovery
          this.qualityIncreaseDelay = 1e4;
          // 10 seconds minimum between quality increases
          this.qualityRecoveryAttempts = 0;
          this.maxQualityRecoveryAttempts = 5;
          // Max recovery attempts before backing off
          this.lastCleanupTime = 0;
          this.cleanupInterval = 6e4;
          // Clean up old records every 60 seconds
          this.maxRecordAge = 3e5;
          // Keep records for maximum 5 minutes
          // Debug safeguards for infinite loop detection
          this.qualityChangeHistory = [];
          this.maxQualityChangesPerMinute = 10;
          // Prevent more than 10 quality changes per minute
          // -------------------------------------------------------------------
          // Simple metric recorder for external systems -----------------------
          // -------------------------------------------------------------------
          /**
           * Lightweight metric recording helper used by visual systems.
           * Currently stores last value per metric name; can be expanded later.
           */
          this._externalMetrics = /* @__PURE__ */ new Map();
          // --- End of static helpers ---
          // ===================================================================
          // PERFORMANCE MARKS AND LONG TASK DETECTION
          // ===================================================================
          // Long task detection
          this.longTaskObserver = null;
          this.longTasks = [];
          this.performanceMarks = /* @__PURE__ */ new Map();
          this.performanceMeasures = /* @__PURE__ */ new Map();
          this.config = {
            enableDebug: config.enableDebug || false,
            monitoringInterval: config.monitoringInterval || 5e3,
            retentionPeriod: config.retentionPeriod || 3e5,
            ...config
          };
          try {
            this._fpsCounter = new FPSCounter();
            this.initializeAdvancedMonitoring();
            this.initialized = true;
            if (this.config.enableDebug) {
              console.log("\u{1F4CA} [PerformanceAnalyzer] Initialized successfully with advanced monitoring.");
            }
          } catch (error) {
            this.initialized = false;
            console.error(
              "CRITICAL: PerformanceAnalyzer failed to initialize.",
              error
            );
          }
          this._buckets = /* @__PURE__ */ new Map();
        }
        recordMetric(name, value) {
          this._externalMetrics.set(name, value);
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] metric '${name}' = ${value}`);
          }
        }
        startMonitoring() {
          if (this.isMonitoring) return;
          this.isMonitoring = true;
          this.monitoringTimer = setInterval(() => {
            this._collectPerformanceMetrics();
          }, this.config.monitoringInterval);
          if (this.config.enableDebug) {
            console.log("\u{1F4CA} [PerformanceAnalyzer] Monitoring started");
          }
        }
        stopMonitoring() {
          if (!this.isMonitoring) return;
          this.isMonitoring = false;
          if (this.monitoringTimer) {
            clearInterval(this.monitoringTimer);
            this.monitoringTimer = null;
          }
          if (this.config.enableDebug) {
            console.log("\u{1F4CA} [PerformanceAnalyzer] Monitoring stopped");
          }
        }
        _collectPerformanceMetrics() {
          const timestamp = performance.now();
          const metrics = {
            timestamp,
            memory: this._getMemoryMetrics(),
            timing: this._getTimingMetrics(),
            fps: this._getFPSMetrics(),
            dom: this._getDOMMetrics(),
            network: this._getNetworkMetrics()
          };
          this.performanceHistory.push(metrics);
          const cutoff = timestamp - this.config.retentionPeriod;
          this.performanceHistory = this.performanceHistory.filter(
            (m) => m.timestamp > cutoff
          );
          this.metricsBuffer.set(timestamp, metrics);
          for (const key of this.metricsBuffer.keys()) {
            if (key < cutoff) {
              this.metricsBuffer.delete(key);
            }
          }
        }
        _getMemoryMetrics() {
          const memoryInfo = performance.memory || {};
          return {
            used: memoryInfo.usedJSHeapSize || 0,
            total: memoryInfo.totalJSHeapSize || 0,
            limit: memoryInfo.jsHeapSizeLimit || 0,
            utilization: memoryInfo.totalJSHeapSize ? memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize * 100 : 0,
            available: memoryInfo.jsHeapSizeLimit ? memoryInfo.jsHeapSizeLimit - memoryInfo.usedJSHeapSize : 0
          };
        }
        _getTimingMetrics() {
          const navigation = performance.getEntriesByType(
            "navigation"
          )[0];
          return {
            domContentLoaded: navigation?.domContentLoadedEventEnd || 0,
            loadComplete: navigation?.loadEventEnd || 0,
            firstPaint: this._getFirstPaint(),
            firstContentfulPaint: this._getFirstContentfulPaint(),
            largestContentfulPaint: this._getLargestContentfulPaint()
          };
        }
        _getFPSMetrics() {
          if (this._fpsCounter) {
            return {
              current: this._fpsCounter.currentFPS,
              average: this._fpsCounter.averageFPS,
              min: this._fpsCounter.minFPS,
              max: this._fpsCounter.maxFPS,
              isEstimate: false
            };
          }
          return { current: 60, average: 60, min: 60, max: 60, isEstimate: true };
        }
        _getDOMMetrics() {
          return {
            elements: document.querySelectorAll("*").length,
            styleSheets: document.styleSheets.length,
            images: document.images.length,
            scripts: document.scripts.length,
            links: document.links.length
          };
        }
        _getNetworkMetrics() {
          const connection = navigator.connection || {};
          return {
            effectiveType: connection.effectiveType || "unknown",
            downlink: connection.downlink || 0,
            rtt: connection.rtt || 0,
            saveData: connection.saveData || false
          };
        }
        _getFirstPaint() {
          const firstPaint = performance.getEntriesByType("paint").find((entry) => entry.name === "first-paint");
          return firstPaint ? firstPaint.startTime : 0;
        }
        _getFirstContentfulPaint() {
          const fcp = performance.getEntriesByType("paint").find((entry) => entry.name === "first-contentful-paint");
          return fcp ? fcp.startTime : 0;
        }
        _getLargestContentfulPaint() {
          const lcpEntries = performance.getEntriesByType("largest-contentful-paint");
          const lastEntry = lcpEntries[lcpEntries.length - 1];
          return lastEntry ? lastEntry.startTime : 0;
        }
        calculateHealthScore() {
          const latestMetrics = this.performanceHistory[this.performanceHistory.length - 1];
          if (!latestMetrics) return 100;
          let score = 100;
          if (latestMetrics.memory.utilization > 80) score -= 20;
          if (latestMetrics.fps.average < 30) score -= 25;
          if (latestMetrics.timing.largestContentfulPaint > 2500) score -= 15;
          return Math.max(0, score);
        }
        getHealthLevel(score) {
          if (score > 80) return "stable";
          if (score > 50) return "warning";
          return "critical";
        }
        // --- Start of methods migrated from PerformanceMonitor ---
        startTiming(operation) {
          return performance.now();
        }
        endTiming(operation, startTime) {
          const duration = performance.now() - startTime;
          if (!this.timedOperations.has(operation)) {
            this.timedOperations.set(operation, []);
          }
          const timings = this.timedOperations.get(operation);
          timings.push(duration);
          if (timings.length > 50) {
            timings.shift();
          }
        }
        getAverageTime(operation) {
          const timings = this.timedOperations.get(operation);
          if (!timings || timings.length === 0) {
            return 0;
          }
          return timings.reduce((a, b) => a + b, 0) / timings.length;
        }
        detectMemoryPressure() {
          const memory = performance.memory;
          if (memory) {
            const used = memory.usedJSHeapSize;
            const total = memory.totalJSHeapSize;
            return used / total > 0.8 ? "high" : "normal";
          }
          return "unknown";
        }
        shouldReduceQuality() {
          const score = this.calculateHealthScore();
          return score < 60;
        }
        /**
         * Emit a trace message when debug mode is enabled.  This method provides a
         * single, centralized entry-point so callers can avoid sprinkling
         * `console.log` statements around.  In the future we might widen this to
         * support different channels (performance panel, remote telemetry, etc.).
         */
        emitTrace(message, data) {
          if (!this.config.enableDebug) return;
          if (data !== void 0) {
            console.log(`\u{1F4CA} [PerformanceAnalyzer] ${message}`, data);
          } else {
            console.log(`\u{1F4CA} [PerformanceAnalyzer] ${message}`);
          }
        }
        /**
         * Throttle helper – returns true when the caller is allowed to perform an update
         * for the supplied bucket. Subsequent calls within `minIntervalMs` will return
         * false until the interval has elapsed. Useful for cheaply rate-limiting CSS
         * variable flushes, expensive observers, etc.
         *
         * @param bucket        Arbitrary string identifying the operation family
         * @param minIntervalMs Minimum time between allowed updates (default 16 ms)
         */
        shouldUpdate(bucket, minIntervalMs = 16) {
          const now = performance.now();
          const nextAllowed = this._buckets.get(bucket) ?? 0;
          if (now >= nextAllowed) {
            this._buckets.set(bucket, now + minIntervalMs);
            return true;
          }
          return false;
        }
        // --- Performance Budget Methods ---
        /**
         * Check if an operation is within performance budget
         */
        isWithinBudget(operation, duration) {
          const budget = this.performanceBudgets[operation];
          if (!budget) return true;
          const withinBudget = duration <= budget;
          if (!withinBudget) {
            this.budgetViolations.set(operation, (this.budgetViolations.get(operation) || 0) + 1);
            if (this.config.enableDebug) {
              console.warn(`\u{1F4CA} [PerformanceAnalyzer] Budget violation: ${operation} took ${duration.toFixed(2)}ms (budget: ${budget}ms)`);
            }
          }
          const history = this.budgetHistory.get(operation) || [];
          history.push({
            duration,
            timestamp: performance.now()
          });
          if (history.length > 100) history.shift();
          this.budgetHistory.set(operation, history);
          return withinBudget;
        }
        /**
         * Time an operation and check against budget
         */
        timeOperation(operation, fn) {
          const start = performance.now();
          const result = fn();
          const duration = performance.now() - start;
          this.isWithinBudget(operation, duration);
          return result;
        }
        /**
         * Time an async operation and check against budget
         */
        async timeOperationAsync(operation, fn) {
          const start = performance.now();
          const result = await fn();
          const duration = performance.now() - start;
          this.isWithinBudget(operation, duration);
          return result;
        }
        /**
         * Get performance budget violations
         */
        getBudgetViolations() {
          return new Map(this.budgetViolations);
        }
        /**
         * Get performance budget statistics
         */
        getBudgetStats() {
          const stats = {};
          for (const [operation, budget] of Object.entries(this.performanceBudgets)) {
            const violations = this.budgetViolations.get(operation) || 0;
            const history = this.budgetHistory.get(operation) || [];
            const durations = history.map((violation) => violation.duration);
            const averageTime = durations.length > 0 ? durations.reduce((a, b) => a + b, 0) / durations.length : 0;
            const maxTime = durations.length > 0 ? Math.max(...durations) : 0;
            stats[operation] = {
              budget,
              violations,
              averageTime,
              maxTime
            };
          }
          return stats;
        }
        /**
         * Update performance budget for an operation
         */
        updateBudget(operation, budgetMs) {
          this.performanceBudgets[operation] = budgetMs;
          if (this.config.enableDebug) {
            console.log(`\u{1F4CA} [PerformanceAnalyzer] Updated budget for ${operation}: ${budgetMs}ms`);
          }
        }
        /**
         * Clear budget violation history
         */
        clearBudgetHistory() {
          this.budgetViolations.clear();
          this.budgetHistory.clear();
        }
        // --- End of migrated methods ---
        destroy() {
          this.stopMonitoring();
          if (this._fpsCounter) {
            this._fpsCounter.stop();
          }
          if (this.longTaskObserver) {
            this.longTaskObserver.disconnect();
            this.longTaskObserver = null;
          }
          this.performanceHistory = [];
          this.metricsBuffer.clear();
          this.timedOperations.clear();
          this.clearPerformanceTimeline();
          this.resetBudgetTracking();
          if (this.config.enableDebug) {
            console.log("\u{1F4CA} [PerformanceAnalyzer] Destroyed and cleaned up.");
          }
        }
        /**
         * Lightweight, synchronous heuristic to decide whether the current device
         * should be treated as "low-end". This avoids the async overhead of
         * `DeviceCapabilityDetector` while still giving callers a fast gate for
         * performance-heavy logic.
         *
         * The heuristic intentionally stays conservative: we only mark devices as
         * low-end when *multiple* indicators point in that direction to minimise
         * false-positives on mid-tier hardware.
         */
        static isLowEndDevice() {
          if (this._isLowEndCache !== null) {
            return this._isLowEndCache;
          }
          try {
            const deviceMemory = navigator.deviceMemory ?? 4;
            const cpuCores = navigator.hardwareConcurrency ?? 4;
            const memoryFlag = deviceMemory < 4;
            const coreFlag = cpuCores <= 2;
            const connection = navigator.connection || {};
            const effectiveType = connection.effectiveType;
            const slowNetworkFlag = ["slow-2g", "2g"].includes(effectiveType ?? "");
            const isLowEnd = memoryFlag && coreFlag || memoryFlag && slowNetworkFlag;
            this._isLowEndCache = isLowEnd;
            return isLowEnd;
          } catch {
            this._isLowEndCache = false;
            return false;
          }
        }
        /**
         * Returns median FPS using the most recent N one-second samples (default 5).
         * Falls back to current FPS when insufficient samples.
         */
        getMedianFPS(sampleWindowSeconds = 5) {
          if (!this._fpsCounter) return 60;
          const hist = this._fpsCounter.getHistory?.() || [];
          const samples = hist.slice(-sampleWindowSeconds);
          if (!samples.length) return this._fpsCounter.currentFPS || 60;
          const sorted = [...samples].sort((a, b) => a - b);
          const mid = Math.floor(sorted.length / 2);
          return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        }
        /**
         * Capture a one-off 60 s (or custom) performance baseline and trigger a JSON
         * download so developers can commit the artefact under
         * `docs/perf-baselines/`.
         *
         * Example (DevTools):
         *   await year3000System.performanceAnalyzer.startBaselineCapture("Home");
         */
        async startBaselineCapture(viewName = "unknown", durationMs = 6e4) {
          if (!this.isMonitoring) {
            this.startMonitoring();
          }
          const start = Date.now();
          if (this.config.enableDebug) {
            console.log(
              `\u{1F4CA} [PerformanceAnalyzer] Baseline capture for "${viewName}" started`
            );
          }
          await new Promise((r) => setTimeout(r, durationMs));
          if (this.config.enableDebug) {
            console.log(
              `\u{1F4CA} [PerformanceAnalyzer] Baseline capture complete \u2013 ${this.performanceHistory.length} samples in ${(Date.now() - start) / 1e3}s`
            );
          }
          const artefact = {
            view: viewName,
            capturedAt: (/* @__PURE__ */ new Date()).toISOString(),
            durationMs,
            samples: this.performanceHistory
          };
          try {
            const blob = new Blob([JSON.stringify(artefact, null, 2)], {
              type: "application/json"
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${viewName}_${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}_baseline.json`;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 5e3);
          } catch (err) {
            console.warn(
              "[PerformanceAnalyzer] Unable to trigger baseline download",
              err
            );
          }
          return [...this.performanceHistory];
        }
        /**
         * Initialize performance monitoring with marks and long task detection
         */
        initializeAdvancedMonitoring() {
          if (typeof PerformanceObserver === "undefined") return;
          try {
            this.longTaskObserver = new PerformanceObserver((list) => {
              const entries = list.getEntries();
              for (const entry of entries) {
                this.longTasks.push(entry);
                if (entry.duration > 50) {
                  this.trackBudget("longTask", entry.duration);
                  if (this.config.enableDebug) {
                    console.warn(`\u{1F40C} [PerformanceAnalyzer] Long task detected: ${entry.duration.toFixed(2)}ms`);
                  }
                }
              }
              const cutoff = performance.now() - 3e4;
              this.longTasks = this.longTasks.filter((task) => task.startTime > cutoff);
            });
            this.longTaskObserver.observe({ entryTypes: ["longtask"] });
            if (this.config.enableDebug) {
              console.log("\u{1F4CA} [PerformanceAnalyzer] Advanced monitoring initialized - long task detection active");
            }
          } catch (error) {
            console.warn("[PerformanceAnalyzer] Could not initialize long task observer:", error);
          }
        }
        /**
         * Mark the start of a performance-critical operation
         */
        markStart(operation) {
          const markName = `${operation}-start`;
          performance.mark(markName);
          this.performanceMarks.set(operation, performance.now());
          if (this.config.enableDebug) {
            console.log(`\u{1F3AF} [PerformanceAnalyzer] Mark start: ${operation}`);
          }
        }
        /**
         * Mark the end of a performance-critical operation and measure duration
         */
        markEnd(operation) {
          const startTime = this.performanceMarks.get(operation);
          if (!startTime) {
            console.warn(`[PerformanceAnalyzer] No start mark found for operation: ${operation}`);
            return 0;
          }
          const endTime = performance.now();
          const duration = endTime - startTime;
          const startMarkName = `${operation}-start`;
          const endMarkName = `${operation}-end`;
          const measureName = `${operation}-duration`;
          try {
            performance.mark(endMarkName);
            performance.measure(measureName, startMarkName, endMarkName);
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(`[PerformanceAnalyzer] Could not create measure for ${operation}:`, error);
            }
          }
          this.performanceMeasures.set(operation, {
            start: startTime,
            end: endTime,
            duration
          });
          this.trackBudget(operation, duration);
          this.performanceMarks.delete(operation);
          if (this.config.enableDebug) {
            console.log(`\u{1F3C1} [PerformanceAnalyzer] Mark end: ${operation} (${duration.toFixed(2)}ms)`);
          }
          return duration;
        }
        /**
         * Get recent long tasks that may be affecting performance
         */
        getRecentLongTasks(timeframeMs = 1e4) {
          const cutoff = performance.now() - timeframeMs;
          return this.longTasks.filter((task) => task.startTime > cutoff);
        }
        /**
         * Get performance timeline with marks and measures
         */
        getPerformanceTimeline() {
          return {
            marks: new Map(this.performanceMarks),
            measures: new Map(this.performanceMeasures),
            longTasks: [...this.longTasks]
          };
        }
        /**
         * Create a performance timing wrapper for functions
         */
        withTiming(operation, fn) {
          this.markStart(operation);
          try {
            const result = fn();
            return result;
          } finally {
            this.markEnd(operation);
          }
        }
        /**
         * Create a performance timing wrapper for async functions
         */
        async withTimingAsync(operation, fn) {
          this.markStart(operation);
          try {
            const result = await fn();
            return result;
          } finally {
            this.markEnd(operation);
          }
        }
        /**
         * Get performance summary for debugging
         */
        getPerformanceSummary() {
          const recentLongTasks = this.getRecentLongTasks(5e3).length;
          const budgetViolations = {};
          for (const [operation, count] of this.budgetViolations.entries()) {
            budgetViolations[operation] = count;
          }
          const memory = this._getMemoryMetrics();
          const fps = this._getFPSMetrics();
          return {
            recentLongTasks,
            budgetViolations,
            currentQuality: this.currentQualityLevel,
            averageFPS: fps.average,
            memoryUsage: memory.utilization
          };
        }
        /**
         * Clear performance timeline data
         */
        clearPerformanceTimeline() {
          this.performanceMarks.clear();
          this.performanceMeasures.clear();
          this.longTasks = [];
          try {
            performance.clearMarks();
            performance.clearMeasures();
          } catch (error) {
          }
        }
        // ===================================================================
        // MEMORY MANAGEMENT AND CLEANUP
        // ===================================================================
        /**
         * Clean up old budget violation records to prevent memory leaks
         */
        cleanupOldRecords() {
          const now = performance.now();
          if (now - this.lastCleanupTime < this.cleanupInterval) return;
          const cutoff = now - this.maxRecordAge;
          let totalRecordsRemoved = 0;
          for (const [operation, history] of this.budgetHistory.entries()) {
            const originalLength = history.length;
            const filteredHistory = history.filter((violation) => violation.timestamp > cutoff);
            if (filteredHistory.length !== originalLength) {
              this.budgetHistory.set(operation, filteredHistory);
              totalRecordsRemoved += originalLength - filteredHistory.length;
            }
            if (filteredHistory.length === 0) {
              this.budgetHistory.delete(operation);
              this.budgetViolations.delete(operation);
            }
          }
          this.lastCleanupTime = now;
          if (this.config.enableDebug && totalRecordsRemoved > 0) {
            console.log(`[PerformanceAnalyzer] Cleaned up ${totalRecordsRemoved} old violation records`);
          }
        }
        /**
         * Detect potential infinite loops in quality changes
         */
        detectInfiniteLoop() {
          const now = performance.now();
          const oneMinuteAgo = now - 6e4;
          this.qualityChangeHistory = this.qualityChangeHistory.filter((change) => change.timestamp > oneMinuteAgo);
          if (this.qualityChangeHistory.length >= this.maxQualityChangesPerMinute) {
            if (this.config.enableDebug) {
              console.error(`[PerformanceAnalyzer] INFINITE LOOP DETECTED: ${this.qualityChangeHistory.length} quality changes in the last minute. Disabling automatic quality adjustment.`);
              console.error("[PerformanceAnalyzer] Quality change history:", this.qualityChangeHistory);
            }
            this.qualityReductionEnabled = false;
            if (typeof window !== "undefined" && window.dispatchEvent) {
              window.dispatchEvent(new CustomEvent("performance:infinite-loop-detected", {
                detail: {
                  changeCount: this.qualityChangeHistory.length,
                  history: [...this.qualityChangeHistory],
                  timestamp: Date.now()
                }
              }));
            }
            return true;
          }
          return false;
        }
        /**
         * Record quality change for infinite loop detection
         */
        recordQualityChange(action, level) {
          this.qualityChangeHistory.push({
            action,
            level,
            timestamp: performance.now()
          });
        }
        // ===================================================================
        // PERFORMANCE BUDGET AND QUALITY REDUCTION SYSTEM
        // ===================================================================
        /**
         * Track operation against performance budget
         */
        trackBudget(operation, timeMs) {
          const budget = this.performanceBudgets[operation];
          if (!budget) return;
          this.cleanupOldRecords();
          if (timeMs > budget) {
            const violationCount = this.budgetViolations.get(operation) || 0;
            this.budgetViolations.set(operation, violationCount + 1);
            const history = this.budgetHistory.get(operation) || [];
            history.push({
              duration: timeMs,
              timestamp: performance.now()
            });
            if (history.length > 100) history.shift();
            this.budgetHistory.set(operation, history);
            if (this.qualityReductionEnabled) {
              this.checkQualityReduction(operation, timeMs, budget);
            }
          }
        }
        /**
         * Check if quality reduction is needed based on budget violations
         */
        checkQualityReduction(operation, actualTime, budget) {
          const violationRatio = actualTime / budget;
          const now = performance.now();
          if (now - this.lastQualityReduction < 1e3) return;
          let targetQuality = null;
          if (violationRatio > 3 && this.currentQualityLevel !== "minimal") {
            targetQuality = "minimal";
          } else if (violationRatio > 2 && this.currentQualityLevel === "ultra") {
            targetQuality = "high";
          } else if (violationRatio > 1.5 && ["ultra", "high"].includes(this.currentQualityLevel)) {
            targetQuality = this.currentQualityLevel === "ultra" ? "high" : "medium";
          }
          if (targetQuality && targetQuality !== this.currentQualityLevel) {
            this.reduceQuality(targetQuality, operation, violationRatio);
          }
        }
        /**
         * Reduce quality level and notify systems
         */
        reduceQuality(newLevel, triggerOperation, violationRatio) {
          const oldLevel = this.currentQualityLevel;
          this.currentQualityLevel = newLevel;
          this.lastQualityReduction = performance.now();
          this.qualityRecoveryAttempts = 0;
          this.recordQualityChange("decrease", newLevel);
          if (typeof window !== "undefined" && window.dispatchEvent) {
            window.dispatchEvent(new CustomEvent("performance:quality-reduced", {
              detail: {
                oldLevel,
                newLevel,
                triggerOperation,
                violationRatio,
                timestamp: Date.now()
              }
            }));
          }
          if (this.config.enableDebug) {
            console.warn(`[PerformanceAnalyzer] Quality reduced: ${oldLevel} \u2192 ${newLevel} (${triggerOperation}: ${violationRatio.toFixed(2)}x budget)`);
          }
        }
        /**
         * Attempt to recover quality if performance has improved
         */
        checkQualityRecovery() {
          const now = performance.now();
          if (this.detectInfiniteLoop()) {
            return;
          }
          if (now - this.lastQualityReduction < this.qualityRecoveryDelay) return;
          if (now - this.lastQualityIncrease < this.qualityIncreaseDelay) return;
          if (this.currentQualityLevel === "ultra") {
            this.qualityRecoveryAttempts = 0;
            return;
          }
          if (this.qualityRecoveryAttempts >= this.maxQualityRecoveryAttempts) {
            const backoffDelay = this.qualityIncreaseDelay * Math.pow(2, this.qualityRecoveryAttempts - this.maxQualityRecoveryAttempts);
            if (now - this.lastQualityIncrease < backoffDelay) {
              if (this.config.enableDebug) {
                console.log(`[PerformanceAnalyzer] Quality recovery in backoff mode. Next attempt in ${(backoffDelay - (now - this.lastQualityIncrease)).toFixed(0)}ms`);
              }
              return;
            }
          }
          const recentViolations = this.getRecentBudgetViolations(2e3);
          const violationCount = Array.from(recentViolations.values()).reduce((sum, count) => sum + count, 0);
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Quality recovery check: ${violationCount} recent violations, attempt ${this.qualityRecoveryAttempts + 1}/${this.maxQualityRecoveryAttempts}`);
          }
          if (violationCount === 0) {
            const newLevel = this.getNextQualityLevel(this.currentQualityLevel);
            if (newLevel !== this.currentQualityLevel) {
              this.qualityRecoveryAttempts++;
              this.increaseQuality(newLevel);
            }
          } else {
            this.qualityRecoveryAttempts = 0;
          }
        }
        /**
         * Get recent budget violations within timeframe
         */
        getRecentBudgetViolations(timeframeMs) {
          const cutoff = performance.now() - timeframeMs;
          const recentViolations = /* @__PURE__ */ new Map();
          for (const [operation, history] of this.budgetHistory.entries()) {
            const recentCount = history.filter((violation) => violation.timestamp > cutoff).length;
            if (recentCount > 0) {
              recentViolations.set(operation, recentCount);
            }
          }
          return recentViolations;
        }
        /**
         * Get next higher quality level
         */
        getNextQualityLevel(current) {
          const levels = ["minimal", "low", "medium", "high", "ultra"];
          const currentIndex = levels.indexOf(current);
          return currentIndex < levels.length - 1 ? levels[currentIndex + 1] : current;
        }
        /**
         * Increase quality level
         */
        increaseQuality(newLevel) {
          const oldLevel = this.currentQualityLevel;
          this.currentQualityLevel = newLevel;
          this.lastQualityIncrease = performance.now();
          if (newLevel === "ultra") {
            this.qualityRecoveryAttempts = 0;
          }
          this.recordQualityChange("increase", newLevel);
          if (typeof window !== "undefined" && window.dispatchEvent) {
            window.dispatchEvent(new CustomEvent("performance:quality-increased", {
              detail: {
                oldLevel,
                newLevel,
                recoveryAttempt: this.qualityRecoveryAttempts,
                timestamp: Date.now()
              }
            }));
          }
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Quality increased: ${oldLevel} \u2192 ${newLevel} (attempt ${this.qualityRecoveryAttempts})`);
          }
        }
        /**
         * Get current quality level
         */
        getCurrentQualityLevel() {
          return this.currentQualityLevel;
        }
        /**
         * Get budget violation summary
         */
        getBudgetViolationSummary() {
          return new Map(this.budgetViolations);
        }
        /**
         * Reset budget tracking
         */
        resetBudgetTracking() {
          this.budgetViolations.clear();
          this.budgetHistory.clear();
          this.lastCleanupTime = 0;
          this.qualityRecoveryAttempts = 0;
        }
        /**
         * Configure quality reduction system
         */
        configureQualityReduction(enabled, thresholds) {
          this.qualityReductionEnabled = enabled;
          if (thresholds) {
            this.qualityReductionThresholds = { ...this.qualityReductionThresholds, ...thresholds };
          }
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Quality reduction ${enabled ? "enabled" : "disabled"}`);
          }
        }
        /**
         * Reset quality system after fixing infinite loop issues
         */
        resetQualitySystem() {
          this.qualityChangeHistory = [];
          this.qualityRecoveryAttempts = 0;
          this.lastQualityReduction = 0;
          this.lastQualityIncrease = 0;
          this.qualityReductionEnabled = true;
          this.currentQualityLevel = "high";
          if (this.config.enableDebug) {
            console.log("[PerformanceAnalyzer] Quality system reset - infinite loop protection cleared");
          }
        }
      };
      __name(_PerformanceAnalyzer, "PerformanceAnalyzer");
      _PerformanceAnalyzer._isLowEndCache = null;
      PerformanceAnalyzer = _PerformanceAnalyzer;
    }
  });

  // src-js/core/performance/DeviceCapabilityDetector.ts
  var _DeviceCapabilityDetector, DeviceCapabilityDetector;
  var init_DeviceCapabilityDetector = __esm({
    "src-js/core/performance/DeviceCapabilityDetector.ts"() {
      "use strict";
      _DeviceCapabilityDetector = class _DeviceCapabilityDetector {
        constructor(config = {}) {
          this.deviceCapabilities = null;
          this.isInitialized = false;
          this.config = {
            enableDebug: config.enableDebug || false,
            runStressTests: config.runStressTests !== false,
            ...config
          };
          if (this.config.enableDebug) {
            console.log("\u{1F50D} [DeviceCapabilityDetector] Initialized");
          }
        }
        async initialize() {
          if (this.isInitialized) {
            return this.deviceCapabilities;
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F50D} [DeviceCapabilityDetector] Starting capability detection..."
            );
          }
          this.deviceCapabilities = {
            memory: {
              total: navigator.deviceMemory || 4,
              level: this._detectMemoryLevel(),
              jsHeapSizeLimit: performance.memory?.jsHeapSizeLimit || 0,
              estimatedAvailable: this._estimateAvailableMemory()
            },
            cpu: {
              cores: navigator.hardwareConcurrency || 2,
              level: this._detectCPULevel(),
              estimatedScore: this._calculateCPUScore()
            },
            gpu: {
              supportsWebGL: this._detectWebGLSupport(),
              supportsWebGL2: this._detectWebGL2Support(),
              maxTextureSize: this._getMaxTextureSize(),
              level: this._detectGPULevel(),
              vendor: this._getGPUVendor(),
              renderer: this._getGPURenderer()
            },
            browser: {
              supportsOffscreenCanvas: this._detectOffscreenCanvasSupport(),
              supportsWorkers: this._detectWorkerSupport(),
              supportsSharedArrayBuffer: this._detectSharedArrayBufferSupport(),
              supportsWASM: this._detectWASMSupport(),
              supportsCSSHoudini: this._detectCSSHoudiniSupport()
            },
            display: {
              pixelRatio: window.devicePixelRatio || 1,
              refreshRate: await this._detectRefreshRate(),
              colorGamut: this._detectColorGamut(),
              contrastRatio: this._detectContrastCapability(),
              reducedMotion: this._detectReducedMotion()
            },
            network: {
              effectiveType: navigator.connection?.effectiveType || "unknown",
              downlink: navigator.connection?.downlink || 0,
              rtt: navigator.connection?.rtt || 0,
              saveData: navigator.connection?.saveData || false
            },
            overall: "detecting"
          };
          if (this.config.runStressTests) {
            await this._runCapabilityTests();
          }
          this.deviceCapabilities.overall = this._calculateOverallPerformanceLevel();
          this.isInitialized = true;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F4CA} [DeviceCapabilityDetector] Capabilities detected:",
              this.deviceCapabilities
            );
          }
          return this.deviceCapabilities;
        }
        _detectMemoryLevel() {
          const memory = navigator.deviceMemory || 4;
          if (memory >= 8) return "high";
          if (memory >= 4) return "medium";
          return "low";
        }
        _estimateAvailableMemory() {
          if (performance.memory) {
            return performance.memory.jsHeapSizeLimit - performance.memory.usedJSHeapSize;
          }
          return (navigator.deviceMemory || 4) * 1024 * 1024 * 1024 * 0.7;
        }
        _detectCPULevel() {
          const cores = navigator.hardwareConcurrency || 2;
          if (cores >= 8) return "high";
          if (cores >= 4) return "medium";
          return "low";
        }
        _calculateCPUScore() {
          const start = performance.now();
          let result = 0;
          for (let i = 0; i < 1e5; i++) {
            result += Math.sin(i) * Math.cos(i);
          }
          const duration = performance.now() - start;
          if (duration < 10) return "high";
          if (duration < 25) return "medium";
          return "low";
        }
        _detectWebGLSupport() {
          try {
            const canvas = document.createElement("canvas");
            return !!(canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
          } catch (e) {
            return false;
          }
        }
        _detectWebGL2Support() {
          try {
            const canvas = document.createElement("canvas");
            return !!canvas.getContext("webgl2");
          } catch (e) {
            return false;
          }
        }
        _getMaxTextureSize() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            return gl ? gl.getParameter(gl.MAX_TEXTURE_SIZE) : 0;
          } catch (e) {
            return 0;
          }
        }
        _getGPUVendor() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) return "unknown";
            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            return debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "unknown";
          } catch (e) {
            return "unknown";
          }
        }
        _getGPURenderer() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) return "unknown";
            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            return debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "unknown";
          } catch (e) {
            return "unknown";
          }
        }
        _detectGPULevel() {
          const renderer = this._getGPURenderer().toLowerCase();
          if (/rtx|radeon rx|gtx 16|gtx 20|apple m[1-9]/.test(renderer)) {
            return "high";
          }
          if (/gtx|radeon|intel iris|intel uhd/.test(renderer)) {
            return "medium";
          }
          return "low";
        }
        _detectOffscreenCanvasSupport() {
          return typeof OffscreenCanvas !== "undefined";
        }
        _detectWorkerSupport() {
          return typeof Worker !== "undefined";
        }
        _detectSharedArrayBufferSupport() {
          return typeof SharedArrayBuffer !== "undefined";
        }
        _detectWASMSupport() {
          return typeof WebAssembly !== "undefined";
        }
        _detectCSSHoudiniSupport() {
          return typeof CSS !== "undefined" && CSS.paintWorklet !== void 0;
        }
        async _detectRefreshRate() {
          return new Promise((resolve) => {
            let lastTime = performance.now();
            let frameCount = 0;
            const samples = [];
            const measure = /* @__PURE__ */ __name(() => {
              const currentTime = performance.now();
              const delta = currentTime - lastTime;
              samples.push(1e3 / delta);
              lastTime = currentTime;
              frameCount++;
              if (frameCount < 10) {
                requestAnimationFrame(measure);
              } else {
                const avgFPS = samples.reduce((a, b) => a + b, 0) / samples.length;
                resolve(Math.round(avgFPS));
              }
            }, "measure");
            requestAnimationFrame(measure);
          });
        }
        _detectColorGamut() {
          if (window.matchMedia("(color-gamut: p3)").matches) return "p3";
          if (window.matchMedia("(color-gamut: srgb)").matches) return "srgb";
          return "limited";
        }
        _detectContrastCapability() {
          if (window.matchMedia("(dynamic-range: high)").matches) return "high";
          if (window.matchMedia("(contrast: high)").matches) return "high";
          return "standard";
        }
        _detectReducedMotion() {
          return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        }
        async _runCapabilityTests() {
          if (this.deviceCapabilities) {
            this.deviceCapabilities.gpu.stressTestScore = await this._runGPUStressTest();
            this.deviceCapabilities.memory.stressTestScore = await this._runMemoryStressTest();
          }
          if (this.config.enableDebug) {
            console.log("\u26A1 [DeviceCapabilityDetector] Capability tests completed");
          }
        }
        async _runGPUStressTest() {
          return 0;
        }
        async _runMemoryStressTest() {
          return 0;
        }
        _calculateOverallPerformanceLevel() {
          if (!this.deviceCapabilities) return "low";
          const scores = {
            memory: this.deviceCapabilities.memory.level === "high" ? 3 : this.deviceCapabilities.memory.level === "medium" ? 2 : 1,
            cpu: this.deviceCapabilities.cpu.level === "high" ? 3 : this.deviceCapabilities.cpu.level === "medium" ? 2 : 1,
            gpu: this.deviceCapabilities.gpu.level === "high" ? 3 : this.deviceCapabilities.gpu.level === "medium" ? 2 : 1,
            browser: (this.deviceCapabilities.gpu.supportsWebGL ? 1 : 0) + (this.deviceCapabilities.browser.supportsWorkers ? 1 : 0) + (this.deviceCapabilities.browser.supportsOffscreenCanvas ? 1 : 0)
          };
          const totalScore = scores.memory + scores.cpu + scores.gpu + Math.min(scores.browser, 3);
          if (totalScore >= 10) return "high";
          if (totalScore >= 7) return "medium";
          return "low";
        }
        getCapabilities() {
          if (!this.isInitialized) {
            console.warn(
              "[DeviceCapabilityDetector] Not initialized - call initialize() first"
            );
            return null;
          }
          return this.deviceCapabilities;
        }
        destroy() {
          this.deviceCapabilities = null;
          this.isInitialized = false;
          if (this.config.enableDebug) {
            console.log("\u{1F50D} [DeviceCapabilityDetector] Destroyed");
          }
        }
        /**
         * Recommend a performance-quality label that callers (e.g., visual systems)
         * can use to pick an appropriate performance profile.
         * Returns one of `"low" | "balanced" | "high"`.
         */
        recommendPerformanceQuality() {
          if (!this.isInitialized || !this.deviceCapabilities) {
            return "balanced";
          }
          switch (this.deviceCapabilities.overall) {
            case "high":
              return "high";
            case "medium":
              return "balanced";
            case "low":
            default:
              return "low";
          }
        }
      };
      __name(_DeviceCapabilityDetector, "DeviceCapabilityDetector");
      DeviceCapabilityDetector = _DeviceCapabilityDetector;
    }
  });

  // src-js/utils/core/MusicalLerpOrchestrator.ts
  var MusicalLerpOrchestrator_exports = {};
  __export(MusicalLerpOrchestrator_exports, {
    MusicalLerpOrchestrator: () => MusicalLerpOrchestrator,
    musicalLerpOrchestrator: () => musicalLerpOrchestrator
  });
  var _MusicalLerpOrchestrator, MusicalLerpOrchestrator, musicalLerpOrchestrator;
  var init_MusicalLerpOrchestrator = __esm({
    "src-js/utils/core/MusicalLerpOrchestrator.ts"() {
      "use strict";
      _MusicalLerpOrchestrator = class _MusicalLerpOrchestrator {
        constructor(enableDebug = false) {
          // Base half-life values for different animation types
          this.baseHalfLifeValues = {
            pulse: 0.08,
            // Beat-synchronized effects
            flow: 0.15,
            // Continuous movement (parallax, gradients)
            emotional: 0.25,
            // Color and emotional transitions
            organic: 0.12,
            // Particle and breathing effects
            crystalline: 0.06
            // Precise, geometric animations
          };
          // Beat phase timing configuration (as percentage of beat interval)
          this.beatPhaseConfig = {
            attack: { start: 0, end: 0.15, baseMultiplier: 0.3 },
            // 0-15% of beat
            sustain: { start: 0.15, end: 0.5, baseMultiplier: 1 },
            // 15-50% of beat
            decay: { start: 0.5, end: 0.85, baseMultiplier: 1.4 },
            // 50-85% of beat
            rest: { start: 0.85, end: 1, baseMultiplier: 0.8 }
            // 85-100% of beat
          };
          // Musical modulation ranges for consciousness calculation
          this.modulationConfig = {
            tempo: {
              reference: 120,
              // Reference BPM (120)
              minFactor: 0.6,
              // Minimum tempo influence
              maxFactor: 1.8,
              // Maximum tempo influence
              curve: 0.3
              // Exponential curve factor
            },
            energy: {
              attackRange: 0.7,
              // Energy influence on attack speed
              decayRange: 0.5,
              // Energy influence on decay sustain
              baseline: 1
              // Baseline multiplier
            },
            danceability: {
              fluidityMin: 0.5,
              // Minimum fluidity factor
              fluidityMax: 1,
              // Maximum fluidity factor
              organicThreshold: 0.6
              // Threshold for organic behavior
            },
            temperature: {
              neutral: 4e3,
              // Neutral temperature (4000K)
              range: 16e3,
              // Temperature range for calculation
              warmthInfluence: 0.3,
              // Warm temperature flow influence
              coolPrecision: 0.4
              // Cool temperature precision influence
            }
          };
          this.debugMode = false;
          this.debugMode = enableDebug;
        }
        /**
         * Calculate music-aware LERP parameters for consciousness smoothing
         */
        calculateMusicalLerp(musicContext, animationType = "flow", baseHalfLife) {
          return this.calculateMusicalLerpWithPerformance(
            musicContext,
            animationType,
            baseHalfLife,
            null
            // No performance context
          );
        }
        /**
         * Calculate performance-aware musical LERP parameters for consciousness smoothing
         */
        calculateMusicalLerpWithPerformance(musicContext, animationType = "flow", baseHalfLife, performanceContext, performanceParams) {
          const startTime = performance.now();
          const baseHalf = baseHalfLife || this.baseHalfLifeValues[animationType];
          const usePerformanceOptimizations = performanceParams && performanceContext;
          let performanceOptimized = false;
          let tempoFactor = 1;
          let energyFactor = 1;
          let danceabilityFactor = 1;
          let temperatureFactor = 1;
          let beatPhaseFactor = 1;
          if (usePerformanceOptimizations && performanceParams) {
            performanceOptimized = true;
            if (!performanceParams.useSimplifiedCalculations) {
              tempoFactor = this.calculateTempoFactor(musicContext.tempo);
              if (performanceParams.enableEnergyModulation) {
                energyFactor = this.calculateEnergyFactor(musicContext.energy);
              }
              danceabilityFactor = this.calculateDanceabilityFactor(musicContext.danceability);
              if (performanceParams.enableTemperatureMapping) {
                temperatureFactor = this.calculateTemperatureFactor(musicContext.emotionalTemperature);
              }
              if (performanceParams.enableBeatPhase) {
                beatPhaseFactor = this.calculateBeatPhaseFactor(
                  musicContext.beatPhase,
                  musicContext.timeSinceLastBeat,
                  musicContext.beatInterval
                );
              }
            } else {
              tempoFactor = Math.max(0.7, Math.min(1.5, musicContext.tempo / 120));
              if (performanceParams.enableEnergyModulation) {
                energyFactor = 1 + musicContext.energy * 0.2;
              }
              danceabilityFactor = 0.8 + musicContext.danceability * 0.4;
            }
          } else {
            tempoFactor = this.calculateTempoFactor(musicContext.tempo);
            energyFactor = this.calculateEnergyFactor(musicContext.energy);
            danceabilityFactor = this.calculateDanceabilityFactor(musicContext.danceability);
            temperatureFactor = this.calculateTemperatureFactor(musicContext.emotionalTemperature);
            beatPhaseFactor = this.calculateBeatPhaseFactor(
              musicContext.beatPhase,
              musicContext.timeSinceLastBeat,
              musicContext.beatInterval
            );
          }
          let combinedFactor = tempoFactor * energyFactor * danceabilityFactor * temperatureFactor * beatPhaseFactor;
          if (performanceParams?.performanceMultiplier) {
            combinedFactor *= performanceParams.performanceMultiplier;
          }
          if (performanceParams?.complexityReduction && performanceParams.complexityReduction > 0) {
            const neutralFactor = 1;
            const reducedVariation = 1 - performanceParams.complexityReduction;
            combinedFactor = neutralFactor + (combinedFactor - neutralFactor) * reducedVariation;
          }
          const finalHalfLife = baseHalf * combinedFactor;
          let attackMultiplier;
          let decayMultiplier;
          if (usePerformanceOptimizations && performanceParams?.useSimplifiedCalculations) {
            attackMultiplier = musicContext.energy < 0.5 ? 1.2 : 0.8;
            decayMultiplier = musicContext.valence > 0.5 ? 1.3 : 1;
          } else {
            attackMultiplier = this.calculateAttackMultiplier(musicContext.energy, musicContext.beatPhase);
            decayMultiplier = this.calculateDecayMultiplier(musicContext.energy, musicContext.valence);
          }
          const fluidityFactor = this.calculateFluidityFactor(musicContext.danceability, musicContext.emotionalTemperature);
          const consciousnessLevel = this.calculateConsciousnessLevel(musicContext);
          const result = {
            halfLife: Math.max(0.01, Math.min(2, finalHalfLife)),
            // Clamp to reasonable bounds
            attackMultiplier,
            decayMultiplier,
            fluidityFactor,
            consciousnessLevel,
            performanceOptimized
          };
          if (this.debugMode) {
            result.debugInfo = {
              tempoFactor,
              energyFactor,
              danceabilityFactor,
              temperatureFactor,
              beatPhaseFactor
            };
            if (performanceParams?.performanceMultiplier !== void 0) {
              result.debugInfo.performanceMultiplier = performanceParams.performanceMultiplier;
            }
            if (performanceParams?.complexityReduction !== void 0) {
              result.debugInfo.complexityReduction = performanceParams.complexityReduction;
            }
            const processingTime = performance.now() - startTime;
            if (processingTime > 0.5) {
              console.log(`\u{1F3B5} [MusicalLerpOrchestrator] Calculation time: ${processingTime.toFixed(3)}ms (performance-optimized: ${performanceOptimized})`);
            }
          }
          return result;
        }
        /**
         * Calculate tempo influence on LERP responsiveness
         * Faster tempo = snappier response, slower tempo = flowing movement
         */
        calculateTempoFactor(tempo) {
          const { reference, minFactor, maxFactor, curve } = this.modulationConfig.tempo;
          const normalizedTempo = tempo / reference;
          const factor = Math.pow(normalizedTempo, curve);
          return Math.max(minFactor, Math.min(maxFactor, factor));
        }
        /**
         * Calculate energy influence on attack and decay characteristics
         * High energy = aggressive smoothing, low energy = gentle smoothing
         */
        calculateEnergyFactor(energy) {
          const { baseline } = this.modulationConfig.energy;
          return baseline + energy * 0.3;
        }
        /**
         * Calculate danceability influence on organic fluidity
         * High danceability = organic fluid transitions, low = structured
         */
        calculateDanceabilityFactor(danceability) {
          const { fluidityMin, fluidityMax } = this.modulationConfig.danceability;
          return fluidityMin + danceability * (fluidityMax - fluidityMin);
        }
        /**
         * Calculate emotional temperature influence on movement style
         * Warm temperatures = flowing, cool temperatures = crystalline precise
         */
        calculateTemperatureFactor(emotionalTemperature) {
          const { neutral, range, warmthInfluence } = this.modulationConfig.temperature;
          const temperatureRange = (emotionalTemperature - neutral) / range;
          return 1 + temperatureRange * warmthInfluence;
        }
        /**
         * Calculate beat phase influence for rhythmic consciousness
         * Different smoothing based on beat timing phases
         */
        calculateBeatPhaseFactor(beatPhase, timeSinceLastBeat, beatInterval) {
          const phaseConfig = this.beatPhaseConfig[beatPhase];
          const beatPosition = Math.min(1, timeSinceLastBeat / beatInterval);
          let phaseFactor = phaseConfig.baseMultiplier;
          if (beatPhase === "attack" && beatPosition > 0.1) {
            const transitionFactor = (0.15 - beatPosition) / 0.05;
            phaseFactor = phaseConfig.baseMultiplier + (1 - phaseConfig.baseMultiplier) * (1 - transitionFactor);
          }
          return phaseFactor;
        }
        /**
         * Calculate attack multiplier based on energy and beat phase
         */
        calculateAttackMultiplier(energy, beatPhase) {
          const { attackRange, baseline } = this.modulationConfig.energy;
          let baseAttack = baseline - energy * attackRange;
          if (beatPhase === "attack") {
            baseAttack *= 0.5;
          }
          return Math.max(0.1, baseAttack);
        }
        /**
         * Calculate decay multiplier based on energy and emotional valence
         */
        calculateDecayMultiplier(energy, valence) {
          const { decayRange, baseline } = this.modulationConfig.energy;
          let baseDecay = baseline + energy * decayRange;
          baseDecay += valence * 0.3;
          return Math.max(0.8, Math.min(2, baseDecay));
        }
        /**
         * Calculate fluidity factor for organic movement quality
         */
        calculateFluidityFactor(danceability, emotionalTemperature) {
          const { fluidityMin, fluidityMax, organicThreshold } = this.modulationConfig.danceability;
          const { neutral, range } = this.modulationConfig.temperature;
          let fluidity = fluidityMin + danceability * (fluidityMax - fluidityMin);
          const temperatureNorm = (emotionalTemperature - neutral) / range;
          fluidity += temperatureNorm * 0.2;
          return Math.max(0.3, Math.min(1.2, fluidity));
        }
        /**
         * Calculate overall consciousness level for system-wide awareness
         */
        calculateConsciousnessLevel(musicContext) {
          const { energy, valence, danceability, beatConfidence } = musicContext;
          const energyContribution = energy * 0.3;
          const valenceContribution = valence * 0.2;
          const danceabilityContribution = danceability * 0.25;
          const confidenceContribution = beatConfidence * 0.25;
          return Math.max(0.1, Math.min(
            1,
            energyContribution + valenceContribution + danceabilityContribution + confidenceContribution
          ));
        }
        /**
         * Get current beat phase based on timing
         */
        getCurrentBeatPhase(timeSinceLastBeat, beatInterval) {
          const beatPosition = Math.min(1, timeSinceLastBeat / beatInterval);
          if (beatPosition <= 0.15) return "attack";
          if (beatPosition <= 0.5) return "sustain";
          if (beatPosition <= 0.85) return "decay";
          return "rest";
        }
        /**
         * Create musical context from MusicSyncService data
         */
        createMusicalContext(musicSyncService, lastBeatTime = 0) {
          const musicState = musicSyncService.getCurrentMusicState();
          if (!musicState) return null;
          const { emotion, beat, intensity } = musicState;
          const now = Date.now();
          const timeSinceLastBeat = now - lastBeatTime;
          const beatInterval = beat?.tempo ? 6e4 / beat.tempo : 500;
          return {
            tempo: beat?.tempo || 120,
            energy: beat?.energy || intensity || 0.5,
            valence: emotion?.valence || 0.5,
            danceability: emotion?.danceability || 0.5,
            emotionalTemperature: emotion?.temperature || 4e3,
            beatPhase: this.getCurrentBeatPhase(timeSinceLastBeat, beatInterval),
            beatConfidence: beat?.confidence || 0.5,
            beatInterval,
            timeSinceLastBeat
          };
        }
        /**
         * Enable or disable debug mode
         */
        setDebugMode(enabled) {
          this.debugMode = enabled;
        }
        /**
         * Get current configuration for inspection
         */
        getConfiguration() {
          return {
            baseHalfLifeValues: { ...this.baseHalfLifeValues },
            beatPhaseConfig: { ...this.beatPhaseConfig },
            modulationConfig: { ...this.modulationConfig }
          };
        }
      };
      __name(_MusicalLerpOrchestrator, "MusicalLerpOrchestrator");
      MusicalLerpOrchestrator = _MusicalLerpOrchestrator;
      musicalLerpOrchestrator = new MusicalLerpOrchestrator(false);
    }
  });

  // src-js/utils/core/Year3000Utilities.ts
  var Year3000Utilities_exports = {};
  __export(Year3000Utilities_exports, {
    adjustColor: () => adjustColor,
    bpmToAnimationFrameRate: () => bpmToAnimationFrameRate,
    bpmToInterval: () => bpmToInterval,
    calculateBreathingScale: () => calculateBreathingScale,
    calculateContrastRatio: () => calculateContrastRatio,
    calculateNavigationScale: () => calculateNavigationScale,
    calculateOklabDerivedProperties: () => calculateOklabDerivedProperties,
    calculateRhythmPhase: () => calculateRhythmPhase,
    colorDifference: () => colorDifference,
    debounce: () => debounce,
    easeBeatAnimation: () => easeBeatAnimation,
    findRequiredLuminance: () => findRequiredLuminance,
    generateHarmonicOklabColors: () => generateHarmonicOklabColors,
    getBeatPhase: () => getBeatPhase,
    getCanonicalAccent: () => getCanonicalAccent,
    getHealthMonitor: () => getHealthMonitor,
    getNextBeatTime: () => getNextBeatTime,
    getRootStyle: () => getRootStyle,
    hexToRgb: () => hexToRgb,
    hslToRgb: () => hslToRgb,
    intervalToBpm: () => intervalToBpm,
    isOnBeat: () => isOnBeat,
    isValidHexColor: () => isValidHexColor,
    lerp: () => lerp,
    lerpSmooth: () => lerpSmooth,
    lerpSmoothMusical: () => lerpSmoothMusical,
    lerpSmoothMusicalPerformance: () => lerpSmoothMusicalPerformance,
    lerpSmoothSimpleMusical: () => lerpSmoothSimpleMusical,
    oklabToRgb: () => oklabToRgb,
    processOklabColor: () => processOklabColor,
    rgbToHex: () => rgbToHex,
    rgbToHsl: () => rgbToHsl,
    rgbToOklab: () => rgbToOklab,
    sanitizeColorMap: () => sanitizeColorMap,
    sleep: () => sleep,
    throttle: () => throttle
  });
  function getRootStyle() {
    return document.documentElement;
  }
  function throttle(func, limit) {
    let inThrottle;
    return /* @__PURE__ */ __name(function throttled(...args) {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    }, "throttled");
  }
  function debounce(func, delay) {
    let timeoutId;
    return /* @__PURE__ */ __name(function debounced(...args) {
      clearTimeout(timeoutId);
      timeoutId = window.setTimeout(() => func(...args), delay);
    }, "debounced");
  }
  function isValidHexColor(value) {
    if (typeof value !== "string") {
      return false;
    }
    const trimmed = value.trim();
    const withHash = trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
    const hexPattern = /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$/;
    return hexPattern.test(withHash);
  }
  function hexToRgb(hex) {
    if (typeof hex !== "string") {
      return { r: 0, g: 0, b: 0 };
    }
    if (!isValidHexColor(hex)) {
      return { r: 0, g: 0, b: 0 };
    }
    const sanitizedHex = hex.trim();
    let processedHex = sanitizedHex.startsWith("#") ? sanitizedHex : `#${sanitizedHex}`;
    processedHex = processedHex.replace(/##+/g, "#");
    if (processedHex.length === 4) {
      processedHex = `#${processedHex[1]}${processedHex[1]}${processedHex[2]}${processedHex[2]}${processedHex[3]}${processedHex[3]}`;
    }
    const result = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(processedHex);
    if (result) {
      try {
        const rgb = {
          r: parseInt(result[1] || "0", 16),
          g: parseInt(result[2] || "0", 16),
          b: parseInt(result[3] || "0", 16)
        };
        return rgb;
      } catch (e) {
        return { r: 0, g: 0, b: 0 };
      }
    } else {
      return { r: 0, g: 0, b: 0 };
    }
  }
  function sanitizeColorMap(input) {
    console.log("\u{1F3A8} [Year3000Utilities] sanitizeColorMap input:", {
      input,
      inputKeys: input ? Object.keys(input) : [],
      inputEntries: input ? Object.entries(input) : []
    });
    const validHex = /^#?[0-9a-fA-F]{3}(?:[0-9a-fA-F]{3})?$/;
    const sanitized = {};
    if (!input || typeof input !== "object") {
      console.warn("\u{1F3A8} [Year3000Utilities] sanitizeColorMap: Invalid input type");
      return sanitized;
    }
    const droppedEntries = [];
    Object.entries(input).forEach(([key, value]) => {
      if (typeof value !== "string") {
        droppedEntries.push([key, value]);
        console.warn(`\u{1F3A8} [Year3000Utilities] Dropped non-string color: ${key} = ${value} (type: ${typeof value})`);
        return;
      }
      const trimmed = value.trim();
      if (!trimmed || trimmed === "undefined") {
        droppedEntries.push([key, value]);
        console.warn(`\u{1F3A8} [Year3000Utilities] Dropped empty/undefined color: ${key} = "${value}"`);
        return;
      }
      if (!validHex.test(trimmed)) {
        droppedEntries.push([key, value]);
        console.warn(`\u{1F3A8} [Year3000Utilities] Dropped invalid hex color: ${key} = "${value}"`);
        return;
      }
      const normalised = trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
      sanitized[key] = normalised;
    });
    console.log("\u{1F3A8} [Year3000Utilities] sanitizeColorMap output:", {
      sanitized,
      sanitizedKeys: Object.keys(sanitized),
      sanitizedEntries: Object.entries(sanitized),
      droppedCount: droppedEntries.length,
      droppedEntries
    });
    if (YEAR3000_CONFIG?.enableDebug && Object.keys(input).length !== Object.keys(sanitized).length) {
      console.warn(
        `[StarryNight sanitizeColorMap] Dropped ${Object.keys(input).length - Object.keys(sanitized).length} invalid colour entries.`
      );
    }
    return sanitized;
  }
  function rgbToHsl(r, g2, b) {
    r /= 255;
    g2 /= 255;
    b /= 255;
    const max = Math.max(r, g2, b), min = Math.min(r, g2, b);
    let h = 0, s = 0, l = (max + min) / 2;
    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g2 - b) / d + (g2 < b ? 6 : 0);
          break;
        case g2:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g2) / d + 4;
          break;
      }
      h /= 6;
    }
    return { h: h * 360, s: s * 100, l: l * 100 };
  }
  function hslToRgb(h, s, l) {
    h /= 360;
    s /= 100;
    l /= 100;
    const hue2rgb = /* @__PURE__ */ __name((p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }, "hue2rgb");
    let r_val, g_val, b_val;
    if (s === 0) {
      r_val = g_val = b_val = l;
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r_val = hue2rgb(p, q, h + 1 / 3);
      g_val = hue2rgb(p, q, h);
      b_val = hue2rgb(p, q, h - 1 / 3);
    }
    return {
      r: Math.round(r_val * 255),
      g: Math.round(g_val * 255),
      b: Math.round(b_val * 255)
    };
  }
  function rgbToHex(r, g2, b) {
    const normalize = /* @__PURE__ */ __name((c) => {
      if (!Number.isFinite(c)) return 0;
      const scaled = c <= 1 ? c * 255 : c;
      return Math.min(255, Math.max(0, Math.round(scaled)));
    }, "normalize");
    const [nr, ng, nb] = [normalize(r), normalize(g2), normalize(b)];
    return "#" + [nr, ng, nb].map((channel) => channel.toString(16).padStart(2, "0")).join("");
  }
  function calculateContrastRatio(color1, color2) {
    const getLuminance = /* @__PURE__ */ __name((rgb) => {
      const [r_val = 0, g_val = 0, b_val = 0] = [rgb.r, rgb.g, rgb.b].map((c) => {
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * r_val + 0.7152 * g_val + 0.0722 * b_val;
    }, "getLuminance");
    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color2);
    if (!rgb1 || !rgb2) return 1;
    const lum1 = getLuminance(rgb1);
    const lum2 = getLuminance(rgb2);
    const brightest = Math.max(lum1, lum2);
    const darkest = Math.min(lum1, lum2);
    return (brightest + 0.05) / (darkest + 0.05);
  }
  function lerpSmooth(current, target, deltaTime, halfLife) {
    const EPSILON = 1e-5;
    if (halfLife <= EPSILON || deltaTime <= 0) {
      if (YEAR3000_CONFIG?.enableDebug) {
        if (halfLife <= EPSILON) {
        }
      }
      return target;
    }
    const result = target + (current - target) * Math.pow(2, -deltaTime / halfLife);
    return result;
  }
  function lerpSmoothMusical(current, target, deltaTime, musicContext, animationType = "flow", baseHalfLife) {
    const { musicalLerpOrchestrator: musicalLerpOrchestrator2 } = (init_MusicalLerpOrchestrator(), __toCommonJS(MusicalLerpOrchestrator_exports));
    const musicalParams = musicalLerpOrchestrator2.calculateMusicalLerp(
      musicContext,
      animationType,
      baseHalfLife
    );
    return lerpSmooth(current, target, deltaTime, musicalParams.halfLife);
  }
  function lerpSmoothMusicalPerformance(current, target, deltaTime, musicContext, performanceCoordinator, animationType = "flow", baseHalfLife) {
    if (!performanceCoordinator?.calculatePerformanceAwareMusicalLerp) {
      return lerpSmoothMusical(current, target, deltaTime, musicContext, animationType, baseHalfLife);
    }
    return performanceCoordinator.calculatePerformanceAwareMusicalLerp(
      current,
      target,
      deltaTime,
      musicContext,
      animationType,
      baseHalfLife
    );
  }
  function lerpSmoothSimpleMusical(current, target, deltaTime, tempo = 120, energy = 0.5, baseHalfLife = 0.15) {
    const tempoFactor = Math.pow(tempo / 120, 0.3);
    const energyFactor = 1 + energy * 0.3;
    const musicalHalfLife = baseHalfLife / tempoFactor * energyFactor;
    return lerpSmooth(current, target, deltaTime, musicalHalfLife);
  }
  function bpmToInterval(bpm) {
    if (!bpm || bpm <= 0) return 500;
    return 6e4 / bpm;
  }
  function intervalToBpm(intervalMs) {
    if (!intervalMs || intervalMs <= 0) return 120;
    return 6e4 / intervalMs;
  }
  function bpmToAnimationFrameRate(bpm, framesPerBeat = 4) {
    const beatInterval = bpmToInterval(bpm);
    return beatInterval / framesPerBeat;
  }
  function isOnBeat(currentTime, trackStartTime, bpm, tolerance = 50) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatPosition = timeSinceStart % beatInterval;
    return beatPosition <= tolerance || beatPosition >= beatInterval - tolerance;
  }
  function getBeatPhase(currentTime, trackStartTime, bpm) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatPosition = timeSinceStart % beatInterval;
    return beatPosition / beatInterval;
  }
  function getNextBeatTime(currentTime, trackStartTime, bpm) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatsElapsed = Math.floor(timeSinceStart / beatInterval);
    return trackStartTime + (beatsElapsed + 1) * beatInterval;
  }
  function easeBeatAnimation(beatPhase, easingType = "ease-out") {
    switch (easingType) {
      case "ease-in":
        return beatPhase * beatPhase;
      case "linear":
        return beatPhase;
      case "ease-out":
      default:
        return beatPhase * (2 - beatPhase);
    }
  }
  function calculateRhythmPhase(currentTime, animationSpeedFactor = 1) {
    const speed = 1e-3 * animationSpeedFactor;
    return currentTime * speed % (2 * Math.PI);
  }
  function calculateBreathingScale(rhythmPhase, processedEnergy = 0.5) {
    const baseScale = 1;
    const pulseAmount = 0.02 * processedEnergy;
    const breath = Math.sin(rhythmPhase) * pulseAmount;
    return baseScale + breath;
  }
  function calculateNavigationScale(visualIntensity = 0.5, moodIdentifier = "neutral") {
    const baseScale = 1;
    const moodFactor = moodIdentifier === "energetic" ? 1.2 : moodIdentifier === "calm" ? 0.8 : 1;
    return baseScale + 0.05 * visualIntensity * moodFactor;
  }
  function rgbToOklab(r_srgb, g_srgb, b_srgb) {
    const r = r_srgb / 255;
    const g2 = g_srgb / 255;
    const b = b_srgb / 255;
    const l = 0.4122214708 * r + 0.5363325363 * g2 + 0.0514459929 * b;
    const m = 0.2119034982 * r + 0.6806995451 * g2 + 0.1073969566 * b;
    const s = 0.0883024619 * r + 0.2817188376 * g2 + 0.6299787005 * b;
    const l_ = Math.cbrt(l);
    const m_ = Math.cbrt(m);
    const s_ = Math.cbrt(s);
    return {
      L: 0.2104542553 * l_ + 0.793617785 * m_ - 0.0040720468 * s_,
      a: 1.9779984951 * l_ - 2.428592205 * m_ + 0.4505937099 * s_,
      b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.808675766 * s_
    };
  }
  function oklabToRgb(L, a, b_oklab) {
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b_oklab;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b_oklab;
    const s_ = L - 0.0894841775 * a - 1.291485548 * b_oklab;
    const l = l_ * l_ * l_;
    const m = m_ * m_ * m_;
    const s = s_ * s_ * s_;
    let r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
    let g2 = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
    let b = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s;
    r = Math.round(Math.max(0, Math.min(1, r)) * 255);
    g2 = Math.round(Math.max(0, Math.min(1, g2)) * 255);
    b = Math.round(Math.max(0, Math.min(1, b)) * 255);
    return { r, g: g2, b };
  }
  function processOklabColor(oklabColor, context = {}) {
    const { L, a, b } = oklabColor;
    const C = Math.sqrt(a * a + b * b);
    let h_rad = Math.atan2(b, a);
    if (h_rad < 0) {
      h_rad += 2 * Math.PI;
    }
    const h = h_rad * (180 / Math.PI);
    const {
      energy = 0.5,
      valence = 0.5,
      artisticMode = "artist-vision"
    } = context;
    const multipliers = YEAR3000_CONFIG.getCurrentMultipliers();
    let adjusted_L = L * (1 + (valence - 0.5) * 0.1);
    let adjusted_C = C * (1 + (energy - 0.5) * 0.2) * (multipliers?.saturation || 1);
    adjusted_L = Math.max(
      0,
      Math.min(1, adjusted_L * (multipliers?.brightness || 1))
    );
    return {
      L: adjusted_L,
      C: adjusted_C,
      h: C > 1e-3 ? h : null
      // Hue is meaningless if chroma is near zero
    };
  }
  function calculateOklabDerivedProperties(oklabColor) {
    const { L, C, h } = processOklabColor(oklabColor);
    const isWarm = h !== null ? h >= 0 && h < 90 || h >= 270 && h <= 360 : false;
    const isCool = h !== null ? h >= 90 && h < 270 : false;
    let mood = "neutral";
    if (L > 0.7 && C > 0.1) mood = "bright";
    else if (L < 0.4) mood = "dark";
    else if (isWarm && C > 0.1) mood = "warm";
    else if (isCool && C > 0.1) mood = "cool";
    return {
      lightness: L,
      chroma: C,
      hue: h,
      isWarm,
      isCool,
      mood
    };
  }
  function generateHarmonicOklabColors(baseOklabColor, rule = "analogous", angle = 30) {
    const baseLCH = processOklabColor(baseOklabColor);
    if (baseLCH.h === null) {
      return [baseOklabColor];
    }
    const getOklabFromLCH = /* @__PURE__ */ __name((l_val, c_val, h_deg_val) => {
      const h_rad = h_deg_val * (Math.PI / 180);
      const a_val = c_val * Math.cos(h_rad);
      const b_val = c_val * Math.sin(h_rad);
      return { L: l_val, a: a_val, b: b_val };
    }, "getOklabFromLCH");
    const colors = [baseOklabColor];
    const { L, C, h } = baseLCH;
    switch (rule) {
      case "complementary":
        colors.push(getOklabFromLCH(L, C, (h + 180) % 360));
        break;
      case "analogous":
        colors.push(getOklabFromLCH(L, C, (h + angle) % 360));
        colors.push(getOklabFromLCH(L, C, (h - angle + 360) % 360));
        break;
      case "triadic":
        colors.push(getOklabFromLCH(L, C, (h + 120) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 240) % 360));
        break;
      case "tetradic":
        colors.push(getOklabFromLCH(L, C, (h + 90) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 180) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 270) % 360));
        break;
      case "split-complementary":
        colors.push(getOklabFromLCH(L, C, (h + 180 - angle) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 180 + angle) % 360));
        break;
      case "monochromatic":
        colors.push({
          L: Math.max(0, L - 0.2),
          a: baseOklabColor.a,
          b: baseOklabColor.b
        });
        colors.push({
          L: Math.min(1, L + 0.2),
          a: baseOklabColor.a,
          b: baseOklabColor.b
        });
        break;
    }
    return colors;
  }
  function lerp(start, end, amt) {
    return (1 - amt) * start + amt * end;
  }
  function colorDifference(rgb1, rgb2) {
    const lab1 = rgbToOklab(rgb1.r, rgb1.g, rgb1.b);
    const lab2 = rgbToOklab(rgb2.r, rgb2.g, rgb2.b);
    const deltaL = lab1.L - lab2.L;
    const deltaA = lab1.a - lab2.a;
    const deltaB = lab1.b - lab2.b;
    return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
  }
  function getHealthMonitor() {
    return healthMonitorInstance;
  }
  function findRequiredLuminance(color1, color2, ratio) {
    const getLuminance = /* @__PURE__ */ __name((rgb) => {
      const [r_val = 0, g_val = 0, b_val = 0] = [rgb.r, rgb.g, rgb.b].map((c) => {
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * r_val + 0.7152 * g_val + 0.0722 * b_val;
    }, "getLuminance");
    const lum2 = getLuminance(color2);
    let targetLuminance;
    targetLuminance = ratio * (lum2 + 0.05) - 0.05;
    const hsl = rgbToHsl(color1.r, color1.g, color1.b);
    const currentLuminance = getLuminance(color1);
    const luminanceRatio = targetLuminance / currentLuminance;
    return hsl.l;
  }
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function adjustColor(rgb, {
    brightness = 1,
    saturation = 1,
    hue = 0
  }) {
    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
    hsl.h = (hsl.h + hue) % 360;
    hsl.s = Math.max(0, Math.min(100, hsl.s * saturation));
    hsl.l = Math.max(0, Math.min(100, hsl.l * brightness));
    return hslToRgb(hsl.h, hsl.s, hsl.l);
  }
  function getCanonicalAccent() {
    const root = getRootStyle();
    const styles = getComputedStyle(root);
    let hex = styles.getPropertyValue("--sn-accent-hex").trim();
    let rgb = styles.getPropertyValue("--sn-accent-rgb").trim();
    if (!hex && rgb) {
      const [rStr = "0", gStr = "0", bStr = "0"] = rgb.split(/\s*,\s*/);
      const r = parseInt(rStr, 10) || 0;
      const g2 = parseInt(gStr, 10) || 0;
      const b = parseInt(bStr, 10) || 0;
      hex = rgbToHex(r, g2, b);
    }
    if (!rgb && hex) {
      const rgbObj = hexToRgb(hex);
      if (rgbObj) {
        rgb = `${rgbObj.r},${rgbObj.g},${rgbObj.b}`;
      }
    }
    return { hex, rgb };
  }
  var _HealthMonitor, HealthMonitor, healthMonitorInstance;
  var init_Year3000Utilities = __esm({
    "src-js/utils/core/Year3000Utilities.ts"() {
      "use strict";
      init_globalConfig();
      __name(getRootStyle, "getRootStyle");
      __name(throttle, "throttle");
      __name(debounce, "debounce");
      __name(isValidHexColor, "isValidHexColor");
      __name(hexToRgb, "hexToRgb");
      __name(sanitizeColorMap, "sanitizeColorMap");
      __name(rgbToHsl, "rgbToHsl");
      __name(hslToRgb, "hslToRgb");
      __name(rgbToHex, "rgbToHex");
      __name(calculateContrastRatio, "calculateContrastRatio");
      __name(lerpSmooth, "lerpSmooth");
      __name(lerpSmoothMusical, "lerpSmoothMusical");
      __name(lerpSmoothMusicalPerformance, "lerpSmoothMusicalPerformance");
      __name(lerpSmoothSimpleMusical, "lerpSmoothSimpleMusical");
      __name(bpmToInterval, "bpmToInterval");
      __name(intervalToBpm, "intervalToBpm");
      __name(bpmToAnimationFrameRate, "bpmToAnimationFrameRate");
      __name(isOnBeat, "isOnBeat");
      __name(getBeatPhase, "getBeatPhase");
      __name(getNextBeatTime, "getNextBeatTime");
      __name(easeBeatAnimation, "easeBeatAnimation");
      __name(calculateRhythmPhase, "calculateRhythmPhase");
      __name(calculateBreathingScale, "calculateBreathingScale");
      __name(calculateNavigationScale, "calculateNavigationScale");
      __name(rgbToOklab, "rgbToOklab");
      __name(oklabToRgb, "oklabToRgb");
      __name(processOklabColor, "processOklabColor");
      __name(calculateOklabDerivedProperties, "calculateOklabDerivedProperties");
      __name(generateHarmonicOklabColors, "generateHarmonicOklabColors");
      __name(lerp, "lerp");
      __name(colorDifference, "colorDifference");
      _HealthMonitor = class _HealthMonitor {
        registerSystem(name, instance2) {
        }
        updateSystemMetrics(name, metrics) {
        }
      };
      __name(_HealthMonitor, "HealthMonitor");
      HealthMonitor = _HealthMonitor;
      healthMonitorInstance = new HealthMonitor();
      __name(getHealthMonitor, "getHealthMonitor");
      __name(findRequiredLuminance, "findRequiredLuminance");
      __name(sleep, "sleep");
      __name(adjustColor, "adjustColor");
      __name(getCanonicalAccent, "getCanonicalAccent");
    }
  });

  // src-js/ui/managers/SettingsManager.ts
  var _SettingsManager, SettingsManager;
  var init_SettingsManager = __esm({
    "src-js/ui/managers/SettingsManager.ts"() {
      "use strict";
      init_globalConfig();
      init_UnifiedEventBus();
      init_Year3000Utilities();
      _SettingsManager = class _SettingsManager {
        constructor(config = YEAR3000_CONFIG, harmonicModes = HARMONIC_MODES, utils = Year3000Utilities_exports) {
          this.initialized = false;
          this.config = config;
          this.harmonicModes = harmonicModes;
          this.utils = utils;
          this.defaults = {
            "catppuccin-flavor": "mocha",
            "catppuccin-accentColor": "mauve",
            "sn-star-density": "balanced",
            "sn-gradient-intensity": "balanced",
            "sn-glassmorphism-level": "moderate",
            "sn-3d-effects-level": "full",
            "sn-nebula-intensity": "balanced",
            "sn-artistic-mode": "artist-vision",
            "sn-current-harmonic-mode": "analogous-flow",
            "sn-harmonic-intensity": "0.7",
            "sn-harmonic-evolution": "true",
            "sn-harmonic-manual-base-color": "",
            "sn-enable-aberration": "true",
            "sn-nebula-aberration-strength": "0.4",
            "sn-echo-intensity": "2",
            "sn-visual-intensity": (() => {
              try {
                const detector = globalThis.year3000System?.deviceCapabilityDetector;
                const overall = detector?.deviceCapabilities?.overall;
                switch (overall) {
                  case "high":
                    return "1";
                  case "medium":
                    return "0.7";
                  case "low":
                    return "0.4";
                  default:
                    return "0.8";
                }
              } catch (e) {
                return "0.8";
              }
            })(),
            "sn-animation-quality": "auto",
            "sn-glass-beat-pulse": "true",
            "sn-glass-base-intensity": "0.5",
            "sn-flow-gradient": "balanced",
            "sn-brightness-mode": "bright"
          };
          this.validationSchemas = {
            "catppuccin-flavor": {
              default: "mocha",
              allowedValues: ["latte", "frappe", "macchiato", "mocha"]
            },
            "catppuccin-accentColor": {
              default: "mauve",
              allowedValues: [
                "rosewater",
                "flamingo",
                "pink",
                "mauve",
                "red",
                "maroon",
                "peach",
                "yellow",
                "green",
                "teal",
                "sky",
                "sapphire",
                "blue",
                "lavender",
                "text",
                "none"
              ]
            },
            "sn-star-density": {
              default: "balanced",
              allowedValues: ["disabled", "minimal", "balanced", "intense"]
            },
            "sn-gradient-intensity": {
              default: "balanced",
              allowedValues: ["disabled", "minimal", "balanced", "intense"]
            },
            "sn-glassmorphism-level": {
              default: "moderate",
              allowedValues: ["disabled", "minimal", "moderate", "intense"]
            },
            "sn-3d-effects-level": {
              default: "full",
              allowedValues: ["full", "minimal", "disabled"]
            },
            "sn-nebula-intensity": {
              default: "balanced",
              allowedValues: ["disabled", "minimal", "balanced", "intense"]
            },
            "sn-artistic-mode": {
              default: "artist-vision",
              allowedValues: Object.keys(ARTISTIC_MODE_PROFILES)
            },
            "sn-current-harmonic-mode": {
              default: "analogous-flow",
              allowedValues: Object.keys(
                this.harmonicModes
              )
            },
            "sn-harmonic-intensity": { default: "0.7" },
            "sn-harmonic-evolution": {
              default: "true",
              allowedValues: ["true", "false"]
            },
            "sn-harmonic-manual-base-color": { default: "" },
            "sn-enable-aberration": {
              default: "true",
              allowedValues: ["true", "false"]
            },
            "sn-nebula-aberration-strength": { default: "0.4" },
            "sn-echo-intensity": {
              default: "2",
              allowedValues: ["0", "1", "2", "3"]
            },
            "sn-visual-intensity": { default: "0.8" },
            "sn-animation-quality": {
              default: "auto",
              allowedValues: ["auto", "low", "high"]
            },
            "sn-glass-beat-pulse": {
              default: "true",
              allowedValues: ["true", "false"]
            },
            "sn-glass-base-intensity": { default: "0.5" },
            "sn-flow-gradient": {
              default: "balanced",
              allowedValues: ["disabled", "minimal", "balanced", "intense"]
            },
            "sn-brightness-mode": {
              default: "bright",
              allowedValues: ["bright", "balanced", "dark"]
            }
          };
          this.validateAndRepair();
          this.initialized = true;
        }
        forceRepaint(reason) {
          throw new Error("Method not implemented.");
        }
        async initialize() {
          this.initialized = true;
        }
        async healthCheck() {
          try {
            Spicetify.LocalStorage.get("spicetify-exp-features");
            return {
              healthy: true,
              ok: true,
              details: "LocalStorage is accessible.",
              issues: [],
              system: "SettingsManager"
            };
          } catch (e) {
            return {
              healthy: false,
              ok: false,
              details: "Failed to access Spicetify.LocalStorage.",
              issues: [e.message],
              system: "SettingsManager"
            };
          }
        }
        get(key) {
          try {
            const value = Spicetify.LocalStorage.get(key);
            const schema = this.validationSchemas[key];
            if (!schema) {
              console.warn(`StarryNight: No validation schema for key: ${key}.`);
              return value;
            }
            if (value === null || schema.allowedValues && !schema.allowedValues.includes(value)) {
              return schema.default;
            }
            return value;
          } catch (error) {
            console.error(`StarryNight: Error reading key ${key}:`, error);
            return this.validationSchemas[key]?.default;
          }
        }
        getAllowedValues(key) {
          return this.validationSchemas[key]?.allowedValues;
        }
        set(key, value) {
          try {
            const schema = this.validationSchemas[key];
            if (!schema) {
              Spicetify.LocalStorage.set(key, value);
              return true;
            }
            if (key === "sn-harmonic-manual-base-color") {
              if (value !== "" && !/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)) {
                return false;
              }
            } else if (schema.allowedValues && !schema.allowedValues.includes(value)) {
              return false;
            }
            const oldValue = Spicetify.LocalStorage.get(key);
            Spicetify.LocalStorage.set(key, value);
            document.dispatchEvent(
              new CustomEvent("year3000SystemSettingsChanged", {
                detail: { key, value }
              })
            );
            unifiedEventBus.emitSync("settings:changed", {
              settingKey: key,
              oldValue,
              newValue: value,
              timestamp: Date.now()
            });
            return true;
          } catch (error) {
            console.error(`StarryNight: Error setting key ${key}:`, error);
            return false;
          }
        }
        getAllSettings() {
          const settings = {};
          for (const key in this.validationSchemas) {
            settings[key] = this.get(key);
          }
          return settings;
        }
        validateAndRepair() {
          let repairedCount = 0;
          for (const key in this.validationSchemas) {
            const aKey = key;
            const currentValue = Spicetify.LocalStorage.get(aKey);
            const validatedValue = this.get(aKey);
            if (currentValue !== validatedValue) {
              this.set(aKey, validatedValue);
              repairedCount++;
            }
          }
          if (repairedCount > 0) {
            console.log(`StarryNight: Repaired ${repairedCount} invalid settings.`);
          }
        }
        resetAllToDefaults() {
          for (const key of Object.keys(this.defaults)) {
            this.set(
              key,
              this.defaults[key]
            );
          }
          console.log("StarryNight: All settings reset to defaults.");
        }
        // To satisfy the SystemHealthMonitor, which expects all registered systems
        // to have these lifecycle methods.
        updateAnimation() {
        }
        destroy() {
          console.log("StarryNight: SettingsManager destroyed (no-op).");
        }
        // === NEW: Harmonic mode helpers ===========================================
        /**
         * Return the full HarmonicMode object for the currently selected mode.
         * Falls back to the default entry ("analogous-flow") if the key is missing.
         */
        getCurrentHarmonicMode() {
          const key = this.get("sn-current-harmonic-mode");
          return this.harmonicModes[key] || this.harmonicModes["analogous-flow"];
        }
        /**
         * Retrieve a HarmonicMode definition by key, or undefined if not found.
         */
        getHarmonicMode(key) {
          return this.harmonicModes[key];
        }
      };
      __name(_SettingsManager, "SettingsManager");
      SettingsManager = _SettingsManager;
    }
  });

  // src-js/core/events/EventBus.ts
  var EventBus_exports = {};
  __export(EventBus_exports, {
    EventBus: () => EventBus,
    GlobalEventBus: () => GlobalEventBus
  });
  var _EventBus, EventBus, GlobalEventBus, g;
  var init_EventBus = __esm({
    "src-js/core/events/EventBus.ts"() {
      "use strict";
      _EventBus = class _EventBus {
        constructor() {
          this.subscribers = {};
        }
        subscribe(topic, callback) {
          if (!this.subscribers[topic]) {
            this.subscribers[topic] = /* @__PURE__ */ new Set();
          }
          this.subscribers[topic].add(callback);
          return () => {
            if (this.subscribers[topic]) {
              this.subscribers[topic].delete(callback);
              if (this.subscribers[topic].size === 0) {
                delete this.subscribers[topic];
              }
            }
          };
        }
        publish(topic, payload) {
          if (this.subscribers[topic]) {
            this.subscribers[topic].forEach((callback) => {
              try {
                callback(payload);
              } catch (error) {
                console.error(
                  `[EventBus] Error in subscriber for topic "${topic}":`,
                  error
                );
              }
            });
          }
        }
        unsubscribe(topic, callback) {
          if (this.subscribers[topic]) {
            this.subscribers[topic].delete(callback);
            if (this.subscribers[topic].size === 0) {
              delete this.subscribers[topic];
            }
          }
        }
        // -------------------------------------------------------------------
        // Compatibility aliases (v2 API) ------------------------------------
        // These provide ergonomic `on` / `emit` helpers used throughout newer
        // systems while retaining the underlying subscribe/publish semantics.
        // -------------------------------------------------------------------
        /**
         * Alias for `subscribe` to improve readability (`on('topic', cb)`).
         */
        on(topic, callback) {
          return this.subscribe(topic, callback);
        }
        /**
         * Alias for `publish` so call sites can use `emit('topic', data)`.
         */
        emit(topic, payload) {
          this.publish(topic, payload);
        }
        destroy() {
          this.subscribers = {};
        }
      };
      __name(_EventBus, "EventBus");
      EventBus = _EventBus;
      GlobalEventBus = new EventBus();
      g = globalThis;
      if (!g.GlobalEventBus) {
        g.GlobalEventBus = GlobalEventBus;
      }
    }
  });

  // src-js/core/css/UnifiedCSSConsciousnessController.ts
  var CRITICAL_NOW_PLAYING_VARS, _UnifiedCSSConsciousnessController, UnifiedCSSConsciousnessController;
  var init_UnifiedCSSConsciousnessController = __esm({
    "src-js/core/css/UnifiedCSSConsciousnessController.ts"() {
      "use strict";
      init_EventBus();
      CRITICAL_NOW_PLAYING_VARS = /* @__PURE__ */ new Set([
        // Legacy variables (Phase 1 migration)
        "--sn-beat-pulse-intensity",
        "--sn-breathing-scale",
        "--sn-accent-hex",
        "--sn-accent-rgb",
        // New namespaced variables (Phase 2+)
        "--sn.music.beat.pulse.intensity",
        "--sn.music.breathing.scale",
        "--sn.music.rhythm.phase",
        "--sn.music.spectrum.phase",
        "--sn.color.accent.hex",
        "--sn.color.accent.rgb",
        "--sn.bg.webgl.ready",
        "--sn.bg.active-backend"
      ]);
      _UnifiedCSSConsciousnessController = class _UnifiedCSSConsciousnessController {
        constructor(config, performanceCoordinator, unifiedEventBus2) {
          this.initialized = false;
          // === BATCHING LAYER (from UnifiedCSSConsciousnessController) ===
          this.cssVariableQueue = /* @__PURE__ */ new Map();
          this.batchUpdateTimer = null;
          this.rafHandle = null;
          this.microtaskScheduled = false;
          // === MANAGEMENT LAYER (from UnifiedCSSConsciousnessController) ===
          this.pendingTransactions = /* @__PURE__ */ new Map();
          this.transactionCounter = 0;
          this.updateQueue = /* @__PURE__ */ new Map();
          this.flushTimer = null;
          // === PERFORMANCE LAYER (from UnifiedCSSConsciousnessController) ===
          this.currentDeviceCapabilities = null;
          this.currentPerformanceMode = null;
          this.lastCSSUpdate = 0;
          this.cssUpdateThrottle = 100;
          // Update CSS at most every 100ms
          this.appliedClasses = /* @__PURE__ */ new Set();
          // === CONSCIOUSNESS LAYER (new integration) ===
          this.consciousnessState = null;
          this.consciousnessUpdateTimer = null;
          this.lastConsciousnessUpdate = 0;
          // Performance tracking
          this.performanceMetrics = {
            totalBatches: 0,
            totalUpdates: 0,
            totalBatchTime: 0,
            maxBatchTime: 0,
            averageBatchSize: 0,
            overBudgetBatches: 0,
            conflictResolutions: 0,
            transactionCount: 0,
            consciousnessUpdates: 0
          };
          // Priority weights for conflict resolution
          this.PRIORITY_WEIGHTS = {
            low: 1,
            normal: 2,
            high: 3,
            critical: 4
          };
          this.config = config;
          this.performanceCoordinator = performanceCoordinator;
          this.eventBus = GlobalEventBus;
          if (unifiedEventBus2) {
            this.unifiedEventBus = unifiedEventBus2;
          }
          this.cssConfig = {
            // Batching configuration
            batchIntervalMs: 0,
            // 0 = coalesced; scheduling handled via rAF/microtask
            maxBatchSize: 50,
            enableDebug: config.enableDebug,
            useCssTextFastPath: false,
            autoHijack: true,
            // Performance configuration
            enableAdaptiveOptimization: true,
            enableThermalThrottling: true,
            enableBatteryOptimization: true,
            enableDeviceTierOptimization: true,
            debugPerformanceClasses: config.enableDebug,
            // Consciousness configuration
            enableConsciousnessIntegration: true,
            consciousnessUpdateInterval: 16,
            // 60fps
            enableMusicConsciousness: true,
            enableAestheticConsciousness: true
          };
          this.currentDeviceCapabilities = this.performanceCoordinator.getDeviceCapabilities();
          this.currentPerformanceMode = this.performanceCoordinator.getCurrentPerformanceMode();
          _UnifiedCSSConsciousnessController.instance = this;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSConsciousnessController] Created with consciousness-driven CSS management"
            );
          }
        }
        /**
         * Get singleton instance with dependency injection
         */
        static getInstance(config, performanceCoordinator, unifiedEventBus2) {
          if (!_UnifiedCSSConsciousnessController.instance) {
            if (!config || !performanceCoordinator) {
              return null;
            }
            _UnifiedCSSConsciousnessController.instance = new _UnifiedCSSConsciousnessController(
              config,
              performanceCoordinator,
              unifiedEventBus2
            );
          }
          return _UnifiedCSSConsciousnessController.instance;
        }
        // ===================================================================
        // IMANAGEDYSTEM INTERFACE IMPLEMENTATION
        // ===================================================================
        async initialize() {
          if (this.initialized) return;
          this.subscribeToEvents();
          this.applyInitialOptimizations();
          if (this.cssConfig.enableConsciousnessIntegration) {
            this.startConsciousnessIntegration();
          }
          if (this.cssConfig.autoHijack) {
            this.enableGlobalHijack();
          }
          this.initialized = true;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSConsciousnessController] Initialized with device tier:",
              this.currentDeviceCapabilities?.performanceTier
            );
          }
        }
        updateAnimation(deltaTime) {
        }
        async healthCheck() {
          const queueSize = this.cssVariableQueue.size + this.updateQueue.size;
          const pendingTransactions = this.pendingTransactions.size;
          const isHealthy = queueSize <= 1e3 && pendingTransactions <= 100;
          return {
            system: "UnifiedCSSConsciousnessController",
            healthy: isHealthy,
            ok: isHealthy,
            details: isHealthy ? "CSS consciousness controller operating normally" : "High queue size or pending transactions",
            metrics: {
              queueSize,
              pendingTransactions,
              performanceMetrics: this.performanceMetrics,
              consciousnessActive: this.consciousnessState !== null,
              deviceTier: this.currentDeviceCapabilities?.performanceTier,
              performanceMode: this.currentPerformanceMode?.name
            }
          };
        }
        destroy() {
          if (this.consciousnessUpdateTimer) {
            clearTimeout(this.consciousnessUpdateTimer);
            this.consciousnessUpdateTimer = null;
          }
          if (this.flushTimer) {
            clearTimeout(this.flushTimer);
            this.flushTimer = null;
          }
          if (this.rafHandle !== null) {
            cancelAnimationFrame(this.rafHandle);
            this.rafHandle = null;
          }
          this.flushCSSVariableBatch();
          for (const className of this.appliedClasses) {
            document.body.classList.remove(className);
          }
          this.appliedClasses.clear();
          this.cssVariableQueue.clear();
          this.updateQueue.clear();
          this.pendingTransactions.clear();
          if (_UnifiedCSSConsciousnessController.instance === this) {
            _UnifiedCSSConsciousnessController.instance = null;
          }
          this.initialized = false;
          if (this.config.enableDebug) {
            console.log("\u{1F30C} [UnifiedCSSConsciousnessController] Destroyed");
          }
        }
        forceRepaint(reason) {
          this.flushCSSVariableBatch();
          if (this.config.enableDebug && reason) {
            console.log(
              `\u{1F30C} [UnifiedCSSConsciousnessController] Force repaint: ${reason}`
            );
          }
        }
        // ===================================================================
        // PUBLIC API - UNIFIED CSS VARIABLE OPERATIONS
        // ===================================================================
        /**
         * Queue a CSS variable update with priority and consciousness awareness
         */
        queueCSSVariableUpdate(property, value, element = null, priority = "normal", source = "unknown") {
          if (CRITICAL_NOW_PLAYING_VARS.has(property)) {
            const styleDecl = (element || document.documentElement).style;
            if (_UnifiedCSSConsciousnessController.nativeSetProperty) {
              _UnifiedCSSConsciousnessController.nativeSetProperty.call(
                styleDecl,
                property,
                value
              );
            } else {
              styleDecl.setProperty(property, value);
            }
            return;
          }
          const target = element || document.documentElement;
          const elementKey = element ? `element_${element.id || element.className || "unnamed"}` : "root";
          const updateKey = `${elementKey}:${property}`;
          const update = {
            element: target,
            property,
            value,
            timestamp: performance.now(),
            priority,
            source
          };
          const existingUpdate = this.cssVariableQueue.get(updateKey);
          if (existingUpdate) {
            if (this.shouldReplaceUpdate(existingUpdate, update)) {
              this.cssVariableQueue.set(updateKey, update);
              this.performanceMetrics.conflictResolutions++;
            }
          } else {
            this.cssVariableQueue.set(updateKey, update);
          }
          this.performanceMetrics.totalUpdates++;
          this.scheduleFlush(priority);
          if (priority === "critical" || this.cssVariableQueue.size >= this.cssConfig.maxBatchSize) {
            this.flushCSSVariableBatch();
          }
        }
        /**
         * Update multiple CSS variables in a transaction
         */
        updateVariables(variables, priority = "normal", source = "unknown") {
          const transactionId = `tx_${++this.transactionCounter}`;
          const variableMap = new Map(Object.entries(variables));
          const transaction = {
            id: transactionId,
            variables: variableMap,
            timestamp: performance.now(),
            priority,
            completed: false
          };
          this.pendingTransactions.set(transactionId, transaction);
          for (const [property, value] of variableMap) {
            this.queueCSSVariableUpdate(
              property,
              value,
              null,
              priority,
              `${source}:${transactionId}`
            );
          }
          this.performanceMetrics.transactionCount++;
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSConsciousnessController] Transaction ${transactionId} queued with ${variableMap.size} variables`
            );
          }
        }
        /**
         * Update consciousness-driven CSS variables
         */
        updateConsciousnessVariables(consciousnessState) {
          if (!this.cssConfig.enableConsciousnessIntegration) return;
          this.consciousnessState = consciousnessState;
          this.performanceMetrics.consciousnessUpdates++;
          const variables = {};
          if (consciousnessState.musicState && this.cssConfig.enableMusicConsciousness) {
            variables["--sn.music.beat.pulse.intensity"] = consciousnessState.musicState.intensity.toString();
            variables["--sn.music.tempo.bpm"] = consciousnessState.musicState.bpm.toString();
            variables["--sn.music.rhythm.phase"] = `${consciousnessState.musicState.rhythmPhase}deg`;
            variables["--sn.music.breathing.scale"] = consciousnessState.musicState.breathingScale.toString();
            variables["--sn.music.energy.level"] = consciousnessState.musicState.energy.toString();
            variables["--sn.music.valence"] = consciousnessState.musicState.valence.toString();
          }
          if (consciousnessState.aestheticState && this.cssConfig.enableAestheticConsciousness) {
            variables["--sn.aesthetic.harmony.level"] = consciousnessState.aestheticState.harmonyLevel.toString();
            variables["--sn.aesthetic.evolution.factor"] = consciousnessState.aestheticState.evolutionFactor.toString();
            variables["--sn.color.temperature"] = consciousnessState.aestheticState.colorTemperature.toString();
          }
          if (consciousnessState.performanceState) {
            variables["--sn.performance.mode"] = consciousnessState.performanceState.mode;
            variables["--sn.device.tier"] = consciousnessState.performanceState.deviceTier;
            variables["--sn.performance.optimization.level"] = consciousnessState.performanceState.optimizationLevel.toString();
          }
          this.updateVariables(variables, "high", "consciousness-system");
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSConsciousnessController] Consciousness state updated with ${Object.keys(variables).length} variables`
            );
          }
        }
        /**
         * Apply performance-based optimizations
         */
        applyPerformanceOptimizations(performanceMode) {
          if (!this.cssConfig.enableAdaptiveOptimization) return;
          this.currentPerformanceMode = performanceMode;
          const variables = {
            "--sn.performance.mode": performanceMode.name,
            "--sn.performance.quality.level": performanceMode.qualityLevel.toString(),
            "--sn.performance.fps.target": performanceMode.frameRate.toString(),
            "--sn.performance.frame.budget": (1e3 / performanceMode.frameRate).toString(),
            "--sn.performance.optimization.level": performanceMode.optimizationLevel.toString(),
            "--sn.performance.blur.quality": performanceMode.blurQuality.toString(),
            "--sn.performance.shadow.quality": performanceMode.shadowQuality.toString(),
            "--sn.performance.animation.quality": performanceMode.animationQuality.toString(),
            "--sn.performance.effect.quality": performanceMode.effectQuality.toString()
          };
          this.updateVariables(variables, "high", "performance-coordinator");
          this.applyPerformanceModeOptimizations();
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSConsciousnessController] Performance optimizations applied for mode: ${performanceMode.name}`
            );
          }
        }
        /**
         * Get a CSS variable value
         */
        getVariable(key) {
          const computedStyle = getComputedStyle(document.documentElement);
          return computedStyle.getPropertyValue(key).trim() || null;
        }
        /**
         * Force immediate flush of all pending updates
         */
        flushUpdates() {
          this.flushCSSVariableBatch();
        }
        /**
         * Optimized CSS variable batch flush with efficient DOM operations
         */
        flushCSSVariableBatch() {
          if (this.cssVariableQueue.size === 0) return;
          const startTime = performance.now();
          const FRAME_BUDGET = 8;
          const updates = Array.from(this.cssVariableQueue.values());
          this.cssVariableQueue.clear();
          if (this.rafHandle !== null) {
            cancelAnimationFrame(this.rafHandle);
            this.rafHandle = null;
          }
          this.microtaskScheduled = false;
          try {
            const updatesByElement = /* @__PURE__ */ new Map();
            for (const update of updates) {
              if (!updatesByElement.has(update.element)) {
                updatesByElement.set(update.element, []);
              }
              updatesByElement.get(update.element).push(update);
            }
            for (const [element, elementUpdates] of updatesByElement.entries()) {
              if (performance.now() - startTime > FRAME_BUDGET) {
                for (const update of elementUpdates) {
                  const updateKey = `${update.element.id || "root"}:${update.property}`;
                  this.cssVariableQueue.set(updateKey, update);
                }
                this.scheduleFlush("high");
                break;
              }
              if (elementUpdates.length >= 3) {
                this.applyCSSTextBatch(element, elementUpdates);
              } else {
                for (const update of elementUpdates) {
                  if (_UnifiedCSSConsciousnessController.nativeSetProperty) {
                    _UnifiedCSSConsciousnessController.nativeSetProperty.call(
                      element.style,
                      update.property,
                      update.value
                    );
                  } else {
                    element.style.setProperty(update.property, update.value);
                  }
                }
              }
            }
            const batchTime = performance.now() - startTime;
            this.updatePerformanceMetrics(batchTime, updates.length);
            if (batchTime > FRAME_BUDGET && this.config.enableDebug) {
              console.warn(
                `\u{1F30C} [UnifiedCSSConsciousnessController] CSS batch exceeded frame budget: ${batchTime.toFixed(
                  2
                )}ms (${updates.length} updates)`
              );
            } else if (this.config.enableDebug && Math.random() < 0.05) {
              console.log(
                `\u{1F30C} [UnifiedCSSConsciousnessController] Efficient CSS batch: ${updates.length} updates in ${batchTime.toFixed(2)}ms`
              );
            }
          } catch (error) {
            console.error(
              "[UnifiedCSSConsciousnessController] Error in optimized CSS batch processing:",
              error
            );
            this.applyUpdatesWithFallback(updates);
          }
        }
        /**
         * Optimized cssText batching using efficient string building
         */
        applyCSSTextBatch(element, updates) {
          try {
            const currentStyle = element.style.cssText;
            const propertyMap = /* @__PURE__ */ new Map();
            if (currentStyle) {
              const declarations = currentStyle.split(";");
              for (const declaration of declarations) {
                const colonIndex = declaration.indexOf(":");
                if (colonIndex > 0) {
                  const property = declaration.slice(0, colonIndex).trim();
                  const value = declaration.slice(colonIndex + 1).trim();
                  if (property && value) {
                    propertyMap.set(property, value);
                  }
                }
              }
            }
            for (const update of updates) {
              propertyMap.set(update.property, update.value);
            }
            const cssDeclarations = [];
            for (const [property, value] of propertyMap) {
              cssDeclarations.push(`${property}:${value}`);
            }
            element.style.cssText = cssDeclarations.join(";");
          } catch (error) {
            for (const update of updates) {
              try {
                element.style.setProperty(update.property, update.value);
              } catch (e) {
                console.warn(`Failed to apply ${update.property}:`, e);
              }
            }
          }
        }
        /**
         * Fallback update application with error recovery
         */
        applyUpdatesWithFallback(updates) {
          for (const update of updates) {
            try {
              if (_UnifiedCSSConsciousnessController.nativeSetProperty) {
                _UnifiedCSSConsciousnessController.nativeSetProperty.call(
                  update.element.style,
                  update.property,
                  update.value
                );
              } else {
                update.element.style.setProperty(update.property, update.value);
              }
            } catch (e) {
              console.warn(
                `[UnifiedCSSConsciousnessController] Failed to apply CSS property ${update.property}:`,
                e
              );
            }
          }
        }
        // ===================================================================
        // CONVENIENCE METHODS FOR COMMON CSS UPDATES
        // ===================================================================
        /**
         * Set music synchronization variables
         */
        setMusicMetrics(metrics) {
          const variables = {};
          if (metrics.beatIntensity !== void 0) {
            variables["--sn.music.beat.pulse.intensity"] = metrics.beatIntensity.toString();
          }
          if (metrics.rhythmPhase !== void 0) {
            variables["--sn.music.rhythm.phase"] = `${metrics.rhythmPhase}deg`;
          }
          if (metrics.breathingScale !== void 0) {
            variables["--sn.music.breathing.scale"] = metrics.breathingScale.toString();
          }
          if (metrics.spectrumPhase !== void 0) {
            variables["--sn.music.spectrum.phase"] = `${metrics.spectrumPhase}deg`;
          }
          if (metrics.energy !== void 0) {
            variables["--sn.music.energy.level"] = metrics.energy.toString();
          }
          if (metrics.valence !== void 0) {
            variables["--sn.music.valence"] = metrics.valence.toString();
          }
          if (metrics.bpm !== void 0) {
            variables["--sn.music.tempo.bpm"] = metrics.bpm.toString();
          }
          this.updateVariables(variables, "critical", "music-system");
        }
        /**
         * Set color variables
         */
        setColorTokens(colors) {
          const variables = {};
          if (colors.accentHex) {
            variables["--sn.color.accent.hex"] = colors.accentHex;
          }
          if (colors.accentRgb) {
            variables["--sn.color.accent.rgb"] = colors.accentRgb;
          }
          if (colors.primaryRgb) {
            variables["--sn.bg.gradient.primary.rgb"] = colors.primaryRgb;
          }
          if (colors.secondaryRgb) {
            variables["--sn.bg.gradient.secondary.rgb"] = colors.secondaryRgb;
          }
          if (colors.gradientOpacity !== void 0) {
            variables["--sn.bg.gradient.opacity"] = colors.gradientOpacity.toString();
          }
          if (colors.gradientBlur) {
            variables["--sn.bg.gradient.blur"] = colors.gradientBlur;
          }
          this.updateVariables(variables, "high", "color-system");
        }
        /**
         * Set performance variables
         */
        setPerformanceTokens(perf) {
          const variables = {};
          if (perf.webglReady !== void 0) {
            variables["--sn.bg.webgl.ready"] = perf.webglReady ? "1" : "0";
          }
          if (perf.activeBackend) {
            variables["--sn.bg.active-backend"] = perf.activeBackend;
          }
          if (perf.qualityLevel) {
            variables["--sn.perf.quality.level"] = perf.qualityLevel;
          }
          if (perf.reducedMotion !== void 0) {
            variables["--sn.anim.motion.reduced"] = perf.reducedMotion ? "1" : "0";
          }
          if (perf.gpuAcceleration !== void 0) {
            variables["--sn.perf.gpu.acceleration.enabled"] = perf.gpuAcceleration ? "1" : "0";
          }
          this.updateVariables(variables, "high", "performance-system");
        }
        /**
         * Direct property setter (convenience API)
         */
        setProperty(property, value, element = null) {
          if (property.startsWith("--spice-") && this.config.enableSpiceVariableDebug) {
            const caller = new Error().stack?.split("\n")[2]?.trim().replace(/^\s*at\s+/, "") || "unknown";
            console.log(
              `\u{1F527} [CSS Debug] Setting ${property} = ${value} (from: ${caller})`
            );
          }
          this.queueCSSVariableUpdate(property, value, element);
        }
        // ===================================================================
        // PERFORMANCE AND DEVICE OPTIMIZATION METHODS
        // ===================================================================
        /**
         * Apply device-specific CSS classes
         */
        applyDeviceOptimizations() {
          if (!this.cssConfig.enableDeviceTierOptimization || !this.currentDeviceCapabilities)
            return;
          this.removeClassesByPrefix("device-tier-");
          this.removeClassesByPrefix("device-mobile-");
          this.removeClassesByPrefix("device-gpu-");
          const tierClass = `device-tier-${this.currentDeviceCapabilities.performanceTier}`;
          this.addCSSClass(tierClass);
          if (this.currentDeviceCapabilities.isMobile) {
            this.addCSSClass("device-mobile-optimized");
          }
          if (this.currentDeviceCapabilities.gpuAcceleration) {
            this.addCSSClass("device-gpu-accelerated");
          } else {
            this.addCSSClass("device-gpu-fallback");
          }
          const memoryTier = this.getMemoryTier(
            this.currentDeviceCapabilities.memoryGB
          );
          this.addCSSClass(`device-memory-${memoryTier}`);
        }
        /**
         * Apply performance mode CSS classes
         */
        applyPerformanceModeOptimizations() {
          if (!this.currentPerformanceMode) return;
          this.removeClassesByPrefix("performance-mode-");
          const modeClass = `performance-mode-${this.currentPerformanceMode.name}`;
          this.addCSSClass(modeClass);
          const optimizationClass = `optimization-level-${this.currentPerformanceMode.optimizationLevel}`;
          this.addCSSClass(optimizationClass);
        }
        /**
         * Get performance report
         */
        getPerformanceReport() {
          const averageBatchTime = this.performanceMetrics.totalBatches > 0 ? this.performanceMetrics.totalBatchTime / this.performanceMetrics.totalBatches : 0;
          return {
            enabled: true,
            pendingUpdates: this.cssVariableQueue.size + this.updateQueue.size,
            totalUpdates: this.performanceMetrics.totalUpdates,
            totalBatches: this.performanceMetrics.totalBatches,
            averageBatchSize: Math.round(this.performanceMetrics.averageBatchSize * 10) / 10,
            averageBatchTime: Math.round(averageBatchTime * 100) / 100,
            maxBatchTime: Math.round(this.performanceMetrics.maxBatchTime * 100) / 100,
            overBudgetBatches: this.performanceMetrics.overBudgetBatches,
            conflictResolutions: this.performanceMetrics.conflictResolutions,
            transactionCount: this.performanceMetrics.transactionCount,
            consciousnessUpdates: this.performanceMetrics.consciousnessUpdates,
            consciousnessActive: this.consciousnessState !== null,
            deviceTier: this.currentDeviceCapabilities?.performanceTier,
            performanceMode: this.currentPerformanceMode?.name
          };
        }
        // ===================================================================
        // PRIVATE METHODS
        // ===================================================================
        subscribeToEvents() {
          this.eventBus.subscribe("performance:mode-changed", (payload) => {
            this.currentPerformanceMode = this.performanceCoordinator.getCurrentPerformanceMode();
            this.applyPerformanceModeOptimizations();
            this.updateCSSPerformanceVariables();
          });
          this.eventBus.subscribe("performance:thermal-warning", (payload) => {
            this.applyThermalOptimizations(payload.temperature);
          });
          this.eventBus.subscribe("performance:auto-optimized", (payload) => {
            this.currentPerformanceMode = this.performanceCoordinator.getCurrentPerformanceMode();
            this.applyCurrentOptimizations();
            this.updateCSSPerformanceVariables();
          });
        }
        applyInitialOptimizations() {
          this.applyDeviceOptimizations();
          this.applyPerformanceModeOptimizations();
          this.updateCSSPerformanceVariables();
          if (this.cssConfig.debugPerformanceClasses) {
            this.addCSSClass("debug-performance");
          }
        }
        applyCurrentOptimizations() {
          this.applyDeviceOptimizations();
          this.applyPerformanceModeOptimizations();
          const batteryState = this.performanceCoordinator.getBatteryState();
          const thermalState = this.performanceCoordinator.getThermalState();
          if (batteryState) {
            this.applyBatteryOptimizations(batteryState.level, batteryState.charging);
          }
          const thermalTemp = thermalState.temperature || "normal";
          this.applyThermalOptimizations(thermalTemp);
        }
        updateCSSPerformanceVariables() {
          const now = Date.now();
          if (now - this.lastCSSUpdate < this.cssUpdateThrottle) return;
          this.lastCSSUpdate = now;
          if (!this.currentPerformanceMode || !this.currentDeviceCapabilities) return;
          const variables = {
            "--sn.performance.mode": this.currentPerformanceMode.name,
            "--sn.performance.quality.level": this.currentPerformanceMode.qualityLevel.toString(),
            "--sn.performance.fps.target": this.currentPerformanceMode.frameRate.toString(),
            "--sn.performance.frame.budget": (1e3 / this.currentPerformanceMode.frameRate).toString(),
            "--sn.performance.optimization.level": this.currentPerformanceMode.optimizationLevel.toString(),
            "--sn.device.tier": this.currentDeviceCapabilities.performanceTier,
            "--sn.device.memory": this.currentDeviceCapabilities.memoryGB.toString(),
            "--sn.device.gpu": this.currentDeviceCapabilities.gpuAcceleration ? "1" : "0",
            "--sn.device.mobile": this.currentDeviceCapabilities.isMobile ? "1" : "0",
            "--sn.performance.blur.quality": this.currentPerformanceMode.blurQuality.toString(),
            "--sn.performance.shadow.quality": this.currentPerformanceMode.shadowQuality.toString(),
            "--sn.performance.animation.quality": this.currentPerformanceMode.animationQuality.toString(),
            "--sn.performance.effect.quality": this.currentPerformanceMode.effectQuality.toString()
          };
          this.updateVariables(variables, "high", "performance-coordinator");
        }
        startConsciousnessIntegration() {
          if (this.consciousnessUpdateTimer) return;
          const updateConsciousness = /* @__PURE__ */ __name(() => {
            const now = performance.now();
            if (now - this.lastConsciousnessUpdate >= this.cssConfig.consciousnessUpdateInterval) {
              this.lastConsciousnessUpdate = now;
              if (this.consciousnessState) {
                this.updateConsciousnessVariables(this.consciousnessState);
              }
            }
            this.consciousnessUpdateTimer = setTimeout(
              updateConsciousness,
              this.cssConfig.consciousnessUpdateInterval
            );
          }, "updateConsciousness");
          updateConsciousness();
        }
        shouldReplaceUpdate(existing, incoming) {
          const existingWeight = this.PRIORITY_WEIGHTS[existing.priority];
          const incomingWeight = this.PRIORITY_WEIGHTS[incoming.priority];
          if (incomingWeight > existingWeight) {
            return true;
          }
          if (incomingWeight === existingWeight) {
            return incoming.timestamp > existing.timestamp;
          }
          return false;
        }
        scheduleFlush(priority) {
          if (this.rafHandle !== null || this.microtaskScheduled) {
            return;
          }
          const flushCallback = /* @__PURE__ */ __name(() => {
            this.rafHandle = null;
            this.microtaskScheduled = false;
            this.flushCSSVariableBatch();
          }, "flushCallback");
          if (typeof document !== "undefined" && document.visibilityState === "hidden") {
            this.microtaskScheduled = true;
            queueMicrotask(flushCallback);
          } else if (typeof requestAnimationFrame === "function") {
            this.rafHandle = requestAnimationFrame(flushCallback);
          } else {
            setTimeout(flushCallback, 0);
          }
        }
        updatePerformanceMetrics(batchTime, batchSize) {
          this.performanceMetrics.totalBatches++;
          this.performanceMetrics.totalBatchTime += batchTime;
          this.performanceMetrics.maxBatchTime = Math.max(
            this.performanceMetrics.maxBatchTime,
            batchTime
          );
          this.performanceMetrics.averageBatchSize = (this.performanceMetrics.averageBatchSize * (this.performanceMetrics.totalBatches - 1) + batchSize) / this.performanceMetrics.totalBatches;
          if (batchTime > 8) {
            this.performanceMetrics.overBudgetBatches++;
            if (this.config.enableDebug) {
              console.warn(
                `[UnifiedCSSConsciousnessController] CSS batch took ${batchTime.toFixed(
                  2
                )}ms for ${batchSize} updates`
              );
            }
          }
        }
        enableGlobalHijack() {
          if (_UnifiedCSSConsciousnessController.hijackEnabled) return;
          const original = CSSStyleDeclaration.prototype.setProperty;
          _UnifiedCSSConsciousnessController.nativeSetProperty = original;
          const controllerInstance = this;
          CSSStyleDeclaration.prototype.setProperty = function(prop, value, priority) {
            if (prop && (prop.startsWith("--sn-") || prop.startsWith("--sn.")) && controllerInstance) {
              controllerInstance.queueCSSVariableUpdate(prop, String(value ?? ""));
            } else {
              original.call(this, prop, value, priority);
            }
          };
          _UnifiedCSSConsciousnessController.hijackEnabled = true;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSConsciousnessController] Global setProperty hijack enabled (--sn- and --sn. namespaces)"
            );
          }
        }
        addCSSClass(className) {
          if (!this.appliedClasses.has(className)) {
            document.body.classList.add(className);
            this.appliedClasses.add(className);
          }
        }
        removeCSSClass(className) {
          if (this.appliedClasses.has(className)) {
            document.body.classList.remove(className);
            this.appliedClasses.delete(className);
          }
        }
        removeClassesByPrefix(prefix) {
          const classesToRemove = Array.from(this.appliedClasses).filter(
            (className) => className.startsWith(prefix)
          );
          for (const className of classesToRemove) {
            this.removeCSSClass(className);
          }
        }
        getMemoryTier(memoryGB) {
          if (memoryGB >= 16) return "high";
          if (memoryGB >= 8) return "medium";
          if (memoryGB >= 4) return "low";
          return "minimal";
        }
        applyThermalOptimizations(thermalState) {
          if (!this.cssConfig.enableThermalThrottling) return;
          this.removeClassesByPrefix("thermal-");
          const thermalClass = `thermal-${thermalState}`;
          this.addCSSClass(thermalClass);
        }
        applyBatteryOptimizations(batteryLevel, charging) {
          if (!this.cssConfig.enableBatteryOptimization) return;
          this.removeClassesByPrefix("battery-");
          if (batteryLevel < 0.2) {
            this.addCSSClass("battery-low");
          } else if (batteryLevel < 0.5) {
            this.addCSSClass("battery-medium");
          } else {
            this.addCSSClass("battery-high");
          }
          if (charging) {
            this.addCSSClass("battery-charging");
          }
        }
        // ===================================================================
        // CONVENIENCE METHODS FROM UNIFIEDCSSVARIABLEMANAGER
        // ===================================================================
        /**
         * Update music system variables (from UnifiedCSSVariableManager)
         */
        updateMusicVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-music-${key.replace(/\./g, "-")}`;
              updates[fullKey] = String(value);
            }
          }
          this.updateVariables(updates, "critical", "music-system");
        }
        /**
         * Update color system variables (from UnifiedCSSVariableManager)
         */
        updateColorVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-color-${key.replace(/\./g, "-")}`;
              updates[fullKey] = String(value);
            }
          }
          this.updateVariables(updates, "high", "color-system");
        }
        /**
         * Update animation system variables (from UnifiedCSSVariableManager)
         */
        updateAnimationVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-anim-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.updateVariables(updates, "normal", "animation-system");
        }
        /**
         * Update performance system variables (from UnifiedCSSVariableManager)
         */
        updatePerformanceVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-performance-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.updateVariables(updates, "high", "performance-system");
        }
        /**
         * Update utility system variables (from UnifiedCSSVariableManager)
         */
        updateUtilityVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.updateVariables(updates, "low", "utility-system");
        }
        /**
         * Queue a CSS variable update (from UnifiedCSSVariableManager compatibility)
         */
        queueUpdate(property, value, priority = "normal", source = "unknown") {
          this.queueCSSVariableUpdate(property, value, null, priority, source);
        }
        /**
         * Queue multiple CSS variable updates in a transaction (from UnifiedCSSVariableManager)
         */
        queueTransaction(variables, priority = "normal", source = "unknown") {
          const transactionId = `tx_${++this.transactionCounter}`;
          const variableMap = new Map(Object.entries(variables));
          const transaction = {
            id: transactionId,
            variables: variableMap,
            timestamp: performance.now(),
            priority,
            completed: false
          };
          this.pendingTransactions.set(transactionId, transaction);
          for (const [property, value] of variableMap) {
            this.queueUpdate(property, value, priority, `${source}:${transactionId}`);
          }
          this.performanceMetrics.transactionCount++;
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSConsciousnessController] Transaction ${transactionId} queued with ${variableMap.size} variables`
            );
          }
          return transactionId;
        }
        /**
         * Force immediate flush (from UnifiedCSSVariableManager)
         */
        forceFlush() {
          this.flushCSSVariableBatch();
        }
        /**
         * Register a variable group (from UnifiedCSSVariableManager compatibility)
         */
        registerVariableGroup(name, priority = "normal", batchSize = 50, flushInterval = 16) {
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSConsciousnessController] Variable group registration: ${name} (handled internally)`
            );
          }
        }
        /**
         * Update variables in a specific group (from UnifiedCSSVariableManager compatibility)
         */
        updateVariableGroup(groupName, variables, source = "unknown") {
          this.updateVariables(variables, "normal", `group:${groupName}:${source}`);
        }
        /**
         * Update configuration (from CSSVariableBatcher compatibility)
         */
        updateConfig(newConfig) {
          this.cssConfig = { ...this.cssConfig, ...newConfig };
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSConsciousnessController] Configuration updated:",
              newConfig
            );
          }
        }
        // ===================================================================
        // LEGACY COMPATIBILITY METHODS
        // ===================================================================
        // For backwards compatibility with UnifiedCSSConsciousnessController API
        flushNow() {
          this.flushCSSVariableBatch();
        }
        setBatchingEnabled(enabled) {
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSConsciousnessController] Batching ${enabled ? "enabled" : "disabled"}`
            );
          }
        }
        addCriticalVariable(variable) {
          CRITICAL_NOW_PLAYING_VARS.add(variable);
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSConsciousnessController] Added critical variable: ${variable}`
            );
          }
        }
        removeCriticalVariable(variable) {
          CRITICAL_NOW_PLAYING_VARS.delete(variable);
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSConsciousnessController] Removed critical variable: ${variable}`
            );
          }
        }
        isCriticalVariable(variable) {
          return CRITICAL_NOW_PLAYING_VARS.has(variable);
        }
        getCriticalVariables() {
          return Array.from(CRITICAL_NOW_PLAYING_VARS);
        }
        // ===================================================================
        // SIMPLIFIED COORDINATION PATTERNS (Extracted from SharedVariableCoordination.ts)
        // ===================================================================
        /**
         * Update consciousness intensity with simplified coordination through UnifiedEventBus
         * Replaces the complex ConsciousnessIntensityCoordinator pattern with a simple subscription-based approach
         */
        updateConsciousnessIntensity(intensity, sourceStrategy, musicEnergy) {
          const clampedIntensity = Math.max(0, Math.min(1, intensity));
          this.queueCSSVariableUpdate(
            "--consciousness-intensity",
            clampedIntensity.toString(),
            null,
            "high",
            `consciousness-${sourceStrategy}`
          );
          if (this.unifiedEventBus) {
            this.unifiedEventBus.emitSync("consciousness:intensity-changed", {
              intensity: clampedIntensity,
              userEngagement: 0.5,
              // Default engagement level
              timestamp: Date.now(),
              sourceStrategy,
              musicEnergy: musicEnergy ?? 0
            });
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSConsciousnessController] Consciousness intensity updated by ${sourceStrategy}: ${clampedIntensity}`
            );
          }
        }
        /**
         * Update crossfade opacity with simplified coordination through UnifiedEventBus
         * Replaces the complex CrossfadeOpacityCoordinator pattern with a simple subscription-based approach
         */
        updateCrossfadeOpacity(opacity, sourceStrategy, webglEnabled) {
          let finalOpacity = Math.max(0, Math.min(1, opacity));
          if (!webglEnabled) {
            finalOpacity = 0;
          }
          this.queueCSSVariableUpdate(
            "--sn-gradient-crossfade-opacity",
            finalOpacity.toString(),
            null,
            "high",
            `crossfade-${sourceStrategy}`
          );
          if (this.unifiedEventBus) {
            this.unifiedEventBus.emitSync("gradient:crossfade-changed", {
              opacity: finalOpacity,
              sourceStrategy,
              webglEnabled,
              timestamp: Date.now()
            });
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSConsciousnessController] Crossfade opacity updated by ${sourceStrategy}: ${finalOpacity} (WebGL: ${webglEnabled})`
            );
          }
        }
        /**
         * Subscribe to consciousness intensity changes from other strategies
         */
        subscribeToConsciousnessChanges(callback) {
          if (!this.unifiedEventBus) {
            console.warn(
              "[UnifiedCSSConsciousnessController] No UnifiedEventBus available for consciousness subscriptions"
            );
            return () => {
            };
          }
          const subscriptionId = this.unifiedEventBus.subscribe(
            "consciousness:intensity-changed",
            callback,
            "UnifiedCSSConsciousnessController"
          );
          return () => this.unifiedEventBus?.unsubscribe(subscriptionId);
        }
        /**
         * Subscribe to crossfade opacity changes from other strategies
         */
        subscribeToCrossfadeChanges(callback) {
          if (!this.unifiedEventBus) {
            console.warn(
              "[UnifiedCSSConsciousnessController] No UnifiedEventBus available for crossfade subscriptions"
            );
            return () => {
            };
          }
          const subscriptionId = this.unifiedEventBus.subscribe(
            "gradient:crossfade-changed",
            callback,
            "UnifiedCSSConsciousnessController"
          );
          return () => this.unifiedEventBus?.unsubscribe(subscriptionId);
        }
      };
      __name(_UnifiedCSSConsciousnessController, "UnifiedCSSConsciousnessController");
      _UnifiedCSSConsciousnessController.instance = null;
      _UnifiedCSSConsciousnessController.hijackEnabled = false;
      UnifiedCSSConsciousnessController = _UnifiedCSSConsciousnessController;
    }
  });

  // src-js/utils/color/OKLABColorProcessor.ts
  var _OKLABColorProcessor, OKLABColorProcessor;
  var init_OKLABColorProcessor = __esm({
    "src-js/utils/color/OKLABColorProcessor.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_Year3000Utilities();
      _OKLABColorProcessor = class _OKLABColorProcessor {
        constructor(enableDebug = false) {
          this.utils = Year3000Utilities_exports;
          this.debugEnabled = enableDebug;
        }
        /**
         * Process a color through OKLAB space with enhancement preset
         */
        processColor(hexColor, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const startTime = performance.now();
          let originalRgb = null;
          try {
            originalRgb = this.utils.hexToRgb(hexColor);
            if (!originalRgb) {
              throw new Error(`Invalid hex color: ${hexColor}`);
            }
            const oklabOriginal = this.utils.rgbToOklab(originalRgb.r, originalRgb.g, originalRgb.b);
            const oklabEnhanced = this.enhanceOKLABColor(oklabOriginal, preset);
            const oklabShadow = this.generateShadowColor(oklabOriginal, preset);
            const enhancedRgb = this.utils.oklabToRgb(oklabEnhanced.L, oklabEnhanced.a, oklabEnhanced.b);
            const shadowRgb = this.utils.oklabToRgb(oklabShadow.L, oklabShadow.a, oklabShadow.b);
            const enhancedHex = this.utils.rgbToHex(enhancedRgb.r, enhancedRgb.g, enhancedRgb.b);
            const shadowHex = this.utils.rgbToHex(shadowRgb.r, shadowRgb.g, shadowRgb.b);
            const oklchEnhanced = this.convertOklabToOklch(oklabEnhanced);
            const processingTime = performance.now() - startTime;
            const result = {
              originalHex: hexColor,
              originalRgb,
              enhancedHex,
              enhancedRgb,
              shadowHex,
              shadowRgb,
              oklabOriginal,
              oklabEnhanced,
              oklabShadow,
              oklchEnhanced,
              processingTime
            };
            if (this.debugEnabled) {
              Y3K?.debug?.log("OKLABColorProcessor", "Color processed:", {
                input: hexColor,
                enhanced: enhancedHex,
                shadow: shadowHex,
                preset: preset.name,
                processingTime: `${processingTime.toFixed(2)}ms`
              });
            }
            return result;
          } catch (error) {
            if (this.debugEnabled) {
              Y3K?.debug?.error("OKLABColorProcessor", "Color processing failed:", error);
            }
            const fallbackRgb = originalRgb || { r: 124, g: 58, b: 237 };
            return this.createFallbackResult(hexColor, fallbackRgb);
          }
        }
        /**
         * Process multiple colors with consistent enhancement
         */
        processColorPalette(colors, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const results = {};
          Object.entries(colors).forEach(([key, hex]) => {
            if (hex && this.utils.hexToRgb(hex)) {
              results[key] = this.processColor(hex, preset);
            }
          });
          return results;
        }
        /**
         * Generate CSS variables from processed color
         */
        generateCSSVariables(processed, prefix = "sn-oklab") {
          const cssVars = {};
          cssVars[`--${prefix}-enhanced-hex`] = processed.enhancedHex;
          cssVars[`--${prefix}-enhanced-rgb`] = `${processed.enhancedRgb.r},${processed.enhancedRgb.g},${processed.enhancedRgb.b}`;
          cssVars[`--${prefix}-enhanced-r`] = Math.round(processed.enhancedRgb.r).toString();
          cssVars[`--${prefix}-enhanced-g`] = Math.round(processed.enhancedRgb.g).toString();
          cssVars[`--${prefix}-enhanced-b`] = Math.round(processed.enhancedRgb.b).toString();
          cssVars[`--${prefix}-shadow-hex`] = processed.shadowHex;
          cssVars[`--${prefix}-shadow-rgb`] = `${processed.shadowRgb.r},${processed.shadowRgb.g},${processed.shadowRgb.b}`;
          cssVars[`--${prefix}-lightness`] = processed.oklabEnhanced.L.toFixed(3);
          cssVars[`--${prefix}-chroma-a`] = processed.oklabEnhanced.a.toFixed(3);
          cssVars[`--${prefix}-chroma-b`] = processed.oklabEnhanced.b.toFixed(3);
          cssVars[`--${prefix}-oklch-l`] = processed.oklchEnhanced.L.toFixed(3);
          cssVars[`--${prefix}-oklch-c`] = processed.oklchEnhanced.C.toFixed(3);
          cssVars[`--${prefix}-oklch-h`] = processed.oklchEnhanced.H.toFixed(1);
          return cssVars;
        }
        /**
         * Interpolate between two colors in OKLAB space
         */
        interpolateOKLAB(color1Hex, color2Hex, factor, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const rgb1 = this.utils.hexToRgb(color1Hex);
          const rgb2 = this.utils.hexToRgb(color2Hex);
          if (!rgb1 || !rgb2) {
            throw new Error("Invalid hex colors for interpolation");
          }
          const oklab1 = this.utils.rgbToOklab(rgb1.r, rgb1.g, rgb1.b);
          const oklab2 = this.utils.rgbToOklab(rgb2.r, rgb2.g, rgb2.b);
          const interpolatedOklab = {
            L: oklab1.L + (oklab2.L - oklab1.L) * factor,
            a: oklab1.a + (oklab2.a - oklab1.a) * factor,
            b: oklab1.b + (oklab2.b - oklab1.b) * factor
          };
          const interpolatedRgb = this.utils.oklabToRgb(interpolatedOklab.L, interpolatedOklab.a, interpolatedOklab.b);
          const interpolatedHex = this.utils.rgbToHex(interpolatedRgb.r, interpolatedRgb.g, interpolatedRgb.b);
          return this.processColor(interpolatedHex, preset);
        }
        /**
         * Generate gradient stops in OKLAB space
         */
        generateOKLABGradient(startHex, endHex, stopCount = 5, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const gradientStops = [];
          for (let i = 0; i < stopCount; i++) {
            const factor = i / (stopCount - 1);
            const interpolated = this.interpolateOKLAB(startHex, endHex, factor, preset);
            gradientStops.push(interpolated);
          }
          return gradientStops;
        }
        /**
         * Enhance color in OKLAB space
         */
        enhanceOKLABColor(oklab, preset) {
          const currentChroma = Math.sqrt(oklab.a * oklab.a + oklab.b * oklab.b);
          const enhancedL = Math.min(1, Math.max(0, oklab.L * preset.lightnessBoost));
          const chromaMultiplier = currentChroma > preset.vibrantThreshold ? preset.chromaBoost : 1;
          const enhancedA = oklab.a * chromaMultiplier;
          const enhancedB = oklab.b * chromaMultiplier;
          return { L: enhancedL, a: enhancedA, b: enhancedB };
        }
        /**
         * Generate shadow color by reducing lightness while preserving hue
         */
        generateShadowColor(oklab, preset) {
          return {
            L: Math.max(0.02, oklab.L * preset.shadowReduction),
            a: oklab.a * 0.8,
            // Slightly desaturate shadows
            b: oklab.b * 0.8
          };
        }
        /**
         * Convert OKLAB to OKLCH (cylindrical representation)
         */
        convertOklabToOklch(oklab) {
          const L = oklab.L;
          const C = Math.sqrt(oklab.a * oklab.a + oklab.b * oklab.b);
          let H = Math.atan2(oklab.b, oklab.a) * (180 / Math.PI);
          if (H < 0) H += 360;
          return { L, C, H };
        }
        /**
         * Create fallback result for error cases
         */
        createFallbackResult(hexColor, fallbackRgb) {
          const fallbackOklab = this.utils.rgbToOklab(fallbackRgb.r, fallbackRgb.g, fallbackRgb.b);
          return {
            originalHex: hexColor,
            originalRgb: fallbackRgb,
            enhancedHex: hexColor,
            enhancedRgb: fallbackRgb,
            shadowHex: "#000000",
            shadowRgb: { r: 0, g: 0, b: 0 },
            oklabOriginal: fallbackOklab,
            oklabEnhanced: fallbackOklab,
            oklabShadow: { L: 0.05, a: 0, b: 0 },
            oklchEnhanced: this.convertOklabToOklch(fallbackOklab),
            processingTime: 0
          };
        }
        /**
         * Get preset by name with fallback
         */
        static getPreset(name) {
          return _OKLABColorProcessor.PRESETS[name.toUpperCase()] || _OKLABColorProcessor.PRESETS.STANDARD;
        }
        /**
         * Create custom preset
         */
        static createCustomPreset(name, description, lightnessBoost, chromaBoost, shadowReduction = 0.3, vibrantThreshold = 0.1) {
          return {
            name,
            description,
            lightnessBoost: Math.max(0.5, Math.min(1.5, lightnessBoost)),
            chromaBoost: Math.max(0.5, Math.min(2, chromaBoost)),
            shadowReduction: Math.max(0.1, Math.min(0.5, shadowReduction)),
            vibrantThreshold: Math.max(0.05, Math.min(0.2, vibrantThreshold))
          };
        }
      };
      __name(_OKLABColorProcessor, "OKLABColorProcessor");
      // Built-in enhancement presets
      _OKLABColorProcessor.PRESETS = {
        SUBTLE: {
          name: "Subtle Enhancement",
          description: "Minimal color enhancement for conservative aesthetics",
          lightnessBoost: 1.05,
          chromaBoost: 1.1,
          shadowReduction: 0.4,
          vibrantThreshold: 0.08
        },
        STANDARD: {
          name: "Standard Enhancement",
          description: "Balanced color enhancement for general use",
          lightnessBoost: 1.1,
          chromaBoost: 1.15,
          shadowReduction: 0.3,
          vibrantThreshold: 0.1
        },
        VIBRANT: {
          name: "Vibrant Enhancement",
          description: "Enhanced vibrancy for dynamic color experiences",
          lightnessBoost: 1.15,
          chromaBoost: 1.25,
          shadowReduction: 0.25,
          vibrantThreshold: 0.12
        },
        COSMIC: {
          name: "Cosmic Enhancement",
          description: "Maximum enhancement for Year 3000 consciousness experiences",
          lightnessBoost: 1.2,
          chromaBoost: 1.35,
          shadowReduction: 0.2,
          vibrantThreshold: 0.15
        }
      };
      OKLABColorProcessor = _OKLABColorProcessor;
    }
  });

  // src-js/visual/strategies/DynamicCatppuccinStrategy.ts
  var _DynamicCatppuccinStrategy, DynamicCatppuccinStrategy;
  var init_DynamicCatppuccinStrategy = __esm({
    "src-js/visual/strategies/DynamicCatppuccinStrategy.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_globalConfig();
      init_SettingsManager();
      init_UnifiedCSSConsciousnessController();
      init_Year3000Utilities();
      init_OKLABColorProcessor();
      _DynamicCatppuccinStrategy = class _DynamicCatppuccinStrategy {
        constructor(settingsManager, cssController) {
          this.utils = Year3000Utilities_exports;
          this.config = YEAR3000_CONFIG;
          this.dynamicColorState = {
            currentAccentHex: "#7c3aed",
            // Default StarryNight cosmic purple
            currentAccentRgb: "124,58,237",
            baseBackgroundHex: "#0d1117",
            // Default StarryNight deep space black
            baseBackgroundRgb: "13,17,23",
            lastUpdateTime: 0,
            musicEnergy: 0.5,
            transitionInProgress: false
          };
          this.integrationConfig = {
            accentUpdateEnabled: true,
            baseTransformationEnabled: true,
            consciousnessIntegrationEnabled: true,
            oklabEnhancementEnabled: true,
            smoothTransitionDuration: 800,
            // 0.8s smooth transitions
            energyResponseMultiplier: 1.2,
            oklabPreset: "VIBRANT"
            // Use vibrant OKLAB enhancement
          };
          // Transition management
          this.transitionTimer = 0;
          this.lastTransitionStartTime = 0;
          this.transitionFromAccent = "";
          this.transitionToAccent = "";
          this.settingsManager = settingsManager || new SettingsManager();
          this.cssController = cssController || UnifiedCSSConsciousnessController.getInstance();
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.initializeCurrentState();
          Y3K?.debug?.log("DynamicCatppuccinStrategy", "Color strategy initialized with CSS coordinator and OKLAB processing");
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "dynamic-catppuccin";
        }
        /**
         * Check if strategy can handle the given context
         */
        canProcess(context) {
          return this.checkDynamicAccentEnabled();
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          return 5;
        }
        /**
         * Process colors using Dynamic Catppuccin strategy with OKLAB enhancement
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const newAccentHex = this.selectBestAccentColor(context.rawColors);
            if (!newAccentHex) {
              throw new Error("No suitable accent color found in extracted colors");
            }
            let processedAccentHex = newAccentHex;
            let processedAccentRgb = this.utils.hexToRgb(newAccentHex);
            let oklabResult = null;
            if (this.integrationConfig.oklabEnhancementEnabled) {
              const preset = OKLABColorProcessor.getPreset(this.integrationConfig.oklabPreset);
              oklabResult = this.oklabProcessor.processColor(newAccentHex, preset);
              processedAccentHex = oklabResult.enhancedHex;
              processedAccentRgb = oklabResult.enhancedRgb;
              Y3K?.debug?.log("DynamicCatppuccinStrategy", "OKLAB color enhancement applied:", {
                original: newAccentHex,
                enhanced: processedAccentHex,
                preset: preset.name,
                processingTime: `${oklabResult.processingTime.toFixed(2)}ms`
              });
            }
            await this.applyColorFacade(processedAccentHex, context.rawColors, oklabResult);
            this.dynamicColorState.currentAccentHex = processedAccentHex;
            if (processedAccentRgb) {
              this.dynamicColorState.currentAccentRgb = `${processedAccentRgb.r},${processedAccentRgb.g},${processedAccentRgb.b}`;
            }
            this.dynamicColorState.lastUpdateTime = Date.now();
            if (context.musicData?.energy !== void 0) {
              this.dynamicColorState.musicEnergy = context.musicData.energy;
              await this.updateConsciousnessWithMusicEnergy(context.musicData.energy);
            }
            const processingTime = performance.now() - startTime;
            const result = {
              processedColors: {
                accent: processedAccentHex,
                primary: processedAccentHex,
                originalAccent: newAccentHex,
                // Keep original for reference
                ...context.rawColors
              },
              accentHex: processedAccentHex,
              accentRgb: this.dynamicColorState.currentAccentRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `dynamic-catppuccin-${context.trackUri}`,
                harmonicIntensity: this.integrationConfig.energyResponseMultiplier,
                oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
                oklabPreset: this.integrationConfig.oklabPreset,
                ...oklabResult && { oklabMetadata: {
                  originalHex: oklabResult.originalHex,
                  enhancedHex: oklabResult.enhancedHex,
                  shadowHex: oklabResult.shadowHex,
                  oklabProcessingTime: oklabResult.processingTime
                } }
              },
              context
            };
            Y3K?.debug?.log("DynamicCatppuccinStrategy", "Color processing completed", {
              originalAccent: newAccentHex,
              processedAccent: processedAccentHex,
              oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
              processingTime,
              trackUri: context.trackUri
            });
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3K?.debug?.error("DynamicCatppuccinStrategy", "Color processing failed:", error);
            return {
              processedColors: context.rawColors,
              accentHex: this.dynamicColorState.currentAccentHex,
              accentRgb: this.dynamicColorState.currentAccentRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error"
              },
              context
            };
          }
        }
        /**
         * Check if dynamic accent is enabled in settings
         */
        checkDynamicAccentEnabled() {
          try {
            const accentSetting = this.settingsManager.get("catppuccin-accentColor");
            const isDynamic = String(accentSetting) === "dynamic";
            if (this.config.enableDebug) {
              Y3K?.debug?.log("DynamicCatppuccinStrategy", `Accent setting: ${accentSetting}, Dynamic: ${isDynamic}`);
            }
            return isDynamic;
          } catch (error) {
            Y3K?.debug?.error("DynamicCatppuccinStrategy", "Error checking dynamic accent setting:", error);
            return false;
          }
        }
        /**
         * Initialize current state from existing CSS variables
         */
        initializeCurrentState() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentAccent = computedStyle.getPropertyValue("--spice-accent").trim() || computedStyle.getPropertyValue("--sn-color-accent-hex").trim();
          if (currentAccent) {
            this.dynamicColorState.currentAccentHex = currentAccent;
            const rgb = this.utils.hexToRgb(currentAccent);
            if (rgb) {
              this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
            }
          }
          const currentBase = computedStyle.getPropertyValue("--spice-base").trim() || "#1e1e2e";
          this.dynamicColorState.baseBackgroundHex = currentBase;
          const baseRgb = this.utils.hexToRgb(currentBase);
          if (baseRgb) {
            this.dynamicColorState.baseBackgroundRgb = `${baseRgb.r},${baseRgb.g},${baseRgb.b}`;
          }
          this.dynamicColorState.lastUpdateTime = Date.now();
          Y3K?.debug?.log("DynamicCatppuccinStrategy", "Current state initialized:", {
            accent: this.dynamicColorState.currentAccentHex,
            base: this.dynamicColorState.baseBackgroundHex
          });
        }
        /**
         * Select best accent color from extracted colors
         */
        selectBestAccentColor(colors) {
          const priorities = [
            "VIBRANT_NON_ALARMING",
            // Best for UI - vibrant but not overwhelming
            "VIBRANT",
            // Strong and lively
            "LIGHT_VIBRANT",
            // Lighter variant
            "PROMINENT",
            // Most noticeable color
            "PRIMARY",
            // Primary extracted color
            "DARK_VIBRANT"
            // Darker variant as fallback
          ];
          for (const key of priorities) {
            const color2 = colors[key];
            if (color2 && this.utils.hexToRgb(color2)) {
              return color2;
            }
          }
          return null;
        }
        /**
         * Apply colors using Color Extension Facade pattern with coordinated updates
         * Updates both core Spicetify variables AND consciousness extensions with OKLAB enhancement
         */
        async applyColorFacade(accentHex, rawColors, oklabResult) {
          const rgb = this.utils.hexToRgb(accentHex);
          if (!rgb) return;
          const rgbString = `${rgb.r},${rgb.g},${rgb.b}`;
          const variablesToUpdate = {
            // Dynamic color variables (highest priority) - updated by music systems
            "--sn-dynamic-accent-hex": accentHex,
            "--sn-dynamic-accent-rgb": rgbString,
            "--sn-dynamic-primary-hex": accentHex,
            "--sn-dynamic-primary-rgb": rgbString,
            // Core Spicetify variables for compatibility
            "--spice-accent": accentHex,
            "--spice-button": accentHex,
            "--spice-button-active": accentHex,
            "--spice-rgb-accent": rgbString,
            "--spice-rgb-button": rgbString,
            // Extracted color variables for ColorHarmonyEngine
            "--sn-color-extracted-primary-rgb": rgbString,
            "--sn-color-extracted-vibrant-rgb": rgbString,
            "--sn-color-extracted-dominant-rgb": rgbString
          };
          if (oklabResult && this.integrationConfig.oklabEnhancementEnabled) {
            const oklabCSSVars = this.oklabProcessor.generateCSSVariables(oklabResult, "sn-oklab-accent");
            Object.assign(variablesToUpdate, {
              ...oklabCSSVars,
              // Enhanced shadow variables for depth effects
              "--sn-dynamic-shadow-hex": oklabResult.shadowHex,
              "--sn-dynamic-shadow-rgb": `${oklabResult.shadowRgb.r},${oklabResult.shadowRgb.g},${oklabResult.shadowRgb.b}`,
              // OKLCH variables for advanced CSS features
              "--sn-accent-oklch-l": oklabResult.oklchEnhanced.L.toFixed(3),
              "--sn-accent-oklch-c": oklabResult.oklchEnhanced.C.toFixed(3),
              "--sn-accent-oklch-h": oklabResult.oklchEnhanced.H.toFixed(1)
            });
            Y3K?.debug?.log("DynamicCatppuccinStrategy", "Added OKLAB-enhanced CSS variables:", {
              oklabVarsCount: Object.keys(oklabCSSVars).length,
              enhancedHex: oklabResult.enhancedHex,
              shadowHex: oklabResult.shadowHex
            });
          }
          if (this.cssController) {
            this.cssController.updateVariables(variablesToUpdate, "high", "core-spicetify-facade");
          }
          const primaryColor = rawColors["PRIMARY"] || rawColors["VIBRANT"];
          if (primaryColor) {
            await this.updateLivingBaseBackground(primaryColor);
          }
          if (this.integrationConfig.consciousnessIntegrationEnabled) {
            await this.updateConsciousnessWithAccent(accentHex, rgbString);
          }
          Y3K?.debug?.log("DynamicCatppuccinStrategy", `Applied coordinated color facade - Spicetify: ${accentHex}, Consciousness extensions updated`, {
            oklabProcessing: !!oklabResult,
            variableCount: Object.keys(variablesToUpdate).length
          });
        }
        /**
         * Update living base background using coordinated variable updates
         * Preserves Spicetify base while adding consciousness layers
         */
        async updateLivingBaseBackground(primaryHex) {
          const primaryRgb = this.utils.hexToRgb(primaryHex);
          if (!primaryRgb) return;
          const primaryRgbString = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          const consciousnessGradient = `
      linear-gradient(135deg, 
        var(--spice-base) 0%,
        rgba(${primaryRgbString}, 0.08) 30%,
        var(--spice-base) 70%
      ),
      var(--spice-base)
    `;
          const livingBaseVariables = {
            // Dynamic secondary colors
            "--sn-dynamic-secondary-hex": primaryHex,
            "--sn-dynamic-secondary-rgb": primaryRgbString,
            // Extracted color system for consciousness effects
            "--sn-color-extracted-secondary-rgb": primaryRgbString,
            "--sn-color-harmony-complementary-rgb": primaryRgbString,
            // Living gradient enhancements
            "--living-base-gradient": consciousnessGradient,
            "--consciousness-base-gradient": consciousnessGradient
          };
          if (this.cssController) {
            this.cssController.updateVariables(livingBaseVariables, "normal", "living-base-background");
          }
          Y3K?.debug?.log("DynamicCatppuccinStrategy", `Coordinated living base facade updated - Primary: ${primaryHex}, preserving --spice-base`);
        }
        /**
         * Update consciousness system with new accent awareness using coordinated updates
         */
        async updateConsciousnessWithAccent(accentHex, accentRgb) {
          const consciousnessVariables = {
            // Holographic consciousness variables
            "--organic-holographic-rgb": accentRgb,
            "--holographic-scanline-rgb": accentRgb,
            // Depth consciousness variables
            "--consciousness-intensity": `calc(0.5 + var(--musical-sync-intensity) * ${this.integrationConfig.energyResponseMultiplier})`
          };
          if (this.cssController) {
            this.cssController.updateVariables(consciousnessVariables, "normal", "consciousness-accent-integration");
          }
        }
        /**
         * Update consciousness with music energy using coordinated updates
         */
        async updateConsciousnessWithMusicEnergy(energy) {
          const adjustedEnergy = energy * this.integrationConfig.energyResponseMultiplier;
          const baseIntensity = 0.5;
          const consciousnessIntensity = Math.max(0.1, Math.min(1, baseIntensity + adjustedEnergy * 0.3));
          const musicEnergyVariables = {
            "--musical-sync-intensity": adjustedEnergy.toString(),
            "--holographic-music-flicker-intensity": adjustedEnergy.toString(),
            "--consciousness-intensity": consciousnessIntensity.toString()
          };
          if (this.cssController) {
            this.cssController.updateVariables(musicEnergyVariables, "high", "consciousness-music-energy");
            this.cssController.updateConsciousnessIntensity(
              parseFloat(consciousnessIntensity.toString()),
              "DynamicCatppuccinStrategy",
              adjustedEnergy
            );
          }
        }
        /**
         * Get current dynamic color state for debugging
         */
        getDynamicColorState() {
          return { ...this.dynamicColorState };
        }
        /**
         * Update integration configuration
         */
        updateConfig(newConfig) {
          this.integrationConfig = { ...this.integrationConfig, ...newConfig };
          if ("oklabEnhancementEnabled" in newConfig || "oklabPreset" in newConfig) {
            this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          }
          Y3K?.debug?.log("DynamicCatppuccinStrategy", "Configuration updated:", {
            ...newConfig,
            oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
            oklabPreset: this.integrationConfig.oklabPreset
          });
        }
        /**
         * Health check for strategy status
         */
        async healthCheck() {
          const isDynamicEnabled = this.checkDynamicAccentEnabled();
          const hasRecentUpdate = Date.now() - this.dynamicColorState.lastUpdateTime < 3e4;
          return {
            healthy: isDynamicEnabled,
            canProcess: isDynamicEnabled,
            issues: !isDynamicEnabled ? ["Dynamic accent not enabled in settings"] : [],
            metrics: {
              dynamicAccentEnabled: isDynamicEnabled,
              currentAccent: this.dynamicColorState.currentAccentHex,
              lastUpdateAge: Date.now() - this.dynamicColorState.lastUpdateTime,
              hasRecentUpdate,
              transitionInProgress: this.dynamicColorState.transitionInProgress,
              musicEnergy: this.dynamicColorState.musicEnergy,
              oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
              oklabPreset: this.integrationConfig.oklabPreset,
              consciousnessIntegration: this.integrationConfig.consciousnessIntegrationEnabled
            }
          };
        }
        /**
         * Cleanup resources
         */
        destroy() {
          if (this.transitionTimer) {
            clearTimeout(this.transitionTimer);
            this.transitionTimer = 0;
          }
          this.dynamicColorState.transitionInProgress = false;
          Y3K?.debug?.log("DynamicCatppuccinStrategy", "Dynamic Catppuccin strategy destroyed");
        }
      };
      __name(_DynamicCatppuccinStrategy, "DynamicCatppuccinStrategy");
      DynamicCatppuccinStrategy = _DynamicCatppuccinStrategy;
    }
  });

  // src-js/core/css/CSSVariableCoordinator.ts
  var _CSSVariableCoordinator, CSSVariableCoordinator, globalCSSVariableCoordinator;
  var init_CSSVariableCoordinator = __esm({
    "src-js/core/css/CSSVariableCoordinator.ts"() {
      "use strict";
      init_UnifiedCSSConsciousnessController();
      _CSSVariableCoordinator = class _CSSVariableCoordinator {
        constructor(controller) {
          this.controller = controller ?? UnifiedCSSConsciousnessController.getInstance?.() ?? null;
        }
        async batchSetVariables(caller, variables, priority = "normal", source = "unknown") {
          if (this.controller) {
            this.controller.updateVariables(
              variables,
              priority,
              `${caller}:${source}`
            );
          } else {
            this.applyDirect(variables);
          }
        }
        async setVariable(caller, property, value, priority = "normal", source = "unknown") {
          if (this.controller) {
            this.controller.updateVariables(
              { [property]: value },
              priority,
              `${caller}:${source}`
            );
          } else {
            this.applyDirect({ [property]: value });
          }
        }
        // -------------------------------------------------------------------------
        // Fallback when the main controller hasn’t been initialised
        // -------------------------------------------------------------------------
        applyDirect(vars) {
          const root = document.documentElement;
          for (const [k, v] of Object.entries(vars)) {
            root.style.setProperty(k, v);
          }
        }
      };
      __name(_CSSVariableCoordinator, "CSSVariableCoordinator");
      CSSVariableCoordinator = _CSSVariableCoordinator;
      globalCSSVariableCoordinator = new CSSVariableCoordinator();
    }
  });

  // src-js/visual/strategies/LivingGradientStrategy.ts
  var _LivingGradientStrategy, LivingGradientStrategy;
  var init_LivingGradientStrategy = __esm({
    "src-js/visual/strategies/LivingGradientStrategy.ts"() {
      "use strict";
      init_globalConfig();
      init_CSSVariableCoordinator();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_OKLABColorProcessor();
      init_Year3000Utilities();
      _LivingGradientStrategy = class _LivingGradientStrategy {
        constructor(settingsManager, cssCoordinator) {
          this.utils = Year3000Utilities_exports;
          this.config = YEAR3000_CONFIG;
          this.livingBaseState = {
            currentBaseHex: "#1e1e2e",
            // Catppuccin base
            currentBaseRgb: "30,30,46",
            currentPrimaryHex: "#cba6f7",
            // Default mauve
            currentPrimaryRgb: "203,166,247",
            consciousnessIntensity: 0.5,
            breathingPhase: 0,
            musicEnergy: 0.5,
            lastUpdateTime: 0,
            webglIntegrationActive: false,
            oklabGradientStops: []
          };
          this.gradientConfig = {
            baseTransformationEnabled: true,
            webglIntegrationEnabled: true,
            breathingAnimationEnabled: true,
            consciousnessLayerOpacity: 0.08,
            // Subtle but visible
            organicFlowIntensity: 1.2,
            musicResponsiveness: 1,
            oklabInterpolationEnabled: true,
            oklabPreset: "STANDARD",
            // Use standard OKLAB enhancement for gradients
            gradientSmoothness: 0.8
            // High smoothness for natural transitions
          };
          // Animation control
          this.animationFrameId = 0;
          this.breathingStartTime = 0;
          this.isAnimating = false;
          this.settingsManager = settingsManager || new SettingsManager();
          this.cssCoordinator = cssCoordinator || globalCSSVariableCoordinator;
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.initializeBaseState();
          Y3K?.debug?.log(
            "LivingGradientStrategy",
            "Living gradient strategy initialized with OKLAB interpolation"
          );
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "living-gradient";
        }
        /**
         * Check if strategy can handle the given context
         */
        canProcess(context) {
          return this.gradientConfig.baseTransformationEnabled;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          return 8;
        }
        /**
         * Process colors using Living Gradient strategy with OKLAB interpolation
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const primaryColor = this.selectPrimaryColor(context.rawColors);
            const secondaryColor = this.selectSecondaryColor(context.rawColors);
            if (!primaryColor) {
              throw new Error("No suitable primary color found for living gradient");
            }
            let processedPrimary = primaryColor;
            let processedSecondary = secondaryColor;
            let oklabGradientStops = [];
            if (this.gradientConfig.oklabInterpolationEnabled && primaryColor) {
              const preset = OKLABColorProcessor.getPreset(
                this.gradientConfig.oklabPreset
              );
              const primaryResult = this.oklabProcessor.processColor(
                primaryColor,
                preset
              );
              processedPrimary = primaryResult.enhancedHex;
              if (secondaryColor) {
                const secondaryResult = this.oklabProcessor.processColor(
                  secondaryColor,
                  preset
                );
                processedSecondary = secondaryResult.enhancedHex;
                const stopCount = Math.ceil(5 * this.gradientConfig.gradientSmoothness) + 3;
                oklabGradientStops = this.oklabProcessor.generateOKLABGradient(
                  processedPrimary,
                  processedSecondary,
                  stopCount,
                  preset
                );
              } else {
                const baseColor = this.livingBaseState.currentBaseHex;
                oklabGradientStops = this.oklabProcessor.generateOKLABGradient(
                  processedPrimary,
                  baseColor,
                  5,
                  preset
                );
                processedSecondary = oklabGradientStops[oklabGradientStops.length - 1]?.enhancedHex || processedPrimary;
              }
              Y3K?.debug?.log(
                "LivingGradientStrategy",
                "OKLAB gradient processing applied:",
                {
                  originalPrimary: primaryColor,
                  processedPrimary,
                  originalSecondary: secondaryColor,
                  processedSecondary,
                  gradientStops: oklabGradientStops.length,
                  preset: preset.name
                }
              );
            }
            await this.updateLivingBaseState(
              processedPrimary,
              processedSecondary,
              context,
              oklabGradientStops
            );
            await this.applyLivingConsciousnessBase();
            this.updateBreathingAnimation();
            await this.updateWebGLIntegration();
            const processingTime = performance.now() - startTime;
            const result = {
              processedColors: {
                primary: processedPrimary,
                secondary: processedSecondary || processedPrimary,
                originalPrimary: primaryColor,
                // Keep original for reference
                ...secondaryColor && { originalSecondary: secondaryColor },
                livingBase: this.livingBaseState.currentBaseHex,
                ...context.rawColors
              },
              accentHex: processedPrimary,
              accentRgb: this.livingBaseState.currentPrimaryRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `living-gradient-${context.trackUri}`,
                harmonicIntensity: this.gradientConfig.organicFlowIntensity,
                oklabInterpolation: this.gradientConfig.oklabInterpolationEnabled,
                oklabPreset: this.gradientConfig.oklabPreset,
                gradientStopCount: oklabGradientStops.length,
                gradientSmoothness: this.gradientConfig.gradientSmoothness
              },
              context
            };
            Y3K?.debug?.log(
              "LivingGradientStrategy",
              "Living gradient processing completed",
              {
                originalPrimary: primaryColor,
                processedPrimary,
                originalSecondary: secondaryColor,
                processedSecondary,
                oklabProcessing: this.gradientConfig.oklabInterpolationEnabled,
                gradientStops: oklabGradientStops.length,
                processingTime,
                trackUri: context.trackUri
              }
            );
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3K?.debug?.error(
              "LivingGradientStrategy",
              "Living gradient processing failed:",
              error
            );
            return {
              processedColors: context.rawColors,
              accentHex: this.livingBaseState.currentPrimaryHex,
              accentRgb: this.livingBaseState.currentPrimaryRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error"
              },
              context
            };
          }
        }
        /**
         * Initialize base state from existing CSS variables
         */
        initializeBaseState() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentBase = computedStyle.getPropertyValue("--spice-base").trim() || "#1e1e2e";
          this.livingBaseState.currentBaseHex = currentBase;
          const baseRgb = this.utils.hexToRgb(currentBase);
          if (baseRgb) {
            this.livingBaseState.currentBaseRgb = `${baseRgb.r},${baseRgb.g},${baseRgb.b}`;
          }
          const currentPrimary = computedStyle.getPropertyValue("--sn-gradient-primary-rgb").trim();
          if (currentPrimary) {
            const rgbValues = currentPrimary.split(",").map((v) => parseInt(v.trim()));
            if (rgbValues.length === 3) {
              this.livingBaseState.currentPrimaryRgb = currentPrimary;
              this.livingBaseState.currentPrimaryHex = this.utils.rgbToHex(
                rgbValues[0],
                rgbValues[1],
                rgbValues[2]
              );
            }
          }
          this.livingBaseState.lastUpdateTime = Date.now();
          Y3K?.debug?.log("LivingGradientStrategy", "Base state initialized:", {
            base: this.livingBaseState.currentBaseHex,
            primary: this.livingBaseState.currentPrimaryHex
          });
        }
        /**
         * Select primary color for living gradient
         */
        selectPrimaryColor(colors) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "PROMINENT",
            "VIBRANT_NON_ALARMING",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorities) {
            const color2 = colors[key];
            if (color2 && this.utils.hexToRgb(color2)) {
              return color2;
            }
          }
          return null;
        }
        /**
         * Select secondary color for gradient complexity
         */
        selectSecondaryColor(colors) {
          const priorities = [
            "SECONDARY",
            "DARK_VIBRANT",
            "DESATURATED",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorities) {
            const color2 = colors[key];
            if (color2 && this.utils.hexToRgb(color2)) {
              return color2;
            }
          }
          return null;
        }
        /**
         * Update living base state with new colors and context including OKLAB data
         */
        async updateLivingBaseState(primaryColor, secondaryColor, context, oklabGradientStops = []) {
          const primaryRgb = this.utils.hexToRgb(primaryColor);
          if (!primaryRgb) return;
          this.livingBaseState.currentPrimaryHex = primaryColor;
          this.livingBaseState.currentPrimaryRgb = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          this.livingBaseState.oklabGradientStops = oklabGradientStops;
          if (context.musicData?.energy !== void 0) {
            this.livingBaseState.musicEnergy = context.musicData.energy;
            const baseIntensity = this.gradientConfig.consciousnessLayerOpacity;
            const musicMultiplier = 1 + context.musicData.energy * this.gradientConfig.musicResponsiveness;
            this.livingBaseState.consciousnessIntensity = Math.max(
              0.05,
              Math.min(1, baseIntensity * musicMultiplier)
            );
          }
          this.livingBaseState.lastUpdateTime = Date.now();
        }
        /**
         * Apply living consciousness base gradient using coordinated updates
         */
        async applyLivingConsciousnessBase() {
          const consciousnessGradient = this.createLivingGradient(
            this.livingBaseState.oklabGradientStops
          );
          const breathingMultiplier = 1 + Math.sin(this.livingBaseState.breathingPhase) * 0.2;
          const finalOpacity = this.livingBaseState.consciousnessIntensity * breathingMultiplier;
          const flowX = Math.sin(this.livingBaseState.breathingPhase * 0.7) * this.gradientConfig.organicFlowIntensity;
          const flowY = Math.cos(this.livingBaseState.breathingPhase * 0.5) * this.gradientConfig.organicFlowIntensity;
          const baseDuration = 4e3;
          const energyMultiplier = 0.5 + this.livingBaseState.musicEnergy * 1.5;
          const breathingDuration = baseDuration / energyMultiplier;
          const consciousnessBaseVariables = {
            "--living-base-gradient": consciousnessGradient,
            "--consciousness-base-gradient": consciousnessGradient,
            "--consciousness-layer-opacity": finalOpacity.toString(),
            "--consciousness-flow-x": `${flowX}%`,
            "--consciousness-flow-y": `${flowY}%`,
            "--consciousness-breathing-duration": `${breathingDuration}ms`
          };
          await this.cssCoordinator.batchSetVariables(
            "LivingGradientStrategy",
            consciousnessBaseVariables,
            "high",
            // High priority for consciousness animations
            "living-consciousness-base"
          );
          Y3K?.debug?.log(
            "LivingGradientStrategy",
            "Applied coordinated living consciousness base gradient"
          );
        }
        /**
         * Create living gradient based on current state with OKLAB enhancement
         */
        createLivingGradient(oklabGradientStops = []) {
          const primaryRgb = this.livingBaseState.currentPrimaryRgb;
          const baseRgb = this.livingBaseState.currentBaseRgb;
          if (this.gradientConfig.oklabInterpolationEnabled && oklabGradientStops.length > 0) {
            const gradientStops = oklabGradientStops.map((stop, index) => {
              const percentage = index / (oklabGradientStops.length - 1) * 100;
              const rgb = `${stop.enhancedRgb.r},${stop.enhancedRgb.g},${stop.enhancedRgb.b}`;
              const opacity = 0.6 * (1 - index / oklabGradientStops.length) + 0.1;
              return `rgba(${rgb}, calc(var(--consciousness-layer-opacity) * ${opacity})) ${percentage}%`;
            }).join(", ");
            return `
        radial-gradient(
          ellipse at calc(50% + var(--consciousness-flow-x)) calc(50% + var(--consciousness-flow-y)),
          ${gradientStops}
        ),
        linear-gradient(
          135deg,
          rgba(${oklabGradientStops[0]?.enhancedRgb.r || primaryRgb.split(",")[0]},${oklabGradientStops[0]?.enhancedRgb.g || primaryRgb.split(",")[1]},${oklabGradientStops[0]?.enhancedRgb.b || primaryRgb.split(",")[2]}, calc(var(--consciousness-layer-opacity) * 0.4)) 0%,
          var(--spice-base) 50%,
          rgba(${oklabGradientStops[oklabGradientStops.length - 1]?.enhancedRgb.r || primaryRgb.split(",")[0]},${oklabGradientStops[oklabGradientStops.length - 1]?.enhancedRgb.g || primaryRgb.split(",")[1]},${oklabGradientStops[oklabGradientStops.length - 1]?.enhancedRgb.b || primaryRgb.split(",")[2]}, calc(var(--consciousness-layer-opacity) * 0.2)) 100%
        ),
        var(--spice-base)
      `;
          }
          return `
      radial-gradient(
        ellipse at calc(50% + var(--consciousness-flow-x)) calc(50% + var(--consciousness-flow-y)),
        rgba(${primaryRgb}, calc(var(--consciousness-layer-opacity) * 0.6)) 0%,
        rgba(${primaryRgb}, calc(var(--consciousness-layer-opacity) * 0.3)) 30%,
        rgba(${baseRgb}, calc(var(--consciousness-layer-opacity) * 0.1)) 60%,
        var(--spice-base) 100%
      ),
      linear-gradient(
        135deg,
        rgba(${primaryRgb}, calc(var(--consciousness-layer-opacity) * 0.4)) 0%,
        var(--spice-base) 50%,
        rgba(${primaryRgb}, calc(var(--consciousness-layer-opacity) * 0.2)) 100%
      ),
      var(--spice-base)
    `;
        }
        /**
         * Update breathing animation
         */
        updateBreathingAnimation() {
          if (!this.gradientConfig.breathingAnimationEnabled) return;
          if (!this.isAnimating) {
            this.startBreathingAnimation();
          }
        }
        /**
         * Start breathing animation loop
         */
        startBreathingAnimation() {
          if (this.isAnimating) return;
          this.isAnimating = true;
          this.breathingStartTime = Date.now();
          const animate = /* @__PURE__ */ __name(() => {
            if (!this.isAnimating) return;
            const elapsed = Date.now() - this.breathingStartTime;
            const baseDuration = 4e3;
            const energyMultiplier = 0.5 + this.livingBaseState.musicEnergy * 1.5;
            const actualDuration = baseDuration / energyMultiplier;
            this.livingBaseState.breathingPhase = elapsed / actualDuration * Math.PI * 2;
            if (this.gradientConfig.breathingAnimationEnabled) {
              this.applyLivingConsciousnessBase().catch((error) => {
                Y3K?.debug?.error(
                  "LivingGradientStrategy",
                  "Error applying consciousness base in animation:",
                  error
                );
              });
            }
            this.animationFrameId = requestAnimationFrame(animate);
          }, "animate");
          this.animationFrameId = requestAnimationFrame(animate);
          Y3K?.debug?.log("LivingGradientStrategy", "Breathing animation started");
        }
        /**
         * Update WebGL integration variables using coordinated updates
         */
        async updateWebGLIntegration() {
          if (!this.gradientConfig.webglIntegrationEnabled) return;
          const webglIntegrationVariables = {
            "--sn-gradient-primary-rgb": this.livingBaseState.currentPrimaryRgb,
            "--sn-bg-gradient-primary-rgb": this.livingBaseState.currentPrimaryRgb,
            "--sn-webgl-living-gradient-sync": "1",
            "--sn-gradient-consciousness-level": this.livingBaseState.consciousnessIntensity.toString()
          };
          await this.cssCoordinator.batchSetVariables(
            "LivingGradientStrategy",
            webglIntegrationVariables,
            "high",
            // High priority for WebGL coordination
            "webgl-living-gradient-integration"
          );
          this.livingBaseState.webglIntegrationActive = true;
          Y3K?.debug?.log("LivingGradientStrategy", "WebGL integration updated");
        }
        /**
         * Get current living base state for debugging
         */
        getLivingBaseState() {
          return { ...this.livingBaseState };
        }
        /**
         * Update configuration
         */
        updateConfig(newConfig) {
          this.gradientConfig = { ...this.gradientConfig, ...newConfig };
          if ("oklabInterpolationEnabled" in newConfig || "oklabPreset" in newConfig) {
            this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          }
          Y3K?.debug?.log("LivingGradientStrategy", "Configuration updated:", {
            ...newConfig,
            oklabInterpolation: this.gradientConfig.oklabInterpolationEnabled,
            oklabPreset: this.gradientConfig.oklabPreset,
            gradientSmoothness: this.gradientConfig.gradientSmoothness
          });
        }
        /**
         * Health check for strategy status
         */
        async healthCheck() {
          const hasRecentUpdate = Date.now() - this.livingBaseState.lastUpdateTime < 3e4;
          return {
            healthy: this.gradientConfig.baseTransformationEnabled,
            canProcess: this.gradientConfig.baseTransformationEnabled,
            issues: !this.gradientConfig.baseTransformationEnabled ? ["Base transformation disabled in configuration"] : [],
            metrics: {
              baseTransformationEnabled: this.gradientConfig.baseTransformationEnabled,
              breathingAnimationEnabled: this.gradientConfig.breathingAnimationEnabled,
              webglIntegrationActive: this.livingBaseState.webglIntegrationActive,
              consciousnessIntensity: this.livingBaseState.consciousnessIntensity,
              musicEnergy: this.livingBaseState.musicEnergy,
              breathingPhase: this.livingBaseState.breathingPhase,
              hasRecentUpdate,
              isAnimating: this.isAnimating,
              oklabInterpolation: this.gradientConfig.oklabInterpolationEnabled,
              oklabPreset: this.gradientConfig.oklabPreset,
              gradientSmoothness: this.gradientConfig.gradientSmoothness,
              oklabGradientStops: this.livingBaseState.oklabGradientStops.length
            }
          };
        }
        /**
         * Stop animations and cleanup
         */
        destroy() {
          this.isAnimating = false;
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = 0;
          }
          Y3K?.debug?.log(
            "LivingGradientStrategy",
            "Living gradient strategy destroyed"
          );
        }
      };
      __name(_LivingGradientStrategy, "LivingGradientStrategy");
      LivingGradientStrategy = _LivingGradientStrategy;
    }
  });

  // src-js/utils/graphics/ShaderLoader.ts
  var ShaderLoader_exports = {};
  __export(ShaderLoader_exports, {
    DEFAULT_VERTEX_SHADER: () => DEFAULT_VERTEX_SHADER,
    ShaderLoader: () => ShaderLoader,
    createGradientTexture: () => createGradientTexture
  });
  function createGradientTexture(gl, stops, width = 256) {
    try {
      if (!gl) {
        Y3K?.debug?.error("ShaderLoader", "WebGL context is null or undefined");
        return null;
      }
      if (!stops || stops.length === 0) {
        Y3K?.debug?.error("ShaderLoader", "Invalid or empty color stops array");
        return null;
      }
      if (width <= 0 || width > 8192) {
        Y3K?.debug?.error("ShaderLoader", `Invalid texture width: ${width}`);
        return null;
      }
      const glError = gl.getError();
      if (glError !== gl.NO_ERROR) {
        Y3K?.debug?.warn("ShaderLoader", `WebGL context has pending error: ${glError}`);
      }
      if (gl.isContextLost()) {
        Y3K?.debug?.error("ShaderLoader", "WebGL context is lost");
        return null;
      }
      const canvas = document.createElement("canvas");
      if (!canvas) {
        Y3K?.debug?.error("ShaderLoader", "Failed to create canvas element");
        return null;
      }
      canvas.width = width;
      canvas.height = 1;
      const ctx = canvas.getContext("2d", { willReadFrequently: false });
      if (!ctx) {
        Y3K?.debug?.error("ShaderLoader", "Failed to get 2D canvas context");
        return null;
      }
      const validStops = stops.filter((stop) => {
        if (typeof stop.r !== "number" || typeof stop.g !== "number" || typeof stop.b !== "number" || typeof stop.a !== "number" || typeof stop.position !== "number") {
          Y3K?.debug?.warn("ShaderLoader", "Invalid color stop found, skipping");
          return false;
        }
        if (stop.position < 0 || stop.position > 1) {
          Y3K?.debug?.warn("ShaderLoader", `Invalid color stop position: ${stop.position}, clamping`);
          stop.position = Math.max(0, Math.min(1, stop.position));
        }
        return true;
      });
      if (validStops.length === 0) {
        Y3K?.debug?.error("ShaderLoader", "No valid color stops after validation");
        return null;
      }
      validStops.sort((a, b) => a.position - b.position);
      const gradient = ctx.createLinearGradient(0, 0, width, 0);
      if (!gradient) {
        Y3K?.debug?.error("ShaderLoader", "Failed to create linear gradient");
        return null;
      }
      try {
        validStops.forEach((stop, index) => {
          const r = Math.max(0, Math.min(255, Math.round(stop.r * 255)));
          const g2 = Math.max(0, Math.min(255, Math.round(stop.g * 255)));
          const b = Math.max(0, Math.min(255, Math.round(stop.b * 255)));
          const a = Math.max(0, Math.min(1, stop.a));
          const color2 = `rgba(${r}, ${g2}, ${b}, ${a})`;
          gradient.addColorStop(stop.position, color2);
        });
      } catch (error) {
        Y3K?.debug?.error("ShaderLoader", "Failed to add color stops to gradient:", error);
        return null;
      }
      try {
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, 1);
      } catch (error) {
        Y3K?.debug?.error("ShaderLoader", "Failed to fill canvas with gradient:", error);
        return null;
      }
      const texture = gl.createTexture();
      if (!texture) {
        Y3K?.debug?.error("ShaderLoader", "Failed to create WebGL texture - gl.createTexture() returned null");
        return null;
      }
      try {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const bindError = gl.getError();
        if (bindError !== gl.NO_ERROR) {
          Y3K?.debug?.error("ShaderLoader", `WebGL error after texture binding: ${bindError}`);
          gl.deleteTexture(texture);
          return null;
        }
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
        const uploadError = gl.getError();
        if (uploadError !== gl.NO_ERROR) {
          Y3K?.debug?.error("ShaderLoader", `WebGL error after texture upload: ${uploadError}`);
          gl.deleteTexture(texture);
          return null;
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        const paramError = gl.getError();
        if (paramError !== gl.NO_ERROR) {
          Y3K?.debug?.error("ShaderLoader", `WebGL error after setting texture parameters: ${paramError}`);
          gl.deleteTexture(texture);
          return null;
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
        Y3K?.debug?.log("ShaderLoader", `Gradient texture created successfully: ${width}x1, ${validStops.length} stops`);
        return texture;
      } catch (error) {
        Y3K?.debug?.error("ShaderLoader", "Exception during WebGL texture operations:", error);
        if (texture) {
          gl.deleteTexture(texture);
        }
        return null;
      }
    } catch (error) {
      Y3K?.debug?.error(
        "ShaderLoader",
        `Gradient texture creation failed: ${error instanceof Error ? error.message : "Unknown error"}`
      );
      return null;
    }
  }
  var _ShaderLoader, ShaderLoader, DEFAULT_VERTEX_SHADER;
  var init_ShaderLoader = __esm({
    "src-js/utils/graphics/ShaderLoader.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _ShaderLoader = class _ShaderLoader {
        /**
         * Load and compile a fragment shader from source
         * @param gl WebGL2 rendering context
         * @param source GLSL fragment shader source code
         * @param cacheKey Optional cache key (defaults to hash of source)
         * @returns Compiled WebGL shader or null on failure
         */
        static loadFragment(gl, source, cacheKey) {
          const key = cacheKey || this.hashSource(source);
          const contextCache = this.getContextCache(gl);
          if (contextCache[key]) {
            return contextCache[key];
          }
          try {
            const shader = this.compileShader(gl, gl.FRAGMENT_SHADER, source);
            if (shader) {
              contextCache[key] = shader;
              Y3K?.debug?.log(
                "ShaderLoader",
                `Fragment shader compiled: ${key.substring(0, 8)}...`
              );
            }
            return shader;
          } catch (error) {
            Y3K?.debug?.error(
              "ShaderLoader",
              `Fragment shader compilation failed: ${error}`
            );
            return null;
          }
        }
        /**
         * Load and compile a vertex shader from source
         * @param gl WebGL2 rendering context
         * @param source GLSL vertex shader source code
         * @param cacheKey Optional cache key
         * @returns Compiled WebGL shader or null on failure
         */
        static loadVertex(gl, source, cacheKey) {
          const key = cacheKey || this.hashSource(source);
          const contextCache = this.getContextCache(gl);
          if (contextCache[key]) {
            return contextCache[key];
          }
          try {
            const shader = this.compileShader(gl, gl.VERTEX_SHADER, source);
            if (shader) {
              contextCache[key] = shader;
              Y3K?.debug?.log(
                "ShaderLoader",
                `Vertex shader compiled: ${key.substring(0, 8)}...`
              );
            }
            return shader;
          } catch (error) {
            Y3K?.debug?.error(
              "ShaderLoader",
              `Vertex shader compilation failed: ${error}`
            );
            return null;
          }
        }
        /**
         * Create a shader program from vertex and fragment shaders
         * @param gl WebGL2 rendering context
         * @param vertexShader Compiled vertex shader
         * @param fragmentShader Compiled fragment shader
         * @returns WebGL program or null on failure
         */
        static createProgram(gl, vertexShader, fragmentShader) {
          try {
            const program = gl.createProgram();
            if (!program) return null;
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
              const info = gl.getProgramInfoLog(program);
              gl.deleteProgram(program);
              throw new Error(`Program linking failed: ${info}`);
            }
            return program;
          } catch (error) {
            Y3K?.debug?.error("ShaderLoader", `Program creation failed: ${error}`);
            return null;
          }
        }
        /**
         * Clear shader cache for a specific WebGL context
         * @param gl WebGL2 rendering context
         */
        static clearCache(gl) {
          const contextCache = this.cache.get(gl);
          if (contextCache) {
            Object.values(contextCache).forEach((shader) => {
              gl.deleteShader(shader);
            });
            this.cache.delete(gl);
          }
        }
        /**
         * Clear all shader caches (use on theme hot-reload)
         */
        static clearAllCaches() {
          this.cache.clear();
        }
        static compileShader(gl, type, source) {
          const shader = gl.createShader(type);
          if (!shader) return null;
          gl.shaderSource(shader, source);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            const info = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error(`Shader compilation failed: ${info}`);
          }
          return shader;
        }
        /**
         * Clear shader cache for a specific WebGL context
         * This should be called when the WebGL context is lost to prevent
         * reusing invalid shader objects after context restoration
         */
        static clearContextCache(gl) {
          if (this.cache.has(gl)) {
            const contextCache = this.cache.get(gl);
            Object.values(contextCache).forEach((shader) => {
              if (shader && gl && !gl.isContextLost()) {
                try {
                  gl.deleteShader(shader);
                } catch (e) {
                }
              }
            });
            this.cache.set(gl, {});
            Y3K?.debug?.log("ShaderLoader", "Context cache cleared due to WebGL context loss/restore");
          }
        }
        static getContextCache(gl) {
          if (!this.cache.has(gl)) {
            this.cache.set(gl, {});
          }
          return this.cache.get(gl);
        }
        static hashSource(source) {
          let hash = 0;
          for (let i = 0; i < source.length; i++) {
            const char = source.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
          }
          return hash.toString(16);
        }
      };
      __name(_ShaderLoader, "ShaderLoader");
      _ShaderLoader.cache = /* @__PURE__ */ new Map();
      ShaderLoader = _ShaderLoader;
      DEFAULT_VERTEX_SHADER = `#version 300 es
precision mediump float;

in vec2 a_position;
out vec2 v_uv;

void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;
      __name(createGradientTexture, "createGradientTexture");
    }
  });

  // src-js/visual/strategies/WebGLGradientStrategy.ts
  var FLOW_GRADIENT_SHADER, _WebGLGradientStrategy, WebGLGradientStrategy;
  var init_WebGLGradientStrategy = __esm({
    "src-js/visual/strategies/WebGLGradientStrategy.ts"() {
      "use strict";
      init_globalConfig();
      init_CSSVariableCoordinator();
      init_UnifiedCSSConsciousnessController();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_OKLABColorProcessor();
      init_Year3000Utilities();
      init_ShaderLoader();
      FLOW_GRADIENT_SHADER = `#version 300 es
precision mediump float;

uniform float u_time;
uniform sampler2D u_gradientTex;
uniform vec2 u_resolution;
uniform float u_flowStrength;
uniform float u_noiseScale;

// Wave stack uniforms
uniform float u_waveY[2];
uniform float u_waveHeight[2];
uniform float u_waveOffset[2];
uniform float u_blurExp;
uniform float u_blurMax;

out vec4 fragColor;

// Simplex noise implementation
vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

  i = mod289(i);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// Octave noise for richer detail
float octaveNoise(vec2 uv, float octaves, float persistence, float scale) {
  float value = 0.0;
  float amplitude = 1.0;
  float frequency = scale;
  float maxValue = 0.0;

  for(float i = 0.0; i < octaves; i++) {
    value += snoise(uv * frequency) * amplitude;
    maxValue += amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return value / maxValue;
}

// Wave alpha calculation with smooth transitions
float wave_alpha(vec2 uv, int waveIndex) {
  float y = uv.y;
  float waveCenter = u_waveY[waveIndex];
  float waveHeight = u_waveHeight[waveIndex];

  float distance = abs(y - waveCenter);
  float alpha = 1.0 - smoothstep(0.0, waveHeight * 0.5, distance);

  return alpha;
}

// Dynamic blur calculation using power function
float calc_blur(vec2 uv) {
  vec2 center = vec2(0.5, 0.5);
  float distance = length(uv - center);

  float blur = pow(distance, u_blurExp);
  blur = clamp(blur, 0.0, u_blurMax);

  return blur;
}

// Background noise generator with time offset
float background_noise(vec2 uv, float timeOffset) {
  vec2 flowUV = uv;
  float adjustedTime = u_time + timeOffset;

  flowUV.x += adjustedTime * 0.02 * u_flowStrength;
  flowUV.y += sin(adjustedTime * 0.03 + uv.x * 3.14159) * 0.01 * u_flowStrength;

  float noise1 = octaveNoise(flowUV * u_noiseScale, 4.0, 0.5, 1.0);
  float noise2 = octaveNoise(flowUV * u_noiseScale * 2.0 + vec2(100.0), 3.0, 0.4, 1.0);

  return (noise1 + noise2 * 0.3) * 0.5 + 0.5;
}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;

  // Generate three distinct background noise fields with time offsets
  float noise1 = background_noise(uv, u_waveOffset[0]);
  float noise2 = background_noise(uv, u_waveOffset[1]);
  float noise3 = background_noise(uv, 0.0); // Base noise without offset

  // Calculate wave alphas for blending
  float alpha1 = wave_alpha(uv, 0);
  float alpha2 = wave_alpha(uv, 1);
  float alpha3 = 1.0 - alpha1 - alpha2; // Remaining area
  alpha3 = max(alpha3, 0.0); // Ensure non-negative

  // Normalize alphas to ensure they sum to 1.0
  float totalAlpha = alpha1 + alpha2 + alpha3;
  if (totalAlpha > 0.0) {
    alpha1 /= totalAlpha;
    alpha2 /= totalAlpha;
    alpha3 /= totalAlpha;
  }

  // Blend the three noise fields based on wave alphas
  float t = noise1 * alpha1 + noise2 * alpha2 + noise3 * alpha3;
  t = clamp(t, 0.0, 1.0);

  // Sample gradient texture
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));

  // Apply dynamic blur based on position
  float blurAmount = calc_blur(uv);

  // Apply subtle vignette with blur modulation
  vec2 center = uv - 0.5;
  float vignette = 1.0 - dot(center, center) * (0.3 + blurAmount * 0.2);
  color.rgb *= vignette;

  // Apply blur effect to alpha channel for depth
  color.a *= (1.0 - blurAmount * 0.3);

  fragColor = color;
}`;
      _WebGLGradientStrategy = class _WebGLGradientStrategy {
        constructor(settingsManager, cssCoordinator) {
          this.utils = Year3000Utilities_exports;
          this.config = YEAR3000_CONFIG;
          this.cssController = null;
          this.webglState = {
            canvas: null,
            wrapper: null,
            gl: null,
            shaderProgram: null,
            gradientTexture: null,
            vertexBuffer: null,
            vao: null,
            isWebGLAvailable: false,
            webglReady: false,
            animationId: null,
            startTime: 0,
            lastFrameTime: 0,
            lastUpdateTime: 0,
            // Initialize LERP smoothing properties (current = target initially)
            currentFlowStrength: 0.3,
            targetFlowStrength: 0.3,
            currentNoiseScale: 1,
            targetNoiseScale: 1,
            currentBlurExp: 1.2,
            targetBlurExp: 1.2,
            currentBlurMax: 0.5,
            targetBlurMax: 0.5,
            currentWaveY: [0.3, 0.7],
            targetWaveY: [0.3, 0.7],
            currentWaveHeight: [0.4, 0.3],
            targetWaveHeight: [0.4, 0.3],
            currentWaveOffset: [0.1, 0.6],
            targetWaveOffset: [0.1, 0.6]
          };
          this.uniforms = {
            u_time: null,
            u_gradientTex: null,
            u_resolution: null,
            u_flowStrength: null,
            u_noiseScale: null,
            u_waveY: null,
            u_waveHeight: null,
            u_waveOffset: null,
            u_blurExp: null,
            u_blurMax: null
          };
          this.flowSettings = {
            enabled: true,
            intensity: "balanced",
            flowStrength: 0.7,
            noiseScale: 1.2,
            waveY: [0.25, 0.75],
            waveHeight: [0.4, 0.3],
            waveOffset: [2.5, -1.8],
            blurExp: 1.2,
            blurMax: 0.6,
            frameThrottleInterval: 1e3 / 45,
            // 45 FPS target
            oklabProcessingEnabled: true,
            oklabPreset: "VIBRANT",
            // Use vibrant preset for WebGL gradients
            gradientTextureSize: 512
            // High precision for OKLAB gradients
          };
          this.prefersReducedMotion = false;
          /**
           * WebGL animation loop
           */
          this.animateWebGL = /* @__PURE__ */ __name(() => {
            if (!this.webglState.webglReady || !this.webglState.gl || !this.webglState.canvas)
              return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.webglState.lastFrameTime;
            if (deltaTime < this.flowSettings.frameThrottleInterval) {
              this.webglState.animationId = requestAnimationFrame(this.animateWebGL);
              return;
            }
            this.webglState.lastFrameTime = currentTime;
            this.renderWebGLFrame(currentTime);
            this.webglState.animationId = requestAnimationFrame(this.animateWebGL);
          }, "animateWebGL");
          // LERP smoothing half-life values (in seconds) for WebGL uniform transitions
          this.lerpHalfLifeValues = {
            flowStrength: 0.25,
            // Fast flow response
            noiseScale: 0.3,
            // Moderate noise transitions
            blur: 0.2,
            // Quick blur transitions
            wave: 0.35
            // Gentle wave movements
          };
          /**
           * Resize WebGL canvas
           */
          this.resizeWebGLCanvas = /* @__PURE__ */ __name(() => {
            if (!this.webglState.canvas) return;
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            this.webglState.canvas.width = displayWidth * dpr;
            this.webglState.canvas.height = displayHeight * dpr;
            this.webglState.canvas.style.width = displayWidth + "px";
            this.webglState.canvas.style.height = displayHeight + "px";
          }, "resizeWebGLCanvas");
          this.settingsManager = settingsManager || new SettingsManager();
          this.deviceDetector = new DeviceCapabilityDetector();
          this.cssCoordinator = cssCoordinator || globalCSSVariableCoordinator;
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.cssController = UnifiedCSSConsciousnessController.getInstance();
          this.prefersReducedMotion = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;
          this.webglState.isWebGLAvailable = this.checkWebGL2Support();
          this.loadFlowSettings();
          Y3K?.debug?.log(
            "WebGLGradientStrategy",
            "WebGL gradient strategy initialized with OKLAB processing",
            {
              webglAvailable: this.webglState.isWebGLAvailable,
              deviceCapability: this.deviceDetector.recommendPerformanceQuality(),
              oklabProcessing: this.flowSettings.oklabProcessingEnabled
            }
          );
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "webgl-gradient";
        }
        /**
         * Check if strategy can handle the given context
         */
        canProcess(context) {
          return this.webglState.isWebGLAvailable && this.flowSettings.enabled && this.deviceDetector.recommendPerformanceQuality() !== "low";
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          const baseTime = 12;
          const shaderComplexity = this.flowSettings.intensity === "intense" ? 1.3 : 1;
          return Math.round(baseTime * shaderComplexity);
        }
        /**
         * Process colors using WebGL Gradient strategy with OKLAB enhancement
         */
        async processColors(context) {
          const startTime = performance.now();
          let oklabResults = {};
          try {
            if (!this.webglState.webglReady) {
              await this.initializeWebGLGradient();
            }
            let processedColors = context.rawColors;
            if (this.flowSettings.oklabProcessingEnabled) {
              const preset = OKLABColorProcessor.getPreset(
                this.flowSettings.oklabPreset
              );
              oklabResults = this.oklabProcessor.processColorPalette(
                context.rawColors,
                preset
              );
              processedColors = Object.fromEntries(
                Object.entries(oklabResults).map(([key, result2]) => [
                  key,
                  result2.enhancedHex
                ])
              );
              Y3K?.debug?.log(
                "WebGLGradientStrategy",
                "OKLAB color enhancement applied:",
                {
                  originalColors: Object.keys(context.rawColors).length,
                  processedColors: Object.keys(processedColors).length,
                  preset: preset.name
                }
              );
            }
            const gradientStops = this.createGradientStops(
              processedColors,
              oklabResults
            );
            await this.updateGradientTexture(gradientStops);
            await this.enableHybridCoordination();
            if (!this.webglState.animationId) {
              this.startWebGLAnimation();
            }
            if (context.musicData?.energy !== void 0) {
              await this.updateFlowWithMusicEnergy(context.musicData.energy);
            }
            this.webglState.lastUpdateTime = Date.now();
            const processingTime = performance.now() - startTime;
            const primaryColor = this.selectPrimaryColor(processedColors) || "#cba6f7";
            const result = {
              processedColors: {
                webgl: "active",
                gradientStops: gradientStops.length.toString(),
                ...processedColors,
                ...Object.keys(context.rawColors).length > 0 && {
                  originalColors: JSON.stringify(context.rawColors)
                }
              },
              accentHex: primaryColor,
              accentRgb: this.convertToRgbString(primaryColor),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `webgl-gradient-${context.trackUri}`,
                harmonicIntensity: this.flowSettings.flowStrength,
                webglReady: this.webglState.webglReady,
                oklabProcessing: this.flowSettings.oklabProcessingEnabled,
                oklabPreset: this.flowSettings.oklabPreset,
                gradientTextureSize: this.flowSettings.gradientTextureSize,
                oklabResultsCount: Object.keys(oklabResults).length
              },
              context
            };
            Y3K?.debug?.log(
              "WebGLGradientStrategy",
              "WebGL gradient processing completed",
              {
                gradientStops: gradientStops.length,
                processingTime,
                trackUri: context.trackUri
              }
            );
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3K?.debug?.error(
              "WebGLGradientStrategy",
              "WebGL gradient processing failed:",
              error
            );
            await this.fallbackToCSSGradient();
            return {
              processedColors: context.rawColors,
              accentHex: this.selectPrimaryColor(context.rawColors) || "#cba6f7",
              accentRgb: this.convertToRgbString(
                this.selectPrimaryColor(context.rawColors) || "#cba6f7"
              ),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error",
                fallbackMode: "css"
              },
              context
            };
          }
        }
        /**
         * Check WebGL2 support
         */
        checkWebGL2Support() {
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2");
          return gl !== null;
        }
        /**
         * Load flow settings from settings manager
         */
        loadFlowSettings() {
          if (!this.settingsManager) return;
          try {
            const intensitySetting = this.settingsManager.get(
              "sn-flow-gradient"
            );
            if (intensitySetting === "disabled") {
              this.flowSettings.enabled = false;
              return;
            }
            this.flowSettings.intensity = intensitySetting || "balanced";
            switch (this.flowSettings.intensity) {
              case "minimal":
                this.flowSettings.flowStrength = 0.4;
                this.flowSettings.noiseScale = 0.8;
                this.flowSettings.waveHeight = [0.3, 0.2];
                this.flowSettings.waveOffset = [1.5, -1];
                this.flowSettings.blurExp = 1;
                this.flowSettings.blurMax = 0.4;
                break;
              case "balanced":
                this.flowSettings.flowStrength = 0.7;
                this.flowSettings.noiseScale = 1.2;
                this.flowSettings.waveHeight = [0.4, 0.3];
                this.flowSettings.waveOffset = [2.5, -1.8];
                this.flowSettings.blurExp = 1.2;
                this.flowSettings.blurMax = 0.6;
                break;
              case "intense":
                this.flowSettings.flowStrength = 1;
                this.flowSettings.noiseScale = 1.6;
                this.flowSettings.waveHeight = [0.5, 0.4];
                this.flowSettings.waveOffset = [3.5, -2.5];
                this.flowSettings.blurExp = 1.4;
                this.flowSettings.blurMax = 0.8;
                break;
            }
          } catch (error) {
            Y3K?.debug?.warn(
              "WebGLGradientStrategy",
              "Failed to load settings, using defaults:",
              error
            );
          }
        }
        /**
         * Initialize WebGL gradient system
         */
        async initializeWebGLGradient() {
          if (!this.webglState.isWebGLAvailable) {
            throw new Error("WebGL2 not available");
          }
          await this.createWebGLCanvas();
          await this.initializeWebGLContext();
          await this.compileWebGLShaders();
          this.createWebGLGeometry();
          this.setupWebGLUniforms();
          this.resizeWebGLCanvas();
          this.attachWebGLToDom();
          window.addEventListener("resize", this.resizeWebGLCanvas.bind(this));
          this.webglState.webglReady = true;
          Y3K?.debug?.log(
            "WebGLGradientStrategy",
            "WebGL gradient system initialized successfully"
          );
        }
        /**
         * Create WebGL canvas and wrapper
         */
        async createWebGLCanvas() {
          this.webglState.wrapper = document.createElement("div");
          this.webglState.wrapper.className = "sn-webgl-gradient-wrapper";
          this.webglState.wrapper.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -11;
      pointer-events: none;
      overflow: hidden;
    `;
          this.webglState.canvas = document.createElement("canvas");
          this.webglState.canvas.id = "sn-webgl-gradient";
          this.webglState.canvas.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    `;
          this.webglState.wrapper.appendChild(this.webglState.canvas);
        }
        /**
         * Initialize WebGL context
         */
        async initializeWebGLContext() {
          if (!this.webglState.canvas) {
            throw new Error("Canvas not created");
          }
          this.webglState.gl = this.webglState.canvas.getContext("webgl2", {
            alpha: true,
            antialias: false,
            depth: false,
            stencil: false,
            powerPreference: "default"
          });
          if (!this.webglState.gl) {
            throw new Error("Failed to get WebGL2 context");
          }
        }
        /**
         * Compile WebGL shaders
         */
        async compileWebGLShaders() {
          if (!this.webglState.gl) {
            throw new Error("WebGL context not available");
          }
          const vertexShader = ShaderLoader.loadVertex(
            this.webglState.gl,
            DEFAULT_VERTEX_SHADER
          );
          const fragmentShader = ShaderLoader.loadFragment(
            this.webglState.gl,
            FLOW_GRADIENT_SHADER
          );
          if (!vertexShader || !fragmentShader) {
            throw new Error("Failed to compile shaders");
          }
          this.webglState.shaderProgram = ShaderLoader.createProgram(
            this.webglState.gl,
            vertexShader,
            fragmentShader
          );
          if (!this.webglState.shaderProgram) {
            throw new Error("Failed to create shader program");
          }
        }
        /**
         * Create WebGL geometry
         */
        createWebGLGeometry() {
          if (!this.webglState.gl || !this.webglState.shaderProgram) return;
          const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
          this.webglState.vertexBuffer = this.webglState.gl.createBuffer();
          this.webglState.gl.bindBuffer(
            this.webglState.gl.ARRAY_BUFFER,
            this.webglState.vertexBuffer
          );
          this.webglState.gl.bufferData(
            this.webglState.gl.ARRAY_BUFFER,
            vertices,
            this.webglState.gl.STATIC_DRAW
          );
          this.webglState.vao = this.webglState.gl.createVertexArray();
          this.webglState.gl.bindVertexArray(this.webglState.vao);
          const positionLocation = this.webglState.gl.getAttribLocation(
            this.webglState.shaderProgram,
            "a_position"
          );
          this.webglState.gl.enableVertexAttribArray(positionLocation);
          this.webglState.gl.vertexAttribPointer(
            positionLocation,
            2,
            this.webglState.gl.FLOAT,
            false,
            0,
            0
          );
          this.webglState.gl.bindVertexArray(null);
        }
        /**
         * Setup WebGL uniforms
         */
        setupWebGLUniforms() {
          if (!this.webglState.gl || !this.webglState.shaderProgram) return;
          this.uniforms.u_time = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_time"
          );
          this.uniforms.u_gradientTex = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_gradientTex"
          );
          this.uniforms.u_resolution = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_resolution"
          );
          this.uniforms.u_flowStrength = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_flowStrength"
          );
          this.uniforms.u_noiseScale = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_noiseScale"
          );
          this.uniforms.u_waveY = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_waveY"
          );
          this.uniforms.u_waveHeight = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_waveHeight"
          );
          this.uniforms.u_waveOffset = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_waveOffset"
          );
          this.uniforms.u_blurExp = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_blurExp"
          );
          this.uniforms.u_blurMax = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_blurMax"
          );
        }
        /**
         * Create gradient stops from extracted colors with OKLAB enhancement
         */
        createGradientStops(colors, oklabResults = {}) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "VIBRANT_NON_ALARMING",
            "LIGHT_VIBRANT",
            "DARK_VIBRANT",
            "PROMINENT"
          ];
          const stops = [];
          const usedColors = /* @__PURE__ */ new Set();
          let position = 0;
          for (const key of priorities) {
            const color2 = colors[key];
            if (color2 && !usedColors.has(color2)) {
              const oklabResult = oklabResults[key];
              const finalColor = oklabResult ? oklabResult.enhancedHex : color2;
              const rgb = this.utils.hexToRgb(finalColor);
              if (rgb) {
                stops.push({
                  r: rgb.r / 255,
                  g: rgb.g / 255,
                  b: rgb.b / 255,
                  a: 1,
                  position: position / (Math.min(priorities.length, 4) - 1),
                  // Include OKLAB metadata for debugging
                  ...oklabResult && {
                    oklabOriginal: oklabResult.originalHex,
                    oklabEnhanced: oklabResult.enhancedHex
                  }
                });
                usedColors.add(color2);
                position++;
                if (stops.length >= 4) break;
              }
            }
          }
          if (stops.length === 0) {
            return this.getDefaultGradientStops();
          }
          return stops;
        }
        /**
         * Get default gradient stops
         */
        getDefaultGradientStops() {
          return [
            { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 0 },
            // Base
            { r: 0.549, g: 0.408, b: 0.878, a: 1, position: 0.3 },
            // Mauve
            { r: 0.788, g: 0.557, b: 0.902, a: 1, position: 0.6 },
            // Pink
            { r: 0.957, g: 0.761, b: 0.494, a: 1, position: 1 }
            // Peach
          ];
        }
        /**
         * Update gradient texture with new color stops
         */
        async updateGradientTexture(colorStops) {
          if (!this.webglState.gl) return;
          if (this.webglState.gradientTexture) {
            this.webglState.gl.deleteTexture(this.webglState.gradientTexture);
          }
          this.webglState.gradientTexture = createGradientTexture(
            this.webglState.gl,
            colorStops
          );
          if (!this.webglState.gradientTexture) {
            throw new Error("Failed to create gradient texture");
          }
          await this.updateCSSFallbackVariables(colorStops);
        }
        /**
         * Update CSS fallback variables for hybrid coordination using coordinated updates
         */
        async updateCSSFallbackVariables(colorStops) {
          const maxStops = Math.min(8, colorStops.length);
          const gradientStopVariables = {
            "--sn-grad-stop-count": String(maxStops)
          };
          for (let i = 0; i < maxStops; i++) {
            const c = colorStops[i];
            if (c) {
              gradientStopVariables[`--sn-grad-stop-${i}-rgb`] = `${Math.round(
                c.r * 255
              )},${Math.round(c.g * 255)},${Math.round(c.b * 255)}`;
            }
          }
          await this.cssCoordinator.batchSetVariables(
            "WebGLGradientStrategy",
            gradientStopVariables,
            "normal",
            // Normal priority for gradient configuration
            "gradient-stops-configuration"
          );
        }
        /**
         * Enable hybrid coordination between WebGL and CSS using coordinated updates
         */
        async enableHybridCoordination() {
          const hybridCoordinationVariables = {
            "--sn-webgl-ready": "1",
            "--sn-webgl-enabled": "1",
            "--sn-current-backend": "hybrid",
            "--sn-gradient-crossfade-opacity": "0.5"
            // 50% blend
          };
          await this.cssCoordinator.batchSetVariables(
            "WebGLGradientStrategy",
            hybridCoordinationVariables,
            "high",
            // High priority for WebGL coordination
            "hybrid-coordination-enable"
          );
        }
        /**
         * Start WebGL animation loop
         */
        startWebGLAnimation() {
          this.webglState.startTime = performance.now();
          this.webglState.lastFrameTime = this.webglState.startTime;
          this.animateWebGL();
        }
        /**
         * Update WebGL uniform values with LERP smoothing for framerate-independent transitions
         */
        updateUniformsWithLERP(deltaTimeSeconds) {
          this.webglState.targetFlowStrength = this.flowSettings.flowStrength;
          this.webglState.targetNoiseScale = this.flowSettings.noiseScale;
          this.webglState.targetBlurExp = this.flowSettings.blurExp;
          this.webglState.targetBlurMax = this.flowSettings.blurMax;
          this.webglState.targetWaveY = [this.flowSettings.waveY[0], this.flowSettings.waveY[1]];
          this.webglState.targetWaveHeight = [this.flowSettings.waveHeight[0], this.flowSettings.waveHeight[1]];
          this.webglState.targetWaveOffset = [this.flowSettings.waveOffset[0], this.flowSettings.waveOffset[1]];
          this.webglState.currentFlowStrength = lerpSmooth(
            this.webglState.currentFlowStrength,
            this.webglState.targetFlowStrength,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.flowStrength
          );
          this.webglState.currentNoiseScale = lerpSmooth(
            this.webglState.currentNoiseScale,
            this.webglState.targetNoiseScale,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.noiseScale
          );
          this.webglState.currentBlurExp = lerpSmooth(
            this.webglState.currentBlurExp,
            this.webglState.targetBlurExp,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.blur
          );
          this.webglState.currentBlurMax = lerpSmooth(
            this.webglState.currentBlurMax,
            this.webglState.targetBlurMax,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.blur
          );
          const waveIndex0 = 0;
          const waveIndex1 = 1;
          this.webglState.currentWaveY[waveIndex0] = lerpSmooth(
            this.webglState.currentWaveY[waveIndex0],
            this.webglState.targetWaveY[waveIndex0],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveY[waveIndex1] = lerpSmooth(
            this.webglState.currentWaveY[waveIndex1],
            this.webglState.targetWaveY[waveIndex1],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveHeight[waveIndex0] = lerpSmooth(
            this.webglState.currentWaveHeight[waveIndex0],
            this.webglState.targetWaveHeight[waveIndex0],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveHeight[waveIndex1] = lerpSmooth(
            this.webglState.currentWaveHeight[waveIndex1],
            this.webglState.targetWaveHeight[waveIndex1],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveOffset[waveIndex0] = lerpSmooth(
            this.webglState.currentWaveOffset[waveIndex0],
            this.webglState.targetWaveOffset[waveIndex0],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveOffset[waveIndex1] = lerpSmooth(
            this.webglState.currentWaveOffset[waveIndex1],
            this.webglState.targetWaveOffset[waveIndex1],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
        }
        /**
         * Render WebGL frame
         */
        renderWebGLFrame(currentTime) {
          if (!this.webglState.gl || !this.webglState.shaderProgram || !this.webglState.vao || !this.webglState.gradientTexture) {
            return;
          }
          const deltaTimeSeconds = (currentTime - this.webglState.lastFrameTime) / 1e3;
          this.updateUniformsWithLERP(deltaTimeSeconds);
          this.webglState.gl.viewport(
            0,
            0,
            this.webglState.canvas.width,
            this.webglState.canvas.height
          );
          this.webglState.gl.clearColor(0, 0, 0, 0);
          this.webglState.gl.clear(this.webglState.gl.COLOR_BUFFER_BIT);
          this.webglState.gl.useProgram(this.webglState.shaderProgram);
          this.webglState.gl.bindVertexArray(this.webglState.vao);
          const time = this.prefersReducedMotion ? 0 : (currentTime - this.webglState.startTime) / 1e3;
          if (this.uniforms.u_time) {
            this.webglState.gl.uniform1f(this.uniforms.u_time, time);
          }
          if (this.uniforms.u_resolution) {
            this.webglState.gl.uniform2f(
              this.uniforms.u_resolution,
              this.webglState.canvas.width,
              this.webglState.canvas.height
            );
          }
          if (this.uniforms.u_flowStrength) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_flowStrength,
              this.webglState.currentFlowStrength
              // Use smoothed value
            );
          }
          if (this.uniforms.u_noiseScale) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_noiseScale,
              this.webglState.currentNoiseScale
              // Use smoothed value
            );
          }
          if (this.uniforms.u_waveY) {
            this.webglState.gl.uniform1fv(
              this.uniforms.u_waveY,
              this.webglState.currentWaveY
              // Use smoothed values
            );
          }
          if (this.uniforms.u_waveHeight) {
            this.webglState.gl.uniform1fv(
              this.uniforms.u_waveHeight,
              this.webglState.currentWaveHeight
              // Use smoothed values
            );
          }
          if (this.uniforms.u_waveOffset) {
            this.webglState.gl.uniform1fv(
              this.uniforms.u_waveOffset,
              this.webglState.currentWaveOffset
              // Use smoothed values
            );
          }
          if (this.uniforms.u_blurExp) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_blurExp,
              this.webglState.currentBlurExp
              // Use smoothed value
            );
          }
          if (this.uniforms.u_blurMax) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_blurMax,
              this.webglState.currentBlurMax
              // Use smoothed value
            );
          }
          this.webglState.gl.activeTexture(this.webglState.gl.TEXTURE0);
          this.webglState.gl.bindTexture(
            this.webglState.gl.TEXTURE_2D,
            this.webglState.gradientTexture
          );
          if (this.uniforms.u_gradientTex) {
            this.webglState.gl.uniform1i(this.uniforms.u_gradientTex, 0);
          }
          this.webglState.gl.drawArrays(this.webglState.gl.TRIANGLES, 0, 3);
          this.webglState.gl.bindVertexArray(null);
        }
        /**
         * Update flow with music energy using coordinated updates
         */
        async updateFlowWithMusicEnergy(energy) {
          const baseStrength = this.flowSettings.flowStrength;
          const energyMultiplier = 1 + energy * 0.5;
          const adjustedStrength = baseStrength * energyMultiplier;
          await this.cssCoordinator.setVariable(
            "WebGLGradientStrategy",
            "--sn-flow-strength",
            adjustedStrength.toString(),
            "high",
            // High priority for real-time music responsiveness
            "music-energy-flow-strength"
          );
        }
        /**
         * Attach WebGL canvas to DOM
         */
        attachWebGLToDom() {
          if (!this.webglState.wrapper) return;
          const containers = [
            ".Root__main-view",
            ".main-view-container",
            ".main-gridContainer-gridContainer",
            ".Root__top-container",
            "body"
          ];
          let targetContainer = null;
          for (const selector of containers) {
            targetContainer = document.querySelector(selector);
            if (targetContainer) break;
          }
          if (!targetContainer) {
            targetContainer = document.body;
          }
          targetContainer.appendChild(this.webglState.wrapper);
        }
        /**
         * Fallback to CSS gradient
         */
        async fallbackToCSSGradient() {
          const cssGradientFallbackVariables = {
            "--sn-webgl-ready": "0",
            "--sn-webgl-enabled": "0",
            "--sn-current-backend": "css",
            "--sn-gradient-crossfade-opacity": "0"
          };
          await this.cssCoordinator.batchSetVariables(
            "WebGLGradientStrategy",
            cssGradientFallbackVariables,
            "critical",
            // Critical priority for fallback scenarios
            "css-gradient-fallback"
          );
          if (this.cssController) {
            this.startCSSFallbackAnimation();
          }
          Y3K?.debug?.log("WebGLGradientStrategy", "Using CSS gradient fallback");
        }
        /**
         * Start CSS fallback animation
         */
        startCSSFallbackAnimation() {
          if (!this.cssController) return;
          const animateCSS = /* @__PURE__ */ __name(() => {
            if (!this.webglState.webglReady) return;
            const time = performance.now() / 1e3;
            const flowX = Math.sin(time * 0.04) * 20 + Math.sin(time * 0.07) * 8;
            const flowY = Math.cos(time * 0.05) * 20 + Math.cos(time * 0.09) * 6;
            const scale = 1.15 + Math.sin(time * 0.03) * 0.2;
            this.cssController.queueCSSVariableUpdate(
              "--sn-gradient-flow-x",
              `${flowX}%`
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-gradient-flow-y",
              `${flowY}%`
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-gradient-flow-scale",
              scale.toString()
            );
            setTimeout(animateCSS, this.flowSettings.frameThrottleInterval);
          }, "animateCSS");
          animateCSS();
        }
        /**
         * Select primary color from extracted colors
         */
        selectPrimaryColor(colors) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "PROMINENT",
            "VIBRANT_NON_ALARMING",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorities) {
            const color2 = colors[key];
            if (color2 && this.utils.hexToRgb(color2)) {
              return color2;
            }
          }
          return null;
        }
        /**
         * Convert hex color to RGB string
         */
        convertToRgbString(hex) {
          const rgb = this.utils.hexToRgb(hex);
          return rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "203,166,247";
        }
        /**
         * Update configuration
         */
        updateConfig(newConfig) {
          this.flowSettings = { ...this.flowSettings, ...newConfig };
          if ("oklabProcessingEnabled" in newConfig || "oklabPreset" in newConfig) {
            this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          }
          Y3K?.debug?.log("WebGLGradientStrategy", "Configuration updated:", {
            ...newConfig,
            oklabProcessing: this.flowSettings.oklabProcessingEnabled,
            oklabPreset: this.flowSettings.oklabPreset,
            gradientTextureSize: this.flowSettings.gradientTextureSize
          });
        }
        /**
         * Health check for strategy status
         */
        async healthCheck() {
          const hasRecentUpdate = Date.now() - this.webglState.lastUpdateTime < 3e4;
          return {
            healthy: this.webglState.webglReady && this.flowSettings.enabled,
            canProcess: this.canProcess({}),
            issues: !this.webglState.webglReady ? ["WebGL system not ready"] : !this.flowSettings.enabled ? ["WebGL gradient disabled in settings"] : [],
            metrics: {
              webglAvailable: this.webglState.isWebGLAvailable,
              webglReady: this.webglState.webglReady,
              flowEnabled: this.flowSettings.enabled,
              intensity: this.flowSettings.intensity,
              deviceCapability: this.deviceDetector.recommendPerformanceQuality(),
              hasRecentUpdate,
              animationActive: this.webglState.animationId !== null,
              oklabProcessing: this.flowSettings.oklabProcessingEnabled,
              oklabPreset: this.flowSettings.oklabPreset,
              gradientTextureSize: this.flowSettings.gradientTextureSize,
              canvasSize: this.webglState.canvas ? {
                width: this.webglState.canvas.width,
                height: this.webglState.canvas.height
              } : null
            }
          };
        }
        /**
         * Cleanup WebGL resources
         */
        destroy() {
          if (this.webglState.animationId) {
            cancelAnimationFrame(this.webglState.animationId);
            this.webglState.animationId = null;
          }
          if (this.webglState.gl) {
            if (this.webglState.gradientTexture) {
              this.webglState.gl.deleteTexture(this.webglState.gradientTexture);
              this.webglState.gradientTexture = null;
            }
            if (this.webglState.vertexBuffer) {
              this.webglState.gl.deleteBuffer(this.webglState.vertexBuffer);
              this.webglState.vertexBuffer = null;
            }
            if (this.webglState.vao) {
              this.webglState.gl.deleteVertexArray(this.webglState.vao);
              this.webglState.vao = null;
            }
            if (this.webglState.shaderProgram) {
              this.webglState.gl.deleteProgram(this.webglState.shaderProgram);
              this.webglState.shaderProgram = null;
            }
            ShaderLoader.clearCache(this.webglState.gl);
          }
          if (this.webglState.wrapper && this.webglState.wrapper.parentNode) {
            this.webglState.wrapper.parentNode.removeChild(this.webglState.wrapper);
            this.webglState.wrapper = null;
          }
          this.webglState.canvas = null;
          this.webglState.gl = null;
          this.webglState.webglReady = false;
          window.removeEventListener("resize", this.resizeWebGLCanvas);
          const resetVariables = {
            "--sn-webgl-ready": "0",
            "--sn-webgl-enabled": "0",
            "--sn-current-backend": "css",
            "--sn-gradient-crossfade-opacity": "0"
          };
          this.cssCoordinator.batchSetVariables(
            "WebGLGradientStrategy",
            resetVariables,
            "critical",
            // Critical priority for cleanup
            "strategy-destroy-cleanup"
          ).catch((error) => {
            Y3K?.debug?.error(
              "WebGLGradientStrategy",
              "Error during destroy cleanup:",
              error
            );
          });
          Y3K?.debug?.log(
            "WebGLGradientStrategy",
            "WebGL gradient strategy destroyed"
          );
        }
      };
      __name(_WebGLGradientStrategy, "WebGLGradientStrategy");
      WebGLGradientStrategy = _WebGLGradientStrategy;
    }
  });

  // src-js/visual/strategies/DepthLayeredStrategy.ts
  var _DepthLayeredStrategy, DepthLayeredStrategy;
  var init_DepthLayeredStrategy = __esm({
    "src-js/visual/strategies/DepthLayeredStrategy.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_globalConfig();
      init_SettingsManager();
      init_DeviceCapabilityDetector();
      init_UnifiedCSSConsciousnessController();
      init_Year3000Utilities();
      _DepthLayeredStrategy = class _DepthLayeredStrategy {
        constructor(settingsManager) {
          this.utils = Year3000Utilities_exports;
          this.config = YEAR3000_CONFIG;
          this.cssController = null;
          this.depthState = {
            containerElement: null,
            backgroundContainer: null,
            depthLayers: /* @__PURE__ */ new Map(),
            animationFrameId: null,
            lastAnimationTime: 0,
            scrollY: 0,
            scrollX: 0,
            lastUpdateTime: 0,
            isInitialized: false,
            stylesInjected: false
          };
          this.depthSettings = {
            enabled: true,
            layerCount: 6,
            maxDepth: 1e3,
            parallaxStrength: 0.5,
            depthFogIntensity: 0.7,
            infiniteScrolling: true,
            qualityLevel: "medium",
            performanceMode: false,
            musicResponsiveness: 1
          };
          this.performanceMetrics = {
            totalLayers: 0,
            visibleLayers: 0,
            averageDepth: 0,
            parallaxRange: 0,
            renderTime: 0,
            memoryUsage: 0
          };
          this.layerTemplates = {
            cosmic: {
              animation: "cosmic-drift",
              duration: "120s",
              baseGradient: "radial-gradient(ellipse at center, {primary} 0%, {secondary} 50%, {base} 100%)"
            },
            nebula: {
              animation: "nebula-flow",
              duration: "180s",
              baseGradient: "conic-gradient(from 45deg, {primary} 0%, {secondary} 25%, {tertiary} 50%, {quaternary} 75%, {primary} 100%)"
            },
            stellar: {
              animation: "stellar-motion",
              duration: "240s",
              baseGradient: "linear-gradient(45deg, {primary} 0%, {secondary} 25%, {tertiary} 50%, {quaternary} 75%, {primary} 100%)"
            },
            quantum: {
              animation: "quantum-field",
              duration: "300s",
              baseGradient: "radial-gradient(circle at 30% 70%, {primary} 0%, transparent 50%), radial-gradient(circle at 70% 30%, {secondary} 0%, transparent 50%)"
            },
            dimensional: {
              animation: "dimensional-shift",
              duration: "360s",
              baseGradient: "linear-gradient(135deg, {primary} 0%, {secondary} 20%, {tertiary} 40%, {quaternary} 60%, {primary} 80%, {secondary} 100%)"
            },
            void: {
              animation: "void-expansion",
              duration: "480s",
              baseGradient: "radial-gradient(ellipse at center, {base} 0%, {secondary} 30%, {primary} 60%, transparent 100%)"
            }
          };
          // Event handlers
          this.boundScrollHandler = null;
          this.boundResizeHandler = null;
          this.settingsManager = settingsManager || new SettingsManager();
          this.deviceDetector = new DeviceCapabilityDetector();
          this.cssController = UnifiedCSSConsciousnessController.getInstance();
          this.loadDepthSettings();
          this.adaptToDeviceCapabilities();
          this.boundScrollHandler = this.handleScroll.bind(this);
          this.boundResizeHandler = this.handleResize.bind(this);
          Y3K?.debug?.log("DepthLayeredStrategy", "Depth layered strategy initialized", {
            layerCount: this.depthSettings.layerCount,
            qualityLevel: this.depthSettings.qualityLevel,
            deviceCapability: this.deviceDetector.recommendPerformanceQuality()
          });
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "depth-layered";
        }
        /**
         * Check if strategy can handle the given context
         */
        canProcess(context) {
          return this.depthSettings.enabled;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          const baseTime = 15;
          const layerMultiplier = this.depthSettings.layerCount / 6;
          const qualityMultiplier = this.depthSettings.qualityLevel === "high" ? 1.3 : this.depthSettings.qualityLevel === "low" ? 0.7 : 1;
          return Math.round(baseTime * layerMultiplier * qualityMultiplier);
        }
        /**
         * Process colors using Depth Layered strategy
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            if (!this.depthState.isInitialized) {
              await this.initializeDepthSystem();
            }
            const depthColors = this.extractDepthColors(context.rawColors);
            await this.updateDepthLayers(depthColors);
            if (!this.depthState.animationFrameId) {
              this.startDepthAnimation();
            }
            if (context.musicData?.energy !== void 0) {
              this.updateDepthWithMusicEnergy(context.musicData.energy);
            }
            this.depthState.lastUpdateTime = Date.now();
            this.updatePerformanceMetrics();
            const processingTime = performance.now() - startTime;
            const result = {
              processedColors: {
                depthLayers: this.depthState.depthLayers.size.toString(),
                depthEnabled: this.depthSettings.enabled.toString(),
                qualityLevel: this.depthSettings.qualityLevel,
                ...context.rawColors
              },
              accentHex: this.selectPrimaryColor(context.rawColors) || "#cba6f7",
              accentRgb: this.convertToRgbString(this.selectPrimaryColor(context.rawColors) || "#cba6f7"),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `depth-layered-${context.trackUri}`,
                harmonicIntensity: this.depthSettings.parallaxStrength,
                layerCount: this.depthState.depthLayers.size
              },
              context
            };
            Y3K?.debug?.log("DepthLayeredStrategy", "Depth layered processing completed", {
              layerCount: this.depthState.depthLayers.size,
              processingTime,
              trackUri: context.trackUri
            });
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3K?.debug?.error("DepthLayeredStrategy", "Depth layered processing failed:", error);
            return {
              processedColors: context.rawColors,
              accentHex: this.selectPrimaryColor(context.rawColors) || "#cba6f7",
              accentRgb: this.convertToRgbString(this.selectPrimaryColor(context.rawColors) || "#cba6f7"),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error"
              },
              context
            };
          }
        }
        /**
         * Load depth settings from settings manager
         */
        loadDepthSettings() {
          if (!this.settingsManager) return;
          try {
            const qualitySetting = this.settingsManager.get("sn-depth-quality");
            if (qualitySetting) {
              this.depthSettings.qualityLevel = qualitySetting;
              this.adjustQualitySettings();
            }
            const enabledSetting = this.settingsManager.get("sn-depth-enabled");
            if (enabledSetting !== void 0) {
              this.depthSettings.enabled = enabledSetting;
            }
          } catch (error) {
            Y3K?.debug?.warn("DepthLayeredStrategy", "Failed to load settings:", error);
          }
        }
        /**
         * Adapt settings to device capabilities
         */
        adaptToDeviceCapabilities() {
          const recommendation = this.deviceDetector.recommendPerformanceQuality();
          switch (recommendation) {
            case "low":
              this.depthSettings.qualityLevel = "low";
              this.depthSettings.layerCount = 3;
              this.depthSettings.performanceMode = true;
              this.depthSettings.parallaxStrength = 0.3;
              this.depthSettings.depthFogIntensity = 0.5;
              break;
            case "balanced":
              this.depthSettings.qualityLevel = "medium";
              this.depthSettings.layerCount = 6;
              this.depthSettings.performanceMode = false;
              this.depthSettings.parallaxStrength = 0.5;
              this.depthSettings.depthFogIntensity = 0.7;
              break;
            case "high":
              this.depthSettings.qualityLevel = "high";
              this.depthSettings.layerCount = 9;
              this.depthSettings.performanceMode = false;
              this.depthSettings.parallaxStrength = 0.8;
              this.depthSettings.depthFogIntensity = 0.9;
              break;
          }
        }
        /**
         * Adjust quality settings based on selected level
         */
        adjustQualitySettings() {
          switch (this.depthSettings.qualityLevel) {
            case "low":
              this.depthSettings.layerCount = 3;
              this.depthSettings.parallaxStrength = 0.3;
              this.depthSettings.depthFogIntensity = 0.5;
              break;
            case "medium":
              this.depthSettings.layerCount = 6;
              this.depthSettings.parallaxStrength = 0.5;
              this.depthSettings.depthFogIntensity = 0.7;
              break;
            case "high":
              this.depthSettings.layerCount = 9;
              this.depthSettings.parallaxStrength = 0.8;
              this.depthSettings.depthFogIntensity = 0.9;
              break;
          }
        }
        /**
         * Initialize depth system
         */
        async initializeDepthSystem() {
          this.createContainerElements();
          this.injectDepthAnimations();
          this.setupEventListeners();
          this.depthState.isInitialized = true;
          Y3K?.debug?.log("DepthLayeredStrategy", "Depth system initialized successfully");
        }
        /**
         * Create container elements for depth layers
         */
        createContainerElements() {
          this.depthState.containerElement = document.querySelector(".Root__main-view") || document.querySelector(".main-view-container") || document.body;
          this.depthState.backgroundContainer = document.createElement("div");
          this.depthState.backgroundContainer.className = "sn-depth-background-container";
          this.depthState.backgroundContainer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -20;
      pointer-events: none;
      overflow: hidden;
      perspective: 1000px;
      transform-style: preserve-3d;
    `;
          this.depthState.containerElement.insertBefore(
            this.depthState.backgroundContainer,
            this.depthState.containerElement.firstChild
          );
        }
        /**
         * Inject CSS animations for depth layers
         */
        injectDepthAnimations() {
          if (this.depthState.stylesInjected) return;
          const styleElement = document.createElement("style");
          styleElement.textContent = `
      .sn-depth-layer {
        position: absolute;
        width: 120%;
        height: 120%;
        top: -10%;
        left: -10%;
        pointer-events: none;
        transform-style: preserve-3d;
        will-change: transform, opacity;
      }
      
      @keyframes cosmic-drift {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        25% { transform: translate3d(-2%, 1%, 0) rotate(0.5deg) scale(1.02); }
        50% { transform: translate3d(0, -1%, 0) rotate(0deg) scale(0.98); }
        75% { transform: translate3d(2%, 0.5%, 0) rotate(-0.5deg) scale(1.01); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }
      
      @keyframes nebula-flow {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        33% { transform: translate3d(1%, -1%, 0) rotate(1deg) scale(1.03); }
        66% { transform: translate3d(-1%, 1%, 0) rotate(-1deg) scale(0.97); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }
      
      @keyframes stellar-motion {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        20% { transform: translate3d(-1%, 0.5%, 0) rotate(0.3deg) scale(1.01); }
        40% { transform: translate3d(0.5%, -0.5%, 0) rotate(-0.3deg) scale(0.99); }
        60% { transform: translate3d(1%, 0.5%, 0) rotate(0.2deg) scale(1.02); }
        80% { transform: translate3d(-0.5%, 1%, 0) rotate(-0.2deg) scale(0.98); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }
      
      @keyframes quantum-field {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); filter: blur(0px); }
        25% { transform: translate3d(0.5%, -0.5%, 0) rotate(0.1deg) scale(1.01); filter: blur(0.5px); }
        50% { transform: translate3d(-0.5%, 0.5%, 0) rotate(-0.1deg) scale(0.99); filter: blur(1px); }
        75% { transform: translate3d(0.3%, 0.3%, 0) rotate(0.05deg) scale(1.005); filter: blur(0.3px); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); filter: blur(0px); }
      }
      
      @keyframes dimensional-shift {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        16% { transform: translate3d(0.2%, -0.2%, 0) rotate(0.1deg) scale(1.005); }
        32% { transform: translate3d(-0.2%, 0.2%, 0) rotate(-0.1deg) scale(0.995); }
        48% { transform: translate3d(0.1%, 0.1%, 0) rotate(0.05deg) scale(1.002); }
        64% { transform: translate3d(-0.1%, -0.1%, 0) rotate(-0.05deg) scale(0.998); }
        80% { transform: translate3d(0.15%, 0%, 0) rotate(0.02deg) scale(1.001); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }
      
      @keyframes void-expansion {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.9; }
        50% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1.1); opacity: 0.6; }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.9; }
      }
      
      @media (prefers-reduced-motion: reduce) {
        .sn-depth-layer {
          animation: none !important;
        }
      }
    `;
          document.head.appendChild(styleElement);
          this.depthState.stylesInjected = true;
        }
        /**
         * Setup event listeners for depth system
         */
        setupEventListeners() {
          if (this.boundScrollHandler) {
            window.addEventListener("scroll", this.boundScrollHandler, { passive: true });
          }
          if (this.boundResizeHandler) {
            window.addEventListener("resize", this.boundResizeHandler, { passive: true });
          }
        }
        /**
         * Extract depth colors from color context
         */
        extractDepthColors(colors) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "LIGHT_VIBRANT",
            "DARK_VIBRANT",
            "VIBRANT_NON_ALARMING",
            "PROMINENT",
            "SECONDARY",
            "DESATURATED"
          ];
          const depthColors = [];
          const usedColors = /* @__PURE__ */ new Set();
          for (const key of priorities) {
            const color2 = colors[key];
            if (color2 && !usedColors.has(color2) && this.utils.hexToRgb(color2)) {
              depthColors.push(color2);
              usedColors.add(color2);
              if (depthColors.length >= this.depthSettings.layerCount) break;
            }
          }
          while (depthColors.length < this.depthSettings.layerCount) {
            const baseColor = depthColors[0] || "#cba6f7";
            const variation = this.createColorVariation(baseColor, depthColors.length);
            depthColors.push(variation);
          }
          return depthColors;
        }
        /**
         * Create color variation for depth layers
         */
        createColorVariation(baseColor, index) {
          const rgb = this.utils.hexToRgb(baseColor);
          if (!rgb) return baseColor;
          const factor = 0.8 - index * 0.1;
          const r = Math.round(rgb.r * factor);
          const g2 = Math.round(rgb.g * factor);
          const b = Math.round(rgb.b * factor);
          return this.utils.rgbToHex(r, g2, b);
        }
        /**
         * Update depth layers with new colors
         */
        async updateDepthLayers(depthColors) {
          if (!this.depthState.backgroundContainer) return;
          this.depthState.depthLayers.forEach((layer) => {
            if (layer.element.parentNode) {
              layer.element.parentNode.removeChild(layer.element);
            }
          });
          this.depthState.depthLayers.clear();
          const layerTemplateKeys = Object.keys(this.layerTemplates);
          for (let i = 0; i < this.depthSettings.layerCount; i++) {
            const depth = (i + 1) * (this.depthSettings.maxDepth / this.depthSettings.layerCount);
            const templateKey = layerTemplateKeys[i % layerTemplateKeys.length];
            const template = this.layerTemplates[templateKey];
            const layerElement = document.createElement("div");
            layerElement.className = "sn-depth-layer";
            layerElement.id = `sn-depth-layer-${i}`;
            const depthFactor = depth / this.depthSettings.maxDepth;
            const parallaxFactor = 1 - depthFactor * this.depthSettings.parallaxStrength;
            const opacity = 1 - depthFactor * this.depthSettings.depthFogIntensity;
            const scale = 1 + depthFactor * 0.2;
            const blur = depthFactor * 3;
            const gradient = this.createDepthGradient(template.baseGradient, depthColors, i);
            layerElement.style.cssText = `
        background: ${gradient};
        transform: translate3d(0, 0, ${-depth}px) scale(${scale});
        opacity: ${opacity};
        filter: blur(${blur}px);
        animation: ${template.animation} ${template.duration} ease-in-out infinite;
        animation-delay: ${i * 0.5}s;
      `;
            const depthLayer = {
              id: `depth-layer-${i}`,
              element: layerElement,
              depth,
              parallaxFactor,
              opacityRange: [opacity * 0.5, opacity],
              scaleRange: [scale * 0.95, scale * 1.05],
              rotationSpeed: 0.01 + i * 1e-3,
              colorShift: i * 30,
              blurAmount: blur,
              animationPhase: i * Math.PI / 4,
              enabled: true,
              gradientColors: depthColors.slice(i, i + 4)
            };
            this.depthState.depthLayers.set(depthLayer.id, depthLayer);
            this.depthState.backgroundContainer.appendChild(layerElement);
          }
          Y3K?.debug?.log("DepthLayeredStrategy", `Updated ${this.depthState.depthLayers.size} depth layers with new colors`);
        }
        /**
         * Create depth gradient from template and colors
         */
        createDepthGradient(template, colors, layerIndex) {
          const colorCount = colors.length;
          const primaryIndex = layerIndex % colorCount;
          const secondaryIndex = (layerIndex + 1) % colorCount;
          const tertiaryIndex = (layerIndex + 2) % colorCount;
          const quaternaryIndex = (layerIndex + 3) % colorCount;
          const depthFactor = layerIndex / this.depthSettings.layerCount;
          const baseOpacity = 0.8 - depthFactor * 0.6;
          const primary = this.convertToRgba(colors[primaryIndex] || "#cba6f7", baseOpacity);
          const secondary = this.convertToRgba(colors[secondaryIndex] || "#f5c2e7", baseOpacity * 0.7);
          const tertiary = this.convertToRgba(colors[tertiaryIndex] || "#fab387", baseOpacity * 0.5);
          const quaternary = this.convertToRgba(colors[quaternaryIndex] || "#a6e3a1", baseOpacity * 0.3);
          const base = this.convertToRgba("#1e1e2e", baseOpacity * 0.9);
          return template.replace(/\{primary\}/g, primary).replace(/\{secondary\}/g, secondary).replace(/\{tertiary\}/g, tertiary).replace(/\{quaternary\}/g, quaternary).replace(/\{base\}/g, base);
        }
        /**
         * Convert hex color to RGBA string
         */
        convertToRgba(hex, alpha) {
          const rgb = this.utils.hexToRgb(hex);
          return rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})` : `rgba(203, 166, 247, ${alpha})`;
        }
        /**
         * Start depth animation loop
         */
        startDepthAnimation() {
          this.depthState.lastAnimationTime = performance.now();
          const animate = /* @__PURE__ */ __name(() => {
            if (!this.depthState.isInitialized) return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.depthState.lastAnimationTime;
            if (deltaTime < 33) {
              this.depthState.animationFrameId = requestAnimationFrame(animate);
              return;
            }
            this.depthState.lastAnimationTime = currentTime;
            this.updateDepthAnimations(deltaTime);
            this.updatePerformanceMetrics();
            this.depthState.animationFrameId = requestAnimationFrame(animate);
          }, "animate");
          this.depthState.animationFrameId = requestAnimationFrame(animate);
        }
        /**
         * Update depth animations
         */
        updateDepthAnimations(deltaTime) {
          this.depthState.depthLayers.forEach((layer) => {
            layer.animationPhase += layer.rotationSpeed * deltaTime * 1e-3;
            const breathingFactor = Math.sin(layer.animationPhase) * 0.05;
            const currentOpacity = parseFloat(layer.element.style.opacity);
            const newOpacity = currentOpacity + breathingFactor;
            layer.element.style.opacity = Math.max(0, Math.min(1, newOpacity)).toString();
          });
        }
        /**
         * Update depth with music energy
         */
        updateDepthWithMusicEnergy(energy) {
          const energyModulation = energy * this.depthSettings.musicResponsiveness * 0.3;
          this.depthState.depthLayers.forEach((layer) => {
            const baseOpacity = layer.opacityRange[0];
            const maxOpacity = layer.opacityRange[1];
            const newOpacity = baseOpacity + energyModulation * (maxOpacity - baseOpacity);
            layer.element.style.opacity = Math.max(0, Math.min(1, newOpacity)).toString();
          });
        }
        /**
         * Handle scroll events for parallax
         */
        handleScroll(event) {
          if (!this.depthSettings.infiniteScrolling) return;
          this.depthState.scrollY = window.scrollY;
          this.depthState.scrollX = window.scrollX;
          this.updateParallaxEffects();
        }
        /**
         * Handle resize events
         */
        handleResize(event) {
          this.updateLayerDimensions();
        }
        /**
         * Update parallax effects
         */
        updateParallaxEffects() {
          this.depthState.depthLayers.forEach((layer) => {
            const parallaxY = this.depthState.scrollY * layer.parallaxFactor;
            const parallaxX = this.depthState.scrollX * layer.parallaxFactor * 0.5;
            const currentTransform = layer.element.style.transform;
            const newTransform = currentTransform.replace(
              /translate3d\([^)]*\)/,
              `translate3d(${parallaxX}px, ${parallaxY}px, ${-layer.depth}px)`
            );
            layer.element.style.transform = newTransform;
          });
        }
        /**
         * Update layer dimensions
         */
        updateLayerDimensions() {
          this.depthState.depthLayers.forEach((layer) => {
            const depthFactor = layer.depth / this.depthSettings.maxDepth;
            const scale = 1 + depthFactor * 0.2;
            const currentTransform = layer.element.style.transform;
            const newTransform = currentTransform.replace(
              /scale\([^)]*\)/,
              `scale(${scale})`
            );
            layer.element.style.transform = newTransform;
          });
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics() {
          this.performanceMetrics.totalLayers = this.depthState.depthLayers.size;
          this.performanceMetrics.visibleLayers = Array.from(this.depthState.depthLayers.values()).filter((layer) => parseFloat(layer.element.style.opacity) > 0.01).length;
          this.performanceMetrics.averageDepth = Array.from(this.depthState.depthLayers.values()).reduce((sum, layer) => sum + layer.depth, 0) / this.depthState.depthLayers.size;
          this.performanceMetrics.parallaxRange = this.depthSettings.parallaxStrength;
          this.performanceMetrics.renderTime = performance.now() - this.depthState.lastAnimationTime;
          if (this.cssController) {
            this.cssController.queueCSSVariableUpdate(
              "--sn-depth-layers-total",
              this.performanceMetrics.totalLayers.toString()
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-depth-layers-visible",
              this.performanceMetrics.visibleLayers.toString()
            );
          }
        }
        /**
         * Select primary color from extracted colors
         */
        selectPrimaryColor(colors) {
          const priorities = ["PRIMARY", "VIBRANT", "PROMINENT", "VIBRANT_NON_ALARMING", "LIGHT_VIBRANT"];
          for (const key of priorities) {
            const color2 = colors[key];
            if (color2 && this.utils.hexToRgb(color2)) {
              return color2;
            }
          }
          return null;
        }
        /**
         * Convert hex color to RGB string
         */
        convertToRgbString(hex) {
          const rgb = this.utils.hexToRgb(hex);
          return rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "203,166,247";
        }
        /**
         * Update configuration
         */
        updateConfig(newConfig) {
          this.depthSettings = { ...this.depthSettings, ...newConfig };
          if (newConfig.qualityLevel) {
            this.adjustQualitySettings();
          }
          Y3K?.debug?.log("DepthLayeredStrategy", "Configuration updated:", newConfig);
        }
        /**
         * Health check for strategy status
         */
        async healthCheck() {
          const hasRecentUpdate = Date.now() - this.depthState.lastUpdateTime < 3e4;
          return {
            healthy: this.depthState.isInitialized && this.depthSettings.enabled,
            canProcess: this.canProcess({}),
            issues: !this.depthState.isInitialized ? ["Depth system not initialized"] : !this.depthSettings.enabled ? ["Depth layers disabled in settings"] : [],
            metrics: {
              isInitialized: this.depthState.isInitialized,
              depthEnabled: this.depthSettings.enabled,
              layerCount: this.depthState.depthLayers.size,
              qualityLevel: this.depthSettings.qualityLevel,
              parallaxStrength: this.depthSettings.parallaxStrength,
              hasRecentUpdate,
              animationActive: this.depthState.animationFrameId !== null,
              performanceMetrics: this.performanceMetrics
            }
          };
        }
        /**
         * Cleanup depth resources
         */
        destroy() {
          if (this.depthState.animationFrameId) {
            cancelAnimationFrame(this.depthState.animationFrameId);
            this.depthState.animationFrameId = null;
          }
          if (this.boundScrollHandler) {
            window.removeEventListener("scroll", this.boundScrollHandler);
            this.boundScrollHandler = null;
          }
          if (this.boundResizeHandler) {
            window.removeEventListener("resize", this.boundResizeHandler);
            this.boundResizeHandler = null;
          }
          this.depthState.depthLayers.forEach((layer) => {
            if (layer.element.parentNode) {
              layer.element.parentNode.removeChild(layer.element);
            }
          });
          this.depthState.depthLayers.clear();
          if (this.depthState.backgroundContainer && this.depthState.backgroundContainer.parentNode) {
            this.depthState.backgroundContainer.parentNode.removeChild(this.depthState.backgroundContainer);
            this.depthState.backgroundContainer = null;
          }
          this.depthState.isInitialized = false;
          this.depthState.containerElement = null;
          Y3K?.debug?.log("DepthLayeredStrategy", "Depth layered strategy destroyed");
        }
      };
      __name(_DepthLayeredStrategy, "DepthLayeredStrategy");
      DepthLayeredStrategy = _DepthLayeredStrategy;
    }
  });

  // src-js/visual/strategies/BackgroundStrategySelector.ts
  var _BackgroundStrategySelector, BackgroundStrategySelector;
  var init_BackgroundStrategySelector = __esm({
    "src-js/visual/strategies/BackgroundStrategySelector.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_DeviceCapabilityDetector();
      init_SettingsManager();
      init_DynamicCatppuccinStrategy();
      init_LivingGradientStrategy();
      init_WebGLGradientStrategy();
      init_DepthLayeredStrategy();
      _BackgroundStrategySelector = class _BackgroundStrategySelector {
        constructor(settingsManager) {
          // Strategy instances (lazy-loaded)
          this.strategyInstances = /* @__PURE__ */ new Map();
          // Strategy metadata for selection decisions
          this.strategyMetadata = /* @__PURE__ */ new Map();
          this.settingsManager = settingsManager || new SettingsManager();
          this.deviceDetector = new DeviceCapabilityDetector();
          this.initializeStrategyMetadata();
          Y3K?.debug?.log("BackgroundStrategySelector", "Strategy selector initialized");
        }
        /**
         * Initialize metadata for all available strategies
         */
        initializeStrategyMetadata() {
          this.strategyMetadata.set("dynamic-catppuccin", {
            name: "dynamic-catppuccin",
            priority: 10,
            // Highest priority - core accent system
            estimatedProcessingTime: 5,
            memoryImpact: 2,
            qualityScore: 9,
            compatibilityScore: 10
            // Always compatible
          });
          this.strategyMetadata.set("living-gradient", {
            name: "living-gradient",
            priority: 8,
            // High priority - foundation layer
            estimatedProcessingTime: 8,
            memoryImpact: 3,
            qualityScore: 8,
            compatibilityScore: 9
            // Compatible with most devices
          });
          this.strategyMetadata.set("webgl-gradient", {
            name: "webgl-gradient",
            priority: 6,
            // Medium-high priority - performance dependent
            estimatedProcessingTime: 12,
            memoryImpact: 7,
            qualityScore: 10,
            compatibilityScore: 6
            // Requires WebGL support
          });
          this.strategyMetadata.set("depth-layered", {
            name: "depth-layered",
            priority: 7,
            // Medium-high priority - consciousness enhancement
            estimatedProcessingTime: 15,
            memoryImpact: 5,
            qualityScore: 9,
            compatibilityScore: 7
            // Requires moderate device capabilities
          });
        }
        /**
         * Select optimal strategies based on comprehensive criteria analysis
         */
        selectStrategies(context, criteria) {
          const startTime = performance.now();
          const selectedStrategies = [];
          try {
            const deviceContext = criteria.deviceContext || this.buildDeviceContext();
            const settingsContext = criteria.settingsContext || this.buildSettingsContext();
            const strategyDecisions = this.analyzeStrategyCompatibility(
              context,
              { ...criteria, deviceContext, settingsContext }
            );
            for (const decision of strategyDecisions) {
              if (decision.shouldInclude) {
                const strategy = this.getOrCreateStrategy(decision.strategyName);
                if (strategy && strategy.canProcess(context)) {
                  selectedStrategies.push(strategy);
                }
              }
            }
            if (selectedStrategies.length === 0) {
              const fallbackStrategy = this.getOrCreateStrategy("living-gradient");
              if (fallbackStrategy?.canProcess(context)) {
                selectedStrategies.push(fallbackStrategy);
              }
            }
            const processingTime = performance.now() - startTime;
            Y3K?.debug?.log("BackgroundStrategySelector", "Strategy selection completed", {
              selectedCount: selectedStrategies.length,
              strategies: selectedStrategies.map((s) => s.getStrategyName()),
              processingTime,
              deviceLevel: deviceContext.performanceLevel,
              visualGuideMode: settingsContext.visualGuideMode
            });
            return selectedStrategies;
          } catch (error) {
            Y3K?.debug?.error("BackgroundStrategySelector", "Strategy selection failed:", error);
            const fallbackStrategy = this.getOrCreateStrategy("living-gradient");
            return fallbackStrategy ? [fallbackStrategy] : [];
          }
        }
        /**
         * Analyze strategy compatibility and selection logic
         */
        analyzeStrategyCompatibility(context, criteria) {
          const decisions = [];
          const dynamicScore = this.scoreDynamicCatppuccinStrategy(criteria);
          decisions.push({
            strategyName: "dynamic-catppuccin",
            shouldInclude: criteria.settingsContext.dynamicAccentEnabled && dynamicScore > 0.5,
            reason: criteria.settingsContext.dynamicAccentEnabled ? `Dynamic accent enabled (score: ${dynamicScore.toFixed(2)})` : "Dynamic accent disabled in settings",
            score: dynamicScore
          });
          const livingScore = this.scoreLivingGradientStrategy(criteria);
          decisions.push({
            strategyName: "living-gradient",
            shouldInclude: livingScore > 0.3,
            // Almost always include as foundation
            reason: `Living gradient foundation (score: ${livingScore.toFixed(2)})`,
            score: livingScore
          });
          const webglScore = this.scoreWebGLGradientStrategy(criteria);
          decisions.push({
            strategyName: "webgl-gradient",
            shouldInclude: criteria.settingsContext.webglEnabled && criteria.deviceContext.supportsWebGL && criteria.deviceContext.performanceLevel !== "low" && webglScore > 0.6,
            reason: `WebGL capabilities (score: ${webglScore.toFixed(2)}, device: ${criteria.deviceContext.performanceLevel})`,
            score: webglScore
          });
          const depthScore = this.scoreDepthLayeredStrategy(criteria);
          decisions.push({
            strategyName: "depth-layered",
            shouldInclude: criteria.settingsContext.depthLayersEnabled && criteria.settingsContext.consciousnessLevel > 0.4 && criteria.deviceContext.performanceLevel !== "low" && depthScore > 0.5,
            reason: `Depth consciousness (score: ${depthScore.toFixed(2)}, consciousness: ${criteria.settingsContext.consciousnessLevel})`,
            score: depthScore
          });
          return decisions;
        }
        /**
         * Score Dynamic Catppuccin Strategy compatibility
         */
        scoreDynamicCatppuccinStrategy(criteria) {
          let score = 0.8;
          if (criteria.settingsContext.dynamicAccentEnabled) score += 0.2;
          if (criteria.musicContext?.energy && criteria.musicContext.energy > 0.7) {
            score += 0.1;
          }
          const visualModes = ["cosmic", "cinematic", "ethereal", "natural"];
          if (visualModes.includes(criteria.settingsContext.visualGuideMode)) {
            score += 0.1;
          }
          score += 0.1;
          return Math.min(1, score);
        }
        /**
         * Score Living Gradient Strategy compatibility
         */
        scoreLivingGradientStrategy(criteria) {
          let score = 0.9;
          if (criteria.settingsContext.breathingAnimationEnabled) score += 0.1;
          score += criteria.settingsContext.consciousnessLevel * 0.2;
          if (criteria.musicContext?.valence !== void 0) {
            score += 0.05;
          }
          if (criteria.deviceContext.performanceLevel === "high") score += 0.05;
          return Math.min(1, score);
        }
        /**
         * Score WebGL Gradient Strategy compatibility
         */
        scoreWebGLGradientStrategy(criteria) {
          let score = 0;
          if (!criteria.deviceContext.supportsWebGL) return 0;
          if (!criteria.settingsContext.webglEnabled) return 0;
          score = 0.6;
          switch (criteria.deviceContext.performanceLevel) {
            case "high":
              score += 0.3;
              break;
            case "medium":
              score += 0.2;
              break;
            case "low":
              score = 0;
              return 0;
          }
          if (criteria.deviceContext.memoryCapacity > 4e3) score += 0.1;
          if (criteria.deviceContext.memoryCapacity > 8e3) score += 0.1;
          if (criteria.settingsContext.consciousnessLevel > 0.7) score += 0.1;
          if (criteria.musicContext?.energy && criteria.musicContext.energy > 0.8) {
            score += 0.1;
          }
          if (criteria.deviceContext.isMobile) score -= 0.2;
          return Math.min(1, Math.max(0, score));
        }
        /**
         * Score Depth Layered Strategy compatibility
         */
        scoreDepthLayeredStrategy(criteria) {
          let score = 0;
          if (!criteria.settingsContext.depthLayersEnabled) return 0;
          score = 0.5;
          score += criteria.settingsContext.consciousnessLevel * 0.4;
          switch (criteria.deviceContext.performanceLevel) {
            case "high":
              score += 0.2;
              break;
            case "medium":
              score += 0.1;
              break;
            case "low":
              score = 0;
              return 0;
          }
          if (["cosmic", "cinematic"].includes(criteria.settingsContext.visualGuideMode)) {
            score += 0.2;
          }
          if (criteria.musicContext?.tempo && criteria.musicContext.tempo < 100) {
            score += 0.1;
          }
          if (criteria.deviceContext.memoryCapacity > 6e3) score += 0.1;
          if (criteria.deviceContext.isMobile) score -= 0.15;
          return Math.min(1, Math.max(0, score));
        }
        /**
         * Build device context from current device capabilities
         */
        buildDeviceContext() {
          const memoryMB = window.navigator.deviceMemory ? window.navigator.deviceMemory * 1024 : 4096;
          const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
          return {
            supportsWebGL: this.deviceDetector.hasWebGLSupport ? this.deviceDetector.hasWebGLSupport() : false,
            performanceLevel: this.deviceDetector.recommendPerformanceQuality(),
            memoryCapacity: memoryMB,
            isMobile
          };
        }
        /**
         * Build settings context from settings manager
         */
        buildSettingsContext() {
          try {
            return {
              dynamicAccentEnabled: this.settingsManager.get("sn-dynamic-accent-enabled") ?? true,
              gradientIntensity: this.settingsManager.get("sn-gradient-intensity") ?? "balanced",
              webglEnabled: this.settingsManager.get("sn-webgl-enabled") ?? true,
              visualGuideMode: this.settingsManager.get("sn-visual-guide-mode") ?? "cosmic",
              depthLayersEnabled: this.settingsManager.get("sn-depth-enabled") ?? true,
              consciousnessLevel: this.settingsManager.get("sn-consciousness-level") ?? 0.8,
              breathingAnimationEnabled: this.settingsManager.get("sn-breathing-enabled") ?? true
            };
          } catch (error) {
            Y3K?.debug?.warn("BackgroundStrategySelector", "Failed to load settings, using defaults:", error);
            return {
              dynamicAccentEnabled: true,
              gradientIntensity: "balanced",
              webglEnabled: true,
              visualGuideMode: "cosmic",
              depthLayersEnabled: true,
              consciousnessLevel: 0.8,
              breathingAnimationEnabled: true
            };
          }
        }
        /**
         * Get or create strategy instance (lazy loading)
         */
        getOrCreateStrategy(strategyName) {
          if (this.strategyInstances.has(strategyName)) {
            return this.strategyInstances.get(strategyName);
          }
          let strategy = null;
          try {
            switch (strategyName) {
              case "dynamic-catppuccin":
                strategy = new DynamicCatppuccinStrategy(this.settingsManager);
                break;
              case "living-gradient":
                strategy = new LivingGradientStrategy(this.settingsManager);
                break;
              case "webgl-gradient":
                strategy = new WebGLGradientStrategy(this.settingsManager);
                break;
              case "depth-layered":
                strategy = new DepthLayeredStrategy(this.settingsManager);
                break;
              default:
                Y3K?.debug?.warn("BackgroundStrategySelector", `Unknown strategy: ${strategyName}`);
                return null;
            }
            if (strategy) {
              this.strategyInstances.set(strategyName, strategy);
              Y3K?.debug?.log("BackgroundStrategySelector", `Created strategy instance: ${strategyName}`);
            }
          } catch (error) {
            Y3K?.debug?.error("BackgroundStrategySelector", `Failed to create strategy ${strategyName}:`, error);
            return null;
          }
          return strategy;
        }
        /**
         * Get estimated total processing time for selected strategies
         */
        getEstimatedProcessingTime(strategies, context) {
          return strategies.reduce((total, strategy) => {
            return total + strategy.getEstimatedProcessingTime(context);
          }, 0);
        }
        /**
         * Get strategy metadata for debugging
         */
        getStrategyMetadata(strategyName) {
          return this.strategyMetadata.get(strategyName) || null;
        }
        /**
         * Get all available strategy names
         */
        getAvailableStrategyNames() {
          return Array.from(this.strategyMetadata.keys());
        }
        /**
         * Update strategy selection criteria (for runtime adjustments)
         */
        updateSelectionCriteria(updates) {
          Y3K?.debug?.log("BackgroundStrategySelector", "Strategy selection criteria updated:", updates);
        }
        /**
         * Cleanup strategy instances
         */
        destroy() {
          this.strategyInstances.forEach((strategy, name) => {
            if ("destroy" in strategy && typeof strategy.destroy === "function") {
              try {
                strategy.destroy();
              } catch (error) {
                Y3K?.debug?.warn("BackgroundStrategySelector", `Error destroying strategy ${name}:`, error);
              }
            }
          });
          this.strategyInstances.clear();
          this.strategyMetadata.clear();
          Y3K?.debug?.log("BackgroundStrategySelector", "Strategy selector destroyed");
        }
      };
      __name(_BackgroundStrategySelector, "BackgroundStrategySelector");
      BackgroundStrategySelector = _BackgroundStrategySelector;
    }
  });

  // src-js/visual/integration/ColorOrchestrator.ts
  var _ColorStrategyRegistry, ColorStrategyRegistry, _ColorOrchestrator, ColorOrchestrator, globalColorOrchestrator;
  var init_ColorOrchestrator = __esm({
    "src-js/visual/integration/ColorOrchestrator.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_globalConfig();
      init_PerformanceAnalyzer();
      init_DeviceCapabilityDetector();
      init_SettingsManager();
      init_BackgroundStrategySelector();
      init_OKLABColorProcessor();
      init_Year3000Utilities();
      _ColorStrategyRegistry = class _ColorStrategyRegistry {
        constructor() {
          this.strategies = /* @__PURE__ */ new Map();
          this.defaultStrategy = null;
        }
        /**
         * Register a color processing strategy
         */
        register(strategy) {
          const name = strategy.getStrategyName();
          this.strategies.set(name, strategy);
          if (!this.defaultStrategy) {
            this.defaultStrategy = strategy;
          }
          Y3K?.debug?.log("ColorStrategyRegistry", `Registered strategy: ${name}`);
        }
        /**
         * Select best strategy for given criteria
         */
        selectStrategy(criteria) {
          if (criteria.performance === "high" && criteria.quality === "basic") {
            for (const strategy of this.strategies.values()) {
              const strategyName = strategy.getStrategyName().toLowerCase();
              if (strategyName.includes("lightweight") || strategyName.includes("fast")) {
                return strategy;
              }
            }
          }
          if (criteria.quality === "premium" && criteria.performance === "low") {
            for (const strategy of this.strategies.values()) {
              const strategyName = strategy.getStrategyName().toLowerCase();
              if (strategyName.includes("harmony") || strategyName.includes("advanced")) {
                return strategy;
              }
            }
          }
          if (criteria.deviceCapabilities?.isMobile) {
            for (const strategy of this.strategies.values()) {
              const strategyName = strategy.getStrategyName().toLowerCase();
              if (strategyName.includes("mobile") || strategyName.includes("optimized")) {
                return strategy;
              }
            }
          }
          return this.defaultStrategy;
        }
        /**
         * Get all registered strategies
         */
        getStrategies() {
          return Array.from(this.strategies.values());
        }
        /**
         * Get strategy by name
         */
        getStrategy(name) {
          return this.strategies.get(name) || null;
        }
        /**
         * Set default strategy
         */
        setDefaultStrategy(strategy) {
          this.defaultStrategy = strategy;
        }
        /**
         * Get registry status
         */
        getStatus() {
          return {
            strategyCount: this.strategies.size,
            strategies: Array.from(this.strategies.keys()),
            defaultStrategy: this.defaultStrategy?.getStrategyName() || null
          };
        }
      };
      __name(_ColorStrategyRegistry, "ColorStrategyRegistry");
      ColorStrategyRegistry = _ColorStrategyRegistry;
      _ColorOrchestrator = class _ColorOrchestrator {
        constructor() {
          this.isInitialized = false;
          this.processingQueue = [];
          this.isProcessing = false;
          this.currentStrategy = null;
          this.oklabCoordinationEnabled = true;
          // Phase 4: Recursion prevention
          this.processedContexts = /* @__PURE__ */ new Map();
          // trackUri -> timestamp
          this.CONTEXT_CACHE_TTL = 2e3;
          // 2 seconds to prevent rapid reprocessing
          this.MAX_QUEUE_SIZE = 10;
          // Prevent queue overflow
          // Enhanced result caching for performance
          this.resultCache = /* @__PURE__ */ new Map();
          this.cacheMaxSize = 50;
          this.cacheTimeoutMs = 3e5;
          // 5 minutes
          // Enhanced performance metrics
          this.orchestrationMetrics = {
            totalProcessingTime: 0,
            strategiesProcessed: 0,
            strategiesSucceeded: 0,
            strategiesFailed: 0,
            cacheHits: 0,
            averageStrategyTime: 0,
            memoryUsage: 0,
            oklabCoordinations: 0,
            oklabProcessingTime: 0
          };
          // Legacy performance tracking (maintained for compatibility)
          this.processedCount = 0;
          this.totalProcessingTime = 0;
          this.lastProcessingTime = 0;
          this.registry = new ColorStrategyRegistry();
          this.settingsManager = new SettingsManager();
          this.performanceAnalyzer = new PerformanceAnalyzer(YEAR3000_CONFIG);
          this.deviceDetector = new DeviceCapabilityDetector();
          this.strategySelector = new BackgroundStrategySelector(this.settingsManager);
          this.oklabProcessor = new OKLABColorProcessor(YEAR3000_CONFIG.enableDebug);
          this.selectionCriteria = {
            performance: "medium",
            quality: "enhanced",
            deviceCapabilities: {
              hasWebGL: Boolean(window.WebGLRenderingContext),
              memoryMB: this.estimateMemoryMB(),
              isMobile: this.detectMobile()
            },
            userPreferences: {
              harmonicMode: "cosmic",
              intensity: 0.8,
              enableAdvancedBlending: true
            }
          };
          this.updateDeviceCapabilities();
          Y3K?.debug?.log("ColorOrchestrator", "Enhanced color orchestrator created with multi-strategy coordination");
        }
        /**
         * Initialize enhanced orchestrator with event bus and strategy registry
         */
        async initialize() {
          if (this.isInitialized) {
            Y3K?.debug?.warn("ColorOrchestrator", "Already initialized");
            return;
          }
          try {
            unifiedEventBus.subscribe(
              "colors:extracted",
              this.handleColorExtractionEvent.bind(this),
              "ColorOrchestrator"
            );
            this.updateDeviceCapabilities();
            this.loadUserPreferences();
            this.performanceAnalyzer.startMonitoring();
            await this.registerDefaultStrategies();
            this.isInitialized = true;
            Y3K?.debug?.log("ColorOrchestrator", "Enhanced color orchestrator initialized", {
              strategies: this.registry.getStatus().strategyCount,
              criteria: this.selectionCriteria,
              oklabEnabled: this.oklabCoordinationEnabled,
              deviceLevel: this.deviceDetector.recommendPerformanceQuality()
            });
          } catch (error) {
            Y3K?.debug?.error("ColorOrchestrator", "Enhanced initialization failed:", error);
            throw error;
          }
        }
        /**
         * Handle color extraction event from UnifiedEventBus
         * Phase 3: Updated to handle UnifiedEventBus events directly (no event.type wrapper)
         */
        async handleColorExtractionEvent(data) {
          const context = data;
          await this.handleColorExtraction(context);
        }
        /**
         * Enhanced color extraction processing with multi-strategy coordination
         * Phase 4: Added recursion prevention, queue overflow protection, and caching
         */
        async handleColorExtraction(context) {
          const now = Date.now();
          const contextKey = context.trackUri || "unknown";
          const lastProcessed = this.processedContexts.get(contextKey);
          if (lastProcessed && now - lastProcessed < this.CONTEXT_CACHE_TTL) {
            Y3K?.debug?.warn(
              "ColorOrchestrator",
              `Skipping recent context to prevent recursion: ${contextKey}`,
              {
                lastProcessed: new Date(lastProcessed).toISOString(),
                timeDiff: now - lastProcessed
              }
            );
            return;
          }
          const cacheKey = this.generateCacheKey(context);
          const cachedResult = this.getCachedResult(cacheKey);
          if (cachedResult) {
            this.orchestrationMetrics.cacheHits++;
            await this.applyColorResult(cachedResult);
            Y3K?.debug?.log("ColorOrchestrator", "Using cached color result", { cacheKey });
            return;
          }
          if (this.processingQueue.length >= this.MAX_QUEUE_SIZE) {
            Y3K?.debug?.warn(
              "ColorOrchestrator",
              `Queue overflow protection: dropping context ${contextKey}`,
              {
                queueSize: this.processingQueue.length,
                maxSize: this.MAX_QUEUE_SIZE
              }
            );
            this.processingQueue.shift();
          }
          this.cleanupProcessedContexts(now);
          this.processingQueue.push(context);
          if (!this.isProcessing) {
            await this.processQueue();
          }
        }
        /**
         * Process the color processing queue
         */
        async processQueue() {
          if (this.isProcessing || this.processingQueue.length === 0) return;
          this.isProcessing = true;
          try {
            while (this.processingQueue.length > 0) {
              const context = this.processingQueue.shift();
              await this.processColorContext(context);
            }
          } catch (error) {
            Y3K?.debug?.error("ColorOrchestrator", "Queue processing failed:", error);
          } finally {
            this.isProcessing = false;
            this.currentStrategy = null;
          }
        }
        /**
         * Clean up expired processed context cache entries
         * Phase 4: Prevents memory leaks from recursion prevention cache
         */
        cleanupProcessedContexts(now) {
          for (const [contextKey, timestamp] of this.processedContexts.entries()) {
            if (now - timestamp > this.CONTEXT_CACHE_TTL) {
              this.processedContexts.delete(contextKey);
            }
          }
        }
        /**
         * Enhanced single color context processing with multi-strategy coordination
         * Phase 4: Added multi-strategy processing, OKLAB coordination, and result merging
         */
        async processColorContext(context) {
          const startTime = performance.now();
          const contextKey = context.trackUri || "unknown";
          try {
            const selectedStrategies = this.strategySelector.selectStrategies(
              context,
              this.buildStrategySelectionCriteria(context)
            );
            if (selectedStrategies.length === 0) {
              const fallbackStrategy = this.selectStrategy(context);
              if (fallbackStrategy) {
                selectedStrategies.push(fallbackStrategy);
              } else {
                throw new Error("No suitable strategies selected for color processing");
              }
            }
            const strategyResults = await this.processWithStrategies(context, selectedStrategies);
            if (this.oklabCoordinationEnabled && strategyResults.filter((r) => r.success).length > 1) {
              await this.coordinateOKLABProcessing(strategyResults, context);
            }
            const finalResult = this.mergeStrategyResults(strategyResults, context);
            const cacheKey = this.generateCacheKey(context);
            this.cacheResult(cacheKey, finalResult);
            await this.applyColorResult(finalResult);
            this.processedContexts.set(contextKey, Date.now());
            const totalTime = performance.now() - startTime;
            this.updateOrchestrationMetrics(strategyResults, totalTime);
            this.lastProcessingTime = totalTime;
            this.totalProcessingTime += totalTime;
            this.processedCount++;
            Y3K?.debug?.log("ColorOrchestrator", "Enhanced color processing completed", {
              strategies: selectedStrategies.map((s) => s.getStrategyName()),
              processingTime: totalTime,
              trackUri: context.trackUri,
              oklabCoordination: this.oklabCoordinationEnabled,
              successfulStrategies: strategyResults.filter((r) => r.success).length
            });
          } catch (error) {
            const endTime = performance.now();
            this.lastProcessingTime = endTime - startTime;
            Y3K?.debug?.error("ColorOrchestrator", "Enhanced color processing failed:", {
              error,
              strategy: this.currentStrategy,
              trackUri: context.trackUri
            });
            await this.applyFallbackColors(context);
          }
        }
        /**
         * Select best strategy for given context
         */
        selectStrategy(context) {
          const contextualCriteria = { ...this.selectionCriteria };
          if (context.performanceHints) {
            if (context.performanceHints.preferLightweight) {
              contextualCriteria.performance = "high";
              contextualCriteria.quality = "basic";
            }
            if (context.performanceHints.enableAdvancedBlending) {
              contextualCriteria.quality = "premium";
            }
          }
          if (context.musicData) {
            if (context.musicData.energy && context.musicData.energy > 0.8) {
              contextualCriteria.quality = "premium";
            }
          }
          return this.registry.selectStrategy(contextualCriteria);
        }
        /**
         * Register default strategies (ColorHarmonyEngine will self-register)
         */
        async registerDefaultStrategies() {
          Y3K?.debug?.log(
            "ColorOrchestrator",
            "Default strategies registration completed"
          );
        }
        // ============================================================================
        // Enhanced Multi-Strategy Processing Methods
        // ============================================================================
        /**
         * Process colors with multiple strategies in parallel
         */
        async processWithStrategies(context, strategies) {
          const results = [];
          const strategyPromises = strategies.map(async (strategy) => {
            const strategyStartTime = performance.now();
            this.currentStrategy = strategy.getStrategyName();
            try {
              const result = await strategy.processColors(context);
              const processingTime = performance.now() - strategyStartTime;
              return {
                strategy,
                result,
                processingTime,
                success: true
              };
            } catch (error) {
              const processingTime = performance.now() - strategyStartTime;
              Y3K?.debug?.error("ColorOrchestrator", `Strategy ${strategy.getStrategyName()} failed:`, error);
              return {
                strategy,
                result: this.createErrorResult(context, strategy, error),
                processingTime,
                success: false,
                error: error instanceof Error ? error.message : "Unknown error"
              };
            }
          });
          const strategyResults = await Promise.all(strategyPromises);
          return strategyResults;
        }
        /**
         * Merge results from multiple strategies with intelligent conflict resolution
         */
        mergeStrategyResults(strategyResults, context) {
          const successfulResults = strategyResults.filter((r) => r.success);
          if (successfulResults.length === 0) {
            return this.createFallbackResult(context);
          }
          if (successfulResults.length === 1) {
            return successfulResults[0].result;
          }
          const mergeOptions = {
            priorityWeighting: true,
            conflictResolution: "merge",
            preserveMetadata: true,
            consciousnessBlending: true,
            oklabCoordination: this.oklabCoordinationEnabled
          };
          return this.performResultMerge(successfulResults, context, mergeOptions);
        }
        /**
         * Perform intelligent merging of multiple color results
         */
        performResultMerge(results, context, options) {
          const sortedResults = results.sort((a, b) => {
            const aPriority = this.strategySelector.getStrategyMetadata(a.strategy.getStrategyName())?.priority || 0;
            const bPriority = this.strategySelector.getStrategyMetadata(b.strategy.getStrategyName())?.priority || 0;
            return bPriority - aPriority;
          });
          const baseResult = sortedResults[0].result;
          const mergedResult = {
            processedColors: { ...baseResult.processedColors },
            accentHex: baseResult.accentHex,
            accentRgb: baseResult.accentRgb,
            metadata: {
              ...baseResult.metadata,
              strategy: "enhanced-orchestrator",
              mergedStrategies: sortedResults.map((r) => r.strategy.getStrategyName()),
              totalProcessingTime: sortedResults.reduce((sum, r) => sum + r.processingTime, 0)
            },
            context
          };
          for (let i = 1; i < sortedResults.length; i++) {
            const currentResult = sortedResults[i].result;
            Object.entries(currentResult.processedColors).forEach(([key, value]) => {
              if (options.conflictResolution === "override") {
                if (i === 1) mergedResult.processedColors[key] = value;
              } else if (options.conflictResolution === "merge") {
                const strategyName = currentResult.metadata.strategy;
                mergedResult.processedColors[`${strategyName}-${key}`] = value;
              }
            });
            if (options.preserveMetadata) {
              const strategyName = currentResult.metadata.strategy;
              mergedResult.metadata[`${strategyName}-metadata`] = currentResult.metadata;
            }
          }
          if (options.consciousnessBlending) {
            this.applyConsciousnessBlending(mergedResult, sortedResults);
          }
          if (options.oklabCoordination) {
            this.applyOKLABCoordination(mergedResult, sortedResults);
          }
          return mergedResult;
        }
        /**
         * Apply consciousness-aware blending to merged results
         */
        applyConsciousnessBlending(mergedResult, strategyResults) {
          let totalWeight = 0;
          let weightedR = 0, weightedG = 0, weightedB = 0;
          strategyResults.forEach((result) => {
            const strategyMetadata = this.strategySelector.getStrategyMetadata(result.strategy.getStrategyName());
            const weight = (strategyMetadata?.qualityScore || 5) / 10;
            const rgb = this.hexToRgb(result.result.accentHex);
            if (rgb) {
              weightedR += rgb.r * weight;
              weightedG += rgb.g * weight;
              weightedB += rgb.b * weight;
              totalWeight += weight;
            }
          });
          if (totalWeight > 0) {
            const avgR = Math.round(weightedR / totalWeight);
            const avgG = Math.round(weightedG / totalWeight);
            const avgB = Math.round(weightedB / totalWeight);
            mergedResult.accentHex = this.rgbToHex(avgR, avgG, avgB);
            mergedResult.accentRgb = `${avgR},${avgG},${avgB}`;
            mergedResult.metadata.consciousnessBlending = {
              strategyCount: strategyResults.length,
              totalWeight,
              blendedAccent: mergedResult.accentHex
            };
          }
        }
        /**
         * Coordinate OKLAB processing across strategies for perceptual uniformity
         */
        async coordinateOKLABProcessing(strategyResults, context) {
          const oklabStartTime = performance.now();
          try {
            const successfulResults = strategyResults.filter((r) => r.success);
            const allColors = {};
            successfulResults.forEach((result) => {
              Object.entries(result.result.processedColors).forEach(([key, value]) => {
                if (value && value.startsWith("#")) {
                  allColors[`${result.strategy.getStrategyName()}-${key}`] = value;
                }
              });
            });
            const preset = this.getOptimalOKLABPreset(context);
            const oklabResults = this.oklabProcessor.processColorPalette(allColors, preset);
            successfulResults.forEach((result) => {
              const strategyName = result.strategy.getStrategyName();
              result.oklabData = Object.values(oklabResults).filter(
                (oklab) => oklab.originalHex in allColors && Object.keys(allColors).find(
                  (key) => key.startsWith(strategyName) && allColors[key] === oklab.originalHex
                )
              );
            });
            const oklabProcessingTime = performance.now() - oklabStartTime;
            this.orchestrationMetrics.oklabCoordinations++;
            this.orchestrationMetrics.oklabProcessingTime += oklabProcessingTime;
            Y3K?.debug?.log("ColorOrchestrator", "OKLAB coordination completed", {
              strategiesCoordinated: successfulResults.length,
              colorsProcessed: Object.keys(allColors).length,
              preset: preset.name,
              processingTime: oklabProcessingTime
            });
          } catch (error) {
            Y3K?.debug?.error("ColorOrchestrator", "OKLAB coordination failed:", error);
          }
        }
        /**
         * Apply OKLAB coordination to merged results for perceptual consistency
         */
        applyOKLABCoordination(mergedResult, strategyResults) {
          try {
            const allOKLABData = [];
            strategyResults.forEach((result) => {
              if (result.oklabData) {
                allOKLABData.push(...result.oklabData);
              }
            });
            if (allOKLABData.length === 0) return;
            const oklabAccent = this.calculatePerceptuallyUniformAccent(allOKLABData);
            if (oklabAccent) {
              mergedResult.accentHex = oklabAccent.enhancedHex;
              mergedResult.accentRgb = `${oklabAccent.enhancedRgb.r},${oklabAccent.enhancedRgb.g},${oklabAccent.enhancedRgb.b}`;
              const oklabCSSVars = this.oklabProcessor.generateCSSVariables(oklabAccent, "sn-oklab-unified");
              Object.entries(oklabCSSVars).forEach(([key, value]) => {
                mergedResult.processedColors[key] = value;
              });
              mergedResult.metadata.oklabCoordination = {
                enabled: true,
                strategiesCoordinated: strategyResults.length,
                colorsProcessed: allOKLABData.length,
                perceptualAccent: oklabAccent.enhancedHex,
                lightness: oklabAccent.oklabEnhanced.L,
                chroma: oklabAccent.oklchEnhanced.C,
                hue: oklabAccent.oklchEnhanced.H
              };
            }
          } catch (error) {
            Y3K?.debug?.error("ColorOrchestrator", "OKLAB coordination application failed:", error);
          }
        }
        /**
         * Calculate perceptually uniform accent color from OKLAB data
         */
        calculatePerceptuallyUniformAccent(oklabData) {
          if (oklabData.length === 0) return null;
          if (oklabData.length === 1) return oklabData[0] || null;
          let totalWeight = 0;
          let weightedL = 0, weightedA = 0, weightedB = 0;
          oklabData.forEach((oklab) => {
            const chroma = Math.sqrt(oklab.oklabEnhanced.a ** 2 + oklab.oklabEnhanced.b ** 2);
            const weight = Math.max(0.1, chroma);
            weightedL += oklab.oklabEnhanced.L * weight;
            weightedA += oklab.oklabEnhanced.a * weight;
            weightedB += oklab.oklabEnhanced.b * weight;
            totalWeight += weight;
          });
          if (totalWeight === 0) return oklabData[0] || null;
          const avgOklab = {
            L: weightedL / totalWeight,
            a: weightedA / totalWeight,
            b: weightedB / totalWeight
          };
          const avgRgb = oklabToRgb(avgOklab.L, avgOklab.a, avgOklab.b);
          const avgHex = rgbToHex(avgRgb.r, avgRgb.g, avgRgb.b);
          const preset = OKLABColorProcessor.getPreset("STANDARD");
          return this.oklabProcessor.processColor(avgHex, preset);
        }
        /**
         * Get current processing status with enhanced metrics
         * Phase 4: Added recursion prevention status and orchestration metrics
         */
        getStatus() {
          return {
            isProcessing: this.isProcessing,
            ...this.currentStrategy ? { currentStrategy: this.currentStrategy } : {},
            queueSize: this.processingQueue.length,
            processedContextsCount: this.processedContexts.size,
            maxQueueSize: this.MAX_QUEUE_SIZE,
            contextCacheTTL: this.CONTEXT_CACHE_TTL,
            orchestrationMetrics: { ...this.orchestrationMetrics },
            oklabCoordinationEnabled: this.oklabCoordinationEnabled
          };
        }
        /**
         * Set strategy selection criteria
         */
        setSelectionCriteria(criteria) {
          this.selectionCriteria = { ...this.selectionCriteria, ...criteria };
          Y3K?.debug?.log(
            "ColorOrchestrator",
            "Selection criteria updated",
            criteria
          );
        }
        /**
         * Get processing performance metrics
         */
        getPerformanceMetrics() {
          return {
            processedCount: this.processedCount,
            averageProcessingTime: this.processedCount > 0 ? this.totalProcessingTime / this.processedCount : 0,
            lastProcessingTime: this.lastProcessingTime,
            totalProcessingTime: this.totalProcessingTime
          };
        }
        /**
         * Register a new color processing strategy
         */
        registerStrategy(strategy) {
          this.registry.register(strategy);
        }
        /**
         * Get strategy registry for advanced operations
         */
        getRegistry() {
          return this.registry;
        }
        // ============================================================================
        // Utility Methods
        // ============================================================================
        /**
         * Estimate available memory in MB
         */
        estimateMemoryMB() {
          const memoryInfo = performance.memory;
          if (memoryInfo && memoryInfo.usedJSHeapSize && memoryInfo.jsHeapSizeLimit) {
            return (memoryInfo.jsHeapSizeLimit - memoryInfo.usedJSHeapSize) / (1024 * 1024);
          }
          return this.detectMobile() ? 256 : 1024;
        }
        /**
         * Detect if running on mobile device
         */
        detectMobile() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
        }
        // ============================================================================
        // Enhanced Utility Methods
        // ============================================================================
        /**
         * Build strategy selection criteria based on current context and settings
         */
        buildStrategySelectionCriteria(context) {
          return {
            ...this.selectionCriteria,
            settingsContext: {
              dynamicAccentEnabled: this.settingsManager.get("sn-dynamic-accent-enabled") ?? true,
              gradientIntensity: this.settingsManager.get("sn-gradient-intensity") ?? "balanced",
              webglEnabled: this.settingsManager.get("sn-webgl-enabled") ?? true,
              visualGuideMode: this.settingsManager.get("sn-visual-guide-mode") ?? "cosmic",
              depthLayersEnabled: this.settingsManager.get("sn-depth-enabled") ?? true,
              consciousnessLevel: this.settingsManager.get("sn-consciousness-level") ?? 0.8,
              breathingAnimationEnabled: this.settingsManager.get("sn-breathing-enabled") ?? true
            },
            musicContext: context.musicData,
            deviceContext: {
              supportsWebGL: this.deviceDetector.hasWebGLSupport ? this.deviceDetector.hasWebGLSupport() : false,
              performanceLevel: this.deviceDetector.recommendPerformanceQuality(),
              memoryCapacity: window.navigator.deviceMemory ? window.navigator.deviceMemory * 1024 : 4096,
              isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
            }
          };
        }
        /**
         * Get optimal OKLAB preset based on context
         */
        getOptimalOKLABPreset(context) {
          const intensity = this.selectionCriteria.userPreferences?.intensity || 0.8;
          const musicEnergy = context.musicData?.energy || 0.5;
          const combinedIntensity = (intensity + musicEnergy) / 2;
          if (combinedIntensity >= 0.8) {
            return OKLABColorProcessor.getPreset("COSMIC");
          } else if (combinedIntensity >= 0.6) {
            return OKLABColorProcessor.getPreset("VIBRANT");
          } else if (combinedIntensity >= 0.4) {
            return OKLABColorProcessor.getPreset("STANDARD");
          } else {
            return OKLABColorProcessor.getPreset("SUBTLE");
          }
        }
        /**
         * 🔧 PHASE 2: Emit color result instead of applying CSS directly
         * ColorStateManager will handle all CSS applications through batching
         */
        async applyColorResult(result) {
          try {
            unifiedEventBus.emit("colors:harmonized", {
              processedColors: result.processedColors,
              accentHex: result.accentHex || "#cba6f7",
              accentRgb: result.accentRgb || "203,166,247",
              strategies: [result.metadata.strategy],
              processingTime: result.metadata.processingTime,
              trackUri: result.metadata.trackUri,
              coordinationMetrics: {
                detectedGenre: result.metadata.genre || "unknown",
                emotionalState: result.metadata.emotion || "neutral",
                oklabPreset: result.metadata.oklabPreset || "default",
                coordinationStrategy: result.metadata.strategy,
                musicInfluenceStrength: result.metadata.intensity || 0.5
              },
              processingMode: "orchestrated"
            });
            const event = new CustomEvent("colors/harmonized", {
              detail: {
                type: "colors/harmonized",
                payload: {
                  ...result,
                  cssVariables: result.processedColors
                }
              }
            });
            document.dispatchEvent(event);
          } catch (error) {
            Y3K?.debug?.error("ColorOrchestrator", "Failed to apply color result:", error);
          }
        }
        /**
         * Cache management methods
         */
        generateCacheKey(context) {
          return `${context.trackUri}-${context.timestamp}-${JSON.stringify(context.musicData || {})}`;
        }
        getCachedResult(cacheKey) {
          return this.resultCache.get(cacheKey) || null;
        }
        cacheResult(cacheKey, result) {
          if (this.resultCache.size >= this.cacheMaxSize) {
            const firstKey = this.resultCache.keys().next().value;
            if (firstKey) this.resultCache.delete(firstKey);
          }
          this.resultCache.set(cacheKey, result);
          setTimeout(() => {
            this.resultCache.delete(cacheKey);
          }, this.cacheTimeoutMs);
        }
        /**
         * Device capability and preference management
         */
        updateDeviceCapabilities() {
          this.selectionCriteria.deviceCapabilities = {
            hasWebGL: this.deviceDetector.hasWebGLSupport ? this.deviceDetector.hasWebGLSupport() : false,
            memoryMB: window.navigator.deviceMemory ? window.navigator.deviceMemory * 1024 : 4096,
            isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
          };
        }
        loadUserPreferences() {
          try {
            this.selectionCriteria.userPreferences = {
              harmonicMode: this.settingsManager.get("sn-visual-guide-mode") ?? "cosmic",
              intensity: this.settingsManager.get("sn-consciousness-level") ?? 0.8,
              enableAdvancedBlending: this.settingsManager.get("sn-advanced-blending") ?? true
            };
          } catch (error) {
            Y3K?.debug?.warn("ColorOrchestrator", "Failed to load user preferences:", error);
          }
        }
        /**
         * Error handling and fallback methods
         */
        createErrorResult(context, strategy, error) {
          return {
            processedColors: context.rawColors,
            accentHex: "#cba6f7",
            // Fallback mauve
            accentRgb: "203,166,247",
            metadata: {
              strategy: strategy.getStrategyName(),
              processingTime: 0,
              error: error instanceof Error ? error.message : "Unknown error"
            },
            context
          };
        }
        createFallbackResult(context) {
          return {
            processedColors: context.rawColors,
            accentHex: "#cba6f7",
            // Fallback mauve
            accentRgb: "203,166,247",
            metadata: {
              strategy: "fallback",
              processingTime: 0,
              error: "All strategies failed"
            },
            context
          };
        }
        async applyFallbackColors(context) {
          const fallbackResult = this.createFallbackResult(context);
          await this.applyColorResult(fallbackResult);
        }
        /**
         * Update orchestration metrics
         */
        updateOrchestrationMetrics(results, totalTime) {
          this.orchestrationMetrics.totalProcessingTime += totalTime;
          this.orchestrationMetrics.strategiesProcessed += results.length;
          this.orchestrationMetrics.strategiesSucceeded += results.filter((r) => r.success).length;
          this.orchestrationMetrics.strategiesFailed += results.filter((r) => !r.success).length;
          const successfulTimes = results.filter((r) => r.success).map((r) => r.processingTime);
          if (successfulTimes.length > 0) {
            this.orchestrationMetrics.averageStrategyTime = successfulTimes.reduce((a, b) => a + b, 0) / successfulTimes.length;
          }
        }
        /**
         * Color utility methods
         */
        hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
          } : null;
        }
        rgbToHex(r, g2, b) {
          return "#" + ((1 << 24) + (r << 16) + (g2 << 8) + b).toString(16).slice(1);
        }
        // ============================================================================
        // Enhanced Public Interface Methods
        // ============================================================================
        /**
         * Get orchestration metrics for monitoring
         */
        getOrchestrationMetrics() {
          return { ...this.orchestrationMetrics };
        }
        /**
         * Clear result cache
         */
        clearCache() {
          this.resultCache.clear();
          Y3K?.debug?.log("ColorOrchestrator", "Result cache cleared");
        }
        /**
         * Enable or disable OKLAB coordination
         */
        setOKLABCoordinationEnabled(enabled) {
          this.oklabCoordinationEnabled = enabled;
          Y3K?.debug?.log("ColorOrchestrator", `OKLAB coordination ${enabled ? "enabled" : "disabled"}`);
        }
        /**
         * Get OKLAB coordination status
         */
        isOKLABCoordinationEnabled() {
          return this.oklabCoordinationEnabled;
        }
        /**
         * Get OKLAB processor for external use
         */
        getOKLABProcessor() {
          return this.oklabProcessor;
        }
        /**
         * Cleanup resources
         */
        async destroy() {
          unifiedEventBus.unsubscribeAll("ColorOrchestrator");
          this.clearCache();
          this.processingQueue = [];
          this.isProcessing = false;
          this.isInitialized = false;
          this.processedContexts.clear();
          this.strategySelector.destroy();
          Y3K?.debug?.log("ColorOrchestrator", "Enhanced color orchestrator destroyed");
        }
      };
      __name(_ColorOrchestrator, "ColorOrchestrator");
      ColorOrchestrator = _ColorOrchestrator;
      globalColorOrchestrator = new ColorOrchestrator();
    }
  });

  // src-js/utils/core/PaletteExtensionManager.ts
  var GENRE_PALETTE_HINTS, _PaletteExtensionManager, PaletteExtensionManager;
  var init_PaletteExtensionManager = __esm({
    "src-js/utils/core/PaletteExtensionManager.ts"() {
      "use strict";
      GENRE_PALETTE_HINTS = {
        jazz: { temperatureShift: 15, saturationBoost: 1.1, warmth: 0.8 },
        electronic: { temperatureShift: -10, saturationBoost: 1.2, warmth: 0.2 },
        classical: { temperatureShift: 5, saturationBoost: 0.9, warmth: 0.6 },
        rock: { temperatureShift: 0, saturationBoost: 1.15, warmth: 0.5 },
        ambient: { temperatureShift: -5, saturationBoost: 0.8, warmth: 0.3 },
        hiphop: { temperatureShift: 8, saturationBoost: 1.25, warmth: 0.7 },
        pop: { temperatureShift: 0, saturationBoost: 1, warmth: 0.5 },
        metal: { temperatureShift: -15, saturationBoost: 1.3, warmth: 0.1 },
        indie: { temperatureShift: 10, saturationBoost: 0.95, warmth: 0.6 },
        default: { temperatureShift: 0, saturationBoost: 1, warmth: 0.5 }
      };
      _PaletteExtensionManager = class _PaletteExtensionManager {
        constructor(config, utils) {
          this.paletteCache = {};
          this.cacheTTL = 3e5;
          // 5 minutes
          this.maxCacheSize = 50;
          this.config = config;
          this.utils = utils;
        }
        // TODO: Phase 3 - Load custom palette from JSON with validation
        async loadCustomPalette(paletteId, source) {
          const cached = this.paletteCache[paletteId];
          if (cached && Date.now() - cached.timestamp < this.cacheTTL && cached.isValid) {
            if (this.config.enableDebug) {
              console.log(
                `[PaletteExtensionManager] Cache hit for palette: ${paletteId}`
              );
            }
            return cached.palette;
          }
          try {
            const fallbackPalette = this.generateFallbackPalette(paletteId);
            if (this.validatePalette(fallbackPalette)) {
              this.cachePalette(paletteId, fallbackPalette, true);
              return fallbackPalette;
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[PaletteExtensionManager] Failed to load palette ${paletteId}:`,
                error
              );
            }
          }
          return null;
        }
        // TODO: Phase 3 - Generate fallback palette for unknown themes
        generateFallbackPalette(themeName) {
          const root = this.utils.getRootStyle();
          const computedStyle = getComputedStyle(root);
          const baseColor = computedStyle.getPropertyValue("--spice-main").trim() || computedStyle.getPropertyValue("--spice-base").trim() || "#1e1e2e";
          const accentColor = (
            // Prefer Year 3000 dynamic accent if it's already available, else fall back to spice button, then to dynamic accent fallback.
            computedStyle.getPropertyValue("--sn-gradient-accent").trim() || computedStyle.getPropertyValue("--spice-button").trim() || computedStyle.getPropertyValue("--sn-dynamic-accent").trim() || computedStyle.getPropertyValue("--spice-accent").trim() || "#8caaee"
          );
          const baseRgb = this.utils.hexToRgb(
            baseColor.startsWith("#") ? baseColor : `#${baseColor}`
          );
          const accentRgb = this.utils.hexToRgb(
            accentColor.startsWith("#") ? accentColor : `#${accentColor}`
          );
          if (!baseRgb || !accentRgb) {
            const dynamicAccent = computedStyle.getPropertyValue("--sn-dynamic-accent").trim();
            const dynamicBase = computedStyle.getPropertyValue("--spice-base").trim();
            return {
              name: themeName,
              version: "1.0.0",
              accents: {
                mauve: dynamicAccent || "#ca9ee6",
                pink: "#f4b8e4",
                blue: dynamicAccent || "#8caaee",
                sapphire: "#85c1dc",
                sky: "#99d1db",
                teal: "#81c8be",
                green: "#a6d189",
                yellow: "#e5c890",
                peach: "#ef9f76",
                red: "#e78284",
                lavender: "#babbf1"
              },
              neutrals: {
                base: dynamicBase || "#1e1e2e",
                surface0: "#313244",
                surface1: "#45475a",
                surface2: "#585b70",
                overlay0: "#6c7086",
                overlay1: "#7f849c",
                overlay2: "#9399b2",
                text: "#cdd6f4"
              },
              metadata: {
                author: "PaletteExtensionManager",
                description: `Generated fallback for ${themeName}`,
                temperature: "neutral"
              }
            };
          }
          const baseHsl = this.utils.rgbToHsl(baseRgb.r, baseRgb.g, baseRgb.b);
          const accentHsl = this.utils.rgbToHsl(
            accentRgb.r,
            accentRgb.g,
            accentRgb.b
          );
          return {
            name: themeName,
            version: "1.0.0",
            accents: this.generateAccentVariations(accentHsl),
            neutrals: this.generateNeutralVariations(baseHsl),
            metadata: {
              author: "PaletteExtensionManager",
              description: `Generated palette for ${themeName}`,
              temperature: this.detectTemperature(baseHsl, accentHsl)
            }
          };
        }
        // TODO: Phase 3 - Apply genre-aware modifications to palette
        applyGenreAwareModifications(palette, genre) {
          const genreHints = GENRE_PALETTE_HINTS[genre] || GENRE_PALETTE_HINTS.default;
          if (this.config.enableDebug) {
            console.log(
              `[PaletteExtensionManager] Applying ${genre} hints to palette:`,
              genreHints
            );
          }
          const modifiedPalette = {
            ...palette,
            accents: {},
            neutrals: {},
            metadata: {
              ...palette.metadata,
              genre: [...palette.metadata?.genre || [], genre]
            }
          };
          for (const [key, color2] of Object.entries(palette.accents)) {
            modifiedPalette.accents[key] = this.applyGenreColorModification(
              color2,
              genreHints.temperatureShift,
              genreHints.saturationBoost
            );
          }
          for (const [key, color2] of Object.entries(palette.neutrals)) {
            modifiedPalette.neutrals[key] = this.applyGenreColorModification(
              color2,
              genreHints.temperatureShift * 0.3,
              // Less intense for neutrals
              genreHints.saturationBoost * 0.7
            );
          }
          return modifiedPalette;
        }
        // TODO: Phase 3 - Validate palette structure and required properties
        validatePalette(palette) {
          if (!palette || typeof palette !== "object") return false;
          if (!palette.name || typeof palette.name !== "string") return false;
          if (!palette.version || typeof palette.version !== "string") return false;
          if (!palette.accents || typeof palette.accents !== "object") return false;
          if (!palette.neutrals || typeof palette.neutrals !== "object") return false;
          const allColors = [
            ...Object.values(palette.accents),
            ...Object.values(palette.neutrals)
          ];
          for (const color2 of allColors) {
            if (typeof color2 !== "string" || !this.isValidHexColor(color2)) {
              return false;
            }
          }
          return true;
        }
        // TODO: Phase 3 - Cache management
        cachePalette(paletteId, palette, isValid) {
          if (Object.keys(this.paletteCache).length >= this.maxCacheSize) {
            const oldestEntry = Object.entries(this.paletteCache).sort(
              ([, aVal], [, bVal]) => aVal.timestamp - bVal.timestamp
            )[0];
            const oldestKey = oldestEntry?.[0];
            if (oldestKey && this.paletteCache[oldestKey]) {
              delete this.paletteCache[oldestKey];
            }
          }
          this.paletteCache[paletteId] = {
            palette,
            timestamp: Date.now(),
            isValid
          };
        }
        // TODO: Phase 3 - Generate accent color variations
        generateAccentVariations(baseHsl) {
          const variations = {};
          const hueShifts = [0, 30, 60, 120, 180, 210, 240, 300, 330, 45, 90];
          const names = [
            "primary",
            "secondary",
            "tertiary",
            "complement",
            "opposite",
            "warm1",
            "cool1",
            "accent1",
            "accent2",
            "highlight",
            "emphasis"
          ];
          hueShifts.forEach((shift, index) => {
            const name = names[index] || `variant${index}`;
            const adjustedHue = (baseHsl.h + shift) % 360;
            const rgb = this.utils.hslToRgb(adjustedHue, baseHsl.s, baseHsl.l);
            if (rgb) {
              variations[name] = this.utils.rgbToHex(rgb.r, rgb.g, rgb.b);
            }
          });
          return variations;
        }
        // TODO: Phase 3 - Generate neutral color variations
        generateNeutralVariations(baseHsl) {
          const neutrals = {};
          const lightnessLevels = [
            { name: "base", l: baseHsl.l },
            { name: "surface0", l: Math.min(95, baseHsl.l + 10) },
            { name: "surface1", l: Math.min(90, baseHsl.l + 20) },
            { name: "surface2", l: Math.min(85, baseHsl.l + 30) },
            { name: "overlay0", l: Math.min(80, baseHsl.l + 40) },
            { name: "overlay1", l: Math.min(75, baseHsl.l + 50) },
            { name: "text", l: Math.min(95, baseHsl.l + 60) }
          ];
          lightnessLevels.forEach((level) => {
            const rgb = this.utils.hslToRgb(
              baseHsl.h,
              Math.max(0, baseHsl.s - 20),
              level.l
            );
            if (rgb) {
              neutrals[level.name] = this.utils.rgbToHex(rgb.r, rgb.g, rgb.b);
            }
          });
          return neutrals;
        }
        // TODO: Phase 3 - Detect color temperature
        detectTemperature(baseHsl, accentHsl) {
          const avgHue = (baseHsl.h + accentHsl.h) / 2;
          if (avgHue >= 0 && avgHue <= 60 || avgHue >= 300 && avgHue <= 360) {
            return "warm";
          } else if (avgHue >= 120 && avgHue <= 240) {
            return "cool";
          } else {
            return "neutral";
          }
        }
        // TODO: Phase 3 - Apply genre-specific color modifications
        applyGenreColorModification(hexColor, temperatureShift, saturationBoost) {
          const rgb = this.utils.hexToRgb(hexColor);
          if (!rgb) return hexColor;
          const hsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
          const adjustedHue = (hsl.h + temperatureShift + 360) % 360;
          const adjustedSaturation = Math.max(
            0,
            Math.min(100, hsl.s * saturationBoost)
          );
          const modifiedRgb = this.utils.hslToRgb(
            adjustedHue,
            adjustedSaturation,
            hsl.l
          );
          if (modifiedRgb) {
            return this.utils.rgbToHex(modifiedRgb.r, modifiedRgb.g, modifiedRgb.b);
          }
          return hexColor;
        }
        // TODO: Phase 3 - Validate hex color format
        isValidHexColor(color2) {
          return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color2);
        }
        // TODO: Phase 3 - Public API for getting genre hints
        getGenreHints(genre) {
          return GENRE_PALETTE_HINTS[genre] || GENRE_PALETTE_HINTS.default;
        }
        // TODO: Phase 3 - Clear cache
        clearCache() {
          this.paletteCache = {};
          if (this.config.enableDebug) {
            console.log("[PaletteExtensionManager] Palette cache cleared");
          }
        }
      };
      __name(_PaletteExtensionManager, "PaletteExtensionManager");
      PaletteExtensionManager = _PaletteExtensionManager;
    }
  });

  // src-js/utils/spicetify/SemanticColorManager.ts
  var _SemanticColorManager, SemanticColorManager;
  var init_SemanticColorManager = __esm({
    "src-js/utils/spicetify/SemanticColorManager.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_Year3000Utilities();
      _SemanticColorManager = class _SemanticColorManager {
        constructor(config = {}) {
          this.cssConsciousnessController = null;
          this.colorCache = /* @__PURE__ */ new Map();
          this.lastCacheUpdate = 0;
          // IManagedSystem interface
          this.initialized = false;
          // Event tracking for proper system integration
          this.eventSubscriptionIds = [];
          this.lastColorUpdate = 0;
          this.colorUpdateCount = 0;
          this.config = {
            enableDebug: false,
            fallbackToSpiceColors: true,
            cacheDuration: 5e3,
            // 5 seconds
            ...config
          };
        }
        async initialize(cssConsciousnessController) {
          if (this.initialized) {
            console.warn("[SemanticColorManager] Already initialized, skipping");
            return;
          }
          try {
            this.cssConsciousnessController = cssConsciousnessController || null;
            this.setupEventSubscriptions();
            this.initialized = true;
            this.lastColorUpdate = Date.now();
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] Initialized as IManagedSystem with", {
                mappings: _SemanticColorManager.SEMANTIC_MAPPINGS.length,
                batcherAvailable: !!this.cssConsciousnessController,
                spicetifyAvailable: this.isSpicetifyAvailable(),
                eventSubscriptions: this.eventSubscriptionIds.length
              });
            }
            unifiedEventBus.emitSync("system:initialized", {
              systemName: "SemanticColorManager",
              timestamp: Date.now(),
              metadata: {
                mappings: _SemanticColorManager.SEMANTIC_MAPPINGS.length,
                spicetifyAvailable: this.isSpicetifyAvailable()
              }
            });
          } catch (error) {
            console.error("[SemanticColorManager] Initialization failed:", error);
            unifiedEventBus.emitSync("system:error", {
              systemName: "SemanticColorManager",
              error: error instanceof Error ? error.message : "Initialization failed",
              severity: "critical",
              timestamp: Date.now()
            });
            throw error;
          }
        }
        async updateSemanticColors() {
          if (!this.initialized) {
            console.warn("[SemanticColorManager] Not initialized, cannot update colors");
            return;
          }
          const now = Date.now();
          if (now - this.lastCacheUpdate < (this.config.cacheDuration || 5e3)) {
            return;
          }
          console.log("\u{1F3A8} [SemanticColorManager] Starting semantic color update...");
          try {
            const colorUpdateLog = {};
            for (const mapping of _SemanticColorManager.SEMANTIC_MAPPINGS) {
              const color2 = await this.getSemanticColor(mapping.semanticColor);
              colorUpdateLog[mapping.cssVariable] = {
                semanticColor: mapping.semanticColor,
                retrievedColor: color2,
                fallbackColor: mapping.fallbackColor,
                description: mapping.description
              };
              this.applyColorToCSS(mapping.cssVariable, color2);
              const rgbColor = hexToRgb(color2);
              if (rgbColor) {
                const rgbVariable = mapping.cssVariable.replace("--spice-", "--spice-rgb-");
                this.applyColorToCSS(rgbVariable, `${rgbColor.r},${rgbColor.g},${rgbColor.b}`);
                colorUpdateLog[rgbVariable] = `${rgbColor.r},${rgbColor.g},${rgbColor.b}`;
              }
            }
            console.log("\u{1F3A8} [SemanticColorManager] Color update complete:", colorUpdateLog);
            this.lastCacheUpdate = now;
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] Updated all semantic colors");
            }
          } catch (error) {
            console.error("[SemanticColorManager] Failed to update semantic colors:", error);
          }
        }
        async getSemanticColor(semanticColor) {
          const cached = this.colorCache.get(semanticColor);
          if (cached && Date.now() - this.lastCacheUpdate < (this.config.cacheDuration || 5e3)) {
            return cached;
          }
          let color2;
          try {
            if (this.isSpicetifyAvailable() && Spicetify.Platform?.getSemanticColors) {
              const semanticColors = await Spicetify.Platform.getSemanticColors();
              color2 = semanticColors[semanticColor];
              console.log(`\u{1F3A8} [SemanticColorManager] Spicetify returned for ${semanticColor}:`, {
                rawValue: color2,
                type: typeof color2,
                isWhite: color2 === "#ffffff" || color2 === "#fff" || color2 === "white",
                isInvalid: !color2 || color2 === "undefined" || color2 === "null"
              });
            } else {
              console.warn(`\u{1F3A8} [SemanticColorManager] Spicetify not available, using fallback for ${semanticColor}`);
              color2 = this.getFallbackColor(semanticColor);
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(`[SemanticColorManager] Failed to get semantic color ${semanticColor}:`, error);
            }
            color2 = this.getFallbackColor(semanticColor);
          }
          color2 = this.validateColor(color2, semanticColor);
          this.colorCache.set(semanticColor, color2);
          return color2;
        }
        /**
         * Validate color to prevent white (#ffffff) or invalid colors from being applied
         */
        validateColor(color2, semanticColor) {
          const normalizedColor = color2?.toLowerCase().trim();
          const invalidColors = [
            "#ffffff",
            "#fff",
            "white",
            "#000000",
            "#000",
            "black",
            "",
            "undefined",
            "null",
            "transparent"
          ];
          if (!normalizedColor || invalidColors.includes(normalizedColor)) {
            const fallbackColor = this.getFallbackColor(semanticColor);
            if (this.config.enableDebug) {
              console.warn(`\u{1F527} [SemanticColorManager] Invalid color "${color2}" for ${semanticColor}, using fallback: ${fallbackColor}`);
            }
            return fallbackColor;
          }
          if (!normalizedColor.match(/^#[0-9a-f]{6}$/i) && !normalizedColor.match(/^#[0-9a-f]{3}$/i)) {
            const fallbackColor = this.getFallbackColor(semanticColor);
            if (this.config.enableDebug) {
              console.warn(`\u{1F527} [SemanticColorManager] Malformed color "${color2}" for ${semanticColor}, using fallback: ${fallbackColor}`);
            }
            return fallbackColor;
          }
          return color2;
        }
        getFallbackColor(semanticColor) {
          const mapping = _SemanticColorManager.SEMANTIC_MAPPINGS.find((m) => m.semanticColor === semanticColor);
          if (mapping) {
            return mapping.fallbackColor;
          }
          if (semanticColor.startsWith("text")) {
            return "#cad3f5";
          } else if (semanticColor.startsWith("background")) {
            return "#24273a";
          } else if (semanticColor.startsWith("essential")) {
            return "#c6a0f6";
          } else if (semanticColor.startsWith("decorative")) {
            return "#939ab7";
          }
          return "#cad3f5";
        }
        applyColorToCSS(cssVariable, color2) {
          if (this.cssConsciousnessController) {
            this.cssConsciousnessController.queueCSSVariableUpdate(cssVariable, color2);
          } else {
            document.documentElement.style.setProperty(cssVariable, color2);
          }
        }
        isSpicetifyAvailable() {
          return typeof Spicetify !== "undefined" && Spicetify.Platform && typeof Spicetify.Platform.getSemanticColors === "function";
        }
        flushUpdates() {
          if (this.cssConsciousnessController) {
            this.cssConsciousnessController.flushCSSVariableBatch();
          }
        }
        clearCache() {
          this.colorCache.clear();
          this.lastCacheUpdate = 0;
        }
        /**
         * Update Spicetify variables directly with OKLAB-processed album colors
         * This bypasses CSS fallback chains and prevents Spotify overrides
         * 
         * Enhanced for comprehensive override protection across all visual systems
         */
        updateWithAlbumColors(oklabColors) {
          if (!this.initialized) {
            console.warn("[SemanticColorManager] Not initialized, cannot update with album colors");
            return;
          }
          try {
            const primaryColor = oklabColors["OKLAB_PRIMARY"] || oklabColors["VIBRANT"] || oklabColors["PRIMARY"];
            const accentColor = oklabColors["OKLAB_ACCENT"] || oklabColors["LIGHT_VIBRANT"] || oklabColors["SECONDARY"];
            const shadowColor = oklabColors["OKLAB_SHADOW"] || oklabColors["DARK_VIBRANT"] || oklabColors["DARK"];
            const highlightColor = oklabColors["OKLAB_HIGHLIGHT"] || oklabColors["VIBRANT_NON_ALARMING"] || oklabColors["LIGHT"];
            if (!primaryColor) {
              console.warn("[SemanticColorManager] No primary color found in OKLAB result, skipping update");
              return;
            }
            const colorDistribution = this.generateIntelligentColorDistribution(
              primaryColor,
              accentColor,
              shadowColor,
              highlightColor
            );
            const rgbDistribution = this.convertColorsToRgb(colorDistribution);
            const coreSpicetifyUpdates = {
              "--spice-accent": colorDistribution.primary,
              "--spice-rgb-accent": rgbDistribution.primary,
              "--spice-surface1": colorDistribution.surface1,
              "--spice-rgb-surface1": rgbDistribution.surface1,
              "--spice-button-active": colorDistribution.primary,
              "--spice-rgb-button-active": rgbDistribution.primary,
              "--spice-highlight": colorDistribution.highlight,
              "--spice-rgb-highlight": rgbDistribution.highlight,
              "--spice-press": colorDistribution.shadow,
              "--spice-rgb-press": rgbDistribution.shadow
            };
            const criticalSpicetifyUpdates = {
              "--spice-surface0": colorDistribution.surface0,
              "--spice-rgb-surface0": rgbDistribution.surface0,
              "--spice-surface2": colorDistribution.surface2,
              "--spice-rgb-surface2": rgbDistribution.surface2,
              "--spice-base": colorDistribution.base,
              "--spice-rgb-base": rgbDistribution.base
            };
            const coreLayoutSpicetifyUpdates = {
              "--spice-main": colorDistribution.base,
              "--spice-rgb-main": rgbDistribution.base,
              "--spice-main-elevated": colorDistribution.surface0,
              "--spice-rgb-main-elevated": rgbDistribution.surface0,
              "--spice-sidebar": colorDistribution.surface1,
              "--spice-rgb-sidebar": rgbDistribution.surface1,
              "--spice-text": this.generateTextColor(colorDistribution.base),
              "--spice-rgb-text": this.hexToRgb(this.generateTextColor(colorDistribution.base)),
              "--spice-subtext": this.generateSubtextColor(colorDistribution.base),
              "--spice-rgb-subtext": this.hexToRgb(this.generateSubtextColor(colorDistribution.base)),
              "--spice-highlight-elevated": colorDistribution.surface2,
              "--spice-rgb-highlight-elevated": rgbDistribution.surface2,
              // Missing Catppuccin overlay system (CRITICAL for background hierarchy)
              "--spice-overlay0": this.generateOverlayColor(colorDistribution.base, 0.04),
              "--spice-rgb-overlay0": this.hexToRgb(this.generateOverlayColor(colorDistribution.base, 0.04)),
              "--spice-overlay1": this.generateOverlayColor(colorDistribution.base, 0.08),
              "--spice-rgb-overlay1": this.hexToRgb(this.generateOverlayColor(colorDistribution.base, 0.08)),
              "--spice-overlay2": this.generateOverlayColor(colorDistribution.base, 0.12),
              "--spice-rgb-overlay2": this.hexToRgb(this.generateOverlayColor(colorDistribution.base, 0.12)),
              "--spice-crust": this.generateCrustColor(colorDistribution.base),
              "--spice-rgb-crust": this.hexToRgb(this.generateCrustColor(colorDistribution.base)),
              "--spice-mantle": this.generateMantleColor(colorDistribution.base),
              "--spice-rgb-mantle": this.hexToRgb(this.generateMantleColor(colorDistribution.base))
            };
            const neuralSpicetifyUpdates = {
              "--spice-blue": colorDistribution.neuralPrimary,
              "--spice-rgb-blue": rgbDistribution.neuralPrimary,
              "--spice-mauve": colorDistribution.neuralSecondary,
              "--spice-rgb-mauve": rgbDistribution.neuralSecondary,
              "--spice-teal": colorDistribution.neuralTertiary,
              "--spice-rgb-teal": rgbDistribution.neuralTertiary,
              // ZONE SYSTEM: Context-aware color variables for different UI zones
              "--spice-flamingo": this.generateZoneColor(colorDistribution.primary, "flamingo"),
              // Zone home secondary
              "--spice-rgb-flamingo": this.hexToRgb(this.generateZoneColor(colorDistribution.primary, "flamingo")),
              "--spice-lavender": this.generateZoneColor(colorDistribution.highlight, "lavender"),
              // Zone playlist/search primary
              "--spice-rgb-lavender": this.hexToRgb(this.generateZoneColor(colorDistribution.highlight, "lavender")),
              "--spice-peach": this.generateZoneColor(colorDistribution.surface2, "peach"),
              // Zone artist primary
              "--spice-rgb-peach": this.hexToRgb(this.generateZoneColor(colorDistribution.surface2, "peach")),
              "--spice-rosewater": this.generateZoneColor(colorDistribution.surface1, "rosewater"),
              // Zone artist/home secondary
              "--spice-rgb-rosewater": this.hexToRgb(this.generateZoneColor(colorDistribution.surface1, "rosewater")),
              "--spice-sapphire": this.generateZoneColor(colorDistribution.neuralPrimary, "sapphire"),
              // Zone search secondary
              "--spice-rgb-sapphire": this.hexToRgb(this.generateZoneColor(colorDistribution.neuralPrimary, "sapphire"))
            };
            const paletteSpicetifyUpdates = {
              "--spice-pink": this.generatePaletteColor(colorDistribution.primary, "pink"),
              "--spice-rgb-pink": this.hexToRgb(this.generatePaletteColor(colorDistribution.primary, "pink")),
              "--spice-sky": this.generatePaletteColor(colorDistribution.neuralPrimary, "sky"),
              "--spice-rgb-sky": this.hexToRgb(this.generatePaletteColor(colorDistribution.neuralPrimary, "sky")),
              "--spice-red": this.generatePaletteColor(colorDistribution.highlight, "red"),
              // Used for errors
              "--spice-rgb-red": this.hexToRgb(this.generatePaletteColor(colorDistribution.highlight, "red")),
              "--spice-maroon": this.generatePaletteColor(colorDistribution.shadow, "maroon"),
              "--spice-rgb-maroon": this.hexToRgb(this.generatePaletteColor(colorDistribution.shadow, "maroon")),
              "--spice-yellow": this.generatePaletteColor(colorDistribution.surface2, "yellow"),
              // Used for warnings
              "--spice-rgb-yellow": this.hexToRgb(this.generatePaletteColor(colorDistribution.surface2, "yellow")),
              "--spice-green": this.generatePaletteColor(colorDistribution.neuralTertiary, "green"),
              // Used for success
              "--spice-rgb-green": this.hexToRgb(this.generatePaletteColor(colorDistribution.neuralTertiary, "green")),
              "--spice-misc": colorDistribution.surface1,
              // Neutral grey from palette
              "--spice-rgb-misc": rgbDistribution.surface1
            };
            const effectsSpicetifyUpdates = {
              // Shimmer effect colors (neural consciousness colors for harmonious shimmer)
              "--spice-shimmer-primary": colorDistribution.neuralPrimary,
              "--spice-rgb-shimmer-primary": rgbDistribution.neuralPrimary,
              "--spice-shimmer-secondary": colorDistribution.neuralSecondary,
              "--spice-rgb-shimmer-secondary": rgbDistribution.neuralSecondary,
              "--spice-shimmer-tertiary": colorDistribution.neuralTertiary,
              "--spice-rgb-shimmer-tertiary": rgbDistribution.neuralTertiary,
              "--spice-shimmer-quaternary": colorDistribution.primary,
              "--spice-rgb-shimmer-quaternary": rgbDistribution.primary,
              // Particle consciousness colors
              "--spice-particle-glow": colorDistribution.highlight,
              "--spice-rgb-particle-glow": rgbDistribution.highlight,
              "--spice-particle-core": colorDistribution.primary,
              "--spice-rgb-particle-core": rgbDistribution.primary,
              "--spice-particle-trail": colorDistribution.shadow,
              "--spice-rgb-particle-trail": rgbDistribution.shadow,
              // Cinematic drama colors (high contrast variants)
              "--spice-cinematic-red": this.generateCinematicRed(colorDistribution.primary),
              "--spice-rgb-cinematic-red": this.hexToRgb(this.generateCinematicRed(colorDistribution.primary)),
              "--spice-cinematic-cyan": this.generateCinematicCyan(colorDistribution.primary),
              "--spice-rgb-cinematic-cyan": this.hexToRgb(this.generateCinematicCyan(colorDistribution.primary)),
              "--spice-cinematic-yellow": this.generateCinematicYellow(colorDistribution.highlight),
              "--spice-rgb-cinematic-yellow": this.hexToRgb(this.generateCinematicYellow(colorDistribution.highlight)),
              // Holographic UI colors (ethereal variants)
              "--spice-holographic-primary": this.generateHolographicPrimary(colorDistribution.primary),
              "--spice-rgb-holographic-primary": this.hexToRgb(this.generateHolographicPrimary(colorDistribution.primary)),
              "--spice-holographic-accent": this.generateHolographicAccent(colorDistribution.neuralPrimary),
              "--spice-rgb-holographic-accent": this.hexToRgb(this.generateHolographicAccent(colorDistribution.neuralPrimary)),
              "--spice-holographic-glow": this.generateHolographicGlow(colorDistribution.highlight),
              "--spice-rgb-holographic-glow": this.hexToRgb(this.generateHolographicGlow(colorDistribution.highlight))
            };
            const allSpicetifyUpdates = {
              ...coreSpicetifyUpdates,
              ...criticalSpicetifyUpdates,
              ...coreLayoutSpicetifyUpdates,
              ...neuralSpicetifyUpdates,
              ...paletteSpicetifyUpdates,
              ...effectsSpicetifyUpdates
            };
            Object.entries(allSpicetifyUpdates).forEach(([variable, value]) => {
              this.applyColorToCSS(variable, value);
            });
            const starryNightUpdates = {
              "--sn-gradient-accent": colorDistribution.primary,
              "--sn-gradient-accent-rgb": rgbDistribution.primary,
              "--sn-gradient-primary": colorDistribution.primary,
              "--sn-gradient-primary-rgb": rgbDistribution.primary,
              "--sn-gradient-secondary": colorDistribution.surface1,
              "--sn-gradient-secondary-rgb": rgbDistribution.surface1
            };
            Object.entries(starryNightUpdates).forEach(([variable, value]) => {
              this.applyColorToCSS(variable, value);
            });
            const snColorUpdates = {
              "--sn-color-accent-hex": colorDistribution.primary,
              "--sn-color-accent-rgb": rgbDistribution.primary,
              "--sn-accent-hex": colorDistribution.primary,
              "--sn-accent-rgb": rgbDistribution.primary,
              "--sn-color-extracted-primary-rgb": rgbDistribution.primary,
              "--sn-color-extracted-secondary-rgb": rgbDistribution.surface1,
              "--sn-color-harmony-complementary-rgb": rgbDistribution.shadow,
              "--sn-color-harmony-analogous-rgb": rgbDistribution.highlight,
              "--sn-color-harmony-triadic-rgb": rgbDistribution.neuralPrimary
            };
            Object.entries(snColorUpdates).forEach(([variable, value]) => {
              this.applyColorToCSS(variable, value);
            });
            this.clearCache();
            this.lastColorUpdate = Date.now();
            this.colorUpdateCount++;
            const totalVariablesUpdated = Object.keys(allSpicetifyUpdates).length + Object.keys(starryNightUpdates).length + Object.keys(snColorUpdates).length;
            unifiedEventBus.emitSync("colors:applied", {
              cssVariables: {
                ...allSpicetifyUpdates,
                ...starryNightUpdates,
                ...snColorUpdates
              },
              accentHex: colorDistribution.primary,
              accentRgb: rgbDistribution.primary,
              appliedAt: this.lastColorUpdate
            });
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] Comprehensive Spicetify variable update with OKLAB album colors:", {
                primaryColor: colorDistribution.primary,
                accentColor: colorDistribution.surface1,
                shadowColor: colorDistribution.shadow,
                highlightColor: colorDistribution.highlight,
                surfaceProgression: [colorDistribution.base, colorDistribution.surface0, colorDistribution.surface1, colorDistribution.surface2],
                neuralColors: [colorDistribution.neuralPrimary, colorDistribution.neuralSecondary, colorDistribution.neuralTertiary],
                effectColors: {
                  shimmerColors: 4,
                  // primary, secondary, tertiary, quaternary
                  particleColors: 3,
                  // glow, core, trail
                  cinematicColors: 3,
                  // red, cyan, yellow
                  holographicColors: 3
                  // primary, accent, glow
                },
                totalSpicetifyVariablesUpdated: Object.keys(allSpicetifyUpdates).length,
                coreLayoutVariablesUpdated: Object.keys(coreLayoutSpicetifyUpdates).length,
                starryNightVariablesUpdated: Object.keys(starryNightUpdates).length,
                snColorVariablesUpdated: Object.keys(snColorUpdates).length,
                effectVariablesAdded: Object.keys(effectsSpicetifyUpdates).length,
                eventEmitted: true,
                totalVariablesUpdated
              });
            }
          } catch (error) {
            console.error("[SemanticColorManager] Failed to update with album colors:", error);
          }
        }
        /**
         * Generate intelligent color distribution for comprehensive Spicetify variable coverage
         * Uses OKLAB-inspired color science for perceptually uniform depth progression and neural networks
         */
        generateIntelligentColorDistribution(primaryColor, accentColor, shadowColor, highlightColor) {
          const primary = primaryColor;
          const accent = accentColor || primaryColor;
          const shadow = shadowColor || this.generateDarkerVariant(primaryColor, 0.3);
          const highlight = highlightColor || this.generateLighterVariant(primaryColor, 0.2);
          const base = this.generateDarkerVariant(primaryColor, 0.6);
          const surface0 = this.generateDarkerVariant(primaryColor, 0.4);
          const surface1 = accent;
          const surface2 = this.generateLighterVariant(accent, 0.15);
          const neuralPrimary = this.generateHueRotatedColor(primaryColor, 120);
          const neuralSecondary = this.generateHueRotatedColor(primaryColor, -60);
          const neuralTertiary = this.generateHueRotatedColor(primaryColor, 180);
          return {
            primary,
            surface0,
            surface1,
            surface2,
            base,
            shadow,
            highlight,
            neuralPrimary,
            neuralSecondary,
            neuralTertiary
          };
        }
        /**
         * Convert color distribution object to RGB strings for CSS variables
         */
        convertColorsToRgb(colorDistribution) {
          const rgbDistribution = {};
          Object.entries(colorDistribution).forEach(([key, hexColor]) => {
            rgbDistribution[key] = this.hexToRgb(hexColor);
          });
          return rgbDistribution;
        }
        /**
         * Generate a darker variant of a color by reducing lightness
         */
        generateDarkerVariant(hexColor, factor) {
          try {
            const rgb = this.hexToRgbObject(hexColor);
            if (!rgb) return hexColor;
            const r = Math.max(0, Math.round(rgb.r * (1 - factor)));
            const g2 = Math.max(0, Math.round(rgb.g * (1 - factor)));
            const b = Math.max(0, Math.round(rgb.b * (1 - factor)));
            return this.rgbToHex(r, g2, b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate darker variant:", error);
            return hexColor;
          }
        }
        /**
         * Generate a lighter variant of a color by increasing lightness
         */
        generateLighterVariant(hexColor, factor) {
          try {
            const rgb = this.hexToRgbObject(hexColor);
            if (!rgb) return hexColor;
            const r = Math.min(255, Math.round(rgb.r + (255 - rgb.r) * factor));
            const g2 = Math.min(255, Math.round(rgb.g + (255 - rgb.g) * factor));
            const b = Math.min(255, Math.round(rgb.b + (255 - rgb.b) * factor));
            return this.rgbToHex(r, g2, b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate lighter variant:", error);
            return hexColor;
          }
        }
        /**
         * Generate a hue-rotated variant of a color for neural consciousness systems
         */
        generateHueRotatedColor(hexColor, hueDegrees) {
          try {
            const rgb = this.hexToRgbObject(hexColor);
            if (!rgb) return hexColor;
            const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
            hsl.h = (hsl.h + hueDegrees) % 360;
            if (hsl.h < 0) hsl.h += 360;
            const rotatedRgb = this.hslToRgb(hsl.h, hsl.s, hsl.l);
            return this.rgbToHex(rotatedRgb.r, rotatedRgb.g, rotatedRgb.b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate hue-rotated color:", error);
            return hexColor;
          }
        }
        /**
         * Convert hex color to RGB object
         */
        hexToRgbObject(hex) {
          const cleanHex = hex.replace("#", "");
          if (cleanHex.length !== 6) return null;
          const r = parseInt(cleanHex.substring(0, 2), 16);
          const g2 = parseInt(cleanHex.substring(2, 4), 16);
          const b = parseInt(cleanHex.substring(4, 6), 16);
          return { r, g: g2, b };
        }
        /**
         * Convert RGB values to hex string
         */
        rgbToHex(r, g2, b) {
          const toHex = /* @__PURE__ */ __name((n) => {
            const hex = Math.round(Math.max(0, Math.min(255, n))).toString(16);
            return hex.length === 1 ? "0" + hex : hex;
          }, "toHex");
          return `#${toHex(r)}${toHex(g2)}${toHex(b)}`;
        }
        /**
         * Convert RGB to HSL for hue manipulation
         */
        rgbToHsl(r, g2, b) {
          r /= 255;
          g2 /= 255;
          b /= 255;
          const max = Math.max(r, g2, b);
          const min = Math.min(r, g2, b);
          let h = 0;
          let s = 0;
          const l = (max + min) / 2;
          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g2 - b) / d + (g2 < b ? 6 : 0);
                break;
              case g2:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g2) / d + 4;
                break;
            }
            h /= 6;
          }
          return { h: h * 360, s: s * 100, l: l * 100 };
        }
        /**
         * Convert HSL back to RGB
         */
        hslToRgb(h, s, l) {
          h /= 360;
          s /= 100;
          l /= 100;
          const hue2rgb = /* @__PURE__ */ __name((p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          }, "hue2rgb");
          let r, g2, b;
          if (s === 0) {
            r = g2 = b = l;
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g2 = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return {
            r: Math.round(r * 255),
            g: Math.round(g2 * 255),
            b: Math.round(b * 255)
          };
        }
        /**
         * Convert hex color to RGB string for CSS variables
         */
        hexToRgb(hex) {
          const cleanHex = hex.replace("#", "");
          const r = parseInt(cleanHex.substring(0, 2), 16);
          const g2 = parseInt(cleanHex.substring(2, 4), 16);
          const b = parseInt(cleanHex.substring(4, 6), 16);
          return `${r}, ${g2}, ${b}`;
        }
        getColorMappings() {
          return _SemanticColorManager.SEMANTIC_MAPPINGS;
        }
        // 🎨 PHASE 3: Effect-Specific Color Generators
        // Generate specialized colors for visual effect systems
        /**
         * Generate cinematic red color with high contrast characteristics
         * Based on album color psychology for dramatic effects
         */
        generateCinematicRed(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#FF0000";
            const dramaticRed = Math.min(255, rgb.r + 100);
            const warmGreen = Math.max(0, Math.min(rgb.g * 0.3, 100));
            const warmBlue = Math.max(0, Math.min(rgb.b * 0.2, 80));
            return this.rgbToHex(dramaticRed, warmGreen, warmBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate cinematic red:", error);
            return "#FF0000";
          }
        }
        /**
         * Generate cinematic cyan color complementary to the base color
         * Creates high contrast cyan for dramatic visual effects
         */
        generateCinematicCyan(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#00FFFF";
            const dramaticGreen = Math.min(255, rgb.g + 120);
            const dramaticBlue = Math.min(255, rgb.b + 140);
            const coolRed = Math.max(0, Math.min(rgb.r * 0.2, 60));
            return this.rgbToHex(coolRed, dramaticGreen, dramaticBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate cinematic cyan:", error);
            return "#00FFFF";
          }
        }
        /**
         * Generate cinematic yellow for accent dramatic effects
         * Bright, attention-grabbing yellow based on highlight color
         */
        generateCinematicYellow(highlightColor) {
          try {
            const rgb = this.hexToRgbObject(highlightColor);
            if (!rgb) return "#FFFF00";
            const brightRed = Math.min(255, rgb.r + 80);
            const brightGreen = Math.min(255, rgb.g + 100);
            const subtleBlue = Math.max(0, Math.min(rgb.b * 0.3, 120));
            return this.rgbToHex(brightRed, brightGreen, subtleBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate cinematic yellow:", error);
            return "#FFFF00";
          }
        }
        /**
         * Generate holographic primary color with ethereal characteristics
         * Creates iridescent, otherworldly color based on album primary
         */
        generateHolographicPrimary(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#8A2BE2";
            const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
            const enhancedSaturation = Math.min(1, hsl.s + 0.3);
            const etherealLightness = Math.min(0.8, Math.max(0.4, hsl.l + 0.1));
            const enhancedRgb = this.hslToRgb(hsl.h, enhancedSaturation, etherealLightness);
            return this.rgbToHex(enhancedRgb.r, enhancedRgb.g, enhancedRgb.b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate holographic primary:", error);
            return "#8A2BE2";
          }
        }
        /**
         * Generate holographic accent color with prismatic shift
         * Creates complementary holographic color for accent effects
         */
        generateHolographicAccent(neuralColor) {
          try {
            return this.generateHueRotatedColor(neuralColor, 45);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate holographic accent:", error);
            return "#FF00FF";
          }
        }
        /**
         * Generate holographic glow color for ethereal lighting effects
         * Creates soft, luminous glow based on highlight color
         */
        generateHolographicGlow(highlightColor) {
          try {
            const rgb = this.hexToRgbObject(highlightColor);
            if (!rgb) return "#E0E0FF";
            const glowIntensity = 0.7;
            const glowRed = Math.min(255, rgb.r + (255 - rgb.r) * glowIntensity);
            const glowGreen = Math.min(255, rgb.g + (255 - rgb.g) * glowIntensity);
            const glowBlue = Math.min(255, rgb.b + (255 - rgb.b) * glowIntensity);
            return this.rgbToHex(glowRed, glowGreen, glowBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate holographic glow:", error);
            return "#E0E0FF";
          }
        }
        /**
         * Generate high contrast text color based on background color
         * Creates optimal text readability for consciousness-aware design
         */
        generateTextColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#CAD3F5";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              return "#24273A";
            } else {
              return "#CAD3F5";
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate text color:", error);
            return "#CAD3F5";
          }
        }
        /**
         * Generate medium contrast subdued text color
         * Creates secondary text with reduced contrast for hierarchy
         */
        generateSubtextColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#A5ADCB";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              return "#5B6078";
            } else {
              return "#A5ADCB";
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate subtext color:", error);
            return "#A5ADCB";
          }
        }
        /**
         * Generate progressive overlay colors for background depth hierarchy
         * Creates Catppuccin-style overlay colors with OKLAB-enhanced base
         */
        generateOverlayColor(baseColor, opacity) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return `rgba(88,91,112,${opacity})`;
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              const factor = 1 - opacity * 2;
              const overlayRed = Math.max(0, Math.round(rgb.r * factor));
              const overlayGreen = Math.max(0, Math.round(rgb.g * factor));
              const overlayBlue = Math.max(0, Math.round(rgb.b * factor));
              return this.rgbToHex(overlayRed, overlayGreen, overlayBlue);
            } else {
              const factor = opacity * 255;
              const overlayRed = Math.min(255, Math.round(rgb.r + factor));
              const overlayGreen = Math.min(255, Math.round(rgb.g + factor));
              const overlayBlue = Math.min(255, Math.round(rgb.b + factor));
              return this.rgbToHex(overlayRed, overlayGreen, overlayBlue);
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate overlay color:", error);
            return `rgba(88,91,112,${opacity})`;
          }
        }
        /**
         * Generate window frame/border crust color
         * Creates subtle border color for window chrome elements
         */
        generateCrustColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#232634";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              const crustRed = Math.max(0, Math.round(rgb.r * 0.8));
              const crustGreen = Math.max(0, Math.round(rgb.g * 0.8));
              const crustBlue = Math.max(0, Math.round(rgb.b * 0.8));
              return this.rgbToHex(crustRed, crustGreen, crustBlue);
            } else {
              const crustRed = Math.min(255, Math.round(rgb.r + 20));
              const crustGreen = Math.min(255, Math.round(rgb.g + 20));
              const crustBlue = Math.min(255, Math.round(rgb.b + 20));
              return this.rgbToHex(crustRed, crustGreen, crustBlue);
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate crust color:", error);
            return "#232634";
          }
        }
        /**
         * Generate window background mantle color
         * Creates intermediate color between base and overlay0 for window backgrounds
         */
        generateMantleColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#1e2030";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              const mantleRed = Math.max(0, Math.round(rgb.r * 0.95));
              const mantleGreen = Math.max(0, Math.round(rgb.g * 0.95));
              const mantleBlue = Math.max(0, Math.round(rgb.b * 0.95));
              return this.rgbToHex(mantleRed, mantleGreen, mantleBlue);
            } else {
              const mantleRed = Math.min(255, Math.round(rgb.r + 10));
              const mantleGreen = Math.min(255, Math.round(rgb.g + 10));
              const mantleBlue = Math.min(255, Math.round(rgb.b + 10));
              return this.rgbToHex(mantleRed, mantleGreen, mantleBlue);
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate mantle color:", error);
            return "#1e2030";
          }
        }
        /**
         * Generate zone-specific colors with consciousness-aware hue shifts
         * Creates contextual color variations for different UI zones (home, playlist, artist, search)
         */
        generateZoneColor(baseColor, zoneType) {
          try {
            const rgb = hexToRgb(baseColor);
            if (!rgb) {
              console.warn(`\u{1F527} [SemanticColorManager] Failed to parse RGB from ${baseColor}`);
              return baseColor;
            }
            const zoneAdjustments = {
              flamingo: { rAdjust: 20, gAdjust: -10, bAdjust: -5 },
              // Warm pink for home comfort
              lavender: { rAdjust: 10, gAdjust: -5, bAdjust: 15 },
              // Cool purple for focus/playlist
              peach: { rAdjust: 25, gAdjust: 10, bAdjust: -15 },
              // Warm orange for artist discovery
              rosewater: { rAdjust: 15, gAdjust: -8, bAdjust: 0 },
              // Subtle pink for secondary elements
              sapphire: { rAdjust: -20, gAdjust: -10, bAdjust: 25 }
              // Deep blue for search precision
            };
            const config = zoneAdjustments[zoneType];
            const adjustedR = Math.max(0, Math.min(255, rgb.r + config.rAdjust));
            const adjustedG = Math.max(0, Math.min(255, rgb.g + config.gAdjust));
            const adjustedB = Math.max(0, Math.min(255, rgb.b + config.bAdjust));
            const zoneHex = rgbToHex(adjustedR, adjustedG, adjustedB);
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [SemanticColorManager] Generated ${zoneType} color: ${baseColor} \u2192 ${zoneHex} (RGB: ${rgb.r},${rgb.g},${rgb.b} \u2192 ${adjustedR},${adjustedG},${adjustedB})`);
            }
            return zoneHex;
          } catch (error) {
            console.warn(`\u{1F527} [SemanticColorManager] Failed to generate ${zoneType} color for "${baseColor}":`, error);
            return baseColor;
          }
        }
        /**
         * Generate palette-specific colors with consciousness-aware variations
         * Creates color variations for Catppuccin palette colors (pink, sky, red, maroon, yellow, green)
         */
        generatePaletteColor(baseColor, paletteType) {
          try {
            const rgb = hexToRgb(baseColor);
            if (!rgb) {
              console.warn(`\u{1F527} [SemanticColorManager] Failed to parse RGB from ${baseColor}`);
              return baseColor;
            }
            const paletteAdjustments = {
              pink: { rAdjust: 30, gAdjust: -20, bAdjust: -10 },
              // Soft pink for decorative elements
              sky: { rAdjust: -30, gAdjust: 10, bAdjust: 30 },
              // Bright sky blue for information
              red: { rAdjust: 35, gAdjust: -25, bAdjust: -15 },
              // Vibrant red for errors/warnings
              maroon: { rAdjust: 25, gAdjust: -15, bAdjust: -10 },
              // Deep maroon for emphasis
              yellow: { rAdjust: 30, gAdjust: 25, bAdjust: -30 },
              // Bright yellow for warnings
              green: { rAdjust: -25, gAdjust: 30, bAdjust: -20 }
              // Natural green for success
            };
            const config = paletteAdjustments[paletteType];
            const adjustedR = Math.max(0, Math.min(255, rgb.r + config.rAdjust));
            const adjustedG = Math.max(0, Math.min(255, rgb.g + config.gAdjust));
            const adjustedB = Math.max(0, Math.min(255, rgb.b + config.bAdjust));
            const paletteHex = rgbToHex(adjustedR, adjustedG, adjustedB);
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [SemanticColorManager] Generated ${paletteType} color: ${baseColor} \u2192 ${paletteHex} (RGB: ${rgb.r},${rgb.g},${rgb.b} \u2192 ${adjustedR},${adjustedG},${adjustedB})`);
            }
            return paletteHex;
          } catch (error) {
            console.warn(`\u{1F527} [SemanticColorManager] Failed to generate ${paletteType} color for "${baseColor}":`, error);
            return baseColor;
          }
        }
        destroy() {
          try {
            this.cleanupEventSubscriptions();
            this.clearCache();
            this.cssConsciousnessController = null;
            this.initialized = false;
            this.lastColorUpdate = 0;
            this.colorUpdateCount = 0;
            unifiedEventBus.emitSync("system:destroyed", {
              systemName: "SemanticColorManager",
              timestamp: Date.now(),
              reason: "Manual destruction"
            });
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] System destroyed and cleaned up");
            }
          } catch (error) {
            console.error("[SemanticColorManager] Error during destruction:", error);
          }
        }
        /**
         * IManagedSystem interface implementation
         */
        updateAnimation(deltaTime) {
        }
        /**
         * IManagedSystem health check implementation
         */
        async healthCheck() {
          const healthResult = {
            system: "SemanticColorManager",
            healthy: true,
            details: "SemanticColorManager operational",
            issues: [],
            metrics: {
              initialized: this.initialized,
              spicetifyAvailable: this.isSpicetifyAvailable(),
              cssConsciousnessAvailable: !!this.cssConsciousnessController,
              lastColorUpdate: this.lastColorUpdate,
              colorUpdateCount: this.colorUpdateCount,
              eventSubscriptions: this.eventSubscriptionIds.length,
              cacheSize: this.colorCache.size,
              lastCacheUpdate: this.lastCacheUpdate
            }
          };
          if (!this.initialized) {
            healthResult.healthy = false;
            healthResult.issues.push("System not initialized");
          }
          if (!this.isSpicetifyAvailable()) {
            healthResult.healthy = false;
            healthResult.issues.push("Spicetify API not available");
          }
          if (this.colorUpdateCount === 0 && this.initialized) {
            healthResult.issues.push("No color updates performed since initialization");
          }
          if (this.eventSubscriptionIds.length === 0 && this.initialized) {
            healthResult.issues.push("No event subscriptions active");
          }
          if (healthResult.issues.length > 0) {
            healthResult.details = `Issues detected: ${healthResult.issues.join(", ")}`;
            if (healthResult.issues.length >= 2) {
              healthResult.healthy = false;
            }
          }
          return healthResult;
        }
        /**
         * Setup event subscriptions for system integration
         */
        setupEventSubscriptions() {
          const trackChangeId = unifiedEventBus.subscribe(
            "music:track-changed",
            async (data) => {
              if (this.config.enableDebug) {
                console.log("\u{1F3A8} [SemanticColorManager] Track changed, preparing for color refresh:", data.trackUri);
              }
              this.clearCache();
            },
            "SemanticColorManager"
          );
          const settingsChangeId = unifiedEventBus.subscribe(
            "settings:changed",
            async (data) => {
              if (data.settingKey.includes("color") || data.settingKey.includes("theme")) {
                if (this.config.enableDebug) {
                  console.log("\u{1F3A8} [SemanticColorManager] Color-related setting changed:", data.settingKey);
                }
                this.clearCache();
              }
            },
            "SemanticColorManager"
          );
          this.eventSubscriptionIds = [trackChangeId, settingsChangeId];
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [SemanticColorManager] Event subscriptions established:", this.eventSubscriptionIds.length);
          }
        }
        /**
         * Clean up event subscriptions
         */
        cleanupEventSubscriptions() {
          for (const subscriptionId of this.eventSubscriptionIds) {
            unifiedEventBus.unsubscribe(subscriptionId);
          }
          this.eventSubscriptionIds = [];
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [SemanticColorManager] Event subscriptions cleaned up");
          }
        }
        /**
         * Get system metrics for monitoring
         */
        getSystemMetrics() {
          return {
            initialized: this.initialized,
            lastColorUpdate: this.lastColorUpdate,
            colorUpdateCount: this.colorUpdateCount,
            eventSubscriptions: this.eventSubscriptionIds.length,
            cacheSize: this.colorCache.size,
            spicetifyAvailable: this.isSpicetifyAvailable()
          };
        }
      };
      __name(_SemanticColorManager, "SemanticColorManager");
      // Semantic color mappings to our CSS variables
      _SemanticColorManager.SEMANTIC_MAPPINGS = [
        // Text colors (Catppuccin Macchiato)
        { semanticColor: "textBase", cssVariable: "--spice-text", fallbackColor: "#cad3f5", description: "Primary text color" },
        { semanticColor: "textSubdued", cssVariable: "--spice-subtext", fallbackColor: "#a5adcb", description: "Secondary text color" },
        { semanticColor: "textBrightAccent", cssVariable: "--spice-accent", fallbackColor: "#c6a0f6", description: "Accent text color" },
        { semanticColor: "textNegative", cssVariable: "--spice-red", fallbackColor: "#ed8796", description: "Error text color" },
        { semanticColor: "textWarning", cssVariable: "--spice-yellow", fallbackColor: "#eed49f", description: "Warning text color" },
        { semanticColor: "textPositive", cssVariable: "--spice-green", fallbackColor: "#a6da95", description: "Success text color" },
        { semanticColor: "textAnnouncement", cssVariable: "--spice-blue", fallbackColor: "#8aadf4", description: "Info text color" },
        // Essential colors (for icons, controls) - Catppuccin Macchiato
        { semanticColor: "essentialBase", cssVariable: "--spice-button", fallbackColor: "#cad3f5", description: "Primary button color" },
        { semanticColor: "essentialSubdued", cssVariable: "--spice-button-disabled", fallbackColor: "#6e738d", description: "Disabled button color" },
        { semanticColor: "essentialBrightAccent", cssVariable: "--spice-button-active", fallbackColor: "#c6a0f6", description: "Active button color" },
        { semanticColor: "essentialNegative", cssVariable: "--spice-notification-error", fallbackColor: "#ed8796", description: "Error button color" },
        { semanticColor: "essentialWarning", cssVariable: "--spice-notification-warning", fallbackColor: "#eed49f", description: "Warning button color" },
        { semanticColor: "essentialPositive", cssVariable: "--spice-notification-success", fallbackColor: "#a6da95", description: "Success button color" },
        // Background colors - Catppuccin Macchiato
        { semanticColor: "backgroundBase", cssVariable: "--spice-main", fallbackColor: "#24273a", description: "Main background color" },
        { semanticColor: "backgroundHighlight", cssVariable: "--spice-highlight", fallbackColor: "#363a4f", description: "Highlight background color" },
        { semanticColor: "backgroundPress", cssVariable: "--spice-press", fallbackColor: "#494d64", description: "Press state background color" },
        { semanticColor: "backgroundElevatedBase", cssVariable: "--spice-card", fallbackColor: "#1e2030", description: "Card background color" },
        { semanticColor: "backgroundElevatedHighlight", cssVariable: "--spice-card-highlight", fallbackColor: "#363a4f", description: "Card highlight background" },
        { semanticColor: "backgroundTintedBase", cssVariable: "--spice-sidebar", fallbackColor: "#363a4f", description: "Sidebar background color" },
        { semanticColor: "backgroundTintedHighlight", cssVariable: "--spice-sidebar-highlight", fallbackColor: "#494d64", description: "Sidebar highlight background" },
        // Decorative colors - Catppuccin Macchiato
        { semanticColor: "decorativeBase", cssVariable: "--spice-decorative", fallbackColor: "#cad3f5", description: "Decorative element color" },
        { semanticColor: "decorativeSubdued", cssVariable: "--spice-decorative-subdued", fallbackColor: "#939ab7", description: "Subdued decorative color" }
      ];
      SemanticColorManager = _SemanticColorManager;
    }
  });

  // src-js/utils/graphics/VisualCanvasFactory.ts
  function detectWebGL2Support() {
    try {
      const testCanvas = document.createElement("canvas");
      const gl = testCanvas.getContext("webgl2");
      if (!gl) return false;
      const hasRequiredExtensions = gl.getExtension("EXT_color_buffer_float") !== null;
      return true;
    } catch (e) {
      return false;
    }
  }
  function createWebGL2Context(canvas, options) {
    try {
      const contextOptions = {
        alpha: options.alpha ?? true,
        antialias: options.antialias ?? true,
        preserveDrawingBuffer: options.preserveDrawingBuffer ?? false,
        powerPreference: "high-performance",
        failIfMajorPerformanceCaveat: false
      };
      const gl = canvas.getContext(
        "webgl2",
        contextOptions
      );
      if (!gl) return null;
      const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      return {
        canvas,
        ctx: gl,
        type: "webgl2",
        capabilities: {
          supportsGPUAcceleration: true,
          supports3D: true,
          maxTextureSize
        }
      };
    } catch (error) {
      console.warn(
        "[VisualCanvasFactory] WebGL2 context creation failed:",
        error
      );
      return null;
    }
  }
  function create2DContext(canvas, options) {
    const contextOptions = {
      alpha: options.alpha ?? true,
      desynchronized: true
      // Optimize for animations
    };
    const ctx = canvas.getContext(
      "2d",
      contextOptions
    );
    return {
      canvas,
      ctx,
      type: "2d",
      capabilities: {
        supportsGPUAcceleration: false,
        supports3D: false
      }
    };
  }
  async function createOptimizedCanvas(options) {
    const canvas = document.createElement("canvas");
    canvas.id = options.id;
    canvas.width = options.width ?? window.innerWidth;
    canvas.height = options.height ?? window.innerHeight;
    const fallbackChain = options.fallbackChain ?? ["webgl2", "2d"];
    if (options.preferredType) {
      const chain = [
        options.preferredType,
        ...fallbackChain.filter((t) => t !== options.preferredType)
      ];
      fallbackChain.splice(0, fallbackChain.length, ...chain);
    }
    for (const contextType of fallbackChain) {
      let result = null;
      switch (contextType) {
        case "webgl2":
          if (detectWebGL2Support()) {
            result = createWebGL2Context(canvas, options);
          }
          break;
        case "2d":
          result = create2DContext(canvas, options);
          break;
      }
      if (result) {
        return result;
      }
    }
    return create2DContext(canvas, options);
  }
  function detectRenderingCapabilities() {
    const webgl2 = detectWebGL2Support();
    let recommendedType = "2d";
    if (webgl2) {
      recommendedType = "webgl2";
    }
    return { webgl2, recommendedType };
  }
  var init_VisualCanvasFactory = __esm({
    "src-js/utils/graphics/VisualCanvasFactory.ts"() {
      "use strict";
      __name(detectWebGL2Support, "detectWebGL2Support");
      __name(createWebGL2Context, "createWebGL2Context");
      __name(create2DContext, "create2DContext");
      __name(createOptimizedCanvas, "createOptimizedCanvas");
      __name(detectRenderingCapabilities, "detectRenderingCapabilities");
    }
  });

  // src-js/utils/animation/visualPerformance.ts
  function selectPerformanceProfile(quality, performanceProfiles, opts = {}) {
    const { trace } = opts;
    if (!performanceProfiles || typeof performanceProfiles !== "object") {
      trace?.(
        "[visualPerformance] No performanceProfiles provided \u2013 skipping selection"
      );
      return null;
    }
    let selected = performanceProfiles[quality];
    if (!selected) {
      trace?.(
        `[visualPerformance] Profile '${quality}' not found, falling back to 'balanced'`
      );
      selected = performanceProfiles["balanced"];
    }
    if (!selected) {
      const firstKey = Object.keys(
        performanceProfiles
      )[0];
      selected = performanceProfiles[firstKey];
      trace?.(
        `[visualPerformance] Using first available profile '${firstKey}' as fallback`
      );
    }
    return selected;
  }
  var init_visualPerformance = __esm({
    "src-js/utils/animation/visualPerformance.ts"() {
      "use strict";
      __name(selectPerformanceProfile, "selectPerformanceProfile");
    }
  });

  // src-js/visual/base/BaseVisualSystem.ts
  var _BaseVisualSystem, BaseVisualSystem;
  var init_BaseVisualSystem = __esm({
    "src-js/visual/base/BaseVisualSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_VisualCanvasFactory();
      init_Year3000Utilities();
      init_visualPerformance();
      _BaseVisualSystem = class _BaseVisualSystem {
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, performanceMonitor, musicSyncService, settingsManager) {
          this._initializationStartTime = null;
          // GPU-accelerated canvas support
          this.canvasCapabilities = null;
          this.activeCanvasResults = /* @__PURE__ */ new Map();
          this.config = config;
          this.utils = utils;
          this.performanceMonitor = performanceMonitor;
          this.musicSyncService = musicSyncService;
          this.settingsManager = settingsManager;
          this.systemName = this.constructor.name;
          this.initialized = false;
          this.isActive = false;
          this.currentPerformanceProfile = {};
          this.metrics = {
            initializationTime: 0,
            updates: 0,
            errors: 0
          };
          this._resizeHandler = null;
          this.boundHandleSettingsChange = this.handleSettingsChange.bind(this);
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Constructor`);
          }
        }
        // Replace the current skeletal `initialize` method with this complete, multi-phase version.
        async initialize() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing...`);
            if (this.performanceMonitor) {
              this._initializationStartTime = this.performanceMonitor.startTiming(
                `initialize_${this.systemName}`
              );
            }
          }
          if (this.settingsManager) {
            document.addEventListener(
              "year3000SystemSettingsChanged",
              this.boundHandleSettingsChange
            );
            try {
              const detectorInstance = globalThis.year3000System?.deviceCapabilityDetector;
              let quality = "balanced";
              if (detectorInstance?.isInitialized) {
                quality = detectorInstance.recommendPerformanceQuality();
              }
              this.performanceMonitor?.emitTrace?.(
                `[${this.systemName}] Auto-selected performance quality '${quality}' based on device capability.`
              );
              this._applyPerformanceProfile(quality);
            } catch (e) {
              this.performanceMonitor?.emitTrace?.(
                `[${this.systemName}] Device capability detection failed; defaulting to 'balanced'.`,
                e
              );
              this._applyPerformanceProfile("balanced");
            }
          }
          await this._performSystemSpecificInitialization();
          this.initialized = true;
          this.isActive = true;
          if (this.musicSyncService) {
            if (this._validateDependenciesForSubscription()) {
              this.musicSyncService.subscribe(this, this.systemName);
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Subscribed to MusicSyncService.`);
              }
            } else {
              console.warn(
                `[${this.systemName}] Dependency validation failed; subscription skipped.`
              );
            }
          }
          if (this.config.enableDebug && this._initializationStartTime !== null && this.performanceMonitor) {
            this.performanceMonitor.endTiming(
              `initialize_${this.systemName}`,
              this._initializationStartTime
            );
            console.log(`[${this.systemName}] Initialization complete.`);
          }
        }
        // Add new virtual methods for subclass extension.
        // These provide safe hooks for custom initialization logic.
        async _performSystemSpecificInitialization() {
          this.canvasCapabilities = detectRenderingCapabilities();
          if (this.canvasCapabilities) {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Canvas capabilities detected: WebGL2=${this.canvasCapabilities.webgl2}, Recommended=${this.canvasCapabilities.recommendedType}`
            );
          }
        }
        _validateDependenciesForSubscription() {
          if (typeof this.updateFromMusicAnalysis !== "function") {
            console.error(
              `[${this.systemName}] Missing updateFromMusicAnalysis method.`
            );
            return false;
          }
          if (!this.initialized) {
            console.warn(`[${this.systemName}] System not initialized.`);
            return false;
          }
          return this._performAdditionalDependencyValidation();
        }
        _performAdditionalDependencyValidation() {
          return true;
        }
        // Replace the current skeletal `destroy` method with this complete version for proper cleanup.
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying...`);
          }
          try {
            this.initialized = false;
            this.isActive = false;
            if (this.musicSyncService) {
              this.musicSyncService.unsubscribe(this.systemName);
            }
            if (this.settingsManager && this.boundHandleSettingsChange) {
              document.removeEventListener(
                "year3000SystemSettingsChanged",
                this.boundHandleSettingsChange
              );
            }
            if (this._resizeHandler) {
              window.removeEventListener("resize", this._resizeHandler);
              this._resizeHandler = null;
            }
            this._performSystemSpecificCleanup();
          } catch (error) {
            console.error(`[${this.systemName}] Error during destruction:`, error);
            this.metrics.errors++;
          }
        }
        // Add the virtual cleanup hook for subclasses.
        _performSystemSpecificCleanup() {
          for (const [id, canvasResult] of this.activeCanvasResults) {
            const canvas = canvasResult.canvas;
            if (canvas.parentNode) {
              canvas.parentNode.removeChild(canvas);
            }
            if (this.config.enableDebug) {
              console.log(
                `[${this.systemName}] Cleaned up canvas: ${id} (type: ${canvasResult.type})`
              );
            }
          }
          this.activeCanvasResults.clear();
        }
        updateFromMusicAnalysis(processedMusicData, ...args) {
        }
        /**
         * Unified animation hook called by MasterAnimationCoordinator.
         * Subclasses can override this method or implement updateAnimation for legacy support.
         *
         * @param deltaMs - Time in milliseconds since the last frame for this system
         */
        onAnimate(deltaMs) {
          if (typeof this.updateAnimation === "function") {
            this.updateAnimation(performance.now(), deltaMs);
          }
        }
        updateModeConfiguration(modeConfig) {
        }
        /**
         * Base implementation of the settings-change hook. It is intentionally empty
         * now that the legacy `sn-performanceQuality` key has been removed. Subclasses
         * should override this method if they need to respond to other settings keys
         * and are still encouraged to call `super.handleSettingsChange(event)`.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        handleSettingsChange(event) {
        }
        _applyPerformanceProfile(quality) {
          if (!this.config?.performanceProfiles) {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Performance profiles not found in config.`
            );
            return;
          }
          const profile = selectPerformanceProfile(
            quality,
            this.config.performanceProfiles,
            {
              trace: /* @__PURE__ */ __name((msg) => this.performanceMonitor?.emitTrace(msg), "trace")
            }
          );
          if (profile) {
            this.currentPerformanceProfile = profile;
            this.performanceMonitor?.emitTrace?.(
              `[BaseVisualSystem (${this.systemName})] Applied performance profile '${quality}'`,
              profile
            );
          } else {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Performance profile '${quality}' not found.`
            );
          }
        }
        getCosmicState() {
          if (typeof document === "undefined") return {};
          const root = document.documentElement;
          const style = getComputedStyle(root);
          return {
            energy: parseFloat(style.getPropertyValue("--sn-kinetic-energy")) || 0.5,
            valence: parseFloat(style.getPropertyValue("--sn-kinetic-valence")) || 0.5,
            bpm: parseFloat(style.getPropertyValue("--sn-kinetic-bpm")) || 120,
            tempoMultiplier: parseFloat(style.getPropertyValue("--sn-kinetic-tempo-multiplier")) || 1,
            beatPhase: parseFloat(style.getPropertyValue("--sn-kinetic-beat-phase")) || 0,
            beatPulse: parseFloat(style.getPropertyValue("--sn-kinetic-beat-pulse")) || 0
          };
        }
        /**
         * Create GPU-accelerated optimized canvas with kinetic styling.
         * This method prioritizes WebGL2 > 2D Canvas based on device capabilities.
         */
        async _createOptimizedKineticCanvas(id, zIndex = 5, blendMode = "screen", kineticMode = "pulse") {
          const existing = document.getElementById(id);
          if (existing) {
            existing.remove();
          }
          let preferredType = "2d";
          if (this.canvasCapabilities && this.currentPerformanceProfile) {
            const quality = this.currentPerformanceProfile.quality || "balanced";
            if (quality !== "low" && this.canvasCapabilities.webgl2) {
              preferredType = "webgl2";
            }
          }
          const canvasResult = await createOptimizedCanvas({
            id,
            width: window.innerWidth,
            height: window.innerHeight,
            alpha: true,
            antialias: true,
            preferredType
          });
          const canvas = canvasResult.canvas;
          canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: ${zIndex};
      pointer-events: none;
      mix-blend-mode: ${blendMode};
    `;
          canvas.classList.add("year3000-kinetic-canvas");
          canvas.dataset.kineticMode = kineticMode;
          canvas.dataset.systemName = this.systemName;
          canvas.dataset.canvasType = canvasResult.type;
          const kineticStyles = this._getKineticStyles(kineticMode);
          Object.assign(canvas.style, kineticStyles);
          document.body.appendChild(canvas);
          this.activeCanvasResults.set(id, canvasResult);
          this._resizeHandler = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (typeof this.handleResize === "function") {
              this.handleResize();
            }
          };
          window.addEventListener("resize", this._resizeHandler);
          this._resizeHandler();
          if (this.config.enableDebug) {
            console.log(
              `[BaseVisualSystem (${this.systemName})] Created optimized kinetic canvas: ${canvasResult.type} (mode: ${kineticMode})`
            );
          }
          return canvasResult;
        }
        /**
         * Get current canvas rendering capabilities.
         */
        getCanvasCapabilities() {
          return this.canvasCapabilities;
        }
        /**
         * Check if GPU acceleration is available and active.
         */
        hasGPUAcceleration() {
          return this.canvasCapabilities?.webgl2 || false;
        }
        _createKineticCanvas(id, zIndex = 5, blendMode = "screen", kineticMode = "pulse") {
          const canvas = this._createCanvasElement(id, zIndex, blendMode);
          canvas.classList.add("year3000-kinetic-canvas");
          canvas.dataset.kineticMode = kineticMode;
          canvas.dataset.systemName = this.systemName;
          const kineticStyles = this._getKineticStyles(kineticMode);
          Object.assign(canvas.style, kineticStyles);
          if (this.config.enableDebug) {
            console.log(
              `[BaseVisualSystem (${this.systemName})] Created kinetic canvas with mode: ${kineticMode}`
            );
          }
          return canvas;
        }
        _getKineticStyles(kineticMode) {
          const baseStyles = {
            transition: "all 150ms cubic-bezier(0.25, 0.46, 0.45, 0.94)"
          };
          switch (kineticMode) {
            case "pulse":
              return {
                ...baseStyles,
                animation: "year3000-pulse calc(var(--sn-kinetic-tempo-multiplier, 1) * 1s) ease-in-out infinite"
              };
            case "breathe":
              return {
                ...baseStyles,
                animation: "year3000-breathe calc(var(--sn-kinetic-tempo-multiplier, 1) * 4s) ease-in-out infinite"
              };
            case "flow":
              return {
                ...baseStyles,
                animation: "year3000-flow calc(var(--sn-kinetic-tempo-multiplier, 1) * 8s) linear infinite"
              };
            default:
              return baseStyles;
          }
        }
        _createCanvasElement(id, zIndex, blendMode) {
          const existing = document.getElementById(id);
          if (existing) {
            existing.remove();
          }
          const canvas = document.createElement("canvas");
          canvas.id = id;
          canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: ${zIndex};
      pointer-events: none;
      mix-blend-mode: ${blendMode};
    `;
          document.body.appendChild(canvas);
          this._resizeHandler = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (typeof this.handleResize === "function") {
              this.handleResize();
            }
          };
          window.addEventListener("resize", this._resizeHandler);
          this._resizeHandler();
          return canvas;
        }
        /**
         * Apply a fully-resolved PerformanceProfile coming from Year3000System.
         * Sub-systems may override this to adjust internal parameters (particle
         * counts, throttle values, etc.). The base implementation simply stores the
         * profile so dependants can query `currentPerformanceProfile`.
         */
        applyPerformanceSettings(profile) {
          this.currentPerformanceProfile = profile;
          if (profile.quality && typeof this._applyPerformanceProfile === "function") {
            this._applyPerformanceProfile?.(profile.quality);
          }
          if (this.config.enableDebug) {
            this.performanceMonitor?.emitTrace?.(
              `[BaseVisualSystem (${this.systemName})] Performance settings applied`,
              profile
            );
          }
        }
        /**
         * Centralised settings responder invoked by Year3000System.  The base
         * implementation simply adapts the parameters into a synthetic CustomEvent
         * so that legacy subclasses overriding `handleSettingsChange` continue to
         * work without modification.  Newer systems can override this directly for
         * efficiency.
         */
        applyUpdatedSettings(key, value) {
          const evt = new CustomEvent("year3000SystemSettingsChanged", {
            detail: { key, value }
          });
          try {
            this.handleSettingsChange(evt);
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn(
                `[BaseVisualSystem] ${this.systemName} applyUpdatedSettings error`,
                err
              );
            }
          }
        }
        // ---------------------------------------------------------------------------
        // SETTINGS-AWARE REPAINT CONTRACT
        // ---------------------------------------------------------------------------
        /**
         * Default no-op implementation.  Subclasses that cache colours, shaders, or
         * other theme-dependent resources should override and perform a lightweight
         * refresh.
         */
        forceRepaint(_reason = "generic") {
        }
      };
      __name(_BaseVisualSystem, "BaseVisualSystem");
      BaseVisualSystem = _BaseVisualSystem;
    }
  });

  // src-js/utils/color/EmotionalTemperatureMapper.ts
  var EMOTIONAL_TEMPERATURE_MAP, _EmotionalTemperatureMapper, EmotionalTemperatureMapper;
  var init_EmotionalTemperatureMapper = __esm({
    "src-js/utils/color/EmotionalTemperatureMapper.ts"() {
      "use strict";
      init_OKLABColorProcessor();
      EMOTIONAL_TEMPERATURE_MAP = {
        calm: {
          temperatureRange: [2700, 4e3],
          baseTemperature: 3200,
          characteristics: {
            energy: [0, 0.3],
            valence: [0.4, 0.8],
            intensity: 0.6
          },
          cssClass: "organic-emotion-calm",
          description: "Warm, soothing, meditative states",
          oklabBaseColor: "#89b4fa",
          // Catppuccin blue - calming base
          oklabPreset: "SUBTLE",
          perceptualCharacteristics: {
            lightness: [0.6, 0.8],
            // Moderate to high lightness for calming effect
            chromaBoost: 0.9,
            // Slightly reduced chroma for gentleness
            hueShift: 15
            // Slight warm shift towards cyan-blue
          }
        },
        melancholy: {
          temperatureRange: [2200, 3500],
          baseTemperature: 2800,
          characteristics: {
            energy: [0, 0.4],
            valence: [0, 0.4],
            intensity: 0.8
          },
          cssClass: "organic-emotion-melancholy",
          description: "Deep, introspective, amber-golden tones",
          oklabBaseColor: "#f9e2af",
          // Catppuccin yellow - warm melancholic base
          oklabPreset: "STANDARD",
          perceptualCharacteristics: {
            lightness: [0.4, 0.6],
            // Lower lightness for introspective mood
            chromaBoost: 1.1,
            // Enhanced warmth and saturation
            hueShift: -10
            // Shift towards warmer amber tones
          }
        },
        energetic: {
          temperatureRange: [5500, 7500],
          baseTemperature: 6500,
          characteristics: {
            energy: [0.6, 1],
            valence: [0.5, 1],
            intensity: 1
          },
          cssClass: "organic-emotion-energetic",
          description: "Bright, vibrant, high-energy states",
          oklabBaseColor: "#a6e3a1",
          // Catppuccin green - vibrant energetic base
          oklabPreset: "VIBRANT",
          perceptualCharacteristics: {
            lightness: [0.7, 0.9],
            // High lightness for energy
            chromaBoost: 1.3,
            // Maximum vibrancy
            hueShift: 5
            // Slight shift towards more vibrant green
          }
        },
        aggressive: {
          temperatureRange: [8e3, 12e3],
          baseTemperature: 1e4,
          characteristics: {
            energy: [0.7, 1],
            valence: [0, 0.6],
            intensity: 1.2
          },
          cssClass: "organic-emotion-aggressive",
          description: "Cool, intense, high-energy negative valence",
          oklabBaseColor: "#f38ba8",
          // Catppuccin red - intense aggressive base
          oklabPreset: "COSMIC",
          perceptualCharacteristics: {
            lightness: [0.5, 0.7],
            // Moderate lightness with high intensity
            chromaBoost: 1.4,
            // Maximum chroma for intensity
            hueShift: -5
            // Slight shift towards deeper red
          }
        },
        happy: {
          temperatureRange: [4500, 6500],
          baseTemperature: 5500,
          characteristics: {
            energy: [0.4, 0.8],
            valence: [0.6, 1],
            intensity: 0.9
          },
          cssClass: "organic-emotion-happy",
          description: "Balanced, joyful, warm-white tones",
          oklabBaseColor: "#fab387",
          // Catppuccin peach - warm happy base
          oklabPreset: "STANDARD",
          perceptualCharacteristics: {
            lightness: [0.75, 0.85],
            // High lightness for joy
            chromaBoost: 1.15,
            // Enhanced warmth
            hueShift: 8
            // Shift towards warmer orange
          }
        },
        romantic: {
          temperatureRange: [2500, 3500],
          baseTemperature: 3e3,
          characteristics: {
            energy: [0.2, 0.6],
            valence: [0.5, 0.9],
            intensity: 0.7
          },
          cssClass: "organic-emotion-romantic",
          description: "Soft, intimate, warm tones with pink accent",
          oklabBaseColor: "#f5c2e7",
          // Catppuccin pink - romantic base
          oklabPreset: "SUBTLE",
          perceptualCharacteristics: {
            lightness: [0.65, 0.8],
            // Soft, comfortable lightness
            chromaBoost: 1,
            // Natural saturation
            hueShift: 12
            // Shift towards warmer pink
          }
        },
        mysterious: {
          temperatureRange: [1800, 2800],
          baseTemperature: 2300,
          characteristics: {
            energy: [0.1, 0.5],
            valence: [0.1, 0.5],
            intensity: 0.9
          },
          cssClass: "organic-emotion-mysterious",
          description: "Deep, enigmatic, low temperature with purple accent",
          oklabBaseColor: "#cba6f7",
          // Catppuccin mauve - mysterious base
          oklabPreset: "VIBRANT",
          perceptualCharacteristics: {
            lightness: [0.3, 0.5],
            // Low lightness for mystery
            chromaBoost: 1.2,
            // Enhanced depth
            hueShift: -15
            // Shift towards deeper purple
          }
        },
        epic: {
          temperatureRange: [7e3, 15e3],
          baseTemperature: 11e3,
          characteristics: {
            energy: [0.6, 1],
            valence: [0.3, 0.8],
            intensity: 1.3
          },
          cssClass: "organic-emotion-epic",
          description: "Grand, cinematic, high contrast blue-gold",
          oklabBaseColor: "#74c7ec",
          // Catppuccin sapphire - epic base
          oklabPreset: "COSMIC",
          perceptualCharacteristics: {
            lightness: [0.6, 0.9],
            // Wide lightness range for drama
            chromaBoost: 1.35,
            // Maximum cinematic impact
            hueShift: 20
            // Shift towards more dramatic blue
          }
        },
        ambient: {
          temperatureRange: [3e3, 5e3],
          baseTemperature: 4e3,
          characteristics: {
            energy: [0.1, 0.4],
            valence: [0.3, 0.7],
            intensity: 0.5
          },
          cssClass: "organic-emotion-ambient",
          description: "Atmospheric, floating, neutral temperature",
          oklabBaseColor: "#94e2d5",
          // Catppuccin teal - ambient base
          oklabPreset: "SUBTLE",
          perceptualCharacteristics: {
            lightness: [0.5, 0.7],
            // Balanced lightness for atmosphere
            chromaBoost: 0.8,
            // Reduced chroma for subtlety
            hueShift: 0
            // No hue shift for neutrality
          }
        }
      };
      _EmotionalTemperatureMapper = class _EmotionalTemperatureMapper {
        constructor(enableDebug = false) {
          this.enableDebug = enableDebug;
          this.oklabProcessor = new OKLABColorProcessor(enableDebug);
        }
        /**
         * Analyzes music data and returns the appropriate emotional temperature configuration
         */
        mapMusicToEmotionalTemperature(musicData) {
          const { energy = 0.5, valence = 0.5, danceability = 0.5, tempo = 120, mode = 1 } = musicData;
          let primaryEmotion;
          let secondaryEmotion;
          let blendRatio = 1;
          if (energy >= 0.6 && valence >= 0.6) {
            primaryEmotion = danceability > 0.7 ? "energetic" : "happy";
            if (energy > 0.8 && valence > 0.8) {
              secondaryEmotion = "epic";
              blendRatio = 0.7;
            }
          } else if (energy >= 0.6 && valence < 0.5) {
            primaryEmotion = energy > 0.8 ? "aggressive" : "epic";
            if (valence < 0.3) {
              secondaryEmotion = "mysterious";
              blendRatio = 0.8;
            }
          } else if (energy < 0.4 && valence >= 0.5) {
            primaryEmotion = valence > 0.7 ? "calm" : "romantic";
            if (energy < 0.2) {
              secondaryEmotion = "ambient";
              blendRatio = 0.6;
            }
          } else {
            primaryEmotion = valence < 0.3 ? "melancholy" : "mysterious";
            if (energy < 0.2 && valence < 0.2) {
              secondaryEmotion = "ambient";
              blendRatio = 0.8;
            }
          }
          if (musicData.genre) {
            const genreAdjustment = this.getGenreEmotionalAdjustment(musicData.genre, primaryEmotion);
            if (genreAdjustment) {
              if (genreAdjustment.override) {
                primaryEmotion = genreAdjustment.override;
              }
              if (genreAdjustment.secondary) {
                secondaryEmotion = genreAdjustment.secondary;
                blendRatio = genreAdjustment.blendRatio || 0.7;
              }
            }
          }
          const baseIntensity = EMOTIONAL_TEMPERATURE_MAP[primaryEmotion].characteristics.intensity;
          const energyBoost = energy * 0.3;
          const valenceInfluence = Math.abs(valence - 0.5) * 0.2;
          const tempoInfluence = tempo > 140 ? 0.1 : tempo < 80 ? -0.1 : 0;
          const finalIntensity = Math.max(0.1, Math.min(
            1.5,
            baseIntensity + energyBoost + valenceInfluence + tempoInfluence
          ));
          const emotionData = EMOTIONAL_TEMPERATURE_MAP[primaryEmotion];
          const [minTemp, maxTemp] = emotionData.temperatureRange;
          const temperaturePosition = energy * 0.6 + valence * 0.4;
          const temperature = minTemp + (maxTemp - minTemp) * temperaturePosition;
          const oklabPreset = OKLABColorProcessor.getPreset(emotionData.oklabPreset);
          let oklabResult;
          let perceptualColorHex;
          try {
            const customPreset = this.createContextualOKLABPreset(
              emotionData,
              finalIntensity,
              energy,
              valence
            );
            oklabResult = this.oklabProcessor.processColor(
              emotionData.oklabBaseColor,
              customPreset
            );
            perceptualColorHex = oklabResult.enhancedHex;
            if (this.enableDebug) {
              console.log("\u{1F321}\uFE0F [EmotionalTemperatureMapper] OKLAB processing:", {
                emotion: primaryEmotion,
                baseColor: emotionData.oklabBaseColor,
                preset: customPreset.name,
                enhanced: perceptualColorHex,
                oklabCoords: oklabResult.oklabEnhanced
              });
            }
          } catch (error) {
            if (this.enableDebug) {
              console.warn("\u{1F321}\uFE0F [EmotionalTemperatureMapper] OKLAB processing failed:", error);
            }
            perceptualColorHex = emotionData.oklabBaseColor;
          }
          const cssVariables = this.generateEmotionalCSSVariables(
            primaryEmotion,
            secondaryEmotion,
            finalIntensity,
            temperature,
            blendRatio,
            oklabResult,
            perceptualColorHex
          );
          const result = {
            primaryEmotion,
            ...secondaryEmotion && { secondaryEmotion },
            intensity: finalIntensity,
            temperature: Math.round(temperature),
            blendRatio,
            cssClass: emotionData.cssClass,
            cssVariables,
            // OKLAB integration
            oklabPreset,
            ...oklabResult && { oklabResult },
            ...perceptualColorHex && { perceptualColorHex }
          };
          if (this.enableDebug) {
            console.log("\u{1F321}\uFE0F [EmotionalTemperatureMapper] Music analysis result:", {
              input: { energy, valence, genre: musicData.genre },
              output: result,
              reasoning: {
                energyValenceQuadrant: this.getEnergyValenceQuadrant(energy, valence),
                genreInfluence: musicData.genre,
                intensityFactors: { baseIntensity, energyBoost, valenceInfluence, tempoInfluence }
              }
            });
          }
          return result;
        }
        /**
         * Create contextual OKLAB preset based on emotional characteristics and music data
         */
        createContextualOKLABPreset(emotionData, intensity, energy, valence) {
          const basePreset = OKLABColorProcessor.getPreset(emotionData.oklabPreset);
          const perceptualChars = emotionData.perceptualCharacteristics;
          const lightnessFactor = energy * 0.5 + valence * 0.3 + 0.2;
          const targetLightness = perceptualChars.lightness[0] + (perceptualChars.lightness[1] - perceptualChars.lightness[0]) * lightnessFactor;
          const chromaMultiplier = perceptualChars.chromaBoost * intensity * (0.8 + energy * 0.4);
          return OKLABColorProcessor.createCustomPreset(
            `${emotionData.cssClass}-contextual`,
            `Contextual ${basePreset.description} for ${emotionData.description}`,
            targetLightness / 0.5,
            // Convert to lightness boost multiplier
            chromaMultiplier,
            basePreset.shadowReduction,
            basePreset.vibrantThreshold
          );
        }
        /**
         * Get genre-specific emotional adjustments
         */
        getGenreEmotionalAdjustment(genre, currentEmotion) {
          const genreMap = {
            // Electronic genres
            "edm": { secondary: "energetic", blendRatio: 0.8 },
            "house": { secondary: "energetic", blendRatio: 0.7 },
            "ambient": { override: "ambient" },
            "downtempo": { override: "calm", secondary: "ambient", blendRatio: 0.6 },
            // Rock genres
            "metal": { override: "aggressive" },
            "hard-rock": { secondary: "aggressive", blendRatio: 0.8 },
            "alternative": { secondary: "epic", blendRatio: 0.7 },
            // Classical and orchestral
            "classical": { override: "epic", secondary: "calm", blendRatio: 0.6 },
            "soundtrack": { override: "epic" },
            "orchestral": { override: "epic" },
            // Jazz and soul
            "jazz": { override: "mysterious", secondary: "romantic", blendRatio: 0.7 },
            "blues": { override: "melancholy" },
            "soul": { secondary: "romantic", blendRatio: 0.6 },
            // Folk and acoustic
            "folk": { override: "calm", secondary: "melancholy", blendRatio: 0.6 },
            "acoustic": { override: "romantic", secondary: "calm", blendRatio: 0.7 },
            // Hip-hop and urban
            "hip-hop": { secondary: "aggressive", blendRatio: 0.8 },
            "trap": { secondary: "aggressive", blendRatio: 0.9 },
            // Pop variations
            "pop": { secondary: "happy", blendRatio: 0.7 },
            "indie-pop": { secondary: "happy", blendRatio: 0.6 }
          };
          const normalizedGenre = genre.toLowerCase().replace(/[\s-_]/g, "-");
          return genreMap[normalizedGenre] || null;
        }
        /**
         * Determine energy-valence quadrant for debugging
         */
        getEnergyValenceQuadrant(energy, valence) {
          if (energy >= 0.5 && valence >= 0.5) return "High Energy + Positive";
          if (energy >= 0.5 && valence < 0.5) return "High Energy + Negative";
          if (energy < 0.5 && valence >= 0.5) return "Low Energy + Positive";
          return "Low Energy + Negative";
        }
        /**
         * Generate CSS variables for emotional temperature integration with OKLAB enhancement
         */
        generateEmotionalCSSVariables(primary, secondary, intensity, temperature, blendRatio, oklabResult, perceptualColorHex) {
          const cssVars = {};
          cssVars["--organic-current-emotion"] = primary;
          cssVars["--organic-emotional-intensity"] = intensity.toString();
          cssVars["--organic-current-temperature"] = temperature.toString();
          cssVars["--organic-emotion-primary"] = primary;
          if (secondary) {
            cssVars["--organic-emotion-secondary"] = secondary;
            cssVars["--organic-emotion-blend-ratio"] = blendRatio.toString();
          }
          cssVars["--organic-emotional-saturation"] = Math.max(0.5, intensity).toString();
          cssVars["--organic-cinematic-contrast"] = Math.max(0.8, intensity * 1.2).toString();
          cssVars["--organic-warmth"] = this.calculateWarmth(temperature).toString();
          const breathingSpeed = this.calculateBreathingSpeed(primary, intensity);
          cssVars["--organic-breathing-cycle"] = `${breathingSpeed}s`;
          const temperatureFilters = this.calculateTemperatureFilters(temperature, intensity);
          Object.assign(cssVars, temperatureFilters);
          if (oklabResult && perceptualColorHex) {
            cssVars["--organic-emotion-oklab-hex"] = perceptualColorHex;
            cssVars["--organic-emotion-oklab-rgb"] = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            cssVars["--organic-emotion-oklab-l"] = oklabResult.oklabEnhanced.L.toFixed(3);
            cssVars["--organic-emotion-oklab-a"] = oklabResult.oklabEnhanced.a.toFixed(3);
            cssVars["--organic-emotion-oklab-b"] = oklabResult.oklabEnhanced.b.toFixed(3);
            cssVars["--organic-emotion-oklch-l"] = oklabResult.oklchEnhanced.L.toFixed(3);
            cssVars["--organic-emotion-oklch-c"] = oklabResult.oklchEnhanced.C.toFixed(3);
            cssVars["--organic-emotion-oklch-h"] = oklabResult.oklchEnhanced.H.toFixed(1);
            cssVars["--organic-emotion-oklab-shadow-hex"] = oklabResult.shadowHex;
            cssVars["--organic-emotion-oklab-shadow-rgb"] = `${oklabResult.shadowRgb.r},${oklabResult.shadowRgb.g},${oklabResult.shadowRgb.b}`;
            cssVars["--organic-perceptual-emotion-color"] = perceptualColorHex;
            cssVars["--organic-perceptual-emotion-rgb"] = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            if (this.enableDebug) {
              console.log("\u{1F3A8} [EmotionalTemperatureMapper] Generated OKLAB CSS variables:", {
                emotion: primary,
                perceptualColor: perceptualColorHex,
                oklabCoords: oklabResult.oklabEnhanced,
                oklchCoords: oklabResult.oklchEnhanced
              });
            }
          }
          return cssVars;
        }
        /**
         * Calculate warmth factor based on temperature (0-1)
         */
        calculateWarmth(temperature) {
          if (temperature <= 4e3) {
            return 0.7 + (4e3 - temperature) / (4e3 - 1800) * 0.3;
          } else if (temperature >= 7e3) {
            return Math.max(0.2, 0.7 - (temperature - 7e3) / (15e3 - 7e3) * 0.5);
          } else {
            return 0.5 + (7e3 - temperature) / (7e3 - 4e3) * 0.2;
          }
        }
        /**
         * Calculate breathing animation speed based on emotion and intensity
         */
        calculateBreathingSpeed(emotion, intensity) {
          const baseSpeed = {
            calm: 6,
            melancholy: 8,
            energetic: 2,
            aggressive: 1.5,
            happy: 3,
            romantic: 5,
            mysterious: 7,
            epic: 2.5,
            ambient: 10
          };
          const base = baseSpeed[emotion];
          const intensityFactor = Math.max(0.5, Math.min(2, 2 - intensity));
          return base * intensityFactor;
        }
        /**
         * Calculate temperature-based CSS filter adjustments
         */
        calculateTemperatureFilters(temperature, intensity) {
          const filters = {};
          const hueRotation = this.mapTemperatureToHue(temperature);
          filters["--organic-temperature-hue-shift"] = `${hueRotation}deg`;
          const saturation = Math.max(0.8, Math.min(1.5, 1 + (intensity - 0.5) * 0.4));
          filters["--organic-temperature-saturation"] = saturation.toString();
          const brightness = this.mapTemperatureToBrightness(temperature);
          filters["--organic-temperature-brightness"] = brightness.toString();
          return filters;
        }
        /**
         * Map temperature to hue rotation (-30 to +30 degrees)
         */
        mapTemperatureToHue(temperature) {
          if (temperature <= 4e3) {
            return -15 + (4e3 - temperature) / (4e3 - 2e3) * -15;
          } else if (temperature >= 8e3) {
            return 10 + (temperature - 8e3) / (15e3 - 8e3) * 20;
          } else {
            return -5 + (temperature - 4e3) / (8e3 - 4e3) * 15;
          }
        }
        /**
         * Map temperature to brightness adjustment (0.8-1.2)
         */
        mapTemperatureToBrightness(temperature) {
          const normalized = (temperature - 2e3) / (15e3 - 2e3);
          return 0.9 + normalized * 0.3;
        }
        /**
         * Apply emotional temperature to an element via CSS class and variables
         */
        applyEmotionalTemperature(element, result) {
          const existingClasses = Array.from(element.classList).filter(
            (cls) => cls.startsWith("organic-emotion-")
          );
          element.classList.remove(...existingClasses);
          element.classList.add(result.cssClass);
          if (result.secondaryEmotion) {
            element.classList.add(`organic-emotion-blend-${result.secondaryEmotion}`);
          }
          Object.entries(result.cssVariables).forEach(([property, value]) => {
            element.style.setProperty(property, value);
          });
          if (this.enableDebug) {
            console.log("\u{1F3A8} [EmotionalTemperatureMapper] Applied emotional temperature:", {
              element: element.tagName,
              emotion: result.primaryEmotion,
              secondary: result.secondaryEmotion,
              intensity: result.intensity,
              temperature: result.temperature
            });
          }
        }
        /**
         * Get all available emotional states
         */
        static getAvailableEmotions() {
          return Object.keys(EMOTIONAL_TEMPERATURE_MAP);
        }
        /**
         * Get emotion characteristics for a specific state
         */
        static getEmotionCharacteristics(emotion) {
          return EMOTIONAL_TEMPERATURE_MAP[emotion];
        }
      };
      __name(_EmotionalTemperatureMapper, "EmotionalTemperatureMapper");
      EmotionalTemperatureMapper = _EmotionalTemperatureMapper;
    }
  });

  // src-js/visual/organic-consciousness/integration/MusicEmotionAnalyzer.ts
  var _MusicEmotionAnalyzer, MusicEmotionAnalyzer, _ValenceEnergyMapper, ValenceEnergyMapper, _AudioFeatureAnalyzer, AudioFeatureAnalyzer, _TemperatureCalculator, TemperatureCalculator, _ConsciousnessDetector, ConsciousnessDetector;
  var init_MusicEmotionAnalyzer = __esm({
    "src-js/visual/organic-consciousness/integration/MusicEmotionAnalyzer.ts"() {
      "use strict";
      _MusicEmotionAnalyzer = class _MusicEmotionAnalyzer {
        constructor(config = {}) {
          this.initialized = false;
          this.emotionHistory = [];
          this.currentEmotion = null;
          this.emotionCache = /* @__PURE__ */ new Map();
          // Subscribers for emotion updates
          this.emotionSubscribers = /* @__PURE__ */ new Set();
          this.config = {
            emotionSensitivity: 0.7,
            confidenceThreshold: 0.6,
            smoothingFactor: 0.3,
            memoryDecay: 0.1,
            consciousnessAwareness: true,
            organicFlowDetection: true,
            cinematicAnalysis: true,
            analysisInterval: 500,
            // 2Hz analysis rate
            cacheSize: 100,
            ...config
          };
          this.valenceEnergyMapper = new ValenceEnergyMapper();
          this.audioFeatureAnalyzer = new AudioFeatureAnalyzer();
          this.temperatureCalculator = new TemperatureCalculator();
          this.consciousnessDetector = new ConsciousnessDetector();
        }
        // ===== SYSTEM LIFECYCLE =====
        async initialize() {
          if (this.initialized) return;
          try {
            await this.valenceEnergyMapper.initialize();
            await this.audioFeatureAnalyzer.initialize();
            await this.temperatureCalculator.initialize();
            if (this.config.consciousnessAwareness) {
              await this.consciousnessDetector.initialize();
            }
            this.initialized = true;
            console.log(
              "\u{1F3B5} MusicEmotionAnalyzer initialized with consciousness awareness"
            );
          } catch (error) {
            console.error("\u274C Failed to initialize MusicEmotionAnalyzer:", error);
            throw error;
          }
        }
        updateAnimation(_deltaTime) {
        }
        async healthCheck() {
          const issues = [];
          if (!this.initialized) {
            issues.push("MusicEmotionAnalyzer not initialized");
          }
          if (this.emotionHistory.length === 0) {
            issues.push("No emotion analysis history available");
          }
          if (this.currentEmotion && this.currentEmotion.confidence < this.config.confidenceThreshold) {
            issues.push(
              `Low emotion confidence: ${this.currentEmotion.confidence.toFixed(2)}`
            );
          }
          return {
            healthy: issues.length === 0,
            issues,
            metrics: {
              emotionHistorySize: this.emotionHistory.length,
              currentConfidence: this.currentEmotion?.confidence ?? 0,
              subscriberCount: this.emotionSubscribers.size,
              cacheSize: this.emotionCache.size
            }
          };
        }
        destroy() {
          this.emotionSubscribers.clear();
          this.emotionHistory = [];
          this.emotionCache.clear();
          this.currentEmotion = null;
          this.initialized = false;
        }
        // ===== PUBLIC API =====
        /**
         * Analyze audio features and extract emotional state
         */
        async analyzeEmotion(audioFeatures, audioData) {
          if (!this.initialized) {
            throw new Error(
              "MusicEmotionAnalyzer must be initialized before analysis"
            );
          }
          try {
            const cacheKey = this.createCacheKey(audioFeatures);
            if (this.emotionCache.has(cacheKey)) {
              const cachedEmotion = this.emotionCache.get(cacheKey);
              if (cachedEmotion) {
                this.updateCurrentEmotion(cachedEmotion);
                return cachedEmotion;
              }
            }
            const emotion = await this.performEmotionAnalysis(
              audioFeatures,
              audioData
            );
            this.cacheEmotion(cacheKey, emotion);
            this.updateCurrentEmotion(emotion);
            this.notifyEmotionUpdate(emotion);
            return emotion;
          } catch (error) {
            console.error("\u274C Error analyzing emotion:", error);
            return this.createNeutralEmotion(audioFeatures);
          }
        }
        /**
         * Get current emotional state
         */
        getCurrentEmotion() {
          return this.currentEmotion;
        }
        /**
         * Get emotion analysis history
         */
        getEmotionHistory(limit) {
          if (limit) {
            return this.emotionHistory.slice(-limit);
          }
          return [...this.emotionHistory];
        }
        /**
         * Subscribe to emotion updates
         */
        onEmotionUpdate(callback) {
          this.emotionSubscribers.add(callback);
          return () => {
            this.emotionSubscribers.delete(callback);
          };
        }
        /**
         * Update analysis configuration
         */
        updateConfig(newConfig) {
          this.config = { ...this.config, ...newConfig };
        }
        // ===== PRIVATE ANALYSIS METHODS =====
        async performEmotionAnalysis(audioFeatures, audioData) {
          const musicalCharacteristics = this.audioFeatureAnalyzer.extractCharacteristics(audioFeatures);
          const baseEmotion = this.valenceEnergyMapper.mapToEmotion(
            audioFeatures.valence,
            audioFeatures.energy,
            musicalCharacteristics
          );
          const colorTemperature = this.temperatureCalculator.calculateTemperature(
            baseEmotion,
            musicalCharacteristics
          );
          let consciousnessMetrics = {};
          if (this.config.consciousnessAwareness) {
            consciousnessMetrics = await this.consciousnessDetector.analyze(
              audioFeatures,
              musicalCharacteristics,
              audioData
            );
          }
          const smoothedEmotion = this.applyTemporalSmoothing(
            baseEmotion,
            musicalCharacteristics
          );
          const emotionalState = {
            primary: smoothedEmotion.primary,
            secondary: smoothedEmotion.secondary,
            intensity: smoothedEmotion.intensity,
            confidence: smoothedEmotion.confidence,
            valence: audioFeatures.valence,
            arousal: audioFeatures.energy,
            dominance: this.calculateDominance(audioFeatures, musicalCharacteristics),
            colorTemperature,
            timestamp: Date.now(),
            duration: this.calculateEmotionDuration(
              smoothedEmotion,
              musicalCharacteristics
            ),
            musicalCharacteristics: {
              ...musicalCharacteristics,
              organicFlow: consciousnessMetrics.organicFlow ?? musicalCharacteristics.organicFlow,
              cinematicDepth: consciousnessMetrics.cinematicDepth ?? musicalCharacteristics.cinematicDepth,
              consciousnessResonance: consciousnessMetrics.consciousnessResonance ?? 0.5
            }
          };
          return emotionalState;
        }
        applyTemporalSmoothing(baseEmotion, musicalCharacteristics) {
          if (!this.currentEmotion || this.config.smoothingFactor === 0) {
            return baseEmotion;
          }
          const smoothingFactor = this.config.smoothingFactor;
          const smoothedIntensity = baseEmotion.intensity * (1 - smoothingFactor) + this.currentEmotion.intensity * smoothingFactor;
          const smoothedConfidence = baseEmotion.confidence * (1 - smoothingFactor) + this.currentEmotion.confidence * smoothingFactor;
          const primary = baseEmotion.confidence > this.config.confidenceThreshold ? baseEmotion.primary : this.currentEmotion.primary;
          return {
            primary,
            secondary: baseEmotion.secondary,
            intensity: smoothedIntensity,
            confidence: smoothedConfidence
          };
        }
        calculateDominance(audioFeatures, characteristics) {
          const tempoFactor = Math.min(characteristics.tempo / 140, 1);
          const energyFactor = audioFeatures.energy;
          const loudnessFactor = Math.min((audioFeatures.loudness + 60) / 60, 1);
          return tempoFactor * 0.3 + energyFactor * 0.4 + loudnessFactor * 0.3;
        }
        calculateEmotionDuration(emotion, characteristics) {
          const baseDuration = 2e3;
          const tempoMultiplier = 6e4 / characteristics.tempo;
          const stabilityMultiplier = emotion.confidence * 2;
          return Math.min(
            baseDuration * tempoMultiplier * stabilityMultiplier,
            1e4
          );
        }
        createCacheKey(audioFeatures) {
          const precision = 100;
          return [
            Math.round(audioFeatures.valence * precision),
            Math.round(audioFeatures.energy * precision),
            Math.round(audioFeatures.danceability * precision),
            Math.round(audioFeatures.acousticness * precision),
            audioFeatures.key,
            audioFeatures.mode
          ].join("-");
        }
        cacheEmotion(key, emotion) {
          if (this.emotionCache.size >= this.config.cacheSize) {
            const firstKey = this.emotionCache.keys().next().value;
            if (firstKey !== void 0) {
              this.emotionCache.delete(firstKey);
            }
          }
          this.emotionCache.set(key, emotion);
        }
        updateCurrentEmotion(emotion) {
          this.currentEmotion = emotion;
          this.emotionHistory.push(emotion);
          if (this.emotionHistory.length > 1e3) {
            this.emotionHistory = this.emotionHistory.slice(-500);
          }
        }
        notifyEmotionUpdate(emotion) {
          this.emotionSubscribers.forEach((callback) => {
            try {
              callback(emotion);
            } catch (error) {
              console.error("\u274C Error in emotion subscriber callback:", error);
            }
          });
        }
        createNeutralEmotion(audioFeatures) {
          return {
            primary: "serenity",
            secondary: [],
            intensity: 0.5,
            confidence: 0.3,
            valence: audioFeatures.valence ?? 0.5,
            arousal: audioFeatures.energy ?? 0.5,
            dominance: 0.5,
            colorTemperature: 6500,
            // Neutral daylight temperature
            timestamp: Date.now(),
            duration: 3e3,
            musicalCharacteristics: this.audioFeatureAnalyzer.extractCharacteristics(audioFeatures)
          };
        }
      };
      __name(_MusicEmotionAnalyzer, "MusicEmotionAnalyzer");
      MusicEmotionAnalyzer = _MusicEmotionAnalyzer;
      _ValenceEnergyMapper = class _ValenceEnergyMapper {
        async initialize() {
        }
        mapToEmotion(valence, energy, characteristics) {
          let primary;
          let secondary = [];
          let intensity;
          let confidence = 0.8;
          if (valence >= 0.6 && energy >= 0.6) {
            primary = characteristics.danceability > 0.7 ? "excitement" : "joy";
            secondary = ["joy", "excitement"];
            intensity = Math.min(valence + energy - 0.2, 1);
          } else if (valence >= 0.6 && energy < 0.4) {
            primary = characteristics.acousticness > 0.6 ? "serenity" : "love";
            secondary = ["serenity", "love"];
            intensity = valence * 0.8;
          } else if (valence < 0.4 && energy >= 0.6) {
            primary = characteristics.mode === 0 ? "anger" : "fear";
            secondary = ["anger", "fear"];
            intensity = energy;
          } else if (valence < 0.4 && energy < 0.4) {
            primary = characteristics.acousticness > 0.5 ? "melancholy" : "sadness";
            secondary = ["sadness", "melancholy"];
            intensity = (1 - valence) * 0.8;
          } else {
            if (characteristics.instrumentalness > 0.8) {
              primary = "transcendence";
              secondary = ["transcendence", "consciousness"];
            } else {
              primary = "nostalgia";
              secondary = ["nostalgia"];
            }
            intensity = Math.abs(valence - 0.5) + Math.abs(energy - 0.5);
            confidence = 0.6;
          }
          if (characteristics.organicFlow > 0.8) {
            secondary.push("organic-flow");
          }
          if (characteristics.consciousnessResonance > 0.7) {
            secondary.push("consciousness");
          }
          return { primary, secondary, intensity, confidence };
        }
      };
      __name(_ValenceEnergyMapper, "ValenceEnergyMapper");
      ValenceEnergyMapper = _ValenceEnergyMapper;
      _AudioFeatureAnalyzer = class _AudioFeatureAnalyzer {
        async initialize() {
        }
        extractCharacteristics(audioFeatures) {
          return {
            tempo: audioFeatures.tempo,
            key: audioFeatures.key,
            mode: audioFeatures.mode,
            timeSignature: audioFeatures.timeSignature,
            energy: audioFeatures.energy,
            danceability: audioFeatures.danceability,
            acousticness: audioFeatures.acousticness,
            instrumentalness: audioFeatures.instrumentalness,
            liveness: audioFeatures.liveness,
            speechiness: audioFeatures.speechiness,
            // Calculate consciousness-specific metrics
            organicFlow: this.calculateOrganicFlow(audioFeatures),
            cinematicDepth: this.calculateCinematicDepth(audioFeatures),
            consciousnessResonance: this.calculateConsciousnessResonance(audioFeatures)
          };
        }
        calculateOrganicFlow(features) {
          const acousticWeight = features.acousticness * 0.4;
          const tempoWeight = (1 - Math.min(features.tempo / 140, 1)) * 0.3;
          const energyWeight = (1 - features.energy) * 0.2;
          const danceWeight = features.danceability * 0.1;
          return Math.min(
            acousticWeight + tempoWeight + energyWeight + danceWeight,
            1
          );
        }
        calculateCinematicDepth(features) {
          const instrumentalWeight = features.instrumentalness * 0.4;
          const liveWeight = (1 - features.liveness) * 0.2;
          const speechWeight = (1 - features.speechiness) * 0.2;
          const energyWeight = Math.abs(features.energy - 0.5) * 0.2;
          return Math.min(
            instrumentalWeight + liveWeight + speechWeight + energyWeight,
            1
          );
        }
        calculateConsciousnessResonance(features) {
          const valenceBalance = 1 - Math.abs(features.valence - 0.5) * 2;
          const energyBalance = 1 - Math.abs(features.energy - 0.4) * 2;
          const instrumentalWeight = features.instrumentalness * 0.3;
          const acousticWeight = features.acousticness * 0.2;
          return Math.max(
            0,
            (valenceBalance + energyBalance) * 0.5 + instrumentalWeight + acousticWeight
          );
        }
      };
      __name(_AudioFeatureAnalyzer, "AudioFeatureAnalyzer");
      AudioFeatureAnalyzer = _AudioFeatureAnalyzer;
      _TemperatureCalculator = class _TemperatureCalculator {
        async initialize() {
        }
        calculateTemperature(emotion, characteristics) {
          let baseTemperature;
          switch (emotion.primary) {
            case "joy":
            case "excitement":
              baseTemperature = 8e3;
              break;
            case "love":
            case "serenity":
              baseTemperature = 3e3;
              break;
            case "anger":
              baseTemperature = 15e3;
              break;
            case "fear":
              baseTemperature = 12e3;
              break;
            case "sadness":
            case "melancholy":
              baseTemperature = 2e3;
              break;
            case "nostalgia":
              baseTemperature = 2500;
              break;
            case "transcendence":
            case "consciousness":
              baseTemperature = 6500;
              break;
            case "organic-flow":
              baseTemperature = 4e3;
              break;
            default:
              baseTemperature = 6500;
          }
          const intensityAdjustment = (emotion.intensity - 0.5) * 2e3;
          const tempoAdjustment = (characteristics.tempo - 120) * 10;
          const energyAdjustment = (characteristics.energy - 0.5) * 1e3;
          const finalTemperature = baseTemperature + intensityAdjustment + tempoAdjustment + energyAdjustment;
          return Math.max(1e3, Math.min(2e4, finalTemperature));
        }
      };
      __name(_TemperatureCalculator, "TemperatureCalculator");
      TemperatureCalculator = _TemperatureCalculator;
      _ConsciousnessDetector = class _ConsciousnessDetector {
        async initialize() {
        }
        async analyze(audioFeatures, characteristics, audioData) {
          let organicFlow = characteristics.organicFlow;
          let cinematicDepth = characteristics.cinematicDepth;
          let consciousnessResonance = characteristics.consciousnessResonance;
          if (audioData?.waveform) {
            const waveformAnalysis = this.analyzeWaveformPatterns(audioData.waveform);
            organicFlow = Math.min(
              1,
              organicFlow + waveformAnalysis.smoothness * 0.2
            );
            cinematicDepth = Math.min(
              1,
              cinematicDepth + waveformAnalysis.dynamicRange * 0.3
            );
            consciousnessResonance = Math.min(
              1,
              consciousnessResonance + waveformAnalysis.harmonicComplexity * 0.2
            );
          }
          return {
            organicFlow,
            cinematicDepth,
            consciousnessResonance
          };
        }
        analyzeWaveformPatterns(waveform) {
          let smoothness = 0;
          let dynamicRange = 0;
          let harmonicComplexity = 0;
          if (waveform.length > 1) {
            let totalVariation = 0;
            for (let i = 1; i < waveform.length; i++) {
              const current = waveform[i];
              const previous = waveform[i - 1];
              if (current !== void 0 && previous !== void 0) {
                totalVariation += Math.abs(current - previous);
              }
            }
            smoothness = 1 - Math.min(totalVariation / waveform.length, 1);
            const max = Math.max(...waveform);
            const min = Math.min(...waveform);
            dynamicRange = max - min;
            harmonicComplexity = Math.min(this.estimateHarmonicContent(waveform), 1);
          }
          return { smoothness, dynamicRange, harmonicComplexity };
        }
        estimateHarmonicContent(waveform) {
          let zeroCrossings = 0;
          for (let i = 1; i < waveform.length; i++) {
            const current = waveform[i];
            const previous = waveform[i - 1];
            if (current !== void 0 && previous !== void 0) {
              if (current >= 0 !== previous >= 0) {
                zeroCrossings++;
              }
            }
          }
          return Math.min(zeroCrossings / (waveform.length * 0.1), 1);
        }
      };
      __name(_ConsciousnessDetector, "ConsciousnessDetector");
      ConsciousnessDetector = _ConsciousnessDetector;
    }
  });

  // src-js/audio/GenreGradientEvolution.ts
  var _GenreGradientEvolution, GenreGradientEvolution;
  var init_GenreGradientEvolution = __esm({
    "src-js/audio/GenreGradientEvolution.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _GenreGradientEvolution = class _GenreGradientEvolution {
        constructor(cssConsciousnessController, musicSyncService = null, emotionalGradientMapper = null, settingsManager = null) {
          this.musicSyncService = null;
          this.emotionalGradientMapper = null;
          this.settingsManager = null;
          this.currentGenre = "unknown";
          this.genreConfidence = 0;
          this.genreHistory = [];
          this.maxHistorySize = 30;
          this.genreAnalysisBuffer = [];
          this.bufferSize = 100;
          // Analyze 100 frames for genre detection
          this.isActive = false;
          this.boundSpectralHandler = null;
          this.boundEmotionalHandler = null;
          // Genre characteristic profiles
          this.genreProfiles = {
            electronic: {
              bassEmphasis: 0.8,
              midFrequencyPattern: 0.6,
              trebleSharpness: 0.9,
              dynamicRange: 0.7,
              rhythmComplexity: 0.6,
              syncopation: 0.4,
              grooveWeight: 0.7,
              tempoVariability: 0.3,
              harmonicComplexity: 0.5,
              dissonanceTolerance: 0.6,
              modalInfluence: 0.4,
              microtonal: 0.2,
              compression: 0.8,
              saturation: 0.6,
              stereoWidth: 0.8,
              artificialProcessing: 0.9,
              organicness: 0.2,
              accessibility: 0.6,
              experimentalFactor: 0.7,
              emotionalRange: 0.6
            },
            rock: {
              bassEmphasis: 0.7,
              midFrequencyPattern: 0.8,
              trebleSharpness: 0.7,
              dynamicRange: 0.8,
              rhythmComplexity: 0.6,
              syncopation: 0.3,
              grooveWeight: 0.8,
              tempoVariability: 0.4,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.3,
              microtonal: 0.1,
              compression: 0.6,
              saturation: 0.7,
              stereoWidth: 0.7,
              artificialProcessing: 0.4,
              organicness: 0.6,
              accessibility: 0.8,
              experimentalFactor: 0.4,
              emotionalRange: 0.8
            },
            classical: {
              bassEmphasis: 0.5,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.6,
              dynamicRange: 0.9,
              rhythmComplexity: 0.8,
              syncopation: 0.2,
              grooveWeight: 0.4,
              tempoVariability: 0.7,
              harmonicComplexity: 0.9,
              dissonanceTolerance: 0.4,
              modalInfluence: 0.6,
              microtonal: 0.3,
              compression: 0.3,
              saturation: 0.2,
              stereoWidth: 0.8,
              artificialProcessing: 0.1,
              organicness: 0.9,
              accessibility: 0.4,
              experimentalFactor: 0.6,
              emotionalRange: 0.9
            },
            jazz: {
              bassEmphasis: 0.6,
              midFrequencyPattern: 0.8,
              trebleSharpness: 0.5,
              dynamicRange: 0.8,
              rhythmComplexity: 0.9,
              syncopation: 0.8,
              grooveWeight: 0.9,
              tempoVariability: 0.6,
              harmonicComplexity: 0.9,
              dissonanceTolerance: 0.7,
              modalInfluence: 0.8,
              microtonal: 0.4,
              compression: 0.4,
              saturation: 0.3,
              stereoWidth: 0.7,
              artificialProcessing: 0.2,
              organicness: 0.8,
              accessibility: 0.5,
              experimentalFactor: 0.8,
              emotionalRange: 0.8
            },
            "hip-hop": {
              bassEmphasis: 0.9,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.8,
              dynamicRange: 0.6,
              rhythmComplexity: 0.7,
              syncopation: 0.6,
              grooveWeight: 0.9,
              tempoVariability: 0.3,
              harmonicComplexity: 0.4,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.3,
              microtonal: 0.1,
              compression: 0.8,
              saturation: 0.6,
              stereoWidth: 0.6,
              artificialProcessing: 0.7,
              organicness: 0.4,
              accessibility: 0.8,
              experimentalFactor: 0.5,
              emotionalRange: 0.7
            },
            ambient: {
              bassEmphasis: 0.4,
              midFrequencyPattern: 0.5,
              trebleSharpness: 0.3,
              dynamicRange: 0.9,
              rhythmComplexity: 0.2,
              syncopation: 0.1,
              grooveWeight: 0.2,
              tempoVariability: 0.8,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.6,
              modalInfluence: 0.7,
              microtonal: 0.5,
              compression: 0.5,
              saturation: 0.4,
              stereoWidth: 0.9,
              artificialProcessing: 0.6,
              organicness: 0.7,
              accessibility: 0.3,
              experimentalFactor: 0.8,
              emotionalRange: 0.6
            },
            pop: {
              bassEmphasis: 0.6,
              midFrequencyPattern: 0.8,
              trebleSharpness: 0.7,
              dynamicRange: 0.6,
              rhythmComplexity: 0.4,
              syncopation: 0.3,
              grooveWeight: 0.7,
              tempoVariability: 0.2,
              harmonicComplexity: 0.5,
              dissonanceTolerance: 0.3,
              modalInfluence: 0.2,
              microtonal: 0.1,
              compression: 0.8,
              saturation: 0.5,
              stereoWidth: 0.6,
              artificialProcessing: 0.5,
              organicness: 0.5,
              accessibility: 0.9,
              experimentalFactor: 0.2,
              emotionalRange: 0.7
            },
            metal: {
              bassEmphasis: 0.8,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.9,
              dynamicRange: 0.7,
              rhythmComplexity: 0.7,
              syncopation: 0.4,
              grooveWeight: 0.8,
              tempoVariability: 0.3,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.8,
              modalInfluence: 0.5,
              microtonal: 0.2,
              compression: 0.7,
              saturation: 0.9,
              stereoWidth: 0.7,
              artificialProcessing: 0.6,
              organicness: 0.4,
              accessibility: 0.6,
              experimentalFactor: 0.5,
              emotionalRange: 0.8
            },
            folk: {
              bassEmphasis: 0.4,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.5,
              dynamicRange: 0.7,
              rhythmComplexity: 0.4,
              syncopation: 0.2,
              grooveWeight: 0.6,
              tempoVariability: 0.5,
              harmonicComplexity: 0.5,
              dissonanceTolerance: 0.3,
              modalInfluence: 0.6,
              microtonal: 0.2,
              compression: 0.3,
              saturation: 0.2,
              stereoWidth: 0.5,
              artificialProcessing: 0.1,
              organicness: 0.9,
              accessibility: 0.7,
              experimentalFactor: 0.3,
              emotionalRange: 0.7
            },
            funk: {
              bassEmphasis: 0.9,
              midFrequencyPattern: 0.8,
              trebleSharpness: 0.6,
              dynamicRange: 0.7,
              rhythmComplexity: 0.8,
              syncopation: 0.9,
              grooveWeight: 1,
              tempoVariability: 0.4,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.4,
              microtonal: 0.2,
              compression: 0.6,
              saturation: 0.5,
              stereoWidth: 0.6,
              artificialProcessing: 0.3,
              organicness: 0.7,
              accessibility: 0.7,
              experimentalFactor: 0.4,
              emotionalRange: 0.6
            },
            indie: {
              bassEmphasis: 0.5,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.6,
              dynamicRange: 0.7,
              rhythmComplexity: 0.6,
              syncopation: 0.4,
              grooveWeight: 0.6,
              tempoVariability: 0.5,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.5,
              microtonal: 0.3,
              compression: 0.5,
              saturation: 0.4,
              stereoWidth: 0.7,
              artificialProcessing: 0.3,
              organicness: 0.7,
              accessibility: 0.6,
              experimentalFactor: 0.6,
              emotionalRange: 0.7
            },
            reggae: {
              bassEmphasis: 0.8,
              midFrequencyPattern: 0.6,
              trebleSharpness: 0.5,
              dynamicRange: 0.6,
              rhythmComplexity: 0.5,
              syncopation: 0.7,
              grooveWeight: 0.8,
              tempoVariability: 0.3,
              harmonicComplexity: 0.4,
              dissonanceTolerance: 0.3,
              modalInfluence: 0.4,
              microtonal: 0.2,
              compression: 0.6,
              saturation: 0.4,
              stereoWidth: 0.6,
              artificialProcessing: 0.3,
              organicness: 0.6,
              accessibility: 0.7,
              experimentalFactor: 0.3,
              emotionalRange: 0.6
            },
            blues: {
              bassEmphasis: 0.6,
              midFrequencyPattern: 0.8,
              trebleSharpness: 0.6,
              dynamicRange: 0.8,
              rhythmComplexity: 0.5,
              syncopation: 0.4,
              grooveWeight: 0.8,
              tempoVariability: 0.6,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.4,
              modalInfluence: 0.7,
              microtonal: 0.3,
              compression: 0.4,
              saturation: 0.5,
              stereoWidth: 0.5,
              artificialProcessing: 0.2,
              organicness: 0.8,
              accessibility: 0.7,
              experimentalFactor: 0.4,
              emotionalRange: 0.8
            },
            country: {
              bassEmphasis: 0.5,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.6,
              dynamicRange: 0.7,
              rhythmComplexity: 0.4,
              syncopation: 0.3,
              grooveWeight: 0.6,
              tempoVariability: 0.4,
              harmonicComplexity: 0.4,
              dissonanceTolerance: 0.2,
              modalInfluence: 0.3,
              microtonal: 0.1,
              compression: 0.5,
              saturation: 0.3,
              stereoWidth: 0.6,
              artificialProcessing: 0.2,
              organicness: 0.8,
              accessibility: 0.8,
              experimentalFactor: 0.2,
              emotionalRange: 0.7
            },
            techno: {
              bassEmphasis: 0.9,
              midFrequencyPattern: 0.5,
              trebleSharpness: 0.8,
              dynamicRange: 0.5,
              rhythmComplexity: 0.6,
              syncopation: 0.3,
              grooveWeight: 0.8,
              tempoVariability: 0.2,
              harmonicComplexity: 0.4,
              dissonanceTolerance: 0.6,
              modalInfluence: 0.3,
              microtonal: 0.3,
              compression: 0.9,
              saturation: 0.7,
              stereoWidth: 0.8,
              artificialProcessing: 1,
              organicness: 0.1,
              accessibility: 0.5,
              experimentalFactor: 0.6,
              emotionalRange: 0.5
            },
            house: {
              bassEmphasis: 0.8,
              midFrequencyPattern: 0.6,
              trebleSharpness: 0.7,
              dynamicRange: 0.6,
              rhythmComplexity: 0.5,
              syncopation: 0.4,
              grooveWeight: 0.9,
              tempoVariability: 0.2,
              harmonicComplexity: 0.5,
              dissonanceTolerance: 0.4,
              modalInfluence: 0.3,
              microtonal: 0.2,
              compression: 0.8,
              saturation: 0.6,
              stereoWidth: 0.7,
              artificialProcessing: 0.8,
              organicness: 0.3,
              accessibility: 0.8,
              experimentalFactor: 0.4,
              emotionalRange: 0.6
            },
            trance: {
              bassEmphasis: 0.7,
              midFrequencyPattern: 0.7,
              trebleSharpness: 0.8,
              dynamicRange: 0.8,
              rhythmComplexity: 0.5,
              syncopation: 0.2,
              grooveWeight: 0.7,
              tempoVariability: 0.3,
              harmonicComplexity: 0.6,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.4,
              microtonal: 0.3,
              compression: 0.7,
              saturation: 0.5,
              stereoWidth: 0.9,
              artificialProcessing: 0.8,
              organicness: 0.2,
              accessibility: 0.6,
              experimentalFactor: 0.5,
              emotionalRange: 0.8
            },
            dubstep: {
              bassEmphasis: 1,
              midFrequencyPattern: 0.5,
              trebleSharpness: 0.9,
              dynamicRange: 0.9,
              rhythmComplexity: 0.7,
              syncopation: 0.6,
              grooveWeight: 0.8,
              tempoVariability: 0.4,
              harmonicComplexity: 0.4,
              dissonanceTolerance: 0.8,
              modalInfluence: 0.3,
              microtonal: 0.4,
              compression: 0.8,
              saturation: 0.8,
              stereoWidth: 0.8,
              artificialProcessing: 0.9,
              organicness: 0.1,
              accessibility: 0.4,
              experimentalFactor: 0.7,
              emotionalRange: 0.6
            },
            unknown: {
              bassEmphasis: 0.5,
              midFrequencyPattern: 0.5,
              trebleSharpness: 0.5,
              dynamicRange: 0.5,
              rhythmComplexity: 0.5,
              syncopation: 0.5,
              grooveWeight: 0.5,
              tempoVariability: 0.5,
              harmonicComplexity: 0.5,
              dissonanceTolerance: 0.5,
              modalInfluence: 0.5,
              microtonal: 0.5,
              compression: 0.5,
              saturation: 0.5,
              stereoWidth: 0.5,
              artificialProcessing: 0.5,
              organicness: 0.5,
              accessibility: 0.5,
              experimentalFactor: 0.5,
              emotionalRange: 0.5
            }
          };
          // Genre visual style profiles
          this.genreVisualStyles = {
            electronic: {
              primaryHueRange: [180, 270],
              saturationProfile: [0.8, 0.3],
              brightnessProfile: [1.1, 0.4],
              contrastLevel: 0.8,
              gradientComplexity: 0.8,
              shapeGeometry: "geometric",
              edgeSharpness: 0.9,
              symmetryLevel: 0.7,
              animationStyle: "rhythmic",
              pulseBehavior: "steady",
              flowDirection: "linear",
              transitionCharacter: "mechanical",
              layerBlending: "contrasting",
              depthIllusion: 0.6,
              particleInfluence: 0.8,
              nebulaCharacter: "structured",
              memoryInfluence: 0.3,
              adaptationSpeed: 0.8,
              stabilityPreference: 0.6,
              emergencePattern: "sudden"
            },
            rock: {
              primaryHueRange: [330, 30],
              saturationProfile: [1.2, 0.5],
              brightnessProfile: [1.2, 0.3],
              contrastLevel: 0.9,
              gradientComplexity: 0.7,
              shapeGeometry: "hybrid",
              edgeSharpness: 0.7,
              symmetryLevel: 0.5,
              animationStyle: "rhythmic",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "sharp",
              layerBlending: "harmonious",
              depthIllusion: 0.7,
              particleInfluence: 0.6,
              nebulaCharacter: "dense",
              memoryInfluence: 0.4,
              adaptationSpeed: 0.7,
              stabilityPreference: 0.7,
              emergencePattern: "gradual"
            },
            classical: {
              primaryHueRange: [45, 135],
              saturationProfile: [0.6, 0.4],
              brightnessProfile: [1, 0.5],
              contrastLevel: 0.6,
              gradientComplexity: 0.9,
              shapeGeometry: "organic",
              edgeSharpness: 0.3,
              symmetryLevel: 0.8,
              animationStyle: "smooth",
              pulseBehavior: "subtle",
              flowDirection: "spiral",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.9,
              particleInfluence: 0.4,
              nebulaCharacter: "ethereal",
              memoryInfluence: 0.8,
              adaptationSpeed: 0.3,
              stabilityPreference: 0.9,
              emergencePattern: "progressive"
            },
            jazz: {
              primaryHueRange: [30, 90],
              saturationProfile: [0.7, 0.6],
              brightnessProfile: [0.9, 0.6],
              contrastLevel: 0.7,
              gradientComplexity: 0.8,
              shapeGeometry: "abstract",
              edgeSharpness: 0.5,
              symmetryLevel: 0.3,
              animationStyle: "chaotic",
              pulseBehavior: "syncopated",
              flowDirection: "random",
              transitionCharacter: "organic",
              layerBlending: "complementary",
              depthIllusion: 0.8,
              particleInfluence: 0.7,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.6,
              adaptationSpeed: 0.6,
              stabilityPreference: 0.4,
              emergencePattern: "cyclical"
            },
            "hip-hop": {
              primaryHueRange: [270, 330],
              saturationProfile: [1, 0.4],
              brightnessProfile: [1.1, 0.3],
              contrastLevel: 0.8,
              gradientComplexity: 0.6,
              shapeGeometry: "geometric",
              edgeSharpness: 0.8,
              symmetryLevel: 0.6,
              animationStyle: "rhythmic",
              pulseBehavior: "syncopated",
              flowDirection: "linear",
              transitionCharacter: "sharp",
              layerBlending: "contrasting",
              depthIllusion: 0.5,
              particleInfluence: 0.9,
              nebulaCharacter: "structured",
              memoryInfluence: 0.2,
              adaptationSpeed: 0.9,
              stabilityPreference: 0.5,
              emergencePattern: "sudden"
            },
            ambient: {
              primaryHueRange: [180, 240],
              saturationProfile: [0.4, 0.3],
              brightnessProfile: [0.8, 0.4],
              contrastLevel: 0.3,
              gradientComplexity: 0.9,
              shapeGeometry: "organic",
              edgeSharpness: 0.2,
              symmetryLevel: 0.4,
              animationStyle: "minimal",
              pulseBehavior: "subtle",
              flowDirection: "spiral",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.9,
              particleInfluence: 0.3,
              nebulaCharacter: "ethereal",
              memoryInfluence: 0.9,
              adaptationSpeed: 0.1,
              stabilityPreference: 0.9,
              emergencePattern: "gradual"
            },
            pop: {
              primaryHueRange: [300, 60],
              saturationProfile: [1.1, 0.3],
              brightnessProfile: [1.2, 0.2],
              contrastLevel: 0.7,
              gradientComplexity: 0.6,
              shapeGeometry: "hybrid",
              edgeSharpness: 0.6,
              symmetryLevel: 0.7,
              animationStyle: "rhythmic",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.6,
              particleInfluence: 0.5,
              nebulaCharacter: "dense",
              memoryInfluence: 0.5,
              adaptationSpeed: 0.7,
              stabilityPreference: 0.8,
              emergencePattern: "gradual"
            },
            metal: {
              primaryHueRange: [0, 30],
              saturationProfile: [0.9, 0.4],
              brightnessProfile: [0.7, 0.4],
              contrastLevel: 1,
              gradientComplexity: 0.7,
              shapeGeometry: "geometric",
              edgeSharpness: 0.9,
              symmetryLevel: 0.6,
              animationStyle: "chaotic",
              pulseBehavior: "irregular",
              flowDirection: "radial",
              transitionCharacter: "sharp",
              layerBlending: "clashing",
              depthIllusion: 0.8,
              particleInfluence: 0.7,
              nebulaCharacter: "dense",
              memoryInfluence: 0.3,
              adaptationSpeed: 0.8,
              stabilityPreference: 0.3,
              emergencePattern: "sudden"
            },
            folk: {
              primaryHueRange: [60, 120],
              saturationProfile: [0.6, 0.3],
              brightnessProfile: [0.9, 0.3],
              contrastLevel: 0.5,
              gradientComplexity: 0.5,
              shapeGeometry: "organic",
              edgeSharpness: 0.3,
              symmetryLevel: 0.5,
              animationStyle: "smooth",
              pulseBehavior: "subtle",
              flowDirection: "spiral",
              transitionCharacter: "organic",
              layerBlending: "harmonious",
              depthIllusion: 0.6,
              particleInfluence: 0.3,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.7,
              adaptationSpeed: 0.4,
              stabilityPreference: 0.8,
              emergencePattern: "progressive"
            },
            funk: {
              primaryHueRange: [30, 90],
              saturationProfile: [1, 0.5],
              brightnessProfile: [1, 0.4],
              contrastLevel: 0.8,
              gradientComplexity: 0.7,
              shapeGeometry: "abstract",
              edgeSharpness: 0.6,
              symmetryLevel: 0.4,
              animationStyle: "rhythmic",
              pulseBehavior: "syncopated",
              flowDirection: "random",
              transitionCharacter: "organic",
              layerBlending: "complementary",
              depthIllusion: 0.7,
              particleInfluence: 0.8,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.4,
              adaptationSpeed: 0.8,
              stabilityPreference: 0.5,
              emergencePattern: "cyclical"
            },
            indie: {
              primaryHueRange: [120, 240],
              saturationProfile: [0.7, 0.4],
              brightnessProfile: [0.9, 0.4],
              contrastLevel: 0.6,
              gradientComplexity: 0.7,
              shapeGeometry: "hybrid",
              edgeSharpness: 0.4,
              symmetryLevel: 0.5,
              animationStyle: "smooth",
              pulseBehavior: "steady",
              flowDirection: "spiral",
              transitionCharacter: "fluid",
              layerBlending: "complementary",
              depthIllusion: 0.7,
              particleInfluence: 0.5,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.6,
              adaptationSpeed: 0.5,
              stabilityPreference: 0.7,
              emergencePattern: "progressive"
            },
            reggae: {
              primaryHueRange: [90, 150],
              saturationProfile: [0.8, 0.3],
              brightnessProfile: [1, 0.3],
              contrastLevel: 0.6,
              gradientComplexity: 0.5,
              shapeGeometry: "organic",
              edgeSharpness: 0.4,
              symmetryLevel: 0.6,
              animationStyle: "rhythmic",
              pulseBehavior: "syncopated",
              flowDirection: "linear",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.5,
              particleInfluence: 0.4,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.6,
              adaptationSpeed: 0.5,
              stabilityPreference: 0.7,
              emergencePattern: "cyclical"
            },
            blues: {
              primaryHueRange: [200, 260],
              saturationProfile: [0.6, 0.4],
              brightnessProfile: [0.8, 0.4],
              contrastLevel: 0.6,
              gradientComplexity: 0.6,
              shapeGeometry: "organic",
              edgeSharpness: 0.4,
              symmetryLevel: 0.4,
              animationStyle: "smooth",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.7,
              particleInfluence: 0.4,
              nebulaCharacter: "ethereal",
              memoryInfluence: 0.7,
              adaptationSpeed: 0.4,
              stabilityPreference: 0.8,
              emergencePattern: "progressive"
            },
            country: {
              primaryHueRange: [30, 90],
              saturationProfile: [0.7, 0.3],
              brightnessProfile: [1, 0.3],
              contrastLevel: 0.5,
              gradientComplexity: 0.5,
              shapeGeometry: "organic",
              edgeSharpness: 0.3,
              symmetryLevel: 0.6,
              animationStyle: "smooth",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "organic",
              layerBlending: "harmonious",
              depthIllusion: 0.5,
              particleInfluence: 0.3,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.7,
              adaptationSpeed: 0.4,
              stabilityPreference: 0.8,
              emergencePattern: "gradual"
            },
            techno: {
              primaryHueRange: [240, 300],
              saturationProfile: [1, 0.4],
              brightnessProfile: [1.1, 0.3],
              contrastLevel: 0.9,
              gradientComplexity: 0.6,
              shapeGeometry: "geometric",
              edgeSharpness: 1,
              symmetryLevel: 0.8,
              animationStyle: "rhythmic",
              pulseBehavior: "steady",
              flowDirection: "linear",
              transitionCharacter: "mechanical",
              layerBlending: "contrasting",
              depthIllusion: 0.5,
              particleInfluence: 0.9,
              nebulaCharacter: "structured",
              memoryInfluence: 0.2,
              adaptationSpeed: 0.9,
              stabilityPreference: 0.4,
              emergencePattern: "sudden"
            },
            house: {
              primaryHueRange: [300, 360],
              saturationProfile: [0.9, 0.3],
              brightnessProfile: [1.1, 0.3],
              contrastLevel: 0.7,
              gradientComplexity: 0.6,
              shapeGeometry: "hybrid",
              edgeSharpness: 0.7,
              symmetryLevel: 0.7,
              animationStyle: "rhythmic",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.6,
              particleInfluence: 0.7,
              nebulaCharacter: "dense",
              memoryInfluence: 0.4,
              adaptationSpeed: 0.7,
              stabilityPreference: 0.6,
              emergencePattern: "gradual"
            },
            trance: {
              primaryHueRange: [180, 270],
              saturationProfile: [0.8, 0.5],
              brightnessProfile: [1, 0.5],
              contrastLevel: 0.7,
              gradientComplexity: 0.8,
              shapeGeometry: "abstract",
              edgeSharpness: 0.5,
              symmetryLevel: 0.6,
              animationStyle: "smooth",
              pulseBehavior: "steady",
              flowDirection: "spiral",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.8,
              particleInfluence: 0.6,
              nebulaCharacter: "ethereal",
              memoryInfluence: 0.6,
              adaptationSpeed: 0.5,
              stabilityPreference: 0.7,
              emergencePattern: "progressive"
            },
            dubstep: {
              primaryHueRange: [120, 180],
              saturationProfile: [1.2, 0.6],
              brightnessProfile: [1.1, 0.6],
              contrastLevel: 1,
              gradientComplexity: 0.8,
              shapeGeometry: "geometric",
              edgeSharpness: 0.9,
              symmetryLevel: 0.5,
              animationStyle: "chaotic",
              pulseBehavior: "irregular",
              flowDirection: "random",
              transitionCharacter: "sharp",
              layerBlending: "clashing",
              depthIllusion: 0.7,
              particleInfluence: 1,
              nebulaCharacter: "structured",
              memoryInfluence: 0.2,
              adaptationSpeed: 1,
              stabilityPreference: 0.2,
              emergencePattern: "sudden"
            },
            unknown: {
              primaryHueRange: [0, 360],
              saturationProfile: [0.7, 0.3],
              brightnessProfile: [1, 0.3],
              contrastLevel: 0.6,
              gradientComplexity: 0.6,
              shapeGeometry: "hybrid",
              edgeSharpness: 0.5,
              symmetryLevel: 0.5,
              animationStyle: "smooth",
              pulseBehavior: "steady",
              flowDirection: "radial",
              transitionCharacter: "fluid",
              layerBlending: "harmonious",
              depthIllusion: 0.6,
              particleInfluence: 0.5,
              nebulaCharacter: "wispy",
              memoryInfluence: 0.5,
              adaptationSpeed: 0.5,
              stabilityPreference: 0.6,
              emergencePattern: "gradual"
            }
          };
          this.cssConsciousnessController = cssConsciousnessController;
          this.musicSyncService = musicSyncService;
          this.emotionalGradientMapper = emotionalGradientMapper;
          this.settingsManager = settingsManager;
          this.boundSpectralHandler = this.handleSpectralData.bind(this);
          this.boundEmotionalHandler = this.handleEmotionalData.bind(this);
        }
        async initialize() {
          if (this.boundSpectralHandler) {
            document.addEventListener("music-sync:spectral-data", this.boundSpectralHandler);
          }
          if (this.boundEmotionalHandler) {
            document.addEventListener("emotional-gradient:profile-updated", this.boundEmotionalHandler);
          }
          this.isActive = true;
          Y3K?.debug?.log("GenreGradientEvolution", "Genre-responsive gradient evolution system initialized");
        }
        handleSpectralData(event) {
          if (!this.isActive) return;
          const customEvent = event;
          const spectralData = customEvent.detail;
          if (!spectralData) return;
          this.genreAnalysisBuffer.push(spectralData);
          if (this.genreAnalysisBuffer.length > this.bufferSize) {
            this.genreAnalysisBuffer.shift();
          }
          if (this.genreAnalysisBuffer.length >= this.bufferSize) {
            this.analyzeGenre();
          }
        }
        handleEmotionalData(event) {
          if (!this.isActive) return;
          this.updateVisualEvolution();
        }
        analyzeGenre() {
          if (this.genreAnalysisBuffer.length === 0) return;
          const avgSpectralData = this.calculateAverageSpectralData();
          const genreScores = {};
          for (const genre of Object.keys(this.genreProfiles)) {
            genreScores[genre] = this.calculateGenreSimilarity(avgSpectralData, this.genreProfiles[genre]);
          }
          const sortedGenres = Object.entries(genreScores).sort(([, a], [, b]) => b - a);
          const bestMatch = sortedGenres[0];
          if (bestMatch) {
            const [bestGenre, bestScore] = bestMatch;
            this.updateGenreDetection(bestGenre, bestScore);
          }
        }
        calculateAverageSpectralData() {
          const sum = this.genreAnalysisBuffer.reduce((acc, data) => ({
            bassLevel: acc.bassLevel + data.bassLevel,
            midLevel: acc.midLevel + data.midLevel,
            trebleLevel: acc.trebleLevel + data.trebleLevel,
            vocalLevel: acc.vocalLevel + data.vocalLevel,
            harmonicResonance: acc.harmonicResonance + data.harmonicResonance,
            tonalCenterStrength: acc.tonalCenterStrength + data.tonalCenterStrength,
            dissonanceLevel: acc.dissonanceLevel + data.dissonanceLevel,
            temporalPhase: acc.temporalPhase + data.temporalPhase,
            predictedBeatTime: acc.predictedBeatTime + data.predictedBeatTime,
            structuralPosition: acc.structuralPosition + data.structuralPosition,
            emotionalValence: acc.emotionalValence + data.emotionalValence,
            energyLevel: acc.energyLevel + data.energyLevel,
            tensionLevel: acc.tensionLevel + data.tensionLevel,
            stellarDrift: acc.stellarDrift + data.stellarDrift,
            quantumCoherence: acc.quantumCoherence + data.quantumCoherence,
            consciousnessLevel: acc.consciousnessLevel + data.consciousnessLevel
          }), {
            bassLevel: 0,
            midLevel: 0,
            trebleLevel: 0,
            vocalLevel: 0,
            harmonicResonance: 0,
            tonalCenterStrength: 0,
            dissonanceLevel: 0,
            temporalPhase: 0,
            predictedBeatTime: 0,
            structuralPosition: 0,
            emotionalValence: 0,
            energyLevel: 0,
            tensionLevel: 0,
            stellarDrift: 0,
            quantumCoherence: 0,
            consciousnessLevel: 0
          });
          const count = this.genreAnalysisBuffer.length;
          return {
            bassLevel: sum.bassLevel / count,
            midLevel: sum.midLevel / count,
            trebleLevel: sum.trebleLevel / count,
            vocalLevel: sum.vocalLevel / count,
            harmonicResonance: sum.harmonicResonance / count,
            tonalCenterStrength: sum.tonalCenterStrength / count,
            dissonanceLevel: sum.dissonanceLevel / count,
            temporalPhase: sum.temporalPhase / count,
            predictedBeatTime: sum.predictedBeatTime / count,
            structuralPosition: sum.structuralPosition / count,
            emotionalValence: sum.emotionalValence / count,
            energyLevel: sum.energyLevel / count,
            tensionLevel: sum.tensionLevel / count,
            stellarDrift: sum.stellarDrift / count,
            quantumCoherence: sum.quantumCoherence / count,
            consciousnessLevel: sum.consciousnessLevel / count
          };
        }
        calculateGenreSimilarity(spectralData, genreProfile) {
          const weights = {
            frequency: 0.3,
            // Bass, mid, treble patterns
            rhythm: 0.25,
            // Complexity, syncopation, groove
            harmony: 0.2,
            // Harmonic complexity, dissonance
            production: 0.15,
            // Compression, saturation, processing
            cultural: 0.1
            // Organicness, accessibility, experimental
          };
          const freqSimilarity = 1 - Math.abs(
            spectralData.bassLevel - genreProfile.bassEmphasis + (spectralData.midLevel - genreProfile.midFrequencyPattern) + (spectralData.trebleLevel - genreProfile.trebleSharpness)
          ) / 3;
          const rhythmSimilarity = 1 - Math.abs(
            spectralData.energyLevel - genreProfile.rhythmComplexity + (spectralData.tensionLevel - genreProfile.syncopation)
          ) / 2;
          const harmonySimilarity = 1 - Math.abs(
            spectralData.harmonicResonance - genreProfile.harmonicComplexity + (spectralData.dissonanceLevel - genreProfile.dissonanceTolerance)
          ) / 2;
          const productionSimilarity = 1 - Math.abs(
            spectralData.energyLevel - genreProfile.compression + (spectralData.tonalCenterStrength - genreProfile.saturation)
          ) / 2;
          const culturalSimilarity = 1 - Math.abs(
            spectralData.emotionalValence - genreProfile.accessibility + (spectralData.consciousnessLevel - genreProfile.experimentalFactor)
          ) / 2;
          return freqSimilarity * weights.frequency + rhythmSimilarity * weights.rhythm + harmonySimilarity * weights.harmony + productionSimilarity * weights.production + culturalSimilarity * weights.cultural;
        }
        updateGenreDetection(detectedGenre, score) {
          const timestamp = performance.now();
          this.genreHistory.push({ genre: detectedGenre, confidence: score, timestamp });
          if (this.genreHistory.length > this.maxHistorySize) {
            this.genreHistory.shift();
          }
          const recentHistory = this.genreHistory.slice(-10);
          const genreConsensus = this.calculateGenreConsensus(recentHistory);
          if (genreConsensus.confidence > 0.6 && (genreConsensus.genre !== this.currentGenre || genreConsensus.confidence > this.genreConfidence)) {
            this.currentGenre = genreConsensus.genre;
            this.genreConfidence = genreConsensus.confidence;
            Y3K?.debug?.log("GenreGradientEvolution", `Genre detected: ${this.currentGenre} (confidence: ${this.genreConfidence.toFixed(2)})`);
            this.updateVisualEvolution();
            document.dispatchEvent(new CustomEvent("genre-gradient:genre-detected", {
              detail: { genre: this.currentGenre, confidence: this.genreConfidence }
            }));
          }
        }
        calculateGenreConsensus(history) {
          const genreWeights = {};
          history.forEach((entry, index) => {
            const timeWeight = (index + 1) / history.length;
            const totalWeight = entry.confidence * timeWeight;
            genreWeights[entry.genre] = (genreWeights[entry.genre] || 0) + totalWeight;
          });
          let bestGenre = "unknown";
          let bestScore = 0;
          for (const [genre, weight] of Object.entries(genreWeights)) {
            if (weight !== void 0 && weight > bestScore) {
              bestScore = weight;
              bestGenre = genre;
            }
          }
          return { genre: bestGenre, confidence: bestScore / history.length };
        }
        updateVisualEvolution() {
          if (this.currentGenre === "unknown") return;
          const genreStyle = this.genreVisualStyles[this.currentGenre];
          const emotionalProfile = this.emotionalGradientMapper?.getCurrentEmotionalProfile() || null;
          this.applyGenreVisualStyle(genreStyle, emotionalProfile);
        }
        applyGenreVisualStyle(style, emotionalProfile) {
          const hueRange = style.primaryHueRange[1] - style.primaryHueRange[0];
          const baseHue = style.primaryHueRange[0] + hueRange * 0.5;
          const emotionalHueShift = emotionalProfile ? (emotionalProfile.valence - 0.5) * hueRange * 0.3 : 0;
          this.cssConsciousnessController.setProperty("--sn-genre-base-hue", `${baseHue + emotionalHueShift}deg`);
          this.cssConsciousnessController.setProperty("--sn-genre-hue-range", `${hueRange}deg`);
          const emotionalSatBoost = emotionalProfile ? emotionalProfile.arousal * 0.3 : 0;
          const emotionalBrightBoost = emotionalProfile ? emotionalProfile.energy * 0.2 : 0;
          this.cssConsciousnessController.setProperty("--sn-genre-saturation-base", (style.saturationProfile[0] + emotionalSatBoost).toString());
          this.cssConsciousnessController.setProperty("--sn-genre-saturation-variation", style.saturationProfile[1].toString());
          this.cssConsciousnessController.setProperty("--sn-genre-brightness-base", (style.brightnessProfile[0] + emotionalBrightBoost).toString());
          this.cssConsciousnessController.setProperty("--sn-genre-brightness-variation", style.brightnessProfile[1].toString());
          this.cssConsciousnessController.setProperty("--sn-genre-contrast-level", style.contrastLevel.toString());
          this.cssConsciousnessController.setProperty("--sn-genre-edge-sharpness", style.edgeSharpness.toString());
          this.cssConsciousnessController.setProperty("--sn-genre-gradient-complexity", style.gradientComplexity.toString());
          const emotionalSpeedMod = emotionalProfile ? 0.5 + emotionalProfile.energy : 1;
          this.cssConsciousnessController.setProperty("--sn-genre-animation-speed", emotionalSpeedMod.toString());
          this.cssConsciousnessController.setProperty("--sn-genre-pulse-intensity", style.depthIllusion.toString());
          const layerHarmony = this.mapLayerBlending(style.layerBlending);
          this.cssConsciousnessController.setProperty("--sn-genre-layer-harmony", layerHarmony.toString());
          this.cssConsciousnessController.setProperty("--sn-genre-depth-illusion", style.depthIllusion.toString());
          this.cssConsciousnessController.setProperty("--sn-genre-particle-influence", style.particleInfluence.toString());
          this.cssConsciousnessController.setProperty("--sn-genre-memory-influence", style.memoryInfluence.toString());
          this.cssConsciousnessController.setProperty("--sn-genre-adaptation-speed", style.adaptationSpeed.toString());
          this.cssConsciousnessController.setProperty("--sn-genre-stability-preference", style.stabilityPreference.toString());
          this.cssConsciousnessController.setProperty("--sn-current-genre", this.currentGenre);
          this.cssConsciousnessController.setProperty("--sn-genre-confidence", this.genreConfidence.toString());
          this.updateGenreGradientCoordination(style, emotionalProfile);
        }
        /**
         * Coordinate genre-specific modifications with the consolidated --sn-bg-gradient-* system
         */
        updateGenreGradientCoordination(style, emotionalProfile) {
          const rootStyle = getComputedStyle(document.documentElement);
          const currentPrimary = rootStyle.getPropertyValue("--sn-bg-gradient-primary").trim();
          const currentSecondary = rootStyle.getPropertyValue("--sn-bg-gradient-secondary").trim();
          const currentAccent = rootStyle.getPropertyValue("--sn-bg-gradient-accent").trim();
          if (currentPrimary || currentSecondary || currentAccent) {
            const emotionalSpeedMod = emotionalProfile ? 0.5 + emotionalProfile.energy : 1;
            const genreAngle = this.calculateGenreAngle(style);
            this.cssConsciousnessController.setProperty("--sn-bg-gradient-angle", `${genreAngle}deg`);
            const genreOpacity = this.calculateGenreOpacity(style, emotionalProfile);
            this.cssConsciousnessController.setProperty("--sn-bg-gradient-opacity", genreOpacity.toString());
            const genreBlur = Math.max(60, 120 * (1 - style.edgeSharpness));
            this.cssConsciousnessController.setProperty("--sn-bg-gradient-blur", `${genreBlur}px`);
            const emotionalSatBoost = emotionalProfile ? emotionalProfile.arousal * 0.3 : 0;
            const emotionalBrightBoost = emotionalProfile ? emotionalProfile.energy * 0.2 : 0;
            this.cssConsciousnessController.setProperty("--sn-bg-gradient-saturation", (style.saturationProfile[0] + emotionalSatBoost).toString());
            this.cssConsciousnessController.setProperty("--sn-bg-gradient-brightness", (style.brightnessProfile[0] + emotionalBrightBoost).toString());
            this.cssConsciousnessController.setProperty("--sn-bg-gradient-contrast", style.contrastLevel.toString());
            Y3K?.debug?.log("GenreGradientEvolution", `Coordinated genre "${this.currentGenre}" modifications with gradient system: angle=${genreAngle}\xB0, opacity=${genreOpacity}`);
          }
        }
        /**
         * Calculate gradient angle based on genre characteristics
         */
        calculateGenreAngle(style) {
          const genreAngles = {
            electronic: 135,
            // Digital diagonal flow
            rock: 45,
            // Bold upward energy
            classical: 90,
            // Elegant vertical flow
            jazz: 120,
            // Complex angular flow
            "hip-hop": 0,
            // Horizontal urban flow
            ambient: 180,
            // Ethereal downward flow
            pop: 315,
            // Catchy diagonal up-right
            metal: 225,
            // Aggressive diagonal down
            folk: 60,
            // Natural organic angle
            funk: 30,
            // Groovy slight angle
            indie: 150,
            // Alternative angle
            reggae: 210,
            // Laid-back flow
            blues: 270,
            // Deep downward emotion
            country: 45,
            // Simple upward angle
            techno: 135,
            // Digital diagonal
            house: 315,
            // Dance energy up-right
            trance: 90,
            // Uplifting vertical
            dubstep: 180,
            // Heavy downward
            unknown: 45
            // Default diagonal
          };
          return genreAngles[this.currentGenre] || 45;
        }
        /**
         * Calculate gradient opacity based on genre and emotional characteristics
         */
        calculateGenreOpacity(style, emotionalProfile) {
          let baseOpacity = 0.8;
          switch (this.currentGenre) {
            case "ambient":
            case "classical":
              baseOpacity = 0.6;
              break;
            case "metal":
            case "rock":
            case "dubstep":
              baseOpacity = 0.9;
              break;
            case "jazz":
            case "blues":
              baseOpacity = 0.75;
              break;
            default:
              baseOpacity = 0.8;
          }
          if (emotionalProfile) {
            baseOpacity *= 0.7 + emotionalProfile.energy * 0.3;
          }
          return Math.max(0.3, Math.min(1, baseOpacity));
        }
        mapLayerBlending(blending) {
          switch (blending) {
            case "harmonious":
              return 0.9;
            case "complementary":
              return 0.7;
            case "contrasting":
              return 0.5;
            case "clashing":
              return 0.3;
            default:
              return 0.7;
          }
        }
        getCurrentGenre() {
          return this.currentGenre;
        }
        getGenreConfidence() {
          return this.genreConfidence;
        }
        getGenreHistory() {
          return [...this.genreHistory];
        }
        setGenreOverride(genre, duration = 1e4) {
          this.currentGenre = genre;
          this.genreConfidence = 1;
          this.updateVisualEvolution();
          Y3K?.debug?.log("GenreGradientEvolution", `Genre override: ${genre} for ${duration}ms`);
          setTimeout(() => {
            this.genreConfidence = 0;
            Y3K?.debug?.log("GenreGradientEvolution", "Genre override expired, returning to automatic detection");
          }, duration);
        }
        getGenreCharacteristics(genre) {
          return this.genreProfiles[genre || this.currentGenre];
        }
        getGenreVisualStyle(genre) {
          return this.genreVisualStyles[genre || this.currentGenre];
        }
        destroy() {
          this.isActive = false;
          if (this.boundSpectralHandler) {
            document.removeEventListener("music-sync:spectral-data", this.boundSpectralHandler);
          }
          if (this.boundEmotionalHandler) {
            document.removeEventListener("emotional-gradient:profile-updated", this.boundEmotionalHandler);
          }
          this.genreAnalysisBuffer = [];
          this.genreHistory = [];
          Y3K?.debug?.log("GenreGradientEvolution", "Genre evolution system destroyed");
        }
      };
      __name(_GenreGradientEvolution, "GenreGradientEvolution");
      GenreGradientEvolution = _GenreGradientEvolution;
    }
  });

  // src-js/audio/ColorHarmonyEngine.ts
  var _ColorHarmonyEngine, ColorHarmonyEngine;
  var init_ColorHarmonyEngine = __esm({
    "src-js/audio/ColorHarmonyEngine.ts"() {
      "use strict";
      init_settingKeys();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_ColorOrchestrator();
      init_PaletteExtensionManager();
      init_Year3000Utilities();
      init_SemanticColorManager();
      init_BaseVisualSystem();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      init_MusicEmotionAnalyzer();
      init_GenreGradientEvolution();
      _ColorHarmonyEngine = class _ColorHarmonyEngine extends BaseVisualSystem {
        constructor(config, utils, performanceMonitor, settingsManager) {
          super(
            config,
            utils || Year3000Utilities_exports,
            performanceMonitor,
            null,
            // No direct music service dependency
            settingsManager || null
          );
          this.emergentEngine = null;
          // User-specified harmonic intensity (0-1). Multiplies defaultBlendRatio.
          this.userIntensity = 0.7;
          this.evolutionEnabled = true;
          this._evolutionTimer = null;
          // Timer ref for debounce
          this._pendingPaletteRefresh = null;
          // Track last applied genre to avoid redundant palette refreshes
          this._lastGenre = null;
          this.systemName = "ColorHarmonyEngine";
          this.paletteExtensionManager = new PaletteExtensionManager(
            this.config,
            this.utils
          );
          this.semanticColorManager = new SemanticColorManager({
            enableDebug: this.config.enableDebug,
            fallbackToSpiceColors: true,
            cacheDuration: 5e3
          });
          this.currentTheme = this.detectCurrentTheme();
          if (config && typeof config.harmonicIntensity === "number" && Number.isFinite(config.harmonicIntensity)) {
            const clamped = Math.max(
              0,
              Math.min(1, config.harmonicIntensity)
            );
            this.userIntensity = clamped;
          }
          this.harmonyMetrics = {
            totalHarmonyCalculations: 0,
            musicInfluencedAdjustments: 0,
            temporalMemoryEvents: 0,
            performance: []
          };
          this.musicalMemory = {
            recentTracks: [],
            userColorPreferences: /* @__PURE__ */ new Map(),
            energyHistory: [],
            maxMemorySize: 50
          };
          this.kineticState = {
            currentPulse: 0,
            breathingPhase: 0,
            lastBeatTime: 0,
            visualMomentum: 0
          };
          this.catppuccinPalettes = {
            frappe: {
              accents: {
                rosewater: "#f2d5cf",
                flamingo: "#eebebe",
                pink: "#f4b8e4",
                mauve: "#ca9ee6",
                red: "#e78284",
                maroon: "#ea999c",
                peach: "#ef9f76",
                yellow: "#e5c890",
                green: "#a6d189",
                teal: "#81c8be",
                sky: "#99d1db",
                sapphire: "#85c1dc",
                blue: "#8caaee",
                lavender: "#babbf1"
              },
              neutrals: {
                base: "#303446",
                surface0: "#414559",
                surface1: "#51576d",
                surface2: "#626880"
              }
            },
            latte: {
              accents: {
                rosewater: "#dc8a78",
                flamingo: "#dd7878",
                pink: "#ea76cb",
                mauve: "#8839ef",
                red: "#d20f39",
                maroon: "#e64553",
                peach: "#fe640b",
                yellow: "#df8e1d",
                green: "#40a02b",
                teal: "#179299",
                sky: "#04a5e5",
                sapphire: "#209fb5",
                blue: "#1e66f5",
                lavender: "#7287fd"
              },
              neutrals: {
                base: "#eff1f5",
                surface0: "#e6e9ef",
                surface1: "#dce0e8",
                surface2: "#c5c9d1"
              }
            },
            macchiato: {
              accents: {
                rosewater: "#f4dbd6",
                flamingo: "#f0c6c6",
                pink: "#f5bde6",
                mauve: "#c6a0f6",
                red: "#ed8796",
                maroon: "#ee99a0",
                peach: "#f5a97f",
                yellow: "#eed49f",
                green: "#a6da95",
                teal: "#8bd5ca",
                sky: "#91d7e3",
                sapphire: "#7dc4e4",
                blue: "#8aadf4",
                lavender: "#b7bdf8"
              },
              neutrals: {
                base: "#24273a",
                surface0: "#363a4f",
                surface1: "#494d64",
                surface2: "#5b6078"
              }
            },
            mocha: {
              accents: {
                rosewater: "#f5e0dc",
                flamingo: "#f2cdcd",
                pink: "#f5c2e7",
                mauve: "#cba6f7",
                red: "#f38ba8",
                maroon: "#eba0ac",
                peach: "#fab387",
                yellow: "#f9e2af",
                green: "#a6e3a1",
                teal: "#94e2d5",
                sky: "#89dceb",
                sapphire: "#74c7ec",
                blue: "#89b4fa",
                lavender: "#b4befe"
              },
              neutrals: {
                base: "#1e1e2e",
                surface0: "#313244",
                surface1: "#45475a",
                surface2: "#585b70"
              }
            }
          };
          this.vibrancyConfig = {
            defaultBlendRatio: 0.95,
            // BOLD! 95% extracted color dominance (was 0.85)
            minimumSaturation: 0.3,
            // 🔧 FIXED: Allow muted colors (was 0.6 - too restrictive!)
            maximumDesaturation: 0.2,
            // 🔧 FIXED: Allow more desaturated colors (was 0.05 - too strict!)
            contrastBoostIntensity: 2.2,
            // STRONGER CONTRAST! Up from 1.8
            harmonyTolerance: 0.5,
            // 🔧 FIXED: More flexible harmony (was 0.35 - too restrictive!)
            // 🎨 NEW: Artistic Enhancement Factors
            artisticSaturationBoost: 1.2,
            // 20% saturation enhancement for extracted colors
            cosmicLuminanceBoost: 1.15,
            // 15% luminance boost for cosmic presence
            energyResponsiveness: 0.8,
            // How much music energy affects color intensity
            // 🌟 Dynamic Blending Based on Artistic Mode
            getBlendRatio(artisticMode = "artist-vision") {
              const ratios = {
                "corporate-safe": 0.75,
                // Conservative: 75% extracted
                "artist-vision": 0.95,
                // Bold: 95% extracted
                "cosmic-maximum": 0.98
                // Maximum: 98% extracted!
              };
              return ratios[artisticMode] || this.defaultBlendRatio;
            }
          };
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Initialized with Year 3000 Quantum Empathy"
            );
          }
          if (config && typeof config.harmonicEvolution === "boolean") {
            this.evolutionEnabled = config.harmonicEvolution;
          }
          this.emotionalTemperatureMapper = new EmotionalTemperatureMapper(this.config.enableDebug);
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.musicEmotionAnalyzer = new MusicEmotionAnalyzer({
            emotionSensitivity: 0.7,
            confidenceThreshold: 0.6,
            consciousnessAwareness: true,
            organicFlowDetection: true,
            cinematicAnalysis: true,
            analysisInterval: 500
            // 2Hz analysis rate
          });
          this.genreGradientEvolution = new GenreGradientEvolution(
            void 0,
            // cssConsciousnessController will be set during initialize()
            null,
            // musicSyncService will be injected if available
            null,
            // emotionalGradientMapper will be injected if available
            this.settingsManager
          );
          this.oklabState = {
            currentPreset: OKLABColorProcessor.PRESETS.STANDARD,
            processedPalette: {},
            perceptualGradientCache: /* @__PURE__ */ new Map(),
            colorHarmonyCache: /* @__PURE__ */ new Map(),
            lastProcessingTime: 0
          };
          this.emotionalState = {
            currentEmotion: null,
            emotionHistory: [],
            lastEmotionUpdate: 0,
            emotionInfluenceIntensity: 0.8
            // Strong emotion influence by default
          };
          this.genreState = {
            currentGenre: "unknown",
            genreConfidence: 0,
            genreHistory: [],
            lastGenreUpdate: 0,
            genreInfluenceIntensity: 0.7
            // Moderate genre influence by default
          };
          this._boundSettingsChangeHandler = this._handleSettingsChange.bind(this);
          this._boundArtisticModeHandler = this._handleArtisticModeChanged.bind(this);
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this._boundSettingsChangeHandler
          );
          document.addEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          if (this.evolutionEnabled) {
            this._startEvolutionLoop();
          }
        }
        // Unified implementation
        updateAnimation(timestampOrDelta, maybeDelta) {
          const delta = maybeDelta ?? timestampOrDelta;
          this.onAnimate(delta);
        }
        // TODO: Implement proper onAnimate method for Year 3000 per-frame updates
        onAnimate(deltaMs) {
          this._updateCSSVariables(deltaMs);
          this._calculateBeatPulse(deltaMs);
          unifiedEventBus.emitSync("performance:frame", {
            deltaTime: deltaMs,
            fps: 60,
            memoryUsage: performance.memory?.usedJSHeapSize || 0,
            timestamp: performance.now()
          });
        }
        // 🔧 PHASE 2: Emit harmony state instead of applying CSS directly
        _updateCSSVariables(deltaMs) {
          const harmonyVariables = {
            "--sn-harmony-energy": this.kineticState.visualMomentum.toFixed(3),
            "--sn-harmony-pulse": this.kineticState.currentPulse.toFixed(3),
            "--sn-harmony-breathing-phase": (Math.sin(this.kineticState.breathingPhase) * 0.5 + 0.5).toFixed(3)
          };
          if (this.kineticState.musicIntensityMultiplier !== void 0) {
            harmonyVariables["--sn-harmony-intensity"] = this.kineticState.musicIntensityMultiplier.toFixed(3);
          }
          if (this.kineticState.valenceGravity !== void 0) {
            harmonyVariables["--sn-harmony-valence"] = this.kineticState.valenceGravity.toFixed(3);
          }
          if (this.kineticState.beatPhase !== void 0) {
            harmonyVariables["--sn-harmony-beat-phase"] = this.kineticState.beatPhase.toFixed(3);
          }
          if (this.kineticState.hueShift !== void 0) {
            harmonyVariables["--sn-harmony-hue-shift"] = `${this.kineticState.hueShift.toFixed(1)}deg`;
          }
          const glow = Math.max(0, Math.min(1, this.kineticState.currentPulse * 1.2));
          harmonyVariables["--sn-text-glow-intensity"] = glow.toFixed(3);
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: harmonyVariables,
            timestamp: Date.now()
          });
        }
        // TODO: Private method for calculating beat pulse effects
        _calculateBeatPulse(deltaMs) {
          this.kineticState.currentPulse *= Math.pow(0.95, deltaMs / 16.67);
          this.kineticState.breathingPhase += deltaMs / 1e3 * 0.5;
          if (this.kineticState.breathingPhase > 2 * Math.PI) {
            this.kineticState.breathingPhase -= 2 * Math.PI;
          }
        }
        async initialize() {
          await super.initialize();
          const cssConsciousnessController = this.performanceMonitor ? this.performanceMonitor.cssConsciousnessController : void 0;
          this.semanticColorManager.initialize(cssConsciousnessController);
          unifiedEventBus.subscribe("colors:extracted", this.handleColorExtraction.bind(this), "ColorHarmonyEngine");
          try {
            globalColorOrchestrator.registerStrategy(this);
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [ColorHarmonyEngine] Registered with ColorOrchestrator as strategy processor.");
            }
          } catch (error) {
            console.warn("\u{1F3A8} [ColorHarmonyEngine] Failed to register with ColorOrchestrator:", error);
          }
          try {
            await this.musicEmotionAnalyzer.initialize();
            this.musicEmotionAnalyzer.onEmotionUpdate((emotion) => {
              this.handleEmotionUpdate(emotion);
            });
            if (this.config.enableDebug) {
              console.log("\u{1F3AD} [ColorHarmonyEngine] MusicEmotionAnalyzer initialized with consciousness awareness");
            }
          } catch (error) {
            console.warn("\u{1F3AD} [ColorHarmonyEngine] Failed to initialize MusicEmotionAnalyzer:", error);
          }
          try {
            await this.genreGradientEvolution.initialize();
            if (this.config.enableDebug) {
              console.log("\u{1F3B6} [ColorHarmonyEngine] GenreGradientEvolution initialized with aesthetic intelligence");
            }
          } catch (error) {
            console.warn("\u{1F3B6} [ColorHarmonyEngine] Failed to initialize GenreGradientEvolution:", error);
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Initialized with Year 3000 Quantum Empathy via BaseVisualSystem and SemanticColorManager."
            );
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Subscribed to 'colors/extracted' events for strategy pattern processing."
            );
          }
          this.initialized = true;
        }
        /**
         * Handle emotion updates from MusicEmotionAnalyzer
         * Updates emotional state and triggers consciousness-aware color processing
         */
        handleEmotionUpdate(emotion) {
          if (!this.initialized) return;
          try {
            this.emotionalState.currentEmotion = emotion;
            this.emotionalState.emotionHistory.push(emotion);
            this.emotionalState.lastEmotionUpdate = Date.now();
            if (this.emotionalState.emotionHistory.length > 50) {
              this.emotionalState.emotionHistory = this.emotionalState.emotionHistory.slice(-25);
            }
            unifiedEventBus.emit("emotion:analyzed", {
              emotion,
              colorTemperature: emotion.colorTemperature,
              consciousnessLevel: emotion.musicalCharacteristics.consciousnessResonance,
              organicFlow: emotion.musicalCharacteristics.organicFlow,
              cinematicDepth: emotion.musicalCharacteristics.cinematicDepth,
              timestamp: emotion.timestamp
            });
            if (this.config.enableDebug) {
              console.log(`\u{1F3AD} [ColorHarmonyEngine] Emotion updated: ${emotion.primary} (intensity: ${emotion.intensity.toFixed(2)}, confidence: ${emotion.confidence.toFixed(2)})`);
            }
            this.triggerEmotionalColorUpdate(emotion);
          } catch (error) {
            console.error("\u{1F3AD} [ColorHarmonyEngine] Error handling emotion update:", error);
          }
        }
        /**
         * Trigger color update based on emotional state
         */
        triggerEmotionalColorUpdate(emotion) {
          if (this.emotionalState.emotionInfluenceIntensity > 0 && emotion.confidence > 0.6) {
            if (this._pendingPaletteRefresh) {
              clearTimeout(this._pendingPaletteRefresh);
            }
            this._pendingPaletteRefresh = setTimeout(() => {
              this.refreshPaletteWithEmotion(emotion);
              this._pendingPaletteRefresh = null;
            }, 100);
          }
        }
        /**
         * Refresh palette with emotional influence
         */
        async refreshPaletteWithEmotion(emotion) {
          try {
            const emotionalContext = {
              primaryEmotion: emotion.primary,
              emotionIntensity: emotion.intensity,
              colorTemperature: emotion.colorTemperature,
              valence: emotion.valence,
              arousal: emotion.arousal,
              dominance: emotion.dominance,
              organicFlow: emotion.musicalCharacteristics.organicFlow,
              cinematicDepth: emotion.musicalCharacteristics.cinematicDepth,
              consciousnessResonance: emotion.musicalCharacteristics.consciousnessResonance
            };
            unifiedEventBus.emit("emotionalColorContext:updated", emotionalContext);
            if (this.config.enableDebug) {
              console.log(`\u{1F3AD} [ColorHarmonyEngine] Refreshing colors with ${emotion.primary} emotion influence`);
            }
          } catch (error) {
            console.error("\u{1F3AD} [ColorHarmonyEngine] Error refreshing palette with emotion:", error);
          }
        }
        async healthCheck() {
          if (!this.catppuccinPalettes[this.currentTheme]) {
            return {
              healthy: false,
              ok: false,
              details: `Current theme '${this.currentTheme}' not found in palettes.`,
              issues: [`Current theme '${this.currentTheme}' not found in palettes.`],
              system: "ColorHarmonyEngine"
            };
          }
          return {
            healthy: true,
            ok: true,
            details: "Palettes are loaded correctly.",
            issues: [],
            system: "ColorHarmonyEngine"
          };
        }
        // ============================================================================
        // IColorProcessor Strategy Pattern Implementation
        // ============================================================================
        /**
         * Process colors according to Catppuccin harmony strategy with enhanced OKLAB integration
         * Implements the Strategy pattern for color processing with comprehensive system utilization
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const { rawColors, trackUri, musicData } = context;
            const optimalPreset = this.determineOptimalOKLABPreset(context);
            this.oklabState.currentPreset = optimalPreset;
            const genreData = await this.analyzeGenreAesthetics(musicData, rawColors);
            const emotionalTemperature = await this.getAdvancedEmotionalTemperature(musicData, rawColors);
            const processedColors = await this.blendWithAdvancedOKLAB(rawColors, musicData, emotionalTemperature, genreData || void 0);
            const accentHex = processedColors["VIBRANT"] || processedColors["PROMINENT"] || Object.values(processedColors)[0] || "#a6adc8";
            const rgb = this.utils.hexToRgb(accentHex);
            const accentRgb = rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "166,173,200";
            try {
              const harmonizedEventData = {
                processedColors,
                accentHex,
                accentRgb,
                originalColors: rawColors,
                trackUri,
                musicData,
                timestamp: Date.now(),
                strategies: ["ColorHarmonyEngine"],
                processingTime: performance.now() - startTime,
                coordinationMetrics: {
                  detectedGenre: genreData?.genre || "unknown",
                  genreConfidence: genreData?.confidence || 0,
                  emotionalState: this.emotionalState.currentEmotion?.primary || "neutral",
                  oklabPreset: optimalPreset?.name || "standard",
                  coordinationStrategy: "genre-emotion-color-unified",
                  musicInfluenceStrength: this.genreState.genreInfluenceIntensity
                }
              };
              unifiedEventBus.emitSync("colors:harmonized", harmonizedEventData);
              if (this.config.enableDebug) {
                console.log("\u{1F3A8} [ColorHarmonyEngine] Emitted colors:harmonized via UnifiedEventBus (facade pattern):", {
                  processedColors: Object.keys(processedColors),
                  accentHex,
                  noDomEvents: "correct architecture"
                });
              }
            } catch (eventError) {
              if (this.config.enableDebug) {
                console.warn("[ColorHarmonyEngine] Failed to emit colors:harmonized event:", eventError);
              }
            }
            const processingTime = performance.now() - startTime;
            this.harmonyMetrics.totalHarmonyCalculations++;
            this.harmonyMetrics.performance.push(processingTime);
            const result = {
              processedColors,
              accentHex,
              accentRgb,
              metadata: {
                strategy: "CatppuccinHarmony",
                processingTime,
                cacheKey: `catppuccin-${trackUri}-${this.currentTheme}`,
                harmonicIntensity: this.userIntensity
              },
              context
            };
            const cssVariables = this.generateAdvancedOKLABCSSVariables(result);
            this.applyCSSVariablesToDOM(cssVariables);
            this.generatePerceptualGradientData(result);
            this.updateAdvancedHarmonyMetrics(result, processingTime);
            unifiedEventBus.emitSync("colors:harmonized", {
              processedColors: result.processedColors,
              accentHex: result.accentHex,
              accentRgb: result.accentRgb,
              strategies: result.metadata?.strategy ? [result.metadata.strategy] : ["ColorHarmonyEngine"],
              processingTime,
              trackUri: result.context.trackUri
            });
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3A8} [ColorHarmonyEngine] Processed colors via strategy pattern in ${processingTime.toFixed(2)}ms`,
                { accentHex, strategy: "CatppuccinHarmony", cssVariablesCount: Object.keys(cssVariables).length }
              );
            }
            return result;
          } catch (error) {
            console.error("[ColorHarmonyEngine] Strategy processing failed:", error);
            return {
              processedColors: { VIBRANT: "#a6adc8" },
              accentHex: "#a6adc8",
              accentRgb: "166,173,200",
              metadata: {
                strategy: "CatppuccinHarmony",
                processingTime: performance.now() - startTime,
                error: String(error)
              },
              context
            };
          }
        }
        /**
         * Get strategy name for identification
         */
        getStrategyName() {
          return "CatppuccinHarmony";
        }
        /**
         * Check if this strategy can process the given context
         */
        canProcess(context) {
          return context && context.rawColors && Object.keys(context.rawColors).length > 0;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          const baseTime = 5;
          const colorCount = Object.keys(context.rawColors || {}).length;
          const complexityFactor = Math.max(1, colorCount / 5);
          return baseTime * complexityFactor;
        }
        /**
         * Handle color extraction events from unifiedEventBus
         * Event-driven entry point for strategy pattern
         */
        async handleColorExtraction(data) {
          try {
            if (!this.initialized) {
              if (this.config.enableDebug) {
                console.warn("[ColorHarmonyEngine] Received color extraction event but not initialized");
              }
              return;
            }
            const context = {
              rawColors: data.rawColors,
              trackUri: data.trackUri,
              timestamp: data.timestamp,
              harmonicMode: this.currentTheme,
              musicData: data.musicData,
              performanceHints: {
                preferLightweight: false,
                enableAdvancedBlending: true,
                maxProcessingTime: 100
              }
            };
            if (this.canProcess(context)) {
              await this.processColors(context);
            } else {
              if (this.config.enableDebug) {
                console.warn("[ColorHarmonyEngine] Cannot process color context:", context);
              }
            }
          } catch (error) {
            console.error("[ColorHarmonyEngine] Error handling color extraction event:", error);
          }
        }
        /**
         * Generate CSS variables from color result
         */
        generateCSSVariables(result) {
          const cssVars = {};
          cssVars["--sn-accent-hex"] = result.accentHex;
          cssVars["--sn-accent-rgb"] = result.accentRgb;
          cssVars[_ColorHarmonyEngine.CANONICAL_HEX_VAR] = result.accentHex;
          cssVars[_ColorHarmonyEngine.CANONICAL_RGB_VAR] = result.accentRgb;
          const processedColors = result.processedColors;
          const primaryColor = processedColors["VIBRANT"] || processedColors["PROMINENT"] || result.accentHex;
          const secondaryColor = processedColors["DARK_VIBRANT"] || processedColors["DESATURATED"] || primaryColor;
          const accentColor = processedColors["VIBRANT_NON_ALARMING"] || processedColors["LIGHT_VIBRANT"] || primaryColor;
          cssVars["--sn-bg-gradient-primary"] = primaryColor;
          cssVars["--sn-bg-gradient-secondary"] = secondaryColor;
          cssVars["--sn-bg-gradient-accent"] = accentColor;
          const primaryRgb = this.utils.hexToRgb(primaryColor);
          const secondaryRgb = this.utils.hexToRgb(secondaryColor);
          const accentRgb = this.utils.hexToRgb(accentColor);
          if (primaryRgb) {
            cssVars["--sn-bg-gradient-primary-rgb"] = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          }
          if (secondaryRgb) {
            cssVars["--sn-bg-gradient-secondary-rgb"] = `${secondaryRgb.r},${secondaryRgb.g},${secondaryRgb.b}`;
          }
          if (accentRgb) {
            cssVars["--sn-bg-gradient-accent-rgb"] = `${accentRgb.r},${accentRgb.g},${accentRgb.b}`;
          }
          this.generateOKLABVariables(cssVars, result);
          if (this.config.enableDebug) {
            console.log("\u{1F527} [ColorHarmonyEngine] Generated background gradient CSS variables:", {
              primary: `${primaryColor} -> ${cssVars["--sn-bg-gradient-primary-rgb"]}`,
              secondary: `${secondaryColor} -> ${cssVars["--sn-bg-gradient-secondary-rgb"]}`,
              accent: `${accentColor} -> ${cssVars["--sn-bg-gradient-accent-rgb"]}`,
              totalVariables: Object.keys(cssVars).length,
              note: "CSS mapping automatically updates --sn-gradient-* variables"
            });
          }
          return cssVars;
        }
        /**
         * Generate OKLAB-processed CSS variables for perceptual color processing
         */
        generateOKLABVariables(cssVars, result) {
          try {
            const primaryHex = result.accentHex;
            const processedColors = result.processedColors;
            const secondaryHex = processedColors["DARK_VIBRANT"] || processedColors["DESATURATED"] || primaryHex;
            const primaryRgb = this.utils.hexToRgb(primaryHex);
            const secondaryRgb = this.utils.hexToRgb(secondaryHex);
            if (primaryRgb) {
              const oklabPrimary = this.utils.rgbToOklab(primaryRgb.r, primaryRgb.g, primaryRgb.b);
              const enhancedOklab = {
                L: Math.min(1, oklabPrimary.L * 1.1),
                // Slight lightness boost
                a: oklabPrimary.a * 1.15,
                // Enhanced chroma for vibrancy
                b: oklabPrimary.b * 1.15
              };
              const enhancedRgb = this.utils.oklabToRgb(enhancedOklab.L, enhancedOklab.a, enhancedOklab.b);
              cssVars["--sn-color-oklab-bright-highlight-rgb"] = `${enhancedRgb.r},${enhancedRgb.g},${enhancedRgb.b}`;
              cssVars["--sn-color-oklab-primary-r"] = Math.round(enhancedRgb.r).toString();
              cssVars["--sn-color-oklab-primary-g"] = Math.round(enhancedRgb.g).toString();
              cssVars["--sn-color-oklab-primary-b"] = Math.round(enhancedRgb.b).toString();
              cssVars["--sn-color-oklab-accent-r"] = Math.round(enhancedRgb.r).toString();
              cssVars["--sn-color-oklab-accent-g"] = Math.round(enhancedRgb.g).toString();
              cssVars["--sn-color-oklab-accent-b"] = Math.round(enhancedRgb.b).toString();
              cssVars["--sn-color-oklab-accent-luminance"] = enhancedOklab.L.toFixed(3);
              const oklch = this.convertOklabToOklch(enhancedOklab);
              cssVars["--sn-color-oklch-accent-l"] = oklch.L.toFixed(3);
              cssVars["--sn-color-oklch-accent-c"] = oklch.C.toFixed(3);
              cssVars["--sn-color-oklch-accent-h"] = oklch.H.toFixed(1);
              cssVars["--sn-color-oklch-primary-l"] = oklch.L.toFixed(3);
              cssVars["--sn-color-oklch-primary-c"] = oklch.C.toFixed(3);
              cssVars["--sn-color-oklch-primary-h"] = oklch.H.toFixed(1);
            }
            if (secondaryRgb) {
              const oklabSecondary = this.utils.rgbToOklab(secondaryRgb.r, secondaryRgb.g, secondaryRgb.b);
              const shadowOklab = {
                L: Math.max(0.05, oklabSecondary.L * 0.3),
                // Much darker for shadow
                a: oklabSecondary.a * 0.8,
                // Slightly desaturated
                b: oklabSecondary.b * 0.8
              };
              const shadowRgb = this.utils.oklabToRgb(shadowOklab.L, shadowOklab.a, shadowOklab.b);
              cssVars["--sn-color-oklab-dynamic-shadow-rgb"] = `${shadowRgb.r},${shadowRgb.g},${shadowRgb.b}`;
              cssVars["--sn-color-oklab-base-luminance"] = shadowOklab.L.toFixed(3);
            }
            if (this.config.enableDebug) {
              console.log("\u{1F52C} [ColorHarmonyEngine] Generated OKLAB-processed variables:", {
                primaryColor: primaryHex,
                secondaryColor: secondaryHex,
                oklabVariablesCount: Object.keys(cssVars).filter((k) => k.includes("oklab")).length,
                oklchVariablesCount: Object.keys(cssVars).filter((k) => k.includes("oklch")).length
              });
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn("\u{1F52C} [ColorHarmonyEngine] OKLAB processing failed, using fallbacks:", error);
            }
            const fallbackRgb = this.utils.hexToRgb(result.accentHex);
            if (fallbackRgb) {
              cssVars["--sn-color-oklab-bright-highlight-rgb"] = `${fallbackRgb.r},${fallbackRgb.g},${fallbackRgb.b}`;
              cssVars["--sn-color-oklab-dynamic-shadow-rgb"] = `${Math.round(fallbackRgb.r * 0.3)},${Math.round(fallbackRgb.g * 0.3)},${Math.round(fallbackRgb.b * 0.3)}`;
            }
          }
        }
        /**
         * Convert OKLAB to OKLCH (cylindrical representation)
         */
        convertOklabToOklch(oklab) {
          const L = oklab.L;
          const C = Math.sqrt(oklab.a * oklab.a + oklab.b * oklab.b);
          let H = Math.atan2(oklab.b, oklab.a) * (180 / Math.PI);
          if (H < 0) H += 360;
          return { L, C, H };
        }
        detectCurrentTheme() {
          const rootElement = this.utils.getRootStyle();
          if (!rootElement) {
            console.warn(
              "[ColorHarmonyEngine detectCurrentTheme] Root element not found. Defaulting to mocha."
            );
            return "mocha";
          }
          const computedRootStyle = getComputedStyle(rootElement);
          const baseColorHex = computedRootStyle.getPropertyValue("--spice-main").trim();
          const normalizedBaseColor = baseColorHex.startsWith("#") ? baseColorHex.substring(1).toUpperCase() : baseColorHex.toUpperCase();
          const themeMap = {
            "303446": "frappe",
            EFF1F5: "latte",
            "24273A": "macchiato",
            "1E1E2E": "mocha"
          };
          const knownTheme = themeMap[normalizedBaseColor];
          if (knownTheme) {
            if (this.config.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Detected Catppuccin theme: ${knownTheme}`
              );
            }
            return knownTheme;
          }
          if (this.config.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] Unknown theme detected (${normalizedBaseColor}), attempting to generate fallback`
            );
          }
          const fallbackThemeName = `custom-${normalizedBaseColor.toLowerCase()}`;
          try {
            const fallbackPalette = this.paletteExtensionManager.generateFallbackPalette(fallbackThemeName);
            if (this.config.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Generated fallback palette for theme: ${fallbackThemeName}`,
                fallbackPalette
              );
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[ColorHarmonyEngine] Failed to generate fallback palette:`,
                error
              );
            }
          }
          if (this.config.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] Falling back to mocha theme for unknown base color: ${normalizedBaseColor}`
            );
          }
          return "mocha";
        }
        // TODO: Phase 3 - New method to get genre-aware palette
        async _getGenreAwarePalette(genre) {
          const basePalette = this.catppuccinPalettes[this.currentTheme];
          if (!genre || !basePalette) {
            return basePalette;
          }
          try {
            const customPalette = {
              name: this.currentTheme,
              version: "1.0.0",
              accents: basePalette.accents,
              neutrals: basePalette.neutrals,
              metadata: {
                author: "Catppuccin",
                description: `${this.currentTheme} flavor`,
                temperature: "neutral"
              }
            };
            const modifiedPalette = this.paletteExtensionManager.applyGenreAwareModifications(
              customPalette,
              genre
            );
            return {
              accents: modifiedPalette.accents,
              neutrals: modifiedPalette.neutrals
            };
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[ColorHarmonyEngine] Failed to apply genre modifications for ${genre}:`,
                error
              );
            }
            return basePalette;
          }
        }
        getMusicIntensityMultiplier(energy = 0.5, valence = 0.5) {
          const baseMultiplier = this.config.getCurrentMultipliers().musicEnergyBoost;
          const energyBoost = energy > 0.7 ? 1.3 : energy > 0.4 ? 1 : 0.8;
          const valenceBoost = valence > 0.6 ? 1.2 : valence < 0.4 ? 0.9 : 1;
          return baseMultiplier * energyBoost * valenceBoost;
        }
        validateColorHarmony(color2, context = "general") {
          const startTime = performance.now();
          this.harmonyMetrics.totalHarmonyCalculations++;
          const contextRequirements = {
            general: {
              minContrast: 1.8,
              minHarmony: this.vibrancyConfig.harmonyTolerance
            },
            search: { minContrast: 2.8, minHarmony: 0.4 },
            navigation: { minContrast: 2.5, minHarmony: 0.45 },
            text: { minContrast: 4.5, minHarmony: 0.6 },
            accent: { minContrast: 1.5, minHarmony: 0.3 }
          };
          const requirements = contextRequirements[context] || contextRequirements["general"];
          const currentPalette = this.catppuccinPalettes[this.currentTheme];
          if (!currentPalette?.neutrals?.base) {
            const errorMsg = `[StarryNight] Catppuccin palette or base neutral not found for theme: ${this.currentTheme}`;
            console.error(errorMsg);
            return {
              isValid: false,
              error: "Palette configuration error.",
              contrastRatio: 0,
              harmonyScore: 0,
              meetsContrast: false,
              isHarmonious: false,
              artisticMode: this.config.artisticMode,
              adjustedRequirements: requirements,
              recommendations: []
            };
          }
          const backgroundColor = currentPalette.neutrals.base;
          const colorHex = this.utils.rgbToHex(color2.r, color2.g, color2.b);
          const contrastRatio = this.utils.calculateContrastRatio(
            colorHex,
            backgroundColor
          );
          const harmonyScore = this.calculateHarmonyScore(color2, currentPalette);
          const currentMode = this.config.artisticMode;
          let adjustedRequirements = { ...requirements };
          if (currentMode === "cosmic-maximum") {
            adjustedRequirements.minContrast *= 0.7;
            adjustedRequirements.minHarmony *= 0.6;
          } else if (currentMode === "artist-vision") {
            adjustedRequirements.minContrast *= 0.85;
            adjustedRequirements.minHarmony *= 0.8;
          }
          const meetsContrast = contrastRatio >= adjustedRequirements.minContrast;
          const isHarmonious = harmonyScore >= adjustedRequirements.minHarmony;
          const endTime = performance.now();
          this.harmonyMetrics.performance.push(endTime - startTime);
          return {
            isValid: meetsContrast && isHarmonious,
            contrastRatio,
            harmonyScore,
            meetsContrast,
            isHarmonious,
            artisticMode: currentMode,
            adjustedRequirements,
            recommendations: this.generateRecommendations(
              color2,
              contrastRatio,
              harmonyScore,
              adjustedRequirements
            )
          };
        }
        calculateHarmonyScore(color2, palette) {
          const colorHsl = this.utils.rgbToHsl(color2.r, color2.g, color2.b);
          let maxHarmony = 0;
          const accentColors = Object.values(palette.accents);
          for (const accentColor of accentColors) {
            const accentRgb = this.utils.hexToRgb(accentColor);
            if (!accentRgb) continue;
            const accentHsl = this.utils.rgbToHsl(
              accentRgb.r,
              accentRgb.g,
              accentRgb.b
            );
            const hueDiff = Math.abs(colorHsl.h - accentHsl.h);
            const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);
            const harmoniousAngles = [
              0,
              30,
              60,
              90,
              120,
              150,
              180,
              210,
              240,
              270,
              300,
              330
            ];
            const isHarmonious = harmoniousAngles.some(
              (angle) => Math.abs(normalizedHueDiff - angle) < 20
            );
            if (isHarmonious) {
              const harmonyStrength = 1 - Math.min(
                ...harmoniousAngles.map(
                  (angle) => Math.abs(normalizedHueDiff - angle)
                )
              ) / 20;
              maxHarmony = Math.max(maxHarmony, harmonyStrength);
            }
          }
          return maxHarmony;
        }
        findBestHarmoniousAccent(rgb, palette) {
          let bestAccent = {
            name: "mauve",
            hex: this.utils.getRootStyle()?.style.getPropertyValue("--sn-dynamic-accent")?.trim() || this.utils.getRootStyle()?.style.getPropertyValue("--spice-accent")?.trim() || "#cba6f7",
            // Fallback to default mauve hex
            rgb: { r: 203, g: 166, b: 247 }
          };
          const accentPriority = [
            "mauve",
            "lavender",
            "blue",
            "sapphire",
            "sky",
            "pink",
            "peach",
            "teal"
          ];
          let bestScore = -1;
          const inputHsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
          for (const accentName of accentPriority) {
            const accentHex = palette.accents[accentName];
            if (accentHex) {
              const accentRgb = this.utils.hexToRgb(accentHex);
              if (!accentRgb) continue;
              const accentHsl = this.utils.rgbToHsl(
                accentRgb.r,
                accentRgb.g,
                accentRgb.b
              );
              const hueDiff = Math.abs(inputHsl.h - accentHsl.h);
              const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);
              const harmonyScore = 1 - normalizedHueDiff / 180;
              const saturationBonus = accentHsl.s * 0.3;
              const totalScore = harmonyScore + saturationBonus;
              if (totalScore > bestScore) {
                bestScore = totalScore;
                bestAccent = {
                  name: accentName,
                  hex: accentHex,
                  rgb: accentRgb
                };
              }
            }
          }
          return bestAccent;
        }
        blendColors(rgb1, rgb2, ratio = this.vibrancyConfig.defaultBlendRatio) {
          const r = Math.max(0, Math.min(1, ratio));
          const oklab1 = this.utils.rgbToOklab(rgb1.r, rgb1.g, rgb1.b);
          const oklab2 = this.utils.rgbToOklab(rgb2.r, rgb2.g, rgb2.b);
          const lerp2 = /* @__PURE__ */ __name((a, b) => a * r + b * (1 - r), "lerp");
          const blendedOklab = {
            L: lerp2(oklab1.L, oklab2.L),
            a: lerp2(oklab1.a, oklab2.a),
            b: lerp2(oklab1.b, oklab2.b)
          };
          const blendedRgb = this.utils.oklabToRgb(
            blendedOklab.L,
            blendedOklab.a,
            blendedOklab.b
          );
          const blendedHsl = this.utils.rgbToHsl(
            blendedRgb.r,
            blendedRgb.g,
            blendedRgb.b
          );
          const artisticMode = this.config?.artisticMode ?? "artist-vision";
          const emergentMultipliers = this.emergentEngine?.getCurrentMultipliers?.() || void 0;
          const shouldUseEmergent = artisticMode === "cosmic-maximum" && !!emergentMultipliers;
          const validMultipliers = emergentMultipliers || {};
          const saturationBoostFactor = shouldUseEmergent ? (validMultipliers.visualIntensityBase || 1) * 1.25 : this.vibrancyConfig.artisticSaturationBoost;
          const luminanceBoostFactor = shouldUseEmergent ? (validMultipliers.aestheticGravityStrength || 1) * 1.15 : this.vibrancyConfig.cosmicLuminanceBoost;
          blendedHsl.s = Math.max(
            blendedHsl.s,
            this.vibrancyConfig.minimumSaturation * 100
          );
          blendedHsl.s = Math.min(100, blendedHsl.s * saturationBoostFactor);
          if (artisticMode !== "corporate-safe") {
            blendedHsl.l = Math.min(95, blendedHsl.l * luminanceBoostFactor);
          }
          const finalRgb = this.utils.hslToRgb(
            blendedHsl.h,
            blendedHsl.s,
            blendedHsl.l
          );
          return { r: finalRgb.r, g: finalRgb.g, b: finalRgb.b };
        }
        blendWithCatppuccin(extractedColors, musicContext = null) {
          this.performanceMonitor?.emitTrace?.(
            "[ColorHarmonyEngine] Starting blendWithCatppuccin"
          );
          let emotionalTemperature = null;
          if (musicContext) {
            try {
              const musicAnalysis = {
                energy: musicContext.energy || 0.5,
                valence: musicContext.valence || 0.5,
                danceability: musicContext.danceability,
                tempo: musicContext.enhancedBPM || musicContext.tempo,
                loudness: musicContext.loudness,
                acousticness: musicContext.acousticness,
                instrumentalness: musicContext.instrumentalness,
                speechiness: musicContext.speechiness,
                mode: musicContext.mode,
                key: musicContext.key,
                genre: musicContext.genre
              };
              emotionalTemperature = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(musicAnalysis);
              if (emotionalTemperature) {
                unifiedEventBus.emit("system:css-variables", {
                  source: "ColorHarmonyEngine",
                  variables: emotionalTemperature.cssVariables,
                  timestamp: Date.now()
                });
                document.body.classList.remove(...Array.from(document.body.classList).filter((c) => c.startsWith("organic-emotion-")));
                document.body.classList.add(emotionalTemperature.cssClass);
                if (emotionalTemperature.secondaryEmotion) {
                  document.body.classList.add(`organic-emotion-blend-${emotionalTemperature.secondaryEmotion}`);
                }
              }
              if (this.config.enableDebug) {
                console.log("\u{1F321}\uFE0F [ColorHarmonyEngine] Applied emotional temperature:", emotionalTemperature);
              }
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn("\u{1F321}\uFE0F [ColorHarmonyEngine] Failed to apply emotional temperature:", error);
              }
            }
          }
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [ColorHarmonyEngine] blendWithCatppuccin debug:", {
              extractedColors,
              musicContext,
              emotionalTemperature,
              currentTheme: this.currentTheme,
              vibrancyConfig: this.vibrancyConfig,
              userIntensity: this.userIntensity
            });
          }
          const currentPalette = this.catppuccinPalettes[this.currentTheme];
          if (!currentPalette) {
            console.error(
              `[StarryNight] Catppuccin palette not found for theme: ${this.currentTheme}`
            );
            return extractedColors;
          }
          const harmonizedColors = {};
          for (const [role, color2] of Object.entries(extractedColors)) {
            if (!color2) continue;
            const extractedRgb = this.utils.hexToRgb(color2);
            if (!extractedRgb) {
              if (this.config.enableDebug) {
                console.warn(`\u{1F3A8} [ColorHarmonyEngine] Failed to parse color for role ${role}: ${color2}`);
              }
              harmonizedColors[role] = color2;
              continue;
            }
            const extractedHsl = this.utils.rgbToHsl(extractedRgb.r, extractedRgb.g, extractedRgb.b);
            const saturationCheck = extractedHsl.s >= this.vibrancyConfig.minimumSaturation * 100;
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [ColorHarmonyEngine] Processing color ${role}:`, {
                originalColor: color2,
                rgb: extractedRgb,
                hsl: extractedHsl,
                saturationCheck,
                minimumSaturationRequired: this.vibrancyConfig.minimumSaturation * 100,
                actualSaturation: extractedHsl.s
              });
            }
            const bestAccent = this.findBestHarmoniousAccent(
              extractedRgb,
              currentPalette
            );
            if (!bestAccent?.rgb) {
              console.warn(
                `[StarryNight] Could not find a valid harmonious accent for role: ${role}. Using original color.`
              );
              harmonizedColors[role] = color2;
              continue;
            }
            let blendRatio = this.vibrancyConfig.getBlendRatio(
              this.config.artisticMode
            );
            if (emotionalTemperature) {
              const emotionalIntensity = emotionalTemperature.intensity;
              blendRatio *= emotionalIntensity * this.userIntensity;
              const temperatureInfluence = this.calculateTemperatureBlendInfluence(emotionalTemperature.temperature);
              blendRatio *= temperatureInfluence;
              blendRatio = Math.max(0, Math.min(1, blendRatio));
              if (this.config.enableDebug) {
                console.log("\u{1F321}\uFE0F [ColorHarmonyEngine] Emotional temperature blend adjustment:", {
                  originalRatio: this.vibrancyConfig.getBlendRatio(this.config.artisticMode),
                  emotionalIntensity,
                  temperatureInfluence,
                  finalBlendRatio: blendRatio,
                  temperature: emotionalTemperature.temperature
                });
              }
            } else if (musicContext) {
              const musicIntensity = this.getMusicIntensityMultiplier(
                musicContext.energy,
                musicContext.valence
              );
              blendRatio *= musicIntensity * this.userIntensity;
              blendRatio = Math.max(0, Math.min(1, blendRatio));
            }
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [ColorHarmonyEngine] Blending ${role}:`, {
                extractedRgb,
                bestAccent: bestAccent.hex,
                blendRatio,
                artisticMode: this.config.artisticMode
              });
            }
            const finalRgb = this.blendColors(
              extractedRgb,
              bestAccent.rgb,
              blendRatio
            );
            const finalHex = this.utils.rgbToHex(finalRgb.r, finalRgb.g, finalRgb.b);
            harmonizedColors[role] = finalHex;
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [ColorHarmonyEngine] Final color for ${role}: ${color2} \u2192 ${finalHex}`);
            }
          }
          this.harmonyMetrics.musicInfluencedAdjustments++;
          this.performanceMonitor?.emitTrace?.(
            "[ColorHarmonyEngine] Completed blendWithCatppuccin"
          );
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [ColorHarmonyEngine] Final harmonized result:", {
              inputColors: extractedColors,
              outputColors: harmonizedColors,
              colorCount: Object.keys(harmonizedColors).length
            });
          }
          this.updateSemanticColorsWithHarmonizedPalette(harmonizedColors);
          return harmonizedColors;
        }
        /**
         * Updates semantic colors using the harmonized palette
         * Integrates with Spicetify's semantic color system for consistent theming
         */
        updateSemanticColorsWithHarmonizedPalette(harmonizedColors) {
          if (!this.semanticColorManager) {
            return;
          }
          try {
            this.semanticColorManager.updateWithAlbumColors(harmonizedColors);
            const primaryColor = harmonizedColors["VIBRANT"] || harmonizedColors["PRIMARY"];
            const secondaryColor = harmonizedColors["DARK_VIBRANT"] || harmonizedColors["SECONDARY"];
            const accentColor = harmonizedColors["VIBRANT_NON_ALARMING"] || harmonizedColors["LIGHT_VIBRANT"];
            if (primaryColor) {
              this.semanticColorManager.getSemanticColor("essentialBrightAccent").then((color2) => {
                const blendedColor = this.blendWithSemanticColor(primaryColor, color2, 0.7);
                this.applyCSSVariable("--spice-accent", blendedColor);
                this.applyCSSVariable("--spice-button-active", blendedColor);
              });
            }
            if (secondaryColor) {
              this.semanticColorManager.getSemanticColor("backgroundElevatedHighlight").then((color2) => {
                const blendedColor = this.blendWithSemanticColor(secondaryColor, color2, 0.5);
                this.applyCSSVariable("--spice-highlight", blendedColor);
              });
            }
            if (accentColor) {
              this.semanticColorManager.getSemanticColor("textBrightAccent").then((color2) => {
                const blendedColor = this.blendWithSemanticColor(accentColor, color2, 0.6);
                this.applyCSSVariable("--spice-text-accent", blendedColor);
              });
            }
            this.semanticColorManager.flushUpdates();
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn("[ColorHarmonyEngine] Failed to update semantic colors:", error);
            }
          }
        }
        /**
         * Blends a harmonized color with a semantic color for consistency
         */
        blendWithSemanticColor(harmonizedHex, semanticHex, blendRatio) {
          const harmonizedRgb = this.utils.hexToRgb(harmonizedHex);
          const semanticRgb = this.utils.hexToRgb(semanticHex);
          if (!harmonizedRgb || !semanticRgb) {
            return harmonizedHex;
          }
          const blendedRgb = this.blendColors(harmonizedRgb, semanticRgb, blendRatio);
          return this.utils.rgbToHex(blendedRgb.r, blendedRgb.g, blendedRgb.b);
        }
        /**
         * 🔧 PHASE 2: Emit CSS variable instead of applying directly
         */
        applyCSSVariable(property, value) {
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: { [property]: value },
            timestamp: Date.now()
          });
        }
        /**
         * Apply multiple CSS variables to the DOM efficiently
         * Enhanced with comprehensive UI component support and robust fallbacks
         */
        applyCSSVariablesToDOM(cssVariables) {
          const year3000System2 = globalThis.year3000System;
          const cssConsciousnessController = year3000System2?.cssConsciousnessController || this.performanceMonitor?.cssConsciousnessController || year3000System2?.facadeCoordinator?.getCachedNonVisualSystem?.("UnifiedCSSConsciousnessController");
          const enhancedCssVariables = this.enhanceCSSVariablesForUIComponents(cssVariables);
          if (cssConsciousnessController && typeof cssConsciousnessController.batchSetVariables === "function") {
            try {
              cssConsciousnessController.batchSetVariables(
                "ColorHarmonyEngine",
                enhancedCssVariables,
                "high",
                // High priority for color processing
                "color-harmony-oklab-processing"
              );
              if (this.config.enableDebug) {
                console.log("\u{1F527} [ColorHarmonyEngine] Applied CSS variables via cssConsciousnessController batcher");
              }
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn("\u{1F527} [ColorHarmonyEngine] cssConsciousnessController.batchSetVariables failed, using direct application:", error);
              }
              this.applyVariablesDirectly(enhancedCssVariables);
            }
          } else {
            if (this.config.enableDebug) {
              console.log("\u{1F527} [ColorHarmonyEngine] cssConsciousnessController not available, using direct DOM application");
            }
            this.applyVariablesDirectly(enhancedCssVariables);
          }
          unifiedEventBus.emitSync("colors:applied", {
            cssVariables: enhancedCssVariables,
            accentHex: enhancedCssVariables["--sn-accent-hex"] || "#a6adc8",
            accentRgb: enhancedCssVariables["--sn-accent-rgb"] || "166,173,200",
            appliedAt: Date.now()
          });
          if (this.config.enableDebug) {
            console.log("\u{1F52C} [ColorHarmonyEngine] Applied enhanced CSS variables to DOM:", {
              totalVariables: Object.keys(enhancedCssVariables).length,
              oklabVariables: Object.keys(enhancedCssVariables).filter((k) => k.includes("oklab")).length,
              oklchVariables: Object.keys(enhancedCssVariables).filter((k) => k.includes("oklch")).length,
              gradientVariables: Object.keys(enhancedCssVariables).filter((k) => k.includes("gradient")).length,
              spiceVariables: Object.keys(enhancedCssVariables).filter((k) => k.includes("spice")).length,
              sidebarVariables: Object.keys(enhancedCssVariables).filter((k) => k.includes("sidebar")).length,
              cssConsciousnessControllerUsed: !!cssConsciousnessController
            });
          }
        }
        /**
         * Enhance CSS variables with UI component-specific mappings
         * Maps OKLAB-processed colors to variables that sidebar, now-playing, and other UI components expect
         */
        enhanceCSSVariablesForUIComponents(cssVariables) {
          const enhanced = { ...cssVariables };
          const accentHex = enhanced["--sn-accent-hex"] || enhanced[_ColorHarmonyEngine.CANONICAL_HEX_VAR];
          const accentRgb = enhanced["--sn-accent-rgb"] || enhanced[_ColorHarmonyEngine.CANONICAL_RGB_VAR];
          const primaryHex = enhanced["--sn-bg-gradient-primary"];
          const primaryRgb = enhanced["--sn-bg-gradient-primary-rgb"];
          const secondaryHex = enhanced["--sn-bg-gradient-secondary"];
          const secondaryRgb = enhanced["--sn-bg-gradient-secondary-rgb"];
          if (accentHex && accentRgb) {
            enhanced["--spice-accent"] = accentHex;
            enhanced["--spice-button"] = accentHex;
            enhanced["--spice-button-active"] = accentHex;
            enhanced["--spice-rgb-accent"] = accentRgb;
            enhanced["--spice-rgb-button"] = accentRgb;
            enhanced["--spice-text-accent"] = accentHex;
            enhanced["--sn-sidebar-entanglement-color-rgb"] = accentRgb;
            enhanced["--sn-sidebar-accent-color"] = accentHex;
            enhanced["--sn-sidebar-accent-rgb"] = accentRgb;
            enhanced["--sn-sidebar-dynamic-accent"] = accentHex;
            enhanced["--sn-nowplaying-accent-color"] = accentHex;
            enhanced["--sn-nowplaying-accent-rgb"] = accentRgb;
            enhanced["--sn-nowplaying-primary-color"] = accentHex;
            enhanced["--sn-nowplaying-primary-rgb"] = accentRgb;
            enhanced["--sn-main-feed-accent-color"] = accentHex;
            enhanced["--sn-main-feed-accent-rgb"] = accentRgb;
            enhanced["--sn-content-accent-color"] = accentHex;
            enhanced["--sn-content-accent-rgb"] = accentRgb;
          }
          if (primaryHex && primaryRgb) {
            enhanced["--sn-primary-gradient-color"] = primaryHex;
            enhanced["--sn-primary-gradient-rgb"] = primaryRgb;
            enhanced["--sn-main-feed-primary-color"] = primaryHex;
            enhanced["--sn-main-feed-primary-rgb"] = primaryRgb;
          }
          if (secondaryHex && secondaryRgb) {
            enhanced["--sn-secondary-gradient-color"] = secondaryHex;
            enhanced["--sn-secondary-gradient-rgb"] = secondaryRgb;
            enhanced["--sn-main-feed-secondary-color"] = secondaryHex;
            enhanced["--sn-main-feed-secondary-rgb"] = secondaryRgb;
          }
          const oklabBrightHighlight = enhanced["--sn-color-oklab-bright-highlight-rgb"];
          if (oklabBrightHighlight) {
            enhanced["--sn-consciousness-bright-accent-rgb"] = oklabBrightHighlight;
            enhanced["--sn-holographic-accent-rgb"] = oklabBrightHighlight;
            enhanced["--organic-holographic-rgb"] = oklabBrightHighlight;
          }
          const oklabDynamicShadow = enhanced["--sn-color-oklab-dynamic-shadow-rgb"];
          if (oklabDynamicShadow) {
            enhanced["--sn-consciousness-shadow-rgb"] = oklabDynamicShadow;
            enhanced["--sn-depth-shadow-rgb"] = oklabDynamicShadow;
          }
          return enhanced;
        }
        /**
         * 🔧 PHASE 2: Emit CSS variables instead of applying directly
         */
        applyVariablesDirectly(cssVariables) {
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: cssVariables,
            timestamp: Date.now()
          });
        }
        generateRecommendations(color2, contrastRatio, harmonyScore, requirements) {
          const recommendations = [];
          const currentPalette = this.catppuccinPalettes[this.currentTheme];
          const baseRgb = this.utils.hexToRgb(currentPalette.neutrals.base);
          if (!baseRgb) {
            return [];
          }
          if (contrastRatio < requirements.minContrast) {
            const targetL = this.utils.findRequiredLuminance(
              color2,
              baseRgb,
              requirements.minContrast
            );
            const currentHsl = this.utils.rgbToHsl(color2.r, color2.g, color2.b);
            const adjustedRgbArr = this.utils.hslToRgb(
              currentHsl.h,
              currentHsl.s,
              targetL
            );
            const adjustedRgb = {
              r: adjustedRgbArr.r,
              g: adjustedRgbArr.g,
              b: adjustedRgbArr.b
            };
            recommendations.push({
              type: "contrast",
              suggestion: `Adjust luminance to meet contrast of ${requirements.minContrast}`,
              recommendedColor: this.utils.rgbToHex(
                adjustedRgb.r,
                adjustedRgb.g,
                adjustedRgb.b
              )
            });
          }
          if (harmonyScore < requirements.minHarmony) {
            const harmoniousAccent = this.findBestHarmoniousAccent(
              color2,
              currentPalette
            );
            const blendedColor = this.blendColors(color2, harmoniousAccent.rgb, 0.5);
            recommendations.push({
              type: "harmony",
              suggestion: `Blend with harmonious accent color to improve score to at least ${requirements.minHarmony}`,
              recommendedColor: this.utils.rgbToHex(
                blendedColor.r,
                blendedColor.g,
                blendedColor.b
              )
            });
          }
          return recommendations;
        }
        getPerformanceReport() {
          return {
            system: this.systemName,
            metrics: this.harmonyMetrics,
            kineticState: this.kineticState,
            musicalMemorySize: this.musicalMemory.recentTracks.length,
            currentTheme: this.currentTheme
          };
        }
        updateFromMusicAnalysis(processedMusicData, rawFeatures, trackUri) {
          if (!processedMusicData) return;
          const g2 = processedMusicData.genre;
          if (g2 && g2 !== this._lastGenre) {
            this._applyGenrePalette(g2).then(() => {
              this._lastGenre = g2;
              this._forcePaletteRepaint();
            });
          }
          this._updateMusicalMemory(processedMusicData, trackUri);
          this._updateKineticState(processedMusicData);
          this._applyAestheticGravity(processedMusicData);
          this._calculateMusicAwareDynamics(processedMusicData);
        }
        // TODO: Phase 2 - New method for music-aware dynamic calculations
        _calculateMusicAwareDynamics(musicData) {
          const {
            energy = 0.5,
            valence = 0.5,
            enhancedBPM = 120,
            beatOccurred = false
          } = musicData;
          const musicIntensityMultiplier = this._calculateMusicIntensityMultiplier(
            energy,
            valence
          );
          const beatPhase = this._calculateBeatPhase(enhancedBPM);
          const valenceGravity = (valence - 0.5) * 2;
          const hueShift = this._calculateHueShift(beatOccurred, energy, beatPhase);
          this.kineticState = {
            ...this.kineticState,
            musicIntensityMultiplier,
            beatPhase,
            valenceGravity,
            hueShift
          };
        }
        // TODO: Phase 2 - Calculate music intensity based on energy and valence
        _calculateMusicIntensityMultiplier(energy, valence) {
          const baseIntensity = energy * 0.7 + valence * 0.3;
          const contrastBoost = Math.abs(valence - 0.5) * 0.4;
          return Math.max(0.1, Math.min(2, baseIntensity + contrastBoost));
        }
        // TODO: Phase 2 - Calculate beat phase for cyclic effects
        _calculateBeatPhase(enhancedBPM) {
          const now = performance.now();
          const beatInterval = 6e4 / enhancedBPM;
          const timeSinceStart = now % beatInterval;
          return timeSinceStart / beatInterval;
        }
        // TODO: Phase 2 - Calculate dynamic hue shift for beat effects
        _calculateHueShift(beatOccurred, energy, beatPhase) {
          if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
            return 0;
          }
          const artisticMode = this.config.artisticMode;
          const baseAmplitude = artisticMode === "cosmic-maximum" ? 8 : 5;
          let hueShift = Math.sin(beatPhase * 2 * Math.PI) * baseAmplitude;
          if (beatOccurred) {
            const beatBoost = artisticMode === "cosmic-maximum" ? 12 : 10;
            hueShift += energy * beatBoost;
          }
          const clampRange = artisticMode === "cosmic-maximum" ? 25 : 15;
          return Math.max(-clampRange, Math.min(clampRange, hueShift));
        }
        _updateMusicalMemory(musicData, trackUri) {
          this.musicalMemory.recentTracks.unshift({
            trackUri,
            ...musicData,
            timestamp: Date.now()
          });
          if (this.musicalMemory.recentTracks.length > this.musicalMemory.maxMemorySize) {
            this.musicalMemory.recentTracks.pop();
          }
          this.musicalMemory.energyHistory.unshift(musicData.energy);
          if (this.musicalMemory.energyHistory.length > 20) {
            this.musicalMemory.energyHistory.pop();
          }
          this.harmonyMetrics.temporalMemoryEvents++;
        }
        _updateKineticState(musicData) {
          const { energy, enhancedBPM, beatOccurred } = musicData;
          const now = performance.now();
          if (beatOccurred) {
            this.kineticState.lastBeatTime = now;
            this.kineticState.currentPulse = 1;
          } else {
            this.kineticState.currentPulse *= 0.95;
          }
          const timeSinceLastBeat = now - this.kineticState.lastBeatTime;
          const beatInterval = 6e4 / (enhancedBPM || 120);
          this.kineticState.breathingPhase = timeSinceLastBeat % beatInterval / beatInterval * 2 * Math.PI;
          this.kineticState.visualMomentum = this.utils.lerp(
            this.kineticState.visualMomentum,
            energy,
            0.1
          );
        }
        // 🔧 PHASE 2: Emit gravity variables instead of applying CSS directly
        _applyAestheticGravity(musicData) {
          const { visualIntensity, valence, energy } = musicData;
          const gravityX = (valence - 0.5) * 2;
          const gravityY = (energy - 0.5) * 2;
          const gravityStrength = visualIntensity;
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: {
              "--sn-gravity-x": gravityX.toFixed(3),
              "--sn-gravity-y": gravityY.toFixed(3),
              "--sn-gravity-strength": gravityStrength.toFixed(3)
            },
            timestamp: Date.now()
          });
        }
        getQuantumEmpathyMetrics() {
          const avgEnergy = this.musicalMemory.energyHistory.reduce((a, b) => a + b, 0) / this.musicalMemory.energyHistory.length || 0;
          return {
            averageRecentEnergy: avgEnergy,
            systemMomentum: this.kineticState.visualMomentum,
            preferenceProfileSize: this.musicalMemory.userColorPreferences.size
          };
        }
        generateHarmonicVariations(baseRgb) {
          const oklab = this.utils.rgbToOklab(baseRgb.r, baseRgb.g, baseRgb.b);
          const darkOklabL = Math.max(0, Math.min(1, oklab.L * 0.75));
          const darkRgb = this.utils.oklabToRgb(darkOklabL, oklab.a, oklab.b);
          const lightOklabL = Math.max(0, Math.min(1, oklab.L * 1.25));
          const lightRgb = this.utils.oklabToRgb(lightOklabL, oklab.a, oklab.b);
          return {
            darkVibrantHex: this.utils.rgbToHex(darkRgb.r, darkRgb.g, darkRgb.b),
            lightVibrantHex: this.utils.rgbToHex(lightRgb.r, lightRgb.g, lightRgb.b)
          };
        }
        /**
         * Get current gradient colors optimized for WebGL texture creation
         * Uses variable inheritance from OKLAB processed consciousness-aware colors
         * @param stopCount Number of gradient stops to generate (default: 5)
         * @returns Array of RGB color objects or null if unavailable
         */
        getCurrentGradient(stopCount = 5) {
          try {
            const currentPalette = this.catppuccinPalettes[this.currentTheme];
            if (!currentPalette) {
              return null;
            }
            const rootEl = this.utils.getRootStyle();
            if (!rootEl) {
              return this.generateFallbackGradient(stopCount);
            }
            const computedStyle = getComputedStyle(rootEl);
            const inheritedColors = this.getInheritedGradientColors(computedStyle);
            if (!inheritedColors) {
              Y3K?.debug?.warn("ColorHarmonyEngine", "Failed to inherit processed gradient variables, using fallback");
              return this.generateFallbackGradient(stopCount);
            }
            const gradientColors = [];
            const musicInfluence = this.kineticState.musicIntensityMultiplier || 1;
            const hueShift = this.kineticState.hueShift || 0;
            const valenceGravity = this.kineticState.valenceGravity || 0.5;
            const emotionalTemperature = this.emotionalState?.currentEmotion?.colorTemperature || 0.5;
            const { primary, secondary, accent, emotional, tertiary } = inheritedColors;
            const baseColors = [
              primary,
              // Deep consciousness base
              secondary,
              // Harmonic transition
              accent,
              // Vibrational peak  
              emotional,
              // Emotional resonance
              tertiary
              // Transcendent highlight
            ];
            for (let i = 0; i < stopCount; i++) {
              const position = i / (stopCount - 1);
              let interpolatedColor;
              if (stopCount === 1) {
                interpolatedColor = accent;
              } else {
                const colorIndex = position * (baseColors.length - 1);
                const lowerIndex = Math.floor(colorIndex);
                const upperIndex = Math.min(lowerIndex + 1, baseColors.length - 1);
                const interpolationFactor = colorIndex - lowerIndex;
                const temperatureInfluence = Math.sin(emotionalTemperature * Math.PI) * 0.3;
                const adjustedFactor = Math.max(0, Math.min(1, interpolationFactor + temperatureInfluence));
                const color1 = baseColors[lowerIndex];
                const color2 = baseColors[upperIndex];
                if (color1 && color2) {
                  interpolatedColor = {
                    r: color1.r + (color2.r - color1.r) * adjustedFactor,
                    g: color1.g + (color2.g - color1.g) * adjustedFactor,
                    b: color1.b + (color2.b - color1.b) * adjustedFactor
                  };
                } else {
                  interpolatedColor = accent;
                }
              }
              let finalColor = this._applyConsciousnessModulation(
                interpolatedColor,
                {
                  musicInfluence,
                  valenceGravity,
                  hueShift,
                  emotionalTemperature,
                  position
                }
              );
              gradientColors.push({
                r: Math.round(Math.max(0, Math.min(255, finalColor.r))),
                g: Math.round(Math.max(0, Math.min(255, finalColor.g))),
                b: Math.round(Math.max(0, Math.min(255, finalColor.b)))
              });
            }
            if (this.config?.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Generated gradient with ${stopCount} stops:`,
                gradientColors
              );
            }
            return gradientColors;
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "Unknown error";
            const errorDetails = {
              method: "getCurrentGradient",
              stopCount,
              currentTheme: this.currentTheme,
              kineticState: this.kineticState,
              timestamp: Date.now(),
              error: errorMessage
            };
            Y3K?.debug?.error(
              "ColorHarmonyEngine",
              "Failed to generate gradient colors",
              errorDetails
            );
            unifiedEventBus.emit("system:error", {
              systemName: "ColorHarmonyEngine",
              error: `Gradient generation failed: ${errorMessage}`,
              severity: "error",
              timestamp: Date.now()
            });
            try {
              const fallbackColors = this.generateFallbackGradient(stopCount);
              if (fallbackColors && fallbackColors.length > 0) {
                Y3K?.debug?.warn(
                  "ColorHarmonyEngine",
                  "Using fallback gradient after error",
                  { fallbackColorCount: fallbackColors.length }
                );
                return fallbackColors;
              }
            } catch (fallbackError) {
              Y3K?.debug?.error(
                "ColorHarmonyEngine",
                "Fallback gradient generation also failed",
                fallbackError
              );
            }
            return null;
          }
        }
        /**
         * Get inherited gradient colors from processed OKLAB CSS variables
         * Uses variable inheritance instead of manual CSS reading
         */
        getInheritedGradientColors(computedStyle) {
          try {
            const primaryRgb = this.parseRGBVariable(computedStyle, "--sn-oklab-processed-primary-rgb") || this.parseRGBVariable(computedStyle, "--sn-gradient-primary-rgb") || this.parseRGBVariable(computedStyle, "--sn-musical-harmony-primary-rgb");
            const secondaryRgb = this.parseRGBVariable(computedStyle, "--sn-oklab-processed-secondary-rgb") || this.parseRGBVariable(computedStyle, "--sn-gradient-secondary-rgb") || this.parseRGBVariable(computedStyle, "--sn-musical-harmony-secondary-rgb");
            const accentRgb = this.parseRGBVariable(computedStyle, "--sn-oklab-processed-accent-rgb") || this.parseRGBVariable(computedStyle, "--sn-gradient-accent-rgb") || this.parseRGBVariable(computedStyle, "--sn-color-accent-rgb");
            const emotionalRgb = this.parseRGBVariable(computedStyle, "--sn-oklab-emotional-temperature-rgb") || this.parseRGBVariable(computedStyle, "--sn-emotional-temperature-warm-rgb") || accentRgb;
            const tertiaryRgb = this.parseRGBVariable(computedStyle, "--sn-oklab-processed-bright-highlight-rgb") || this.parseRGBVariable(computedStyle, "--sn-consciousness-flow-rgb") || this.parseRGBVariable(computedStyle, "--sn-musical-harmony-tertiary-rgb");
            if (!primaryRgb || !accentRgb) {
              Y3K?.debug?.warn("ColorHarmonyEngine", "Missing essential inherited colors", {
                hasPrimary: !!primaryRgb,
                hasAccent: !!accentRgb
              });
              return null;
            }
            return {
              primary: primaryRgb,
              secondary: secondaryRgb || primaryRgb,
              accent: accentRgb,
              emotional: emotionalRgb || accentRgb,
              tertiary: tertiaryRgb || accentRgb
            };
          } catch (error) {
            Y3K?.debug?.error("ColorHarmonyEngine", "Failed to inherit gradient colors:", error);
            return null;
          }
        }
        /**
         * Parse RGB variable from CSS computed style with fallback chain
         */
        parseRGBVariable(computedStyle, variableName) {
          try {
            const value = computedStyle.getPropertyValue(variableName).trim();
            if (!value) return null;
            const rgbMatch = value.match(/(\d+),\s*(\d+),\s*(\d+)/);
            if (rgbMatch && rgbMatch[1] && rgbMatch[2] && rgbMatch[3]) {
              return {
                r: parseInt(rgbMatch[1], 10),
                g: parseInt(rgbMatch[2], 10),
                b: parseInt(rgbMatch[3], 10)
              };
            }
            return null;
          } catch (error) {
            return null;
          }
        }
        /**
         * Interpolate between two colors using perceptually aware interpolation
         */
        interpolateOKLABColors(color1, color2, factor) {
          const gamma = 2.2;
          const r1 = Math.pow(color1.r / 255, gamma);
          const g1 = Math.pow(color1.g / 255, gamma);
          const b1 = Math.pow(color1.b / 255, gamma);
          const r2 = Math.pow(color2.r / 255, gamma);
          const g2 = Math.pow(color2.g / 255, gamma);
          const b2 = Math.pow(color2.b / 255, gamma);
          const rInterp = r1 + (r2 - r1) * factor;
          const gInterp = g1 + (g2 - g1) * factor;
          const bInterp = b1 + (b2 - b1) * factor;
          return {
            r: Math.round(Math.pow(rInterp, 1 / gamma) * 255),
            g: Math.round(Math.pow(gInterp, 1 / gamma) * 255),
            b: Math.round(Math.pow(bInterp, 1 / gamma) * 255)
          };
        }
        /**
         * Apply consciousness modulation to color (preserves OKLAB processing)
         */
        _applyConsciousnessModulation(color2, modulation) {
          try {
            const hsl = this.utils.rgbToHsl(color2.r, color2.g, color2.b);
            let { h, s, l } = hsl;
            s = Math.max(0, Math.min(1, s * (0.7 + modulation.musicInfluence * 0.6)));
            h = (h + modulation.hueShift + (modulation.emotionalTemperature - 0.5) * 60) % 360;
            const gravityEffect = modulation.valenceGravity * 0.2 * Math.sin(modulation.position * Math.PI);
            l = Math.max(0.1, Math.min(0.9, l + gravityEffect));
            const modulatedRgb = this.utils.hslToRgb(h, s, l);
            return {
              r: modulatedRgb.r,
              g: modulatedRgb.g,
              b: modulatedRgb.b
            };
          } catch (error) {
            return color2;
          }
        }
        /**
         * Generate fallback gradient colors when primary generation fails
         * Uses safe Catppuccin colors to prevent complete gradient failure
         */
        generateFallbackGradient(stopCount) {
          try {
            const fallbackHexColors = [
              "#1e1e2e",
              // Base
              "#313244",
              // Surface0
              "#45475a",
              // Surface1
              "#585b70",
              // Surface2
              "#cba6f7",
              // Mauve (primary accent)
              "#f5c2e7",
              // Pink
              "#fab387"
              // Peach
            ];
            if (stopCount < 2 || stopCount > fallbackHexColors.length) {
              Y3K?.debug?.warn(
                "ColorHarmonyEngine",
                `Invalid fallback stopCount: ${stopCount}, using default`
              );
              stopCount = Math.min(Math.max(stopCount, 2), fallbackHexColors.length);
            }
            const fallbackColors = [];
            for (let i = 0; i < stopCount; i++) {
              const colorIndex = Math.floor(i / (stopCount - 1) * (fallbackHexColors.length - 1));
              const hex = fallbackHexColors[colorIndex];
              const rgb = hex ? this.utils.hexToRgb(hex) : null;
              if (rgb) {
                fallbackColors.push(rgb);
              } else {
                fallbackColors.push({
                  r: 203,
                  g: 166,
                  b: 247
                  // Mauve fallback
                });
              }
            }
            if (fallbackColors.length < 2) {
              fallbackColors.push(
                { r: 30, g: 30, b: 46 },
                // Base
                { r: 203, g: 166, b: 247 }
                // Mauve
              );
            }
            Y3K?.debug?.log(
              "ColorHarmonyEngine",
              `Generated fallback gradient with ${fallbackColors.length} colors`,
              fallbackColors
            );
            return fallbackColors;
          } catch (error) {
            Y3K?.debug?.error(
              "ColorHarmonyEngine",
              "Critical error in fallback gradient generation",
              error
            );
            return null;
          }
        }
        /**
         * Analyze music and update emotional state for consciousness-aware color processing
         * This method connects the Music → Emotion → Color flow
         */
        async analyzeMusicEmotion(audioFeatures, audioData) {
          if (!this.initialized || !this.musicEmotionAnalyzer) {
            if (this.config.enableDebug) {
              console.warn("\u{1F3AD} [ColorHarmonyEngine] Cannot analyze music emotion: not initialized");
            }
            return null;
          }
          try {
            const emotion = await this.musicEmotionAnalyzer.analyzeEmotion(audioFeatures, audioData);
            if (this.config.enableDebug) {
              console.log(`\u{1F3AD} [ColorHarmonyEngine] Analyzed music emotion: ${emotion.primary} (${emotion.intensity.toFixed(2)} intensity, ${emotion.confidence.toFixed(2)} confidence)`);
            }
            return emotion;
          } catch (error) {
            console.error("\u{1F3AD} [ColorHarmonyEngine] Error analyzing music emotion:", error);
            return null;
          }
        }
        /**
         * Get current emotional state
         */
        getCurrentEmotion() {
          return this.emotionalState?.currentEmotion || null;
        }
        /**
         * Get emotion history for consciousness flow analysis
         */
        getEmotionHistory(limit = 10) {
          if (!this.emotionalState?.emotionHistory) return [];
          return this.emotionalState.emotionHistory.slice(-limit);
        }
        /**
         * Set emotion influence intensity (0-1) for color processing
         */
        setEmotionInfluenceIntensity(intensity) {
          if (this.emotionalState) {
            this.emotionalState.emotionInfluenceIntensity = Math.max(0, Math.min(1, intensity));
            if (this.config.enableDebug) {
              console.log(`\u{1F3AD} [ColorHarmonyEngine] Emotion influence intensity set to ${this.emotionalState.emotionInfluenceIntensity}`);
            }
          }
        }
        /**
         * Create a color variant with lightness, saturation, and hue adjustments
         */
        _createVariant(baseColor, lightnessFactor, valenceGravity, hueShift) {
          const oklab = this.utils.rgbToOklab(baseColor.r, baseColor.g, baseColor.b);
          const newL = Math.max(0, Math.min(1, oklab.L + lightnessFactor * 0.2));
          const chromaScale = 0.8 + valenceGravity * 0.4;
          const newA = oklab.a * chromaScale;
          const newB = oklab.b * chromaScale;
          const hueAdjustment = hueShift * 0.1;
          const adjustedA = newA * Math.cos(hueAdjustment) - newB * Math.sin(hueAdjustment);
          const adjustedB = newA * Math.sin(hueAdjustment) + newB * Math.cos(hueAdjustment);
          return this.utils.oklabToRgb(newL, adjustedA, adjustedB);
        }
        /**
         * Apply music intensity influence to color
         */
        _applyMusicInfluence(color2, intensity, position) {
          const positionEffect = 1 + Math.sin(position * Math.PI) * 0.2;
          const effectiveIntensity = Math.max(
            0.7,
            Math.min(1.3, intensity * positionEffect)
          );
          return {
            r: color2.r * effectiveIntensity,
            g: color2.g * effectiveIntensity,
            b: color2.b * effectiveIntensity
          };
        }
        // =========================
        // PUBLIC API – User Control
        // =========================
        /**
         * Update user-defined harmonic intensity (0–1). Values outside range are clamped.
         */
        setIntensity(value) {
          const clamped = Math.max(0, Math.min(1, value));
          this.userIntensity = clamped;
          if (this.config?.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] User harmonic intensity set to ${clamped}`
            );
          }
        }
        /**
         * External systems can push a pre-computed RGB palette to the engine.
         * Currently this simply triggers a palette refresh so all CSS variables
         * are recalculated.  Future phases may blend these colours directly.
         *
         * @param colors – Array of RGB objects ({ r,g,b }) representing the new palette
         */
        updatePalette(colors) {
          if (!colors?.length) return;
          if (this.config?.enableDebug) {
            console.log("[ColorHarmonyEngine] updatePalette invoked", {
              count: colors.length
            });
          }
          this.forceRepaint("external-palette");
        }
        // ============================
        // Settings / Event Integration
        // ============================
        _handleSettingsChange(event) {
          const { key, value } = event.detail || {};
          switch (key) {
            case HARMONIC_INTENSITY_KEY: {
              const num = parseFloat(value);
              if (!Number.isNaN(num)) {
                this.setIntensity(num);
              }
              break;
            }
            case HARMONIC_EVOLUTION_KEY: {
              const enabled = value === "true" || value === true;
              this._setEvolutionEnabled(enabled);
              break;
            }
          }
        }
        _handleArtisticModeChanged() {
          this.currentTheme = this.detectCurrentTheme();
          if (!this._pendingPaletteRefresh) {
            this._pendingPaletteRefresh = setTimeout(() => {
              this._pendingPaletteRefresh = null;
              this.refreshPalette();
            }, 80);
          }
        }
        _forcePaletteRepaint() {
          this.kineticState.hueShift = (this.kineticState.hueShift || 0) + 0.01;
        }
        // Evolution helpers
        _startEvolutionLoop() {
          if (this._evolutionTimer) return;
          const basePeriod = 3e4;
          const period = basePeriod / Math.max(0.1, this.userIntensity);
          this._evolutionTimer = setInterval(() => {
            const step = 2 * this.userIntensity;
            const current = this.kineticState.hueShift ?? 0;
            this.kineticState.hueShift = (current + step + 360) % 360 - 180;
          }, period);
        }
        _stopEvolutionLoop() {
          if (this._evolutionTimer) {
            clearInterval(this._evolutionTimer);
            this._evolutionTimer = null;
          }
        }
        _setEvolutionEnabled(enabled) {
          if (this.evolutionEnabled === enabled) return;
          this.evolutionEnabled = enabled;
          if (enabled) this._startEvolutionLoop();
          else this._stopEvolutionLoop();
        }
        // Clean up listeners when destroyed
        destroy() {
          this._stopEvolutionLoop();
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this._boundSettingsChangeHandler
          );
          document.removeEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          if (this.semanticColorManager) {
            this.semanticColorManager.destroy();
          }
          if (this.musicEmotionAnalyzer) {
            this.musicEmotionAnalyzer.destroy();
          }
          if (this.emotionalState) {
            this.emotionalState.currentEmotion = null;
            this.emotionalState.emotionHistory = [];
          }
          super.destroy?.();
        }
        /**
         * Public helper that triggers a colour rebake based on the current track.
         * Prefer calling the global Year3000System where available so the full
         * pipeline (extraction → harmonisation → CSS variable batch) is reused.
         */
        async refreshPalette() {
          try {
            const y3kSystem = globalThis.year3000System;
            if (y3kSystem?.updateColorsFromCurrentTrack) {
              await y3kSystem.updateColorsFromCurrentTrack();
              return;
            }
            const root = this.utils.getRootStyle();
            if (!root) return;
            const styles = getComputedStyle(root);
            const primary = styles.getPropertyValue("--sn-gradient-primary").trim();
            if (primary) {
              const rgb = this.utils.hexToRgb(primary);
              const variables = {
                "--sn-gradient-primary": primary
              };
              if (rgb) {
                variables["--sn-gradient-primary-rgb"] = `${rgb.r},${rgb.g},${rgb.b}`;
              }
              unifiedEventBus.emit("system:css-variables", {
                source: "ColorHarmonyEngine",
                variables,
                timestamp: Date.now()
              });
            }
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn("[ColorHarmonyEngine] refreshPalette failed", err);
            }
          }
        }
        /**
         * Swap Catppuccin palette accents & neutrals based on detected genre.
         * Executes asynchronously to avoid blocking audio thread.
         */
        async _applyGenrePalette(genre) {
          try {
            const palette = await this._getGenreAwarePalette(genre);
            if (!palette) return;
            this.catppuccinPalettes[this.currentTheme] = palette;
            await this.refreshPalette();
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [ColorHarmonyEngine] Genre changed to: ${genre}`);
            }
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn("[ColorHarmonyEngine] _applyGenrePalette failed", err);
            }
          }
        }
        setEmergentEngine(engine) {
          this.emergentEngine = engine;
        }
        // ---------------------------------------------------------------------------
        // 🔄 SETTINGS-AWARE REPAINT IMPLEMENTATION
        // ---------------------------------------------------------------------------
        /**
         * Calculate temperature-based blend influence for emotional temperature integration
         * Maps color temperature (1000K-20000K) to blend ratio influence (0.7-1.3)
         */
        calculateTemperatureBlendInfluence(temperature) {
          const normalized = Math.max(0, Math.min(1, (temperature - 1e3) / (2e4 - 1e3)));
          if (temperature <= 4e3) {
            const warmFactor = (4e3 - temperature) / (4e3 - 1e3);
            return 1 + warmFactor * 0.3;
          } else if (temperature >= 8e3) {
            const coolFactor = (temperature - 8e3) / (2e4 - 8e3);
            return 1.1 + coolFactor * 0.2;
          } else {
            const midFactor = Math.abs(temperature - 6e3) / 2e3;
            return 0.9 + midFactor * 0.2;
          }
        }
        /**
         * Re-apply the current palette immediately.  This is extremely lightweight
         * (just re-blends colours + sets CSS vars) so it can be called synchronously
         * from Year3000System after a relevant settings change.
         */
        forceRepaint(_reason = "settings-change") {
          this.refreshPalette?.();
        }
        // ============================================================================
        // 🌟 ENHANCED OKLAB INTEGRATION METHODS
        // ============================================================================
        /**
         * Determine optimal OKLAB enhancement preset based on musical and visual context
         */
        determineOptimalOKLABPreset(context) {
          const musicData = context.musicData;
          let selectedPreset = OKLABColorProcessor.PRESETS.STANDARD;
          if (musicData) {
            const { energy = 0.5, valence = 0.5 } = musicData;
            if (energy > 0.8 && valence > 0.7) {
              selectedPreset = OKLABColorProcessor.PRESETS.COSMIC;
            } else if (energy > 0.7 && valence < 0.4) {
              selectedPreset = OKLABColorProcessor.PRESETS.VIBRANT;
            } else if (energy < 0.3) {
              selectedPreset = OKLABColorProcessor.PRESETS.SUBTLE;
            }
          }
          if (context.performanceHints?.preferLightweight) {
            selectedPreset = OKLABColorProcessor.PRESETS.SUBTLE;
          }
          if (this.config?.enableDebug) {
            console.log("\u{1F52C} [ColorHarmonyEngine] OKLAB preset selection:", {
              energy: musicData?.energy,
              valence: musicData?.valence,
              selectedPreset: selectedPreset.name,
              reason: this.getPresetSelectionReason(musicData, context)
            });
          }
          return selectedPreset;
        }
        /**
         * Get comprehensive emotional temperature analysis using EmotionalTemperatureMapper
         * Enhanced with album art color analysis for multi-sensory emotion intelligence
         */
        async getAdvancedEmotionalTemperature(musicData, albumArtColors) {
          if (!this.emotionalTemperatureMapper || !musicData) {
            return null;
          }
          try {
            const analysisData = {
              energy: musicData.energy || 0.5,
              valence: musicData.valence || 0.5,
              danceability: musicData.danceability,
              tempo: musicData.tempo,
              loudness: musicData.loudness,
              acousticness: musicData.acousticness,
              instrumentalness: musicData.instrumentalness,
              speechiness: musicData.speechiness,
              mode: musicData.mode,
              key: musicData.key,
              genre: musicData.genre
            };
            const enhancedAnalysisData = await this.enhanceWithAlbumArtPsychology(analysisData, albumArtColors);
            const emotionalResult = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(enhancedAnalysisData);
            if (this.config?.enableDebug) {
              console.log("\u{1F321}\uFE0F [ColorHarmonyEngine] Advanced emotional temperature with album art enhancement:", {
                input: analysisData,
                enhanced: enhancedAnalysisData,
                albumArtInfluence: albumArtColors ? Object.keys(albumArtColors).length + " colors" : "None",
                emotion: emotionalResult.primaryEmotion,
                secondaryEmotion: emotionalResult.secondaryEmotion,
                intensity: emotionalResult.intensity,
                temperature: emotionalResult.temperature,
                oklabPreset: emotionalResult.oklabPreset.name,
                perceptualColor: emotionalResult.perceptualColorHex
              });
            }
            return emotionalResult;
          } catch (error) {
            console.warn("[ColorHarmonyEngine] Advanced emotional temperature analysis failed:", error);
            return null;
          }
        }
        /**
         * Enhance music emotion analysis with album art color psychology
         * Uses color theory and psychological associations to calibrate emotion detection
         * Creating a multi-sensory approach to artist consciousness recognition
         */
        async enhanceWithAlbumArtPsychology(originalAnalysis, albumArtColors) {
          if (!albumArtColors || Object.keys(albumArtColors).length === 0) {
            return originalAnalysis;
          }
          try {
            const colorPsychology = this.analyzeAlbumArtPsychology(albumArtColors);
            const enhanced = { ...originalAnalysis };
            const currentEnergy = enhanced.energy || 0.5;
            const currentValence = enhanced.valence || 0.5;
            if (colorPsychology.warmth > 0.6) {
              enhanced.energy = Math.min(1, currentEnergy * (1 + colorPsychology.warmth * 0.3));
              enhanced.valence = Math.min(1, currentValence + colorPsychology.warmth * 0.2);
            }
            if (colorPsychology.coolness > 0.6) {
              enhanced.energy = Math.max(0, currentEnergy * (1 - colorPsychology.coolness * 0.2));
              if (colorPsychology.saturation > 0.5) {
                enhanced.valence = Math.min(1, currentValence + colorPsychology.coolness * 0.15);
              }
            }
            if (colorPsychology.saturation > 0.7) {
              enhanced.energy = Math.min(1, currentEnergy + colorPsychology.saturation * 0.2);
            }
            if (colorPsychology.saturation < 0.3) {
              enhanced.valence = Math.max(0, currentValence - 0.15);
              enhanced.energy = Math.max(0, currentEnergy - 0.1);
            }
            if (colorPsychology.darkness > 0.7) {
              const finalEnergy = enhanced.energy || currentEnergy;
              if (finalEnergy > 0.6) {
                enhanced.energy = Math.min(1, finalEnergy + 0.1);
              } else {
                enhanced.valence = Math.max(0, (enhanced.valence || currentValence) - 0.2);
              }
            }
            if (colorPsychology.brightness > 0.8) {
              enhanced.valence = Math.min(1, (enhanced.valence || currentValence) + colorPsychology.brightness * 0.2);
            }
            if (colorPsychology.harmony > 0.8) {
              enhanced.valence = Math.min(1, (enhanced.valence || currentValence) + 0.1);
            } else if (colorPsychology.harmony < 0.3) {
              enhanced.energy = Math.min(1, (enhanced.energy || currentEnergy) + 0.15);
            }
            if (this.config?.enableDebug) {
              console.log("\u{1F3A8} [ColorHarmonyEngine] Album art psychology enhancement:", {
                original: { energy: originalAnalysis.energy || 0.5, valence: originalAnalysis.valence || 0.5 },
                enhanced: { energy: enhanced.energy || 0.5, valence: enhanced.valence || 0.5 },
                colorPsychology,
                adjustments: {
                  energyChange: (enhanced.energy || 0.5) - (originalAnalysis.energy || 0.5),
                  valenceChange: (enhanced.valence || 0.5) - (originalAnalysis.valence || 0.5)
                }
              });
            }
            return enhanced;
          } catch (error) {
            console.warn("[ColorHarmonyEngine] Album art psychology enhancement failed:", error);
            return originalAnalysis;
          }
        }
        /**
         * Analyze album art colors for psychological and emotional indicators
         * 🎨 PHASE 2.3: Enhanced with genre indicators and artist consciousness recognition
         * Based on color psychology research and artist expression patterns
         */
        analyzeAlbumArtPsychology(albumArtColors) {
          try {
            const colors = Object.values(albumArtColors);
            if (colors.length === 0) {
              return {
                warmth: 0.5,
                coolness: 0.5,
                saturation: 0.5,
                brightness: 0.5,
                darkness: 0.5,
                harmony: 0.5,
                dominantHue: 180,
                emotionalIntensity: 0.5,
                genreIndicators: {
                  electronicLikelihood: 0.5,
                  organicLikelihood: 0.5,
                  metalHardcoreLikelihood: 0.5,
                  popCommercialLikelihood: 0.5,
                  jazzClassicalLikelihood: 0.5,
                  folkAcousticLikelihood: 0.5
                },
                artistConsciousness: {
                  visualSophistication: 0.5,
                  artisticIntention: 0.5,
                  culturalIndicators: [],
                  emotionalDepth: 0.5
                }
              };
            }
            let totalWarmth = 0, totalCoolness = 0, totalSaturation = 0;
            let totalBrightness = 0, totalDarkness = 0;
            const hues = [];
            for (const color2 of colors) {
              const rgb = this.utils.hexToRgb(color2);
              if (!rgb) continue;
              const hsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
              const { h, s, l } = hsl;
              hues.push(h);
              if (h >= 0 && h <= 60 || h >= 300 && h <= 360) {
                totalWarmth += s * l;
              } else if (h >= 120 && h <= 240) {
                totalCoolness += s * l;
              }
              totalSaturation += s;
              totalBrightness += l;
              totalDarkness += 1 - l;
            }
            const count = colors.length;
            const avgWarmth = totalWarmth / count;
            const avgCoolness = totalCoolness / count;
            const avgSaturation = totalSaturation / count;
            const avgBrightness = totalBrightness / count;
            const avgDarkness = totalDarkness / count;
            const harmony = this.calculateColorHarmony(hues);
            const dominantHue = this.calculateDominantHue(hues);
            const emotionalIntensity = Math.min(1, (avgSaturation + this.calculateContrast(colors)) / 2);
            const genreIndicators = this._analyzeGenreIndicatorsFromColors({
              warmth: Math.min(1, avgWarmth),
              coolness: Math.min(1, avgCoolness),
              saturation: avgSaturation,
              brightness: avgBrightness,
              darkness: avgDarkness,
              harmony,
              dominantHue,
              emotionalIntensity
            });
            const artistConsciousness = this._analyzeArtistConsciousness(colors, {
              avgSaturation,
              avgBrightness,
              harmony,
              emotionalIntensity,
              colorCount: colors.length
            });
            return {
              warmth: Math.min(1, avgWarmth),
              coolness: Math.min(1, avgCoolness),
              saturation: avgSaturation,
              brightness: avgBrightness,
              darkness: avgDarkness,
              harmony,
              dominantHue,
              emotionalIntensity,
              genreIndicators,
              artistConsciousness
            };
          } catch (error) {
            console.warn("[ColorHarmonyEngine] Album art psychology analysis failed:", error);
            return {
              warmth: 0.5,
              coolness: 0.5,
              saturation: 0.5,
              brightness: 0.5,
              darkness: 0.5,
              harmony: 0.5,
              dominantHue: 180,
              emotionalIntensity: 0.5,
              genreIndicators: {
                electronicLikelihood: 0.5,
                organicLikelihood: 0.5,
                metalHardcoreLikelihood: 0.5,
                popCommercialLikelihood: 0.5,
                jazzClassicalLikelihood: 0.5,
                folkAcousticLikelihood: 0.5
              },
              artistConsciousness: {
                visualSophistication: 0.5,
                artisticIntention: 0.5,
                culturalIndicators: [],
                emotionalDepth: 0.5
              }
            };
          }
        }
        /**
         * Calculate color harmony score based on hue relationships
         */
        calculateColorHarmony(hues) {
          if (hues.length <= 1) return 1;
          let harmonyScore = 0;
          const harmonyTypes = [
            60,
            // Complementary
            120,
            // Triadic  
            30,
            // Analogous
            90
            // Tetradic
          ];
          for (let i = 0; i < hues.length; i++) {
            for (let j = i + 1; j < hues.length; j++) {
              const hue1 = hues[i];
              const hue2 = hues[j];
              if (hue1 === void 0 || hue2 === void 0) continue;
              const diff = Math.abs(hue1 - hue2);
              const minDiff = Math.min(diff, 360 - diff);
              for (const harmonic of harmonyTypes) {
                if (Math.abs(minDiff - harmonic) <= 15) {
                  harmonyScore += 1;
                }
              }
            }
          }
          const maxPossible = hues.length * (hues.length - 1) / 2;
          return Math.min(1, harmonyScore / maxPossible);
        }
        /**
         * Calculate dominant hue from hue array
         */
        calculateDominantHue(hues) {
          if (hues.length === 0) return 180;
          const segments = new Array(12).fill(0);
          for (const hue of hues) {
            const segment = Math.floor(hue / 30);
            segments[segment]++;
          }
          const maxSegment = segments.indexOf(Math.max(...segments));
          return maxSegment * 30 + 15;
        }
        /**
         * Calculate contrast level between colors
         */
        calculateContrast(colors) {
          if (colors.length <= 1) return 0;
          let totalContrast = 0;
          let comparisons = 0;
          for (let i = 0; i < colors.length; i++) {
            for (let j = i + 1; j < colors.length; j++) {
              const color1 = colors[i];
              const color2 = colors[j];
              if (!color1 || !color2) continue;
              const rgb1 = this.utils.hexToRgb(color1);
              const rgb2 = this.utils.hexToRgb(color2);
              if (rgb1 && rgb2) {
                const lum1 = (rgb1.r * 0.299 + rgb1.g * 0.587 + rgb1.b * 0.114) / 255;
                const lum2 = (rgb2.r * 0.299 + rgb2.g * 0.587 + rgb2.b * 0.114) / 255;
                totalContrast += Math.abs(lum1 - lum2);
                comparisons++;
              }
            }
          }
          return comparisons > 0 ? totalContrast / comparisons : 0;
        }
        /**
         * Blend colors using advanced OKLAB processing for perceptually uniform results
         */
        async blendWithAdvancedOKLAB(rawColors, musicData, emotionalTemperature, genreData) {
          const processedColors = { ...rawColors };
          try {
            const optimalPreset = emotionalTemperature?.oklabPreset || this.oklabState.currentPreset;
            let genreAdjustedPreset = optimalPreset;
            if (genreData && genreData.confidence > 0.5 && this.genreState.genreInfluenceIntensity > 0) {
              genreAdjustedPreset = this.applyGenreColorAesthetics(optimalPreset, genreData);
            }
            const colorPriorities = ["PRIMARY", "VIBRANT", "PROMINENT", "VIBRANT_NON_ALARMING", "LIGHT_VIBRANT"];
            for (const colorKey of colorPriorities) {
              const colorHex = rawColors[colorKey];
              if (colorHex && this.isValidHex(colorHex)) {
                try {
                  const genreKey = genreData ? `-${genreData.genre}` : "";
                  const cacheKey = `${colorHex}-${genreAdjustedPreset.name}${genreKey}`;
                  if (this.oklabState.processedPalette[cacheKey]) {
                    processedColors[colorKey] = this.oklabState.processedPalette[cacheKey].enhancedHex;
                    continue;
                  }
                  const oklabResult = this.oklabProcessor.processColor(colorHex, genreAdjustedPreset);
                  processedColors[colorKey] = oklabResult.enhancedHex;
                  this.oklabState.processedPalette[cacheKey] = oklabResult;
                  if (this.config?.enableDebug) {
                    console.log(`\u{1F3A8} [ColorHarmonyEngine] OKLAB enhanced ${colorKey}:`, {
                      original: colorHex,
                      enhanced: oklabResult.enhancedHex,
                      preset: optimalPreset.name,
                      processingTime: oklabResult.processingTime
                    });
                  }
                } catch (error) {
                  console.warn(`[ColorHarmonyEngine] OKLAB processing failed for ${colorKey}:`, error);
                }
              }
            }
            if (emotionalTemperature?.perceptualColorHex && processedColors.PRIMARY) {
              try {
                const blendResult = this.oklabProcessor.interpolateOKLAB(
                  processedColors.PRIMARY,
                  emotionalTemperature.perceptualColorHex,
                  emotionalTemperature.intensity * 0.3,
                  // Blend factor based on intensity
                  optimalPreset
                );
                processedColors.EMOTIONAL_BLEND = blendResult.enhancedHex;
                if (this.config?.enableDebug) {
                  console.log("\u{1F321}\uFE0F [ColorHarmonyEngine] Emotional color blending:", {
                    primary: processedColors.PRIMARY,
                    emotionalColor: emotionalTemperature.perceptualColorHex,
                    blendFactor: emotionalTemperature.intensity * 0.3,
                    result: blendResult.enhancedHex
                  });
                }
              } catch (error) {
                console.warn("[ColorHarmonyEngine] Emotional color blending failed:", error);
              }
            }
            this.oklabState.lastProcessingTime = Date.now();
            const albumArtInfluence = this.getAlbumArtInfluenceSetting();
            if (albumArtInfluence > 0 && rawColors && Object.keys(rawColors).length > 0) {
              try {
                const albumBlendedColors = await this._applyDirectAlbumColorBlending(
                  processedColors,
                  rawColors,
                  albumArtInfluence,
                  genreAdjustedPreset
                );
                Object.assign(processedColors, albumBlendedColors);
                if (this.config?.enableDebug) {
                  console.log("\u{1F3A8} [ColorHarmonyEngine] Applied direct album color blending:", {
                    albumInfluence: (albumArtInfluence * 100).toFixed(1) + "%",
                    blendedKeys: Object.keys(albumBlendedColors),
                    note: "album colors now directly influence final UI colors"
                  });
                }
              } catch (error) {
                console.warn("[ColorHarmonyEngine] Direct album color blending failed:", error);
              }
            }
            if (this.semanticColorManager) {
              try {
                this.semanticColorManager.updateWithAlbumColors(processedColors);
                if (this.config?.enableDebug) {
                  console.log("\u{1F3A8} [ColorHarmonyEngine] Applied comprehensive Spicetify variable updates via strategy pattern:", {
                    processedColorCount: Object.keys(processedColors).length,
                    methodUsed: "blendWithAdvancedOKLAB"
                  });
                }
              } catch (error) {
                console.warn("[ColorHarmonyEngine] Failed to update Spicetify variables via strategy pattern:", error);
              }
            }
          } catch (error) {
            console.error("[ColorHarmonyEngine] Advanced OKLAB blending failed:", error);
          }
          return processedColors;
        }
        /**
         * Generate advanced CSS variables with comprehensive OKLAB integration
         */
        generateAdvancedOKLABCSSVariables(result) {
          const cssVariables = {};
          try {
            Object.entries(result.processedColors).forEach(([key, value]) => {
              if (value && typeof value === "string") {
                cssVariables[`--sn-processed-${key.toLowerCase()}`] = value;
              }
            });
            Object.entries(this.oklabState.processedPalette).forEach(([cacheKey, oklabResult]) => {
              const [originalColor, presetName] = cacheKey.split("-");
              if (originalColor && presetName) {
                const prefix = `sn-oklab-${presetName.toLowerCase()}`;
                const oklabVars = this.oklabProcessor.generateCSSVariables(oklabResult, prefix);
                Object.assign(cssVariables, oklabVars);
              }
            });
            if (this.oklabState.perceptualGradientCache.size > 0) {
              const gradientEntries = Array.from(this.oklabState.perceptualGradientCache.entries());
              const [gradientKey, gradientStops] = gradientEntries[0] || [];
              if (gradientStops && gradientStops.length > 0) {
                gradientStops.forEach((stop, index) => {
                  const percentage = index / (gradientStops.length - 1) * 100;
                  cssVariables[`--sn-oklab-gradient-stop-${index}`] = stop.enhancedHex;
                  cssVariables[`--sn-oklab-gradient-stop-${index}-rgb`] = `${stop.enhancedRgb.r},${stop.enhancedRgb.g},${stop.enhancedRgb.b}`;
                  cssVariables[`--sn-oklab-gradient-stop-${index}-pos`] = `${percentage}%`;
                });
                const gradientString = gradientStops.map((stop, index) => {
                  const percentage = index / (gradientStops.length - 1) * 100;
                  return `${stop.enhancedHex} ${percentage}%`;
                }).join(", ");
                cssVariables["--sn-oklab-perceptual-gradient"] = `linear-gradient(135deg, ${gradientString})`;
                cssVariables["--sn-oklab-gradient-stop-count"] = gradientStops.length.toString();
              }
            }
            if (result.processedColors.EMOTIONAL_BLEND) {
              cssVariables["--sn-consciousness-emotional-color"] = result.processedColors.EMOTIONAL_BLEND;
              const emotionalRgb = hexToRgb(result.processedColors.EMOTIONAL_BLEND);
              if (emotionalRgb) {
                cssVariables["--sn-consciousness-emotional-rgb"] = `${emotionalRgb.r},${emotionalRgb.g},${emotionalRgb.b}`;
              }
            }
            cssVariables["--sn-oklab-preset-active"] = this.oklabState.currentPreset.name;
            cssVariables["--sn-oklab-cache-size"] = Object.keys(this.oklabState.processedPalette).length.toString();
            cssVariables["--sn-oklab-last-processing"] = this.oklabState.lastProcessingTime.toString();
            if (this.config?.enableDebug) {
              console.log("\u{1F3A8} [ColorHarmonyEngine] Generated advanced OKLAB CSS variables:", {
                totalVariables: Object.keys(cssVariables).length,
                gradientStops: this.oklabState.perceptualGradientCache.size,
                oklabProcessedColors: Object.keys(this.oklabState.processedPalette).length
              });
            }
          } catch (error) {
            console.error("[ColorHarmonyEngine] Advanced OKLAB CSS variable generation failed:", error);
          }
          return cssVariables;
        }
        /**
         * Generate perceptual gradient data using OKLAB interpolation for smooth color transitions
         */
        generatePerceptualGradientData(result) {
          try {
            const primaryColor = result.processedColors.PRIMARY;
            const secondaryColor = result.processedColors.SECONDARY || result.processedColors.EMOTIONAL_BLEND;
            if (!primaryColor || !this.isValidHex(primaryColor)) {
              return;
            }
            const startColor = primaryColor;
            const endColor = secondaryColor && this.isValidHex(secondaryColor) ? secondaryColor : this.generateComplementaryColor(primaryColor);
            const gradientKey = `${startColor}-${endColor}-${this.oklabState.currentPreset.name}`;
            if (this.oklabState.perceptualGradientCache.has(gradientKey)) {
              return;
            }
            const stopCount = 7;
            const gradientStops = this.oklabProcessor.generateOKLABGradient(
              startColor,
              endColor,
              stopCount,
              this.oklabState.currentPreset
            );
            this.oklabState.perceptualGradientCache.set(gradientKey, gradientStops);
            if (this.oklabState.perceptualGradientCache.size > 10) {
              const firstKey = this.oklabState.perceptualGradientCache.keys().next().value;
              if (firstKey) {
                this.oklabState.perceptualGradientCache.delete(firstKey);
              }
            }
            if (this.config?.enableDebug) {
              console.log("\u{1F308} [ColorHarmonyEngine] Generated perceptual gradient data:", {
                startColor,
                endColor,
                stopCount,
                preset: this.oklabState.currentPreset.name,
                cacheKey: gradientKey,
                cacheSize: this.oklabState.perceptualGradientCache.size
              });
            }
          } catch (error) {
            console.error("[ColorHarmonyEngine] Perceptual gradient generation failed:", error);
          }
        }
        /**
         * Update advanced harmony metrics with comprehensive performance and quality tracking
         */
        updateAdvancedHarmonyMetrics(result, processingTime) {
          try {
            const primaryColor = result.processedColors.PRIMARY;
            const secondaryColor = result.processedColors.SECONDARY;
            let harmonyScore = 0.5;
            if (primaryColor && this.isValidHex(primaryColor)) {
              const primaryRgb = hexToRgb(primaryColor);
              if (primaryRgb) {
                const vibrancy = this.calculateColorVibrancy(primaryRgb);
                harmonyScore = Math.min(1, vibrancy * 0.8 + 0.2);
              }
            }
            const metrics = {
              processingTime,
              harmonyScore,
              oklabProcessedColors: Object.keys(this.oklabState.processedPalette).length,
              perceptualGradientsCached: this.oklabState.perceptualGradientCache.size,
              currentPreset: this.oklabState.currentPreset.name,
              lastUpdate: Date.now()
            };
            if (result.metadata) {
              result.metadata.advancedHarmonyMetrics = metrics;
            }
            if (this.config?.enableDebug) {
              console.log("\u{1F4CA} [ColorHarmonyEngine] Advanced harmony metrics updated:", metrics);
            }
          } catch (error) {
            console.error("[ColorHarmonyEngine] Advanced harmony metrics update failed:", error);
          }
        }
        // ============================================================================
        // 🔧 UTILITY METHODS FOR ENHANCED OKLAB INTEGRATION
        // ============================================================================
        /**
         * Get preset selection reasoning for debugging
         */
        getPresetSelectionReason(musicData, context) {
          if (!musicData) return "No music data available";
          const { energy = 0.5, valence = 0.5 } = musicData;
          if (context.performanceHints?.preferLightweight) return "Performance optimization requested";
          if (energy > 0.8 && valence > 0.7) return "High energy + positive valence";
          if (energy > 0.7 && valence < 0.4) return "High energy + negative valence";
          if (energy < 0.3) return "Low energy music";
          return "Standard balanced processing";
        }
        /**
         * Generate complementary color for gradient endpoints
         */
        generateComplementaryColor(hexColor) {
          try {
            const rgb = hexToRgb(hexColor);
            if (!rgb) return hexColor;
            const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
            const complementHue = (hsl.h + 180) % 360;
            const complementRgb = this.hslToRgb(complementHue, hsl.s, hsl.l);
            return rgbToHex(complementRgb.r, complementRgb.g, complementRgb.b);
          } catch (error) {
            console.warn("[ColorHarmonyEngine] Complementary color generation failed:", error);
            return hexColor;
          }
        }
        /**
         * Calculate color vibrancy metric (0-1)
         */
        calculateColorVibrancy(rgb) {
          const max = Math.max(rgb.r, rgb.g, rgb.b);
          const min = Math.min(rgb.r, rgb.g, rgb.b);
          const delta = max - min;
          if (max === 0) return 0;
          const saturation = delta / max;
          const lightness = max / 255;
          const lightnessFactor = 1 - Math.abs(lightness - 0.5) * 2;
          return saturation * lightnessFactor;
        }
        /**
         * Validate hex color format
         */
        isValidHex(hex) {
          return /^#[0-9A-Fa-f]{6}$/.test(hex);
        }
        /**
         * Convert RGB to HSL color space
         */
        rgbToHsl(r, g2, b) {
          r /= 255;
          g2 /= 255;
          b /= 255;
          const max = Math.max(r, g2, b);
          const min = Math.min(r, g2, b);
          const delta = max - min;
          let h = 0;
          let s = 0;
          const l = (max + min) / 2;
          if (delta !== 0) {
            s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
            switch (max) {
              case r:
                h = (g2 - b) / delta + (g2 < b ? 6 : 0);
                break;
              case g2:
                h = (b - r) / delta + 2;
                break;
              case b:
                h = (r - g2) / delta + 4;
                break;
            }
            h /= 6;
          }
          return { h: h * 360, s, l };
        }
        /**
         * Convert HSL to RGB color space
         */
        hslToRgb(h, s, l) {
          h /= 360;
          const hue2rgb = /* @__PURE__ */ __name((p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          }, "hue2rgb");
          let r, g2, b;
          if (s === 0) {
            r = g2 = b = l;
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g2 = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return {
            r: Math.round(r * 255),
            g: Math.round(g2 * 255),
            b: Math.round(b * 255)
          };
        }
        // ============================================================================
        // GENRE AESTHETIC INTELLIGENCE METHODS
        // ============================================================================
        /**
         * Analyze current music for genre-specific aesthetic characteristics
         */
        async analyzeGenreAesthetics(musicData, albumArtColors) {
          try {
            if (!this.genreGradientEvolution) {
              return null;
            }
            const currentGenre = this.genreGradientEvolution.getCurrentGenre();
            const genreConfidence = this.genreGradientEvolution.getGenreConfidence();
            if (genreConfidence < 0.3) {
              return null;
            }
            const genreCharacteristics = this.genreGradientEvolution.getGenreCharacteristics(currentGenre);
            const genreVisualStyle = this.genreGradientEvolution.getGenreVisualStyle(currentGenre);
            let albumGenreHarmonyScore = 1;
            let genreValidatedByAlbumColors = genreConfidence;
            if (albumArtColors && Object.keys(albumArtColors).length > 0) {
              try {
                const albumColorAnalysis = this._analyzeAlbumGenreHarmony(albumArtColors, currentGenre, genreCharacteristics);
                albumGenreHarmonyScore = albumColorAnalysis.harmonyScore;
                genreValidatedByAlbumColors = genreConfidence * albumGenreHarmonyScore;
                if (this.config.enableDebug) {
                  console.log(`\u{1F3A8} [ColorHarmonyEngine] Album-Genre harmony analysis:`, {
                    genre: currentGenre,
                    originalConfidence: (genreConfidence * 100).toFixed(1) + "%",
                    harmonyScore: (albumGenreHarmonyScore * 100).toFixed(1) + "%",
                    validatedConfidence: (genreValidatedByAlbumColors * 100).toFixed(1) + "%",
                    albumColorCount: Object.keys(albumArtColors).length
                  });
                }
              } catch (error) {
                console.warn("[ColorHarmonyEngine] Album-genre harmony analysis failed:", error);
              }
            }
            this.genreState.currentGenre = currentGenre;
            this.genreState.genreConfidence = genreValidatedByAlbumColors;
            this.genreState.lastGenreUpdate = Date.now();
            this.genreState.genreHistory.unshift({
              genre: currentGenre,
              confidence: genreValidatedByAlbumColors,
              // Use album-enhanced confidence
              timestamp: Date.now()
            });
            if (this.genreState.genreHistory.length > 10) {
              this.genreState.genreHistory = this.genreState.genreHistory.slice(0, 10);
            }
            if (this.config.enableDebug) {
              console.log(`\u{1F3B6} [ColorHarmonyEngine] Genre aesthetic analysis: ${currentGenre} (${(genreValidatedByAlbumColors * 100).toFixed(1)}% album-validated confidence)`);
            }
            return {
              genre: currentGenre,
              confidence: genreValidatedByAlbumColors,
              // Return album-enhanced confidence
              characteristics: genreCharacteristics,
              visualStyle: genreVisualStyle
            };
          } catch (error) {
            console.warn("[ColorHarmonyEngine] Error analyzing genre aesthetics:", error);
            return null;
          }
        }
        /**
         * Apply genre-specific characteristics to OKLAB color preset
         */
        applyGenreColorAesthetics(basePreset, genreData) {
          const { characteristics, visualStyle, confidence } = genreData;
          const genreAdjustedPreset = {
            ...basePreset,
            name: `${basePreset.name}-${genreData.genre}`,
            description: `${basePreset.description} with ${genreData.genre} aesthetic characteristics`
          };
          const genreInfluence = confidence * this.genreState.genreInfluenceIntensity;
          if (characteristics.saturation > 0.7) {
            genreAdjustedPreset.chromaBoost = Math.min(2, basePreset.chromaBoost + 0.3 * genreInfluence);
          } else if (characteristics.saturation < 0.3) {
            genreAdjustedPreset.chromaBoost = Math.max(0.8, basePreset.chromaBoost - 0.2 * genreInfluence);
          }
          if (characteristics.harmonicComplexity > 0.7) {
            genreAdjustedPreset.vibrantThreshold = Math.max(0.05, basePreset.vibrantThreshold - 0.05 * genreInfluence);
          } else if (characteristics.harmonicComplexity < 0.3) {
            genreAdjustedPreset.vibrantThreshold = Math.min(0.2, basePreset.vibrantThreshold + 0.03 * genreInfluence);
          }
          if (characteristics.emotionalRange > 0.7 && characteristics.organicness > 0.6) {
            genreAdjustedPreset.lightnessBoost = Math.max(0.9, basePreset.lightnessBoost - 0.1 * genreInfluence);
          } else if (characteristics.artificialProcessing > 0.7) {
            genreAdjustedPreset.lightnessBoost = Math.min(1.4, basePreset.lightnessBoost + 0.2 * genreInfluence);
          }
          if (visualStyle.contrastLevel > 0.7) {
            genreAdjustedPreset.shadowReduction = Math.max(0.1, basePreset.shadowReduction - 0.1 * genreInfluence);
          } else if (characteristics.organicness > 0.6) {
            genreAdjustedPreset.shadowReduction = Math.min(0.5, basePreset.shadowReduction + 0.1 * genreInfluence);
          }
          if (this.config.enableDebug) {
            console.log(`\u{1F3A8} [ColorHarmonyEngine] Applied ${genreData.genre} aesthetics to ${basePreset.name} preset:`, {
              chromaBoost: `${basePreset.chromaBoost} \u2192 ${genreAdjustedPreset.chromaBoost}`,
              lightnessBoost: `${basePreset.lightnessBoost} \u2192 ${genreAdjustedPreset.lightnessBoost}`,
              vibrantThreshold: `${basePreset.vibrantThreshold} \u2192 ${genreAdjustedPreset.vibrantThreshold}`,
              genreInfluence: `${(genreInfluence * 100).toFixed(1)}%`
            });
          }
          return genreAdjustedPreset;
        }
        /**
         * 🎨 PHASE 2.1: Analyze album color harmony with detected genre for enhanced validation
         */
        _analyzeAlbumGenreHarmony(albumArtColors, genre, genreCharacteristics) {
          try {
            let harmonyScore = 1;
            let explanationParts = [];
            const albumHslColors = Object.entries(albumArtColors).map(([role, hex]) => {
              const rgb = this.utils.hexToRgb(hex);
              return rgb ? this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b) : null;
            }).filter((hsl) => hsl !== null);
            if (albumHslColors.length === 0) {
              return { harmonyScore: 1, explanation: "No valid album colors found" };
            }
            const avgSaturation = albumHslColors.reduce((sum, hsl) => sum + hsl.s, 0) / albumHslColors.length;
            const expectedSaturation = genreCharacteristics.saturation || 0.5;
            const saturationDiff = Math.abs(avgSaturation / 100 - expectedSaturation);
            if (saturationDiff < 0.2) {
              harmonyScore *= 1.1;
              explanationParts.push(`album saturation matches genre (\xB1${(saturationDiff * 100).toFixed(1)}%)`);
            } else if (saturationDiff > 0.4) {
              harmonyScore *= 0.85;
              explanationParts.push(`album saturation differs from genre expectations (${(saturationDiff * 100).toFixed(1)}% diff)`);
            }
            const avgHue = albumHslColors.reduce((sum, hsl) => sum + hsl.h, 0) / albumHslColors.length;
            const isWarmAlbum = avgHue >= 15 && avgHue <= 45 || avgHue >= 315 && avgHue <= 345;
            const isCoolAlbum = avgHue >= 180 && avgHue <= 270;
            const expectedWarmth = genreCharacteristics.energyLevel || 0.5;
            if (expectedWarmth > 0.6 && isWarmAlbum) {
              harmonyScore *= 1.15;
              explanationParts.push("warm album colors match high-energy genre");
            } else if (expectedWarmth < 0.4 && isCoolAlbum) {
              harmonyScore *= 1.1;
              explanationParts.push("cool album colors match low-energy genre");
            } else if (expectedWarmth > 0.6 && isCoolAlbum || expectedWarmth < 0.4 && isWarmAlbum) {
              harmonyScore *= 0.9;
              explanationParts.push("album color temperature differs from genre energy");
            }
            const avgLightness = albumHslColors.reduce((sum, hsl) => sum + hsl.l, 0) / albumHslColors.length;
            const isDarkAlbum = avgLightness < 40;
            const isBrightAlbum = avgLightness > 70;
            if (genre.includes("metal") || genre.includes("goth") || genre.includes("dark")) {
              if (isDarkAlbum) {
                harmonyScore *= 1.2;
                explanationParts.push("dark album aesthetic matches genre");
              } else if (isBrightAlbum) {
                harmonyScore *= 0.8;
                explanationParts.push("bright album conflicts with dark genre aesthetic");
              }
            } else if (genre.includes("pop") || genre.includes("dance") || genre.includes("electronic")) {
              if (isBrightAlbum) {
                harmonyScore *= 1.15;
                explanationParts.push("bright album aesthetic matches energetic genre");
              }
            }
            const colorHues = albumHslColors.map((hsl) => hsl.h);
            const hueSpread = Math.max(...colorHues) - Math.min(...colorHues);
            const isMonochromatic = hueSpread < 30;
            const isPolychromatic = hueSpread > 120;
            const expectedComplexity = genreCharacteristics.harmonicComplexity || 0.5;
            if (expectedComplexity > 0.7 && isPolychromatic) {
              harmonyScore *= 1.1;
              explanationParts.push("diverse album colors match complex genre");
            } else if (expectedComplexity < 0.3 && isMonochromatic) {
              harmonyScore *= 1.1;
              explanationParts.push("unified album colors match simple genre");
            }
            harmonyScore = Math.max(0.7, Math.min(1.3, harmonyScore));
            const explanation = explanationParts.length > 0 ? explanationParts.join("; ") : "album colors analyzed for genre harmony";
            return {
              harmonyScore,
              explanation
            };
          } catch (error) {
            console.warn("[ColorHarmonyEngine] Album-genre harmony analysis error:", error);
            return { harmonyScore: 1, explanation: "harmony analysis failed, using default confidence" };
          }
        }
        /**
         * 🎨 PHASE 2.2: Get album art influence setting (0-1) for user control
         */
        getAlbumArtInfluenceSetting() {
          return 0.5;
        }
        /**
         * 🎨 PHASE 2.2: Apply direct album color blending using OKLAB for perceptual uniformity
         */
        async _applyDirectAlbumColorBlending(processedColors, albumArtColors, albumInfluence, oklabPreset) {
          const blendedColors = {};
          try {
            const albumDominantColors = this._extractDominantAlbumColors(albumArtColors);
            if (albumDominantColors.length === 0) {
              return {};
            }
            const blendTargets = ["PRIMARY", "VIBRANT", "PROMINENT", "VIBRANT_NON_ALARMING"];
            for (const colorKey of blendTargets) {
              const processedColor = processedColors[colorKey];
              if (!processedColor || !this.isValidHex(processedColor)) {
                continue;
              }
              try {
                const bestAlbumColor = this._selectHarmoniousAlbumColor(processedColor, albumDominantColors);
                if (bestAlbumColor) {
                  const blendResult = this.oklabProcessor.interpolateOKLAB(
                    processedColor,
                    bestAlbumColor,
                    albumInfluence * 0.6,
                    // Scale down for subtle but noticeable effect
                    oklabPreset
                  );
                  blendedColors[colorKey] = blendResult.enhancedHex;
                  if (this.config?.enableDebug) {
                    console.log(`\u{1F3A8} [ColorHarmonyEngine] Album-blended ${colorKey}:`, {
                      original: processedColor,
                      albumColor: bestAlbumColor,
                      blended: blendResult.enhancedHex,
                      blendFactor: (albumInfluence * 0.6).toFixed(2)
                    });
                  }
                }
              } catch (error) {
                console.warn(`[ColorHarmonyEngine] Album blending failed for ${colorKey}:`, error);
              }
            }
            if (albumDominantColors.length > 0 && albumInfluence > 0.3) {
              try {
                const mostVibrantAlbum = this._selectMostVibrantColor(albumDominantColors);
                if (mostVibrantAlbum) {
                  const albumAccentResult = this.oklabProcessor.processColor(mostVibrantAlbum, oklabPreset);
                  blendedColors["ALBUM_ACCENT"] = albumAccentResult.enhancedHex;
                  if (this.config?.enableDebug) {
                    console.log("\u{1F3A8} [ColorHarmonyEngine] Created ALBUM_ACCENT:", {
                      source: mostVibrantAlbum,
                      enhanced: albumAccentResult.enhancedHex
                    });
                  }
                }
              } catch (error) {
                console.warn("[ColorHarmonyEngine] Album accent creation failed:", error);
              }
            }
            return blendedColors;
          } catch (error) {
            console.error("[ColorHarmonyEngine] Direct album color blending error:", error);
            return {};
          }
        }
        /**
         * 🎨 PHASE 2.2: Extract dominant colors from album art for blending
         */
        _extractDominantAlbumColors(albumArtColors) {
          const dominantColors = [];
          const colorPriorities = ["VIBRANT", "DOMINANT", "PRIMARY", "PROMINENT", "LIGHT_VIBRANT", "DARK_VIBRANT"];
          for (const priority of colorPriorities) {
            const color2 = albumArtColors[priority];
            if (color2 && this.isValidHex(color2)) {
              dominantColors.push(color2);
            }
          }
          if (dominantColors.length < 3) {
            Object.values(albumArtColors).forEach((color2) => {
              if (color2 && this.isValidHex(color2) && !dominantColors.includes(color2)) {
                dominantColors.push(color2);
              }
            });
          }
          return dominantColors.slice(0, 5);
        }
        /**
         * 🎨 PHASE 2.2: Select the most harmonious album color for blending with a processed color
         */
        _selectHarmoniousAlbumColor(processedColor, albumColors) {
          if (albumColors.length === 0) return null;
          try {
            const processedRgb = this.utils.hexToRgb(processedColor);
            if (!processedRgb) return albumColors[0] || null;
            const processedHsl = this.utils.rgbToHsl(processedRgb.r, processedRgb.g, processedRgb.b);
            let bestColor = albumColors[0] || null;
            let bestHarmonyScore = 0;
            for (const albumColor of albumColors) {
              const albumRgb = this.utils.hexToRgb(albumColor);
              if (!albumRgb) continue;
              const albumHsl = this.utils.rgbToHsl(albumRgb.r, albumRgb.g, albumRgb.b);
              const hueDiff = Math.abs(processedHsl.h - albumHsl.h);
              const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);
              let harmonyScore = 0;
              if (normalizedHueDiff < 30) {
                harmonyScore = 0.9;
              } else if (normalizedHueDiff > 150 && normalizedHueDiff < 210) {
                harmonyScore = 0.8;
              } else if (normalizedHueDiff > 90 && normalizedHueDiff < 150) {
                harmonyScore = 0.6;
              } else {
                harmonyScore = 0.4;
              }
              const saturationDiff = Math.abs(processedHsl.s - albumHsl.s);
              if (saturationDiff < 20) {
                harmonyScore += 0.1;
              }
              if (harmonyScore > bestHarmonyScore) {
                bestHarmonyScore = harmonyScore;
                bestColor = albumColor;
              }
            }
            return bestColor;
          } catch (error) {
            console.warn("[ColorHarmonyEngine] Harmonious color selection failed:", error);
            return albumColors[0] || null;
          }
        }
        /**
         * 🎨 PHASE 2.2: Select the most vibrant color from album colors
         */
        _selectMostVibrantColor(albumColors) {
          if (albumColors.length === 0) return null;
          try {
            let mostVibrant = albumColors[0] || null;
            let highestVibrancy = 0;
            for (const color2 of albumColors) {
              const rgb = this.utils.hexToRgb(color2);
              if (!rgb) continue;
              const hsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
              const vibrancy = hsl.s / 100 * (1 - Math.abs(hsl.l - 50) / 50);
              if (vibrancy > highestVibrancy) {
                highestVibrancy = vibrancy;
                mostVibrant = color2;
              }
            }
            return mostVibrant;
          } catch (error) {
            console.warn("[ColorHarmonyEngine] Most vibrant color selection failed:", error);
            return albumColors[0] || null;
          }
        }
        /**
         * 🎨 PHASE 2.3: Analyze genre indicators from color psychology characteristics
         */
        _analyzeGenreIndicatorsFromColors(colorPsychology) {
          const { warmth, coolness, saturation, brightness, darkness, harmony, dominantHue, emotionalIntensity } = colorPsychology;
          const electronicLikelihood = Math.min(
            1,
            saturation * 0.4 + coolness * 0.3 + (brightness > 0.7 || darkness < 0.3 ? 0.2 : 0) + (dominantHue >= 180 && dominantHue <= 270 ? 0.1 : 0)
            // Blues/cyans
          );
          const organicLikelihood = Math.min(
            1,
            (warmth > coolness ? warmth : 0) * 0.3 + (saturation >= 0.3 && saturation <= 0.7 ? 0.3 : 0) + (brightness >= 0.4 && brightness <= 0.7 ? 0.2 : 0) + harmony * 0.2
            // Natural colors tend to be harmonious
          );
          const metalHardcoreLikelihood = Math.min(
            1,
            darkness * 0.4 + emotionalIntensity * 0.3 + (dominantHue >= 0 && dominantHue <= 30 || dominantHue >= 330 ? 0.2 : 0) + // Reds
            (saturation > 0.6 || saturation < 0.2 ? 0.1 : 0)
            // High contrast
          );
          const popCommercialLikelihood = Math.min(
            1,
            (brightness > 0.6 ? brightness * 0.3 : 0) + saturation * 0.3 + (warmth > 0.5 ? warmth * 0.2 : 0) + (emotionalIntensity > 0.5 ? 0.2 : 0)
          );
          const jazzClassicalLikelihood = Math.min(
            1,
            harmony * 0.4 + (saturation >= 0.4 && saturation <= 0.8 ? 0.3 : 0) + (brightness >= 0.3 && brightness <= 0.8 ? 0.2 : 0) + (warmth + coolness) / 2 * 0.1
            // Balanced temperature
          );
          const folkAcousticLikelihood = Math.min(
            1,
            warmth * 0.4 + (saturation >= 0.2 && saturation <= 0.6 ? 0.3 : 0) + harmony * 0.2 + (dominantHue >= 15 && dominantHue <= 60 ? 0.1 : 0)
            // Earth tones (oranges/browns)
          );
          return {
            electronicLikelihood,
            organicLikelihood,
            metalHardcoreLikelihood,
            popCommercialLikelihood,
            jazzClassicalLikelihood,
            folkAcousticLikelihood
          };
        }
        /**
         * 🎨 PHASE 2.3: Analyze artist consciousness through color sophistication and intention
         */
        _analyzeArtistConsciousness(colors, metrics) {
          const { avgSaturation, avgBrightness, harmony, emotionalIntensity, colorCount } = metrics;
          const visualSophistication = Math.min(
            1,
            harmony * 0.4 + // Good color relationships indicate sophistication
            (colorCount > 2 && colorCount <= 5 ? 0.3 : 0.1) + // Appropriate complexity
            (avgSaturation >= 0.3 && avgSaturation <= 0.8 ? 0.2 : 0) + // Balanced saturation
            (avgBrightness >= 0.2 && avgBrightness <= 0.8 ? 0.1 : 0)
            // Appropriate brightness range
          );
          const artisticIntention = Math.min(
            1,
            harmony * 0.5 + // Harmonious colors suggest intention
            emotionalIntensity * 0.3 + // Strong emotional content suggests purpose
            (colorCount >= 2 && colorCount <= 4 ? 0.2 : 0)
            // Focused palette suggests curation
          );
          const culturalIndicators = [];
          if (avgSaturation > 0.8 && emotionalIntensity > 0.7) {
            culturalIndicators.push("high-energy-culture");
          }
          if (harmony > 0.7 && avgSaturation < 0.6) {
            culturalIndicators.push("minimalist-aesthetic");
          }
          if (avgBrightness < 0.3 && emotionalIntensity > 0.6) {
            culturalIndicators.push("dark-artistic");
          }
          if (avgBrightness > 0.7 && avgSaturation > 0.6) {
            culturalIndicators.push("commercial-pop");
          }
          const emotionalDepth = Math.min(
            1,
            emotionalIntensity * 0.5 + (avgSaturation > 0.4 ? 0.2 : 0) + // Saturated colors convey more emotion
            (harmony > 0.5 ? 0.2 : 0) + // Harmonious colors suggest emotional maturity
            (colorCount >= 3 ? 0.1 : 0)
            // Multiple colors allow for emotional complexity
          );
          return {
            visualSophistication,
            artisticIntention,
            culturalIndicators,
            emotionalDepth
          };
        }
      };
      __name(_ColorHarmonyEngine, "ColorHarmonyEngine");
      /**
       * Canonical accent CSS custom property names.
       *  – `--sn-accent-hex`  : Hex string (e.g. "#cba6f7")
       *  – `--sn-accent-rgb`  : Comma-separated R,G,B channels (e.g. "203,166,247")
       *
       * These are written by the Year3000System colour pipeline and are considered
       * the single source-of-truth accent accessed by SCSS and visual systems.
       */
      _ColorHarmonyEngine.CANONICAL_HEX_VAR = "--sn-accent-hex";
      _ColorHarmonyEngine.CANONICAL_RGB_VAR = "--sn-accent-rgb";
      ColorHarmonyEngine = _ColorHarmonyEngine;
    }
  });

  // src-js/utils/platform/SpicetifyCompat.ts
  var _SpicetifyCompat, SpicetifyCompat;
  var init_SpicetifyCompat = __esm({
    "src-js/utils/platform/SpicetifyCompat.ts"() {
      "use strict";
      _SpicetifyCompat = class _SpicetifyCompat {
        /**
         * Get audio data with fallback handling
         * Uses correct Spicetify.getAudioData() API with fallback to legacy patterns
         */
        static async getAudioData() {
          try {
            if (typeof Spicetify !== "undefined" && Spicetify.getAudioData) {
              return await Spicetify.getAudioData();
            } else {
              console.warn("[SpicetifyCompat] Spicetify.getAudioData not available");
              return null;
            }
          } catch (error) {
            console.error("[SpicetifyCompat] Error fetching audio data:", error);
            return null;
          }
        }
        /**
         * Check if Spicetify APIs are available
         */
        static isAvailable() {
          return typeof Spicetify !== "undefined" && !!Spicetify.getAudioData;
        }
        /**
         * Retry wrapper for audio data fetching
         */
        static async getAudioDataWithRetry(retryDelay = 200, maxRetries = 10) {
          for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
              const audioData = await this.getAudioData();
              if (audioData) {
                return audioData;
              }
            } catch (error) {
              if (attempt < maxRetries - 1) {
                console.log(
                  `[SpicetifyCompat] Retrying audio data fetch (${attempt + 1}/${maxRetries})...`
                );
                await new Promise((resolve) => setTimeout(resolve, retryDelay));
              } else {
                console.warn(
                  `[SpicetifyCompat] Audio data fetch failed after ${maxRetries} attempts:`,
                  error
                );
              }
            }
          }
          return null;
        }
      };
      __name(_SpicetifyCompat, "SpicetifyCompat");
      SpicetifyCompat = _SpicetifyCompat;
    }
  });

  // src-js/audio/GenreProfileManager.ts
  var GENRE_PROFILES, _GenreProfileManager, GenreProfileManager;
  var init_GenreProfileManager = __esm({
    "src-js/audio/GenreProfileManager.ts"() {
      "use strict";
      init_globalConfig();
      init_OKLABColorProcessor();
      GENRE_PROFILES = {
        // Electronic genres - high energy, vibrant colors with dynamic range
        electronic: {
          energyBoost: 1.1,
          beatEmphasis: 1.2,
          precision: 0.9,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "dynamic"
          }
        },
        dance: {
          energyBoost: 1.2,
          beatEmphasis: 1.25,
          precision: 0.95,
          oklabPreset: "COSMIC",
          colorCharacteristics: {
            vibrancyLevel: "cosmic",
            emotionalRange: "extreme",
            colorTemperature: "dynamic"
          }
        },
        house: {
          energyBoost: 1.2,
          beatEmphasis: 1.25,
          precision: 0.95,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        techno: {
          energyBoost: 1.15,
          beatEmphasis: 1.3,
          precision: 1,
          oklabPreset: "COSMIC",
          colorCharacteristics: {
            vibrancyLevel: "cosmic",
            emotionalRange: "extreme",
            colorTemperature: "cool"
          }
        },
        trance: {
          energyBoost: 1.15,
          beatEmphasis: 1.1,
          precision: 0.85,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "dynamic"
          }
        },
        // Rock genres - intense but controlled vibrancy
        rock: {
          energyBoost: 1.05,
          intensityMultiplier: 1.1,
          dynamicRange: 1.1,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        metal: {
          energyBoost: 1.15,
          intensityMultiplier: 1.2,
          dynamicRange: 1.2,
          oklabPreset: "COSMIC",
          colorCharacteristics: {
            vibrancyLevel: "cosmic",
            emotionalRange: "extreme",
            colorTemperature: "cool"
          }
        },
        punk: {
          energyBoost: 1.2,
          intensityMultiplier: 1.1,
          precision: 0.8,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "dynamic"
          }
        },
        // Urban genres - rhythmic emphasis with moderate vibrancy
        hiphop: {
          beatEmphasis: 1.3,
          grooveFactor: 1.2,
          tempoMultiplier: 0.95,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "warm"
          }
        },
        rap: {
          beatEmphasis: 1.3,
          grooveFactor: 1.2,
          tempoMultiplier: 0.95,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "neutral"
          }
        },
        // Sophisticated genres - subtle, refined enhancement
        jazz: {
          adaptiveVariation: true,
          complexity: 1.2,
          smoothingFactor: 1.3,
          oklabPreset: "SUBTLE",
          colorCharacteristics: {
            vibrancyLevel: "subtle",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        classical: {
          gentleMode: true,
          dynamicRange: 1.4,
          tempoVariationHandling: "adaptive",
          oklabPreset: "SUBTLE",
          colorCharacteristics: {
            vibrancyLevel: "subtle",
            emotionalRange: "extreme",
            colorTemperature: "neutral"
          }
        },
        ambient: {
          subtleMode: true,
          intensityReduction: 0.7,
          smoothingFactor: 1.5,
          oklabPreset: "SUBTLE",
          colorCharacteristics: {
            vibrancyLevel: "subtle",
            emotionalRange: "narrow",
            colorTemperature: "cool"
          }
        },
        // Popular genres - balanced enhancement
        pop: {
          energyBoost: 1.05,
          beatEmphasis: 1.1,
          precision: 0.85,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "warm"
          }
        },
        rnb: {
          grooveFactor: 1.25,
          smoothingFactor: 1.1,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "warm"
          }
        },
        soul: {
          grooveFactor: 1.3,
          smoothingFactor: 1.15,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        // Default fallback - safe, balanced enhancement
        default: {
          balanced: true,
          energyBoost: 1,
          beatEmphasis: 1,
          precision: 1,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "neutral"
          }
        }
      };
      _GenreProfileManager = class _GenreProfileManager {
        constructor(dependencies = {}) {
          this.config = dependencies.YEAR3000_CONFIG || YEAR3000_CONFIG;
          if (this.config.enableDebug) {
            console.log("\u{1F9EC} [GenreProfileManager] Initialized");
          }
        }
        _getGenreFromAudioFeatures(features) {
          if (!features) return "default";
          const {
            danceability = 0.5,
            energy = 0.5,
            acousticness = 0.5,
            instrumentalness = 0.5,
            tempo = 120
          } = features;
          if (instrumentalness > 0.6 && acousticness < 0.2 && energy > 0.6) {
            if (tempo > 120) return "techno";
            return "electronic";
          }
          if (danceability > 0.7 && energy > 0.7) return "dance";
          if (acousticness > 0.7 && energy < 0.4) return "classical";
          if (acousticness > 0.5 && instrumentalness < 0.1) return "jazz";
          if (energy > 0.7 && instrumentalness < 0.1 && danceability > 0.5)
            return "rock";
          if (danceability > 0.7 && instrumentalness < 0.2 && energy > 0.5 && tempo < 110)
            return "hiphop";
          return "default";
        }
        getProfileForTrack(audioFeatures) {
          const genre = this._getGenreFromAudioFeatures(audioFeatures);
          const profile = GENRE_PROFILES[genre];
          if (this.config.enableDebug) {
            console.log(
              `[GenreProfileManager] Detected genre: '${genre}'. Applying profile.`
            );
          }
          if (profile) {
            return profile;
          }
          const defaultProfile = GENRE_PROFILES.default;
          if (defaultProfile) {
            return defaultProfile;
          }
          throw new Error(
            "[GenreProfileManager] Critical: Default genre profile is missing."
          );
        }
        /**
         * Public helper that returns the genre string detected for the given audio-features without
         * allocating a full profile. Useful for colour/palette routing.
         */
        detectGenre(features) {
          return this._getGenreFromAudioFeatures(features);
        }
        // === OKLAB INTEGRATION METHODS ===
        /**
         * Get OKLAB enhancement preset for a specific genre
         * Returns the appropriate OKLAB preset based on genre characteristics
         */
        getOKLABPresetForGenre(genre) {
          const profile = GENRE_PROFILES[genre] || GENRE_PROFILES.default;
          const presetName = profile.oklabPreset || "STANDARD";
          try {
            const preset = OKLABColorProcessor.getPreset(presetName);
            if (this.config.enableDebug) {
              console.log(`\u{1F9EC} [GenreProfileManager] OKLAB preset for genre '${genre}':`, {
                genre,
                preset: presetName,
                colorCharacteristics: profile.colorCharacteristics
              });
            }
            return preset;
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(`\u{1F9EC} [GenreProfileManager] Failed to get OKLAB preset '${presetName}' for genre '${genre}', using STANDARD:`, error);
            }
            return OKLABColorProcessor.getPreset("STANDARD");
          }
        }
        /**
         * Get OKLAB enhancement preset for a track based on its audio features
         * Automatically detects genre and returns appropriate OKLAB preset
         */
        getOKLABPresetForTrack(audioFeatures) {
          const detectedGenre = this.detectGenre(audioFeatures);
          return this.getOKLABPresetForGenre(detectedGenre);
        }
        /**
         * Get color characteristics for a specific genre
         * Returns detailed color processing guidance for visual systems
         */
        getColorCharacteristicsForGenre(genre) {
          const profile = GENRE_PROFILES[genre] || GENRE_PROFILES.default;
          const characteristics = profile.colorCharacteristics || {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "neutral"
          };
          if (this.config.enableDebug) {
            console.log(`\u{1F9EC} [GenreProfileManager] Color characteristics for genre '${genre}':`, characteristics);
          }
          return characteristics;
        }
        /**
         * Get color characteristics for a track based on its audio features
         */
        getColorCharacteristicsForTrack(audioFeatures) {
          const detectedGenre = this.detectGenre(audioFeatures);
          return this.getColorCharacteristicsForGenre(detectedGenre);
        }
        /**
         * Create contextual OKLAB preset based on genre and additional factors
         * Allows for dynamic preset customization based on runtime conditions
         */
        createContextualOKLABPreset(audioFeatures, intensityMultiplier = 1, customSuffix = "contextual") {
          const detectedGenre = this.detectGenre(audioFeatures);
          const basePreset = this.getOKLABPresetForGenre(detectedGenre);
          const characteristics = this.getColorCharacteristicsForGenre(detectedGenre);
          const energyInfluence = audioFeatures.energy || 0.5;
          const danceabilityInfluence = audioFeatures.danceability || 0.5;
          const combinedIntensity = (energyInfluence + danceabilityInfluence) / 2 * intensityMultiplier;
          const contextualChromaBoost = basePreset.chromaBoost * (0.8 + combinedIntensity * 0.4);
          const contextualLightnessBoost = basePreset.lightnessBoost * (0.9 + combinedIntensity * 0.2);
          const contextualPreset = OKLABColorProcessor.createCustomPreset(
            `${detectedGenre}-${customSuffix}`,
            `Contextual ${basePreset.description} for ${detectedGenre}`,
            contextualLightnessBoost,
            contextualChromaBoost,
            basePreset.shadowReduction,
            basePreset.vibrantThreshold
          );
          if (this.config.enableDebug) {
            console.log(`\u{1F9EC} [GenreProfileManager] Created contextual OKLAB preset:`, {
              genre: detectedGenre,
              basePreset: basePreset.name,
              contextualPreset: contextualPreset.name,
              adjustments: {
                chromaBoost: `${basePreset.chromaBoost} \u2192 ${contextualChromaBoost}`,
                lightnessBoost: `${basePreset.lightnessBoost} \u2192 ${contextualLightnessBoost}`,
                intensityMultiplier,
                combinedIntensity
              }
            });
          }
          return contextualPreset;
        }
        /**
         * Get all available genre-OKLAB preset mappings
         * Useful for system initialization and debugging
         */
        getAllGenreOKLABMappings() {
          const mappings = {};
          Object.entries(GENRE_PROFILES).forEach(([genre, profile]) => {
            mappings[genre] = {
              preset: profile.oklabPreset || "STANDARD",
              characteristics: profile.colorCharacteristics
            };
          });
          if (this.config.enableDebug) {
            console.log("\u{1F9EC} [GenreProfileManager] All genre-OKLAB mappings:", mappings);
          }
          return mappings;
        }
      };
      __name(_GenreProfileManager, "GenreProfileManager");
      GenreProfileManager = _GenreProfileManager;
    }
  });

  // src-js/audio/MusicSyncService.ts
  var MUSIC_SYNC_CONFIG, _MusicSyncService, MusicSyncService;
  var init_MusicSyncService = __esm({
    "src-js/audio/MusicSyncService.ts"() {
      "use strict";
      init_globalConfig();
      init_UnifiedEventBus();
      init_Year3000Utilities();
      init_SpicetifyCompat();
      init_StorageManager();
      init_GenreProfileManager();
      init_OKLABColorProcessor();
      init_EmotionalTemperatureMapper();
      MUSIC_SYNC_CONFIG = {
        enableDebug: true,
        enableBeatSynchronization: true,
        enableGenreAnalysis: true,
        enableMoodAdaptation: true,
        bpmCalculation: {
          useEnhancedAlgorithm: true,
          danceabilityWeight: 0.9,
          energyWeight: 0.6,
          bpmWeight: 0.6,
          energyThreshold: 0.5,
          danceabilityThreshold: 0.5,
          bpmThreshold: 0.8,
          maxBPM: 180,
          minBPM: 60
        },
        performance: {
          cacheSize: 100,
          cacheTTL: 3e5,
          maxRetries: 10,
          retryDelay: 200,
          enableMetrics: true,
          processingTimeTarget: 50
        },
        synchronization: {
          beatAccuracyTarget: 50,
          maxSyncDelay: 1e3,
          adaptiveQuality: true,
          predictiveCaching: true,
          debounceRapidChanges: 200
        },
        genreProfiles: {
          electronic: { intensityMultiplier: 1.2, precisionBoost: 1.1 },
          jazz: { smoothingFactor: 1.3, adaptiveVariation: true },
          classical: { gentleMode: true, tempoVariationHandling: "adaptive" },
          rock: { energyBoost: 1.15, consistentTiming: true },
          ambient: { subtleMode: true, intensityReduction: 0.7 },
          hiphop: { beatEmphasis: 1.25, rhythmPrecision: "high" },
          default: { balanced: true }
        },
        musicVisualSync: {
          enhancedBPM: {
            fallbacks: {
              tempo: 120,
              loudness: -5,
              key: 0,
              timeSignature: 4
            },
            danceabilityEstimation: {
              highDance: { min: 125, max: 145, value: 0.8 },
              mediumDance: { min: 100, max: 124, value: 0.7 },
              lowMediumDance: { min: 80, max: 99, value: 0.6 },
              lowDance: { value: 0.5 }
            },
            energyEstimation: {
              tempoRange: { min: 80, max: 160 },
              loudnessRange: { min: -15, max: 0 },
              tempoWeight: 0.6,
              loudnessWeight: 0.4
            }
          }
        }
      };
      _MusicSyncService = class _MusicSyncService {
        constructor(dependencies = {}) {
          this.isInitialized = false;
          this.currentTrack = null;
          this.audioData = null;
          this.currentTrackUri = null;
          this.latestProcessedData = null;
          // High-precision beat scheduling
          this.beatSchedulerTimer = null;
          // Phase 1: Song Change Debouncing
          this.songChangeDebounceTimer = null;
          this.nextBeatIndex = 0;
          this.currentSongBeats = [];
          this.songStartTimestamp = 0;
          this.metrics = {
            bpmCalculations: 0,
            beatSyncs: 0,
            cacheHits: 0,
            cacheMisses: 0,
            avgProcessingTime: 0,
            performance: [],
            errors: 0,
            updates: 0
          };
          this.unifiedCache = /* @__PURE__ */ new Map();
          this.subscribers = /* @__PURE__ */ new Map();
          this.beatSync = {
            lastBeatTime: 0,
            nextBeatTime: 0,
            beatInterval: 0,
            confidence: 0,
            isActive: false
          };
          this.performanceInterval = null;
          this.cacheCleanupInterval = null;
          // Increment this prefix whenever cache schema changes to avoid stale data
          this.CACHE_KEY_VERSION_PREFIX = "v3";
          // Phase 1: Event Processing State Tracking for Loop Prevention
          this.eventProcessingState = {
            isProcessingEvent: false,
            eventChain: [],
            lastEventTime: 0,
            consecutiveEvents: 0
          };
          this.MAX_CONSECUTIVE_EVENTS = 5;
          this.EVENT_RESET_TIMEOUT = 3e3;
          /** Current unit beat direction vector (updated each beat). */
          this.currentBeatVector = { x: 0, y: 0 };
          this.config = dependencies.YEAR3000_CONFIG || YEAR3000_CONFIG;
          this.utils = dependencies.Year3000Utilities || Year3000Utilities_exports;
          this.settingsManager = dependencies.settingsManager;
          this.year3000System = dependencies.year3000System;
          this.genreProfileManager = dependencies.genreProfileManager || new GenreProfileManager({ YEAR3000_CONFIG: this.config });
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.emotionalTemperatureMapper = new EmotionalTemperatureMapper(this.config.enableDebug);
          this.cacheTTL = MUSIC_SYNC_CONFIG.performance.cacheTTL;
          this.userPreferences = this.loadUserPreferences();
          if (this.config.enableDebug) {
            console.log("\u{1F3B5} MusicSyncService constructor called");
            console.log(
              "\u{1F3B5} [MusicSyncService] Initialized with GenreProfileManager support"
            );
          }
        }
        /**
         * Public getter for initialization status (required for AdaptivePerformanceSystem dependency validation)
         */
        get initialized() {
          return this.isInitialized;
        }
        async initialize() {
          try {
            if (this.config.enableDebug) {
              console.log("\u{1F3B5} Initializing unified MusicSyncService...");
            }
            if (!SpicetifyCompat.isAvailable()) {
              console.warn(
                "[MusicSyncService] Spicetify audio data API not available at initialization. Some features may be limited."
              );
            }
            this.setupCacheManagement();
            if (MUSIC_SYNC_CONFIG.performance.enableMetrics) {
              this.setupPerformanceMonitoring();
            }
            this.isInitialized = true;
            if (this.config.enableDebug) {
              console.log("\u{1F31F} MusicSyncService initialized successfully!");
            }
          } catch (error) {
            console.error("\u274C MusicSyncService initialization failed:", error);
            this.metrics.errors++;
          }
        }
        // === SUBSCRIBER MANAGEMENT ===
        subscribe(systemInstance, systemName) {
          if (!systemInstance || typeof systemInstance.updateFromMusicAnalysis !== "function") {
            console.warn(
              `[MusicSyncService] Invalid system or missing updateFromMusicAnalysis method: ${systemName}`
            );
            return;
          }
          if (this.subscribers.has(systemName)) {
            if (this.config.enableDebug) {
              console.warn(
                `[MusicSyncService] System ${systemName} already subscribed.`
              );
            }
            return;
          }
          this.subscribers.set(systemName, systemInstance);
          if (this.config.enableDebug) {
            console.log(`[MusicSyncService] System subscribed: ${systemName}`);
          }
          if (this.latestProcessedData && systemInstance.initialized) {
            try {
              systemInstance.updateFromMusicAnalysis(
                this.latestProcessedData,
                null,
                this.currentTrackUri
              );
            } catch (error) {
              console.error(
                `[MusicSyncService] Error notifying new subscriber ${systemName}:`,
                error
              );
            }
          }
        }
        unsubscribe(systemName) {
          if (this.subscribers.has(systemName)) {
            this.subscribers.delete(systemName);
            if (this.config.enableDebug) {
              console.log(`[MusicSyncService] System unsubscribed: ${systemName}`);
            }
          }
        }
        notifySubscribers(processedData, rawFeatures, trackUri) {
          if (!this.isInitialized) {
            console.warn(
              "[MusicSyncService] Not initialized, cannot notify subscribers."
            );
            return;
          }
          this.latestProcessedData = processedData;
          for (const [name, system] of this.subscribers) {
            try {
              if (system.initialized && typeof system.updateFromMusicAnalysis === "function") {
                system.updateFromMusicAnalysis(processedData, rawFeatures, trackUri);
              }
            } catch (error) {
              console.error(
                `[MusicSyncService] Error notifying subscriber ${name}:`,
                error
              );
              this.metrics.errors++;
            }
          }
        }
        // === DATA FETCHING & CACHING ===
        async fetchAudioData(options = {}) {
          const {
            retryDelay = MUSIC_SYNC_CONFIG.performance.retryDelay,
            maxRetries = MUSIC_SYNC_CONFIG.performance.maxRetries
          } = options;
          const currentTrackUri = Spicetify.Player.data?.item?.uri;
          if (!currentTrackUri) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] No current track URI to fetch audio data."
              );
            }
            return null;
          }
          const cacheKey = this.generateCacheKey(currentTrackUri, "audioData");
          const cached = this.getFromCache(cacheKey);
          if (cached?.audioData) {
            if (this.isValidAudioData(cached.audioData)) {
              this.metrics.cacheHits++;
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Cache hit for audioData: ${cacheKey}`
                );
              }
              return cached.audioData;
            }
            this.unifiedCache.delete(cacheKey);
          }
          this.metrics.cacheMisses++;
          for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
              const audioData = await SpicetifyCompat.getAudioData();
              if (this.isValidAudioData(audioData)) {
                this.setInCache(cacheKey, { audioData });
                return audioData;
              }
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Audio analysis unavailable (attempt ${attempt + 1}/${maxRetries}). Retrying\u2026`
                );
              }
            } catch (error) {
              if (attempt === maxRetries - 1) {
                if (this.config.enableDebug) {
                  console.warn(
                    `[MusicSyncService] Audio data fetch error on final attempt:`,
                    error
                  );
                }
                this.metrics.errors++;
                const fallback = {
                  tempo: 120,
                  energy: 0.5,
                  valence: 0.5,
                  loudness: -10,
                  key: 0,
                  time_signature: 4,
                  danceability: 0.5,
                  acousticness: 0.5,
                  instrumentalness: 0,
                  speechiness: 0.05,
                  liveness: 0.2,
                  mode: 1
                };
                if (this.config.enableDebug) {
                  console.warn(
                    `[MusicSyncService] All audio-data attempts failed \u2013 using fallback defaults`
                  );
                }
                return fallback;
              }
            }
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
          }
          return null;
        }
        async getAudioFeatures() {
          try {
            const currentTrack = Spicetify.Player.data?.item;
            if (!currentTrack?.uri) return null;
            const trackId = currentTrack.uri.split(":")[2] || "fallback";
            const cacheKey = this.generateCacheKey(trackId, "features");
            const cached = this.getFromCache(
              cacheKey
            );
            if (cached?.audioFeatures) {
              this.metrics.cacheHits++;
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Cache hit for audioFeatures: ${cacheKey}`
                );
              }
              return cached.audioFeatures;
            }
            this.metrics.cacheMisses++;
            const response = await Spicetify.CosmosAsync.get(
              `https://api.spotify.com/v1/audio-features/${trackId}`
            );
            const features = {
              danceability: response.danceability,
              energy: response.energy,
              valence: response.valence,
              acousticness: response.acousticness,
              instrumentalness: response.instrumentalness,
              tempo: response.tempo
            };
            this.setInCache(cacheKey, { audioFeatures: features });
            return features;
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] Could not fetch audio features:",
                error
              );
            }
            return null;
          }
        }
        generateCacheKey(identifier, type = "default") {
          return `${this.CACHE_KEY_VERSION_PREFIX}-${identifier}-${type}`;
        }
        getFromCache(key) {
          const cached = this.unifiedCache.get(key);
          if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
            return cached.data;
          }
          if (cached) {
            this.unifiedCache.delete(key);
          }
          return null;
        }
        setInCache(key, data) {
          this.unifiedCache.set(key, {
            data,
            timestamp: Date.now()
          });
        }
        // === ENHANCED BPM CALCULATION ===
        async calculateEnhancedBPM(audioData, options = {}) {
          const startTime = performance.now();
          try {
            if (!audioData?.tempo) {
              if (this.config.enableDebug) {
                console.warn("[MusicSyncService] No BPM data available for track");
              }
              return this.getFallbackBPM();
            }
            const trackBPM = audioData.tempo;
            const config = {
              ...MUSIC_SYNC_CONFIG.bpmCalculation,
              ...options
            };
            const audioFeatures = await this.getAudioFeatures();
            if (!audioFeatures) {
              if (this.config.enableDebug) {
                console.log("[MusicSyncService] Using basic BPM calculation");
              }
              return this.validateBPM(trackBPM);
            }
            const { danceability, energy, valence = 0.5 } = audioFeatures;
            if (this.config.enableDebug) {
              console.log(
                `[MusicSyncService] Audio features - Danceability: ${danceability}, Energy: ${energy}, Valence: ${valence}`
              );
            }
            const profile = this.genreProfileManager.getProfileForTrack(
              audioFeatures || void 0
            );
            const detectedGenre = this.genreProfileManager.detectGenre(
              audioFeatures || void 0
            );
            const enhancedBPM = this.computeAdvancedBPM({
              trackBPM,
              danceability,
              energy,
              valence,
              config,
              profile
            });
            const currentTrack = Spicetify.Player.data?.item || Spicetify.Player.data;
            const uriParts = currentTrack?.uri?.split(":") ?? [];
            const trackId = uriParts.length > 2 && uriParts[2] ? uriParts[2] : "fallback";
            const cacheKey = this.generateCacheKey(trackId, "bpm");
            this.setInCache(cacheKey, {
              bpm: enhancedBPM,
              audioFeatures
            });
            this.metrics.bpmCalculations++;
            if (this.config.enableDebug) {
              console.log(
                `[MusicSyncService] Enhanced BPM: ${enhancedBPM} (original: ${trackBPM})`
              );
            }
            return enhancedBPM;
          } catch (error) {
            console.error("[MusicSyncService] BPM calculation failed:", error);
            this.metrics.errors++;
            return this.getFallbackBPM();
          }
        }
        computeAdvancedBPM(params) {
          const { trackBPM, danceability, energy, valence, config, profile } = params;
          const {
            danceabilityWeight,
            energyWeight,
            bpmWeight,
            energyThreshold,
            danceabilityThreshold,
            bpmThreshold,
            maxBPM,
            minBPM
          } = config;
          const normalizedBPM = Math.min(trackBPM / 120, 2);
          let adjustedDanceabilityWeight = danceabilityWeight;
          let adjustedEnergyWeight = energyWeight;
          let adjustedBpmWeight = bpmWeight;
          if (danceability < danceabilityThreshold) {
            adjustedDanceabilityWeight *= danceability;
          }
          if (energy < energyThreshold) {
            adjustedEnergyWeight *= energy;
          }
          if (normalizedBPM < bpmThreshold) {
            adjustedBpmWeight = 0.9;
          }
          let valenceInfluence = 1;
          if (valence > 0.6) {
            valenceInfluence = 1.05;
          } else if (valence < 0.4 && energy < 0.5) {
            valenceInfluence = 0.95;
          }
          const weightSum = adjustedDanceabilityWeight + adjustedEnergyWeight + adjustedBpmWeight;
          const weightedAverage = (danceability * adjustedDanceabilityWeight + energy * adjustedEnergyWeight + normalizedBPM * adjustedBpmWeight) / weightSum;
          let enhancedBPM = weightedAverage * 120 * valenceInfluence;
          if (profile.beatEmphasis) {
            enhancedBPM *= profile.beatEmphasis;
          }
          enhancedBPM = Math.max(minBPM, Math.min(maxBPM, enhancedBPM));
          return Math.round(enhancedBPM * 100) / 100;
        }
        validateBPM(bpm) {
          const { minBPM, maxBPM } = MUSIC_SYNC_CONFIG.bpmCalculation;
          return Math.max(minBPM, Math.min(maxBPM * 2, Math.round(bpm * 100) / 100));
        }
        getFallbackBPM() {
          return 75;
        }
        // === FEATURE ESTIMATION & FALLBACKS ===
        estimateDanceabilityFromTempo(tempo) {
          const config = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.danceabilityEstimation;
          if (tempo >= config.highDance.min && tempo <= config.highDance.max) {
            return config.highDance.value;
          }
          if (tempo >= config.mediumDance.min && tempo <= config.mediumDance.max) {
            return config.mediumDance.value;
          }
          if (tempo >= config.lowMediumDance.min && tempo <= config.lowMediumDance.max) {
            return config.lowMediumDance.value;
          }
          return config.lowDance.value;
        }
        estimateEnergyFromTempoLoudness(tempo, loudness) {
          const config = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.energyEstimation;
          const tempoFactor = Math.max(
            0,
            Math.min(
              1,
              (tempo - config.tempoRange.min) / (config.tempoRange.max - config.tempoRange.min)
            )
          );
          const loudnessFactor = Math.max(
            0,
            Math.min(
              1,
              (loudness - config.loudnessRange.min) / (config.loudnessRange.max - config.loudnessRange.min)
            )
          );
          return tempoFactor * config.tempoWeight + loudnessFactor * config.loudnessWeight;
        }
        estimateValenceFromKey(key) {
          const majorKeys = [0, 2, 4, 5, 7, 9, 11];
          return majorKeys.includes(key) ? 0.6 : 0.4;
        }
        getFallbackProcessedData(trackUri) {
          const fallbacks = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks;
          const fallbackBeatInterval = 6e4 / fallbacks.tempo;
          return {
            trackUri,
            timestamp: Date.now(),
            tempo: fallbacks.tempo,
            loudness: fallbacks.loudness,
            key: fallbacks.key,
            timeSignature: fallbacks.timeSignature,
            estimatedDanceability: this.estimateDanceabilityFromTempo(
              fallbacks.tempo
            ),
            estimatedEnergy: this.estimateEnergyFromTempoLoudness(
              fallbacks.tempo,
              fallbacks.loudness
            ),
            estimatedValence: 0.5,
            energy: 0.5,
            valence: 0.5,
            processedEnergy: 0.5,
            visualIntensity: 0.5,
            moodIdentifier: "neutral",
            baseBPM: fallbacks.tempo,
            enhancedBPM: fallbacks.tempo,
            beatInterval: fallbackBeatInterval,
            bmpCalculationMethod: "fallback",
            dataSource: "fallback"
          };
        }
        // === OKLAB-ENHANCED COLOR PROCESSING ===
        /**
         * Create OKLAB-enhanced fallback colors based on music emotional context
         * Uses EmotionalTemperatureMapper to determine appropriate emotional state and OKLAB processing
         */
        async createOKLABEnhancedFallbackColors(audioFeatures) {
          const baseFallbackColors = {
            VIBRANT: "#f2cdcd",
            // Catppuccin rosewater
            DARK_VIBRANT: "#cba6f7",
            // Catppuccin mauve  
            LIGHT_VIBRANT: "#f5c2e7",
            // Catppuccin pink
            PROMINENT: "#cba6f7",
            // Catppuccin mauve
            VIBRANT_NON_ALARMING: "#f2cdcd",
            // Catppuccin rosewater
            DESATURATED: "#9399b2"
            // Catppuccin overlay1
          };
          if (!audioFeatures || typeof audioFeatures.energy !== "number" || typeof audioFeatures.valence !== "number") {
            const standardPreset = OKLABColorProcessor.getPreset("STANDARD");
            const processedColors2 = {};
            for (const [key, color2] of Object.entries(baseFallbackColors)) {
              try {
                const oklabResult = this.oklabProcessor.processColor(color2, standardPreset);
                processedColors2[key] = oklabResult.enhancedHex;
              } catch (error) {
                if (this.config.enableDebug) {
                  console.warn(`\u{1F3A8} [MusicSyncService] OKLAB processing failed for ${key}:`, error);
                }
                processedColors2[key] = color2;
              }
            }
            return processedColors2;
          }
          const musicAnalysisData = {
            energy: audioFeatures.energy,
            valence: audioFeatures.valence,
            danceability: audioFeatures.danceability,
            tempo: audioFeatures.tempo,
            mode: audioFeatures.mode,
            genre: this.genreProfileManager.detectGenre(audioFeatures)
          };
          const emotionalResult = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(musicAnalysisData);
          let preset;
          if (emotionalResult.intensity >= 1) {
            preset = OKLABColorProcessor.getPreset("COSMIC");
          } else if (emotionalResult.intensity >= 0.7) {
            preset = OKLABColorProcessor.getPreset("VIBRANT");
          } else if (emotionalResult.intensity >= 0.5) {
            preset = OKLABColorProcessor.getPreset("STANDARD");
          } else {
            preset = OKLABColorProcessor.getPreset("SUBTLE");
          }
          const processedColors = {};
          for (const [key, color2] of Object.entries(baseFallbackColors)) {
            try {
              const oklabResult = this.oklabProcessor.processColor(color2, preset);
              processedColors[key] = oklabResult.enhancedHex;
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn(`\u{1F3A8} [MusicSyncService] OKLAB processing failed for ${key}:`, error);
              }
              processedColors[key] = color2;
            }
          }
          processedColors["--sn-emotional-primary"] = emotionalResult.perceptualColorHex || emotionalResult.primaryEmotion;
          processedColors["--sn-emotional-intensity"] = emotionalResult.intensity.toString();
          processedColors["--sn-emotional-preset"] = preset.name;
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [MusicSyncService] Created OKLAB-enhanced fallback colors:", {
              emotion: emotionalResult.primaryEmotion,
              intensity: emotionalResult.intensity,
              preset: preset.name,
              oklabCoordination: processedColors,
              musicContext: { energy: audioFeatures.energy, valence: audioFeatures.valence }
            });
          }
          return processedColors;
        }
        /**
         * Enhance successfully extracted colors with OKLAB processing based on music emotional context
         * Applies perceptually uniform color processing while preserving the original color relationships
         */
        async enhanceExtractedColorsWithOKLAB(extractedColors, audioFeatures) {
          const enhancedColors = {};
          let preset = OKLABColorProcessor.getPreset("STANDARD");
          if (audioFeatures && typeof audioFeatures.energy === "number" && typeof audioFeatures.valence === "number") {
            const musicAnalysisData = {
              energy: audioFeatures.energy,
              valence: audioFeatures.valence,
              danceability: audioFeatures.danceability,
              tempo: audioFeatures.tempo,
              mode: audioFeatures.mode,
              genre: this.genreProfileManager.detectGenre(audioFeatures)
            };
            const emotionalResult = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(musicAnalysisData);
            if (emotionalResult.intensity >= 1) {
              preset = OKLABColorProcessor.getPreset("COSMIC");
            } else if (emotionalResult.intensity >= 0.7) {
              preset = OKLABColorProcessor.getPreset("VIBRANT");
            } else if (emotionalResult.intensity >= 0.5) {
              preset = OKLABColorProcessor.getPreset("STANDARD");
            } else {
              preset = OKLABColorProcessor.getPreset("SUBTLE");
            }
            enhancedColors["--sn-emotional-primary"] = emotionalResult.perceptualColorHex || `oklabColorProcessor-${emotionalResult.primaryEmotion}`;
            enhancedColors["--sn-emotional-intensity"] = emotionalResult.intensity.toString();
            enhancedColors["--sn-emotional-temperature"] = emotionalResult.temperature.toString();
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [MusicSyncService] Applying OKLAB enhancement with emotional context:", {
                emotion: emotionalResult.primaryEmotion,
                intensity: emotionalResult.intensity,
                preset: preset.name,
                colorCount: Object.keys(extractedColors).length
              });
            }
          }
          for (const [key, color2] of Object.entries(extractedColors)) {
            if (!color2 || typeof color2 !== "string" || !color2.startsWith("#")) {
              enhancedColors[key] = color2;
              continue;
            }
            try {
              const oklabResult = this.oklabProcessor.processColor(color2, preset);
              enhancedColors[key] = oklabResult.enhancedHex;
              enhancedColors[`${key}-oklab-l`] = oklabResult.oklabEnhanced.L.toFixed(3);
              enhancedColors[`${key}-oklab-a`] = oklabResult.oklabEnhanced.a.toFixed(3);
              enhancedColors[`${key}-oklab-b`] = oklabResult.oklabEnhanced.b.toFixed(3);
              enhancedColors[`${key}-oklch-c`] = oklabResult.oklchEnhanced.C.toFixed(3);
              enhancedColors[`${key}-oklch-h`] = oklabResult.oklchEnhanced.H.toFixed(1);
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn(`\u{1F3A8} [MusicSyncService] OKLAB processing failed for ${key} (${color2}):`, error);
              }
              enhancedColors[key] = color2;
            }
          }
          enhancedColors["--sn-oklab-preset"] = preset.name;
          enhancedColors["--sn-oklab-enhanced"] = "true";
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [MusicSyncService] OKLAB color enhancement completed:", {
              originalCount: Object.keys(extractedColors).length,
              enhancedCount: Object.keys(enhancedColors).length,
              preset: preset.name,
              sampleEnhanced: {
                original: extractedColors.VIBRANT || extractedColors[Object.keys(extractedColors)[0] || ""],
                enhanced: enhancedColors.VIBRANT || enhancedColors[Object.keys(enhancedColors)[0] || ""]
              }
            });
          }
          return enhancedColors;
        }
        // === MAIN PROCESSING PIPELINE ===
        async processAudioFeatures(rawSpicetifyAudioFeatures, trackUri, trackDurationMs) {
          if (!this.isInitialized) {
            console.warn("[MusicSyncService] Not initialized, skipping processing.");
            return;
          }
          this.stopBeatScheduler();
          this.currentTrackUri = trackUri;
          const cacheKey = this.generateCacheKey(trackUri, "processed");
          const cached = this.getFromCache(cacheKey);
          if (cached?.processedData) {
            this.notifySubscribers(cached.processedData, null, trackUri);
            return;
          }
          try {
            let audioAnalysisData = rawSpicetifyAudioFeatures;
            if (!audioAnalysisData) {
              audioAnalysisData = await this.fetchAudioData();
            }
            if (!audioAnalysisData) {
              throw new Error("Failed to fetch or receive audio data.");
            }
            if (audioAnalysisData.beats && audioAnalysisData.beats.length > 0) {
              this.currentSongBeats = audioAnalysisData.beats;
              this.songStartTimestamp = Date.now();
              this.nextBeatIndex = 0;
              this.scheduleNextBeatEvent();
            }
            const enhancedBPM = await this.calculateEnhancedBPM(audioAnalysisData);
            const beatInterval = enhancedBPM > 0 ? 6e4 / enhancedBPM : 0;
            const trackData = audioAnalysisData;
            const {
              tempo = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.tempo,
              loudness = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.loudness,
              key = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.key,
              time_signature: timeSignature = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.timeSignature
            } = trackData;
            const audioFeatures = await this.getAudioFeatures();
            const estimatedDanceability = audioFeatures?.danceability ?? this.estimateDanceabilityFromTempo(tempo);
            const estimatedEnergy = audioFeatures?.energy ?? this.estimateEnergyFromTempoLoudness(tempo, loudness);
            const estimatedValence = audioFeatures?.valence ?? this.estimateValenceFromKey(key);
            const artisticMultipliers = this.config.getCurrentMultipliers?.() || {
              musicEnergyBoost: 1,
              visualIntensityBase: 1
            };
            const processedEnergy = Math.max(
              0.1,
              Math.min(
                1,
                estimatedEnergy * (artisticMultipliers.musicEnergyBoost || 1)
              )
            );
            const baseIntensity = estimatedEnergy * 0.6 + estimatedDanceability * 0.4;
            const visualIntensity = baseIntensity * (artisticMultipliers.visualIntensityBase || 1);
            let moodIdentifier = "neutral";
            if (estimatedValence > 0.6 && estimatedEnergy > 0.6) {
              moodIdentifier = "energetic-happy";
            } else if (estimatedValence > 0.6 && estimatedEnergy <= 0.6) {
              moodIdentifier = "calm-happy";
            } else if (estimatedValence <= 0.4 && estimatedEnergy > 0.6) {
              moodIdentifier = "intense-moody";
            } else if (estimatedValence <= 0.4 && estimatedEnergy <= 0.4) {
              moodIdentifier = "calm-melancholy";
            }
            const animationSpeedFactor = Math.max(0.5, 0.8 + visualIntensity * 0.4);
            const genreTag = this.genreProfileManager.detectGenre(
              audioFeatures || void 0
            );
            const processedData = {
              trackUri,
              timestamp: Date.now(),
              tempo,
              loudness,
              key,
              timeSignature,
              duration: trackDurationMs,
              estimatedDanceability,
              estimatedEnergy,
              estimatedValence,
              energy: estimatedEnergy,
              valence: estimatedValence,
              processedEnergy,
              visualIntensity,
              moodIdentifier,
              baseBPM: tempo,
              enhancedBPM,
              beatInterval,
              bmpCalculationMethod: "unified-service",
              dataSource: "unified-music-sync-service",
              beatOccurred: false,
              animationSpeedFactor,
              genre: genreTag
            };
            this.setInCache(cacheKey, { processedData });
            this.latestProcessedData = processedData;
            if (this.config.enableDebug) {
              console.log("\u{1F3B5} [MusicSyncService] Processed music data:", {
                baseTempo: tempo,
                enhancedBPM,
                mood: moodIdentifier,
                energy: estimatedEnergy.toFixed(2),
                visualIntensity: visualIntensity.toFixed(2)
              });
            }
            this.notifySubscribers(
              processedData,
              rawSpicetifyAudioFeatures,
              trackUri
            );
            unifiedEventBus.emitSync("music:beat", {
              bpm: processedData.enhancedBPM,
              intensity: processedData.visualIntensity,
              timestamp: performance.now(),
              confidence: 0.8
            });
            unifiedEventBus.emitSync("music:energy", {
              energy: processedData.energy || 0.5,
              valence: processedData.valence || 0.5,
              tempo: processedData.enhancedBPM,
              timestamp: performance.now()
            });
            unifiedEventBus.emitSync("performance:frame", {
              deltaTime: 16,
              // Approximate frame time
              fps: 60,
              memoryUsage: performance.memory?.usedJSHeapSize || 0,
              timestamp: performance.now()
            });
            if (this.config.enableDebug) {
              console.log(
                "[MusicSyncService] Successfully processed audio features.",
                {
                  baseTempo: tempo,
                  enhancedBPM,
                  mood: moodIdentifier,
                  energy: estimatedEnergy.toFixed(2),
                  visualIntensity: visualIntensity.toFixed(2)
                }
              );
            }
          } catch (error) {
            console.error("[MusicSyncService] Processing failed:", error);
            this.metrics.errors++;
            const fallbackData = this.getFallbackProcessedData(trackUri);
            this.latestProcessedData = fallbackData;
            this.notifySubscribers(fallbackData, null, trackUri);
          }
        }
        /**
         * Re-extract colours & (optionally) recompute beat analysis for the current
         * track.  When `force === true` the method runs even if the track URI hasn't
         * changed (used after live settings updates so gradients repaint instantly).
         */
        async processSongUpdate(force = false) {
          const trackUri = Spicetify.Player?.data?.item?.uri;
          if (!trackUri) return;
          if (!force && trackUri === this.currentTrackUri) {
            return;
          }
          if (this.songChangeDebounceTimer) {
            clearTimeout(this.songChangeDebounceTimer);
          }
          if (force) {
            await this._processSongUpdateInternal(trackUri);
            return;
          }
          this.songChangeDebounceTimer = setTimeout(async () => {
            this.songChangeDebounceTimer = null;
            await this._processSongUpdateInternal(trackUri);
          }, MUSIC_SYNC_CONFIG.synchronization.debounceRapidChanges);
        }
        /**
         * Internal implementation of song processing, extracted for debouncing.
         * 🔧 PHASE 1: Enhanced with event loop prevention and chain tracking
         */
        async _processSongUpdateInternal(trackUri) {
          if (this.eventProcessingState.isProcessingEvent) {
            if (this.config.enableDebug) {
              console.warn("\u{1F504} [MusicSyncService] Already processing song update - skipping to prevent recursion");
            }
            return;
          }
          this.eventProcessingState.isProcessingEvent = true;
          this.eventProcessingState.lastEventTime = Date.now();
          this.eventProcessingState.consecutiveEvents++;
          this.eventProcessingState.eventChain.push("_processSongUpdateInternal");
          if (this.eventProcessingState.consecutiveEvents > this.MAX_CONSECUTIVE_EVENTS) {
            console.error("\u{1F504} [MusicSyncService] CRITICAL: Too many consecutive events - circuit breaker activated", {
              consecutiveEvents: this.eventProcessingState.consecutiveEvents,
              eventChain: this.eventProcessingState.eventChain
            });
            this._resetEventProcessingState();
            return;
          }
          const resetTimeout = setTimeout(() => {
            if (this.config.enableDebug) {
              console.warn("\u{1F504} [MusicSyncService] Event processing timeout - resetting state");
            }
            this._resetEventProcessingState();
          }, this.EVENT_RESET_TIMEOUT);
          try {
            this.invalidateTrackCaches(trackUri);
            const trackDuration = Spicetify.Player.data?.item?.duration?.milliseconds || 0;
            const results = await Promise.allSettled([
              this.getAudioFeatures(),
              this.robustColorExtraction(trackUri)
              // 🔧 IMPROVED: More robust color extraction
            ]);
            const audioFeatures = results[0].status === "fulfilled" ? results[0].value : null;
            const rawColors = results[1].status === "fulfilled" ? results[1].value : null;
            if (results[0].status === "rejected") {
              if (this.config.enableDebug) {
                console.warn(
                  "[MusicSyncService] Audio features retrieval failed, continuing without music analysis:",
                  results[0].reason
                );
              }
            }
            if (results[1].status === "rejected") {
              if (this.config.enableDebug) {
                console.warn(
                  "[MusicSyncService] Color extraction failed, continuing without color processing:",
                  results[1].reason
                );
              }
            }
            if (this.config.enableDebug) {
              const successCount = (audioFeatures ? 1 : 0) + (rawColors ? 1 : 0);
              if (successCount === 1) {
                console.log(
                  `[MusicSyncService] Graceful degradation: Continuing with ${audioFeatures ? "audio features only" : "color extraction only"}`
                );
              } else if (successCount === 2) {
                console.log("[MusicSyncService] Full feature extraction successful");
              } else {
                console.warn(
                  "[MusicSyncService] Both strategies failed, will use fallback data"
                );
              }
            }
            console.log("\u{1F3A8} [MusicSyncService] Raw colors BEFORE sanitization:", {
              rawColors,
              rawColorType: typeof rawColors,
              rawColorKeys: rawColors ? Object.keys(rawColors) : [],
              rawColorEntries: rawColors ? Object.entries(rawColors) : []
            });
            const colors = this.utils.sanitizeColorMap(
              rawColors || {}
            );
            console.log("\u{1F3A8} [MusicSyncService] Colors AFTER sanitization:", {
              sanitizedColors: colors,
              sanitizedColorType: typeof colors,
              sanitizedColorKeys: Object.keys(colors),
              sanitizedColorEntries: Object.entries(colors),
              colorCount: Object.keys(colors).length,
              droppedCount: rawColors ? Object.keys(rawColors).length - Object.keys(colors).length : 0
            });
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [MusicSyncService] Color extraction debug:", {
                trackUri,
                rawColorsReceived: rawColors,
                sanitizedColors: colors,
                colorCount: Object.keys(colors).length,
                colorExtractorFailed: results[1].status === "rejected"
              });
            }
            let finalColors = colors;
            let usingFallback = false;
            if (Object.keys(colors).length > 0) {
              try {
                finalColors = await this.enhanceExtractedColorsWithOKLAB(colors, audioFeatures);
                if (this.config.enableDebug) {
                  console.log("\u{1F3A8} [MusicSyncService] Successfully enhanced extracted colors with OKLAB processing");
                }
              } catch (oklabError) {
                if (this.config.enableDebug) {
                  console.warn("\u{1F3A8} [MusicSyncService] OKLAB enhancement failed, using original extracted colors:", oklabError);
                }
                finalColors = colors;
              }
            }
            if (Object.keys(colors).length === 0) {
              try {
                const fallbackColors = await this.createOKLABEnhancedFallbackColors(audioFeatures);
                finalColors = fallbackColors;
                usingFallback = true;
                if (this.config.enableDebug) {
                  console.warn(
                    "\u{1F3A8} [MusicSyncService] Color extraction failed, using OKLAB-enhanced Catppuccin fallback colors with emotional context"
                  );
                }
              } catch (oklabError) {
                if (this.config.enableDebug) {
                  console.warn("\u{1F3A8} [MusicSyncService] OKLAB fallback processing failed, using static fallback colors:", oklabError);
                }
                finalColors = {
                  VIBRANT: "#f2cdcd",
                  // Catppuccin rosewater
                  DARK_VIBRANT: "#cba6f7",
                  // Catppuccin mauve
                  LIGHT_VIBRANT: "#f5c2e7",
                  // Catppuccin pink
                  PROMINENT: "#cba6f7",
                  // Catppuccin mauve
                  VIBRANT_NON_ALARMING: "#f2cdcd",
                  // Catppuccin rosewater
                  DESATURATED: "#9399b2"
                  // Catppuccin overlay1
                };
                usingFallback = true;
              }
            }
            const colorContext = {
              rawColors: finalColors,
              trackUri,
              timestamp: Date.now(),
              harmonicMode: this.config.currentHarmonicMode || "catppuccin",
              musicData: audioFeatures ? {
                energy: audioFeatures.energy,
                valence: audioFeatures.valence,
                tempo: audioFeatures.tempo,
                genre: this.genreProfileManager.detectGenre(audioFeatures)
              } : void 0,
              performanceHints: {
                preferLightweight: false,
                enableAdvancedBlending: true,
                maxProcessingTime: 100
                // 100ms max for color processing
              }
            };
            console.log("\u{1F3A8} [MusicSyncService] FINAL colors before event emission:", {
              finalColors,
              finalColorKeys: Object.keys(finalColors),
              finalColorEntries: Object.entries(finalColors),
              usingFallback,
              extractionFailed: Object.keys(colors).length === 0
            });
            const eventData = {
              rawColors: colorContext.rawColors,
              trackUri: colorContext.trackUri,
              timestamp: Date.now()
            };
            if (colorContext.musicData) {
              eventData.musicData = colorContext.musicData;
            }
            console.log("\u{1F3A8} [MusicSyncService] Emitting colors:extracted event with data:", {
              eventData,
              rawColorKeys: eventData.rawColors ? Object.keys(eventData.rawColors) : [],
              rawColorEntries: eventData.rawColors ? Object.entries(eventData.rawColors) : []
            });
            unifiedEventBus.emitSync("colors:extracted", eventData);
            if (this.config.enableDebug) {
              console.log(
                "\u{1F3B5} [MusicSyncService] Emitted colors:extracted event for strategy processing",
                {
                  trackUri,
                  colorCount: Object.keys(finalColors).length,
                  usingFallback,
                  extractionFailed: Object.keys(colors).length === 0
                }
              );
            }
            if (audioFeatures) {
              const provisionalAudioData = this.convertFeaturesToAudioData(audioFeatures);
              await this.processAudioFeatures(
                provisionalAudioData,
                trackUri,
                trackDuration
              );
            }
            (async () => {
              const fullAnalysis = await this.fetchAudioData();
              if (this.isValidAudioData(fullAnalysis)) {
                await this.processAudioFeatures(
                  fullAnalysis,
                  trackUri,
                  trackDuration
                );
              }
            })();
          } catch (error) {
            console.error(
              `[MusicSyncService] Error processing song update for ${trackUri}:`,
              error
            );
            this.metrics.errors++;
          } finally {
            clearTimeout(resetTimeout);
            this._resetEventProcessingState();
            const chainIndex = this.eventProcessingState.eventChain.indexOf("_processSongUpdateInternal");
            if (chainIndex > -1) {
              this.eventProcessingState.eventChain.splice(chainIndex, 1);
            }
          }
        }
        /**
         * Phase 1: Reset event processing state for loop prevention
         */
        _resetEventProcessingState() {
          this.eventProcessingState.isProcessingEvent = false;
          this.eventProcessingState.eventChain = [];
          const now = Date.now();
          const timeSinceLastEvent = now - this.eventProcessingState.lastEventTime;
          if (timeSinceLastEvent > this.EVENT_RESET_TIMEOUT) {
            this.eventProcessingState.consecutiveEvents = 0;
          } else {
            const decayFactor = Math.min(1, timeSinceLastEvent / this.EVENT_RESET_TIMEOUT);
            this.eventProcessingState.consecutiveEvents = Math.floor(
              this.eventProcessingState.consecutiveEvents * (1 - decayFactor)
            );
          }
          if (this.config.enableDebug && this.eventProcessingState.consecutiveEvents > 0) {
            console.log("\u{1F504} [MusicSyncService] Event processing state reset", {
              consecutiveEvents: this.eventProcessingState.consecutiveEvents,
              timeSinceLastEvent
            });
          }
        }
        // === LIFECYCLE & HELPERS ===
        setupCacheManagement() {
          this.cacheCleanupInterval = setInterval(() => {
            const now = Date.now();
            for (const [key, cacheEntry] of this.unifiedCache.entries()) {
              if (now - cacheEntry.timestamp > this.cacheTTL) {
                this.unifiedCache.delete(key);
              }
            }
          }, this.cacheTTL);
        }
        setupPerformanceMonitoring() {
          this.performanceInterval = setInterval(() => {
            if (this.metrics.performance.length > 0) {
              const avg = this.metrics.performance.reduce((a, b) => a + b, 0) / this.metrics.performance.length;
              this.metrics.avgProcessingTime = avg;
              this.metrics.performance = [];
            }
          }, 6e4);
        }
        loadUserPreferences() {
          try {
            const prefs = StorageManager.get("sn-music-sync-prefs");
            return prefs ? JSON.parse(prefs) : {};
          } catch (e) {
            return {};
          }
        }
        saveUserPreferences() {
          try {
            StorageManager.set(
              "sn-music-sync-prefs",
              JSON.stringify(this.userPreferences)
            );
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] Could not save user preferences:",
                error
              );
            }
          }
        }
        updateConfiguration(newConfig) {
          const previousConfig = { ...MUSIC_SYNC_CONFIG };
          Object.assign(MUSIC_SYNC_CONFIG, newConfig);
          if (this.config.enableDebug) {
            console.log("\u{1F3B5} [MusicSyncService] Configuration updated", {
              from: previousConfig,
              to: MUSIC_SYNC_CONFIG
            });
          }
          this.cacheTTL = MUSIC_SYNC_CONFIG.performance.cacheTTL;
          if (previousConfig.performance.enableMetrics !== MUSIC_SYNC_CONFIG.performance.enableMetrics) {
            if (MUSIC_SYNC_CONFIG.performance.enableMetrics) {
              this.setupPerformanceMonitoring();
            } else if (this.performanceInterval) {
              clearInterval(this.performanceInterval);
              this.performanceInterval = null;
            }
          }
        }
        destroy() {
          if (this.songChangeDebounceTimer) {
            clearTimeout(this.songChangeDebounceTimer);
            this.songChangeDebounceTimer = null;
          }
          this.stopBeatScheduler();
          if (this.performanceInterval) clearInterval(this.performanceInterval);
          if (this.cacheCleanupInterval) clearInterval(this.cacheCleanupInterval);
          this.subscribers.clear();
          this.unifiedCache.clear();
          this.isInitialized = false;
          this.latestProcessedData = null;
          this.metrics = {
            bpmCalculations: 0,
            beatSyncs: 0,
            cacheHits: 0,
            cacheMisses: 0,
            avgProcessingTime: 0,
            performance: [],
            errors: 0,
            updates: 0
          };
          this.cacheCleanupInterval = null;
        }
        // Legacy method for backward compatibility - now uses event-driven pattern
        setColorHarmonyEngine(engine) {
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3B5} [MusicSyncService] setColorHarmonyEngine called - now using event-driven pattern instead of direct dependency."
            );
          }
        }
        getLatestProcessedData() {
          return this.latestProcessedData;
        }
        /**
         * Get the latest beat vector (unit direction) for visual systems that need
         * directional rhythm cues. Falls back to {0,0} when unavailable.
         */
        getCurrentBeatVector() {
          return { ...this.currentBeatVector };
        }
        stopBeatScheduler() {
          if (this.beatSchedulerTimer) {
            clearTimeout(this.beatSchedulerTimer);
            this.beatSchedulerTimer = null;
          }
        }
        triggerBeatEvent() {
          const GOLDEN_RATIO = 0.61803398875;
          const angle = this.nextBeatIndex * GOLDEN_RATIO % 1 * Math.PI * 2;
          this.currentBeatVector = { x: Math.cos(angle), y: Math.sin(angle) };
          if (this.latestProcessedData) {
            const beatUpdate = {
              ...this.latestProcessedData,
              beatOccurred: true,
              beatVector: this.currentBeatVector
            };
            this.notifySubscribers(beatUpdate, null, this.currentTrackUri);
          }
          this.nextBeatIndex++;
          this.scheduleNextBeatEvent();
        }
        scheduleNextBeatEvent() {
          if (this.nextBeatIndex >= this.currentSongBeats.length) {
            return;
          }
          const nextBeat = this.currentSongBeats[this.nextBeatIndex];
          const timeSinceSongStart = Date.now() - this.songStartTimestamp;
          const delay = nextBeat.start * 1e3 - timeSinceSongStart;
          if (delay >= 0) {
            this.beatSchedulerTimer = setTimeout(
              () => this.triggerBeatEvent(),
              delay
            );
          } else {
            this.nextBeatIndex++;
            this.scheduleNextBeatEvent();
          }
        }
        /**
         * Validate that the returned audio analysis object actually contains usable
         * information (primarily tempo). Spotify may return an empty object when the
         * analysis is not ready yet – treating that as valid poisons the cache.
         */
        isValidAudioData(data) {
          return !!data && typeof data.tempo === "number" && data.tempo > 0;
        }
        /**
         * Remove any cached entries (audioData, features, bpm, processed) belonging
         * to the provided track URI. Useful when switching tracks to ensure we do
         * not reuse stale or invalid data cached under the previous song.
         */
        invalidateTrackCaches(trackUri) {
          if (!trackUri) return;
          for (const key of this.unifiedCache.keys()) {
            if (key.includes(trackUri)) {
              this.unifiedCache.delete(key);
            }
          }
        }
        /**
         * Convert the lightweight `audio-features` payload into a pseudo `AudioData`
         * object so the rest of the pipeline (which expects full analysis) can work
         * immediately. Missing properties are filled with sensible defaults.
         */
        convertFeaturesToAudioData(features) {
          const fb = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks;
          return {
            tempo: features.tempo,
            energy: features.energy,
            valence: features.valence,
            loudness: fb.loudness,
            key: fb.key,
            time_signature: fb.timeSignature,
            danceability: features.danceability,
            acousticness: features.acousticness,
            instrumentalness: features.instrumentalness,
            speechiness: 0,
            liveness: 0,
            mode: 0
            // Optional arrays left undefined – beat grid will arrive later
          };
        }
        /**
         * 🔧 IMPROVED: Robust color extraction with retry logic and fallbacks
         */
        async robustColorExtraction(trackUri, maxRetries = 3) {
          console.log("\u{1F3A8} [MusicSyncService] Starting robust color extraction:", {
            trackUri,
            maxRetries,
            timestamp: Date.now()
          });
          for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
              if (!trackUri) {
                console.warn(
                  "\u{1F3A8} [MusicSyncService] Empty trackUri provided to color extraction"
                );
                return null;
              }
              console.log(`\u{1F3A8} [MusicSyncService] Calling Spicetify.colorExtractor (attempt ${attempt})...`);
              const colors = await Spicetify.colorExtractor(trackUri);
              console.log(
                `\u{1F3A8} [MusicSyncService] Raw color extraction result (attempt ${attempt}):`,
                {
                  trackUri,
                  success: !!colors,
                  colorsType: typeof colors,
                  colorsIsNull: colors === null,
                  colorsIsUndefined: colors === void 0,
                  colorCount: colors ? Object.keys(colors).length : 0,
                  rawColors: colors,
                  colorKeys: colors ? Object.keys(colors) : [],
                  colorValues: colors ? Object.values(colors) : []
                }
              );
              if (colors && typeof colors === "object" && Object.keys(colors).length > 0) {
                Object.entries(colors).forEach(([key, value]) => {
                  console.log(`\u{1F3A8} [MusicSyncService] Extracted color: ${key} = ${value}`);
                });
                return colors;
              } else {
                console.warn(`\u{1F3A8} [MusicSyncService] Color extraction returned empty/invalid data on attempt ${attempt}`);
              }
            } catch (error) {
              console.error(
                `\u{1F3A8} [MusicSyncService] Color extraction attempt ${attempt} failed with error:`,
                error,
                {
                  errorMessage: error instanceof Error ? error.message : String(error),
                  errorStack: error instanceof Error ? error.stack : void 0
                }
              );
              if (attempt < maxRetries) {
                const waitTime = 100 * attempt;
                console.log(`\u{1F3A8} [MusicSyncService] Waiting ${waitTime}ms before retry...`);
                await new Promise((resolve) => setTimeout(resolve, waitTime));
              }
            }
          }
          console.error(
            `\u{1F3A8} [MusicSyncService] CRITICAL: All color extraction attempts failed for ${trackUri}`
          );
          return null;
        }
        // -------------------------------------------------------------------
        // External adapter integration helpers ------------------------------
        // -------------------------------------------------------------------
        /**
         * Adapter-facing helper to push music metrics without relying on the
         * full processing pipeline.  Currently a no-op placeholder that may be
         * expanded in future phases.
         */
        updateMetrics(metrics) {
          this.latestProcessedData = metrics;
        }
        /**
         * Get current music state for consciousness systems
         */
        getCurrentMusicState() {
          if (!this.latestProcessedData || !this.audioData) {
            return null;
          }
          return {
            emotion: this.latestProcessedData.emotion || null,
            beat: {
              tempo: this.latestProcessedData.bpm || this.audioData.tempo || 120,
              energy: this.latestProcessedData.energy || this.audioData.energy || 0.5,
              timestamp: Date.now()
            },
            intensity: this.latestProcessedData.intensity || this.audioData.energy || 0.5
          };
        }
        /**
         * Health check method for system status reporting
         */
        async healthCheck() {
          try {
            const isSpicetifyAvailable = SpicetifyCompat.isAvailable();
            const hasSubscribers = this.subscribers.size > 0;
            const hasRecentData = this.latestProcessedData !== null;
            const totalOperations = this.metrics.bpmCalculations + this.metrics.beatSyncs + this.metrics.cacheHits + this.metrics.cacheMisses;
            const errorRate = totalOperations > 0 ? this.metrics.errors / totalOperations : 0;
            if (!this.isInitialized) {
              return {
                status: "critical",
                message: "System not initialized",
                details: { initialized: this.isInitialized, spicetifyAvailable: isSpicetifyAvailable }
              };
            }
            if (!isSpicetifyAvailable) {
              return {
                status: "degraded",
                message: "Spicetify audio data API not available - running in limited mode",
                details: {
                  initialized: this.isInitialized,
                  spicetifyAvailable: isSpicetifyAvailable,
                  subscribers: hasSubscribers,
                  recentData: hasRecentData,
                  errorRate
                }
              };
            }
            if (errorRate > 0.5) {
              return {
                status: "degraded",
                message: `High error rate detected: ${(errorRate * 100).toFixed(1)}%`,
                details: {
                  initialized: this.isInitialized,
                  spicetifyAvailable: isSpicetifyAvailable,
                  subscribers: hasSubscribers,
                  recentData: hasRecentData,
                  errorRate,
                  errors: this.metrics.errors,
                  totalOperations
                }
              };
            }
            return {
              status: "healthy",
              message: "Music sync service operational",
              details: {
                initialized: this.isInitialized,
                spicetifyAvailable: isSpicetifyAvailable,
                subscribers: hasSubscribers,
                subscriberCount: this.subscribers.size,
                recentData: hasRecentData,
                errorRate,
                bpmCalculations: this.metrics.bpmCalculations,
                beatSyncs: this.metrics.beatSyncs,
                cacheHits: this.metrics.cacheHits,
                cacheMisses: this.metrics.cacheMisses,
                avgProcessingTime: this.metrics.avgProcessingTime,
                errors: this.metrics.errors,
                updates: this.metrics.updates
              }
            };
          } catch (error) {
            return {
              status: "critical",
              message: `Health check failed: ${error instanceof Error ? error.message : "Unknown error"}`,
              details: { error: error instanceof Error ? error.message : "Unknown error" }
            };
          }
        }
      };
      __name(_MusicSyncService, "MusicSyncService");
      MusicSyncService = _MusicSyncService;
    }
  });

  // src-js/types/signature.ts
  var createDefaultSignature;
  var init_signature = __esm({
    "src-js/types/signature.ts"() {
      "use strict";
      createDefaultSignature = /* @__PURE__ */ __name((userId) => ({
        version: "1.0.0",
        userId,
        createdAt: Date.now(),
        lastModified: Date.now(),
        colorMemories: /* @__PURE__ */ new Map(),
        rhythmicPreferences: /* @__PURE__ */ new Map(),
        emotionalResonanceProfile: {},
        evolutionaryTrajectory: {
          adaptability: 0.5,
          // Start balanced
          explorationFactor: 0.5,
          // Start balanced
          lastUpdate: Date.now()
        }
      }), "createDefaultSignature");
    }
  });

  // node_modules/idb/build/index.js
  function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
      IDBDatabase,
      IDBObjectStore,
      IDBIndex,
      IDBCursor,
      IDBTransaction
    ]);
  }
  function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey
    ]);
  }
  function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
      const unlisten = /* @__PURE__ */ __name(() => {
        request.removeEventListener("success", success);
        request.removeEventListener("error", error);
      }, "unlisten");
      const success = /* @__PURE__ */ __name(() => {
        resolve(wrap(request.result));
        unlisten();
      }, "success");
      const error = /* @__PURE__ */ __name(() => {
        reject(request.error);
        unlisten();
      }, "error");
      request.addEventListener("success", success);
      request.addEventListener("error", error);
    });
    reverseTransformCache.set(promise, request);
    return promise;
  }
  function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx))
      return;
    const done = new Promise((resolve, reject) => {
      const unlisten = /* @__PURE__ */ __name(() => {
        tx.removeEventListener("complete", complete);
        tx.removeEventListener("error", error);
        tx.removeEventListener("abort", error);
      }, "unlisten");
      const complete = /* @__PURE__ */ __name(() => {
        resolve();
        unlisten();
      }, "complete");
      const error = /* @__PURE__ */ __name(() => {
        reject(tx.error || new DOMException("AbortError", "AbortError"));
        unlisten();
      }, "error");
      tx.addEventListener("complete", complete);
      tx.addEventListener("error", error);
      tx.addEventListener("abort", error);
    });
    transactionDoneMap.set(tx, done);
  }
  function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
  }
  function wrapFunction(func) {
    if (getCursorAdvanceMethods().includes(func)) {
      return function(...args) {
        func.apply(unwrap(this), args);
        return wrap(this.request);
      };
    }
    return function(...args) {
      return wrap(func.apply(unwrap(this), args));
    };
  }
  function transformCachableValue(value) {
    if (typeof value === "function")
      return wrapFunction(value);
    if (value instanceof IDBTransaction)
      cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
      return new Proxy(value, idbProxyTraps);
    return value;
  }
  function wrap(value) {
    if (value instanceof IDBRequest)
      return promisifyRequest(value);
    if (transformCache.has(value))
      return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
      transformCache.set(value, newValue);
      reverseTransformCache.set(newValue, value);
    }
    return newValue;
  }
  function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap(request);
    if (upgrade) {
      request.addEventListener("upgradeneeded", (event) => {
        upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
      });
    }
    if (blocked) {
      request.addEventListener("blocked", (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion,
        event.newVersion,
        event
      ));
    }
    openPromise.then((db) => {
      if (terminated)
        db.addEventListener("close", () => terminated());
      if (blocking) {
        db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
      }
    }).catch(() => {
    });
    return openPromise;
  }
  function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
      return;
    }
    if (cachedMethods.get(prop))
      return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, "");
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
    ) {
      return;
    }
    const method = /* @__PURE__ */ __name(async function(storeName, ...args) {
      const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
      let target2 = tx.store;
      if (useIndex)
        target2 = target2.index(args.shift());
      return (await Promise.all([
        target2[targetFuncName](...args),
        isWrite && tx.done
      ]))[0];
    }, "method");
    cachedMethods.set(prop, method);
    return method;
  }
  async function* iterate(...args) {
    let cursor = this;
    if (!(cursor instanceof IDBCursor)) {
      cursor = await cursor.openCursor(...args);
    }
    if (!cursor)
      return;
    cursor = cursor;
    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
    reverseTransformCache.set(proxiedCursor, unwrap(cursor));
    while (cursor) {
      yield proxiedCursor;
      cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
      advanceResults.delete(proxiedCursor);
    }
  }
  function isIteratorProp(target, prop) {
    return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
  }
  var instanceOfAny, idbProxyableTypes, cursorAdvanceMethods, transactionDoneMap, transformCache, reverseTransformCache, idbProxyTraps, unwrap, readMethods, writeMethods, cachedMethods, advanceMethodProps, methodMap, advanceResults, ittrProxiedCursorToOriginalProxy, cursorIteratorTraps;
  var init_build = __esm({
    "node_modules/idb/build/index.js"() {
      instanceOfAny = /* @__PURE__ */ __name((object, constructors) => constructors.some((c) => object instanceof c), "instanceOfAny");
      __name(getIdbProxyableTypes, "getIdbProxyableTypes");
      __name(getCursorAdvanceMethods, "getCursorAdvanceMethods");
      transactionDoneMap = /* @__PURE__ */ new WeakMap();
      transformCache = /* @__PURE__ */ new WeakMap();
      reverseTransformCache = /* @__PURE__ */ new WeakMap();
      __name(promisifyRequest, "promisifyRequest");
      __name(cacheDonePromiseForTransaction, "cacheDonePromiseForTransaction");
      idbProxyTraps = {
        get(target, prop, receiver) {
          if (target instanceof IDBTransaction) {
            if (prop === "done")
              return transactionDoneMap.get(target);
            if (prop === "store") {
              return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
            }
          }
          return wrap(target[prop]);
        },
        set(target, prop, value) {
          target[prop] = value;
          return true;
        },
        has(target, prop) {
          if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
            return true;
          }
          return prop in target;
        }
      };
      __name(replaceTraps, "replaceTraps");
      __name(wrapFunction, "wrapFunction");
      __name(transformCachableValue, "transformCachableValue");
      __name(wrap, "wrap");
      unwrap = /* @__PURE__ */ __name((value) => reverseTransformCache.get(value), "unwrap");
      __name(openDB, "openDB");
      readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
      writeMethods = ["put", "add", "delete", "clear"];
      cachedMethods = /* @__PURE__ */ new Map();
      __name(getMethod, "getMethod");
      replaceTraps((oldTraps) => ({
        ...oldTraps,
        get: /* @__PURE__ */ __name((target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver), "get"),
        has: /* @__PURE__ */ __name((target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop), "has")
      }));
      advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
      methodMap = {};
      advanceResults = /* @__PURE__ */ new WeakMap();
      ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
      cursorIteratorTraps = {
        get(target, prop) {
          if (!advanceMethodProps.includes(prop))
            return target[prop];
          let cachedFunc = methodMap[prop];
          if (!cachedFunc) {
            cachedFunc = methodMap[prop] = function(...args) {
              advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
            };
          }
          return cachedFunc;
        }
      };
      __name(iterate, "iterate");
      __name(isIteratorProp, "isIteratorProp");
      replaceTraps((oldTraps) => ({
        ...oldTraps,
        get(target, prop, receiver) {
          if (isIteratorProp(target, prop))
            return iterate;
          return oldTraps.get(target, prop, receiver);
        },
        has(target, prop) {
          return isIteratorProp(target, prop) || oldTraps.has(target, prop);
        }
      }));
    }
  });

  // src-js/audio/TemporalMemoryService.ts
  var DB_NAME, DB_VERSION, SIGNATURE_STORE, SIGNATURE_KEY, _TemporalMemoryService, TemporalMemoryService, temporalMemoryService;
  var init_TemporalMemoryService = __esm({
    "src-js/audio/TemporalMemoryService.ts"() {
      "use strict";
      init_signature();
      init_build();
      DB_NAME = "Year3000-TemporalMemory";
      DB_VERSION = 1;
      SIGNATURE_STORE = "aestheticSignatures";
      SIGNATURE_KEY = "currentUser";
      _TemporalMemoryService = class _TemporalMemoryService {
        constructor() {
          this.dbPromise = openDB(DB_NAME, DB_VERSION, {
            upgrade(db) {
              if (!db.objectStoreNames.contains(SIGNATURE_STORE)) {
                db.createObjectStore(SIGNATURE_STORE);
              }
            }
          });
        }
        async getSignature(userId = "defaultUser") {
          try {
            const db = await this.dbPromise;
            const signature = await db.get(SIGNATURE_STORE, SIGNATURE_KEY);
            if (signature) {
              return signature;
            } else {
              const defaultSignature = createDefaultSignature(userId);
              await this.saveSignature(defaultSignature);
              return defaultSignature;
            }
          } catch (error) {
            console.error(
              "[TemporalMemoryService] Failed to get signature from IndexedDB. Returning default.",
              error
            );
            return createDefaultSignature(userId);
          }
        }
        async saveSignature(signature) {
          try {
            const db = await this.dbPromise;
            signature.lastModified = Date.now();
            await db.put(SIGNATURE_STORE, signature, SIGNATURE_KEY);
          } catch (error) {
            console.error(
              "[TemporalMemoryService] Failed to save signature to IndexedDB.",
              error
            );
          }
        }
        async resetSignature(userId = "defaultUser") {
          const defaultSignature = createDefaultSignature(userId);
          await this.saveSignature(defaultSignature);
          console.log("[TemporalMemoryService] Aesthetic signature has been reset.");
          return defaultSignature;
        }
        async getSignatureTrends(signature) {
          if (!signature) return null;
          const trends = {
            dominantColor: null,
            dominantRhythm: null,
            avgEnergy: 0,
            avgValence: 0
          };
          let dominantColor = null;
          signature.colorMemories.forEach((mem, hex) => {
            if (!dominantColor || mem.count > dominantColor.count) {
              dominantColor = { hex, count: mem.count };
            }
            trends.avgValence += mem.emotionalValence * mem.count;
          });
          let totalColorCount = 0;
          signature.colorMemories.forEach((mem) => totalColorCount += mem.count);
          if (totalColorCount > 0) {
            trends.avgValence /= totalColorCount;
          }
          trends.dominantColor = dominantColor;
          let dominantRhythm = null;
          signature.rhythmicPreferences.forEach((pattern, id) => {
            if (!dominantRhythm || pattern.count > dominantRhythm.count) {
              dominantRhythm = { id, count: pattern.count };
            }
            trends.avgEnergy += pattern.associatedEnergy * pattern.count;
          });
          let totalRhythmCount = 0;
          signature.rhythmicPreferences.forEach((p) => totalRhythmCount += p.count);
          if (totalRhythmCount > 0) {
            trends.avgEnergy /= totalRhythmCount;
          }
          trends.dominantRhythm = dominantRhythm;
          return trends;
        }
      };
      __name(_TemporalMemoryService, "TemporalMemoryService");
      TemporalMemoryService = _TemporalMemoryService;
      temporalMemoryService = new TemporalMemoryService();
    }
  });

  // src-js/core/animation/EnhancedMasterAnimationCoordinator.ts
  var _EnhancedMasterAnimationCoordinator, EnhancedMasterAnimationCoordinator;
  var init_EnhancedMasterAnimationCoordinator = __esm({
    "src-js/core/animation/EnhancedMasterAnimationCoordinator.ts"() {
      "use strict";
      init_EventBus();
      init_TemporalMemoryService();
      _EnhancedMasterAnimationCoordinator = class _EnhancedMasterAnimationCoordinator {
        constructor(config, performanceCoordinator) {
          this.performanceCoordinator = null;
          // Animation management
          this.animations = /* @__PURE__ */ new Map();
          this.frameCallbacks = /* @__PURE__ */ new Map();
          this.callbackCounter = 0;
          // Master animation loop
          this.animationFrameId = null;
          this.isRunning = false;
          this.isPaused = false;
          // Timing and performance
          this.lastTimestamp = 0;
          this.frameCount = 0;
          this.startTime = 0;
          this.frameTimeBudget = 16;
          // 60fps
          // Performance metrics
          this.metrics = {
            totalFrames: 0,
            droppedFrames: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            performanceMode: "quality",
            activeAnimations: 0,
            activeCallbacks: 0,
            frameRate: 60,
            lastOptimization: 0
          };
          // Frame context for visual systems
          this.frameContext = {
            timestamp: 0,
            deltaMs: 0,
            performanceMode: "quality",
            frameBudget: 16,
            beatIntensity: 0,
            scrollRatio: 0,
            tiltXY: { x: 0, y: 0 }
          };
          // Performance tracking
          this.performanceHistory = [];
          this.MAX_HISTORY_SIZE = 60;
          // 1 second at 60fps
          // ===================================================================
          // EMERGENT CHOREOGRAPHY ENGINE INTEGRATION (from consolidation)
          // ===================================================================
          // Emergent choreography state
          this.signature = null;
          this.saveInterval = null;
          this.currentBpm = 120;
          this.currentIntensity = 0.5;
          this.emergentEventSubscriptions = [];
          // =========================================================================
          // PRIVATE METHODS
          // =========================================================================
          /**
           * Main animation loop with proper frame time budgeting
           */
          this.animate = /* @__PURE__ */ __name(() => {
            if (!this.isRunning) return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.lastTimestamp;
            if (this.isPaused) {
              this.animationFrameId = requestAnimationFrame(this.animate);
              return;
            }
            this.frameContext.timestamp = currentTime;
            this.frameContext.deltaMs = deltaTime;
            const frameStartTime = performance.now();
            const FRAME_BUDGET = this.frameTimeBudget;
            const callbackStartTime = performance.now();
            this.executeFrameCallbacks(deltaTime, currentTime);
            const callbackTime = performance.now() - callbackStartTime;
            const remainingBudget = FRAME_BUDGET - callbackTime;
            if (remainingBudget > 2) {
              this.executeAnimationSystemsWithBudget(deltaTime, currentTime, remainingBudget);
            } else {
              this.metrics.droppedFrames++;
              if (this.config.enableDebug && Math.random() < 0.1) {
                console.warn(`[EnhancedMasterAnimationCoordinator] Skipped animation systems - budget exceeded: ${callbackTime.toFixed(2)}ms`);
              }
            }
            const midFrameTime = performance.now() - frameStartTime;
            if (midFrameTime < FRAME_BUDGET * 0.8) {
              this.processEmergentTick(deltaTime);
            }
            const frameTime = performance.now() - frameStartTime;
            this.updatePerformanceMetrics(frameTime);
            if (this.performanceCoordinator) {
              this.performanceCoordinator.trackSubsystem("MasterAnimationCoordinator", {
                frameTime,
                fps: this.metrics.frameRate,
                memoryUsage: performance.memory?.usedJSHeapSize || 0,
                cpuUsage: frameTime > this.frameTimeBudget ? frameTime / this.frameTimeBudget * 10 : 0
              });
            }
            this.lastTimestamp = currentTime;
            this.frameCount++;
            if (frameTime > FRAME_BUDGET * 1.5) {
              setTimeout(() => {
                this.animationFrameId = requestAnimationFrame(this.animate);
              }, 4);
            } else {
              this.animationFrameId = requestAnimationFrame(this.animate);
            }
          }, "animate");
          this.config = config;
          this.eventBus = GlobalEventBus;
          this.performanceCoordinator = performanceCoordinator || null;
          this.startTime = performance.now();
          this.lastTimestamp = this.startTime;
          this.currentMultipliers = this.config.cosmicMultipliers;
          this.subscribeToEvents();
          this.initializeEmergentChoreography();
          this.updateFrameBudget();
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Initialized with unified animation coordination and emergent choreography");
          }
        }
        /**
         * Get or create singleton instance
         */
        static getInstance(config, performanceCoordinator) {
          if (!_EnhancedMasterAnimationCoordinator.instance) {
            if (!config) {
              throw new Error("EnhancedMasterAnimationCoordinator requires config for first initialization");
            }
            _EnhancedMasterAnimationCoordinator.instance = new _EnhancedMasterAnimationCoordinator(config, performanceCoordinator);
          }
          return _EnhancedMasterAnimationCoordinator.instance;
        }
        /**
         * Register an animation system (legacy AnimationConductor compatibility)
         */
        registerAnimationSystem(name, system, priority = "normal", targetFPS = 60) {
          if (this.animations.has(name)) {
            if (this.config.enableDebug) {
              console.warn(`[EnhancedMasterAnimationCoordinator] Animation system ${name} already registered`);
            }
            return false;
          }
          const registration = {
            name,
            system,
            priority,
            targetFPS,
            type: "animation",
            enabled: true,
            frameInterval: 1e3 / targetFPS,
            lastUpdate: 0,
            frameCount: 0,
            totalTime: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            skippedFrames: 0
          };
          this.animations.set(name, registration);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered animation system: ${name} (priority: ${priority}, fps: ${targetFPS})`);
          }
          return true;
        }
        /**
         * Register a visual system (legacy VisualFrameCoordinator compatibility)
         */
        registerVisualSystem(system, priority = "normal") {
          if (this.animations.has(system.systemName)) {
            if (this.config.enableDebug) {
              console.warn(`[EnhancedMasterAnimationCoordinator] Visual system ${system.systemName} already registered`);
            }
            return false;
          }
          const registration = {
            name: system.systemName,
            system,
            priority,
            targetFPS: 60,
            type: "visual",
            enabled: true,
            frameInterval: 16.67,
            // 60fps
            lastUpdate: 0,
            frameCount: 0,
            totalTime: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            skippedFrames: 0
          };
          this.animations.set(system.systemName, registration);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered visual system: ${system.systemName} (priority: ${priority})`);
          }
          return true;
        }
        /**
         * Register a frame callback for unified RAF management
         */
        registerFrameCallback(callback, priority = "normal", system) {
          const id = `callback_${++this.callbackCounter}`;
          const frameCallback = {
            id,
            callback,
            priority,
            system: system || void 0,
            enabled: true,
            frameCount: 0,
            totalTime: 0,
            lastExecution: 0
          };
          this.frameCallbacks.set(id, frameCallback);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered frame callback: ${id} (priority: ${priority})`);
          }
          return id;
        }
        /**
         * Unregister an animation system
         */
        unregisterAnimationSystem(name) {
          const removed = this.animations.delete(name);
          if (removed) {
            this.updateMetrics();
            if (this.animations.size === 0 && this.frameCallbacks.size === 0) {
              this.stopMasterAnimationLoop();
            }
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] Unregistered animation system: ${name}`);
            }
          }
          return removed;
        }
        /**
         * Unregister a frame callback
         */
        unregisterFrameCallback(id) {
          const removed = this.frameCallbacks.delete(id);
          if (removed) {
            this.updateMetrics();
            if (this.animations.size === 0 && this.frameCallbacks.size === 0) {
              this.stopMasterAnimationLoop();
            }
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] Unregistered frame callback: ${id}`);
            }
          }
          return removed;
        }
        /**
         * Start the master animation loop
         */
        startMasterAnimationLoop() {
          if (this.isRunning) return;
          this.isRunning = true;
          this.isPaused = false;
          this.lastTimestamp = performance.now();
          this.frameCount = 0;
          this.animate();
          this.eventBus.publish("animation:loop-started", {
            timestamp: Date.now(),
            systems: this.animations.size,
            callbacks: this.frameCallbacks.size
          });
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Master animation loop started");
          }
        }
        /**
         * Stop the master animation loop
         */
        stopMasterAnimationLoop() {
          if (!this.isRunning) return;
          this.isRunning = false;
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
          this.eventBus.publish("animation:loop-stopped", {
            timestamp: Date.now(),
            totalFrames: this.frameCount,
            duration: performance.now() - this.startTime
          });
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Master animation loop stopped");
          }
        }
        /**
         * Pause the animation loop
         */
        pauseAnimationLoop() {
          this.isPaused = true;
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Animation loop paused");
          }
        }
        /**
         * Resume the animation loop
         */
        resumeAnimationLoop() {
          if (!this.isPaused) return;
          this.isPaused = false;
          this.lastTimestamp = performance.now();
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Animation loop resumed");
          }
        }
        /**
         * Set performance mode for all registered systems
         */
        setPerformanceMode(mode) {
          this.metrics.performanceMode = mode;
          this.frameContext.performanceMode = mode;
          this.frameTimeBudget = mode === "performance" ? 8 : 16;
          this.frameContext.frameBudget = this.frameTimeBudget;
          for (const registration of this.animations.values()) {
            if (registration.system.onPerformanceModeChange) {
              registration.system.onPerformanceModeChange(mode);
            }
          }
          this.eventBus.publish("animation:performance-mode-changed", {
            mode,
            timestamp: Date.now()
          });
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Performance mode set to: ${mode}`);
          }
        }
        /**
         * Get current performance metrics
         */
        getPerformanceMetrics() {
          return { ...this.metrics };
        }
        /**
         * Get all registered systems
         */
        getRegisteredSystems() {
          return {
            animations: new Map(this.animations),
            callbacks: new Map(this.frameCallbacks)
          };
        }
        /**
         * Enable or disable a specific system
         */
        setSystemEnabled(name, enabled) {
          const animation = this.animations.get(name);
          if (animation) {
            animation.enabled = enabled;
            this.updateMetrics();
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] System ${name} ${enabled ? "enabled" : "disabled"}`);
            }
            return true;
          }
          return false;
        }
        /**
         * Get current multipliers for emergent choreography
         */
        getCurrentMultipliers() {
          return this.currentMultipliers;
        }
        /**
         * Force update evolutionary trajectory
         */
        async updateEvolutionaryTrajectory() {
          await this._updateEvolutionaryTrajectory();
        }
        /**
         * Destroy the coordinator and clean up resources
         */
        destroy() {
          this.stopMasterAnimationLoop();
          this.destroyEmergentChoreography();
          for (const registration of this.animations.values()) {
            if (registration.type === "visual" && "destroy" in registration.system) {
              try {
                registration.system.destroy();
              } catch (error) {
                console.error(`[EnhancedMasterAnimationCoordinator] Error destroying system ${registration.name}:`, error);
              }
            }
          }
          this.animations.clear();
          this.frameCallbacks.clear();
          if (_EnhancedMasterAnimationCoordinator.instance === this) {
            _EnhancedMasterAnimationCoordinator.instance = null;
          }
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Destroyed");
          }
        }
        /**
         * Execute frame callbacks with priority ordering
         */
        executeFrameCallbacks(deltaTime, timestamp) {
          const sortedCallbacks = Array.from(this.frameCallbacks.values()).filter((callback) => callback.enabled).sort((a, b) => {
            const priorityOrder = { critical: 0, normal: 1, background: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
          });
          for (const callback of sortedCallbacks) {
            const callbackStartTime = performance.now();
            try {
              callback.callback(deltaTime, timestamp);
              const callbackTime = performance.now() - callbackStartTime;
              callback.totalTime += callbackTime;
              callback.frameCount++;
              callback.lastExecution = timestamp;
              if (callbackTime > this.frameTimeBudget * 0.5) {
                if (this.config.enableDebug) {
                  console.warn(`[EnhancedMasterAnimationCoordinator] Callback ${callback.id} exceeded budget: ${callbackTime.toFixed(2)}ms`);
                }
              }
            } catch (error) {
              console.error(`[EnhancedMasterAnimationCoordinator] Error in callback ${callback.id}:`, error);
            }
          }
        }
        /**
         * Execute animation systems with priority ordering and FPS throttling
         */
        executeAnimationSystems(deltaTime, timestamp) {
          const sortedSystems = Array.from(this.animations.values()).filter((animation) => animation.enabled).sort((a, b) => {
            const priorityOrder = { critical: 0, normal: 1, background: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
          });
          for (const animation of sortedSystems) {
            if (timestamp - animation.lastUpdate < animation.frameInterval) {
              animation.skippedFrames++;
              continue;
            }
            const systemStartTime = performance.now();
            try {
              if (animation.type === "visual") {
                animation.system.onAnimate(deltaTime, this.frameContext);
              } else {
                const animationSystem = animation.system;
                if (animationSystem.onAnimate) {
                  animationSystem.onAnimate(deltaTime);
                }
                if (animationSystem.updateAnimation) {
                  animationSystem.updateAnimation(timestamp, deltaTime);
                }
              }
              const systemTime = performance.now() - systemStartTime;
              animation.totalTime += systemTime;
              animation.frameCount++;
              animation.lastUpdate = timestamp;
              animation.averageFrameTime = animation.totalTime / animation.frameCount;
              animation.maxFrameTime = Math.max(animation.maxFrameTime, systemTime);
              if (systemTime > this.frameTimeBudget * 0.8) {
                if (this.config.enableDebug) {
                  console.warn(`[EnhancedMasterAnimationCoordinator] System ${animation.name} exceeded budget: ${systemTime.toFixed(2)}ms`);
                }
              }
            } catch (error) {
              console.error(`[EnhancedMasterAnimationCoordinator] Error in system ${animation.name}:`, error);
            }
          }
        }
        /**
         * Execute animation systems with frame time budget enforcement
         */
        executeAnimationSystemsWithBudget(deltaTime, timestamp, budget) {
          const startTime = performance.now();
          const sortedSystems = Array.from(this.animations.values()).filter((animation) => animation.enabled).sort((a, b) => {
            const priorityOrder = { critical: 0, normal: 1, background: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
          });
          let processedCount = 0;
          let skippedCount = 0;
          for (const animation of sortedSystems) {
            const elapsed = performance.now() - startTime;
            if (elapsed >= budget * 0.9) {
              skippedCount = sortedSystems.length - processedCount;
              if (this.config.enableDebug && skippedCount > 0) {
                console.warn(`[EnhancedMasterAnimationCoordinator] Budget exhausted: skipped ${skippedCount} systems`);
              }
              break;
            }
            if (timestamp - animation.lastUpdate < animation.frameInterval) {
              animation.skippedFrames++;
              continue;
            }
            const systemStartTime = performance.now();
            try {
              if (animation.type === "visual") {
                animation.system.onAnimate(deltaTime, this.frameContext);
              } else {
                const animationSystem = animation.system;
                if (animationSystem.onAnimate) {
                  animationSystem.onAnimate(deltaTime);
                }
                if (animationSystem.updateAnimation) {
                  animationSystem.updateAnimation(timestamp, deltaTime);
                }
              }
              const systemTime = performance.now() - systemStartTime;
              animation.totalTime += systemTime;
              animation.frameCount++;
              animation.lastUpdate = timestamp;
              animation.averageFrameTime = animation.totalTime / animation.frameCount;
              animation.maxFrameTime = Math.max(animation.maxFrameTime, systemTime);
              processedCount++;
              if (systemTime > budget * 0.3) {
                if (this.config.enableDebug) {
                  console.warn(`[EnhancedMasterAnimationCoordinator] System ${animation.name} consuming excessive budget: ${systemTime.toFixed(2)}ms`);
                }
              }
            } catch (error) {
              console.error(`[EnhancedMasterAnimationCoordinator] Error in system ${animation.name}:`, error);
              processedCount++;
            }
          }
          const totalTime = performance.now() - startTime;
          if (skippedCount > 0) {
            this.metrics.droppedFrames += skippedCount;
          }
          if (this.config.enableDebug && Math.random() < 0.02) {
            console.log(`[EnhancedMasterAnimationCoordinator] Budget usage: ${totalTime.toFixed(2)}ms/${budget.toFixed(2)}ms, processed: ${processedCount}/${sortedSystems.length}`);
          }
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics(frameTime) {
          this.metrics.totalFrames++;
          this.metrics.maxFrameTime = Math.max(this.metrics.maxFrameTime, frameTime);
          this.performanceHistory.push(frameTime);
          if (this.performanceHistory.length > this.MAX_HISTORY_SIZE) {
            this.performanceHistory.shift();
          }
          this.metrics.averageFrameTime = this.performanceHistory.reduce((sum, time) => sum + time, 0) / this.performanceHistory.length;
          this.metrics.frameRate = this.performanceHistory.length > 0 ? 1e3 / this.metrics.averageFrameTime : 60;
          if (frameTime > this.frameTimeBudget * 1.5) {
            this.metrics.droppedFrames++;
          }
          if (this.metrics.averageFrameTime > this.frameTimeBudget * 1.2 && this.metrics.performanceMode === "quality") {
            this.setPerformanceMode("performance");
            this.metrics.lastOptimization = Date.now();
          } else if (this.metrics.averageFrameTime < this.frameTimeBudget * 0.8 && this.metrics.performanceMode === "performance") {
            if (Date.now() - this.metrics.lastOptimization > 5e3) {
              this.setPerformanceMode("quality");
            }
          }
        }
        /**
         * Update frame budget based on performance mode
         */
        updateFrameBudget() {
          this.frameTimeBudget = this.metrics.performanceMode === "performance" ? 8 : 16;
          this.frameContext.frameBudget = this.frameTimeBudget;
        }
        /**
         * Update metrics counts
         */
        updateMetrics() {
          this.metrics.activeAnimations = Array.from(this.animations.values()).filter((a) => a.enabled).length;
          this.metrics.activeCallbacks = Array.from(this.frameCallbacks.values()).filter((c) => c.enabled).length;
        }
        /**
         * Subscribe to performance events
         */
        subscribeToEvents() {
          this.eventBus.subscribe("music:beat", (payload) => {
            this.frameContext.beatIntensity = payload.intensity || 0;
          });
          this.eventBus.subscribe("performance:throttle-updates", (payload) => {
            for (const animation of this.animations.values()) {
              if (animation.name === payload.subsystem || payload.subsystem === "*") {
                animation.frameInterval = Math.min(animation.frameInterval * 1.5, 33.33);
              }
            }
          });
          this.eventBus.subscribe("performance:reduce-quality", (payload) => {
            this.setPerformanceMode("performance");
          });
        }
        // =========================================================================
        // EMERGENT CHOREOGRAPHY ENGINE METHODS (from consolidation)
        // =========================================================================
        /**
         * Initialize emergent choreography functionality
         */
        async initializeEmergentChoreography() {
          try {
            this.signature = await temporalMemoryService.getSignature();
            this.registerEmergentEventListeners();
            this.saveInterval = setInterval(() => {
              if (this.signature) {
                temporalMemoryService.saveSignature(this.signature);
              }
            }, 3e4);
            if (this.config.enableDebug) {
              console.log("[EnhancedMasterAnimationCoordinator] Emergent choreography initialized");
            }
          } catch (error) {
            console.error("[EnhancedMasterAnimationCoordinator] Failed to initialize emergent choreography:", error);
          }
        }
        /**
         * Register emergent choreography event listeners
         */
        registerEmergentEventListeners() {
          const beatFrameSub = this.eventBus.subscribe(
            "beat/frame",
            (payload) => this.handleBeatFrame(payload)
          );
          const harmonyFrameSub = this.eventBus.subscribe(
            "colorharmony/frame",
            (payload) => this.handleHarmonyFrame(payload)
          );
          const bpmSub = this.eventBus.subscribe(
            "beat/bpm",
            (payload) => {
              this.currentBpm = payload.bpm;
            }
          );
          const intensitySub = this.eventBus.subscribe(
            "beat/intensity",
            (payload) => {
              this.currentIntensity = payload.intensity;
            }
          );
          this.emergentEventSubscriptions.push(
            beatFrameSub,
            harmonyFrameSub,
            bpmSub,
            intensitySub
          );
        }
        /**
         * Handle beat frame events for emergent adaptation
         */
        handleBeatFrame(payload) {
          if (!this.signature) return;
          this.signature.lastModified = Date.now();
        }
        /**
         * Handle harmony frame events for emergent adaptation
         */
        handleHarmonyFrame(payload) {
          if (!this.signature) return;
          const { kineticState } = payload;
          this.signature.lastModified = Date.now();
        }
        /**
         * Update evolutionary trajectory based on signature trends
         */
        async _updateEvolutionaryTrajectory() {
          if (!this.signature) return;
          const trends = await temporalMemoryService.getSignatureTrends(
            this.signature
          );
          if (!trends) return;
          const { avgEnergy, avgValence } = trends;
          const explorationFactor = 0.5 + (avgEnergy - 0.5) * 0.2;
          this.signature.evolutionaryTrajectory.explorationFactor = Math.max(
            0.1,
            Math.min(0.9, explorationFactor)
          );
          const adaptability = 0.5 + (Math.abs(avgValence) - 0.2) * 0.3;
          this.signature.evolutionaryTrajectory.adaptability = Math.max(
            0.1,
            Math.min(0.9, adaptability)
          );
          this.signature.evolutionaryTrajectory.lastUpdate = Date.now();
        }
        /**
         * Calculate visual pulse based on current BPM and intensity
         */
        _calculateVisualPulse(deltaMs) {
          const beatInterval = 6e4 / this.currentBpm;
          const phase = performance.now() % beatInterval / beatInterval;
          const hueShift = Math.sin(phase * 2 * Math.PI + Math.PI / 2) * 15 * this.currentIntensity;
          return {
            timestamp: performance.now(),
            bpm: this.currentBpm,
            intensity: this.currentIntensity,
            phase,
            hueShift
          };
        }
        /**
         * Calculate adaptive coefficients based on signature
         */
        _calculateAdaptiveCoefficients() {
          if (!this.signature) return;
          const { adaptability, explorationFactor } = this.signature.evolutionaryTrajectory;
          const kineticIntensity = 0.5 + adaptability * 0.5;
          const visualIntensityBase = 0.8 + explorationFactor * 0.4;
          this.currentMultipliers = {
            ...this.config.cosmicMultipliers,
            kineticIntensity,
            visualIntensityBase
          };
          this.eventBus.publish(
            "emergent/multipliersUpdated",
            this.currentMultipliers
          );
        }
        /**
         * Process emergent choreography tick within animation loop
         */
        processEmergentTick(deltaMs) {
          if (!this.signature) return;
          this._calculateAdaptiveCoefficients();
          if (this.signature && Date.now() - this.signature.evolutionaryTrajectory.lastUpdate > 6e4) {
            this._updateEvolutionaryTrajectory();
          }
          const visualPulse = this._calculateVisualPulse(deltaMs);
          if (visualPulse) {
            this.eventBus.publish("visual/pulse", visualPulse);
          }
          const emergentPayload = {
            timestamp: performance.now(),
            deltaMs
            // ...other emergent data to be calculated in later phases
          };
          this.eventBus.publish("emergent/frame", emergentPayload);
        }
        /**
         * Clean up emergent choreography resources
         */
        destroyEmergentChoreography() {
          if (this.signature) {
            temporalMemoryService.saveSignature(this.signature);
          }
          if (this.saveInterval) {
            clearInterval(this.saveInterval);
            this.saveInterval = null;
          }
          this.emergentEventSubscriptions.forEach((unsubscribe) => unsubscribe());
          this.emergentEventSubscriptions = [];
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Emergent choreography destroyed");
          }
        }
      };
      __name(_EnhancedMasterAnimationCoordinator, "EnhancedMasterAnimationCoordinator");
      _EnhancedMasterAnimationCoordinator.instance = null;
      EnhancedMasterAnimationCoordinator = _EnhancedMasterAnimationCoordinator;
    }
  });

  // src-js/core/performance/TimerConsolidationSystem.ts
  var _TimerConsolidationSystem, TimerConsolidationSystem;
  var init_TimerConsolidationSystem = __esm({
    "src-js/core/performance/TimerConsolidationSystem.ts"() {
      "use strict";
      _TimerConsolidationSystem = class _TimerConsolidationSystem {
        constructor(config = {}) {
          this._timerRegistry = /* @__PURE__ */ new Map();
          this._timerMasterInterval = null;
          this.config = {
            timerIntervalMs: config.timerIntervalMs || 50,
            maxTimerBudget: config.maxTimerBudget || 10,
            enableDebug: config.enableDebug || false,
            ...config
          };
          this._timerPerformanceMetrics = {
            totalExecutions: 0,
            totalTime: 0,
            maxExecutionTime: 0,
            averageExecutionTime: 0,
            skippedTimers: 0,
            timerCallbacks: /* @__PURE__ */ new Map()
          };
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Initialized");
          }
        }
        initialize() {
          if (this.config.enableDebug) {
            console.log(
              "\u23F1\uFE0F [TimerConsolidationSystem] Timer consolidation initialized"
            );
          }
        }
        registerConsolidatedTimer(timerId, callback, intervalMs, priority = "normal") {
          if (this._timerRegistry.has(timerId)) {
            console.warn(
              `[TimerConsolidationSystem] Timer ${timerId} already registered`
            );
            return;
          }
          const timerConfig = {
            callback,
            intervalMs,
            priority,
            lastExecution: 0,
            enabled: true,
            executionCount: 0,
            totalExecutionTime: 0,
            maxExecutionTime: 0,
            skippedExecutions: 0
          };
          this._timerRegistry.set(timerId, timerConfig);
          this._timerPerformanceMetrics.timerCallbacks.set(timerId, {
            calls: 0,
            totalTime: 0,
            maxTime: 0
          });
          if (this.config.enableDebug) {
            console.log(
              `\u23F1\uFE0F [TimerConsolidationSystem] Registered timer: ${timerId} (${intervalMs}ms, ${priority} priority)`
            );
          }
          if (this._timerRegistry.size === 1 && !this._timerMasterInterval) {
            this._startMasterTimer();
          }
        }
        unregisterConsolidatedTimer(timerId) {
          if (this._timerRegistry.has(timerId)) {
            this._timerRegistry.delete(timerId);
            this._timerPerformanceMetrics.timerCallbacks.delete(timerId);
            if (this.config.enableDebug) {
              console.log(
                `\u23F1\uFE0F [TimerConsolidationSystem] Unregistered timer: ${timerId}`
              );
            }
            if (this._timerRegistry.size === 0) {
              this._stopMasterTimer();
            }
          }
        }
        _startMasterTimer() {
          if (this._timerMasterInterval) return;
          this._timerMasterInterval = setInterval(() => {
            this._executeMasterTimerFrame();
          }, this.config.timerIntervalMs);
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Master timer started");
          }
        }
        _stopMasterTimer() {
          if (this._timerMasterInterval) {
            clearInterval(this._timerMasterInterval);
            this._timerMasterInterval = null;
          }
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Master timer stopped");
          }
        }
        _executeMasterTimerFrame() {
          const frameStartTime = performance.now();
          let remainingBudget = this.config.maxTimerBudget;
          const timersByPriority = Array.from(this._timerRegistry.entries()).sort(
            ([, a], [, b]) => {
              const priorityOrder = { critical: 0, normal: 1, background: 2 };
              return priorityOrder[a.priority] - priorityOrder[b.priority];
            }
          );
          for (const [timerId, config] of timersByPriority) {
            if (!config.enabled || remainingBudget <= 0 && config.priority === "background") {
              if (remainingBudget <= 0) config.skippedExecutions++;
              continue;
            }
            const timeSinceLastExecution = frameStartTime - config.lastExecution;
            if (timeSinceLastExecution < config.intervalMs) {
              continue;
            }
            const timerStartTime = performance.now();
            try {
              config.callback();
              const timerExecutionTime = performance.now() - timerStartTime;
              config.executionCount++;
              config.totalExecutionTime += timerExecutionTime;
              config.maxExecutionTime = Math.max(
                config.maxExecutionTime,
                timerExecutionTime
              );
              config.lastExecution = frameStartTime;
              const stats = this._timerPerformanceMetrics.timerCallbacks.get(timerId);
              if (stats) {
                stats.calls++;
                stats.totalTime += timerExecutionTime;
                stats.maxTime = Math.max(stats.maxTime, timerExecutionTime);
              }
              remainingBudget -= timerExecutionTime;
            } catch (error) {
              console.error(
                `[TimerConsolidationSystem] Error in timer ${timerId}:`,
                error
              );
              config.enabled = false;
            }
          }
          const totalFrameTime = performance.now() - frameStartTime;
          this._updateTimerPerformanceMetrics(totalFrameTime);
        }
        _updateTimerPerformanceMetrics(frameTime) {
          const metrics = this._timerPerformanceMetrics;
          metrics.totalExecutions++;
          metrics.totalTime += frameTime;
          metrics.maxExecutionTime = Math.max(metrics.maxExecutionTime, frameTime);
          metrics.averageExecutionTime = metrics.totalTime / metrics.totalExecutions;
          if (frameTime > this.config.maxTimerBudget) {
            metrics.skippedTimers++;
          }
        }
        destroy() {
          this._stopMasterTimer();
          this._timerRegistry.clear();
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Destroyed");
          }
        }
      };
      __name(_TimerConsolidationSystem, "TimerConsolidationSystem");
      TimerConsolidationSystem = _TimerConsolidationSystem;
    }
  });

  // src-js/core/performance/UnifiedPerformanceCoordinator.ts
  var _UnifiedPerformanceCoordinator, UnifiedPerformanceCoordinator;
  var init_UnifiedPerformanceCoordinator = __esm({
    "src-js/core/performance/UnifiedPerformanceCoordinator.ts"() {
      "use strict";
      init_EventBus();
      _UnifiedPerformanceCoordinator = class _UnifiedPerformanceCoordinator {
        constructor(config, performanceAnalyzer) {
          // Subsystem tracking
          this.subsystemMetrics = /* @__PURE__ */ new Map();
          // Optimization management
          this.optimizationStrategies = /* @__PURE__ */ new Map();
          this.adaptiveOptimizationEnabled = false;
          this.optimizationInterval = null;
          // Issue tracking
          this.activeIssues = /* @__PURE__ */ new Map();
          this.issueHistory = [];
          // Health monitoring
          this.lastHealthCheck = 0;
          this.healthCheckInterval = null;
          this.HEALTH_CHECK_INTERVAL = 5e3;
          // Initialized in initializeThermalMonitoring
          this.batteryState = null;
          // Initialized in constructor
          this.frameTimeHistory = [];
          this.memoryUsageHistory = [];
          this.lastOptimizationTime = 0;
          this.optimizationCooldown = 5e3;
          // 5 seconds
          // Performance thresholds
          this.PERFORMANCE_THRESHOLDS = {
            frameTime: {
              warning: 16.67,
              // 60fps
              critical: 33.33
              // 30fps
            },
            memoryUsage: {
              warning: 50 * 1024 * 1024,
              // 50MB
              critical: 100 * 1024 * 1024
              // 100MB
            },
            cpuUsage: {
              warning: 15,
              // 15%
              critical: 30
              // 30%
            },
            fps: {
              warning: 50,
              critical: 30
            }
          };
          // Performance modes configuration (from PerformanceOptimizationManager)
          this.PERFORMANCE_MODES = {
            battery: {
              name: "battery",
              qualityLevel: 0.4,
              animationQuality: 0.3,
              effectQuality: 0.2,
              blurQuality: 0.3,
              shadowQuality: 0.2,
              frameRate: 30,
              optimizationLevel: 3
            },
            balanced: {
              name: "balanced",
              qualityLevel: 0.8,
              animationQuality: 0.8,
              effectQuality: 0.7,
              blurQuality: 0.8,
              shadowQuality: 0.7,
              frameRate: 60,
              optimizationLevel: 1
            },
            performance: {
              name: "performance",
              qualityLevel: 1,
              animationQuality: 1,
              effectQuality: 1,
              blurQuality: 1,
              shadowQuality: 1,
              frameRate: 60,
              optimizationLevel: 0
            },
            auto: {
              name: "auto",
              qualityLevel: 0.8,
              // Will be dynamically adjusted
              animationQuality: 0.8,
              effectQuality: 0.8,
              blurQuality: 0.8,
              shadowQuality: 0.8,
              frameRate: 60,
              optimizationLevel: 1
            }
          };
          this.config = config;
          this.performanceAnalyzer = performanceAnalyzer;
          this.eventBus = GlobalEventBus;
          this.initializeDeviceCapabilities();
          this.initializeThermalMonitoring();
          this.initializeBatteryMonitoring();
          this.currentPerformanceMode = this.PERFORMANCE_MODES.auto;
          this.initializeDefaultStrategies();
          this.startHealthMonitoring();
          this.subscribeToEvents();
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Initialized with enhanced device capabilities, thermal monitoring, and battery optimization");
          }
        }
        /**
         * Get or create singleton instance
         */
        static getInstance(config, performanceAnalyzer) {
          if (!_UnifiedPerformanceCoordinator.instance) {
            if (!config || !performanceAnalyzer) {
              throw new Error("UnifiedPerformanceCoordinator requires config and performanceAnalyzer for first initialization");
            }
            _UnifiedPerformanceCoordinator.instance = new _UnifiedPerformanceCoordinator(config, performanceAnalyzer);
          }
          return _UnifiedPerformanceCoordinator.instance;
        }
        /**
         * Track performance metrics for a subsystem
         */
        trackSubsystem(name, metrics) {
          const currentTime = performance.now();
          const existingMetrics = this.subsystemMetrics.get(name) || {
            name,
            frameTime: 0,
            memoryUsage: 0,
            cpuUsage: 0,
            fps: 60,
            lastUpdate: currentTime,
            status: "healthy",
            issues: []
          };
          const updatedMetrics = {
            ...existingMetrics,
            ...metrics,
            lastUpdate: currentTime
          };
          updatedMetrics.status = this.calculateHealthStatus(updatedMetrics);
          this.updateSubsystemIssues(updatedMetrics);
          this.subsystemMetrics.set(name, updatedMetrics);
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.recordMetric(`subsystem_${name}_frame_time`, updatedMetrics.frameTime);
            this.performanceAnalyzer.recordMetric(`subsystem_${name}_memory`, updatedMetrics.memoryUsage);
            this.performanceAnalyzer.recordMetric(`subsystem_${name}_fps`, updatedMetrics.fps);
          }
          if (this.adaptiveOptimizationEnabled && updatedMetrics.status !== "healthy") {
            this.checkAndTriggerOptimization(updatedMetrics);
          }
          if (this.config.enableDebug && updatedMetrics.status !== "healthy") {
            console.warn(`[UnifiedPerformanceCoordinator] Subsystem ${name} status: ${updatedMetrics.status}`, updatedMetrics);
          }
        }
        /**
         * Get comprehensive system health report
         */
        getSystemHealth() {
          const currentTime = performance.now();
          const subsystems = new Map(this.subsystemMetrics);
          let healthyCount = 0;
          let warningCount = 0;
          let criticalCount = 0;
          for (const metrics of subsystems.values()) {
            switch (metrics.status) {
              case "healthy":
                healthyCount++;
                break;
              case "warning":
                warningCount++;
                break;
              case "critical":
                criticalCount++;
                break;
            }
          }
          const totalSubsystems = subsystems.size;
          let overall = "healthy";
          if (criticalCount > 0) {
            overall = "critical";
          } else if (warningCount > 0) {
            overall = "warning";
          }
          const performanceScore = this.calculatePerformanceScore(subsystems);
          const recommendations = this.generateRecommendations(subsystems);
          const healthReport = {
            overall,
            totalSubsystems,
            healthySubsystems: healthyCount,
            warningSubsystems: warningCount,
            criticalSubsystems: criticalCount,
            subsystems,
            recommendations,
            performanceScore,
            lastUpdate: currentTime
          };
          this.lastHealthCheck = currentTime;
          this.eventBus.publish("performance:health-report", healthReport);
          return healthReport;
        }
        /**
         * Enable adaptive optimization
         */
        enableAdaptiveOptimization() {
          if (this.adaptiveOptimizationEnabled) return;
          this.adaptiveOptimizationEnabled = true;
          this.optimizationInterval = setInterval(() => {
            this.performOptimizationCheck();
          }, 2e3);
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Adaptive optimization enabled");
          }
          this.eventBus.publish("performance:optimization-enabled", {
            timestamp: Date.now(),
            strategies: Array.from(this.optimizationStrategies.keys())
          });
        }
        /**
         * Disable adaptive optimization
         */
        disableAdaptiveOptimization() {
          if (!this.adaptiveOptimizationEnabled) return;
          this.adaptiveOptimizationEnabled = false;
          if (this.optimizationInterval) {
            clearInterval(this.optimizationInterval);
            this.optimizationInterval = null;
          }
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Adaptive optimization disabled");
          }
          this.eventBus.publish("performance:optimization-disabled", {
            timestamp: Date.now()
          });
        }
        /**
         * Register an optimization strategy
         */
        registerOptimizationStrategy(strategy) {
          this.optimizationStrategies.set(strategy.name, strategy);
          if (this.config.enableDebug) {
            console.log(`[UnifiedPerformanceCoordinator] Registered optimization strategy: ${strategy.name}`);
          }
        }
        /**
         * Trigger optimization for a specific issue
         */
        triggerOptimization(issue) {
          this.activeIssues.set(`${issue.subsystem}:${issue.type}`, issue);
          this.issueHistory.push(issue);
          if (this.issueHistory.length > 100) {
            this.issueHistory.shift();
          }
          const applicableStrategies = Array.from(this.optimizationStrategies.values()).filter((strategy) => strategy.subsystem === issue.subsystem || strategy.subsystem === "*").sort((a, b) => b.priority - a.priority);
          for (const strategy of applicableStrategies) {
            const subsystemMetrics = this.subsystemMetrics.get(issue.subsystem);
            if (subsystemMetrics && strategy.condition(subsystemMetrics)) {
              try {
                strategy.action(subsystemMetrics);
                if (this.config.enableDebug) {
                  console.log(`[UnifiedPerformanceCoordinator] Applied optimization strategy: ${strategy.name} for ${issue.subsystem}`);
                }
                this.eventBus.publish("performance:optimization-applied", {
                  issue,
                  strategy: strategy.name,
                  timestamp: Date.now()
                });
                break;
              } catch (error) {
                console.error(`[UnifiedPerformanceCoordinator] Error applying optimization strategy ${strategy.name}:`, error);
              }
            }
          }
        }
        /**
         * Get current performance metrics for debugging
         */
        getMetrics() {
          return {
            subsystems: new Map(this.subsystemMetrics),
            issues: new Map(this.activeIssues),
            strategies: new Map(this.optimizationStrategies),
            adaptiveOptimizationEnabled: this.adaptiveOptimizationEnabled
          };
        }
        /**
         * Destroy the coordinator and clean up resources
         */
        destroy() {
          this.disableAdaptiveOptimization();
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          this.subsystemMetrics.clear();
          this.optimizationStrategies.clear();
          this.activeIssues.clear();
          this.issueHistory = [];
          if (_UnifiedPerformanceCoordinator.instance === this) {
            _UnifiedPerformanceCoordinator.instance = null;
          }
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Destroyed");
          }
        }
        // =========================================================================
        // PRIVATE METHODS
        // =========================================================================
        /**
         * Initialize default optimization strategies
         */
        initializeDefaultStrategies() {
          this.registerOptimizationStrategy({
            name: "memory-cleanup",
            type: "memory_cleanup",
            priority: 100,
            subsystem: "*",
            description: "Trigger garbage collection and memory cleanup",
            condition: /* @__PURE__ */ __name((metrics) => metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
              this.eventBus.publish("performance:memory-cleanup", {
                subsystem: metrics.name,
                memoryUsage: metrics.memoryUsage,
                timestamp: Date.now()
              });
            }, "action")
          });
          this.registerOptimizationStrategy({
            name: "fps-optimization",
            type: "reduce_quality",
            priority: 80,
            subsystem: "*",
            description: "Reduce quality settings to improve FPS",
            condition: /* @__PURE__ */ __name((metrics) => metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
              this.eventBus.publish("performance:reduce-quality", {
                subsystem: metrics.name,
                fps: metrics.fps,
                timestamp: Date.now()
              });
            }, "action")
          });
          this.registerOptimizationStrategy({
            name: "cpu-throttling",
            type: "throttle_updates",
            priority: 70,
            subsystem: "*",
            description: "Throttle update frequency to reduce CPU usage",
            condition: /* @__PURE__ */ __name((metrics) => metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
              this.eventBus.publish("performance:throttle-updates", {
                subsystem: metrics.name,
                cpuUsage: metrics.cpuUsage,
                timestamp: Date.now()
              });
            }, "action")
          });
        }
        /**
         * Calculate health status for subsystem
         */
        calculateHealthStatus(metrics) {
          const issues = [];
          if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.critical) {
            issues.push("critical-frame-time");
          } else if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.warning) {
            issues.push("warning-frame-time");
          }
          if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.critical) {
            issues.push("critical-memory");
          } else if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning) {
            issues.push("warning-memory");
          }
          if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.critical) {
            issues.push("critical-cpu");
          } else if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning) {
            issues.push("warning-cpu");
          }
          if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.critical) {
            issues.push("critical-fps");
          } else if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning) {
            issues.push("warning-fps");
          }
          metrics.issues = issues;
          if (issues.some((issue) => issue.startsWith("critical"))) {
            return "critical";
          } else if (issues.some((issue) => issue.startsWith("warning"))) {
            return "warning";
          } else {
            return "healthy";
          }
        }
        /**
         * Update subsystem issues based on thresholds
         */
        updateSubsystemIssues(metrics) {
          const issueKey = `${metrics.name}:performance`;
          if (metrics.status === "healthy") {
            if (this.activeIssues.has(issueKey)) {
              const issue = this.activeIssues.get(issueKey);
              issue.resolved = true;
              this.activeIssues.delete(issueKey);
            }
          } else {
            const issue = {
              type: "render",
              severity: metrics.status === "critical" ? "critical" : "medium",
              subsystem: metrics.name,
              message: `Performance degradation detected: ${metrics.issues.join(", ")}`,
              timestamp: Date.now(),
              resolved: false
            };
            this.activeIssues.set(issueKey, issue);
          }
        }
        /**
         * Check and trigger optimization if needed
         */
        checkAndTriggerOptimization(metrics) {
          const issueKey = `${metrics.name}:performance`;
          const issue = this.activeIssues.get(issueKey);
          if (issue && !issue.resolved) {
            this.triggerOptimization(issue);
          }
        }
        /**
         * Perform periodic optimization check
         */
        performOptimizationCheck() {
          const currentTime = performance.now();
          for (const [name, metrics] of this.subsystemMetrics) {
            if (currentTime - metrics.lastUpdate > 1e4) {
              continue;
            }
            if (metrics.status !== "healthy") {
              this.checkAndTriggerOptimization(metrics);
            }
          }
        }
        /**
         * Calculate overall performance score
         */
        calculatePerformanceScore(subsystems) {
          if (subsystems.size === 0) return 100;
          let totalScore = 0;
          for (const metrics of subsystems.values()) {
            let subsystemScore = 100;
            if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.warning) {
              subsystemScore -= 20;
            }
            if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.critical) {
              subsystemScore -= 30;
            }
            if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning) {
              subsystemScore -= 15;
            }
            if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.critical) {
              subsystemScore -= 25;
            }
            if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning) {
              subsystemScore -= 10;
            }
            if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.critical) {
              subsystemScore -= 20;
            }
            if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning) {
              subsystemScore -= 15;
            }
            if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.critical) {
              subsystemScore -= 25;
            }
            totalScore += Math.max(0, subsystemScore);
          }
          return Math.round(totalScore / subsystems.size);
        }
        /**
         * Generate recommendations based on system health
         */
        generateRecommendations(subsystems) {
          const recommendations = [];
          const allIssues = Array.from(subsystems.values()).flatMap((metrics) => metrics.issues);
          const issueCounts = /* @__PURE__ */ new Map();
          for (const issue of allIssues) {
            issueCounts.set(issue, (issueCounts.get(issue) || 0) + 1);
          }
          for (const [issue, count] of issueCounts) {
            if (count >= 2) {
              switch (issue) {
                case "critical-frame-time":
                case "warning-frame-time":
                  recommendations.push("Consider reducing animation quality or frequency");
                  break;
                case "critical-memory":
                case "warning-memory":
                  recommendations.push("Memory cleanup needed - consider reducing cache sizes");
                  break;
                case "critical-cpu":
                case "warning-cpu":
                  recommendations.push("High CPU usage detected - consider throttling updates");
                  break;
                case "critical-fps":
                case "warning-fps":
                  recommendations.push("Low FPS detected - consider disabling non-essential effects");
                  break;
              }
            }
          }
          if (recommendations.length === 0) {
            recommendations.push("System performance is optimal");
          }
          return recommendations;
        }
        /**
         * Start health monitoring
         */
        startHealthMonitoring() {
          this.healthCheckInterval = setInterval(() => {
            this.getSystemHealth();
          }, this.HEALTH_CHECK_INTERVAL);
        }
        /**
         * Subscribe to performance events
         */
        subscribeToEvents() {
          this.eventBus.subscribe("performance:memory-warning", (payload) => {
            if (payload.subsystem) {
              this.triggerOptimization({
                type: "memory",
                severity: "high",
                subsystem: payload.subsystem,
                message: `Memory usage warning: ${payload.usage}MB`,
                timestamp: Date.now(),
                resolved: false
              });
            }
          });
          this.eventBus.subscribe("performance:fps-drop", (payload) => {
            if (payload.subsystem) {
              this.triggerOptimization({
                type: "fps",
                severity: "medium",
                subsystem: payload.subsystem,
                message: `FPS drop detected: ${payload.fps}`,
                timestamp: Date.now(),
                resolved: false
              });
            }
          });
        }
        // ===============================================================================
        // ENHANCED CAPABILITIES FROM PERFORMANCEOPTIMIZATIONMANAGER CONSOLIDATION
        // ===============================================================================
        /**
         * Initialize device capabilities detection
         */
        initializeDeviceCapabilities() {
          const nav = navigator;
          const memory = performance.memory;
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
          let maxTextureSize = 2048;
          if (gl) {
            maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE) || 2048;
          }
          const estimatedMemory = memory ? Math.round(memory.jsHeapSizeLimit / (1024 * 1024 * 1024)) : 4;
          let performanceTier = "medium";
          if (estimatedMemory >= 8 && nav.hardwareConcurrency >= 8 && maxTextureSize >= 4096) {
            performanceTier = "premium";
          } else if (estimatedMemory >= 4 && nav.hardwareConcurrency >= 4) {
            performanceTier = "high";
          } else if (estimatedMemory >= 2 && nav.hardwareConcurrency >= 2) {
            performanceTier = "medium";
          } else {
            performanceTier = "low";
          }
          this.deviceCapabilities = {
            performanceTier,
            memoryGB: estimatedMemory,
            cpuCores: nav.hardwareConcurrency || 4,
            gpuAcceleration: !!gl,
            isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(nav.userAgent),
            supportsWebGL: !!gl,
            supportsBackdropFilter: CSS.supports("backdrop-filter", "blur(10px)"),
            maxTextureSize,
            devicePixelRatio: window.devicePixelRatio || 1
          };
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Device capabilities detected:", this.deviceCapabilities);
          }
        }
        /**
         * Initialize thermal state monitoring
         */
        initializeThermalMonitoring() {
          this.thermalState = {
            temperature: "normal",
            throttleLevel: 0,
            cpuUsage: 0,
            gpuUsage: 0,
            memoryUsage: 0
          };
          setInterval(() => {
            this.updateThermalState();
          }, 1e4);
        }
        /**
         * Initialize battery monitoring if available
         */
        async initializeBatteryMonitoring() {
          try {
            const nav = navigator;
            if ("getBattery" in nav) {
              const battery = await nav.getBattery();
              this.batteryState = {
                level: battery.level,
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
              };
              battery.addEventListener("levelchange", () => {
                if (this.batteryState) {
                  this.batteryState.level = battery.level;
                  this.adjustPerformanceModeForBattery();
                }
              });
              battery.addEventListener("chargingchange", () => {
                if (this.batteryState) {
                  this.batteryState.charging = battery.charging;
                  this.adjustPerformanceModeForBattery();
                }
              });
              if (this.config.enableDebug) {
                console.log("[UnifiedPerformanceCoordinator] Battery monitoring initialized");
              }
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.log("[UnifiedPerformanceCoordinator] Battery API not available");
            }
          }
        }
        /**
         * Update thermal state based on performance metrics
         */
        updateThermalState() {
          const currentFPS = this.performanceAnalyzer.getMedianFPS() || 60;
          const memory = performance.memory;
          const memoryUsage = memory ? memory.usedJSHeapSize / memory.jsHeapSizeLimit : 0;
          let temperature = "normal";
          let throttleLevel = 0;
          if (currentFPS < 30 || memoryUsage > 0.9) {
            temperature = "critical";
            throttleLevel = 0.8;
          } else if (currentFPS < 45 || memoryUsage > 0.7) {
            temperature = "hot";
            throttleLevel = 0.4;
          } else if (currentFPS < 55 || memoryUsage > 0.5) {
            temperature = "warm";
            throttleLevel = 0.2;
          }
          this.thermalState = {
            temperature,
            throttleLevel,
            cpuUsage: Math.min(1 - currentFPS / 60, 1),
            gpuUsage: 0,
            // TODO: Implement GPU usage detection
            memoryUsage
          };
          if (temperature === "critical" && this.currentPerformanceMode.name !== "battery") {
            this.setPerformanceMode("battery");
          } else if (temperature === "normal" && this.currentPerformanceMode.name === "battery") {
            this.setPerformanceMode("auto");
          }
        }
        /**
         * Adjust performance mode based on battery state
         */
        adjustPerformanceModeForBattery() {
          if (!this.batteryState) return;
          if (!this.batteryState.charging && this.batteryState.level < 0.2) {
            this.setPerformanceMode("battery");
          } else if (this.batteryState.charging && this.currentPerformanceMode.name === "battery") {
            this.setPerformanceMode("auto");
          }
        }
        /**
         * Set performance mode
         */
        setPerformanceMode(modeName) {
          const mode = this.PERFORMANCE_MODES[modeName];
          if (!mode) return;
          this.currentPerformanceMode = mode;
          this.eventBus.emit("performance:mode-changed", {
            mode: modeName,
            qualityLevel: mode.qualityLevel,
            frameRate: mode.frameRate
          });
          if (this.config.enableDebug) {
            console.log(`[UnifiedPerformanceCoordinator] Performance mode changed to: ${modeName}`);
          }
        }
        /**
         * Get current device capabilities
         */
        getDeviceCapabilities() {
          return { ...this.deviceCapabilities };
        }
        /**
         * Get current thermal state
         */
        getThermalState() {
          return { ...this.thermalState };
        }
        /**
         * Get current battery state
         */
        getBatteryState() {
          return this.batteryState ? { ...this.batteryState } : null;
        }
        /**
         * Get current performance mode
         */
        getCurrentPerformanceMode() {
          return { ...this.currentPerformanceMode };
        }
      };
      __name(_UnifiedPerformanceCoordinator, "UnifiedPerformanceCoordinator");
      _UnifiedPerformanceCoordinator.instance = null;
      UnifiedPerformanceCoordinator = _UnifiedPerformanceCoordinator;
    }
  });

  // src-js/core/performance/PerformanceAwareLerpCoordinator.ts
  var _PerformanceAwareLerpCoordinator, PerformanceAwareLerpCoordinator;
  var init_PerformanceAwareLerpCoordinator = __esm({
    "src-js/core/performance/PerformanceAwareLerpCoordinator.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_globalConfig();
      init_EventBus();
      _PerformanceAwareLerpCoordinator = class _PerformanceAwareLerpCoordinator {
        // 3 seconds
        constructor() {
          this.initialized = false;
          // Performance thresholds and targets
          this.performanceThresholds = {
            excellent: { minFPS: 58, maxFrameTime: 17, maxCPU: 0.15 },
            good: { minFPS: 50, maxFrameTime: 20, maxCPU: 0.25 },
            degraded: { minFPS: 40, maxFrameTime: 25, maxCPU: 0.35 },
            critical: { minFPS: 30, maxFrameTime: 33, maxCPU: 0.5 }
          };
          // Quality tier configurations
          this.qualityTierConfigs = /* @__PURE__ */ new Map([
            ["minimal", {
              halfLife: 0.2,
              performanceMultiplier: 0.3,
              complexityReduction: 0.8,
              updateFrequency: 0.5,
              enableBeatPhase: false,
              enableEnergyModulation: false,
              enableTemperatureMapping: false,
              useSimplifiedCalculations: true,
              skipNonCriticalUpdates: true,
              batchUpdates: true
            }],
            ["low", {
              halfLife: 0.15,
              performanceMultiplier: 0.5,
              complexityReduction: 0.6,
              updateFrequency: 0.7,
              enableBeatPhase: false,
              enableEnergyModulation: true,
              enableTemperatureMapping: false,
              useSimplifiedCalculations: true,
              skipNonCriticalUpdates: true,
              batchUpdates: true
            }],
            ["medium", {
              halfLife: 0.1,
              performanceMultiplier: 0.8,
              complexityReduction: 0.4,
              updateFrequency: 0.8,
              enableBeatPhase: true,
              enableEnergyModulation: true,
              enableTemperatureMapping: true,
              useSimplifiedCalculations: false,
              skipNonCriticalUpdates: false,
              batchUpdates: false
            }],
            ["high", {
              halfLife: 0.08,
              performanceMultiplier: 1,
              complexityReduction: 0.2,
              updateFrequency: 0.9,
              enableBeatPhase: true,
              enableEnergyModulation: true,
              enableTemperatureMapping: true,
              useSimplifiedCalculations: false,
              skipNonCriticalUpdates: false,
              batchUpdates: false
            }],
            ["ultra", {
              halfLife: 0.05,
              performanceMultiplier: 1.2,
              complexityReduction: 0,
              updateFrequency: 1,
              enableBeatPhase: true,
              enableEnergyModulation: true,
              enableTemperatureMapping: true,
              useSimplifiedCalculations: false,
              skipNonCriticalUpdates: false,
              batchUpdates: false
            }]
          ]);
          // Performance adaptation state
          this.lastPerformanceCheck = 0;
          this.performanceCheckInterval = 1e3;
          // 1 second
          this.lastQualityAdjustment = 0;
          this.qualityAdjustmentCooldown = 3e3;
          this.eventBus = GlobalEventBus;
          this.currentPerformanceContext = this.createDefaultPerformanceContext();
          this.currentLerpParams = this.qualityTierConfigs.get("medium");
          this.performanceMetrics = this.createDefaultMetrics();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("PerformanceAwareLerpCoordinator", "Performance-aware LERP coordinator initialized");
          }
        }
        // ========================================================================
        // IMANAGEDYSTEM INTERFACE IMPLEMENTATION
        // ========================================================================
        async initialize() {
          if (this.initialized) return;
          try {
            this.subscribeToPerformanceEvents();
            this.startPerformanceMonitoring();
            this.initialized = true;
            this.eventBus.emit("performance:lerp-coordinator-initialized", {
              defaultQuality: "medium",
              availableTiers: Array.from(this.qualityTierConfigs.keys())
            });
            if (YEAR3000_CONFIG.enableDebug) {
              Y3K?.debug?.log("PerformanceAwareLerpCoordinator", "Performance-aware LERP coordination fully initialized");
            }
          } catch (error) {
            Y3K?.debug?.error("PerformanceAwareLerpCoordinator", "Initialization failed:", error);
            throw error;
          }
        }
        updateAnimation(deltaTime) {
          this.updatePerformanceMetrics(deltaTime);
          if (this.shouldAdaptPerformance()) {
            this.adaptLerpPerformance();
          }
        }
        async healthCheck() {
          const metrics = this.performanceMetrics;
          const frameTimeImpact = metrics.frameTimeImpact;
          const calculationTime = metrics.averageCalculationTime;
          const isHealthy = frameTimeImpact < 1 && // < 1ms frame impact
          calculationTime < 0.1 && // < 0.1ms per calculation
          metrics.musicalAccuracy > 0.7;
          return {
            system: "PerformanceAwareLerpCoordinator",
            healthy: isHealthy,
            ok: isHealthy,
            details: isHealthy ? "Performance-aware LERP coordination operating efficiently" : `Performance issues: impact=${frameTimeImpact.toFixed(2)}ms, calc=${calculationTime.toFixed(3)}ms`,
            metrics: {
              frameTimeImpact,
              averageCalculationTime: calculationTime,
              musicalAccuracy: metrics.musicalAccuracy,
              qualityLevel: this.currentPerformanceContext.qualityLevel,
              thermalState: this.currentPerformanceContext.thermalState,
              calculationsPerSecond: metrics.calculationsPerSecond
            }
          };
        }
        destroy() {
          this.stopPerformanceMonitoring();
          this.unsubscribeFromPerformanceEvents();
          this.initialized = false;
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("PerformanceAwareLerpCoordinator", "Performance-aware LERP coordinator destroyed");
          }
        }
        // ========================================================================
        // PUBLIC API - PERFORMANCE-AWARE LERP FUNCTIONS
        // ========================================================================
        /**
         * Calculate performance-aware musical LERP with full consciousness integration
         */
        calculatePerformanceAwareMusicalLerp(current, target, deltaTime, musicalContext, animationType = "flow", baseHalfLife) {
          const startTime = performance.now();
          const lerpParams = this.getCurrentLerpParams();
          const effectiveHalfLife = this.calculateEffectiveHalfLife(
            musicalContext,
            animationType,
            baseHalfLife,
            lerpParams
          );
          let result;
          if (lerpParams.useSimplifiedCalculations || !musicalContext) {
            result = this.calculateSimplifiedLerp(current, target, deltaTime, effectiveHalfLife);
          } else {
            result = this.calculateFullMusicalLerp(
              current,
              target,
              deltaTime,
              musicalContext,
              animationType,
              effectiveHalfLife,
              lerpParams
            );
          }
          const calculationTime = performance.now() - startTime;
          this.updateCalculationMetrics(calculationTime);
          return result;
        }
        /**
         * Get current performance context for external systems
         */
        getCurrentPerformanceContext() {
          return { ...this.currentPerformanceContext };
        }
        /**
         * Get current LERP parameters for external systems
         */
        getCurrentLerpParams() {
          return { ...this.currentLerpParams };
        }
        /**
         * Get performance metrics for monitoring
         */
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Force performance state update (for external performance systems)
         */
        updatePerformanceState(performanceState) {
          this.currentPerformanceContext = {
            ...this.currentPerformanceContext,
            ...performanceState
          };
          this.adaptLerpParameters();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("PerformanceAwareLerpCoordinator", "Performance state updated", {
              qualityLevel: this.currentPerformanceContext.qualityLevel,
              currentFPS: this.currentPerformanceContext.currentFPS,
              thermalState: this.currentPerformanceContext.thermalState
            });
          }
        }
        // ========================================================================
        // PRIVATE IMPLEMENTATION - PERFORMANCE ADAPTATION
        // ========================================================================
        createDefaultPerformanceContext() {
          return {
            currentFPS: 60,
            targetFPS: 60,
            frameTimeMs: 16.67,
            frameBudgetMs: 16.67,
            qualityLevel: "medium",
            qualityScore: 0.5,
            deviceTier: "medium",
            thermalState: "nominal",
            powerLevel: "balanced",
            memoryPressure: "low",
            cpuUtilization: 0.2,
            memoryUtilization: 0.3,
            gpuUtilization: 0.2
          };
        }
        createDefaultMetrics() {
          return {
            averageCalculationTime: 0,
            calculationsPerSecond: 0,
            frameTimeImpact: 0,
            cpuImpact: 0,
            memoryImpact: 0,
            musicalAccuracy: 1,
            smoothnessQuality: 1,
            responsiveness: 1,
            qualityReductions: 0,
            performanceRecoveries: 0
          };
        }
        subscribeToPerformanceEvents() {
          this.eventBus.subscribe("performance:quality-changed", (data) => {
            this.handleQualityChange(data);
          });
          this.eventBus.subscribe("performance:thermal-warning", (data) => {
            this.handleThermalWarning(data);
          });
          this.eventBus.subscribe("quality:level-changed", (data) => {
            this.handleQualityLevelChange(data);
          });
        }
        unsubscribeFromPerformanceEvents() {
        }
        startPerformanceMonitoring() {
        }
        stopPerformanceMonitoring() {
        }
        shouldAdaptPerformance() {
          const now = performance.now();
          if (now - this.lastPerformanceCheck < this.performanceCheckInterval) {
            return false;
          }
          this.lastPerformanceCheck = now;
          const context = this.currentPerformanceContext;
          const performanceIssue = context.currentFPS < context.targetFPS * 0.9 || context.frameTimeMs > context.frameBudgetMs * 1.2 || context.thermalState !== "nominal" || context.memoryPressure === "high";
          const canRecoverQuality = context.currentFPS > context.targetFPS * 1.1 && context.frameTimeMs < context.frameBudgetMs * 0.8 && context.thermalState === "nominal" && now - this.lastQualityAdjustment > this.qualityAdjustmentCooldown;
          return performanceIssue || canRecoverQuality;
        }
        adaptLerpPerformance() {
          const context = this.currentPerformanceContext;
          const shouldReduceQuality = context.currentFPS < context.targetFPS * 0.8 || context.frameTimeMs > context.frameBudgetMs * 1.3 || context.thermalState === "hot" || context.thermalState === "critical" || context.memoryPressure === "high";
          const canIncreaseQuality = context.currentFPS > context.targetFPS * 1.1 && context.frameTimeMs < context.frameBudgetMs * 0.7 && context.thermalState === "nominal" && context.memoryPressure === "low";
          if (shouldReduceQuality) {
            this.reducePerformanceQuality();
          } else if (canIncreaseQuality) {
            this.increasePerformanceQuality();
          }
        }
        reducePerformanceQuality() {
          const currentParams = this.currentLerpParams;
          currentParams.performanceMultiplier = Math.min(2, currentParams.performanceMultiplier * 1.2);
          currentParams.complexityReduction = Math.min(0.9, currentParams.complexityReduction + 0.1);
          currentParams.updateFrequency = Math.max(0.3, currentParams.updateFrequency * 0.9);
          if (currentParams.enableTemperatureMapping) {
            currentParams.enableTemperatureMapping = false;
          } else if (currentParams.enableEnergyModulation) {
            currentParams.enableEnergyModulation = false;
          } else if (currentParams.enableBeatPhase) {
            currentParams.enableBeatPhase = false;
          }
          currentParams.useSimplifiedCalculations = true;
          currentParams.skipNonCriticalUpdates = true;
          currentParams.batchUpdates = true;
          this.performanceMetrics.qualityReductions++;
          this.lastQualityAdjustment = performance.now();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.warn("PerformanceAwareLerpCoordinator", "Reduced LERP quality for performance", {
              performanceMultiplier: currentParams.performanceMultiplier,
              complexityReduction: currentParams.complexityReduction
            });
          }
        }
        increasePerformanceQuality() {
          const currentParams = this.currentLerpParams;
          currentParams.performanceMultiplier = Math.max(0.5, currentParams.performanceMultiplier * 0.9);
          currentParams.complexityReduction = Math.max(0, currentParams.complexityReduction - 0.1);
          currentParams.updateFrequency = Math.min(1, currentParams.updateFrequency * 1.1);
          if (!currentParams.enableBeatPhase && currentParams.complexityReduction < 0.3) {
            currentParams.enableBeatPhase = true;
          } else if (!currentParams.enableEnergyModulation && currentParams.complexityReduction < 0.2) {
            currentParams.enableEnergyModulation = true;
          } else if (!currentParams.enableTemperatureMapping && currentParams.complexityReduction < 0.1) {
            currentParams.enableTemperatureMapping = true;
          }
          this.performanceMetrics.performanceRecoveries++;
          this.lastQualityAdjustment = performance.now();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("PerformanceAwareLerpCoordinator", "Increased LERP quality", {
              performanceMultiplier: currentParams.performanceMultiplier,
              complexityReduction: currentParams.complexityReduction
            });
          }
        }
        adaptLerpParameters() {
          const context = this.currentPerformanceContext;
          const qualityConfig = this.qualityTierConfigs.get(context.qualityLevel);
          if (qualityConfig) {
            this.currentLerpParams = { ...qualityConfig };
            if (context.thermalState === "warm") {
              this.currentLerpParams.performanceMultiplier *= 1.2;
            } else if (context.thermalState === "hot") {
              this.currentLerpParams.performanceMultiplier *= 1.5;
              this.currentLerpParams.enableTemperatureMapping = false;
            } else if (context.thermalState === "critical") {
              this.currentLerpParams.performanceMultiplier *= 2;
              this.currentLerpParams.enableTemperatureMapping = false;
              this.currentLerpParams.enableEnergyModulation = false;
              this.currentLerpParams.useSimplifiedCalculations = true;
            }
            if (context.powerLevel === "battery-saver") {
              this.currentLerpParams.performanceMultiplier *= 1.5;
              this.currentLerpParams.enableTemperatureMapping = false;
              this.currentLerpParams.updateFrequency *= 0.7;
            }
            if (context.memoryPressure === "high") {
              this.currentLerpParams.batchUpdates = true;
              this.currentLerpParams.skipNonCriticalUpdates = true;
              this.currentLerpParams.updateFrequency *= 0.8;
            }
          }
        }
        // ========================================================================
        // PRIVATE IMPLEMENTATION - LERP CALCULATIONS
        // ========================================================================
        calculateEffectiveHalfLife(musicalContext, animationType, baseHalfLife, lerpParams) {
          let halfLife = baseHalfLife || lerpParams.halfLife;
          halfLife *= lerpParams.performanceMultiplier;
          if (musicalContext && lerpParams.enableEnergyModulation) {
            const tempoFactor = Math.max(0.5, Math.min(2, musicalContext.tempo / 120));
            halfLife /= tempoFactor;
            if (lerpParams.enableEnergyModulation) {
              const energyFactor = 0.7 + musicalContext.energy * 0.6;
              halfLife /= energyFactor;
            }
          }
          return Math.max(0.01, Math.min(1, halfLife));
        }
        calculateSimplifiedLerp(current, target, deltaTime, halfLife) {
          const factor = Math.pow(2, -(deltaTime / 1e3) / halfLife);
          return current + (target - current) * (1 - factor);
        }
        calculateFullMusicalLerp(current, target, deltaTime, musicalContext, animationType, effectiveHalfLife, lerpParams) {
          let result = this.calculateSimplifiedLerp(current, target, deltaTime, effectiveHalfLife);
          if (lerpParams.enableBeatPhase && musicalContext.beatPhase) {
            const beatPhaseModifier = this.calculateBeatPhaseModifier(
              musicalContext.beatPhase,
              musicalContext.timeSinceLastBeat,
              musicalContext.beatInterval,
              animationType
            );
            const phaseInfluence = lerpParams.complexityReduction > 0.5 ? 0.1 : 0.2;
            result += (target - current) * beatPhaseModifier * phaseInfluence;
          }
          if (lerpParams.enableEnergyModulation && musicalContext.danceability > 0) {
            const danceabilityFactor = 0.9 + musicalContext.danceability * 0.2;
            result = current + (result - current) * danceabilityFactor;
          }
          return result;
        }
        calculateBeatPhaseModifier(beatPhase, timeSinceLastBeat, beatInterval, animationType) {
          switch (beatPhase) {
            case "attack":
              return animationType === "pulse" ? 0.3 : 0.1;
            case "sustain":
              return animationType === "flow" ? 0.1 : 0.05;
            case "decay":
              return animationType === "pulse" ? -0.1 : -0.05;
            case "rest":
              return 0;
            default:
              return 0;
          }
        }
        // ========================================================================
        // PRIVATE IMPLEMENTATION - METRICS AND MONITORING
        // ========================================================================
        updatePerformanceMetrics(deltaTime) {
          const currentImpact = this.performanceMetrics.frameTimeImpact;
          this.performanceMetrics.frameTimeImpact = currentImpact * 0.9 + 0 * 0.1;
          const calculationsThisFrame = 1;
          this.performanceMetrics.calculationsPerSecond = this.performanceMetrics.calculationsPerSecond * 0.95 + calculationsThisFrame / (deltaTime / 1e3) * 0.05;
        }
        updateCalculationMetrics(calculationTime) {
          const currentAvg = this.performanceMetrics.averageCalculationTime;
          this.performanceMetrics.averageCalculationTime = currentAvg * 0.9 + calculationTime * 0.1;
          const currentImpact = this.performanceMetrics.frameTimeImpact;
          this.performanceMetrics.frameTimeImpact = currentImpact * 0.9 + calculationTime * 0.1;
          const params = this.currentLerpParams;
          let accuracy = 1;
          if (!params.enableBeatPhase) accuracy -= 0.2;
          if (!params.enableEnergyModulation) accuracy -= 0.15;
          if (!params.enableTemperatureMapping) accuracy -= 0.1;
          if (params.useSimplifiedCalculations) accuracy -= 0.1;
          this.performanceMetrics.musicalAccuracy = Math.max(0.3, accuracy);
          this.performanceMetrics.smoothnessQuality = Math.max(
            0.5,
            1 - (params.performanceMultiplier - 1) * 0.3
          );
          this.performanceMetrics.responsiveness = params.updateFrequency;
        }
        // ========================================================================
        // EVENT HANDLERS
        // ========================================================================
        handleQualityChange(data) {
          const { newLevel } = data;
          if (newLevel && newLevel.level) {
            this.currentPerformanceContext.qualityLevel = newLevel.level;
            this.adaptLerpParameters();
          }
        }
        handleThermalWarning(data) {
          this.currentPerformanceContext.thermalState = "hot";
          this.adaptLerpParameters();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.warn("PerformanceAwareLerpCoordinator", "Thermal warning - adapting LERP performance");
          }
        }
        handleQualityLevelChange(data) {
          const { newLevel } = data;
          if (newLevel && typeof newLevel.level === "string") {
            this.currentPerformanceContext.qualityLevel = newLevel.level;
            this.adaptLerpParameters();
          }
        }
      };
      __name(_PerformanceAwareLerpCoordinator, "PerformanceAwareLerpCoordinator");
      PerformanceAwareLerpCoordinator = _PerformanceAwareLerpCoordinator;
    }
  });

  // src-js/core/performance/PerformanceOrchestrator.ts
  var _PerformanceOrchestrator, PerformanceOrchestrator, _TransitionOptimizer, TransitionOptimizer;
  var init_PerformanceOrchestrator = __esm({
    "src-js/core/performance/PerformanceOrchestrator.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_globalConfig();
      init_PerformanceAwareLerpCoordinator();
      init_UnifiedCSSConsciousnessController();
      init_EventBus();
      _PerformanceOrchestrator = class _PerformanceOrchestrator {
        constructor(config, performanceAnalyzer, adaptivePerformanceSystem, deviceCapabilityDetector, budgetManager) {
          this.initialized = false;
          this.lerpCoordinator = null;
          this.cssController = null;
          this.registeredSystems = /* @__PURE__ */ new Map();
          this.systemQualityOverrides = /* @__PURE__ */ new Map();
          // Transition management
          this.transitionCache = /* @__PURE__ */ new Map();
          this.activeTransitions = /* @__PURE__ */ new Set();
          // Monitoring intervals
          this.performanceMonitorInterval = null;
          this.qualityAdjustmentInterval = null;
          this.config = config;
          this.performanceAnalyzer = performanceAnalyzer;
          this.adaptivePerformanceSystem = adaptivePerformanceSystem;
          this.deviceCapabilityDetector = deviceCapabilityDetector;
          this.budgetManager = budgetManager;
          this.eventBus = GlobalEventBus;
          this.currentPerformanceBudget = this.createPerformanceBudget();
          this.qualityLevels = this.createQualityLevels();
          this.currentQualityLevel = this.determineInitialQualityLevel();
          this.frameRateMonitor = {
            frameTimes: [],
            lastFrameTime: performance.now(),
            consecutiveDrops: 0,
            targetFPS: 60,
            criticalThreshold: 30
          };
          this.performanceState = {
            currentFPS: 0,
            targetFPS: 60,
            qualityLevel: this.currentQualityLevel,
            activeOptimizations: [],
            systemHealth: "good",
            budgetStatus: "within"
          };
          this.transitionOptimizer = new TransitionOptimizer(this);
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("PerformanceOrchestrator", "Performance orchestrator initialized", {
              targetFPS: this.frameRateMonitor.targetFPS,
              qualityLevel: this.currentQualityLevel.level,
              memoryBudget: this.currentPerformanceBudget.memoryLimitMB
            });
          }
        }
        // ========================================================================
        // IMANAGEDYSTEM INTERFACE IMPLEMENTATION
        // ========================================================================
        async initialize() {
          if (this.initialized) return;
          try {
            await this.deviceCapabilityDetector.initialize();
            await this.adaptivePerformanceSystem.initialize();
            this.cssController = UnifiedCSSConsciousnessController.getInstance();
            this.lerpCoordinator = new PerformanceAwareLerpCoordinator();
            await this.lerpCoordinator.initialize();
            this.subscribeToEvents();
            this.startPerformanceMonitoring();
            await this.applyInitialOptimizations();
            this.initialized = true;
            this.eventBus.emit("performance:orchestrator-initialized", {
              qualityLevel: this.currentQualityLevel,
              budget: this.currentPerformanceBudget
            });
            if (YEAR3000_CONFIG.enableDebug) {
              Y3K?.debug?.log("PerformanceOrchestrator", "Performance orchestrator fully initialized");
            }
          } catch (error) {
            Y3K?.debug?.error("PerformanceOrchestrator", "Initialization failed:", error);
            throw error;
          }
        }
        updateAnimation(deltaTime) {
          this.updateFrameRateMonitoring(deltaTime);
          if (this.lerpCoordinator?.initialized) {
            this.lerpCoordinator.updateAnimation(deltaTime);
            this.updateLerpCoordinatorPerformanceState();
          }
          if (this.shouldInterventForPerformance()) {
            this.performPerformanceIntervention();
          }
        }
        async healthCheck() {
          const metrics = await this.getCurrentMetrics();
          const registeredSystemCount = this.registeredSystems.size;
          const activeTransitionCount = this.activeTransitions.size;
          const isHealthy = metrics.fps >= this.frameRateMonitor.criticalThreshold && metrics.memoryUsageMB < this.currentPerformanceBudget.memoryLimitMB && this.performanceState.budgetStatus !== "exceeded";
          return {
            system: "PerformanceOrchestrator",
            healthy: isHealthy,
            ok: isHealthy,
            details: isHealthy ? "Performance orchestration operating within targets" : `Performance issues detected: FPS=${metrics.fps}, Memory=${metrics.memoryUsageMB}MB`,
            metrics: {
              currentFPS: metrics.fps,
              targetFPS: this.frameRateMonitor.targetFPS,
              qualityLevel: this.currentQualityLevel.level,
              registeredSystems: registeredSystemCount,
              activeTransitions: activeTransitionCount,
              budgetStatus: this.performanceState.budgetStatus,
              consecutiveFrameDrops: this.frameRateMonitor.consecutiveDrops
            }
          };
        }
        destroy() {
          if (this.performanceMonitorInterval) {
            clearInterval(this.performanceMonitorInterval);
            this.performanceMonitorInterval = null;
          }
          if (this.qualityAdjustmentInterval) {
            clearInterval(this.qualityAdjustmentInterval);
            this.qualityAdjustmentInterval = null;
          }
          if (this.lerpCoordinator) {
            this.lerpCoordinator.destroy();
            this.lerpCoordinator = null;
          }
          this.transitionCache.clear();
          this.activeTransitions.clear();
          this.registeredSystems.clear();
          this.initialized = false;
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("PerformanceOrchestrator", "Performance orchestrator destroyed");
          }
        }
        // ========================================================================
        // PUBLIC API - 60FPS GUARANTEE SYSTEM
        // ========================================================================
        /**
         * Enforce 60fps across all registered systems
         */
        maintain60FPS() {
          const currentFPS = this.performanceAnalyzer.getMedianFPS() || 0;
          this.performanceState.currentFPS = currentFPS;
          if (currentFPS < this.frameRateMonitor.targetFPS) {
            const deficit = this.frameRateMonitor.targetFPS - currentFPS;
            this.handleFrameRateDeficit(deficit);
          } else if (currentFPS > this.frameRateMonitor.targetFPS && this.currentQualityLevel.level !== "ultra") {
            this.considerQualityIncrease();
          }
        }
        /**
         * Enforce frame budgets across all systems
         */
        enforceFrameBudgets() {
          const currentFrameTime = this.performanceAnalyzer.getAverageTime("render") || 16.67;
          const budgetExceeded = currentFrameTime > this.currentPerformanceBudget.frameTimeMs;
          this.performanceState.budgetStatus = budgetExceeded ? "exceeded" : "within";
          if (budgetExceeded) {
            const overage = currentFrameTime - this.currentPerformanceBudget.frameTimeMs;
            Y3K?.debug?.warn("PerformanceOrchestrator", `Frame budget exceeded by ${overage.toFixed(2)}ms`);
            this.enforceFrameBudgetViolation(overage);
          }
        }
        // ========================================================================
        // PUBLIC API - QUALITY SCALING COORDINATION
        // ========================================================================
        /**
         * Register a system for quality scaling coordination
         */
        registerSystem(systemName, system) {
          this.registeredSystems.set(systemName, system);
          system.setQualityLevel(this.currentQualityLevel);
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("PerformanceOrchestrator", `Registered system for quality scaling: ${systemName}`);
          }
        }
        /**
         * Coordinate quality scaling across all systems
         */
        coordinateQualityScaling(deviceTier) {
          const newQualityLevel = this.selectQualityLevelForDevice(deviceTier);
          if (newQualityLevel.level !== this.currentQualityLevel.level) {
            this.applyQualityLevel(newQualityLevel);
          }
          return newQualityLevel;
        }
        /**
         * Update quality settings across all systems
         */
        updateSystemQualitySettings(settings) {
          const updatedQuality = { ...this.currentQualityLevel, ...settings };
          this.applyQualityLevel(updatedQuality);
        }
        // ========================================================================
        // PUBLIC API - TRANSITION OPTIMIZATION
        // ========================================================================
        /**
         * Optimize transition between states
         */
        optimizeTransition(fromState, toState) {
          const transitionKey = `${fromState}->${toState}`;
          if (this.transitionCache.has(transitionKey)) {
            return this.transitionCache.get(transitionKey);
          }
          const plan = this.transitionOptimizer.createTransitionPlan(fromState, toState);
          this.transitionCache.set(transitionKey, plan);
          return plan;
        }
        /**
         * Preload transition assets for smoother performance
         */
        preloadTransitionAssets(transitions) {
          for (const transition of transitions) {
            this.transitionOptimizer.preloadTransition(transition);
          }
        }
        // ========================================================================
        // PUBLIC API - PERFORMANCE STATE ACCESS
        // ========================================================================
        getPerformanceState() {
          return { ...this.performanceState };
        }
        getCurrentQualityLevel() {
          return { ...this.currentQualityLevel };
        }
        getPerformanceBudget() {
          return { ...this.currentPerformanceBudget };
        }
        async getCurrentMetrics() {
          const currentFPS = this.performanceAnalyzer.getMedianFPS() || 0;
          const frameTime = currentFPS > 0 ? 1e3 / currentFPS : 1e3;
          return {
            fps: currentFPS,
            frameTime,
            memoryUsageMB: this.getMemoryUsage(),
            cpuUsagePercent: this.getCPUUsage(),
            gpuUsagePercent: this.getGPUUsage(),
            renderTime: this.performanceAnalyzer.getAverageTime("render") || 16.67,
            timestamp: performance.now()
          };
        }
        /**
         * Get LERP coordinator for external access
         */
        getLerpCoordinator() {
          return this.lerpCoordinator;
        }
        // ========================================================================
        // PRIVATE IMPLEMENTATION
        // ========================================================================
        createPerformanceBudget() {
          const deviceCapabilities = this.deviceCapabilityDetector.deviceCapabilities;
          const memoryTier = deviceCapabilities?.memory.level || "medium";
          return {
            frameTimeMs: 16.67,
            // 60fps target
            memoryLimitMB: this.getMemoryLimitForTier(memoryTier),
            cpuTimeSliceMs: 10,
            gpuUtilizationPercent: 40,
            transitionBudgetMs: 5
          };
        }
        createQualityLevels() {
          return /* @__PURE__ */ new Map([
            ["minimal", {
              level: "minimal",
              targetFPS: 30,
              memoryBudgetMB: 15,
              cpuBudgetPercent: 15,
              features: {
                webgl: false,
                particles: false,
                shaders: false,
                blur: false,
                shadows: false,
                animations: true
              }
            }],
            ["low", {
              level: "low",
              targetFPS: 45,
              memoryBudgetMB: 25,
              cpuBudgetPercent: 20,
              features: {
                webgl: false,
                particles: false,
                shaders: false,
                blur: true,
                shadows: false,
                animations: true
              }
            }],
            ["medium", {
              level: "medium",
              targetFPS: 60,
              memoryBudgetMB: 35,
              cpuBudgetPercent: 25,
              features: {
                webgl: true,
                particles: true,
                shaders: false,
                blur: true,
                shadows: true,
                animations: true
              }
            }],
            ["high", {
              level: "high",
              targetFPS: 60,
              memoryBudgetMB: 45,
              cpuBudgetPercent: 30,
              features: {
                webgl: true,
                particles: true,
                shaders: true,
                blur: true,
                shadows: true,
                animations: true
              }
            }],
            ["ultra", {
              level: "ultra",
              targetFPS: 60,
              memoryBudgetMB: 50,
              cpuBudgetPercent: 35,
              features: {
                webgl: true,
                particles: true,
                shaders: true,
                blur: true,
                shadows: true,
                animations: true
              }
            }]
          ]);
        }
        determineInitialQualityLevel() {
          const deviceCapabilities = this.deviceCapabilityDetector.deviceCapabilities;
          if (!deviceCapabilities) {
            return this.qualityLevels.get("medium");
          }
          const tier = deviceCapabilities.overall;
          switch (tier) {
            case "high":
              return this.qualityLevels.get("high");
            case "medium":
              return this.qualityLevels.get("medium");
            case "low":
              return this.qualityLevels.get("low");
            default:
              return this.qualityLevels.get("minimal");
          }
        }
        selectQualityLevelForDevice(deviceTier) {
          return this.qualityLevels.get(deviceTier) || this.qualityLevels.get("medium");
        }
        applyQualityLevel(qualityLevel) {
          this.currentQualityLevel = qualityLevel;
          this.performanceState.qualityLevel = qualityLevel;
          this.frameRateMonitor.targetFPS = qualityLevel.targetFPS;
          for (const [systemName, system] of this.registeredSystems) {
            try {
              system.setQualityLevel(qualityLevel);
            } catch (error) {
              Y3K?.debug?.error("PerformanceOrchestrator", `Failed to apply quality level to ${systemName}:`, error);
            }
          }
          if (this.cssController) {
            this.cssController.updatePerformanceVariables({
              "quality.level": qualityLevel.level === "minimal" ? 0 : qualityLevel.level === "low" ? 0.25 : qualityLevel.level === "medium" ? 0.5 : qualityLevel.level === "high" ? 0.75 : 1,
              "fps.target": qualityLevel.targetFPS,
              "frame.budget": 1e3 / qualityLevel.targetFPS,
              "optimization.level": qualityLevel.level === "minimal" ? 3 : qualityLevel.level === "low" ? 2 : qualityLevel.level === "medium" ? 1 : 0
            });
          }
          this.eventBus.emit("performance:quality-changed", {
            oldLevel: this.performanceState.qualityLevel,
            newLevel: qualityLevel,
            reason: "orchestrator-coordination"
          });
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("PerformanceOrchestrator", `Quality level changed to: ${qualityLevel.level}`);
          }
        }
        updateFrameRateMonitoring(deltaTime) {
          const currentTime = performance.now();
          const frameTime = currentTime - this.frameRateMonitor.lastFrameTime;
          this.frameRateMonitor.frameTimes.push(frameTime);
          if (this.frameRateMonitor.frameTimes.length > 60) {
            this.frameRateMonitor.frameTimes.shift();
          }
          const avgFrameTime = this.frameRateMonitor.frameTimes.reduce((a, b) => a + b, 0) / this.frameRateMonitor.frameTimes.length;
          const currentFPS = 1e3 / avgFrameTime;
          this.performanceState.currentFPS = currentFPS;
          if (frameTime > 1e3 / this.frameRateMonitor.targetFPS * 1.5) {
            this.frameRateMonitor.consecutiveDrops++;
          } else {
            this.frameRateMonitor.consecutiveDrops = 0;
          }
          this.frameRateMonitor.lastFrameTime = currentTime;
        }
        shouldInterventForPerformance() {
          return this.frameRateMonitor.consecutiveDrops >= 3 || this.performanceState.currentFPS < this.frameRateMonitor.criticalThreshold || this.performanceState.budgetStatus === "exceeded";
        }
        performPerformanceIntervention() {
          const currentQualityIndex = Array.from(this.qualityLevels.keys()).indexOf(this.currentQualityLevel.level);
          if (currentQualityIndex > 0) {
            const qualityKeys = Array.from(this.qualityLevels.keys());
            const lowerQualityKey = qualityKeys[currentQualityIndex - 1];
            if (!lowerQualityKey) return;
            const lowerQuality = this.qualityLevels.get(lowerQualityKey);
            if (!lowerQuality) return;
            Y3K?.debug?.warn("PerformanceOrchestrator", `Performance intervention: reducing quality to ${lowerQuality.level}`);
            this.applyQualityLevel(lowerQuality);
            this.performanceState.activeOptimizations.push(`quality-reduced-to-${lowerQuality.level}`);
          }
        }
        handleFrameRateDeficit(deficit) {
          const optimizationLevel = deficit / this.frameRateMonitor.targetFPS;
          if (optimizationLevel > 0.3) {
            this.performPerformanceIntervention();
          } else if (optimizationLevel > 0.1) {
            this.applySelectiveOptimizations(optimizationLevel);
          }
        }
        considerQualityIncrease() {
          if (this.frameRateMonitor.consecutiveDrops === 0 && this.performanceState.budgetStatus === "within") {
            const currentQualityIndex = Array.from(this.qualityLevels.keys()).indexOf(this.currentQualityLevel.level);
            if (currentQualityIndex < this.qualityLevels.size - 1) {
              const qualityKeys = Array.from(this.qualityLevels.keys());
              const higherQualityKey = qualityKeys[currentQualityIndex + 1];
              if (!higherQualityKey) return;
              const higherQuality = this.qualityLevels.get(higherQualityKey);
              if (!higherQuality) return;
              setTimeout(() => {
                this.applyQualityLevel(higherQuality);
              }, 1e3);
            }
          }
        }
        applySelectiveOptimizations(level) {
          const optimizations = [];
          if (level > 0.15) {
            optimizations.push("reduce-particle-density");
          }
          if (level > 0.2) {
            optimizations.push("disable-shadows");
          }
          if (level > 0.25) {
            optimizations.push("reduce-blur-quality");
          }
          this.performanceState.activeOptimizations = optimizations;
          for (const [systemName, system] of this.registeredSystems) {
            system.reduceQuality(level);
          }
        }
        enforceFrameBudgetViolation(overage) {
          const violationLevel = overage / this.currentPerformanceBudget.frameTimeMs;
          if (violationLevel > 0.5) {
            this.performPerformanceIntervention();
          } else {
            this.applySelectiveOptimizations(violationLevel);
          }
        }
        startPerformanceMonitoring() {
          this.performanceMonitorInterval = window.setInterval(() => {
            this.maintain60FPS();
            this.enforceFrameBudgets();
            this.updateSystemHealth();
          }, 100);
          this.qualityAdjustmentInterval = window.setInterval(() => {
            this.evaluateQualityAdjustment();
          }, 5e3);
        }
        subscribeToEvents() {
          this.eventBus.subscribe("performance:thermal-warning", () => {
            this.handleThermalWarning();
          });
          this.eventBus.subscribe("performance:memory-pressure", (data) => {
            this.handleMemoryPressure(data.level);
          });
          this.eventBus.subscribe("performance:battery-low", () => {
            this.handleBatteryOptimization();
          });
        }
        async applyInitialOptimizations() {
          const deviceCapabilities = this.deviceCapabilityDetector.deviceCapabilities;
          if (deviceCapabilities?.memory.level === "low") {
            this.performanceState.activeOptimizations.push("low-memory-mode");
          }
          if (deviceCapabilities?.cpu.level === "low") {
            this.performanceState.activeOptimizations.push("cpu-conservation");
          }
          this.applyQualityLevel(this.currentQualityLevel);
        }
        updateSystemHealth() {
          const currentFPS = this.performanceState.currentFPS;
          const memoryUsage = this.getMemoryUsage();
          if (currentFPS >= this.frameRateMonitor.targetFPS * 0.9 && memoryUsage < this.currentPerformanceBudget.memoryLimitMB * 0.8) {
            this.performanceState.systemHealth = "excellent";
          } else if (currentFPS >= this.frameRateMonitor.targetFPS * 0.75 && memoryUsage < this.currentPerformanceBudget.memoryLimitMB * 0.9) {
            this.performanceState.systemHealth = "good";
          } else if (currentFPS >= this.frameRateMonitor.criticalThreshold && memoryUsage < this.currentPerformanceBudget.memoryLimitMB) {
            this.performanceState.systemHealth = "degraded";
          } else {
            this.performanceState.systemHealth = "critical";
          }
        }
        evaluateQualityAdjustment() {
          const recentPerformance = this.frameRateMonitor.frameTimes.slice(-30);
          const avgRecentFPS = 1e3 / (recentPerformance.reduce((a, b) => a + b, 0) / recentPerformance.length);
          if (avgRecentFPS < this.frameRateMonitor.targetFPS * 0.8) {
            this.performPerformanceIntervention();
          } else if (avgRecentFPS > this.frameRateMonitor.targetFPS * 1.1) {
            this.considerQualityIncrease();
          }
        }
        handleThermalWarning() {
          this.performPerformanceIntervention();
          this.performanceState.activeOptimizations.push("thermal-throttling");
        }
        handleMemoryPressure(level) {
          if (level === "high") {
            this.performPerformanceIntervention();
            this.performanceState.activeOptimizations.push("memory-pressure-reduction");
          }
        }
        handleBatteryOptimization() {
          const batteryQuality = this.qualityLevels.get("low");
          this.applyQualityLevel(batteryQuality);
          this.performanceState.activeOptimizations.push("battery-optimization");
        }
        getMemoryLimitForTier(tier) {
          switch (tier) {
            case "high":
              return 50;
            case "medium":
              return 35;
            case "low":
              return 25;
            default:
              return 15;
          }
        }
        getMemoryUsage() {
          const memoryInfo = performance.memory;
          return memoryInfo ? memoryInfo.usedJSHeapSize / (1024 * 1024) : 0;
        }
        getCPUUsage() {
          const avgFrameTime = this.frameRateMonitor.frameTimes.reduce((a, b) => a + b, 0) / this.frameRateMonitor.frameTimes.length;
          return Math.min(100, avgFrameTime / 16.67 * 20);
        }
        getGPUUsage() {
          return this.currentQualityLevel.features.webgl ? 30 : 5;
        }
        /**
         * Update LERP coordinator with current performance state
         */
        updateLerpCoordinatorPerformanceState() {
          if (!this.lerpCoordinator?.initialized) return;
          const currentFPS = this.performanceAnalyzer.getMedianFPS() || 0;
          const frameTime = currentFPS > 0 ? 1e3 / currentFPS : 1e3;
          const performanceContext = {
            currentFPS,
            targetFPS: this.frameRateMonitor.targetFPS,
            frameTimeMs: frameTime,
            frameBudgetMs: this.currentPerformanceBudget.frameTimeMs,
            qualityLevel: this.currentQualityLevel.level,
            qualityScore: this.calculateQualityScore(),
            deviceTier: this.determineDeviceTier(),
            thermalState: this.getThermalState(),
            powerLevel: this.getPowerLevel(),
            memoryPressure: this.getMemoryPressure(),
            cpuUtilization: this.getCPUUsage() / 100,
            memoryUtilization: this.getMemoryUsage() / this.currentPerformanceBudget.memoryLimitMB,
            gpuUtilization: this.getGPUUsage() / 100
          };
          this.lerpCoordinator.updatePerformanceState(performanceContext);
        }
        /**
         * Calculate overall quality score (0-1)
         */
        calculateQualityScore() {
          const qualityMap = {
            "minimal": 0.1,
            "low": 0.3,
            "medium": 0.5,
            "high": 0.7,
            "ultra": 0.9
          };
          return qualityMap[this.currentQualityLevel.level] || 0.5;
        }
        /**
         * Determine device tier based on capabilities
         */
        determineDeviceTier() {
          const deviceCapabilities = this.deviceCapabilityDetector.deviceCapabilities;
          if (!deviceCapabilities) return "medium";
          switch (deviceCapabilities.overall) {
            case "high":
              return "ultra";
            case "medium":
              return "high";
            case "low":
              return "medium";
            default:
              return "low";
          }
        }
        /**
         * Get thermal state (simplified - would need actual thermal monitoring)
         */
        getThermalState() {
          const avgFPS = this.performanceAnalyzer.getMedianFPS() || 60;
          if (avgFPS < this.frameRateMonitor.targetFPS * 0.6) return "critical";
          if (avgFPS < this.frameRateMonitor.targetFPS * 0.8) return "hot";
          if (avgFPS < this.frameRateMonitor.targetFPS * 0.9) return "warm";
          return "nominal";
        }
        /**
         * Get power level (simplified - would need battery API integration)
         */
        getPowerLevel() {
          return "balanced";
        }
        /**
         * Get memory pressure level
         */
        getMemoryPressure() {
          const memoryUsage = this.getMemoryUsage();
          const memoryLimit = this.currentPerformanceBudget.memoryLimitMB;
          const utilizationRatio = memoryUsage / memoryLimit;
          if (utilizationRatio > 0.8) return "high";
          if (utilizationRatio > 0.6) return "medium";
          return "low";
        }
      };
      __name(_PerformanceOrchestrator, "PerformanceOrchestrator");
      PerformanceOrchestrator = _PerformanceOrchestrator;
      _TransitionOptimizer = class _TransitionOptimizer {
        constructor(orchestrator) {
          this.orchestrator = orchestrator;
        }
        createTransitionPlan(fromState, toState) {
          return {
            id: `transition_${Date.now()}`,
            fromState,
            toState,
            estimatedDuration: this.estimateTransitionDuration(fromState, toState),
            optimizations: this.generateOptimizations(fromState, toState),
            priority: this.determineTransitionPriority(fromState, toState)
          };
        }
        preloadTransition(transition) {
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("TransitionOptimizer", `Preloading transition: ${transition.fromState} -> ${transition.toState}`);
          }
        }
        estimateTransitionDuration(fromState, toState) {
          return 300;
        }
        generateOptimizations(fromState, toState) {
          return [
            {
              type: "precompute",
              target: "transition-frames",
              savings: 5
            },
            {
              type: "cache",
              target: "intermediate-states",
              savings: 3
            }
          ];
        }
        determineTransitionPriority(fromState, toState) {
          return "normal";
        }
      };
      __name(_TransitionOptimizer, "TransitionOptimizer");
      TransitionOptimizer = _TransitionOptimizer;
    }
  });

  // src-js/core/performance/QualityScalingManager.ts
  var _QualityScalingManager, QualityScalingManager;
  var init_QualityScalingManager = __esm({
    "src-js/core/performance/QualityScalingManager.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_globalConfig();
      init_EventBus();
      _QualityScalingManager = class _QualityScalingManager {
        constructor(config, performanceAnalyzer, deviceCapabilityDetector) {
          this.lerpCoordinator = null;
          // Quality management state
          this.qualityProfiles = /* @__PURE__ */ new Map();
          this.qualityFeatures = /* @__PURE__ */ new Map();
          this.registeredSystems = /* @__PURE__ */ new Map();
          this.systemQualityStates = /* @__PURE__ */ new Map();
          // Current quality state
          this.currentProfile = null;
          this.currentQualityLevel = null;
          // Quality adjustment history
          this.adjustmentHistory = [];
          this.lastQualityCheck = 0;
          this.qualityCheckInterval = 2e3;
          // 2 seconds
          // Performance thresholds for automatic adjustments
          this.performanceThresholds = {
            excellent: { minFPS: 58, maxFrameTime: 17 },
            good: { minFPS: 50, maxFrameTime: 20 },
            degraded: { minFPS: 40, maxFrameTime: 25 },
            critical: { minFPS: 30, maxFrameTime: 33 }
          };
          this.config = config;
          this.performanceAnalyzer = performanceAnalyzer;
          this.deviceCapabilityDetector = deviceCapabilityDetector;
          this.eventBus = GlobalEventBus;
          this.qualityMetrics = {
            overallQuality: 0.5,
            performanceImpact: 0.3,
            enabledFeatures: 0,
            availableFeatures: 0,
            deviceUtilization: { cpu: 0, memory: 0, gpu: 0 },
            recentAdjustments: []
          };
          this.initializeQualityProfiles();
          this.initializeQualityFeatures();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("QualityScalingManager", "Quality scaling manager initialized", {
              profiles: this.qualityProfiles.size,
              features: this.qualityFeatures.size
            });
          }
        }
        // ========================================================================
        // PUBLIC API - LERP COORDINATOR INTEGRATION
        // ========================================================================
        /**
         * Set the LERP coordinator for performance-aware quality scaling
         */
        setLerpCoordinator(coordinator) {
          this.lerpCoordinator = coordinator;
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("QualityScalingManager", "LERP coordinator integrated for performance-aware scaling");
          }
        }
        // ========================================================================
        // PUBLIC API - SYSTEM REGISTRATION
        // ========================================================================
        /**
         * Register a system for quality scaling management
         */
        registerSystem(systemName, system) {
          this.registeredSystems.set(systemName, system);
          const capabilities = system.getQualityCapabilities();
          this.integrateSystemCapabilities(systemName, capabilities);
          if (this.currentQualityLevel) {
            system.setQualityLevel(this.currentQualityLevel);
            this.systemQualityStates.set(systemName, this.currentQualityLevel);
          }
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("QualityScalingManager", `Registered system: ${systemName}`, {
              capabilities: capabilities.length
            });
          }
        }
        /**
         * Unregister a system from quality scaling
         */
        unregisterSystem(systemName) {
          this.registeredSystems.delete(systemName);
          this.systemQualityStates.delete(systemName);
          const systemFeatures = Array.from(this.qualityFeatures.entries()).filter(([id, feature]) => id.startsWith(systemName)).map(([id]) => id);
          for (const featureId of systemFeatures) {
            this.qualityFeatures.delete(featureId);
          }
          this.updateQualityMetrics();
        }
        // ========================================================================
        // PUBLIC API - QUALITY LEVEL MANAGEMENT
        // ========================================================================
        /**
         * Set quality level for all registered systems
         */
        setGlobalQualityLevel(qualityLevel) {
          this.currentQualityLevel = qualityLevel;
          const adjustments = [];
          for (const [systemName, system] of this.registeredSystems) {
            try {
              const oldLevel = this.systemQualityStates.get(systemName);
              system.setQualityLevel(qualityLevel);
              this.systemQualityStates.set(systemName, qualityLevel);
              adjustments.push({
                systemName,
                feature: "global-quality-level",
                oldValue: oldLevel?.level || "unknown",
                newValue: qualityLevel.level,
                performanceGain: this.estimatePerformanceGain(oldLevel, qualityLevel),
                qualityLoss: this.estimateQualityLoss(oldLevel, qualityLevel),
                timestamp: performance.now()
              });
            } catch (error) {
              Y3K?.debug?.error("QualityScalingManager", `Failed to set quality level for ${systemName}:`, error);
            }
          }
          this.adjustmentHistory.push(...adjustments);
          this.trimAdjustmentHistory();
          this.updateQualityMetrics();
          this.eventBus.emit("quality:level-changed", {
            newLevel: qualityLevel,
            affectedSystems: Array.from(this.registeredSystems.keys()),
            adjustments
          });
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("QualityScalingManager", `Global quality level set to: ${qualityLevel.level}`, {
              systemsAffected: adjustments.length
            });
          }
        }
        /**
         * Set quality level for a specific system
         */
        setSystemQualityLevel(systemName, qualityLevel) {
          const system = this.registeredSystems.get(systemName);
          if (!system) {
            Y3K?.debug?.warn("QualityScalingManager", `System not found: ${systemName}`);
            return;
          }
          const oldLevel = this.systemQualityStates.get(systemName);
          try {
            system.setQualityLevel(qualityLevel);
            this.systemQualityStates.set(systemName, qualityLevel);
            const adjustment = {
              systemName,
              feature: "system-quality-level",
              oldValue: oldLevel?.level || "unknown",
              newValue: qualityLevel.level,
              performanceGain: this.estimatePerformanceGain(oldLevel, qualityLevel),
              qualityLoss: this.estimateQualityLoss(oldLevel, qualityLevel),
              timestamp: performance.now()
            };
            this.adjustmentHistory.push(adjustment);
            this.trimAdjustmentHistory();
            this.updateQualityMetrics();
            if (YEAR3000_CONFIG.enableDebug) {
              Y3K?.debug?.log("QualityScalingManager", `Quality level set for ${systemName}: ${qualityLevel.level}`);
            }
          } catch (error) {
            Y3K?.debug?.error("QualityScalingManager", `Failed to set quality level for ${systemName}:`, error);
          }
        }
        // ========================================================================
        // PUBLIC API - CONSCIOUSNESS-AWARE ADAPTATION
        // ========================================================================
        /**
         * Adapt quality based on consciousness state and performance
         */
        adaptToConsciousnessState(consciousnessIntensity, musicEnergy) {
          const currentTime = performance.now();
          if (currentTime - this.lastQualityCheck < this.qualityCheckInterval) {
            return;
          }
          this.lastQualityCheck = currentTime;
          const currentFPS = this.performanceAnalyzer.getMedianFPS() || 0;
          const frameTime = this.performanceAnalyzer.getAverageTime("render") || 16.67;
          const performanceTier = this.getPerformanceTier(currentFPS, frameTime);
          const desiredQuality = this.calculateConsciousnessAwareQuality(
            consciousnessIntensity,
            musicEnergy,
            performanceTier
          );
          if (this.lerpCoordinator?.initialized) {
            this.coordinateLerpConsciousness(consciousnessIntensity, musicEnergy, performanceTier);
          }
          if (this.shouldAdjustQuality(desiredQuality)) {
            this.applyConsciousnessQualityAdjustment(desiredQuality, consciousnessIntensity, musicEnergy);
          }
        }
        /**
         * Reduce quality across all systems with intelligent prioritization
         */
        reduceQualityIntelligently(targetReduction) {
          const adjustments = [];
          let remainingReduction = targetReduction;
          const reductionCandidates = this.getQualityReductionCandidates();
          for (const candidate of reductionCandidates) {
            if (remainingReduction <= 0) break;
            const system = this.registeredSystems.get(candidate.systemName);
            if (!system) continue;
            try {
              const reductionAmount = Math.min(remainingReduction, candidate.maxReduction);
              system.reduceQuality(reductionAmount);
              const adjustment = {
                systemName: candidate.systemName,
                feature: candidate.featureName,
                oldValue: candidate.currentValue,
                newValue: candidate.reducedValue,
                performanceGain: candidate.performanceGain,
                qualityLoss: candidate.qualityLoss,
                timestamp: performance.now()
              };
              adjustments.push(adjustment);
              remainingReduction -= reductionAmount;
            } catch (error) {
              Y3K?.debug?.error("QualityScalingManager", `Failed to reduce quality for ${candidate.systemName}:`, error);
            }
          }
          this.adjustmentHistory.push(...adjustments);
          this.trimAdjustmentHistory();
          this.updateQualityMetrics();
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("QualityScalingManager", `Intelligent quality reduction applied`, {
              targetReduction,
              actualReduction: targetReduction - remainingReduction,
              adjustments: adjustments.length
            });
          }
          return adjustments;
        }
        /**
         * Increase quality where performance allows
         */
        increaseQualityOpportunistically() {
          const adjustments = [];
          const currentFPS = this.performanceAnalyzer.getMedianFPS() || 0;
          const frameTime = this.performanceAnalyzer.getAverageTime("render") || 16.67;
          if (currentFPS < this.performanceThresholds.good.minFPS) {
            return adjustments;
          }
          const improvementCandidates = this.getQualityImprovementCandidates();
          for (const candidate of improvementCandidates) {
            const system = this.registeredSystems.get(candidate.systemName);
            if (!system) continue;
            try {
              system.increaseQuality(candidate.improvementAmount);
              const adjustment = {
                systemName: candidate.systemName,
                feature: candidate.featureName,
                oldValue: candidate.currentValue,
                newValue: candidate.improvedValue,
                performanceGain: -candidate.performanceCost,
                // negative because it costs performance
                qualityLoss: -candidate.qualityGain,
                // negative because it's a gain
                timestamp: performance.now()
              };
              adjustments.push(adjustment);
            } catch (error) {
              Y3K?.debug?.error("QualityScalingManager", `Failed to increase quality for ${candidate.systemName}:`, error);
            }
          }
          this.adjustmentHistory.push(...adjustments);
          this.trimAdjustmentHistory();
          this.updateQualityMetrics();
          return adjustments;
        }
        // ========================================================================
        // PUBLIC API - METRICS AND STATE ACCESS
        // ========================================================================
        getQualityMetrics() {
          return { ...this.qualityMetrics };
        }
        getCurrentQualityLevel() {
          return this.currentQualityLevel ? { ...this.currentQualityLevel } : null;
        }
        getSystemQualityState(systemName) {
          const state = this.systemQualityStates.get(systemName);
          return state ? { ...state } : null;
        }
        getQualityProfiles() {
          return Array.from(this.qualityProfiles.values());
        }
        getQualityFeatures() {
          return Array.from(this.qualityFeatures.values());
        }
        getRecentAdjustments(limit = 20) {
          return this.adjustmentHistory.slice(-limit);
        }
        // ========================================================================
        // PRIVATE IMPLEMENTATION
        // ========================================================================
        initializeQualityProfiles() {
          this.qualityProfiles.set("minimal", {
            name: "minimal",
            displayName: "Minimal Quality",
            description: "Optimized for low-end devices with essential features only",
            levels: [{
              level: "minimal",
              targetFPS: 30,
              memoryBudgetMB: 15,
              cpuBudgetPercent: 15,
              features: {
                webgl: false,
                particles: false,
                shaders: false,
                blur: false,
                shadows: false,
                animations: true
              }
            }],
            deviceRequirements: {
              minMemoryGB: 2,
              minCPUCores: 2,
              requiresWebGL: false,
              requiresGPU: false
            }
          });
          this.qualityProfiles.set("balanced", {
            name: "balanced",
            displayName: "Balanced Quality",
            description: "Optimal balance between quality and performance",
            levels: [{
              level: "medium",
              targetFPS: 60,
              memoryBudgetMB: 35,
              cpuBudgetPercent: 25,
              features: {
                webgl: true,
                particles: true,
                shaders: false,
                blur: true,
                shadows: true,
                animations: true
              }
            }],
            deviceRequirements: {
              minMemoryGB: 4,
              minCPUCores: 4,
              requiresWebGL: true,
              requiresGPU: false
            }
          });
          this.qualityProfiles.set("high", {
            name: "high",
            displayName: "High Quality",
            description: "Maximum visual fidelity for high-end devices",
            levels: [{
              level: "ultra",
              targetFPS: 60,
              memoryBudgetMB: 50,
              cpuBudgetPercent: 35,
              features: {
                webgl: true,
                particles: true,
                shaders: true,
                blur: true,
                shadows: true,
                animations: true
              }
            }],
            deviceRequirements: {
              minMemoryGB: 8,
              minCPUCores: 6,
              requiresWebGL: true,
              requiresGPU: true
            }
          });
        }
        initializeQualityFeatures() {
          this.qualityFeatures.set("webgl-rendering", {
            id: "webgl-rendering",
            name: "WebGL Rendering",
            description: "Hardware-accelerated graphics rendering",
            category: "visual",
            impact: { cpu: 0.2, memory: 0.3, gpu: 0.8, battery: 0.4 },
            dependencies: [],
            conflicts: ["css-fallback"],
            enabled: true,
            quality: 0.4
          });
          this.qualityFeatures.set("particle-effects", {
            id: "particle-effects",
            name: "Particle Effects",
            description: "Dynamic particle systems for enhanced visuals",
            category: "effects",
            impact: { cpu: 0.3, memory: 0.2, gpu: 0.6, battery: 0.3 },
            dependencies: ["webgl-rendering"],
            conflicts: [],
            enabled: true,
            quality: 0.3
          });
          this.qualityFeatures.set("advanced-shaders", {
            id: "advanced-shaders",
            name: "Advanced Shaders",
            description: "Complex shader effects for premium visuals",
            category: "effects",
            impact: { cpu: 0.1, memory: 0.1, gpu: 0.9, battery: 0.5 },
            dependencies: ["webgl-rendering"],
            conflicts: [],
            enabled: false,
            quality: 0.5
          });
          this.qualityFeatures.set("blur-effects", {
            id: "blur-effects",
            name: "Blur Effects",
            description: "Gaussian blur and backdrop effects",
            category: "visual",
            impact: { cpu: 0.4, memory: 0.1, gpu: 0.3, battery: 0.2 },
            dependencies: [],
            conflicts: [],
            enabled: true,
            quality: 0.2
          });
          this.qualityFeatures.set("shadow-effects", {
            id: "shadow-effects",
            name: "Shadow Effects",
            description: "Dynamic shadows and depth effects",
            category: "visual",
            impact: { cpu: 0.3, memory: 0.1, gpu: 0.4, battery: 0.2 },
            dependencies: [],
            conflicts: [],
            enabled: true,
            quality: 0.2
          });
          this.qualityFeatures.set("smooth-animations", {
            id: "smooth-animations",
            name: "Smooth Animations",
            description: "High-framerate smooth animations",
            category: "animation",
            impact: { cpu: 0.2, memory: 0.1, gpu: 0.2, battery: 0.3 },
            dependencies: [],
            conflicts: ["reduced-motion"],
            enabled: true,
            quality: 0.3
          });
        }
        integrateSystemCapabilities(systemName, capabilities) {
          for (const capability of capabilities) {
            const featureId = `${systemName}-${capability.name}`;
            this.qualityFeatures.set(featureId, {
              id: featureId,
              name: capability.name,
              description: `System capability: ${capability.name}`,
              category: "performance",
              impact: this.estimateCapabilityImpact(capability.impact),
              dependencies: [],
              conflicts: [],
              enabled: capability.enabled,
              quality: this.estimateCapabilityQuality(capability.impact)
            });
          }
          this.updateQualityMetrics();
        }
        estimateCapabilityImpact(impact) {
          const impactMap = {
            low: { cpu: 0.1, memory: 0.1, gpu: 0.1, battery: 0.1 },
            medium: { cpu: 0.3, memory: 0.2, gpu: 0.3, battery: 0.2 },
            high: { cpu: 0.6, memory: 0.4, gpu: 0.6, battery: 0.4 },
            critical: { cpu: 0.9, memory: 0.7, gpu: 0.8, battery: 0.6 }
          };
          return impactMap[impact];
        }
        estimateCapabilityQuality(impact) {
          const qualityMap = {
            low: 0.1,
            medium: 0.3,
            high: 0.6,
            critical: 0.8
          };
          return qualityMap[impact];
        }
        updateQualityMetrics() {
          const enabledFeatures = Array.from(this.qualityFeatures.values()).filter((f) => f.enabled);
          const totalFeatures = this.qualityFeatures.size;
          const qualityScore = enabledFeatures.reduce((sum, feature) => sum + feature.quality, 0) / Math.max(totalFeatures, 1);
          const performanceImpact = enabledFeatures.reduce((max, feature) => {
            const featureImpact = Math.max(feature.impact.cpu, feature.impact.memory, feature.impact.gpu);
            return Math.max(max, featureImpact);
          }, 0);
          this.qualityMetrics = {
            overallQuality: qualityScore,
            performanceImpact,
            enabledFeatures: enabledFeatures.length,
            availableFeatures: totalFeatures,
            deviceUtilization: this.calculateDeviceUtilization(enabledFeatures),
            recentAdjustments: this.adjustmentHistory.slice(-10)
          };
        }
        calculateDeviceUtilization(enabledFeatures) {
          return enabledFeatures.reduce(
            (util, feature) => ({
              cpu: util.cpu + feature.impact.cpu,
              memory: util.memory + feature.impact.memory,
              gpu: util.gpu + feature.impact.gpu
            }),
            { cpu: 0, memory: 0, gpu: 0 }
          );
        }
        getPerformanceTier(fps, frameTime) {
          if (fps >= this.performanceThresholds.excellent.minFPS && frameTime <= this.performanceThresholds.excellent.maxFrameTime) {
            return "excellent";
          } else if (fps >= this.performanceThresholds.good.minFPS && frameTime <= this.performanceThresholds.good.maxFrameTime) {
            return "good";
          } else if (fps >= this.performanceThresholds.degraded.minFPS && frameTime <= this.performanceThresholds.degraded.maxFrameTime) {
            return "degraded";
          } else {
            return "critical";
          }
        }
        calculateConsciousnessAwareQuality(consciousnessIntensity, musicEnergy, performanceTier) {
          const baseQuality = {
            excellent: 0.9,
            good: 0.7,
            degraded: 0.5,
            critical: 0.3
          }[performanceTier] || 0.5;
          const consciousnessModifier = 0.8 + consciousnessIntensity * 0.4;
          const musicModifier = 0.9 + musicEnergy * 0.2;
          return Math.min(1, baseQuality * consciousnessModifier * musicModifier);
        }
        shouldAdjustQuality(desiredQuality) {
          const currentQuality = this.qualityMetrics.overallQuality;
          const qualityDifference = Math.abs(desiredQuality - currentQuality);
          return qualityDifference > 0.1;
        }
        applyConsciousnessQualityAdjustment(desiredQuality, consciousnessIntensity, musicEnergy) {
          const currentQuality = this.qualityMetrics.overallQuality;
          if (desiredQuality > currentQuality) {
            this.increaseQualityOpportunistically();
          } else if (desiredQuality < currentQuality) {
            const reductionAmount = currentQuality - desiredQuality;
            this.reduceQualityIntelligently(reductionAmount);
          }
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("QualityScalingManager", `Consciousness-aware quality adjustment`, {
              consciousnessIntensity,
              musicEnergy,
              currentQuality,
              desiredQuality
            });
          }
        }
        getQualityReductionCandidates() {
          const candidates = Array.from(this.qualityFeatures.entries()).filter(([_, feature]) => feature.enabled).map(([id, feature]) => ({
            systemName: id.split("-")[0],
            featureName: feature.name,
            currentValue: "enabled",
            reducedValue: "disabled",
            maxReduction: 0.2,
            performanceGain: Math.max(feature.impact.cpu, feature.impact.memory, feature.impact.gpu) * 10,
            qualityLoss: feature.quality,
            ratio: Math.max(feature.impact.cpu, feature.impact.memory, feature.impact.gpu) * 10 / feature.quality
          })).sort((a, b) => b.ratio - a.ratio);
          return candidates;
        }
        getQualityImprovementCandidates() {
          return Array.from(this.qualityFeatures.entries()).filter(([_, feature]) => !feature.enabled).map(([id, feature]) => ({
            systemName: id.split("-")[0],
            featureName: feature.name,
            currentValue: "disabled",
            improvedValue: "enabled",
            improvementAmount: 0.1,
            performanceCost: Math.max(feature.impact.cpu, feature.impact.memory, feature.impact.gpu) * 10,
            qualityGain: feature.quality
          })).filter((candidate) => candidate.performanceCost < 5);
        }
        estimatePerformanceGain(oldLevel, newLevel) {
          if (!oldLevel) return 0;
          const oldComplexity = this.calculateLevelComplexity(oldLevel);
          const newComplexity = this.calculateLevelComplexity(newLevel);
          return (oldComplexity - newComplexity) * 5;
        }
        estimateQualityLoss(oldLevel, newLevel) {
          if (!oldLevel) return 0;
          const oldQuality = this.calculateLevelQuality(oldLevel);
          const newQuality = this.calculateLevelQuality(newLevel);
          return Math.max(0, oldQuality - newQuality);
        }
        calculateLevelComplexity(level) {
          let complexity = 0;
          if (level.features.webgl) complexity += 3;
          if (level.features.particles) complexity += 2;
          if (level.features.shaders) complexity += 4;
          if (level.features.blur) complexity += 1;
          if (level.features.shadows) complexity += 1;
          if (level.features.animations) complexity += 1;
          return complexity;
        }
        calculateLevelQuality(level) {
          let quality = 0;
          if (level.features.webgl) quality += 0.3;
          if (level.features.particles) quality += 0.2;
          if (level.features.shaders) quality += 0.4;
          if (level.features.blur) quality += 0.1;
          if (level.features.shadows) quality += 0.1;
          if (level.features.animations) quality += 0.2;
          return Math.min(1, quality);
        }
        /**
         * Coordinate LERP consciousness with quality scaling
         */
        coordinateLerpConsciousness(consciousnessIntensity, musicEnergy, performanceTier) {
          if (!this.lerpCoordinator?.initialized) return;
          const currentFPS = this.performanceAnalyzer.getMedianFPS() || 0;
          const frameTime = this.performanceAnalyzer.getAverageTime("render") || 16.67;
          const performanceContext = {
            currentFPS,
            targetFPS: 60,
            frameTimeMs: frameTime,
            frameBudgetMs: 16.67,
            qualityLevel: this.currentQualityLevel?.level || "medium",
            qualityScore: this.qualityMetrics.overallQuality,
            deviceTier: this.determineDeviceTierFromCapabilities(),
            thermalState: this.estimateThermalState(currentFPS),
            powerLevel: "balanced",
            memoryPressure: this.estimateMemoryPressure(),
            cpuUtilization: this.estimateCPUUtilization(frameTime),
            memoryUtilization: this.qualityMetrics.deviceUtilization.memory,
            gpuUtilization: this.qualityMetrics.deviceUtilization.gpu
          };
          this.lerpCoordinator.updatePerformanceState(performanceContext);
          if (YEAR3000_CONFIG.enableDebug) {
            Y3K?.debug?.log("QualityScalingManager", "Coordinated LERP consciousness", {
              consciousnessIntensity,
              musicEnergy,
              performanceTier,
              qualityLevel: performanceContext.qualityLevel
            });
          }
        }
        /**
         * Determine device tier from capabilities
         */
        determineDeviceTierFromCapabilities() {
          const deviceCapabilities = this.deviceCapabilityDetector.deviceCapabilities;
          if (!deviceCapabilities) return "medium";
          switch (deviceCapabilities.overall) {
            case "high":
              return "ultra";
            case "medium":
              return "high";
            case "low":
              return "medium";
            default:
              return "low";
          }
        }
        /**
         * Estimate thermal state based on FPS performance
         */
        estimateThermalState(currentFPS) {
          if (currentFPS < 30) return "critical";
          if (currentFPS < 45) return "hot";
          if (currentFPS < 55) return "warm";
          return "nominal";
        }
        /**
         * Estimate memory pressure based on quality metrics
         */
        estimateMemoryPressure() {
          const memoryUtilization = this.qualityMetrics.deviceUtilization.memory;
          if (memoryUtilization > 0.8) return "high";
          if (memoryUtilization > 0.6) return "medium";
          return "low";
        }
        /**
         * Estimate CPU utilization based on frame time
         */
        estimateCPUUtilization(frameTime) {
          const targetFrameTime = 16.67;
          return Math.min(1, frameTime / targetFrameTime);
        }
        trimAdjustmentHistory() {
          const maxHistory = 100;
          if (this.adjustmentHistory.length > maxHistory) {
            this.adjustmentHistory.splice(0, this.adjustmentHistory.length - maxHistory);
          }
        }
      };
      __name(_QualityScalingManager, "QualityScalingManager");
      QualityScalingManager = _QualityScalingManager;
    }
  });

  // src-js/core/performance/PerformanceBudgetManager.ts
  var _PerformanceBudgetManager, PerformanceBudgetManager;
  var init_PerformanceBudgetManager = __esm({
    "src-js/core/performance/PerformanceBudgetManager.ts"() {
      "use strict";
      _PerformanceBudgetManager = class _PerformanceBudgetManager {
        constructor(config = {}, performanceAnalyzer) {
          this.cssConsciousnessController = null;
          // Optimization state
          this.optimizationLevel = "none";
          this.disabledFeatures = /* @__PURE__ */ new Set();
          this.config = {
            budgets: {
              animationFrame: 16.67,
              // 60 FPS
              cssVariableUpdate: 2,
              domObservation: 5,
              audioAnalysis: 10,
              visualEffects: 8,
              userInteraction: 100
            },
            autoOptimize: {
              enabled: true,
              violationThreshold: 5,
              recoveryThreshold: 80
            },
            enableDebug: false,
            ...config
          };
          this.performanceAnalyzer = performanceAnalyzer;
          this.setupBudgetMonitoring();
        }
        static getInstance(config, performanceAnalyzer) {
          if (!_PerformanceBudgetManager.instance && performanceAnalyzer) {
            _PerformanceBudgetManager.instance = new _PerformanceBudgetManager(
              config,
              performanceAnalyzer
            );
          }
          return _PerformanceBudgetManager.instance;
        }
        /**
         * Register CSS Variable Batcher for optimization
         */
        registerUnifiedCSSConsciousnessController(batcher) {
          this.cssConsciousnessController = batcher;
        }
        /**
         * Set up automatic budget monitoring and optimization
         */
        setupBudgetMonitoring() {
          if (!this.config.autoOptimize.enabled) return;
          setInterval(() => {
            this.checkBudgets();
          }, 5e3);
        }
        /**
         * Check budget violations and trigger optimizations
         */
        checkBudgets() {
          const violations = this.performanceAnalyzer.getBudgetViolations();
          const healthScore = this.performanceAnalyzer.calculateHealthScore();
          let totalViolations = 0;
          for (const [operation, count] of violations) {
            totalViolations += count;
            if (count >= this.config.autoOptimize.violationThreshold) {
              this.optimizeOperation(operation);
            }
          }
          if (totalViolations >= this.config.autoOptimize.violationThreshold * 2) {
            this.escalateOptimization();
          }
          if (healthScore >= this.config.autoOptimize.recoveryThreshold) {
            this.recoverOptimizations();
          }
        }
        /**
         * Optimize a specific operation that's violating budget
         */
        optimizeOperation(operation) {
          if (this.disabledFeatures.has(operation)) return;
          switch (operation) {
            case "cssVariableUpdate":
              this.optimizeCSSVariableUpdates();
              break;
            case "domObservation":
              this.optimizeDOMObservation();
              break;
            case "visualEffects":
              this.optimizeVisualEffects();
              break;
            case "audioAnalysis":
              this.optimizeAudioAnalysis();
              break;
          }
          this.disabledFeatures.add(operation);
          if (this.config.enableDebug) {
            console.log(`\u{1F3AF} [PerformanceBudgetManager] Optimized ${operation} due to budget violations`);
          }
        }
        /**
         * Optimize CSS variable updates
         */
        optimizeCSSVariableUpdates() {
          if (!this.cssConsciousnessController) return;
          this.cssConsciousnessController.updateConfig({
            batchIntervalMs: 32,
            // Reduce to 30 FPS
            maxBatchSize: 25
            // Smaller batches
          });
        }
        /**
         * Optimize DOM observation
         */
        optimizeDOMObservation() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-dom-observation", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Optimize visual effects
         */
        optimizeVisualEffects() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-visual-effects", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Optimize audio analysis
         */
        optimizeAudioAnalysis() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-audio-analysis", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Escalate optimization level
         */
        escalateOptimization() {
          if (this.optimizationLevel === "none") {
            this.optimizationLevel = "conservative";
          } else if (this.optimizationLevel === "conservative") {
            this.optimizationLevel = "aggressive";
          }
          if (this.config.enableDebug) {
            console.log(`\u{1F3AF} [PerformanceBudgetManager] Escalated to ${this.optimizationLevel} optimization`);
          }
        }
        /**
         * Recover from optimizations when performance improves
         */
        recoverOptimizations() {
          if (this.optimizationLevel === "none") return;
          this.disabledFeatures.clear();
          if (this.cssConsciousnessController) {
            this.cssConsciousnessController.updateConfig({
              batchIntervalMs: 16,
              maxBatchSize: 50
            });
          }
          document.dispatchEvent(new CustomEvent("year3000:recover-optimizations", {
            detail: { previousLevel: this.optimizationLevel }
          }));
          this.optimizationLevel = "none";
          if (this.config.enableDebug) {
            console.log("\u{1F3AF} [PerformanceBudgetManager] Recovered from optimizations");
          }
        }
        /**
         * Get current optimization status
         */
        getOptimizationStatus() {
          return {
            level: this.optimizationLevel,
            disabledFeatures: Array.from(this.disabledFeatures),
            budgetViolations: this.performanceAnalyzer.getBudgetViolations(),
            healthScore: this.performanceAnalyzer.calculateHealthScore()
          };
        }
        /**
         * Manually trigger optimization for testing
         */
        manualOptimize(operation) {
          this.optimizeOperation(operation);
        }
        /**
         * Manually recover from optimizations
         */
        manualRecover() {
          this.recoverOptimizations();
        }
        /**
         * Update performance budgets
         */
        updateBudgets(budgets) {
          this.config.budgets = { ...this.config.budgets, ...budgets };
          for (const [operation, budget] of Object.entries(budgets)) {
            this.performanceAnalyzer.updateBudget(operation, budget);
          }
        }
        /**
         * Destroy and cleanup
         */
        destroy() {
          this.disabledFeatures.clear();
          this.cssConsciousnessController = null;
          _PerformanceBudgetManager.instance = null;
        }
      };
      __name(_PerformanceBudgetManager, "PerformanceBudgetManager");
      _PerformanceBudgetManager.instance = null;
      PerformanceBudgetManager = _PerformanceBudgetManager;
    }
  });

  // src-js/core/consciousness/UnifiedConsciousnessCoordinator.ts
  var _UnifiedConsciousnessCoordinator, UnifiedConsciousnessCoordinator, globalUnifiedConsciousnessCoordinator;
  var init_UnifiedConsciousnessCoordinator = __esm({
    "src-js/core/consciousness/UnifiedConsciousnessCoordinator.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_Year3000Utilities();
      _UnifiedConsciousnessCoordinator = class _UnifiedConsciousnessCoordinator {
        constructor(utils = Year3000Utilities_exports, settingsManager = null) {
          this.initialized = false;
          // === TRANSITION MANAGEMENT ===
          this.transitionTimer = 0;
          this.lastTransitionStartTime = 0;
          this.transitionFromAccent = "";
          this.transitionToAccent = "";
          this.settingsManager = null;
          this.utils = utils;
          this.settingsManager = settingsManager;
          this.consciousnessState = {
            consciousnessResonance: 0.7,
            multidimensionalAwareness: 0.8,
            transcendenceLevel: 0.6,
            dominantEmotionalTemperature: 6500,
            emotionalDepth: 0.7,
            emotionalComplexity: 0.5,
            totalIntensity: 0.5,
            activeLayerCount: 3,
            volumetricDepth: 0.4,
            cinematicPerspective: 0.6,
            holographicInfluence: 0.2,
            dataStreamIntensity: 0.3,
            interferencePatterns: 0.1,
            projectionStability: 0.9,
            temporalMemoryDepth: 0.5,
            consciousnessEvolution: 0,
            futureProjection: 0.2,
            catppuccinPreservationLevel: 0.8,
            currentPalette: [],
            paletteEvolution: {
              currentGeneration: 0,
              totalEvolutions: 0,
              evolutionVelocity: 0.1,
              adaptationRate: 0.3,
              previousGenerations: [],
              futureProjections: [],
              temporalPatterns: [],
              consciousnessGrowth: 0,
              transcendenceProgress: 0,
              cosmicAlignment: 0.5
            },
            atmosphericDensity: 0.3,
            cosmicResonance: 0.5,
            quantumFluctuation: 0.2,
            lastBlendTime: Date.now(),
            consciousnessFrameRate: 60,
            systemHealthConsciousness: 1
          };
          this.dynamicColorState = {
            currentAccentHex: "#7c3aed",
            // Default StarryNight cosmic purple
            currentAccentRgb: "124,58,237",
            baseBackgroundHex: "#0d1117",
            // Default StarryNight deep space black
            baseBackgroundRgb: "13,17,23",
            lastUpdateTime: 0,
            musicEnergy: 0.5,
            transitionInProgress: false
          };
          this.integrationConfig = {
            accentUpdateEnabled: true,
            baseTransformationEnabled: true,
            consciousnessIntegrationEnabled: true,
            smoothTransitionDuration: 800,
            // 0.8s smooth transitions
            energyResponseMultiplier: 1.2
          };
        }
        async initialize() {
          if (this.initialized) return;
          try {
            this.setupUnifiedEventSubscriptions();
            this.setupSettingsListeners();
            this.initializeCurrentDynamicState();
            const isDynamicEnabled = this.checkDynamicAccentEnabled();
            this.integrationConfig.accentUpdateEnabled = isDynamicEnabled;
            this.initialized = true;
            Y3K?.debug?.log("UnifiedConsciousnessCoordinator", "\u{1F3A8} Unified consciousness coordinator initialized successfully", {
              consciousnessLevel: this.consciousnessState.consciousnessResonance,
              dynamicAccentEnabled: isDynamicEnabled,
              accentHex: this.dynamicColorState.currentAccentHex
            });
          } catch (error) {
            Y3K?.debug?.error("UnifiedConsciousnessCoordinator", "Failed to initialize:", error);
            throw error;
          }
        }
        async healthCheck() {
          const issues = [];
          if (!this.initialized) {
            issues.push("Coordinator not initialized");
          }
          if (this.dynamicColorState.transitionInProgress && Date.now() - this.lastTransitionStartTime > 1e4) {
            issues.push("Dynamic color transition appears stuck");
          }
          if (this.consciousnessState.systemHealthConsciousness < 0.5) {
            issues.push(`Low consciousness health: ${(this.consciousnessState.systemHealthConsciousness * 100).toFixed(1)}%`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Unified consciousness coordination - consciousness level: ${this.consciousnessState.consciousnessResonance.toFixed(2)}, dynamic accent: ${this.integrationConfig.accentUpdateEnabled}`,
            issues,
            system: "UnifiedConsciousnessCoordinator"
          };
        }
        updateAnimation(deltaTime) {
          this.consciousnessState.consciousnessFrameRate = 1e3 / deltaTime;
          this.consciousnessState.consciousnessEvolution += deltaTime * 1e-4;
          if (this.consciousnessState.consciousnessEvolution > 1) {
            this.consciousnessState.consciousnessEvolution = 0;
          }
          this.consciousnessState.quantumFluctuation = 0.2 + Math.sin(Date.now() * 2e-3) * 0.1;
        }
        destroy() {
          if (this.transitionTimer) {
            clearTimeout(this.transitionTimer);
            this.transitionTimer = 0;
          }
          unifiedEventBus.unsubscribeAll("UnifiedConsciousnessCoordinator");
          this.dynamicColorState.transitionInProgress = false;
          this.initialized = false;
          Y3K?.debug?.log("UnifiedConsciousnessCoordinator", "Unified consciousness coordinator destroyed");
        }
        // ============================================================================
        // Unified Event System Integration
        // ============================================================================
        /**
         * Setup unified event subscriptions for both consciousness systems
         */
        setupUnifiedEventSubscriptions() {
          unifiedEventBus.subscribe("colors:harmonized", (data) => {
            this.handleUnifiedColorUpdate(data);
          }, "UnifiedConsciousnessCoordinator");
          unifiedEventBus.subscribe("colors:extracted", (data) => {
            if (data.rawColors) {
              this.handleExtractedColors(data.rawColors);
            }
          }, "UnifiedConsciousnessCoordinator");
          unifiedEventBus.subscribe("colors:applied", (data) => {
            if (data.cssVariables && this.integrationConfig.accentUpdateEnabled) {
              this.handleCSSVariablesApplied(data.cssVariables, data.accentHex, data.accentRgb);
            }
          }, "UnifiedConsciousnessCoordinator");
          unifiedEventBus.subscribe("settings:changed", (data) => {
            this.handleSettingsChange(data);
          }, "UnifiedConsciousnessCoordinator");
          if (typeof document !== "undefined") {
            document.addEventListener("music-state-change", (event) => {
              const customEvent = event;
              if (customEvent.detail) {
                this.handleMusicStateChange(customEvent.detail);
              }
            });
          }
          Y3K?.debug?.log("UnifiedConsciousnessCoordinator", "Unified event subscriptions setup complete");
        }
        /**
         * 🔧 PHASE 4: Handle unified color events (ColorConsciousnessState logic)
         */
        handleUnifiedColorUpdate(data) {
          const { processedColors, accentHex, accentRgb, coordinationMetrics } = data;
          const musicEmotion = coordinationMetrics?.emotionalState || "neutral";
          const beatData = coordinationMetrics?.musicInfluenceStrength || 0.5;
          this.updateConsciousnessFromMusic(musicEmotion, beatData);
          this.updatePaletteFromUnifiedColors(processedColors, accentHex, accentRgb);
          if (this.integrationConfig.accentUpdateEnabled && accentHex && accentHex !== this.dynamicColorState.currentAccentHex) {
            this.scheduleSmoothAccentTransition(accentHex);
          }
          this.publishConsciousnessUpdate();
        }
        /**
         * 🔧 PHASE 4: Handle extracted colors (DynamicCatppuccinBridge logic)
         */
        handleExtractedColors(extractedColors) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            const newAccentHex = this.selectBestAccentColor(extractedColors);
            if (newAccentHex && newAccentHex !== this.dynamicColorState.currentAccentHex) {
              this.scheduleSmoothAccentTransition(newAccentHex);
            }
            Y3K?.debug?.log("UnifiedConsciousnessCoordinator", "Processed extracted colors:", {
              input: Object.keys(extractedColors),
              selectedAccent: newAccentHex
            });
          } catch (error) {
            Y3K?.debug?.error("UnifiedConsciousnessCoordinator", "Error handling extracted colors:", error);
          }
        }
        /**
         * 🔧 PHASE 4: Handle CSS variables applied (DynamicCatppuccinBridge logic)
         */
        handleCSSVariablesApplied(cssVariables, accentHex, accentRgb) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            if (accentHex && accentHex !== this.dynamicColorState.currentAccentHex) {
              this.dynamicColorState.currentAccentHex = accentHex;
              this.dynamicColorState.currentAccentRgb = accentRgb;
              this.dynamicColorState.lastUpdateTime = Date.now();
            }
            const enhancedVariables = {};
            const accent = cssVariables["--sn-accent-hex"] || cssVariables["--spice-accent"] || accentHex;
            const accentRgbVar = cssVariables["--sn-accent-rgb"] || cssVariables["--spice-rgb-accent"] || accentRgb;
            if (accent && accentRgbVar) {
              enhancedVariables["--sn-dynamic-accent-hex"] = accent;
              enhancedVariables["--sn-dynamic-accent-rgb"] = accentRgbVar;
              enhancedVariables["--sn-dynamic-primary-hex"] = accent;
              enhancedVariables["--sn-dynamic-primary-rgb"] = accentRgbVar;
              if (typeof document !== "undefined") {
                const root = document.documentElement;
                Object.entries(enhancedVariables).forEach(([property, value]) => {
                  root.style.setProperty(property, value);
                });
              }
            }
            Y3K?.debug?.log("UnifiedConsciousnessCoordinator", "Processed colors:applied event:", {
              accentHex: accent,
              accentRgb: accentRgbVar,
              variablesProcessed: Object.keys(cssVariables).length,
              enhancedVariables: Object.keys(enhancedVariables).length
            });
          } catch (error) {
            Y3K?.debug?.error("UnifiedConsciousnessCoordinator", "Error handling CSS variables applied:", error);
          }
        }
        /**
         * Handle music state changes for unified consciousness coordination
         */
        handleMusicStateChange(musicState) {
          if (musicState.energy !== void 0) {
            this.dynamicColorState.musicEnergy = musicState.energy;
            if (this.integrationConfig.consciousnessIntegrationEnabled) {
              this.updateConsciousnessWithMusicEnergy(musicState.energy);
            }
          }
        }
        /**
         * Handle settings changes for unified consciousness
         */
        handleSettingsChange(data) {
          if (["catppuccin-flavor", "catppuccin-accentColor", "sn-dynamic-color-intensity"].includes(data.settingKey)) {
            this.consciousnessState.consciousnessEvolution = 0;
            Y3K?.debug?.log("UnifiedConsciousnessCoordinator", "Consciousness state reset due to settings change:", data.settingKey);
          }
          if (data.settingKey === "catppuccin-accentColor") {
            const isDynamic = String(data.value) === "dynamic";
            this.integrationConfig.accentUpdateEnabled = isDynamic;
            Y3K?.debug?.log("UnifiedConsciousnessCoordinator", `Accent setting changed to: ${data.value}, Dynamic enabled: ${isDynamic}`);
          }
        }
        // ============================================================================
        // Consciousness Processing (ColorConsciousnessState logic)
        // ============================================================================
        /**
         * Update consciousness parameters from musical input
         */
        updateConsciousnessFromMusic(musicEmotion, beatData) {
          if (musicEmotion) {
            this.consciousnessState.consciousnessResonance = (musicEmotion.valence + musicEmotion.intensity) * 0.5;
            this.consciousnessState.dominantEmotionalTemperature = 4e3 + musicEmotion.valence * 4e3;
            this.consciousnessState.totalIntensity = musicEmotion.intensity || 0.5;
            this.consciousnessState.multidimensionalAwareness = Math.min(1, (musicEmotion.valence + musicEmotion.arousal) * 0.6);
            this.consciousnessState.emotionalDepth = Math.abs(musicEmotion.valence - 0.5) * 2;
            this.consciousnessState.dataStreamIntensity = musicEmotion.intensity * 0.7;
          }
          if (beatData) {
            this.consciousnessState.holographicInfluence = Math.min(0.8, beatData.strength * 0.6);
            if (beatData.strength > 0.7) {
              this.updateTemporalMemory(beatData);
            }
            this.consciousnessState.volumetricDepth = Math.min(1, beatData.strength * 0.8);
          }
        }
        /**
         * Convert unified processed colors to consciousness format
         */
        updatePaletteFromUnifiedColors(processedColors, accentHex, accentRgb) {
          const paletteColors = [
            { hex: accentHex, rgb: this.hexToRgb(accentHex) },
            { hex: processedColors["primary"] || accentHex, rgb: this.hexToRgb(processedColors["primary"] || accentHex) },
            { hex: processedColors["secondary"] || accentHex, rgb: this.hexToRgb(processedColors["secondary"] || accentHex) }
          ].filter((color2) => color2.hex);
          this.updatePaletteFromHarmony(paletteColors);
        }
        /**
         * Convert color harmony palette to consciousness format
         */
        updatePaletteFromHarmony(palette) {
          if (this.consciousnessState.currentPalette.length > 0) {
            this.consciousnessState.paletteEvolution.previousGenerations.push(
              [...this.consciousnessState.currentPalette]
            );
            if (this.consciousnessState.paletteEvolution.previousGenerations.length > 5) {
              this.consciousnessState.paletteEvolution.previousGenerations.shift();
            }
          }
          this.consciousnessState.currentPalette = palette.map((color2, index) => ({
            rgb: color2.rgb || { r: color2.r || 0, g: color2.g || 0, b: color2.b || 0 },
            oklab: color2.oklab,
            hsl: color2.hsl,
            xyz: color2.xyz,
            // Consciousness properties
            consciousnessLevel: this.consciousnessState.consciousnessResonance,
            emotionalResonance: this.consciousnessState.emotionalDepth,
            transcendenceIndex: this.consciousnessState.transcendenceLevel,
            // Temporal properties
            temporalStability: Math.max(0.1, 1 - index * 0.1),
            evolutionRate: this.consciousnessState.paletteEvolution.evolutionVelocity,
            memoryImprint: this.consciousnessState.temporalMemoryDepth,
            // Atmospheric properties
            volumetricPresence: this.consciousnessState.volumetricDepth * (1 - index * 0.15),
            holographicReflectance: this.consciousnessState.holographicInfluence,
            cosmicFrequency: 432 + index * 111,
            // Metadata
            colorSpace: color2.oklab ? "oklab" : "rgb",
            generationMethod: "harmony",
            timestamp: Date.now()
          }));
          this.consciousnessState.activeLayerCount = palette.length;
          this.consciousnessState.lastBlendTime = Date.now();
          this.consciousnessState.paletteEvolution.currentGeneration++;
          this.consciousnessState.paletteEvolution.totalEvolutions++;
        }
        /**
         * Update temporal memory based on strong beats
         */
        updateTemporalMemory(beatData) {
          const currentTime = Date.now();
          const pattern = {
            patternId: `pattern-${currentTime}`,
            frequency: beatData.tempo || 120,
            strength: beatData.strength,
            colorSequence: [...this.consciousnessState.currentPalette],
            musicalCorrelation: beatData.strength,
            consciousnessSignature: this.consciousnessState.consciousnessResonance
          };
          this.consciousnessState.paletteEvolution.temporalPatterns.push(pattern);
          if (this.consciousnessState.paletteEvolution.temporalPatterns.length > 10) {
            this.consciousnessState.paletteEvolution.temporalPatterns.shift();
          }
          this.consciousnessState.temporalMemoryDepth = Math.min(
            1,
            this.consciousnessState.temporalMemoryDepth + 0.1
          );
        }
        /**
         * Publish consciousness update for dependent systems
         */
        publishConsciousnessUpdate() {
          unifiedEventBus.emit("consciousness:updated", {
            type: "colorConsciousnessUpdate",
            payload: {
              // Core Data (preserved for compatibility)
              palette: this.consciousnessState.currentPalette,
              consciousnessLevel: this.consciousnessState.consciousnessResonance,
              emotionalTemperature: this.consciousnessState.dominantEmotionalTemperature,
              // Enhanced Transcendent Data
              multidimensionalAwareness: this.consciousnessState.multidimensionalAwareness,
              transcendenceLevel: this.consciousnessState.transcendenceLevel,
              volumetricDepth: this.consciousnessState.volumetricDepth,
              dataStreamIntensity: this.consciousnessState.dataStreamIntensity,
              temporalMemoryDepth: this.consciousnessState.temporalMemoryDepth,
              cosmicResonance: this.consciousnessState.cosmicResonance,
              // Evolution State
              paletteGeneration: this.consciousnessState.paletteEvolution.currentGeneration,
              temporalPatternCount: this.consciousnessState.paletteEvolution.temporalPatterns.length,
              // Full State (for advanced consumers including dynamic color integration)
              fullConsciousnessState: this.consciousnessState
            }
          });
          if (this.consciousnessState.dataStreamIntensity > 0.5) {
            unifiedEventBus.emit("consciousness:holographic-stream", {
              type: "holographicStreamUpdate",
              payload: {
                intensity: this.consciousnessState.dataStreamIntensity,
                interferencePatterns: this.consciousnessState.interferencePatterns,
                projectionStability: this.consciousnessState.projectionStability
              }
            });
          }
          if (this.consciousnessState.paletteEvolution.temporalPatterns.length > 3) {
            unifiedEventBus.emit("consciousness:temporal-pattern", {
              type: "temporalPatternDetected",
              payload: {
                patterns: this.consciousnessState.paletteEvolution.temporalPatterns,
                memoryDepth: this.consciousnessState.temporalMemoryDepth
              }
            });
          }
          if (this.consciousnessState.transcendenceLevel > 0.8) {
            unifiedEventBus.emit("consciousness:transcendence-high", {
              type: "transcendenceLevelHigh",
              payload: {
                level: this.consciousnessState.transcendenceLevel,
                cosmicAlignment: this.consciousnessState.paletteEvolution.cosmicAlignment
              }
            });
          }
        }
        // ============================================================================
        // Dynamic Color Processing (DynamicCatppuccinBridge logic)
        // ============================================================================
        /**
         * Schedule smooth transition between accent colors
         */
        scheduleSmoothAccentTransition(newAccentHex) {
          if (this.dynamicColorState.transitionInProgress) {
            this.transitionToAccent = newAccentHex;
            return;
          }
          this.transitionFromAccent = this.dynamicColorState.currentAccentHex;
          this.transitionToAccent = newAccentHex;
          this.dynamicColorState.transitionInProgress = true;
          this.lastTransitionStartTime = Date.now();
          this.animateAccentTransition();
          Y3K?.debug?.log("UnifiedConsciousnessCoordinator", `Accent transition scheduled: ${this.transitionFromAccent} \u2192 ${newAccentHex}`);
        }
        /**
         * Animate smooth accent color transitions
         */
        animateAccentTransition() {
          const animate = /* @__PURE__ */ __name(() => {
            if (!this.dynamicColorState.transitionInProgress) return;
            const elapsed = Date.now() - this.lastTransitionStartTime;
            const progress = Math.min(elapsed / this.integrationConfig.smoothTransitionDuration, 1);
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const currentColor = this.interpolateColors(
              this.transitionFromAccent,
              this.transitionToAccent,
              easeProgress
            );
            if (currentColor) {
              this.applyDynamicAccent(currentColor);
            }
            if (progress >= 1) {
              this.dynamicColorState.transitionInProgress = false;
              this.dynamicColorState.currentAccentHex = this.transitionToAccent;
              this.dynamicColorState.lastUpdateTime = Date.now();
              const rgb = this.utils.hexToRgb(this.transitionToAccent);
              if (rgb) {
                this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
              }
              Y3K?.debug?.log("UnifiedConsciousnessCoordinator", `Accent transition complete: ${this.transitionToAccent}`);
            } else {
              requestAnimationFrame(animate);
            }
          }, "animate");
          requestAnimationFrame(animate);
        }
        /**
         * Apply dynamic accent using unified consciousness coordination
         */
        applyDynamicAccent(accentHex) {
          if (typeof document === "undefined") return;
          const root = document.documentElement;
          const rgb = this.utils.hexToRgb(accentHex);
          if (!rgb) return;
          const rgbString = `${rgb.r},${rgb.g},${rgb.b}`;
          root.style.setProperty("--sn-dynamic-accent-hex", accentHex);
          root.style.setProperty("--sn-dynamic-accent-rgb", rgbString);
          root.style.setProperty("--sn-dynamic-primary-hex", accentHex);
          root.style.setProperty("--sn-dynamic-primary-rgb", rgbString);
          root.style.setProperty("--spice-accent", accentHex);
          root.style.setProperty("--spice-button", accentHex);
          root.style.setProperty("--spice-button-active", accentHex);
          root.style.setProperty("--spice-rgb-accent", rgbString);
          root.style.setProperty("--spice-rgb-button", rgbString);
          root.style.setProperty("--sn-color-extracted-primary-rgb", rgbString);
          root.style.setProperty("--sn-color-extracted-vibrant-rgb", rgbString);
          root.style.setProperty("--sn-color-extracted-dominant-rgb", rgbString);
          if (this.integrationConfig.consciousnessIntegrationEnabled) {
            this.updateConsciousnessWithAccent(accentHex, rgbString);
          }
        }
        /**
         * Update consciousness system with new accent awareness
         */
        updateConsciousnessWithAccent(accentHex, accentRgb) {
          if (typeof document === "undefined") return;
          const root = document.documentElement;
          root.style.setProperty("--organic-holographic-rgb", accentRgb);
          root.style.setProperty("--holographic-scanline-rgb", accentRgb);
          root.style.setProperty(
            "--consciousness-intensity",
            `calc(0.5 + var(--musical-sync-intensity) * ${this.integrationConfig.energyResponseMultiplier})`
          );
        }
        /**
         * Update consciousness with music energy
         */
        updateConsciousnessWithMusicEnergy(energy) {
          if (typeof document === "undefined") return;
          const root = document.documentElement;
          const adjustedEnergy = energy * this.integrationConfig.energyResponseMultiplier;
          root.style.setProperty("--musical-sync-intensity", adjustedEnergy.toString());
          root.style.setProperty("--holographic-music-flicker-intensity", adjustedEnergy.toString());
          const baseIntensity = 0.5;
          const consciousnessIntensity = Math.max(0.1, Math.min(1, baseIntensity + adjustedEnergy * 0.3));
          root.style.setProperty("--consciousness-intensity", consciousnessIntensity.toString());
        }
        // ============================================================================
        // Utility Methods (Consolidated)
        // ============================================================================
        /**
         * Helper method to convert hex to RGB
         */
        hexToRgb(hex) {
          hex = hex.replace("#", "");
          const r = parseInt(hex.substring(0, 2), 16);
          const g2 = parseInt(hex.substring(2, 4), 16);
          const b = parseInt(hex.substring(4, 6), 16);
          return { r, g: g2, b };
        }
        /**
         * Interpolate between two hex colors
         */
        interpolateColors(fromHex, toHex, progress) {
          const fromRgb = this.utils.hexToRgb(fromHex);
          const toRgb = this.utils.hexToRgb(toHex);
          if (!fromRgb || !toRgb) return null;
          const r = Math.round(fromRgb.r + (toRgb.r - fromRgb.r) * progress);
          const g2 = Math.round(fromRgb.g + (toRgb.g - fromRgb.g) * progress);
          const b = Math.round(fromRgb.b + (toRgb.b - fromRgb.b) * progress);
          return this.utils.rgbToHex(r, g2, b);
        }
        /**
         * Select best accent color from extracted colors
         */
        selectBestAccentColor(colors) {
          const priorities = [
            "VIBRANT_NON_ALARMING",
            "VIBRANT",
            "LIGHT_VIBRANT",
            "PROMINENT",
            "PRIMARY",
            "DARK_VIBRANT"
          ];
          for (const key of priorities) {
            const color2 = colors[key];
            if (color2 && this.utils.hexToRgb(color2)) {
              return color2;
            }
          }
          return null;
        }
        /**
         * Check if dynamic accent is enabled in settings
         */
        checkDynamicAccentEnabled() {
          try {
            if (!this.settingsManager) return false;
            const accentSetting = this.settingsManager.get("catppuccin-accentColor");
            return String(accentSetting) === "dynamic";
          } catch (error) {
            Y3K?.debug?.error("UnifiedConsciousnessCoordinator", "Error checking dynamic accent setting:", error);
            return false;
          }
        }
        /**
         * Initialize current dynamic state from existing CSS variables
         */
        initializeCurrentDynamicState() {
          if (typeof document === "undefined") return;
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentAccent = computedStyle.getPropertyValue("--sn-dynamic-accent-hex").trim() || computedStyle.getPropertyValue("--sn-cosmic-accent-hex").trim() || computedStyle.getPropertyValue("--spice-accent").trim();
          if (currentAccent) {
            this.dynamicColorState.currentAccentHex = currentAccent;
            const rgb = this.utils.hexToRgb(currentAccent);
            if (rgb) {
              this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
            }
          }
          this.dynamicColorState.lastUpdateTime = Date.now();
        }
        /**
         * Setup settings change listeners
         */
        setupSettingsListeners() {
          if (typeof document === "undefined") return;
          document.addEventListener("year3000SystemSettingsChanged", (event) => {
            const customEvent = event;
            const { key, value } = customEvent.detail || {};
            if (key === "catppuccin-accentColor") {
              const isDynamic = String(value) === "dynamic";
              this.integrationConfig.accentUpdateEnabled = isDynamic;
              Y3K?.debug?.log("UnifiedConsciousnessCoordinator", `Accent setting changed to: ${value}, Coordinator active: ${this.initialized}`);
            }
          });
        }
        // ============================================================================
        // Public API (Backward Compatibility)
        // ============================================================================
        /**
         * Get current consciousness state (ColorConsciousnessState compatibility)
         */
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        /**
         * Set consciousness parameters manually (ColorConsciousnessState compatibility)
         */
        setConsciousness(level, temperature = 6500) {
          this.consciousnessState.consciousnessResonance = Math.max(0, Math.min(1, level));
          this.consciousnessState.dominantEmotionalTemperature = Math.max(1e3, Math.min(1e4, temperature));
          this.consciousnessState.transcendenceLevel = Math.min(1, level * 1.2);
          this.consciousnessState.multidimensionalAwareness = level * 0.9;
          this.publishConsciousnessUpdate();
        }
        /**
         * Get transcendent color palette (ColorConsciousnessState compatibility)
         */
        getTranscendentPalette() {
          return [...this.consciousnessState.currentPalette];
        }
        /**
         * Get temporal patterns (ColorConsciousnessState compatibility)
         */
        getTemporalPatterns() {
          return [...this.consciousnessState.paletteEvolution.temporalPatterns];
        }
        /**
         * Get current dynamic color state (DynamicCatppuccinBridge compatibility)
         */
        getDynamicColorState() {
          return { ...this.dynamicColorState };
        }
        /**
         * Update integration configuration (DynamicCatppuccinBridge compatibility)
         */
        updateConfig(newConfig) {
          this.integrationConfig = { ...this.integrationConfig, ...newConfig };
          Y3K?.debug?.log("UnifiedConsciousnessCoordinator", "Configuration updated:", newConfig);
        }
        /**
         * Set transcendence level manually (ColorConsciousnessState compatibility)
         */
        setTranscendence(level) {
          this.consciousnessState.transcendenceLevel = Math.max(0, Math.min(1, level));
          this.consciousnessState.cosmicResonance = level * 0.8;
          this.consciousnessState.paletteEvolution.transcendenceProgress = level;
          this.publishConsciousnessUpdate();
        }
        /**
         * Set data stream intensity (ColorConsciousnessState compatibility)
         */
        setDataStreamIntensity(intensity) {
          this.consciousnessState.dataStreamIntensity = Math.max(0, Math.min(1, intensity));
          this.publishConsciousnessUpdate();
        }
      };
      __name(_UnifiedConsciousnessCoordinator, "UnifiedConsciousnessCoordinator");
      UnifiedConsciousnessCoordinator = _UnifiedConsciousnessCoordinator;
      globalUnifiedConsciousnessCoordinator = new UnifiedConsciousnessCoordinator();
    }
  });

  // src-js/visual/strategies/BackgroundStrategyRegistry.ts
  var _BackgroundStrategyRegistry, BackgroundStrategyRegistry;
  var init_BackgroundStrategyRegistry = __esm({
    "src-js/visual/strategies/BackgroundStrategyRegistry.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_SettingsManager();
      _BackgroundStrategyRegistry = class _BackgroundStrategyRegistry {
        // 30 seconds
        constructor(settingsManager) {
          this.strategiesMap = /* @__PURE__ */ new Map();
          // Performance monitoring
          this.metrics = {
            totalStrategies: 0,
            healthyStrategies: 0,
            averageResponseTime: 0,
            totalUsageCount: 0,
            cacheHitRate: 0,
            memoryUsage: 0
          };
          // Health monitoring
          this.healthCheckInterval = null;
          this.HEALTH_CHECK_INTERVAL_MS = 3e4;
          this.settingsManager = settingsManager || new SettingsManager();
          this.startHealthMonitoring();
          Y3K?.debug?.log("BackgroundStrategyRegistry", "Strategy registry initialized");
        }
        /**
         * Register a color processing strategy
         */
        register(strategy) {
          const strategyName = strategy.getStrategyName();
          if (this.strategiesMap.has(strategyName)) {
            Y3K?.debug?.warn("BackgroundStrategyRegistry", `Strategy ${strategyName} is already registered, replacing...`);
          }
          try {
            const registration = {
              strategy,
              registrationTime: Date.now(),
              lastUsed: 0,
              usageCount: 0,
              errorCount: 0,
              averageProcessingTime: 0,
              isHealthy: true,
              metadata: this.inferStrategyMetadata(strategy)
            };
            this.strategiesMap.set(strategyName, registration);
            this.updateMetrics();
            Y3K?.debug?.log("BackgroundStrategyRegistry", `Registered strategy: ${strategyName}`, {
              category: registration.metadata.category,
              priority: registration.metadata.priority,
              memoryImpact: registration.metadata.memoryImpact
            });
          } catch (error) {
            Y3K?.debug?.error("BackgroundStrategyRegistry", `Failed to register strategy ${strategyName}:`, error);
          }
        }
        /**
         * Select best strategy for given criteria
         */
        selectStrategy(criteria) {
          const availableStrategies = Array.from(this.strategiesMap.values()).filter((reg) => reg.isHealthy).sort((a, b) => this.scoreStrategy(b, criteria) - this.scoreStrategy(a, criteria));
          if (availableStrategies.length === 0) {
            Y3K?.debug?.warn("BackgroundStrategyRegistry", "No healthy strategies available");
            return null;
          }
          const selectedStrategy = availableStrategies[0];
          if (!selectedStrategy) {
            Y3K?.debug?.warn("BackgroundStrategyRegistry", "No strategies available after filtering");
            return null;
          }
          this.recordStrategyUsage(selectedStrategy.strategy.getStrategyName());
          Y3K?.debug?.log("BackgroundStrategyRegistry", `Selected strategy: ${selectedStrategy.strategy.getStrategyName()}`, {
            score: this.scoreStrategy(selectedStrategy, criteria),
            totalAvailable: availableStrategies.length
          });
          return selectedStrategy.strategy;
        }
        /**
         * Get all registered strategies
         */
        getStrategies() {
          return Array.from(this.strategiesMap.values()).filter((reg) => reg.isHealthy).map((reg) => reg.strategy);
        }
        /**
         * Get strategy by name
         */
        getStrategy(name) {
          const registration = this.strategiesMap.get(name);
          return registration && registration.isHealthy ? registration.strategy : null;
        }
        /**
         * Get multiple strategies by criteria with intelligent selection
         */
        selectMultipleStrategies(criteria, maxStrategies = 4) {
          const scoredStrategies = Array.from(this.strategiesMap.values()).filter((reg) => reg.isHealthy).map((reg) => ({
            registration: reg,
            score: this.scoreStrategy(reg, criteria)
          })).sort((a, b) => b.score - a.score).slice(0, maxStrategies);
          scoredStrategies.forEach((scored) => {
            this.recordStrategyUsage(scored.registration.strategy.getStrategyName());
          });
          const selectedStrategies = scoredStrategies.map((scored) => scored.registration.strategy);
          Y3K?.debug?.log("BackgroundStrategyRegistry", `Selected ${selectedStrategies.length} strategies`, {
            strategies: selectedStrategies.map((s) => s.getStrategyName()),
            scores: scoredStrategies.map((s) => s.score)
          });
          return selectedStrategies;
        }
        /**
         * Score a strategy based on selection criteria
         */
        scoreStrategy(registration, criteria) {
          let score = 0;
          score += registration.metadata.priority * 10;
          switch (criteria.performance) {
            case "high":
              if (registration.metadata.memoryImpact === "low") score += 20;
              if (registration.averageProcessingTime < 10) score += 15;
              break;
            case "medium":
              if (registration.metadata.memoryImpact !== "high") score += 10;
              if (registration.averageProcessingTime < 20) score += 10;
              break;
            case "low":
              break;
          }
          switch (criteria.quality) {
            case "premium":
              if (registration.metadata.category === "enhancement") score += 15;
              if (registration.metadata.tags.includes("webgl")) score += 10;
              break;
            case "enhanced":
              if (registration.metadata.category !== "effects") score += 10;
              break;
            case "basic":
              if (registration.metadata.category === "foundation") score += 15;
              break;
          }
          if (criteria.deviceCapabilities) {
            if (criteria.deviceCapabilities.hasWebGL && registration.metadata.tags.includes("webgl")) {
              score += 15;
            }
            if (criteria.deviceCapabilities.isMobile && registration.metadata.memoryImpact === "low") {
              score += 10;
            }
            if (criteria.deviceCapabilities.memoryMB && criteria.deviceCapabilities.memoryMB < 4e3) {
              if (registration.metadata.memoryImpact === "high") score -= 20;
            }
          }
          if (criteria.userPreferences) {
            if (criteria.userPreferences.enableAdvancedBlending && registration.metadata.tags.includes("advanced-blending")) {
              score += 12;
            }
            if (criteria.userPreferences.harmonicMode) {
              const mode = criteria.userPreferences.harmonicMode;
              if (registration.metadata.tags.includes(mode)) {
                score += 8;
              }
            }
          }
          const errorRate = registration.usageCount > 0 ? registration.errorCount / registration.usageCount : 0;
          score -= errorRate * 30;
          const timeSinceLastUse = Date.now() - registration.lastUsed;
          if (timeSinceLastUse < 3e5) {
            score += 5;
          }
          return Math.max(0, score);
        }
        /**
         * Infer strategy metadata from strategy instance
         */
        inferStrategyMetadata(strategy) {
          const strategyName = strategy.getStrategyName();
          const tags = [];
          let category = "enhancement";
          let priority = 5;
          let memoryImpact = "medium";
          let deviceRequirements = [];
          switch (strategyName) {
            case "dynamic-catppuccin":
              category = "accent";
              priority = 10;
              memoryImpact = "low";
              tags.push("catppuccin", "dynamic", "accent", "spicetify");
              break;
            case "living-gradient":
              category = "foundation";
              priority = 8;
              memoryImpact = "low";
              tags.push("gradient", "breathing", "foundation", "css");
              break;
            case "webgl-gradient":
              category = "enhancement";
              priority = 6;
              memoryImpact = "high";
              deviceRequirements.push("webgl");
              tags.push("webgl", "gradient", "performance", "advanced-blending");
              break;
            case "depth-layered":
              category = "effects";
              priority = 7;
              memoryImpact = "medium";
              tags.push("depth", "layers", "parallax", "consciousness", "cosmic", "cinematic");
              break;
            default:
              break;
          }
          return {
            category,
            priority,
            memoryImpact,
            deviceRequirements,
            tags
          };
        }
        /**
         * Record strategy usage for metrics
         */
        recordStrategyUsage(strategyName) {
          const registration = this.strategiesMap.get(strategyName);
          if (registration) {
            registration.usageCount++;
            registration.lastUsed = Date.now();
          }
        }
        /**
         * Record strategy error for health monitoring
         */
        recordStrategyError(strategyName, error) {
          const registration = this.strategiesMap.get(strategyName);
          if (registration) {
            registration.errorCount++;
            const errorRate = registration.errorCount / Math.max(1, registration.usageCount);
            if (errorRate > 0.5 && registration.usageCount > 5) {
              registration.isHealthy = false;
              Y3K?.debug?.warn("BackgroundStrategyRegistry", `Strategy ${strategyName} marked as unhealthy`, {
                errorRate,
                errorCount: registration.errorCount,
                usageCount: registration.usageCount
              });
            }
          }
        }
        /**
         * Record strategy processing time for performance tracking
         */
        recordStrategyProcessingTime(strategyName, processingTime) {
          const registration = this.strategiesMap.get(strategyName);
          if (registration) {
            const totalTime = registration.averageProcessingTime * (registration.usageCount - 1) + processingTime;
            registration.averageProcessingTime = totalTime / registration.usageCount;
          }
        }
        /**
         * Start health monitoring for all registered strategies
         */
        startHealthMonitoring() {
          this.healthCheckInterval = window.setInterval(() => {
            this.performHealthChecks();
          }, this.HEALTH_CHECK_INTERVAL_MS);
        }
        /**
         * Perform health checks on all registered strategies
         */
        async performHealthChecks() {
          try {
            for (const [name, registration] of this.strategiesMap.entries()) {
              try {
                if ("healthCheck" in registration.strategy && typeof registration.strategy.healthCheck === "function") {
                  const healthResult = await registration.strategy.healthCheck();
                  registration.isHealthy = healthResult?.healthy ?? true;
                  if (!registration.isHealthy) {
                    Y3K?.debug?.warn("BackgroundStrategyRegistry", `Strategy ${name} failed health check:`, healthResult);
                  }
                }
              } catch (error) {
                registration.isHealthy = false;
                Y3K?.debug?.error("BackgroundStrategyRegistry", `Health check failed for strategy ${name}:`, error);
              }
            }
            this.updateMetrics();
          } catch (error) {
            Y3K?.debug?.error("BackgroundStrategyRegistry", "Health check monitoring failed:", error);
          }
        }
        /**
         * Update registry metrics
         */
        updateMetrics() {
          const registrations = Array.from(this.strategiesMap.values());
          this.metrics.totalStrategies = registrations.length;
          this.metrics.healthyStrategies = registrations.filter((r) => r.isHealthy).length;
          this.metrics.totalUsageCount = registrations.reduce((sum, r) => sum + r.usageCount, 0);
          const processingTimes = registrations.filter((r) => r.averageProcessingTime > 0).map((r) => r.averageProcessingTime);
          if (processingTimes.length > 0) {
            this.metrics.averageResponseTime = processingTimes.reduce((a, b) => a + b, 0) / processingTimes.length;
          }
          this.metrics.memoryUsage = registrations.reduce((sum, r) => {
            const impact = r.metadata.memoryImpact === "high" ? 3 : r.metadata.memoryImpact === "medium" ? 2 : 1;
            return sum + impact;
          }, 0);
        }
        /**
         * Get registry metrics for monitoring
         */
        getRegistryMetrics() {
          return { ...this.metrics };
        }
        /**
         * Get detailed strategy information
         */
        getStrategyInfo(strategyName) {
          const registration = this.strategiesMap.get(strategyName);
          return registration ? { ...registration } : null;
        }
        /**
         * Get all strategy information for debugging
         */
        getAllStrategyInfo() {
          return Array.from(this.strategiesMap.entries()).map(([name, registration]) => ({
            name,
            registration: { ...registration }
          }));
        }
        /**
         * Unregister a strategy
         */
        unregister(strategyName) {
          const success = this.strategiesMap.delete(strategyName);
          if (success) {
            this.updateMetrics();
            Y3K?.debug?.log("BackgroundStrategyRegistry", `Unregistered strategy: ${strategyName}`);
          }
          return success;
        }
        /**
         * Clear all strategies
         */
        clear() {
          this.strategiesMap.clear();
          this.updateMetrics();
          Y3K?.debug?.log("BackgroundStrategyRegistry", "All strategies cleared from registry");
        }
        /**
         * Cleanup resources
         */
        destroy() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          for (const [name, registration] of this.strategiesMap.entries()) {
            if ("destroy" in registration.strategy && typeof registration.strategy.destroy === "function") {
              try {
                registration.strategy.destroy();
              } catch (error) {
                Y3K?.debug?.warn("BackgroundStrategyRegistry", `Error destroying strategy ${name}:`, error);
              }
            }
          }
          this.clear();
          Y3K?.debug?.log("BackgroundStrategyRegistry", "Strategy registry destroyed");
        }
      };
      __name(_BackgroundStrategyRegistry, "BackgroundStrategyRegistry");
      BackgroundStrategyRegistry = _BackgroundStrategyRegistry;
    }
  });

  // src-js/utils/color/MusicalOKLABCoordinator.ts
  var _MusicalOKLABCoordinator, MusicalOKLABCoordinator;
  var init_MusicalOKLABCoordinator = __esm({
    "src-js/utils/color/MusicalOKLABCoordinator.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_globalConfig();
      init_OKLABColorProcessor();
      init_EmotionalTemperatureMapper();
      init_GenreProfileManager();
      _MusicalOKLABCoordinator = class _MusicalOKLABCoordinator {
        // 5 minutes
        constructor(enableDebug = YEAR3000_CONFIG.enableDebug) {
          this.coordinationCache = /* @__PURE__ */ new Map();
          this.cacheMaxSize = 20;
          this.cacheTimeoutMs = 3e5;
          this.enableDebug = enableDebug;
          this.oklabProcessor = new OKLABColorProcessor(enableDebug);
          this.emotionalMapper = new EmotionalTemperatureMapper(enableDebug);
          this.genreManager = new GenreProfileManager({ YEAR3000_CONFIG });
          if (this.enableDebug) {
            Y3K?.debug?.log("MusicalOKLABCoordinator", "Unified music-to-OKLAB coordinator initialized");
          }
        }
        /**
         * Main coordination method - processes musical context through complete OKLAB pipeline
         */
        async coordinateMusicalColors(context, options = {}) {
          const startTime = performance.now();
          const cacheKey = this.generateCacheKey(context);
          const cachedResult = this.coordinationCache.get(cacheKey);
          if (cachedResult) {
            if (this.enableDebug) {
              Y3K?.debug?.log("MusicalOKLABCoordinator", "Using cached coordination result", { cacheKey });
            }
            return cachedResult;
          }
          try {
            const coordinationStrategy = this.determineCoordinationStrategy(context, options);
            const oklabPreset = await this.getOptimalOKLABPreset(context, coordinationStrategy, options);
            const colorProcessingResult = await this.processColorsWithMusicalContext(
              context.rawColors,
              context.musicData,
              oklabPreset
            );
            const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(context.musicData);
            const detectedGenre = this.genreManager.detectGenre(context.musicData);
            const genreCharacteristics = this.genreManager.getColorCharacteristicsForGenre(detectedGenre);
            const musicInfluenceStrength = this.calculateMusicInfluenceStrength(context.musicData, emotionalResult);
            const cssVariables = this.generateUnifiedCSSVariables(
              colorProcessingResult,
              emotionalResult,
              genreCharacteristics,
              oklabPreset
            );
            const { accentHex, accentRgb } = this.selectOptimalAccentColor(colorProcessingResult);
            const processingTime = performance.now() - startTime;
            const result = {
              enhancedColors: Object.fromEntries(
                Object.entries(colorProcessingResult).map(([key, oklabResult]) => [key, oklabResult.enhancedHex])
              ),
              accentHex,
              accentRgb,
              oklabPreset,
              oklabResults: colorProcessingResult,
              detectedGenre,
              emotionalResult,
              genreCharacteristics,
              processingTime,
              musicInfluenceStrength,
              coordinationStrategy,
              cssVariables
            };
            this.cacheResult(cacheKey, result);
            if (this.enableDebug) {
              Y3K?.debug?.log("MusicalOKLABCoordinator", "Musical OKLAB coordination completed", {
                genre: detectedGenre,
                emotion: emotionalResult.primaryEmotion,
                strategy: coordinationStrategy,
                preset: oklabPreset.name,
                processingTime,
                colorCount: Object.keys(colorProcessingResult).length
              });
            }
            return result;
          } catch (error) {
            if (this.enableDebug) {
              Y3K?.debug?.error("MusicalOKLABCoordinator", "Musical coordination failed:", error);
            }
            return this.createFallbackResult(context, performance.now() - startTime);
          }
        }
        /**
         * Determine the optimal coordination strategy based on musical context
         */
        determineCoordinationStrategy(context, options) {
          const { musicData } = context;
          if (!musicData || typeof musicData.energy !== "number" || typeof musicData.valence !== "number") {
            return "fallback";
          }
          if (options.preferGenreOverEmotion === true) {
            return "genre-primary";
          } else if (options.preferGenreOverEmotion === false) {
            return "emotion-primary";
          }
          const energyExtremity = Math.abs(musicData.energy - 0.5) * 2;
          const valenceExtremity = Math.abs(musicData.valence - 0.5) * 2;
          const emotionalExtremity = (energyExtremity + valenceExtremity) / 2;
          if (emotionalExtremity > 0.6) {
            return "emotion-primary";
          }
          const detectedGenre = this.genreManager.detectGenre(musicData);
          if (detectedGenre !== "default") {
            return "genre-primary";
          }
          return "balanced";
        }
        /**
         * Get optimal OKLAB preset considering both genre and emotional context
         */
        async getOptimalOKLABPreset(context, strategy, options) {
          const { musicData } = context;
          try {
            let preset;
            switch (strategy) {
              case "genre-primary":
                preset = this.genreManager.getOKLABPresetForTrack(musicData);
                break;
              case "emotion-primary":
                const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
                preset = emotionalResult.oklabPreset;
                break;
              case "balanced":
                const genrePreset = this.genreManager.getOKLABPresetForTrack(musicData);
                const emotionalResult2 = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
                preset = this.blendPresets(genrePreset, emotionalResult2.oklabPreset, options.intensityMultiplier || 1);
                break;
              default:
                preset = OKLABColorProcessor.getPreset("STANDARD");
            }
            return preset;
          } catch (error) {
            if (this.enableDebug) {
              Y3K?.debug?.warn("MusicalOKLABCoordinator", "Failed to get optimal preset, using STANDARD:", error);
            }
            return OKLABColorProcessor.getPreset("STANDARD");
          }
        }
        /**
         * Blend two OKLAB presets for balanced coordination strategy
         */
        blendPresets(genrePreset, emotionalPreset, intensityMultiplier) {
          const blendedChromaBoost = (genrePreset.chromaBoost + emotionalPreset.chromaBoost) / 2 * intensityMultiplier;
          const blendedLightnessBoost = (genrePreset.lightnessBoost + emotionalPreset.lightnessBoost) / 2;
          const blendedShadowReduction = (genrePreset.shadowReduction + emotionalPreset.shadowReduction) / 2;
          const blendedVibrantThreshold = (genrePreset.vibrantThreshold + emotionalPreset.vibrantThreshold) / 2;
          return OKLABColorProcessor.createCustomPreset(
            "blended-genre-emotion",
            `Blended ${genrePreset.name} + ${emotionalPreset.name}`,
            blendedLightnessBoost,
            blendedChromaBoost,
            blendedShadowReduction,
            blendedVibrantThreshold
          );
        }
        /**
         * Process all colors through OKLAB with musical context
         */
        async processColorsWithMusicalContext(rawColors, musicData, preset) {
          const results = {};
          for (const [key, color2] of Object.entries(rawColors)) {
            if (!color2 || typeof color2 !== "string" || !color2.startsWith("#")) {
              continue;
            }
            try {
              const oklabResult = this.oklabProcessor.processColor(color2, preset);
              results[key] = oklabResult;
            } catch (error) {
              if (this.enableDebug) {
                Y3K?.debug?.warn("MusicalOKLABCoordinator", `Failed to process color ${key}:`, error);
              }
            }
          }
          return results;
        }
        /**
         * Calculate music influence strength for coordination
         */
        calculateMusicInfluenceStrength(musicData, emotionalResult) {
          const energyInfluence = musicData.energy || 0.5;
          const valenceExtremity = Math.abs((musicData.valence || 0.5) - 0.5) * 2;
          const emotionalIntensity = emotionalResult.intensity;
          const baseInfluence = (energyInfluence + valenceExtremity + emotionalIntensity) / 3;
          let contextBoost = 1;
          if (musicData.tempo && musicData.tempo > 0) contextBoost += 0.1;
          if (musicData.danceability && musicData.danceability > 0.7) contextBoost += 0.1;
          if (musicData.genre && musicData.genre !== "default") contextBoost += 0.1;
          return Math.min(1, baseInfluence * contextBoost);
        }
        /**
         * Generate comprehensive CSS variables for all visual systems
         */
        generateUnifiedCSSVariables(oklabResults, emotionalResult, genreCharacteristics, preset) {
          const variables = {};
          Object.entries(oklabResults).forEach(([key, result]) => {
            variables[`--sn-${key.toLowerCase()}-enhanced`] = result.enhancedHex;
            variables[`--sn-${key.toLowerCase()}-oklab-l`] = result.oklabEnhanced.L.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklab-a`] = result.oklabEnhanced.a.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklab-b`] = result.oklabEnhanced.b.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklch-c`] = result.oklchEnhanced.C.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklch-h`] = result.oklchEnhanced.H.toFixed(1);
            variables[`--sn-${key.toLowerCase()}-shadow`] = result.shadowHex;
          });
          Object.entries(emotionalResult.cssVariables).forEach(([key, value]) => {
            variables[key] = value;
          });
          variables["--sn-detected-genre"] = genreCharacteristics ? genreCharacteristics.vibrancyLevel : "standard";
          variables["--sn-color-temperature"] = genreCharacteristics ? genreCharacteristics.colorTemperature : "neutral";
          variables["--sn-emotional-range"] = genreCharacteristics ? genreCharacteristics.emotionalRange : "moderate";
          variables["--sn-oklab-preset-name"] = preset.name;
          variables["--sn-oklab-chroma-boost"] = preset.chromaBoost.toString();
          variables["--sn-oklab-lightness-boost"] = preset.lightnessBoost.toString();
          variables["--sn-musical-oklab-coordination"] = "enabled";
          variables["--sn-color-processing-mode"] = "unified-musical-oklab";
          return variables;
        }
        /**
         * Select optimal accent color from enhanced palette
         */
        selectOptimalAccentColor(oklabResults) {
          const priorityKeys = ["VIBRANT", "PROMINENT", "DARK_VIBRANT", "LIGHT_VIBRANT"];
          for (const key of priorityKeys) {
            if (oklabResults[key]) {
              const result = oklabResults[key];
              return {
                accentHex: result.enhancedHex,
                accentRgb: `${result.enhancedRgb.r},${result.enhancedRgb.g},${result.enhancedRgb.b}`
              };
            }
          }
          const firstResult = Object.values(oklabResults)[0];
          if (firstResult) {
            return {
              accentHex: firstResult.enhancedHex,
              accentRgb: `${firstResult.enhancedRgb.r},${firstResult.enhancedRgb.g},${firstResult.enhancedRgb.b}`
            };
          }
          return {
            accentHex: "#cba6f7",
            // Catppuccin mauve
            accentRgb: "203,166,247"
          };
        }
        /**
         * Create fallback result when coordination fails
         */
        createFallbackResult(context, processingTime) {
          const fallbackPreset = OKLABColorProcessor.getPreset("STANDARD");
          return {
            enhancedColors: context.rawColors,
            accentHex: "#cba6f7",
            accentRgb: "203,166,247",
            oklabPreset: fallbackPreset,
            oklabResults: {},
            detectedGenre: "default",
            emotionalResult: {
              primaryEmotion: "calm",
              intensity: 0.5,
              temperature: 3500,
              blendRatio: 1,
              cssClass: "organic-emotion-calm",
              cssVariables: {},
              oklabPreset: fallbackPreset
            },
            genreCharacteristics: {
              vibrancyLevel: "standard",
              emotionalRange: "moderate",
              colorTemperature: "neutral"
            },
            processingTime,
            musicInfluenceStrength: 0.5,
            coordinationStrategy: "fallback",
            cssVariables: {
              "--sn-musical-oklab-coordination": "fallback",
              "--sn-oklab-preset-name": "STANDARD"
            }
          };
        }
        // Utility methods
        generateCacheKey(context) {
          return `${context.trackUri}-${context.timestamp}-${JSON.stringify(context.musicData)}`;
        }
        cacheResult(cacheKey, result) {
          if (this.coordinationCache.size >= this.cacheMaxSize) {
            const firstKey = this.coordinationCache.keys().next().value;
            if (firstKey) this.coordinationCache.delete(firstKey);
          }
          this.coordinationCache.set(cacheKey, result);
          setTimeout(() => {
            this.coordinationCache.delete(cacheKey);
          }, this.cacheTimeoutMs);
        }
        /**
         * Convert MusicalOKLABResult to ColorResult for integration with existing systems
         */
        convertToColorResult(musicalResult, context) {
          return {
            processedColors: {
              ...musicalResult.enhancedColors,
              ...musicalResult.cssVariables
            },
            accentHex: musicalResult.accentHex,
            accentRgb: musicalResult.accentRgb,
            metadata: {
              strategy: "musical-oklab-coordinator",
              processingTime: musicalResult.processingTime,
              detectedGenre: musicalResult.detectedGenre,
              emotionalState: musicalResult.emotionalResult.primaryEmotion,
              oklabPreset: musicalResult.oklabPreset.name,
              coordinationStrategy: musicalResult.coordinationStrategy,
              musicInfluenceStrength: musicalResult.musicInfluenceStrength
            },
            context: {
              rawColors: context.rawColors,
              trackUri: context.trackUri,
              timestamp: context.timestamp,
              harmonicMode: context.harmonicMode || "musical-oklab",
              musicData: context.musicData
            }
          };
        }
        /**
         * Clear coordination cache
         */
        clearCache() {
          this.coordinationCache.clear();
          if (this.enableDebug) {
            Y3K?.debug?.log("MusicalOKLABCoordinator", "Coordination cache cleared");
          }
        }
        /**
         * Get coordination metrics for monitoring
         */
        getCoordinationMetrics() {
          return {
            cacheSize: this.coordinationCache.size,
            maxCacheSize: this.cacheMaxSize,
            cacheTimeoutMs: this.cacheTimeoutMs,
            enableDebug: this.enableDebug
          };
        }
      };
      __name(_MusicalOKLABCoordinator, "MusicalOKLABCoordinator");
      MusicalOKLABCoordinator = _MusicalOKLABCoordinator;
    }
  });

  // src-js/core/color/UnifiedColorProcessingEngine.ts
  var _UnifiedColorProcessingEngine, UnifiedColorProcessingEngine, globalUnifiedColorProcessingEngine;
  var init_UnifiedColorProcessingEngine = __esm({
    "src-js/core/color/UnifiedColorProcessingEngine.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_PerformanceAnalyzer();
      init_SettingsManager();
      init_BackgroundStrategyRegistry();
      init_BackgroundStrategySelector();
      init_MusicalOKLABCoordinator();
      init_OKLABColorProcessor();
      init_DeviceCapabilityDetector();
      _UnifiedColorProcessingEngine = class _UnifiedColorProcessingEngine {
        // 30 seconds
        constructor(settingsManager, performanceAnalyzer) {
          this.initialized = false;
          // === STATE MANAGEMENT ===
          this.processingState = {
            isProcessing: false,
            currentTrackUri: null,
            lastExtractedColors: null,
            lastProcessedResult: null,
            lastProcessingTime: 0,
            processingQueue: [],
            queueSize: 0
          };
          this.metrics = {
            totalExtractions: 0,
            totalProcessed: 0,
            totalApplied: 0,
            averageProcessingTime: 0,
            successRate: 0,
            errorCount: 0,
            lastProcessingTime: 0,
            oklabCoordinations: 0,
            strategySelections: 0,
            cacheHits: 0
          };
          // === PERFORMANCE OPTIMIZATION ===
          this.processingTimeout = null;
          this.PROCESSING_TIMEOUT_MS = 1e4;
          // 10 seconds
          this.MAX_QUEUE_SIZE = 10;
          this.processingCache = /* @__PURE__ */ new Map();
          this.CACHE_TTL_MS = 3e4;
          this.settingsManager = settingsManager || new SettingsManager();
          this.performanceAnalyzer = performanceAnalyzer || new PerformanceAnalyzer();
          this.deviceCapabilityDetector = new DeviceCapabilityDetector();
          this.strategyRegistry = new BackgroundStrategyRegistry(this.settingsManager);
          this.strategySelector = new BackgroundStrategySelector(this.settingsManager);
          this.oklabProcessor = new OKLABColorProcessor();
          this.musicalOKLABCoordinator = new MusicalOKLABCoordinator(true);
        }
        async initialize() {
          if (this.initialized) return;
          try {
            await this.deviceCapabilityDetector.initialize();
            this.setupEventSubscriptions();
            this.registerDefaultStrategies();
            this.initialized = true;
            Y3K?.debug?.log("UnifiedColorProcessingEngine", "\u{1F3A8} Unified color processing engine initialized");
          } catch (error) {
            Y3K?.debug?.error("UnifiedColorProcessingEngine", "Failed to initialize:", error);
            throw error;
          }
        }
        async healthCheck() {
          const issues = [];
          if (!this.initialized) {
            issues.push("Engine not initialized");
          }
          if (this.processingState.isProcessing && Date.now() - this.processingState.lastProcessingTime > this.PROCESSING_TIMEOUT_MS) {
            issues.push("Processing appears stuck");
          }
          if (this.metrics.errorCount > 0 && this.metrics.successRate < 0.8) {
            issues.push(`Low success rate: ${(this.metrics.successRate * 100).toFixed(1)}%`);
          }
          if (this.processingState.queueSize > this.MAX_QUEUE_SIZE) {
            issues.push(`Queue overflow: ${this.processingState.queueSize} items`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Unified color processing - ${this.metrics.totalProcessed} processed, ${this.metrics.successRate.toFixed(2)} success rate`,
            issues,
            system: "UnifiedColorProcessingEngine"
          };
        }
        updateAnimation(deltaTime) {
          if (this.processingCache.size > 50) {
            this.cleanupCache();
          }
        }
        destroy() {
          if (this.processingTimeout) {
            clearTimeout(this.processingTimeout);
            this.processingTimeout = null;
          }
          this.processingState.processingQueue = [];
          this.processingCache.clear();
          unifiedEventBus.unsubscribeAll("UnifiedColorProcessingEngine");
          this.initialized = false;
        }
        // ============================================================================
        // Event Subscription Setup
        // ============================================================================
        setupEventSubscriptions() {
          unifiedEventBus.subscribe("colors:extracted", (data) => {
            this.handleColorExtraction(data);
          }, "UnifiedColorProcessingEngine");
          unifiedEventBus.subscribe("settings:changed", (data) => {
            this.handleSettingsChange(data);
          }, "UnifiedColorProcessingEngine");
        }
        // ============================================================================
        // Main Processing Pipeline
        // ============================================================================
        /**
         * 🔧 PHASE 3: Main color processing entry point
         * Consolidates processing logic from all three orchestrators
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const cacheKey = this.generateCacheKey(context);
            const cached = this.getCachedResult(cacheKey);
            if (cached) {
              this.metrics.cacheHits++;
              return cached;
            }
            const strategy = await this.selectOptimalStrategy(context);
            this.metrics.strategySelections++;
            const result = await this.processWithOKLAB(context, strategy);
            const processingTime = performance.now() - startTime;
            this.updateMetrics(processingTime, true);
            const unifiedResult = {
              ...result,
              processingTime,
              strategy,
              success: true,
              timestamp: Date.now(),
              coordinationMetrics: {
                detectedGenre: context.musicData?.genre || "unknown",
                emotionalState: context.musicData?.energy ? this.classifyEmotionalState(context.musicData.energy) : "neutral",
                oklabPreset: this.determineOKLABPreset(context),
                coordinationStrategy: strategy.getStrategyName(),
                musicInfluenceStrength: context.musicData?.energy || 0.5
              }
            };
            this.cacheResult(cacheKey, unifiedResult);
            unifiedEventBus.emit("colors:harmonized", {
              processedColors: result.processedColors,
              accentHex: result.accentHex || "#cba6f7",
              accentRgb: result.accentRgb || "203,166,247",
              strategies: [strategy.getStrategyName()],
              coordinationMetrics: unifiedResult.coordinationMetrics,
              oklabData: unifiedResult.oklabData,
              processingTime,
              timestamp: Date.now()
            });
            return unifiedResult;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            this.updateMetrics(processingTime, false);
            Y3K?.debug?.error("UnifiedColorProcessingEngine", "Processing failed:", error);
            return this.createFallbackResult(context, error);
          }
        }
        /**
         * 🔧 PHASE 3: Handle color extraction events - IColorOrchestrator interface
         * Accepts both ColorContext and UnifiedEventBus data formats
         */
        async handleColorExtraction(contextOrData) {
          if ("rawColors" in contextOrData && "trackUri" in contextOrData) {
            return this.processColorContext(contextOrData);
          }
          return this.handleColorExtractionEvent(contextOrData);
        }
        /**
         * Process ColorContext directly (IColorOrchestrator interface)
         */
        async processColorContext(context) {
          this.metrics.totalExtractions++;
          try {
            if (this.processingState.isProcessing) {
              this.addToQueue(context);
              return;
            }
            await this.processWithTimeout(context);
          } catch (error) {
            this.metrics.errorCount++;
            Y3K?.debug?.error("UnifiedColorProcessingEngine", "Color context processing failed:", error);
          }
        }
        /**
         * Handle UnifiedEventBus format events
         */
        async handleColorExtractionEvent(data) {
          this.metrics.totalExtractions++;
          try {
            const context = {
              rawColors: data.rawColors,
              trackUri: data.trackUri,
              musicData: data.musicData,
              timestamp: data.timestamp || Date.now()
            };
            if (this.processingState.isProcessing) {
              this.addToQueue(context);
              return;
            }
            await this.processWithTimeout(context);
          } catch (error) {
            this.metrics.errorCount++;
            Y3K?.debug?.error("UnifiedColorProcessingEngine", "Color extraction handling failed:", error);
          }
        }
        /**
         * 🔧 PHASE 3: Process context with OKLAB coordination
         * Consolidates OKLAB processing from ColorHarmonyEngine
         */
        async processWithOKLAB(context, strategy) {
          const musicalContext = {
            rawColors: context.rawColors,
            musicData: context.musicData,
            // Type compatibility
            trackUri: context.trackUri,
            timestamp: context.timestamp
          };
          const oklabResult = await this.musicalOKLABCoordinator.coordinateMusicalColors(musicalContext);
          this.metrics.oklabCoordinations++;
          const strategyResult = await strategy.processColors(context);
          const enhancedColors = await this.enhanceWithOKLAB(strategyResult.processedColors, oklabResult);
          return {
            ...strategyResult,
            processedColors: enhancedColors,
            metadata: {
              ...strategyResult.metadata,
              oklabPreset: this.determineOKLABPreset(context),
              oklabCoordination: oklabResult
            }
          };
        }
        /**
         * 🔧 PHASE 3: Strategy selection consolidating all orchestrator logic
         */
        async selectOptimalStrategy(context) {
          try {
            const capabilities = this.deviceCapabilityDetector.getCapabilities();
            const backgroundCriteria = {
              performance: "medium",
              quality: "enhanced",
              deviceCapabilities: {
                hasWebGL: capabilities?.gpu?.supportsWebGL || true,
                memoryMB: capabilities?.memory?.total || 4096,
                isMobile: false
              },
              userPreferences: {
                harmonicMode: "cosmic",
                intensity: 0.8,
                enableAdvancedBlending: true
              },
              // BackgroundStrategySelector-specific properties
              settingsContext: {
                dynamicAccentEnabled: true,
                gradientIntensity: "medium",
                webglEnabled: capabilities?.gpu?.supportsWebGL || true,
                visualGuideMode: "enhanced",
                depthLayersEnabled: true,
                consciousnessLevel: 0.8,
                breathingAnimationEnabled: true
              },
              deviceContext: {
                supportsWebGL: capabilities?.gpu?.supportsWebGL || true,
                performanceLevel: "medium",
                memoryCapacity: capabilities?.memory?.total || 4096,
                isMobile: false
              }
            };
            const strategies = this.strategySelector.selectStrategies(
              context,
              backgroundCriteria
            );
            if (strategies && strategies.length > 0 && strategies[0]) {
              return strategies[0];
            }
          } catch (error) {
            Y3K?.debug?.warn("UnifiedColorProcessingEngine", "Strategy selection failed, using fallback:", error);
          }
          const fallbackStrategy = {
            getStrategyName: /* @__PURE__ */ __name(() => "fallback", "getStrategyName"),
            canProcess: /* @__PURE__ */ __name((ctx) => true, "canProcess"),
            getEstimatedProcessingTime: /* @__PURE__ */ __name((ctx) => 50, "getEstimatedProcessingTime"),
            // 50ms estimate
            processColors: /* @__PURE__ */ __name(async (ctx) => ({
              processedColors: ctx.rawColors,
              accentHex: "#cba6f7",
              accentRgb: "203,166,247",
              context: ctx,
              metadata: { strategy: "fallback", timestamp: Date.now(), processingTime: 0 }
            }), "processColors")
          };
          return fallbackStrategy;
        }
        // ============================================================================
        // Queue Management (from orchestrators)
        // ============================================================================
        addToQueue(context) {
          if (this.processingState.queueSize >= this.MAX_QUEUE_SIZE) {
            this.processingState.processingQueue.shift();
          }
          this.processingState.processingQueue.push(context);
          this.processingState.queueSize = this.processingState.processingQueue.length;
        }
        async processQueue() {
          while (this.processingState.processingQueue.length > 0 && !this.processingState.isProcessing) {
            const context = this.processingState.processingQueue.shift();
            this.processingState.queueSize = this.processingState.processingQueue.length;
            await this.processWithTimeout(context);
          }
        }
        async processWithTimeout(context) {
          this.processingState.isProcessing = true;
          this.processingState.lastProcessingTime = Date.now();
          this.processingTimeout = window.setTimeout(() => {
            Y3K?.debug?.warn("UnifiedColorProcessingEngine", "Processing timeout - forcing reset");
            this.processingState.isProcessing = false;
            this.metrics.errorCount++;
          }, this.PROCESSING_TIMEOUT_MS);
          try {
            await this.processColors(context);
            this.metrics.totalProcessed++;
          } finally {
            if (this.processingTimeout) {
              clearTimeout(this.processingTimeout);
              this.processingTimeout = null;
            }
            this.processingState.isProcessing = false;
            if (this.processingState.processingQueue.length > 0) {
              setTimeout(() => this.processQueue(), 0);
            }
          }
        }
        // ============================================================================
        // Performance Optimization
        // ============================================================================
        generateCacheKey(context) {
          const keyData = {
            colors: Object.keys(context.rawColors).sort().join(","),
            music: context.musicData?.energy || 0
          };
          return JSON.stringify(keyData);
        }
        getCachedResult(key) {
          const cached = this.processingCache.get(key);
          if (cached && Date.now() - cached.timestamp < this.CACHE_TTL_MS) {
            return cached;
          }
          return null;
        }
        cacheResult(key, result) {
          this.processingCache.set(key, { ...result, timestamp: Date.now() });
        }
        cleanupCache() {
          const now = Date.now();
          for (const [key, result] of this.processingCache.entries()) {
            if (now - result.timestamp > this.CACHE_TTL_MS) {
              this.processingCache.delete(key);
            }
          }
        }
        updateMetrics(processingTime, success) {
          this.metrics.averageProcessingTime = (this.metrics.averageProcessingTime * this.metrics.totalProcessed + processingTime) / (this.metrics.totalProcessed + 1);
          if (success) {
            this.metrics.successRate = (this.metrics.successRate * this.metrics.totalProcessed + 1) / (this.metrics.totalProcessed + 1);
          } else {
            this.metrics.successRate = this.metrics.successRate * this.metrics.totalProcessed / (this.metrics.totalProcessed + 1);
          }
          this.metrics.lastProcessingTime = Date.now();
        }
        // ============================================================================
        // Utility Methods
        // ============================================================================
        async enhanceWithOKLAB(colors, oklabResult) {
          const enhanced = { ...colors };
          if (oklabResult.enhancedColors) {
            Object.entries(oklabResult.enhancedColors).forEach(([key, value]) => {
              enhanced[`oklab-${key}`] = value;
            });
          }
          return enhanced;
        }
        classifyEmotionalState(energy) {
          if (energy > 0.8) return "energetic";
          if (energy > 0.6) return "upbeat";
          if (energy > 0.4) return "moderate";
          if (energy > 0.2) return "calm";
          return "peaceful";
        }
        determineOKLABPreset(context) {
          const energy = context.musicData?.energy || 0.5;
          if (energy > 0.8) return "high-energy";
          if (energy > 0.6) return "dynamic";
          if (energy > 0.4) return "balanced";
          return "ambient";
        }
        createFallbackResult(context, error) {
          return {
            processedColors: {
              fallback: "#cba6f7"
              // Default Catppuccin mauve
            },
            accentHex: "#cba6f7",
            accentRgb: "203,166,247",
            context,
            // Required by ColorResult interface
            metadata: {
              strategy: "fallback",
              error: error.message,
              timestamp: Date.now(),
              processingTime: 0
            }
          };
        }
        registerDefaultStrategies() {
        }
        async handleSettingsChange(data) {
          if (["catppuccin-flavor", "catppuccin-accentColor", "sn-dynamic-color-intensity"].includes(data.settingKey)) {
            this.processingCache.clear();
            Y3K?.debug?.log("UnifiedColorProcessingEngine", "Cache cleared due to settings change:", data.settingKey);
          }
        }
        async handlePerformanceWarning(data) {
          if (data.memoryUsage > 50) {
            this.processingCache.clear();
            Y3K?.debug?.log("UnifiedColorProcessingEngine", "Cache cleared due to memory pressure");
          }
        }
        // ============================================================================
        // Public API (Backward Compatibility)
        // ============================================================================
        /**
         * Get processing metrics for debugging and monitoring
         */
        getMetrics() {
          return { ...this.metrics };
        }
        /**
         * Force reprocess current colors (compatibility method)
         */
        async forceReprocessColors() {
          this.processingCache.clear();
          if (this.processingState.lastExtractedColors) {
            const context = {
              rawColors: this.processingState.lastExtractedColors,
              trackUri: this.processingState.currentTrackUri || "",
              timestamp: Date.now()
            };
            await this.processColors(context);
          }
        }
        /**
         * Get current processing state (debugging)
         */
        getProcessingState() {
          return { ...this.processingState };
        }
        // ============================================================================
        // IColorOrchestrator Interface Implementation
        // ============================================================================
        /**
         * Get current processing status (IColorOrchestrator interface)
         */
        getStatus() {
          return {
            isProcessing: this.processingState.isProcessing,
            queueSize: this.processingState.queueSize
          };
        }
        /**
         * Set strategy selection criteria (IColorOrchestrator interface)
         */
        setSelectionCriteria(criteria) {
          Y3K?.debug?.log("UnifiedColorProcessingEngine", "Strategy selection criteria updated:", criteria);
        }
      };
      __name(_UnifiedColorProcessingEngine, "UnifiedColorProcessingEngine");
      UnifiedColorProcessingEngine = _UnifiedColorProcessingEngine;
      globalUnifiedColorProcessingEngine = new UnifiedColorProcessingEngine();
    }
  });

  // src-js/utils/performance/ViewportAwarenessManager.ts
  var _ViewportAwarenessManager, ViewportAwarenessManager, ViewportManager;
  var init_ViewportAwarenessManager = __esm({
    "src-js/utils/performance/ViewportAwarenessManager.ts"() {
      "use strict";
      _ViewportAwarenessManager = class _ViewportAwarenessManager {
        constructor() {
          this.observers = /* @__PURE__ */ new Map();
          this.trackedElements = /* @__PURE__ */ new Map();
          this.isSupported = typeof IntersectionObserver !== "undefined";
          if (!this.isSupported) {
            console.warn("[ViewportAwarenessManager] IntersectionObserver not supported, falling back to always-visible behavior");
          }
        }
        static getInstance() {
          if (!_ViewportAwarenessManager.instance) {
            _ViewportAwarenessManager.instance = new _ViewportAwarenessManager();
          }
          return _ViewportAwarenessManager.instance;
        }
        /**
         * Track an element's visibility with callback
         */
        trackElement(element, callback, options = {}) {
          if (!this.isSupported) {
            const fallbackState = {
              isVisible: true,
              intersectionRatio: 1,
              lastVisibilityChange: Date.now(),
              element
            };
            callback(fallbackState);
            return () => {
            };
          }
          const opts = {
            visibilityThreshold: 0.1,
            rootMargin: "50px",
            trackRootElement: false,
            ...options
          };
          const observerKey = this.getObserverKey(opts);
          let observer = this.observers.get(observerKey);
          if (!observer) {
            observer = new IntersectionObserver(
              (entries) => this.handleIntersectionChanges(entries),
              {
                threshold: opts.visibilityThreshold,
                rootMargin: opts.rootMargin,
                root: opts.rootSelector ? document.querySelector(opts.rootSelector) : null
              }
            );
            this.observers.set(observerKey, observer);
          }
          const initialState = {
            isVisible: false,
            // Will be updated by intersection callback
            intersectionRatio: 0,
            lastVisibilityChange: Date.now(),
            element
          };
          this.trackedElements.set(element, {
            callback,
            options: opts,
            state: initialState
          });
          observer.observe(element);
          return () => this.untrackElement(element);
        }
        /**
         * Check if an element is currently visible
         */
        isElementVisible(element) {
          const tracked = this.trackedElements.get(element);
          return tracked?.state.isVisible ?? true;
        }
        /**
         * Get current visibility state for an element
         */
        getVisibilityState(element) {
          return this.trackedElements.get(element)?.state ?? null;
        }
        /**
         * Stop tracking an element
         */
        untrackElement(element) {
          const tracked = this.trackedElements.get(element);
          if (!tracked) return;
          const observerKey = this.getObserverKey(tracked.options);
          const observer = this.observers.get(observerKey);
          if (observer) {
            observer.unobserve(element);
          }
          this.trackedElements.delete(element);
        }
        /**
         * Track viewport visibility of the main Spotify container
         */
        trackSpotifyContainer(callback) {
          const spotifySelectors = [
            ".Root__main-view",
            '[data-testid="topbar"]',
            ".main-view-container",
            "#main"
          ];
          let element = null;
          for (const selector of spotifySelectors) {
            element = document.querySelector(selector);
            if (element) break;
          }
          if (!element) {
            console.warn("[ViewportAwarenessManager] Could not find Spotify main container, using document.body");
            element = document.body;
          }
          return this.trackElement(element, callback, {
            visibilityThreshold: 0.1,
            rootMargin: "0px",
            trackRootElement: true
          });
        }
        /**
         * Bulk check visibility of multiple elements
         */
        checkBulkVisibility(elements) {
          const results = /* @__PURE__ */ new Map();
          for (const element of elements) {
            results.set(element, this.isElementVisible(element));
          }
          return results;
        }
        /**
         * Cleanup all observers and tracked elements
         */
        destroy() {
          for (const observer of this.observers.values()) {
            observer.disconnect();
          }
          this.observers.clear();
          this.trackedElements.clear();
        }
        handleIntersectionChanges(entries) {
          for (const entry of entries) {
            const tracked = this.trackedElements.get(entry.target);
            if (!tracked) continue;
            const wasVisible = tracked.state.isVisible;
            const isNowVisible = entry.isIntersecting;
            tracked.state = {
              isVisible: isNowVisible,
              intersectionRatio: entry.intersectionRatio,
              lastVisibilityChange: wasVisible !== isNowVisible ? Date.now() : tracked.state.lastVisibilityChange,
              element: entry.target
            };
            if (wasVisible !== isNowVisible) {
              try {
                tracked.callback(tracked.state);
              } catch (error) {
                console.error("[ViewportAwarenessManager] Error in visibility callback:", error);
              }
            }
          }
        }
        getObserverKey(options) {
          return `${options.visibilityThreshold}-${options.rootMargin}-${options.rootSelector || "viewport"}`;
        }
      };
      __name(_ViewportAwarenessManager, "ViewportAwarenessManager");
      ViewportAwarenessManager = _ViewportAwarenessManager;
      ViewportManager = ViewportAwarenessManager.getInstance();
    }
  });

  // src-js/visual/base/ViewportAwareSystem.ts
  var _ViewportAwareSystem, ViewportAwareSystem;
  var init_ViewportAwareSystem = __esm({
    "src-js/visual/base/ViewportAwareSystem.ts"() {
      "use strict";
      init_ViewportAwarenessManager();
      init_UnifiedEventBus();
      _ViewportAwareSystem = class _ViewportAwareSystem {
        constructor(options = {}) {
          this.initialized = false;
          this.isVisible = true;
          // Default to visible until we know otherwise
          this.visibilityState = null;
          this.animationsPaused = false;
          this.settingsUpdatesPaused = false;
          this.viewportOptions = {
            visibilityThreshold: 0.1,
            rootMargin: "50px",
            pauseAnimationsWhenHidden: true,
            pauseSettingsUpdatesWhenHidden: true,
            resumeDelay: 100,
            ...options
          };
        }
        async initialize() {
          await this.initializeViewportTracking();
          await this.initializeEventSubscriptions();
          await this.initializeSystem();
          this.initialized = true;
        }
        async healthCheck() {
          const systemHealth = await this.performHealthCheck();
          return {
            ...systemHealth,
            details: `${systemHealth.details} | Viewport: ${this.isVisible ? "visible" : "hidden"}`
          };
        }
        updateAnimation(deltaTime) {
          if (this.shouldSkipAnimationUpdate()) {
            return;
          }
          this.performAnimationUpdate(deltaTime);
        }
        destroy() {
          this.cleanupViewportTracking();
          this.cleanupEventSubscriptions();
          this.performDestroy();
        }
        /**
         * Handle settings changes with viewport awareness
         */
        handleSettingsChange(event) {
          if (this.shouldSkipSettingsUpdate()) {
            return;
          }
          this.performSettingsUpdate(event);
        }
        /**
         * Force a repaint/update regardless of visibility
         */
        forceRepaint(reason) {
          this.performForceRepaint?.(reason);
        }
        // Optional hooks for viewport awareness
        onVisibilityChanged(state) {
        }
        onBecomingVisible() {
        }
        onBecomingHidden() {
        }
        async initializeViewportTracking() {
          let targetElement = null;
          if (this.viewportOptions.trackingSelector) {
            targetElement = document.querySelector(this.viewportOptions.trackingSelector);
          }
          if (!targetElement) {
            this.untrackViewport = ViewportManager.trackSpotifyContainer(
              (state) => this.handleVisibilityChange(state)
            );
          } else {
            this.untrackViewport = ViewportManager.trackElement(
              targetElement,
              (state) => this.handleVisibilityChange(state),
              this.viewportOptions
            );
          }
        }
        async initializeEventSubscriptions() {
          this.settingsSubscriptionId = unifiedEventBus.subscribe(
            "settings:changed",
            (data) => this.handleUnifiedSettingsChange(data),
            `ViewportAwareSystem-${this.constructor.name}`
          );
        }
        cleanupEventSubscriptions() {
          if (this.settingsSubscriptionId) {
            unifiedEventBus.unsubscribe(this.settingsSubscriptionId);
            delete this.settingsSubscriptionId;
          }
        }
        handleUnifiedSettingsChange(data) {
          if (this.shouldSkipSettingsUpdate()) {
            return;
          }
          const legacyEvent = new CustomEvent("year3000SystemSettingsChanged", {
            detail: { key: data.settingKey, value: data.newValue }
          });
          this.performSettingsUpdate(legacyEvent);
        }
        handleVisibilityChange(state) {
          const wasVisible = this.isVisible;
          this.isVisible = state.isVisible;
          this.visibilityState = state;
          if (!wasVisible && this.isVisible) {
            this.handleBecomingVisible();
          } else if (wasVisible && !this.isVisible) {
            this.handleBecomingHidden();
          }
          this.onVisibilityChanged(state);
        }
        handleBecomingVisible() {
          if (this.resumeTimeoutId) {
            clearTimeout(this.resumeTimeoutId);
          }
          this.resumeTimeoutId = window.setTimeout(() => {
            this.animationsPaused = false;
            this.settingsUpdatesPaused = false;
            this.onBecomingVisible();
          }, this.viewportOptions.resumeDelay || 100);
        }
        handleBecomingHidden() {
          if (this.viewportOptions.pauseAnimationsWhenHidden) {
            this.animationsPaused = true;
          }
          if (this.viewportOptions.pauseSettingsUpdatesWhenHidden) {
            this.settingsUpdatesPaused = true;
          }
          this.onBecomingHidden();
        }
        shouldSkipAnimationUpdate() {
          return this.animationsPaused || !this.isVisible && (this.viewportOptions.pauseAnimationsWhenHidden ?? true);
        }
        shouldSkipSettingsUpdate() {
          return this.settingsUpdatesPaused || !this.isVisible && (this.viewportOptions.pauseSettingsUpdatesWhenHidden ?? true);
        }
        cleanupViewportTracking() {
          if (this.untrackViewport) {
            this.untrackViewport();
            delete this.untrackViewport;
          }
          if (this.resumeTimeoutId) {
            clearTimeout(this.resumeTimeoutId);
            delete this.resumeTimeoutId;
          }
        }
        /**
         * Get current visibility information for debugging
         */
        getVisibilityInfo() {
          return {
            isVisible: this.isVisible,
            animationsPaused: this.animationsPaused,
            settingsUpdatesPaused: this.settingsUpdatesPaused,
            ...this.visibilityState?.intersectionRatio !== void 0 && {
              intersectionRatio: this.visibilityState.intersectionRatio
            }
          };
        }
      };
      __name(_ViewportAwareSystem, "ViewportAwareSystem");
      ViewportAwareSystem = _ViewportAwareSystem;
    }
  });

  // src-js/ui/managers/GlassmorphismManager.ts
  var _GlassmorphismManager, GlassmorphismManager;
  var init_GlassmorphismManager = __esm({
    "src-js/ui/managers/GlassmorphismManager.ts"() {
      "use strict";
      init_globalConfig();
      init_settingKeys();
      init_ViewportAwareSystem();
      init_Year3000Utilities();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      init_UnifiedEventBus();
      _GlassmorphismManager = class _GlassmorphismManager extends ViewportAwareSystem {
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, cssBatcher = null, performanceAnalyzer = null, settingsManager, viewportOptions = {}) {
          super({
            visibilityThreshold: 0.2,
            // More generous threshold since glass effects are subtle
            pauseAnimationsWhenHidden: false,
            // Glass effects are mostly static
            pauseSettingsUpdatesWhenHidden: true,
            // Skip expensive glass calculations when hidden
            resumeDelay: 50,
            // Quick resume for UI effects
            ...viewportOptions
          });
          this.cssBatcher = null;
          this.performanceAnalyzer = null;
          this.observers = [];
          // Year 3000 consciousness integration
          this.musicSyncService = null;
          // Quality scaling state
          this.currentQualityLevel = null;
          this.qualityCapabilities = [];
          // Cross-system consciousness coordination
          this.consciousnessCoordinationCallbacks = /* @__PURE__ */ new Set();
          this.config = config;
          this.utils = utils;
          this.cssBatcher = cssBatcher;
          this.performanceAnalyzer = performanceAnalyzer;
          this.settingsManager = settingsManager;
          this.isSupported = this.detectBackdropFilterSupport();
          this.currentIntensity = "balanced";
          this.emotionalMapper = new EmotionalTemperatureMapper(true);
          this.oklabProcessor = new OKLABColorProcessor(true);
          this.cinematicPreset = OKLABColorProcessor.getPreset("STANDARD");
          this.consciousnessState = {
            currentEmotion: "neutral",
            emotionalIntensity: 0.5,
            beatPhase: 0,
            lastBeatTime: 0,
            cinematicDramaLevel: 0,
            dynamicAccentHex: "#cba6f7",
            // Catppuccin mauve fallback
            dynamicAccentRgb: "203,166,247",
            consciousnessLevel: 0.5,
            genreStyle: "organic",
            breathingRate: 1
          };
        }
        static getInstance() {
          if (!_GlassmorphismManager.instance) {
            throw new Error("GlassmorphismManager instance not initialized");
          }
          return _GlassmorphismManager.instance;
        }
        // Implement abstract methods from ViewportAwareSystem
        async initializeSystem() {
          const initialIntensity = this.settingsManager.get("sn-glassmorphism-level");
          this.applyGlassmorphismSettings(initialIntensity);
          await this.initializeConsciousnessIntegration();
        }
        async performHealthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "GlassmorphismManager is operational.",
            issues: [],
            system: "GlassmorphismManager"
          };
        }
        performAnimationUpdate(deltaTime) {
        }
        performDestroy() {
          this.observers.forEach((observer) => observer.disconnect());
          this.observers = [];
        }
        performSettingsUpdate(event) {
          const customEvent = event;
          const { key, value } = customEvent.detail || {};
          if (key === GLASS_LEVEL_KEY || key === GLASS_LEVEL_OLD_KEY) {
            this.applyGlassmorphismSettings(value);
          }
        }
        // Override viewport awareness hooks for glassmorphism-specific behavior
        onBecomingVisible() {
          if (this.currentIntensity !== "disabled") {
            const root = document.documentElement;
            const computedStyle = getComputedStyle(root);
            const accentRgb = computedStyle.getPropertyValue("--spice-rgb-accent").trim();
            if (accentRgb && accentRgb !== "") {
              this.updateGlassColors(`rgb(${accentRgb})`, `rgb(${accentRgb})`);
            }
          }
        }
        onBecomingHidden() {
        }
        // Settings change handling is now managed by ViewportAwareSystem base class
        detectBackdropFilterSupport() {
          try {
            return CSS.supports("backdrop-filter", "blur(1px)") || CSS.supports("-webkit-backdrop-filter", "blur(1px)");
          } catch (error) {
            console.warn(
              "StarryNight: CSS.supports not available, assuming no backdrop-filter support",
              error
            );
            return false;
          }
        }
        applyGlassmorphismSettings(intensity) {
          const body = document.body;
          body.classList.remove(
            "sn-glass-disabled",
            "sn-glass-minimal",
            "sn-glass-balanced",
            "sn-glass-intense"
          );
          body.classList.add(`sn-glass-${intensity}`);
          this.currentIntensity = intensity;
          this.updateGlassVariables(intensity);
        }
        updateGlassVariables(intensity) {
          const root = document.documentElement;
          const shouldReduceQuality = this.performanceAnalyzer?.shouldReduceQuality() || false;
          let blurValue, opacityValue, saturationValue;
          switch (intensity) {
            case "disabled":
              root.style.removeProperty("--glass-blur");
              root.style.removeProperty("--glass-opacity");
              root.style.removeProperty("--glass-saturation");
              return;
            case "minimal":
              blurValue = shouldReduceQuality ? "2px" : "3px";
              opacityValue = "0.05";
              saturationValue = "1.05";
              break;
            case "intense":
              blurValue = shouldReduceQuality ? "6px" : "8px";
              opacityValue = "0.15";
              saturationValue = "1.4";
              break;
            case "balanced":
            default:
              blurValue = shouldReduceQuality ? "4px" : "6px";
              opacityValue = "0.1";
              saturationValue = "1.2";
              break;
          }
          const consciousnessModulations = this.calculateConsciousnessModulations();
          const finalBlur = this.modulateBlurValue(blurValue, consciousnessModulations);
          const finalOpacity = this.modulateOpacityValue(opacityValue, consciousnessModulations);
          const finalSaturation = this.modulateSaturationValue(saturationValue, consciousnessModulations);
          root.style.setProperty("--glass-blur", finalBlur);
          root.style.setProperty("--glass-opacity", finalOpacity);
          root.style.setProperty("--glass-saturation", finalSaturation);
          root.style.setProperty("--glass-breathing-rate", `${this.consciousnessState.breathingRate}s`);
          root.style.setProperty("--glass-consciousness-level", this.consciousnessState.consciousnessLevel.toString());
        }
        updateGlassColors(primaryColor, secondaryColor) {
          if (this.currentIntensity === "disabled") return;
          const root = document.documentElement;
          const glassPrimary = this.convertToGlassColor(primaryColor, 0.1);
          const glassSecondary = this.convertToGlassColor(secondaryColor, 0.08);
          root.style.setProperty("--glass-background", glassPrimary);
          root.style.setProperty("--glass-border", glassSecondary);
        }
        convertToGlassColor(color2, opacity) {
          try {
            if (typeof color2 !== "string") {
              return this.getThemeAwareFallback(opacity);
            }
            if (color2.startsWith("rgb")) {
              const values = color2.match(/\d+/g);
              if (values && values.length >= 3) {
                return `rgba(${values[0]}, ${values[1]}, ${values[2]}, ${opacity})`;
              }
            }
            if (color2.startsWith("#")) {
              const hex = color2.slice(1);
              const r = parseInt(hex.substring(0, 2), 16);
              const g2 = parseInt(hex.substring(2, 4), 16);
              const b = parseInt(hex.substring(4, 6), 16);
              if (!isNaN(r) && !isNaN(g2) && !isNaN(b)) {
                return `rgba(${r}, ${g2}, ${b}, ${opacity})`;
              }
            }
            return this.getThemeAwareFallback(opacity);
          } catch (error) {
            return this.getThemeAwareFallback(opacity);
          }
        }
        /**
         * Get theme-aware fallback color using Year 3000 dynamic accent cascade
         * Falls back through: --sn-dynamic-accent-rgb → --sn-color-accent-rgb → --spice-rgb-accent → Catppuccin mauve
         */
        getThemeAwareFallback(opacity) {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          if (this.consciousnessState.dynamicAccentRgb && this.consciousnessState.dynamicAccentRgb !== "203,166,247") {
            return `rgba(${this.consciousnessState.dynamicAccentRgb}, ${opacity})`;
          }
          const dynamicAccentRgb = computedStyle.getPropertyValue("--sn-dynamic-accent-rgb").trim() || computedStyle.getPropertyValue("--sn-color-accent-rgb").trim() || computedStyle.getPropertyValue("--spice-rgb-accent").trim();
          if (dynamicAccentRgb && dynamicAccentRgb !== "" && !dynamicAccentRgb.includes("undefined")) {
            return `rgba(${dynamicAccentRgb}, ${opacity})`;
          }
          const textRgb = computedStyle.getPropertyValue("--spice-rgb-text").trim();
          if (textRgb && textRgb !== "" && !textRgb.includes("undefined")) {
            return `rgba(${textRgb}, ${opacity})`;
          }
          return `rgba(203, 166, 247, ${opacity})`;
        }
        // ===================================================================
        // Year 3000 Consciousness Integration Methods
        // ===================================================================
        /**
         * Initialize consciousness integration with music sync and emotional systems
         */
        async initializeConsciousnessIntegration() {
          try {
            unifiedEventBus.subscribe("colors:extracted", (event) => {
              this.onColorsExtracted(event);
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("colors:harmonized", (event) => {
              this.onColorsHarmonized(event);
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("music:beat", (event) => {
              this.onMusicBeat(event);
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("consciousness:dramatic-moment", (event) => {
              this.onCinematicDramaEvent(event);
            }, "GlassmorphismManager");
            this.updateDynamicAccentColor();
            this.initializeCrossSystemCoordination();
            console.log("[GlassmorphismManager] \u2705 Year 3000 consciousness integration initialized");
          } catch (error) {
            console.error("[GlassmorphismManager] Failed to initialize consciousness integration:", error);
          }
        }
        /**
         * Calculate consciousness modulations for glass properties
         */
        calculateConsciousnessModulations() {
          const { emotionalIntensity, beatPhase, cinematicDramaLevel, consciousnessLevel } = this.consciousnessState;
          const emotionalModulation = 1 + (emotionalIntensity - 0.5) * 0.4;
          const beatModulation = 1 + Math.sin(beatPhase) * consciousnessLevel * 0.15;
          const cinematicModulation = 1 + cinematicDramaLevel * 0.3;
          const breathingModulation = 1 + Math.sin(Date.now() * this.consciousnessState.breathingRate * 1e-3) * 0.08;
          return {
            emotionalModulation,
            beatModulation,
            cinematicModulation,
            breathingModulation
          };
        }
        /**
         * Modulate blur value with consciousness awareness
         */
        modulateBlurValue(baseBlur, modulations) {
          const blurValue = parseFloat(baseBlur.replace("px", ""));
          const { emotionalModulation, beatModulation, breathingModulation } = modulations;
          const finalBlur = blurValue * emotionalModulation * beatModulation * breathingModulation;
          return `${Math.max(1, Math.round(finalBlur))}px`;
        }
        /**
         * Modulate opacity value with consciousness awareness
         */
        modulateOpacityValue(baseOpacity, modulations) {
          const opacityValue = parseFloat(baseOpacity);
          const { emotionalModulation, cinematicModulation, breathingModulation } = modulations;
          const finalOpacity = opacityValue * (1 + (emotionalModulation - 1) * 0.5) * cinematicModulation * breathingModulation;
          return Math.max(0.01, Math.min(1, finalOpacity)).toFixed(3);
        }
        /**
         * Modulate saturation value with consciousness awareness
         */
        modulateSaturationValue(baseSaturation, modulations) {
          const saturationValue = parseFloat(baseSaturation);
          const { emotionalModulation, beatModulation, cinematicModulation } = modulations;
          const finalSaturation = saturationValue * emotionalModulation * beatModulation * cinematicModulation;
          return Math.max(1, Math.min(3, finalSaturation)).toFixed(2);
        }
        /**
         * Handle color extraction events
         */
        onColorsExtracted(event) {
          const { rawColors, musicData } = event;
          if (musicData) {
            const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
            this.updateEmotionalState(emotionalResult);
          }
        }
        /**
         * Handle color harmonization events
         */
        onColorsHarmonized(event) {
          const { processedColors, coordinationMetrics } = event;
          if (processedColors.VIBRANT) {
            const oklabResult = this.oklabProcessor.processColor(processedColors.VIBRANT, this.cinematicPreset);
            this.consciousnessState.dynamicAccentHex = oklabResult.enhancedHex;
            this.consciousnessState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            this.updateGlassColors(oklabResult.enhancedHex, oklabResult.enhancedHex);
          }
          if (coordinationMetrics?.consciousnessLevel !== void 0) {
            this.consciousnessState.consciousnessLevel = coordinationMetrics.consciousnessLevel;
          }
        }
        /**
         * Handle music beat events for rhythm-responsive glass effects
         */
        onMusicBeat(event) {
          const { beat, intensity, timestamp } = event;
          this.consciousnessState.beatPhase += Math.PI * 2 * 0.5;
          this.consciousnessState.lastBeatTime = timestamp || Date.now();
          if (intensity > 0.8 && this.currentIntensity !== "disabled") {
            this.applyBeatSyncGlassPulse(intensity);
          }
        }
        /**
         * Handle cinematic drama events for intense glass effects
         */
        onCinematicDramaEvent(event) {
          const { intensity, type } = event;
          this.consciousnessState.cinematicDramaLevel = intensity;
          if (intensity > 0.7 && this.currentIntensity !== "disabled") {
            this.applyDramaticGlassDistortion(intensity);
          }
        }
        /**
         * Update emotional state from music analysis
         */
        updateEmotionalState(emotionalResult) {
          this.consciousnessState.currentEmotion = emotionalResult.primaryEmotion;
          this.consciousnessState.emotionalIntensity = emotionalResult.intensity;
          switch (emotionalResult.primaryEmotion) {
            case "energetic":
            case "aggressive":
              this.consciousnessState.breathingRate = 1.5;
              this.cinematicPreset = OKLABColorProcessor.getPreset("COSMIC");
              break;
            case "calm":
            case "ambient":
              this.consciousnessState.breathingRate = 0.7;
              this.cinematicPreset = OKLABColorProcessor.getPreset("SUBTLE");
              break;
            default:
              this.consciousnessState.breathingRate = 1;
              this.cinematicPreset = OKLABColorProcessor.getPreset("STANDARD");
          }
        }
        /**
         * Apply beat-synchronized glass pulse effect
         */
        applyBeatSyncGlassPulse(intensity) {
          if (!this.cssBatcher) return;
          const pulseBlur = intensity * 2;
          const pulseOpacity = intensity * 0.05;
          this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-blur", `${pulseBlur}px`);
          this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-opacity", pulseOpacity.toString());
          setTimeout(() => {
            if (this.cssBatcher) {
              this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-blur", "0px");
              this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-opacity", "0");
            }
          }, 150);
        }
        /**
         * Apply dramatic glass distortion for cinematic moments
         */
        applyDramaticGlassDistortion(intensity) {
          if (!this.cssBatcher) return;
          const dramaticBlur = intensity * 4;
          const dramaticSaturation = 1 + intensity * 0.5;
          this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-blur", `${dramaticBlur}px`);
          this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-saturation", dramaticSaturation.toString());
          setTimeout(() => {
            if (this.cssBatcher) {
              this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-blur", "0px");
              this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-saturation", "1");
            }
          }, 1200);
        }
        /**
         * Update dynamic accent color from CSS variables
         */
        updateDynamicAccentColor() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const dynamicAccentHex = computedStyle.getPropertyValue("--sn-dynamic-accent-hex").trim() || computedStyle.getPropertyValue("--sn-color-accent-hex").trim() || computedStyle.getPropertyValue("--spice-accent").trim();
          const dynamicAccentRgb = computedStyle.getPropertyValue("--sn-dynamic-accent-rgb").trim() || computedStyle.getPropertyValue("--sn-color-accent-rgb").trim() || computedStyle.getPropertyValue("--spice-rgb-accent").trim();
          if (dynamicAccentHex && dynamicAccentHex !== "") {
            this.consciousnessState.dynamicAccentHex = dynamicAccentHex;
          }
          if (dynamicAccentRgb && dynamicAccentRgb !== "") {
            this.consciousnessState.dynamicAccentRgb = dynamicAccentRgb;
          }
        }
        /**
         * Get current consciousness state for debugging
         */
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        // ===================================================================
        // Quality Scaling Implementation (QualityScalingCapable)
        // ===================================================================
        /**
         * Set quality level for glass effects
         */
        setQualityLevel(level) {
          this.currentQualityLevel = level;
          let adjustedIntensity;
          switch (level.level) {
            case "minimal":
              adjustedIntensity = "minimal";
              break;
            case "low":
              adjustedIntensity = "minimal";
              break;
            case "medium":
              adjustedIntensity = "balanced";
              break;
            case "high":
              adjustedIntensity = "intense";
              break;
            case "ultra":
              adjustedIntensity = "intense";
              break;
          }
          this.applyGlassmorphismSettings(adjustedIntensity);
          console.log(`[GlassmorphismManager] Quality level set to: ${level.level} (intensity: ${adjustedIntensity})`);
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const intensityImpact = this.currentIntensity === "disabled" ? 0 : this.currentIntensity === "minimal" ? 0.1 : this.currentIntensity === "balanced" ? 0.3 : this.currentIntensity === "intense" ? 0.5 : 0.2;
          const consciousnessImpact = this.consciousnessState.consciousnessLevel * 0.1;
          const breathingImpact = this.consciousnessState.breathingRate > 1 ? 0.05 : 0;
          return {
            fps: 60,
            frameTime: intensityImpact + consciousnessImpact + breathingImpact,
            memoryUsageMB: intensityImpact * 2,
            // Minimal memory impact
            cpuUsagePercent: (intensityImpact + consciousnessImpact) * 50,
            gpuUsagePercent: intensityImpact * 20,
            // Backdrop filter GPU usage
            renderTime: intensityImpact * 1.5,
            timestamp: Date.now()
          };
        }
        /**
         * Reduce quality level
         */
        reduceQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.consciousnessState.consciousnessLevel = Math.max(0.1, this.consciousnessState.consciousnessLevel - amount);
          this.consciousnessState.breathingRate = Math.max(0.5, this.consciousnessState.breathingRate - amount * 0.5);
          if (amount > 0.5) {
            switch (this.currentIntensity) {
              case "intense":
                this.applyGlassmorphismSettings("balanced");
                break;
              case "balanced":
                this.applyGlassmorphismSettings("minimal");
                break;
              case "minimal":
                this.applyGlassmorphismSettings("disabled");
                break;
            }
          }
          console.log(`[GlassmorphismManager] Quality reduced by ${amount}`);
        }
        /**
         * Increase quality level
         */
        increaseQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.consciousnessState.consciousnessLevel = Math.min(1, this.consciousnessState.consciousnessLevel + amount);
          this.consciousnessState.breathingRate = Math.min(2, this.consciousnessState.breathingRate + amount * 0.5);
          if (amount > 0.5) {
            switch (this.currentIntensity) {
              case "disabled":
                this.applyGlassmorphismSettings("minimal");
                break;
              case "minimal":
                this.applyGlassmorphismSettings("balanced");
                break;
              case "balanced":
                this.applyGlassmorphismSettings("intense");
                break;
            }
          }
          console.log(`[GlassmorphismManager] Quality increased by ${amount}`);
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          if (this.qualityCapabilities.length === 0) {
            this.qualityCapabilities = [
              {
                name: "Backdrop Filter Blur",
                impact: "high",
                enabled: this.isSupported && this.currentIntensity !== "disabled",
                canToggle: true
              },
              {
                name: "Glass Saturation",
                impact: "low",
                enabled: this.currentIntensity !== "disabled",
                canToggle: true
              },
              {
                name: "Consciousness Breathing",
                impact: "low",
                enabled: true,
                canToggle: true
              },
              {
                name: "Beat Sync Pulse",
                impact: "low",
                enabled: true,
                canToggle: true
              },
              {
                name: "Dramatic Distortion",
                impact: "medium",
                enabled: true,
                canToggle: true
              }
            ];
          }
          return this.qualityCapabilities;
        }
        /**
         * Refresh color state for efficient color system updates
         */
        async refreshColorState(trigger) {
          try {
            this.updateDynamicAccentColor();
            if (this.consciousnessState.dynamicAccentHex) {
              const oklabResult = this.oklabProcessor.processColor(
                this.consciousnessState.dynamicAccentHex,
                this.cinematicPreset
              );
              this.consciousnessState.dynamicAccentHex = oklabResult.enhancedHex;
              this.consciousnessState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
              this.updateGlassColors(oklabResult.enhancedHex, oklabResult.enhancedHex);
            }
            console.log(`[GlassmorphismManager] Color state refreshed for trigger: ${trigger}`);
          } catch (error) {
            console.error("[GlassmorphismManager] Error refreshing color state:", error);
          }
        }
        // ===================================================================
        // Cross-System Consciousness Coordination
        // ===================================================================
        /**
         * Register for consciousness coordination updates
         */
        onConsciousnessCoordination(callback) {
          this.consciousnessCoordinationCallbacks.add(callback);
          return () => {
            this.consciousnessCoordinationCallbacks.delete(callback);
          };
        }
        /**
         * Synchronize consciousness state with other systems
         */
        synchronizeConsciousnessState(sharedState) {
          if (sharedState.currentEmotion) {
            this.consciousnessState.currentEmotion = sharedState.currentEmotion;
          }
          if (sharedState.emotionalIntensity !== void 0) {
            this.consciousnessState.emotionalIntensity = sharedState.emotionalIntensity;
          }
          if (sharedState.beatPhase !== void 0) {
            this.consciousnessState.beatPhase = sharedState.beatPhase;
          }
          if (sharedState.cinematicDramaLevel !== void 0) {
            this.consciousnessState.cinematicDramaLevel = sharedState.cinematicDramaLevel;
          }
          if (sharedState.consciousnessLevel !== void 0) {
            this.consciousnessState.consciousnessLevel = sharedState.consciousnessLevel;
          }
          if (sharedState.dynamicAccentHex) {
            this.consciousnessState.dynamicAccentHex = sharedState.dynamicAccentHex;
          }
          if (sharedState.dynamicAccentRgb) {
            this.consciousnessState.dynamicAccentRgb = sharedState.dynamicAccentRgb;
          }
          if (sharedState.genreStyle) {
            this.consciousnessState.genreStyle = sharedState.genreStyle;
          }
          if (sharedState.breathingRate !== void 0) {
            this.consciousnessState.breathingRate = sharedState.breathingRate;
          }
          this.updateGlassVariables(this.currentIntensity);
          this.broadcastConsciousnessState();
        }
        /**
         * Broadcast consciousness state to coordinated systems
         */
        broadcastConsciousnessState() {
          this.consciousnessCoordinationCallbacks.forEach((callback) => {
            try {
              callback(this.consciousnessState);
            } catch (error) {
              console.error("[GlassmorphismManager] Error in consciousness coordination callback:", error);
            }
          });
        }
        /**
         * Enhanced emotional state update with coordination
         */
        updateEmotionalStateWithCoordination(emotionalResult) {
          this.updateEmotionalState(emotionalResult);
          this.broadcastConsciousnessState();
          unifiedEventBus.emit("consciousness:coordination", {
            source: "GlassmorphismManager",
            state: this.consciousnessState,
            timestamp: Date.now()
          });
        }
        /**
         * Enhanced beat event with coordination
         */
        onMusicBeatWithCoordination(event) {
          this.onMusicBeat(event);
          this.broadcastConsciousnessState();
          unifiedEventBus.subscribe("consciousness:beat-sync", (syncEvent) => {
            if (syncEvent.source !== "GlassmorphismManager") {
              this.consciousnessState.beatPhase = syncEvent.beatPhase;
              this.consciousnessState.lastBeatTime = syncEvent.lastBeatTime;
            }
          }, "GlassmorphismManager");
        }
        /**
         * Enhanced dramatic event with coordination
         */
        onCinematicDramaEventWithCoordination(event) {
          this.onCinematicDramaEvent(event);
          this.broadcastConsciousnessState();
          unifiedEventBus.subscribe("consciousness:dramatic-sync", (syncEvent) => {
            if (syncEvent.source !== "GlassmorphismManager") {
              this.consciousnessState.cinematicDramaLevel = syncEvent.dramaticLevel;
              if (syncEvent.dramaticLevel > 0.7) {
                this.applyDramaticGlassDistortion(syncEvent.dramaticLevel);
              }
            }
          }, "GlassmorphismManager");
        }
        /**
         * Initialize cross-system consciousness coordination
         */
        initializeCrossSystemCoordination() {
          try {
            unifiedEventBus.subscribe("consciousness:coordination", (event) => {
              if (event.source !== "GlassmorphismManager") {
                this.synchronizeConsciousnessState(event.state);
              }
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("consciousness:beat-sync", (event) => {
              if (event.source !== "GlassmorphismManager") {
                this.consciousnessState.beatPhase = event.beatPhase;
                this.consciousnessState.lastBeatTime = event.lastBeatTime;
                this.applyCoordinatedBeatPulse(event.beatPhase);
              }
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("consciousness:dramatic-sync", (event) => {
              if (event.source !== "GlassmorphismManager") {
                this.consciousnessState.cinematicDramaLevel = event.dramaticLevel;
                this.applyCoordinatedDramaticEffects(event.dramaticLevel, event.type || "unknown");
              }
            }, "GlassmorphismManager");
            console.log("[GlassmorphismManager] \u2705 Cross-system consciousness coordination initialized");
          } catch (error) {
            console.error("[GlassmorphismManager] Failed to initialize cross-system coordination:", error);
          }
        }
        checkPerformanceAndAdjust() {
          if (this.performanceAnalyzer?.shouldReduceQuality() || false) {
            if (this.currentIntensity === "intense") {
              this.applyGlassmorphismSettings("balanced");
            } else if (this.currentIntensity === "balanced" || this.currentIntensity === "moderate") {
              this.applyGlassmorphismSettings("minimal");
            }
          }
        }
        applyGlassmorphism(level) {
          const glassConfig = this.config.glassmorphism[level];
          if (!this.cssBatcher) return;
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-display",
            level === "disabled" ? "none" : "block"
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-blur",
            `${glassConfig.blur}px`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-saturation",
            `${glassConfig.saturation}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-brightness",
            `${glassConfig.brightness}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-noise-opacity",
            `${glassConfig.noiseOpacity}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-border-opacity",
            `${glassConfig.borderOpacity}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-shadow-opacity",
            `${glassConfig.shadowOpacity}`
          );
          this.cssBatcher.flushCSSVariableBatch();
          if (this.config.enableDebug) {
            console.log(`\u{1F48E} [GlassmorphismManager] Applied level: ${level}`);
          }
        }
        // --------------------------------------------------------------------
        // Year3000System central settings broadcast hook
        // --------------------------------------------------------------------
        applyUpdatedSettings(key, value) {
          if (key === "sn-glassmorphism-level") {
            this.applyGlassmorphismSettings(value);
          }
        }
        // ===================================================================
        // Cross-System Consciousness Coordination Methods
        // ===================================================================
        /**
         * Apply coordinated beat pulse to glass effects
         */
        applyCoordinatedBeatPulse(beatPhase) {
          const modulations = this.calculateConsciousnessModulations();
          const baseIntensity = this.getIntensityValue(this.currentIntensity);
          const beatPulse = 1 + Math.sin(beatPhase) * 0.15 * modulations.beatModulation;
          const pulseOpacity = baseIntensity.opacity * beatPulse;
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-opacity", pulseOpacity.toString());
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-accent-opacity", (pulseOpacity * 0.8).toString());
          this.cssBatcher?.flushCSSVariableBatch();
        }
        /**
         * Apply coordinated dramatic effects to glass systems
         */
        applyCoordinatedDramaticEffects(dramaticLevel, type) {
          const modulations = this.calculateConsciousnessModulations();
          const baseIntensity = this.getIntensityValue(this.currentIntensity);
          const dramaticMultiplier = 1 + dramaticLevel * 0.4;
          const dramaticOpacity = Math.min(1, baseIntensity.opacity * dramaticMultiplier);
          const dramaticBlur = Math.min(20, baseIntensity.blur * (1 + dramaticLevel * 0.3));
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-opacity", dramaticOpacity.toString());
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-blur", `${dramaticBlur}px`);
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-accent-opacity", (dramaticOpacity * 0.9).toString());
          this.cssBatcher?.flushCSSVariableBatch();
          setTimeout(() => {
            this.updateGlassVariables(this.currentIntensity);
          }, 1500);
        }
        /**
         * Get intensity values for glass effects
         */
        getIntensityValue(intensity) {
          switch (intensity) {
            case "disabled":
              return { opacity: 0, blur: 0, saturation: 1 };
            case "minimal":
              return { opacity: 0.05, blur: 3, saturation: 1.05 };
            case "balanced":
              return { opacity: 0.1, blur: 6, saturation: 1.2 };
            case "intense":
              return { opacity: 0.15, blur: 8, saturation: 1.4 };
            case "moderate":
              return { opacity: 0.08, blur: 5, saturation: 1.15 };
            default:
              return { opacity: 0.1, blur: 6, saturation: 1.2 };
          }
        }
      };
      __name(_GlassmorphismManager, "GlassmorphismManager");
      GlassmorphismManager = _GlassmorphismManager;
    }
  });

  // src-js/ui/managers/Card3DManager.ts
  var _Card3DManager, Card3DManager;
  var init_Card3DManager = __esm({
    "src-js/ui/managers/Card3DManager.ts"() {
      "use strict";
      init_settingKeys();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      init_UnifiedEventBus();
      _Card3DManager = class _Card3DManager {
        constructor(performanceMonitor, settingsManager, utils) {
          this.initialized = false;
          this.cardQuerySelector = ".main-card-card, .main-gridContainer-gridContainer.main-gridContainer-fixedWidth";
          this.cardEventHandlers = /* @__PURE__ */ new WeakMap();
          // Year 3000 consciousness integration
          this.musicSyncService = null;
          // Quality scaling state
          this.currentQualityLevel = null;
          this.qualityCapabilities = [];
          // Cross-system consciousness coordination
          this.consciousnessCoordinationCallbacks = /* @__PURE__ */ new Set();
          this.config = {
            perspective: 1e3,
            maxRotation: 5,
            scale: 1.02,
            transitionSpeed: "200ms",
            glowOpacity: 0.8,
            selector: ".main-card-card, .main-grid-grid > *, .main-shelf-shelf > * > *",
            // Year 3000 consciousness enhancements
            consciousnessDepthMultiplier: 1.5,
            emotionalResponseStrength: 0.8,
            beatSyncIntensity: 0.6,
            cinematicDramaMultiplier: 1.2
          };
          this.performanceMonitor = performanceMonitor;
          this.settingsManager = settingsManager;
          this.utils = utils;
          this.cards = document.querySelectorAll(this.config.selector);
          this.emotionalMapper = new EmotionalTemperatureMapper(true);
          this.oklabProcessor = new OKLABColorProcessor(true);
          this.cinematicPreset = OKLABColorProcessor.getPreset("VIBRANT");
          this.consciousnessState = {
            currentEmotion: "neutral",
            emotionalIntensity: 0.5,
            beatPhase: 0,
            lastBeatTime: 0,
            cinematicDramaLevel: 0,
            dynamicAccentHex: "#cba6f7",
            // Catppuccin mauve fallback
            dynamicAccentRgb: "203,166,247",
            consciousnessLevel: 0.5
          };
          this.boundHandleSettingsChange = this.handleSettingsChange.bind(this);
        }
        static getInstance(performanceMonitor, settingsManager, utils) {
          if (!_Card3DManager.instance) {
            _Card3DManager.instance = new _Card3DManager(
              performanceMonitor,
              settingsManager,
              utils
            );
          }
          return _Card3DManager.instance;
        }
        async initialize() {
          if (this.initialized) return;
          const quality = this.performanceMonitor.shouldReduceQuality();
          if (quality) {
            if (this.settingsManager.get("sn-3d-effects-level") !== "disabled") {
              console.log(
                `[Card3DManager] Performance is low. 3D effects disabled. Current quality: ${quality}`
              );
              return;
            }
          }
          this.cards = document.querySelectorAll(this.config.selector);
          await this.applyEventListeners();
          await this.initializeConsciousnessIntegration();
          this.initializeCrossSystemCoordination();
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this.boundHandleSettingsChange
          );
          this.initialized = true;
        }
        async healthCheck() {
          const elements = document.querySelectorAll(this.cardQuerySelector);
          if (elements.length > 0) {
            return {
              healthy: true,
              ok: true,
              details: `Found ${elements.length} cards to manage.`,
              issues: [],
              system: "Card3DManager"
            };
          }
          return {
            healthy: false,
            ok: false,
            details: "No card elements found with the configured selector.",
            issues: ["No card elements found with the configured selector."],
            system: "Card3DManager"
          };
        }
        updateAnimation(deltaTime) {
        }
        apply3DMode(mode) {
          console.log(`[Card3DManager] Applying 3D mode: ${mode}`);
          if (mode === "disabled") {
            this.destroy();
          } else {
            this.initialize();
          }
        }
        get shouldEnable3DEffects() {
          const quality = this.performanceMonitor.shouldReduceQuality();
          const setting = this.settingsManager.get("sn-enable3dCards");
          return !quality && setting !== "disabled";
        }
        async applyEventListeners() {
          this.cards.forEach((card) => {
            if (this.cardEventHandlers.has(card)) return;
            const moveHandler = /* @__PURE__ */ __name((e) => this.handleMouseMove(card, e), "moveHandler");
            const leaveHandler = /* @__PURE__ */ __name(() => this.handleMouseLeave(card), "leaveHandler");
            this.cardEventHandlers.set(card, {
              move: moveHandler,
              leave: leaveHandler
            });
            card.addEventListener("mousemove", moveHandler);
            card.addEventListener("mouseleave", leaveHandler);
          });
        }
        handleMouseMove(card, e) {
          if (!this.shouldEnable3DEffects) return;
          const { clientX, clientY } = e;
          const { top, left, width, height } = card.getBoundingClientRect();
          const x = clientX - left;
          const y = clientY - top;
          const rotateX = this.config.maxRotation * (y - height / 2) / (height / 2);
          const rotateY = -this.config.maxRotation * (x - width / 2) / (width / 2);
          card.style.transform = `perspective(${this.config.perspective}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale3d(${this.config.scale}, ${this.config.scale}, ${this.config.scale})`;
          card.style.transition = `transform ${this.config.transitionSpeed} ease-out`;
          this.applyGlow(card, x, y, width, height);
        }
        handleMouseLeave(card) {
          card.style.transform = "perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)";
          card.style.transition = "transform 600ms ease-in-out";
          this.removeGlow(card);
        }
        applyGlow(card, x, y, width, height) {
          let glowElement = card.querySelector(".card-glow");
          if (!glowElement) {
            glowElement = document.createElement("div");
            glowElement.className = "card-glow";
            card.appendChild(glowElement);
          }
          const { dynamicAccentRgb, emotionalIntensity, beatPhase, cinematicDramaLevel } = this.consciousnessState;
          const baseOpacity = this.config.glowOpacity;
          const emotionalModulation = 1 + (emotionalIntensity - 0.5) * this.config.emotionalResponseStrength;
          const beatModulation = 1 + Math.sin(beatPhase) * this.config.beatSyncIntensity * 0.3;
          const cinematicModulation = 1 + cinematicDramaLevel * this.config.cinematicDramaMultiplier * 0.4;
          const consciousnessOpacity = baseOpacity * emotionalModulation * beatModulation * cinematicModulation;
          const finalOpacity = Math.max(0.1, Math.min(1, consciousnessOpacity));
          const baseRadius = 40;
          const breathingRadius = baseRadius + Math.sin(beatPhase * 0.5) * 8 * this.config.beatSyncIntensity;
          glowElement.style.background = `radial-gradient(circle at ${x}px ${y}px, 
      rgba(${dynamicAccentRgb}, ${finalOpacity}) 0%, 
      rgba(${dynamicAccentRgb}, ${finalOpacity * 0.6}) 20%, 
      transparent ${breathingRadius}%)`;
        }
        removeGlow(card) {
          const glowElement = card.querySelector(".card-glow");
          if (glowElement) {
            glowElement.style.background = "transparent";
          }
        }
        destroy() {
          this.cards.forEach((card) => {
            const handlers = this.cardEventHandlers.get(card);
            if (handlers) {
              card.removeEventListener("mousemove", handlers.move);
              card.removeEventListener("mouseleave", handlers.leave);
              this.cardEventHandlers.delete(card);
            }
            this.removeGlow(card);
            card.style.transform = "";
            card.style.transition = "";
          });
          this.initialized = false;
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this.boundHandleSettingsChange
          );
        }
        handleSettingsChange(event) {
          const { key, value } = event.detail || {};
          if (key === CARD_3D_LEVEL_KEY) {
            this.apply3DMode(value);
          }
        }
        // ===================================================================
        // Year 3000 Consciousness Integration Methods
        // ===================================================================
        /**
         * Initialize consciousness integration with music sync and emotional systems
         */
        async initializeConsciousnessIntegration() {
          try {
            unifiedEventBus.subscribe("colors:extracted", (event) => {
              this.onColorsExtracted(event);
            }, "Card3DManager");
            unifiedEventBus.subscribe("colors:harmonized", (event) => {
              this.onColorsHarmonized(event);
            }, "Card3DManager");
            unifiedEventBus.subscribe("music:beat", (event) => {
              this.onMusicBeat(event);
            }, "Card3DManager");
            unifiedEventBus.subscribe("consciousness:dramatic-moment", (event) => {
              this.onCinematicDramaEvent(event);
            }, "Card3DManager");
            this.updateDynamicAccentColor();
            console.log("[Card3DManager] \u2705 Year 3000 consciousness integration initialized");
          } catch (error) {
            console.error("[Card3DManager] Failed to initialize consciousness integration:", error);
          }
        }
        /**
         * Handle color extraction events
         */
        onColorsExtracted(event) {
          const { rawColors, musicData } = event;
          if (musicData) {
            const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
            this.updateEmotionalState(emotionalResult);
          }
        }
        /**
         * Handle color harmonization events
         */
        onColorsHarmonized(event) {
          const { processedColors, coordinationMetrics } = event;
          if (processedColors.VIBRANT) {
            const oklabResult = this.oklabProcessor.processColor(processedColors.VIBRANT, this.cinematicPreset);
            this.consciousnessState.dynamicAccentHex = oklabResult.enhancedHex;
            this.consciousnessState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
          }
          if (coordinationMetrics?.consciousnessLevel !== void 0) {
            this.consciousnessState.consciousnessLevel = coordinationMetrics.consciousnessLevel;
          }
        }
        /**
         * Handle music beat events for rhythm-responsive 3D effects
         */
        onMusicBeat(event) {
          const { beat, intensity, timestamp } = event;
          this.consciousnessState.beatPhase += Math.PI * 2 * this.config.beatSyncIntensity;
          this.consciousnessState.lastBeatTime = timestamp || Date.now();
          if (intensity > 0.7) {
            this.applyBeatSyncDepthPulse(intensity);
          }
        }
        /**
         * Handle cinematic drama events for intense 3D effects
         */
        onCinematicDramaEvent(event) {
          const { intensity, type } = event;
          this.consciousnessState.cinematicDramaLevel = intensity;
          if (intensity > 0.8) {
            this.applyDramaticDepthDistortion(intensity);
          }
        }
        /**
         * Update emotional state from music analysis
         */
        updateEmotionalState(emotionalResult) {
          this.consciousnessState.currentEmotion = emotionalResult.primaryEmotion;
          this.consciousnessState.emotionalIntensity = emotionalResult.intensity;
          switch (emotionalResult.primaryEmotion) {
            case "energetic":
            case "aggressive":
              this.cinematicPreset = OKLABColorProcessor.getPreset("COSMIC");
              break;
            case "calm":
            case "ambient":
              this.cinematicPreset = OKLABColorProcessor.getPreset("SUBTLE");
              break;
            default:
              this.cinematicPreset = OKLABColorProcessor.getPreset("VIBRANT");
          }
        }
        /**
         * Apply beat-synchronized depth pulse to all cards
         */
        applyBeatSyncDepthPulse(intensity) {
          const pulseScale = 1 + intensity * 0.15 * this.config.beatSyncIntensity;
          this.cards.forEach((card) => {
            if (card instanceof HTMLElement) {
              const currentTransform = card.style.transform || "";
              const scaledTransform = currentTransform.replace(/scale3d\([^)]*\)/, `scale3d(${pulseScale}, ${pulseScale}, ${pulseScale})`);
              card.style.transform = scaledTransform || `scale3d(${pulseScale}, ${pulseScale}, ${pulseScale})`;
              card.style.transition = "transform 100ms ease-out";
              setTimeout(() => {
                if (card.style.transform.includes(`scale3d(${pulseScale}`)) {
                  card.style.transform = card.style.transform.replace(/scale3d\([^)]*\)/, "scale3d(1, 1, 1)");
                }
              }, 200);
            }
          });
        }
        /**
         * Apply dramatic depth distortion for cinematic moments
         */
        applyDramaticDepthDistortion(intensity) {
          const dramaticPerspective = this.config.perspective * (1 + intensity * this.config.cinematicDramaMultiplier);
          const dramaticRotation = this.config.maxRotation * (1 + intensity * 0.8);
          this.cards.forEach((card) => {
            if (card instanceof HTMLElement) {
              const dramaticTransform = `perspective(${dramaticPerspective}px) rotateX(${dramaticRotation * 0.3}deg) rotateY(${dramaticRotation * 0.2}deg)`;
              card.style.transform = dramaticTransform;
              card.style.transition = "transform 800ms ease-out";
              setTimeout(() => {
                card.style.transform = "perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)";
                card.style.transition = "transform 1200ms ease-in-out";
              }, 1500);
            }
          });
        }
        /**
         * Update dynamic accent color from CSS variables
         */
        updateDynamicAccentColor() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const dynamicAccentHex = computedStyle.getPropertyValue("--sn-dynamic-accent-hex").trim() || computedStyle.getPropertyValue("--sn-color-accent-hex").trim() || computedStyle.getPropertyValue("--spice-accent").trim();
          const dynamicAccentRgb = computedStyle.getPropertyValue("--sn-dynamic-accent-rgb").trim() || computedStyle.getPropertyValue("--sn-color-accent-rgb").trim() || computedStyle.getPropertyValue("--spice-rgb-accent").trim();
          if (dynamicAccentHex && dynamicAccentHex !== "") {
            this.consciousnessState.dynamicAccentHex = dynamicAccentHex;
          }
          if (dynamicAccentRgb && dynamicAccentRgb !== "") {
            this.consciousnessState.dynamicAccentRgb = dynamicAccentRgb;
          }
        }
        /**
         * Set music sync service for consciousness integration
         */
        setMusicSyncService(musicSyncService) {
          this.musicSyncService = musicSyncService;
        }
        /**
         * Get current consciousness state for debugging
         */
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        // ===================================================================
        // Quality Scaling Implementation (QualityScalingCapable)
        // ===================================================================
        /**
         * Set quality level for 3D effects
         */
        setQualityLevel(level) {
          this.currentQualityLevel = level;
          switch (level.level) {
            case "minimal":
              this.config.perspective = 800;
              this.config.maxRotation = 2;
              this.config.consciousnessDepthMultiplier = 1;
              this.config.emotionalResponseStrength = 0.3;
              this.config.beatSyncIntensity = 0.2;
              this.config.cinematicDramaMultiplier = 0.5;
              break;
            case "low":
              this.config.perspective = 900;
              this.config.maxRotation = 3;
              this.config.consciousnessDepthMultiplier = 1.2;
              this.config.emotionalResponseStrength = 0.5;
              this.config.beatSyncIntensity = 0.4;
              this.config.cinematicDramaMultiplier = 0.8;
              break;
            case "medium":
              this.config.perspective = 1e3;
              this.config.maxRotation = 5;
              this.config.consciousnessDepthMultiplier = 1.5;
              this.config.emotionalResponseStrength = 0.8;
              this.config.beatSyncIntensity = 0.6;
              this.config.cinematicDramaMultiplier = 1.2;
              break;
            case "high":
              this.config.perspective = 1200;
              this.config.maxRotation = 7;
              this.config.consciousnessDepthMultiplier = 1.8;
              this.config.emotionalResponseStrength = 1;
              this.config.beatSyncIntensity = 0.8;
              this.config.cinematicDramaMultiplier = 1.5;
              break;
            case "ultra":
              this.config.perspective = 1500;
              this.config.maxRotation = 10;
              this.config.consciousnessDepthMultiplier = 2;
              this.config.emotionalResponseStrength = 1.2;
              this.config.beatSyncIntensity = 1;
              this.config.cinematicDramaMultiplier = 2;
              break;
          }
          console.log(`[Card3DManager] Quality level set to: ${level.level}`);
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const cardCount = this.cards.length;
          const baseImpact = cardCount * 0.1;
          const consciousnessImpact = this.config.consciousnessDepthMultiplier * 0.2;
          const emotionalImpact = this.config.emotionalResponseStrength * 0.15;
          const cinematicImpact = this.config.cinematicDramaMultiplier * 0.1;
          return {
            fps: 60,
            frameTime: baseImpact + consciousnessImpact + emotionalImpact + cinematicImpact,
            memoryUsageMB: cardCount * 0.05,
            // Minimal memory impact
            cpuUsagePercent: (baseImpact + consciousnessImpact) * 100,
            gpuUsagePercent: 5,
            // Minimal GPU usage for 3D transforms
            renderTime: baseImpact * 2,
            timestamp: Date.now()
          };
        }
        /**
         * Reduce quality level
         */
        reduceQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.config.consciousnessDepthMultiplier = Math.max(0.5, this.config.consciousnessDepthMultiplier - amount);
          this.config.emotionalResponseStrength = Math.max(0.1, this.config.emotionalResponseStrength - amount);
          this.config.beatSyncIntensity = Math.max(0.1, this.config.beatSyncIntensity - amount);
          this.config.cinematicDramaMultiplier = Math.max(0.5, this.config.cinematicDramaMultiplier - amount);
          console.log(`[Card3DManager] Quality reduced by ${amount}`);
        }
        /**
         * Increase quality level
         */
        increaseQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.config.consciousnessDepthMultiplier = Math.min(2, this.config.consciousnessDepthMultiplier + amount);
          this.config.emotionalResponseStrength = Math.min(1.5, this.config.emotionalResponseStrength + amount);
          this.config.beatSyncIntensity = Math.min(1, this.config.beatSyncIntensity + amount);
          this.config.cinematicDramaMultiplier = Math.min(2, this.config.cinematicDramaMultiplier + amount);
          console.log(`[Card3DManager] Quality increased by ${amount}`);
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          if (this.qualityCapabilities.length === 0) {
            this.qualityCapabilities = [
              {
                name: "3D Perspective",
                impact: "medium",
                enabled: true,
                canToggle: true
              },
              {
                name: "Consciousness Glow",
                impact: "low",
                enabled: true,
                canToggle: true
              },
              {
                name: "Beat Sync Effects",
                impact: "low",
                enabled: true,
                canToggle: true
              },
              {
                name: "Dramatic Distortion",
                impact: "medium",
                enabled: true,
                canToggle: true
              },
              {
                name: "Emotional Modulation",
                impact: "low",
                enabled: true,
                canToggle: true
              }
            ];
          }
          return this.qualityCapabilities;
        }
        /**
         * Refresh color state for efficient color system updates
         */
        async refreshColorState(trigger) {
          try {
            this.updateDynamicAccentColor();
            if (this.consciousnessState.dynamicAccentHex) {
              const oklabResult = this.oklabProcessor.processColor(
                this.consciousnessState.dynamicAccentHex,
                this.cinematicPreset
              );
              this.consciousnessState.dynamicAccentHex = oklabResult.enhancedHex;
              this.consciousnessState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            }
            console.log(`[Card3DManager] Color state refreshed for trigger: ${trigger}`);
          } catch (error) {
            console.error("[Card3DManager] Error refreshing color state:", error);
          }
        }
        // ===================================================================
        // Cross-System Consciousness Coordination
        // ===================================================================
        /**
         * Register for consciousness coordination updates
         */
        onConsciousnessCoordination(callback) {
          this.consciousnessCoordinationCallbacks.add(callback);
          return () => {
            this.consciousnessCoordinationCallbacks.delete(callback);
          };
        }
        /**
         * Synchronize consciousness state with other systems
         */
        synchronizeConsciousnessState(sharedState) {
          if (sharedState.currentEmotion) {
            this.consciousnessState.currentEmotion = sharedState.currentEmotion;
          }
          if (sharedState.emotionalIntensity !== void 0) {
            this.consciousnessState.emotionalIntensity = sharedState.emotionalIntensity;
          }
          if (sharedState.beatPhase !== void 0) {
            this.consciousnessState.beatPhase = sharedState.beatPhase;
          }
          if (sharedState.cinematicDramaLevel !== void 0) {
            this.consciousnessState.cinematicDramaLevel = sharedState.cinematicDramaLevel;
          }
          if (sharedState.consciousnessLevel !== void 0) {
            this.consciousnessState.consciousnessLevel = sharedState.consciousnessLevel;
          }
          if (sharedState.dynamicAccentHex) {
            this.consciousnessState.dynamicAccentHex = sharedState.dynamicAccentHex;
          }
          if (sharedState.dynamicAccentRgb) {
            this.consciousnessState.dynamicAccentRgb = sharedState.dynamicAccentRgb;
          }
          this.broadcastConsciousnessState();
        }
        /**
         * Broadcast consciousness state to coordinated systems
         */
        broadcastConsciousnessState() {
          this.consciousnessCoordinationCallbacks.forEach((callback) => {
            try {
              callback(this.consciousnessState);
            } catch (error) {
              console.error("[Card3DManager] Error in consciousness coordination callback:", error);
            }
          });
        }
        /**
         * Enhanced emotional state update with coordination
         */
        updateEmotionalStateWithCoordination(emotionalResult) {
          this.updateEmotionalState(emotionalResult);
          this.broadcastConsciousnessState();
          unifiedEventBus.emit("consciousness:coordination", {
            source: "Card3DManager",
            state: this.consciousnessState,
            timestamp: Date.now()
          });
        }
        /**
         * Enhanced beat event with coordination
         */
        onMusicBeatWithCoordination(event) {
          this.onMusicBeat(event);
          this.broadcastConsciousnessState();
          unifiedEventBus.emit("consciousness:beat-sync", {
            source: "Card3DManager",
            beatPhase: this.consciousnessState.beatPhase,
            lastBeatTime: this.consciousnessState.lastBeatTime,
            timestamp: Date.now()
          });
        }
        /**
         * Enhanced dramatic event with coordination
         */
        onCinematicDramaEventWithCoordination(event) {
          this.onCinematicDramaEvent(event);
          this.broadcastConsciousnessState();
          unifiedEventBus.emit("consciousness:dramatic-sync", {
            source: "Card3DManager",
            dramaticLevel: this.consciousnessState.cinematicDramaLevel,
            type: event.type,
            timestamp: Date.now()
          });
        }
        /**
         * Initialize cross-system consciousness coordination
         */
        initializeCrossSystemCoordination() {
          try {
            unifiedEventBus.subscribe("consciousness:coordination", (event) => {
              if (event.source !== "Card3DManager") {
                this.synchronizeConsciousnessState(event.state);
              }
            }, "Card3DManager");
            unifiedEventBus.subscribe("consciousness:beat-sync", (event) => {
              if (event.source !== "Card3DManager") {
                this.consciousnessState.beatPhase = event.beatPhase;
                this.consciousnessState.lastBeatTime = event.lastBeatTime;
              }
            }, "Card3DManager");
            unifiedEventBus.subscribe("consciousness:dramatic-sync", (event) => {
              if (event.source !== "Card3DManager") {
                this.consciousnessState.cinematicDramaLevel = event.dramaticLevel;
              }
            }, "Card3DManager");
            console.log("[Card3DManager] \u2705 Cross-system consciousness coordination initialized");
          } catch (error) {
            console.error("[Card3DManager] Failed to initialize cross-system coordination:", error);
          }
        }
      };
      __name(_Card3DManager, "Card3DManager");
      Card3DManager = _Card3DManager;
    }
  });

  // src-js/core/base/UnifiedSystemBase.ts
  var _UnifiedSystemBase, UnifiedSystemBase;
  var init_UnifiedSystemBase = __esm({
    "src-js/core/base/UnifiedSystemBase.ts"() {
      "use strict";
      init_PerformanceAnalyzer();
      init_UnifiedCSSConsciousnessController();
      init_UnifiedEventBus();
      init_EnhancedMasterAnimationCoordinator();
      init_UnifiedPerformanceCoordinator();
      init_globalConfig();
      _UnifiedSystemBase = class _UnifiedSystemBase {
        constructor(config = YEAR3000_CONFIG) {
          // Core lifecycle state
          this.initialized = false;
          this.destroyed = false;
          // Event management
          this.eventUnsubscribers = [];
          // Performance tracking
          this.initializationStartTime = null;
          this.frameStartTime = 0;
          this.frameCount = 0;
          this.lastFPSCalculation = 0;
          this.currentFPS = 60;
          this.config = config;
          this.systemName = this.constructor.name;
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] UnifiedSystemBase constructor`);
          }
        }
        // =========================================================================
        // UNIFIED LIFECYCLE MANAGEMENT
        // =========================================================================
        /**
         * Base initialization - sets up shared utilities and calls system-specific init
         */
        async _baseInitialize() {
          if (this.initialized) {
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Already initialized`);
            }
            return;
          }
          try {
            this.initializationStartTime = performance.now();
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Starting unified initialization`);
            }
            const globalSystem = globalThis.year3000System;
            if (globalSystem) {
              this.performanceAnalyzer = globalSystem.performanceAnalyzer || new PerformanceAnalyzer();
              this.cssConsciousnessController = globalSystem.cssConsciousnessController || UnifiedCSSConsciousnessController.getInstance();
              this.eventBus = unifiedEventBus;
              this.performanceCoordinator = globalSystem.performanceCoordinator || UnifiedPerformanceCoordinator.getInstance(this.config, this.performanceAnalyzer);
              this.animationCoordinator = globalSystem.enhancedMasterAnimationCoordinator || EnhancedMasterAnimationCoordinator.getInstance(this.config, this.performanceCoordinator);
              this.unifiedCSSManager = globalSystem.unifiedCSSManager || UnifiedCSSConsciousnessController.getInstance();
            } else {
              this.performanceAnalyzer = new PerformanceAnalyzer();
              this.cssConsciousnessController = UnifiedCSSConsciousnessController.getInstance();
              this.eventBus = unifiedEventBus;
              this.performanceCoordinator = UnifiedPerformanceCoordinator.getInstance(this.config, this.performanceAnalyzer);
              this.animationCoordinator = EnhancedMasterAnimationCoordinator.getInstance(this.config, this.performanceCoordinator);
              this.unifiedCSSManager = UnifiedCSSConsciousnessController.getInstance();
            }
            if (this.unifiedCSSManager && this.performanceAnalyzer && this.cssConsciousnessController) {
            }
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.recordMetric === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_registered`, 1);
            }
            await this.trackPerformanceAsync("initialize", async () => {
              await this.initialize();
            });
            this.initialized = true;
            this.publishEvent("system:initialized", {
              systemName: this.systemName,
              timestamp: Date.now(),
              metadata: {
                initializationTime: this.initializationStartTime ? performance.now() - this.initializationStartTime : 0
              }
            });
            if (this.config.enableDebug) {
              const duration = this.initializationStartTime ? performance.now() - this.initializationStartTime : 0;
              console.log(`[${this.systemName}] Unified initialization complete (${duration.toFixed(2)}ms)`);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Initialization failed:`, error);
            this.publishEvent("system:initialization-failed", {
              systemName: this.systemName,
              error: error instanceof Error ? error.message : String(error),
              timestamp: Date.now()
            });
            throw error;
          }
        }
        /**
         * Base destruction - handles cleanup and calls system-specific destroy
         */
        _baseDestroy() {
          if (this.destroyed) {
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Already destroyed`);
            }
            return;
          }
          try {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Starting unified destruction`);
            }
            this.eventUnsubscribers.forEach((unsubscribe) => {
              try {
                unsubscribe();
              } catch (error) {
                console.warn(`[${this.systemName}] Error during event unsubscription:`, error);
              }
            });
            this.eventUnsubscribers = [];
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.recordMetric === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_unregistered`, 1);
            }
            this.destroy();
            this.destroyed = true;
            this.publishEvent("system:destroyed", {
              systemName: this.systemName,
              timestamp: Date.now()
            });
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Unified destruction complete`);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Destruction failed:`, error);
          }
        }
        // =========================================================================
        // SHARED UTILITY METHODS
        // =========================================================================
        /**
         * Update a single CSS variable with priority support
         */
        updateCSSVariable(property, value, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueUpdate(property, value, priority, this.systemName);
          } else if (this.cssConsciousnessController) {
            this.cssConsciousnessController.queueCSSVariableUpdate(property, value);
          } else {
            console.warn(`[${this.systemName}] CSS variable management not initialized`);
          }
        }
        /**
         * Update multiple CSS variables efficiently with priority support
         */
        updateCSSVariables(updates, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueTransaction(updates, priority, this.systemName);
          } else if (this.cssConsciousnessController) {
            Object.entries(updates).forEach(([property, value]) => {
              this.cssConsciousnessController.queueCSSVariableUpdate(property, value);
            });
          } else {
            console.warn(`[${this.systemName}] CSS variable management not initialized`);
          }
        }
        /**
         * Subscribe to events with automatic cleanup and retry logic
         */
        subscribeToEvent(event, callback) {
          if (!this.eventBus) {
            console.warn(`[${this.systemName}] Event bus not initialized - attempting to initialize`);
            try {
              this.eventBus = unifiedEventBus;
              if (!this.eventBus) {
                console.error(`[${this.systemName}] Failed to get unified event bus - event subscription deferred`);
                return () => {
                };
              }
            } catch (error) {
              console.error(`[${this.systemName}] Error accessing unified event bus:`, error);
              return () => {
              };
            }
          }
          try {
            const subscriptionId = this.eventBus.subscribe(event, callback, this.systemName);
            const unsubscribe = /* @__PURE__ */ __name(() => {
              this.eventBus.unsubscribe(subscriptionId);
            }, "unsubscribe");
            this.eventUnsubscribers.push(unsubscribe);
            return unsubscribe;
          } catch (error) {
            console.error(`[${this.systemName}] Failed to subscribe to event ${event}:`, error);
            return () => {
            };
          }
        }
        /**
         * Publish events to the global event bus
         */
        publishEvent(event, payload) {
          if (!this.eventBus) {
            console.warn(`[${this.systemName}] Event bus not initialized - attempting to initialize`);
            try {
              this.eventBus = unifiedEventBus;
              if (!this.eventBus) {
                console.error(`[${this.systemName}] Failed to get unified event bus - event publication skipped`);
                return;
              }
            } catch (error) {
              console.error(`[${this.systemName}] Error accessing unified event bus:`, error);
              return;
            }
          }
          try {
            this.eventBus.emitSync(event, payload);
          } catch (error) {
            console.error(`[${this.systemName}] Failed to publish event ${event}:`, error);
          }
        }
        /**
         * Track performance of synchronous operations
         */
        trackPerformance(operation, fn) {
          const startTime = performance.now();
          try {
            fn();
          } finally {
            const endTime = performance.now();
            const frameTime = endTime - startTime;
            this.trackSystemPerformance(frameTime);
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.timeOperation === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_${operation}`, frameTime);
            }
          }
        }
        /**
         * Track performance of asynchronous operations
         */
        async trackPerformanceAsync(operation, fn) {
          if (!this.performanceAnalyzer || typeof this.performanceAnalyzer.timeOperationAsync !== "function") {
            await fn();
            return;
          }
          await this.performanceAnalyzer.timeOperationAsync(`${this.systemName}_${operation}`, fn);
        }
        /**
         * Track system performance metrics
         */
        trackSystemPerformance(frameTime) {
          if (!this.performanceCoordinator) return;
          this.frameCount++;
          const currentTime = performance.now();
          if (currentTime - this.lastFPSCalculation >= 1e3) {
            this.currentFPS = this.frameCount;
            this.frameCount = 0;
            this.lastFPSCalculation = currentTime;
          }
          const memoryUsage = performance.memory?.usedJSHeapSize || 0;
          this.performanceCoordinator.trackSubsystem(this.systemName, {
            frameTime,
            memoryUsage,
            fps: this.currentFPS,
            cpuUsage: frameTime > 16.67 ? Math.min(100, frameTime / 16.67 * 5) : 0
            // Rough estimate
          });
        }
        /**
         * Register with animation coordinator
         */
        registerAnimation(priority = 60) {
          if (!this.animationCoordinator) {
            console.warn(`[${this.systemName}] Animation coordinator not initialized, attempting lazy initialization`);
            try {
              this.animationCoordinator = EnhancedMasterAnimationCoordinator.getInstance(this.config, this.performanceCoordinator);
            } catch (error) {
              console.error(`[${this.systemName}] Failed to initialize animation coordinator:`, error);
              return;
            }
          }
          try {
            this.animationCoordinator.registerAnimationSystem(
              this.systemName,
              this,
              "normal",
              priority
            );
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Successfully registered with animation coordinator`);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Failed to register with animation coordinator:`, error);
          }
        }
        /**
         * Force a repaint - useful for settings changes
         */
        forceRepaint(reason) {
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.emitTrace(`[${this.systemName}] Force repaint: ${reason || "unknown"}`);
          }
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.forceFlush();
          }
          document.documentElement.style.transform = "translateZ(0)";
          requestAnimationFrame(() => {
            document.documentElement.style.transform = "";
          });
        }
        // =========================================================================
        // UTILITY GETTERS AND STATUS
        // =========================================================================
        /**
         * Check if system is initialized
         */
        get isInitialized() {
          return this.initialized;
        }
        /**
         * Check if system is destroyed
         */
        get isDestroyed() {
          return this.destroyed;
        }
        /**
         * Get system name
         */
        get name() {
          return this.systemName;
        }
        /**
         * Get system configuration
         */
        get systemConfig() {
          return this.config;
        }
        /**
         * Register a CSS variable group for this system
         */
        registerCSSVariableGroup(groupName, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.registerVariableGroup(`${this.systemName}-${groupName}`, priority);
          }
        }
        /**
         * Update variables in a CSS variable group
         */
        updateCSSVariableGroup(groupName, variables) {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.updateVariableGroup(`${this.systemName}-${groupName}`, variables, this.systemName);
          } else {
            this.updateCSSVariables(variables);
          }
        }
        // =========================================================================
        // COMPATIBILITY METHODS
        // =========================================================================
        /**
         * Legacy compatibility method for IManagedSystem
         * @deprecated Use onAnimate instead
         */
        updateAnimation(deltaTime) {
          this.onAnimate(deltaTime);
        }
        /**
         * Legacy compatibility method for BaseVisualSystem
         * @deprecated Override initialize() directly
         */
        async _performSystemSpecificInitialization() {
          await this.initialize();
        }
        /**
         * Legacy compatibility method for BaseVisualSystem
         * @deprecated Override destroy() directly
         */
        _performSystemSpecificCleanup() {
          this.destroy();
        }
      };
      __name(_UnifiedSystemBase, "UnifiedSystemBase");
      UnifiedSystemBase = _UnifiedSystemBase;
    }
  });

  // src-js/visual/ui-effects/SidebarInteractiveFlowSystem.ts
  var _SidebarInteractiveFlowSystem, SidebarInteractiveFlowSystem;
  var init_SidebarInteractiveFlowSystem = __esm({
    "src-js/visual/ui-effects/SidebarInteractiveFlowSystem.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_globalConfig();
      _SidebarInteractiveFlowSystem = class _SidebarInteractiveFlowSystem extends UnifiedSystemBase {
        constructor(config = YEAR3000_CONFIG) {
          super(config);
          this.interactionPatterns = /* @__PURE__ */ new Map();
          // Performance optimization
          this.proximityObserver = null;
          this.interactionElements = /* @__PURE__ */ new Map();
          this.activeDisturbances = [];
          // Animation state
          this.animationPhase = 0;
          this.lastUpdateTime = 0;
          // Note: frameCount is inherited from UnifiedSystemBase, using localFrameCount instead
          this.localFrameCount = 0;
          // Music integration
          this.musicBeatIntensity = 0;
          this.musicEnergyLevel = 0;
          // Proximity tracking
          this.cursorPosition = { x: 0, y: 0 };
          this.cursorVelocity = { x: 0, y: 0 };
          this.lastCursorUpdate = 0;
          // Performance parameters
          this.MAX_FLOW_VECTORS = 50;
          this.DISTURBANCE_DECAY_RATE = 0.05;
          this.PROXIMITY_THRESHOLD = 100;
          // pixels
          this.INTERACTION_COOLDOWN = 16;
          // ms (~60fps)
          // Flow dynamics
          this.FLOW_LERP = 0.08;
          this.VISCOSITY_LERP = 0.12;
          this.INTENSITY_LERP = 0.15;
          this.flowState = {
            direction: "radial",
            intensity: 0.3,
            velocity: 50,
            viscosity: 0.7,
            flowField: []
          };
          this.liquidConsciousnessState = {
            globalFlowIntensity: 0,
            dominantFlowDirection: 0,
            interactionCount: 0,
            lastInteractionTime: 0,
            proximityElements: []
          };
          this.initializeFlowField();
          if (config.enableDebug) {
            console.log(`[${this.systemName}] Initialized liquid consciousness flow system`);
          }
        }
        /**
         * Initialize the interactive flow system
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing liquid consciousness interactions`);
          }
          this.initializeInteractionPatterns();
          this.setupProximityDetection();
          this.setupCursorTracking();
          this.subscribeToEvent("music:beat", (payload) => {
            this.musicBeatIntensity = payload.intensity;
            this.updateMusicFlowEffects();
          });
          this.subscribeToEvent("music:energy", (payload) => {
            this.musicEnergyLevel = payload.energy;
            this.updateMusicFlowEffects();
          });
          this.subscribeToEvent("sidebar:bilateral-beat", (payload) => {
            this.handleBilateralFlowSync(payload);
          });
          this.subscribeToEvent("sidebar:consciousness-level-changed", (payload) => {
            this.handleConsciousnessFlowChange(payload);
          });
          this.subscribeToEvent("sidebar:interaction", (payload) => {
            this.handleInteractionTrigger(payload);
          });
          this.registerAnimation(50);
          this.initializeFlowCSSVariables();
          this.publishEvent("sidebar:interactive-flow-ready", {
            systemName: this.systemName,
            flowPatterns: this.interactionPatterns.size,
            proximityThreshold: this.PROXIMITY_THRESHOLD,
            timestamp: Date.now()
          });
        }
        /**
         * Initialize flow field with vectors
         */
        initializeFlowField() {
          this.flowState.flowField = [];
          const gridSize = 8;
          const spacing = 20;
          for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
              const vector = {
                x: x * spacing,
                y: y * spacing,
                magnitude: 0.5 + Math.random() * 0.5,
                direction: Math.random() * Math.PI * 2,
                influence: 0.3 + Math.random() * 0.4
              };
              this.flowState.flowField.push(vector);
            }
          }
        }
        /**
         * Initialize interaction patterns
         */
        initializeInteractionPatterns() {
          this.interactionPatterns.set("hover", {
            id: "hover",
            type: "hover",
            response: {
              intensityChange: 0.2,
              velocityChange: 0.1,
              viscosityChange: -0.1,
              // Less viscous on hover
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                // Will be updated on interaction
                radius: 30,
                strength: 0.3,
                decay: 0.05,
                type: "wave"
              }],
              rippleEffect: false,
              // Performance-optimized
              glowEffect: true
            },
            duration: 300,
            easing: "liquid",
            priority: 3
          });
          this.interactionPatterns.set("click", {
            id: "click",
            type: "click",
            response: {
              intensityChange: 0.5,
              velocityChange: 0.3,
              viscosityChange: -0.2,
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 50,
                strength: 0.7,
                decay: 0.08,
                type: "pulse"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 500,
            easing: "liquid",
            priority: 8
          });
          this.interactionPatterns.set("focus", {
            id: "focus",
            type: "focus",
            response: {
              intensityChange: 0.3,
              velocityChange: 0.05,
              viscosityChange: 0.1,
              // More viscous for focus
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 40,
                strength: 0.4,
                decay: 0.02,
                // Slower decay for sustained effect
                type: "spiral"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 1e3,
            easing: "liquid",
            priority: 6
          });
          this.interactionPatterns.set("proximity", {
            id: "proximity",
            type: "proximity",
            response: {
              intensityChange: 0.1,
              velocityChange: 0.05,
              viscosityChange: -0.05,
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 20,
                strength: 0.2,
                decay: 0.03,
                type: "wave"
              }],
              rippleEffect: false,
              glowEffect: false
            },
            duration: 200,
            easing: "liquid",
            priority: 2
          });
          this.interactionPatterns.set("gesture", {
            id: "gesture",
            type: "gesture",
            response: {
              intensityChange: 0.4,
              velocityChange: 0.2,
              viscosityChange: -0.15,
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 60,
                strength: 0.6,
                decay: 0.06,
                type: "vortex"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 400,
            easing: "liquid",
            priority: 7
          });
        }
        /**
         * Set up proximity detection using Intersection Observer
         */
        setupProximityDetection() {
          if (typeof IntersectionObserver !== "undefined") {
            this.proximityObserver = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  const element = entry.target;
                  const elementId = element.id || element.className;
                  if (entry.isIntersecting) {
                    this.interactionElements.set(elementId, element);
                    this.handleProximityEnter(element);
                  } else {
                    this.interactionElements.delete(elementId);
                    this.handleProximityExit(element);
                  }
                });
              },
              {
                threshold: [0, 0.1, 0.5, 1],
                rootMargin: `${this.PROXIMITY_THRESHOLD}px`
              }
            );
            this.observeSidebarElements();
          }
        }
        /**
         * Set up cursor tracking for proximity awareness
         */
        setupCursorTracking() {
          if (this.config.enableDebug) {
            setInterval(() => {
              this.simulateCursorMovement();
            }, 50);
          }
        }
        /**
         * Observe sidebar elements for proximity detection
         */
        observeSidebarElements() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Observing sidebar elements for proximity`);
          }
        }
        /**
         * Handle interaction trigger
         */
        handleInteractionTrigger(trigger) {
          const pattern = this.interactionPatterns.get(trigger.type);
          if (!pattern) return;
          const currentTime = Date.now();
          if (currentTime - this.liquidConsciousnessState.lastInteractionTime < this.INTERACTION_COOLDOWN) {
            return;
          }
          this.liquidConsciousnessState.lastInteractionTime = currentTime;
          this.liquidConsciousnessState.interactionCount++;
          this.applyFlowResponse(pattern.response, trigger.position);
          this.updateGlobalFlowState(pattern);
          this.publishEvent("sidebar:flow-interaction", {
            type: trigger.type,
            position: trigger.position,
            pattern: pattern.id,
            timestamp: currentTime
          });
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Flow interaction: ${trigger.type} at (${trigger.position.x}, ${trigger.position.y})`);
          }
        }
        /**
         * Apply flow response to the system
         */
        applyFlowResponse(response, position) {
          this.flowState.intensity = Math.max(0, Math.min(
            1,
            this.flowState.intensity + response.intensityChange
          ));
          this.flowState.velocity = Math.max(0, Math.min(
            200,
            this.flowState.velocity + response.velocityChange * 50
          ));
          this.flowState.viscosity = Math.max(0, Math.min(
            1,
            this.flowState.viscosity + response.viscosityChange
          ));
          response.flowFieldDisturbance.forEach((disturbance) => {
            const positionedDisturbance = {
              ...disturbance,
              center: position
            };
            this.activeDisturbances.push(positionedDisturbance);
          });
          if (this.activeDisturbances.length > 10) {
            this.activeDisturbances = this.activeDisturbances.slice(-10);
          }
        }
        /**
         * Update global flow state based on interaction pattern
         */
        updateGlobalFlowState(pattern) {
          const priorityWeight = pattern.priority / 10;
          this.liquidConsciousnessState.dominantFlowDirection = (this.liquidConsciousnessState.dominantFlowDirection + Math.random() * Math.PI * 2) * priorityWeight;
          this.liquidConsciousnessState.globalFlowIntensity = Math.max(0, Math.min(
            1,
            this.liquidConsciousnessState.globalFlowIntensity + pattern.response.intensityChange * 0.5
          ));
        }
        /**
         * Handle proximity enter
         */
        handleProximityEnter(element) {
          const rect = element.getBoundingClientRect();
          const center = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          };
          const distance2 = Math.sqrt(
            Math.pow(center.x - this.cursorPosition.x, 2) + Math.pow(center.y - this.cursorPosition.y, 2)
          );
          this.liquidConsciousnessState.proximityElements.push({
            element,
            distance: distance2,
            influence: Math.max(0, 1 - distance2 / this.PROXIMITY_THRESHOLD)
          });
          this.handleInteractionTrigger({
            type: "proximity",
            position: center,
            element,
            timestamp: Date.now(),
            proximityData: {
              distance: distance2,
              angle: Math.atan2(center.y - this.cursorPosition.y, center.x - this.cursorPosition.x),
              velocity: this.cursorVelocity,
              pressure: 0.5
            }
          });
        }
        /**
         * Handle proximity exit
         */
        handleProximityExit(element) {
          this.liquidConsciousnessState.proximityElements = this.liquidConsciousnessState.proximityElements.filter((item) => item.element !== element);
        }
        /**
         * Update music flow effects
         */
        updateMusicFlowEffects() {
          const musicFlowIntensity = this.musicBeatIntensity * 0.3;
          this.flowState.intensity = Math.max(this.flowState.intensity, musicFlowIntensity);
          const musicVelocityBoost = this.musicEnergyLevel * 30;
          this.flowState.velocity = Math.min(200, this.flowState.velocity + musicVelocityBoost);
          const musicViscosityAdjustment = (1 - this.musicEnergyLevel) * 0.2;
          this.flowState.viscosity = Math.max(0.1, this.flowState.viscosity - musicViscosityAdjustment);
          this.updateFlowFieldWithMusic();
        }
        /**
         * Update flow field with music influence
         */
        updateFlowFieldWithMusic() {
          const musicInfluence = this.musicBeatIntensity * 0.5;
          this.flowState.flowField.forEach((vector) => {
            vector.direction += (Math.random() - 0.5) * musicInfluence * 0.1;
            vector.magnitude = Math.max(0.1, Math.min(
              1,
              vector.magnitude + (this.musicEnergyLevel - 0.5) * 0.2
            ));
          });
        }
        /**
         * Handle bilateral flow synchronization
         */
        handleBilateralFlowSync(payload) {
          if (payload.source === "left") {
            const consciousnessFlow = payload.intensity * 0.2;
            this.flowState.intensity = Math.max(this.flowState.intensity, consciousnessFlow);
            const flowDirectionAdjustment = payload.intensity * 0.3;
            this.liquidConsciousnessState.dominantFlowDirection += flowDirectionAdjustment;
          }
        }
        /**
         * Handle consciousness flow changes
         */
        handleConsciousnessFlowChange(payload) {
          const consciousnessLevels = {
            dormant: 0.1,
            aware: 0.3,
            focused: 0.6,
            transcendent: 1
          };
          const targetIntensity = consciousnessLevels[payload.newLevel] || 0.3;
          this.flowState.intensity = this.lerp(this.flowState.intensity, targetIntensity, 0.1);
          const viscosityTarget = 0.8 - targetIntensity * 0.3;
          this.flowState.viscosity = this.lerp(this.flowState.viscosity, viscosityTarget, 0.05);
        }
        /**
         * Simulate cursor movement for testing
         */
        simulateCursorMovement() {
          if (!this.config.enableDebug) return;
          const currentTime = Date.now();
          const deltaTime = currentTime - this.lastCursorUpdate;
          const time = currentTime * 1e-3;
          const newX = 200 + Math.sin(time * 0.5) * 100;
          const newY = 300 + Math.cos(time * 0.3) * 80;
          if (this.lastCursorUpdate > 0) {
            this.cursorVelocity.x = (newX - this.cursorPosition.x) / deltaTime * 1e3;
            this.cursorVelocity.y = (newY - this.cursorPosition.y) / deltaTime * 1e3;
          }
          this.cursorPosition.x = newX;
          this.cursorPosition.y = newY;
          this.lastCursorUpdate = currentTime;
        }
        /**
         * Update flow field disturbances
         */
        updateFlowDisturbances() {
          this.activeDisturbances = this.activeDisturbances.filter((disturbance) => {
            disturbance.strength *= 1 - disturbance.decay;
            return disturbance.strength > 0.01;
          });
          this.activeDisturbances.forEach((disturbance) => {
            this.flowState.flowField.forEach((vector) => {
              const distance2 = Math.sqrt(
                Math.pow(vector.x - disturbance.center.x, 2) + Math.pow(vector.y - disturbance.center.y, 2)
              );
              if (distance2 < disturbance.radius) {
                const influence = disturbance.strength * (1 - distance2 / disturbance.radius);
                switch (disturbance.type) {
                  case "wave":
                    vector.magnitude += influence * 0.3;
                    break;
                  case "spiral":
                    vector.direction += influence * 0.5;
                    break;
                  case "pulse":
                    vector.magnitude += influence * 0.5;
                    vector.direction += influence * 0.2;
                    break;
                  case "vortex":
                    const angle = Math.atan2(
                      vector.y - disturbance.center.y,
                      vector.x - disturbance.center.x
                    );
                    vector.direction = angle + influence * Math.PI * 0.5;
                    break;
                }
              }
            });
          });
        }
        /**
         * Initialize flow CSS variables
         */
        initializeFlowCSSVariables() {
          this.updateCSSVariables({
            "--sn-flow-intensity": this.flowState.intensity.toFixed(3),
            "--sn-flow-velocity": `${this.flowState.velocity}px`,
            "--sn-flow-viscosity": this.flowState.viscosity.toFixed(3),
            "--sn-flow-direction": `${this.liquidConsciousnessState.dominantFlowDirection}rad`,
            "--sn-flow-global-intensity": this.liquidConsciousnessState.globalFlowIntensity.toFixed(3),
            "--sn-flow-interaction-count": this.liquidConsciousnessState.interactionCount.toString(),
            "--sn-flow-proximity-elements": this.liquidConsciousnessState.proximityElements.length.toString(),
            "--sn-flow-disturbances": this.activeDisturbances.length.toString(),
            "--sn-flow-music-beat": this.musicBeatIntensity.toFixed(3),
            "--sn-flow-music-energy": this.musicEnergyLevel.toFixed(3)
          });
        }
        /**
         * Update flow CSS variables
         */
        updateFlowCSSVariables() {
          this.updateCSSVariables({
            "--sn-flow-intensity": this.flowState.intensity.toFixed(3),
            "--sn-flow-velocity": `${this.flowState.velocity}px`,
            "--sn-flow-viscosity": this.flowState.viscosity.toFixed(3),
            "--sn-flow-direction": `${this.liquidConsciousnessState.dominantFlowDirection}rad`,
            "--sn-flow-global-intensity": this.liquidConsciousnessState.globalFlowIntensity.toFixed(3)
          });
        }
        /**
         * Linear interpolation helper
         */
        lerp(from, to, alpha) {
          return from + (to - from) * alpha;
        }
        /**
         * Animation frame callback
         */
        onAnimate(deltaTime) {
          this.lastUpdateTime = performance.now();
          this.animationPhase += deltaTime * 1e-3;
          this.localFrameCount++;
          this.updateFlowDisturbances();
          this.flowState.intensity = this.lerp(
            this.flowState.intensity,
            this.liquidConsciousnessState.globalFlowIntensity,
            this.INTENSITY_LERP
          );
          this.flowState.intensity *= 0.995;
          this.flowState.velocity *= 0.98;
          if (this.localFrameCount % 10 === 0) {
            this.updateFlowFieldNaturalTurbulence();
          }
          this.updateProximityElements();
          this.updateFlowCSSVariables();
          this.updateMusicFlowEffects();
        }
        /**
         * Update flow field with natural turbulence
         */
        updateFlowFieldNaturalTurbulence() {
          this.flowState.flowField.forEach((vector) => {
            vector.direction += (Math.random() - 0.5) * 0.02;
            vector.magnitude += (Math.random() - 0.5) * 0.01;
            vector.magnitude = Math.max(0.1, Math.min(1, vector.magnitude));
          });
        }
        /**
         * Update proximity elements
         */
        updateProximityElements() {
          this.liquidConsciousnessState.proximityElements.forEach((item) => {
            const rect = item.element.getBoundingClientRect();
            const center = {
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2
            };
            item.distance = Math.sqrt(
              Math.pow(center.x - this.cursorPosition.x, 2) + Math.pow(center.y - this.cursorPosition.y, 2)
            );
            item.influence = Math.max(0, 1 - item.distance / this.PROXIMITY_THRESHOLD);
          });
        }
        /**
         * Get current flow state
         */
        getFlowState() {
          return { ...this.flowState };
        }
        /**
         * Get liquid consciousness state
         */
        getLiquidConsciousnessState() {
          return { ...this.liquidConsciousnessState };
        }
        /**
         * Get active disturbances
         */
        getActiveDisturbances() {
          return [...this.activeDisturbances];
        }
        /**
         * System health check
         */
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: `Interactive flow system healthy - ${this.interactionPatterns.size} patterns, ${this.activeDisturbances.length} disturbances, ${this.liquidConsciousnessState.interactionCount} interactions`,
            issues: [],
            system: "SidebarInteractiveFlowSystem"
          };
        }
        /**
         * Clean up resources
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying liquid consciousness flow system`);
          }
          if (this.proximityObserver) {
            this.proximityObserver.disconnect();
            this.proximityObserver = null;
          }
          this.interactionPatterns.clear();
          this.interactionElements.clear();
          this.activeDisturbances = [];
          this.flowState = {
            direction: "radial",
            intensity: 0,
            velocity: 0,
            viscosity: 0.5,
            flowField: []
          };
          this.liquidConsciousnessState = {
            globalFlowIntensity: 0,
            dominantFlowDirection: 0,
            interactionCount: 0,
            lastInteractionTime: 0,
            proximityElements: []
          };
          this.publishEvent("sidebar:interactive-flow-destroyed", {
            timestamp: Date.now()
          });
        }
      };
      __name(_SidebarInteractiveFlowSystem, "SidebarInteractiveFlowSystem");
      SidebarInteractiveFlowSystem = _SidebarInteractiveFlowSystem;
    }
  });

  // src-js/utils/dom/domCache.ts
  function $$(selector, options = {}) {
    if (!SUPPORTS_WEAKREF) {
      return Array.from(document.querySelectorAll(selector));
    }
    let entry = CACHE.get(selector);
    let elements = entry?.ref?.deref();
    if (options.force || !elements) {
      elements = Array.from(document.querySelectorAll(selector));
      const ref = new WeakRef(elements);
      entry = { ref, lastUpdate: Date.now() };
      CACHE.set(selector, entry);
      registry?.register(elements, selector);
    }
    return elements;
  }
  var CACHE, SUPPORTS_WEAKREF, SUPPORTS_REGISTRY, registry;
  var init_domCache = __esm({
    "src-js/utils/dom/domCache.ts"() {
      "use strict";
      CACHE = /* @__PURE__ */ new Map();
      SUPPORTS_WEAKREF = typeof WeakRef !== "undefined";
      SUPPORTS_REGISTRY = typeof FinalizationRegistry !== "undefined";
      registry = SUPPORTS_REGISTRY ? (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore – lib dom may not include FinalizationRegistry in older TS bundlers
        new FinalizationRegistry((selector) => {
          CACHE.delete(selector);
        })
      ) : null;
      __name($$, "$$");
    }
  });

  // src-js/debug/SpotifyDOMSelectors.ts
  function elementExists(selector) {
    return $$(selector).length > 0;
  }
  function findElementsWithFallback(modernSelector, legacySelector, options) {
    let elements = $$(modernSelector, options);
    if (elements.length === 0 && legacySelector) {
      elements = $$(legacySelector, options);
      if (elements.length > 0) {
        console.warn(
          `\u{1F30C} [SpotifyDOMSelectors] Using legacy selector: ${legacySelector}. Consider updating to: ${modernSelector}`
        );
      }
    }
    return elements;
  }
  function validateSpotifyDOM() {
    console.group("\u{1F30C} [SpotifyDOMSelectors] DOM Validation");
    const results = {
      found: 0,
      missing: 0,
      details: {}
    };
    Object.entries(MODERN_SELECTORS).forEach(([key, selector]) => {
      const exists = elementExists(selector);
      results.details[key] = {
        selector,
        exists,
        element: exists ? $$(selector)[0] || null : null
      };
      if (exists) {
        results.found++;
        console.log(`\u2705 ${key}: ${selector}`);
      } else {
        results.missing++;
        console.warn(`\u274C ${key}: ${selector}`);
      }
    });
    console.log(`\u{1F4CA} Summary: ${results.found} found, ${results.missing} missing`);
    console.groupEnd();
    return results;
  }
  function testGravitySystemSelectors() {
    console.group("\u{1F30C} [Phase 1] Testing Gravity System Selectors");
    console.log("\u{1F3AF} Primary gravity well targets:");
    if (GRAVITY_WELL_TARGETS["primary"]) {
      GRAVITY_WELL_TARGETS["primary"].forEach((selector) => {
        const element = $$(selector)[0] || null;
        console.log(`${element ? "\u2705" : "\u274C"} ${selector}`, element);
      });
    }
    console.log("\u{1F3AF} Secondary gravity well targets:");
    if (GRAVITY_WELL_TARGETS["secondary"]) {
      GRAVITY_WELL_TARGETS["secondary"].forEach((selector) => {
        const element = $$(selector)[0] || null;
        console.log(`${element ? "\u2705" : "\u274C"} ${selector}`, element);
      });
    }
    console.log("\u{1F6F8} Orbital elements:");
    Object.entries(ORBITAL_ELEMENTS).forEach(([key, selector]) => {
      const elements = $$(selector);
      console.log(
        `${elements.length > 0 ? "\u2705" : "\u274C"} ${key} (${selector}): ${elements.length} found`
      );
    });
    console.groupEnd();
  }
  function validatePredictionTargets() {
    console.group(
      "\u{1F52E} [SpotifyDOMSelectors] Phase 2 - Prediction Target Validation"
    );
    const testSelectors = [
      { name: "Track Rows", selector: ORBITAL_ELEMENTS["trackRows"] },
      { name: "Progress Bar", selector: MODERN_SELECTORS["progressBar"] },
      { name: "Play Button", selector: MODERN_SELECTORS["playButton"] },
      { name: "Heart Button", selector: MODERN_SELECTORS["heartButton"] },
      { name: "Album Cover", selector: MODERN_SELECTORS["albumCover"] },
      {
        name: "Now Playing Widget",
        selector: MODERN_SELECTORS["nowPlayingWidget"]
      },
      { name: "Now Playing Left", selector: MODERN_SELECTORS["nowPlayingLeft"] },
      { name: "Left Sidebar", selector: MODERN_SELECTORS["leftSidebar"] },
      { name: "Library Items", selector: ORBITAL_ELEMENTS["libraryItems"] }
    ];
    const results = {
      found: 0,
      missing: 0,
      details: {}
    };
    testSelectors.forEach(({ name, selector }) => {
      if (!selector) return;
      const elements = findElementsWithFallback(selector);
      const count = elements.length;
      results.details[name] = {
        selector,
        count,
        exists: count > 0
      };
      if (count > 0) {
        results.found++;
        console.log(`\u2705 ${name}: ${count} elements found (${selector})`);
      } else {
        results.missing++;
        console.warn(`\u274C ${name}: No elements found (${selector})`);
      }
    });
    console.log(
      `\u{1F4CA} Prediction Targets Summary: ${results.found} types found, ${results.missing} missing`
    );
    console.groupEnd();
    return results;
  }
  function testPhase2Systems() {
    console.group("\u{1F30C} [SpotifyDOMSelectors] Phase 2 - System Integration Test");
    const systemTests = {
      behavioralPrediction: validatePredictionTargets(),
      dimensionalNexus: {
        sidebarElement: MODERN_SELECTORS["leftSidebar"] ? elementExists(MODERN_SELECTORS["leftSidebar"]) : false
      },
      dataGlyph: {
        navLinks: MODERN_SELECTORS["navBarLink"] ? elementExists(MODERN_SELECTORS["navBarLink"]) : false,
        trackRows: ORBITAL_ELEMENTS["trackRows"] ? elementExists(ORBITAL_ELEMENTS["trackRows"]) : false,
        cards: ORBITAL_ELEMENTS["cards"] ? elementExists(ORBITAL_ELEMENTS["cards"]) : false
      }
    };
    let totalIssues = 0;
    Object.values(systemTests).forEach((tests) => {
      if (typeof tests === "object" && tests.missing) {
        totalIssues += tests.missing;
      }
    });
    console.log(
      `\u{1F3AF} Phase 2 Integration Health: ${totalIssues === 0 ? "\u2705 All systems operational" : `\u26A0\uFE0F ${totalIssues} issues detected`}`
    );
    console.groupEnd();
    return systemTests;
  }
  var MODERN_SELECTORS, SELECTOR_MAPPINGS, ORBITAL_ELEMENTS, GRAVITY_WELL_TARGETS, ANTI_GRAVITY_ZONES;
  var init_SpotifyDOMSelectors = __esm({
    "src-js/debug/SpotifyDOMSelectors.ts"() {
      "use strict";
      init_domCache();
      MODERN_SELECTORS = {
        // Main Layout Structure
        nowPlayingBar: ".Root__now-playing-bar",
        leftSidebar: ".Root__nav-bar",
        mainView: ".Root__main-view",
        rightSidebar: ".Root__right-sidebar",
        // Now Playing Components
        nowPlayingWidget: "[data-testid='now-playing-widget']",
        nowPlayingLeft: ".main-nowPlayingBar-left",
        nowPlayingCenter: ".main-nowPlayingBar-center",
        nowPlayingRight: ".main-nowPlayingBar-right",
        coverArt: ".main-coverSlotCollapsed-container",
        trackInfo: ".main-trackInfo-container",
        // Navigation & Library
        navMain: "nav[aria-label='Main']",
        yourLibrary: ".main-yourLibraryX-libraryContainer",
        libraryItems: ".main-yourLibraryX-listItem",
        libraryHeader: ".main-yourLibraryX-header",
        playlistList: ".main-rootlist-wrapper",
        // Track Lists & Content
        trackListContainer: "[role='grid'][aria-label*='tracks']",
        trackRow: ".main-trackList-trackListRow",
        trackListHeader: ".main-trackList-trackListHeaderRow",
        trackNumber: ".main-trackList-rowSectionIndex",
        trackTitle: ".main-trackList-rowTitle",
        trackArtist: ".main-trackList-rowSubTitle",
        // Entity Headers (Playlist/Album/Artist Pages)
        entityHeader: ".main-entityHeader-container",
        entityTitle: ".main-entityHeader-title",
        entityMetadata: ".main-entityHeader-metaData",
        entityImage: ".main-entityHeader-imageContainer",
        // Action Bar & Controls
        actionBar: ".main-actionBar-ActionBarRow",
        actionBarInner: ".main-actionBar-ActionBar",
        playButton: "[data-testid='play-button']",
        pauseButton: "[data-testid='pause-button']",
        shuffleButton: "[data-testid='shuffle-button']",
        likeButton: ".control-button-heart",
        // Queue & Right Sidebar
        queue: ".main-queue-trackList",
        queueContainer: "[aria-label='Next in queue']",
        aboutArtist: "[aria-label='About the artist']",
        credits: "[aria-label='Credits']",
        // Search & Filtering
        searchInput: "[data-testid='search-input']",
        searchPage: "[data-testid='search-container']",
        filterPills: ".main-genre-chip",
        sortButton: "[data-testid='sort-button']",
        // Cards & Media
        card: ".main-card-card",
        cardImage: ".main-cardImage-image",
        albumArt: ".main-trackList-albumArt",
        // Modal & Overlay
        modal: ".main-modal-container",
        overlay: ".main-overlay-container"
      };
      SELECTOR_MAPPINGS = Object.entries({
        // Migration mapping: legacy → modern
        ".main-nowPlayingWidget-nowPlaying": MODERN_SELECTORS["nowPlayingBar"],
        ".main-navBar-navBar": MODERN_SELECTORS["leftSidebar"],
        ".main-search-searchBar": MODERN_SELECTORS["searchInput"],
        ".main-topBar-topBar": MODERN_SELECTORS["actionBar"],
        ".main-queue-queue": MODERN_SELECTORS["queue"],
        ".main-trackList-trackList": MODERN_SELECTORS["trackListContainer"]
      }).reduce((acc, [key, value]) => {
        if (typeof value === "string") {
          acc[key] = value;
        }
        return acc;
      }, {});
      ORBITAL_ELEMENTS = {
        // Elements that can have orbital gravity effects
        trackRows: MODERN_SELECTORS["trackRow"] ?? "",
        libraryItems: MODERN_SELECTORS["libraryItems"] ?? "",
        cards: MODERN_SELECTORS["card"] ?? "",
        navLinks: ".main-navBar-navBarLink"
        // This one still works
      };
      GRAVITY_WELL_TARGETS = {
        // Major UI elements that should have gravity wells
        primary: [
          MODERN_SELECTORS["nowPlayingBar"],
          MODERN_SELECTORS["leftSidebar"],
          MODERN_SELECTORS["entityHeader"]
        ].filter((s) => !!s),
        secondary: [
          MODERN_SELECTORS["actionBar"],
          MODERN_SELECTORS["queue"],
          MODERN_SELECTORS["searchInput"]
        ].filter((s) => !!s),
        tertiary: [
          MODERN_SELECTORS["playButton"],
          MODERN_SELECTORS["trackListHeader"]
        ].filter((s) => !!s)
      };
      ANTI_GRAVITY_ZONES = {
        // Areas where anti-gravity effects should be applied
        searchAreas: [
          MODERN_SELECTORS["searchInput"],
          MODERN_SELECTORS["searchPage"]
        ].filter((s) => !!s),
        notifications: [
          "[data-testid='notification-bar']",
          ".main-topBar-notifications"
        ],
        dropdowns: [".main-dropdown-menu", "[role='menu']", "[role='listbox']"]
      };
      __name(elementExists, "elementExists");
      __name(findElementsWithFallback, "findElementsWithFallback");
      __name(validateSpotifyDOM, "validateSpotifyDOM");
      __name(testGravitySystemSelectors, "testGravitySystemSelectors");
      __name(validatePredictionTargets, "validatePredictionTargets");
      __name(testPhase2Systems, "testPhase2Systems");
      if (typeof window !== "undefined") {
        window.SpotifyDOMSelectors = {
          validate: validateSpotifyDOM,
          testGravity: testGravitySystemSelectors,
          validatePredictionTargets,
          testPhase2Systems,
          selectors: MODERN_SELECTORS,
          targets: GRAVITY_WELL_TARGETS,
          orbital: ORBITAL_ELEMENTS,
          antiGravity: ANTI_GRAVITY_ZONES
        };
        console.log("\u{1F3AF} [SpotifyDOMSelectors] Debug functions available:");
        console.log("  window.SpotifyDOMSelectors.validate() - Test all selectors");
        console.log(
          "  window.SpotifyDOMSelectors.testGravity() - Test gravity selectors"
        );
      }
    }
  });

  // src-js/visual/ui-effects/SidebarPerformanceCoordinator.ts
  var SidebarPerformanceCoordinator_exports = {};
  __export(SidebarPerformanceCoordinator_exports, {
    SidebarPerformanceCoordinator: () => SidebarPerformanceCoordinator,
    getSidebarPerformanceCoordinator: () => getSidebarPerformanceCoordinator
  });
  function getSidebarPerformanceCoordinator(config) {
    return SidebarPerformanceCoordinator.getInstance(config);
  }
  var _SidebarPerformanceCoordinator, SidebarPerformanceCoordinator;
  var init_SidebarPerformanceCoordinator = __esm({
    "src-js/visual/ui-effects/SidebarPerformanceCoordinator.ts"() {
      "use strict";
      init_UnifiedCSSConsciousnessController();
      init_PerformanceBudgetManager();
      init_SpotifyDOMSelectors();
      init_EventBus();
      _SidebarPerformanceCoordinator = class _SidebarPerformanceCoordinator {
        constructor(config = {}) {
          this.pendingUpdates = /* @__PURE__ */ new Map();
          this.isFlushScheduled = false;
          this.rafId = null;
          this.performanceAnalyzer = null;
          // Harmonic variable mapping for Year 3000 convergence
          this.harmonicVariableMap = /* @__PURE__ */ new Map([
            ["--sn-rs-beat-intensity", "--sn-beat-pulse-intensity"],
            ["--sn-rs-glow-alpha", "--sn-rhythm-phase"],
            ["--sn-rs-hue-shift", "--sn-spectrum-phase"]
          ]);
          // Performance tracking
          this.flushCount = 0;
          this.totalFlushTime = 0;
          this.lastFlushTimestamp = 0;
          this.budgetManager = null;
          // DOM observation for reactive refresh and temporal play
          this.domObserver = null;
          this.sidebarElement = null;
          this.visibilityObserver = null;
          this.observationThrottleTimer = null;
          this.lastObservationTime = 0;
          this.OBSERVATION_THROTTLE_MS = 200;
          // Throttle observations to 5 Hz for better performance
          this.isFirstOpen = true;
          this.lastScrollUpdate = 0;
          // Timeout tracking for proper cleanup
          this.activeTimeouts = /* @__PURE__ */ new Set();
          this.domObservationRetryTimeout = null;
          // Event-driven coordination for music changes
          this.musicChangeUnsubscribe = null;
          this.config = {
            enableDebug: config.enableDebug ?? false,
            maxBatchSize: config.maxBatchSize ?? 50,
            ...config
          };
          this.performanceAnalyzer = config.performanceAnalyzer || null;
          if (this.performanceAnalyzer) {
            this.budgetManager = PerformanceBudgetManager.getInstance(void 0, this.performanceAnalyzer);
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceCoordinator] Initialized with RAF-based batching"
            );
          }
        }
        /**
         * Singleton accessor for global coordination
         */
        static getInstance(config) {
          if (!_SidebarPerformanceCoordinator.instance) {
            _SidebarPerformanceCoordinator.instance = new _SidebarPerformanceCoordinator(config);
          }
          return _SidebarPerformanceCoordinator.instance;
        }
        /**
         * Queue a CSS variable update for atomic application at next animation frame
         */
        queueUpdate(property, value) {
          const criticalVars = [
            "--sn-rs-glow-alpha",
            "--sn-rs-beat-intensity",
            "--sn-rs-hue-shift"
          ];
          if (criticalVars.includes(property)) {
            this.applyCriticalUpdate(property, value);
            return;
          }
          const cssController = UnifiedCSSConsciousnessController.getInstance();
          if (cssController) {
            cssController.queueCSSVariableUpdate(
              property,
              value,
              this.getSidebarElement()
            );
          } else {
            this.pendingUpdates.set(property, {
              property,
              value,
              timestamp: performance.now()
            });
            if (this.config.enableDebug && this.pendingUpdates.size === 1) {
              console.log(
                `\u{1F30C} [SidebarPerformanceCoordinator] Queuing first update (fallback): ${property}`
              );
            }
            this.scheduleFlush();
          }
        }
        /**
         * Apply critical updates immediately to the sidebar element
         */
        applyCriticalUpdate(property, value) {
          const sidebarElement = this.getSidebarElement();
          if (sidebarElement) {
            try {
              sidebarElement.style.setProperty(property, value);
            } catch (error) {
              console.error(
                `\u{1F30C} [SidebarPerformanceCoordinator] Failed to apply critical ${property}:`,
                error
              );
            }
          }
        }
        /**
         * Get the sidebar element with fallback to document root
         * Extensible to support multiple sidebar locations in the future
         */
        getSidebarElement() {
          if (!this.sidebarElement) {
            this.sidebarElement = document.querySelector(
              MODERN_SELECTORS.rightSidebar
            );
          }
          return this.sidebarElement || document.documentElement;
        }
        /**
         * Schedule atomic flush at next animation frame
         */
        scheduleFlush() {
          if (this.isFlushScheduled) {
            return;
          }
          this.isFlushScheduled = true;
          this.rafId = requestAnimationFrame(() => {
            this.flushUpdates();
          });
        }
        /**
         * Atomically apply all pending updates
         */
        flushUpdates() {
          if (this.pendingUpdates.size === 0) {
            this.isFlushScheduled = false;
            return;
          }
          const startTime = performance.now();
          const targetElement = this.getSidebarElement();
          const updateCount = this.pendingUpdates.size;
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [SidebarPerformanceCoordinator] Flushing ${updateCount} updates atomically`
            );
          }
          if (updateCount > (this.config.maxBatchSize || 50)) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceCoordinator] Large batch detected (${updateCount} updates), may impact performance`
            );
          }
          for (const update of this.pendingUpdates.values()) {
            try {
              targetElement.style.setProperty(
                update.property,
                update.value
              );
              const harmonicVar = this.harmonicVariableMap.get(update.property);
              if (harmonicVar) {
                document.documentElement.style.setProperty(harmonicVar, update.value);
                if (this.config.enableDebug) {
                  console.log(
                    `\u{1F30C} [SidebarPerformanceCoordinator] Mapped ${update.property} \u2192 ${harmonicVar} = ${update.value}`
                  );
                }
              }
            } catch (error) {
              console.error(
                `\u{1F30C} [SidebarPerformanceCoordinator] Failed to apply ${update.property}:`,
                error
              );
            }
          }
          this.pendingUpdates.clear();
          this.isFlushScheduled = false;
          this.rafId = null;
          if (this.config.onFlushComplete) {
            try {
              this.config.onFlushComplete();
            } catch (error) {
              console.error(
                "\u{1F30C} [SidebarPerformanceCoordinator] Error in flush completion callback:",
                error
              );
            }
          }
          const endTime = performance.now();
          const flushTime = endTime - startTime;
          this.flushCount++;
          this.totalFlushTime += flushTime;
          this.lastFlushTimestamp = endTime;
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.emitTrace?.(
              `[SidebarPerformanceCoordinator] Flushed ${updateCount} updates in ${flushTime.toFixed(
                2
              )}ms`
            );
          }
          const avgFlushTime = this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0;
          if (avgFlushTime > 3) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceCoordinator] Performance threshold exceeded: average ${avgFlushTime.toFixed(
                2
              )}ms per flush (target: <3ms)`
            );
          }
          if (this.config.enableDebug && flushTime > 4) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceCoordinator] Slow flush detected: ${flushTime.toFixed(
                2
              )}ms for ${updateCount} updates`
            );
          }
        }
        /**
         * Setup event-driven music change coordination
         * This replaces pure DOM watching to prevent cascade loops
         */
        setupMusicChangeCoordination() {
          if (this.musicChangeUnsubscribe) {
            return;
          }
          this.musicChangeUnsubscribe = GlobalEventBus.on("music:now-playing-changed", (eventData) => {
            this.handleMusicChange(eventData);
          });
          if (this.config.enableDebug) {
            console.log("\u{1F30C} [SidebarPerformanceCoordinator] Event-driven music coordination active");
          }
        }
        /**
         * Handle music change events from the global event bus
         */
        handleMusicChange(eventData) {
          if (this.sidebarElement) {
            this.handleVisibilityChange();
            if (this.config.enableDebug) {
              console.log("\u{1F30C} [SidebarPerformanceCoordinator] Music change coordinated via event", {
                source: eventData.source,
                reason: eventData.reason,
                timestamp: eventData.timestamp
              });
            }
          }
        }
        /**
         * Setup DOM observation for reactive refresh and temporal play
         */
        setupDOMObservation() {
          if (this.domObserver) {
            return;
          }
          this.setupMusicChangeCoordination();
          this.sidebarElement = document.querySelector(
            MODERN_SELECTORS.rightSidebar
          );
          if (!this.sidebarElement) {
            if (this.config.enableDebug) {
              console.warn(
                "\u{1F30C} [SidebarPerformanceCoordinator] Sidebar not found, deferring DOM observation"
              );
            }
            if (this.domObservationRetryTimeout) {
              clearTimeout(this.domObservationRetryTimeout);
              this.activeTimeouts.delete(this.domObservationRetryTimeout);
            }
            this.domObservationRetryTimeout = setTimeout(() => {
              this.setupDOMObservation();
              this.domObservationRetryTimeout = null;
            }, 1e3);
            this.activeTimeouts.add(this.domObservationRetryTimeout);
            return;
          }
          this.domObserver = new MutationObserver((mutations) => {
            const relevantMutations = mutations.filter((mutation) => this.isRelevantMutation(mutation));
            if (relevantMutations.length === 0) {
              return;
            }
            this.throttleObservationUpdate(() => {
              for (const mutation of relevantMutations) {
                if (mutation.type === "attributes" && (mutation.attributeName === "aria-hidden" || mutation.attributeName === "style")) {
                  this.handleVisibilityChange();
                }
              }
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F30C} [SidebarPerformanceCoordinator] Relevant DOM change detected - visibility/structure only",
                  { mutationCount: relevantMutations.length, types: relevantMutations.map((m) => m.type) }
                );
              }
            });
          });
          this.domObserver.observe(this.sidebarElement, {
            childList: true,
            subtree: false,
            // Optimize: Only observe direct children to reduce mutation volume
            attributes: true,
            // Watch for visibility and style changes
            attributeFilter: ["aria-hidden", "style", "class"],
            // Only observe attributes we care about
            attributeOldValue: false,
            // Optimize: Don't observe attribute old values
            characterData: false
            // Don't observe text changes
          });
          this.setupVisibilityObserver();
          this.setupScrollObservation();
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceCoordinator] DOM observation active on sidebar"
            );
          }
        }
        /**
         * Setup visibility observer for temporal echo effects
         */
        setupVisibilityObserver() {
          if (!this.sidebarElement || this.visibilityObserver) return;
          this.visibilityObserver = new IntersectionObserver(
            (entries) => {
              const entry = entries[0];
              if (entry && entry.isIntersecting && this.isFirstOpen) {
                if (window.requestIdleCallback) {
                  window.requestIdleCallback(() => {
                    this.triggerTemporalEcho();
                    this.isFirstOpen = false;
                  });
                } else {
                  setTimeout(() => {
                    this.triggerTemporalEcho();
                    this.isFirstOpen = false;
                  }, 0);
                }
              }
            },
            { threshold: 0.1 }
          );
          this.visibilityObserver.observe(this.sidebarElement);
        }
        /**
         * Setup scroll observation with throttling for performance
         */
        setupScrollObservation() {
          if (!this.sidebarElement) return;
          const queueElement = this.sidebarElement.querySelector(
            ".main-nowPlayingView-queue"
          );
          if (!queueElement) return;
          queueElement.addEventListener(
            "scroll",
            this.throttledScrollHandler.bind(this),
            {
              passive: true
            }
          );
        }
        /**
         * Throttled scroll handler (≤30 Hz as specified)
         */
        throttledScrollHandler() {
          const now = performance.now();
          if (now - this.lastScrollUpdate < 33) return;
          this.lastScrollUpdate = now;
          if (window.requestIdleCallback) {
            window.requestIdleCallback(() => {
              this.queueUpdate("--sn-rs-scroll-ratio", Math.random().toString());
            }, { timeout: 100 });
          } else {
            this.queueUpdate("--sn-rs-scroll-ratio", Math.random().toString());
          }
        }
        /**
         * Filter mutations to only process changes that actually affect UI structure or visibility
         * Prevents cascade loops from CSS variable updates and other non-visual changes
         */
        isRelevantMutation(mutation) {
          if (mutation.type === "attributes") {
            const attrName = mutation.attributeName;
            if (attrName === "aria-hidden" || attrName === "style") {
              return true;
            }
            if (attrName === "class") {
              return true;
            }
            if (attrName?.startsWith("--") || attrName === "data-style") {
              return false;
            }
            return false;
          }
          if (mutation.type === "childList") {
            const hasElementChanges = mutation.addedNodes && Array.from(mutation.addedNodes).some((node) => node.nodeType === Node.ELEMENT_NODE) || mutation.removedNodes && Array.from(mutation.removedNodes).some((node) => node.nodeType === Node.ELEMENT_NODE);
            return hasElementChanges;
          }
          return false;
        }
        /**
         * Throttle DOM observation updates to reduce CPU overhead
         */
        throttleObservationUpdate(callback) {
          const now = performance.now();
          if (now - this.lastObservationTime < this.OBSERVATION_THROTTLE_MS) {
            if (this.observationThrottleTimer) {
              clearTimeout(this.observationThrottleTimer);
            }
            this.observationThrottleTimer = window.setTimeout(() => {
              callback();
              this.lastObservationTime = performance.now();
              this.observationThrottleTimer = null;
            }, this.OBSERVATION_THROTTLE_MS);
          } else {
            callback();
            this.lastObservationTime = now;
          }
        }
        /**
         * Handle visibility changes for temporal effects
         */
        handleVisibilityChange() {
          if (!this.sidebarElement) return;
          const isVisible = !this.sidebarElement.hasAttribute("aria-hidden") && !this.sidebarElement.style.display?.includes(
            "none"
          );
          if (isVisible && this.isFirstOpen) {
            this.triggerTemporalEcho();
            this.isFirstOpen = false;
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [SidebarPerformanceCoordinator] Visibility changed: ${isVisible ? "visible" : "hidden"}`
            );
          }
        }
        /**
         * Trigger one-time temporal echo effect
         */
        triggerTemporalEcho() {
          if (!this.sidebarElement) return;
          this.sidebarElement.classList.add("sn-future-preview");
          this.queueUpdate("--sn-kinetic-intensity", "1");
          this.queueUpdate("--sn-echo-hue-shift", "15deg");
          this.queueUpdate("--sn-echo-radius-multiplier", "1.2");
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceCoordinator] Triggering temporal echo effect"
            );
          }
          const cleanupTimeout = setTimeout(() => {
            this.sidebarElement?.classList.remove("sn-future-preview");
            this.queueUpdate("--sn-kinetic-intensity", "0");
            this.activeTimeouts.delete(cleanupTimeout);
          }, 2e3);
          this.activeTimeouts.add(cleanupTimeout);
        }
        /**
         * Get performance metrics for monitoring
         */
        getPerformanceMetrics() {
          return {
            flushCount: this.flushCount,
            averageFlushTime: this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0,
            lastFlushTimestamp: this.lastFlushTimestamp,
            pendingUpdates: this.pendingUpdates.size
          };
        }
        /**
         * Force immediate flush for critical scenarios
         */
        forceFlush() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
          this.flushUpdates();
        }
        /**
         * Cleanup and destroy coordinator
         */
        destroy() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
          this.activeTimeouts.forEach((timeout) => {
            clearTimeout(timeout);
          });
          this.activeTimeouts.clear();
          if (this.domObservationRetryTimeout) {
            clearTimeout(this.domObservationRetryTimeout);
            this.domObservationRetryTimeout = null;
          }
          if (this.observationThrottleTimer) {
            clearTimeout(this.observationThrottleTimer);
            this.observationThrottleTimer = null;
          }
          if (this.domObserver) {
            this.domObserver.disconnect();
            this.domObserver = null;
          }
          if (this.visibilityObserver) {
            this.visibilityObserver.disconnect();
            this.visibilityObserver = null;
          }
          if (this.musicChangeUnsubscribe) {
            this.musicChangeUnsubscribe();
            this.musicChangeUnsubscribe = null;
          }
          this.pendingUpdates.clear();
          this.isFlushScheduled = false;
          this.sidebarElement = null;
          if (_SidebarPerformanceCoordinator.instance === this) {
            _SidebarPerformanceCoordinator.instance = null;
          }
          if (this.config.enableDebug) {
            const avgFlushTime = this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0;
            console.log(
              `\u{1F30C} [SidebarPerformanceCoordinator] Destroyed. Performance: ${this.flushCount} flushes, ${avgFlushTime.toFixed(2)}ms avg`
            );
          }
        }
      };
      __name(_SidebarPerformanceCoordinator, "SidebarPerformanceCoordinator");
      _SidebarPerformanceCoordinator.instance = null;
      SidebarPerformanceCoordinator = _SidebarPerformanceCoordinator;
      __name(getSidebarPerformanceCoordinator, "getSidebarPerformanceCoordinator");
    }
  });

  // src-js/core/integration/SidebarSystemsIntegration.ts
  var _MockLeftSidebarConsciousnessSystem, MockLeftSidebarConsciousnessSystem, _MockRightSidebarConsciousnessSystem, MockRightSidebarConsciousnessSystem, _MockSidebarSystemsOrchestrator, MockSidebarSystemsOrchestrator, _SidebarSystemsIntegration, SidebarSystemsIntegration;
  var init_SidebarSystemsIntegration = __esm({
    "src-js/core/integration/SidebarSystemsIntegration.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_SidebarInteractiveFlowSystem();
      init_SidebarPerformanceCoordinator();
      init_globalConfig();
      _MockLeftSidebarConsciousnessSystem = class _MockLeftSidebarConsciousnessSystem extends UnifiedSystemBase {
        async initialize() {
          console.log("[MockLeftSidebarConsciousnessSystem] Initialized");
        }
        destroy() {
          console.log("[MockLeftSidebarConsciousnessSystem] Destroyed");
        }
        onAnimate(deltaTime) {
        }
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "Mock left sidebar consciousness healthy",
            issues: [],
            system: "MockLeftSidebarConsciousnessSystem"
          };
        }
        getConsciousnessState() {
          return { level: "aware", intensity: 0.5 };
        }
        getAnimationMetrics() {
          return { beatIntensity: 0.5, explorationLevel: 0.3 };
        }
      };
      __name(_MockLeftSidebarConsciousnessSystem, "MockLeftSidebarConsciousnessSystem");
      MockLeftSidebarConsciousnessSystem = _MockLeftSidebarConsciousnessSystem;
      _MockRightSidebarConsciousnessSystem = class _MockRightSidebarConsciousnessSystem extends UnifiedSystemBase {
        async initialize() {
          console.log("[MockRightSidebarConsciousnessSystem] Right sidebar now handled by facade pattern");
        }
        destroy() {
          console.log("[MockRightSidebarConsciousnessSystem] Destroyed");
        }
        onAnimate(deltaTime) {
        }
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "Right sidebar consciousness managed by facade pattern",
            issues: [],
            system: "MockRightSidebarConsciousnessSystem"
          };
        }
        getConsciousnessState() {
          const year3000System2 = globalThis.year3000System;
          if (year3000System2?.sidebarConsciousnessController) {
            return year3000System2.sidebarConsciousnessController.getConsciousnessState();
          }
          return { level: "aware", intensity: 0.5 };
        }
        getAnimationMetrics() {
          return { beatIntensity: 0.5, explorationLevel: 0.3 };
        }
      };
      __name(_MockRightSidebarConsciousnessSystem, "MockRightSidebarConsciousnessSystem");
      MockRightSidebarConsciousnessSystem = _MockRightSidebarConsciousnessSystem;
      _MockSidebarSystemsOrchestrator = class _MockSidebarSystemsOrchestrator extends UnifiedSystemBase {
        constructor() {
          super(...arguments);
          this.synchronizationEnabled = true;
          this.rightSidebarSystem = null;
        }
        async initialize() {
          console.log("[MockSidebarSystemsOrchestrator] Initialized");
        }
        destroy() {
          console.log("[MockSidebarSystemsOrchestrator] Destroyed");
        }
        onAnimate(deltaTime) {
        }
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "Mock sidebar orchestrator healthy",
            issues: [],
            system: "MockBilateralSidebarOrchestrator"
          };
        }
        getBilateralState() {
          return {
            leftSidebar: { active: true, level: "aware" },
            rightSidebar: { active: !!this.rightSidebarSystem, level: "aware" },
            synchronization: { enabled: this.synchronizationEnabled }
          };
        }
        getPerformanceMetrics() {
          return {
            bilateralSyncMetrics: { syncEvents: 100, avgSyncLatency: 5 },
            performanceMetrics: { totalCSSUpdates: 200, avgUpdateTime: 2 }
          };
        }
        setSynchronizationEnabled(enabled) {
          this.synchronizationEnabled = enabled;
        }
        setRightSidebarSystem(system) {
          this.rightSidebarSystem = system;
        }
      };
      __name(_MockSidebarSystemsOrchestrator, "MockSidebarSystemsOrchestrator");
      MockSidebarSystemsOrchestrator = _MockSidebarSystemsOrchestrator;
      _SidebarSystemsIntegration = class _SidebarSystemsIntegration extends UnifiedSystemBase {
        constructor(config = YEAR3000_CONFIG) {
          super(config);
          // System registry
          this.sidebarSystems = /* @__PURE__ */ new Map();
          // Integration state
          this.integrationEnabled = false;
          // Animation frame tracking
          this.lastFrameTime = 0;
          this.sharedCoordinator = SidebarPerformanceCoordinator.getInstance({
            enableDebug: config.enableDebug,
            performanceAnalyzer: this.performanceAnalyzer,
            onFlushComplete: /* @__PURE__ */ __name(() => this.handlePerformanceFlush(), "onFlushComplete")
          });
          this.leftSidebarConsciousness = new MockLeftSidebarConsciousnessSystem(config);
          this.rightSidebarConsciousness = new MockRightSidebarConsciousnessSystem(config);
          this.sidebarOrchestrator = new MockSidebarSystemsOrchestrator(config);
          this.interactiveFlow = new SidebarInteractiveFlowSystem(config);
          this.performanceMetrics = {
            totalSystems: 4,
            activeSystems: 0,
            bilateralSyncEnabled: false,
            averageFrameTime: 0,
            totalMemoryUsage: 0,
            healthStatus: "healthy"
          };
          if (config.enableDebug) {
            console.log(`[${this.systemName}] Initialized sidebar systems integration`);
          }
        }
        /**
         * Initialize all sidebar systems in proper order
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing sidebar systems integration`);
          }
          try {
            this.registerSidebarSystems();
            await this.registerWithUnifiedRegistry();
            await this.initializeSystemsInOrder();
            this.setupBilateralCoordination();
            this.connectToEventBus();
            this.integrateWithPerformanceSystems();
            this.registerAnimation(70);
            this.integrationEnabled = true;
            this.updatePerformanceMetrics();
            this.publishEvent("sidebar:integration-ready", {
              systemName: this.systemName,
              totalSystems: this.sidebarSystems.size,
              activeSystems: this.performanceMetrics.activeSystems,
              bilateralSync: this.performanceMetrics.bilateralSyncEnabled,
              timestamp: Date.now()
            });
          } catch (error) {
            console.error(`[${this.systemName}] Integration initialization failed:`, error);
            throw error;
          }
        }
        /**
         * Register all sidebar system definitions
         */
        registerSidebarSystems() {
          this.sidebarSystems.set("leftSidebarConsciousness", {
            name: "leftSidebarConsciousness",
            system: this.leftSidebarConsciousness,
            priority: "normal",
            enabled: true,
            dependencies: []
          });
          this.sidebarSystems.set("rightSidebarConsciousness", {
            name: "rightSidebarConsciousness",
            system: this.rightSidebarConsciousness,
            priority: "normal",
            enabled: true,
            dependencies: []
          });
          this.sidebarSystems.set("sidebarOrchestrator", {
            name: "sidebarOrchestrator",
            system: this.sidebarOrchestrator,
            priority: "critical",
            enabled: true,
            dependencies: ["leftSidebarConsciousness", "rightSidebarConsciousness"]
          });
          this.sidebarSystems.set("interactiveFlow", {
            name: "interactiveFlow",
            system: this.interactiveFlow,
            priority: "background",
            enabled: true,
            dependencies: ["sidebarOrchestrator"]
          });
        }
        /**
         * Initialize systems in dependency order
         */
        async initializeSystemsInOrder() {
          const initializationOrder = this.calculateInitializationOrder();
          for (const systemName of initializationOrder) {
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.enabled) {
              try {
                await systemDef.system._baseInitialize();
                this.performanceMetrics.activeSystems++;
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Initialized ${systemName}`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to initialize ${systemName}:`, error);
              }
            }
          }
        }
        /**
         * Calculate system initialization order based on dependencies
         */
        calculateInitializationOrder() {
          const visited = /* @__PURE__ */ new Set();
          const visiting = /* @__PURE__ */ new Set();
          const order = [];
          const visit = /* @__PURE__ */ __name((systemName) => {
            if (visiting.has(systemName)) {
              throw new Error(`Circular dependency detected: ${systemName}`);
            }
            if (visited.has(systemName)) return;
            visiting.add(systemName);
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.dependencies) {
              for (const dep of systemDef.dependencies) {
                visit(dep);
              }
            }
            visiting.delete(systemName);
            visited.add(systemName);
            order.push(systemName);
          }, "visit");
          for (const systemName of this.sidebarSystems.keys()) {
            visit(systemName);
          }
          return order;
        }
        /**
         * Set up bilateral consciousness coordination
         */
        setupBilateralCoordination() {
          this.sidebarOrchestrator.setRightSidebarSystem(this.rightSidebarConsciousness);
          this.sidebarOrchestrator.setSynchronizationEnabled(true);
          this.performanceMetrics.bilateralSyncEnabled = true;
          this.subscribeToEvent("sidebar:bilateral-sync", (payload) => {
            this.handleBilateralSync(payload);
          });
          this.subscribeToEvent("sidebar:consciousness-level-changed", (payload) => {
            this.handleConsciousnessChange(payload);
          });
        }
        /**
         * Handle bilateral synchronization events
         */
        handleBilateralSync(payload) {
          if (payload.source === "orchestrator") {
            this.updatePerformanceMetrics();
          }
        }
        /**
         * Handle consciousness level changes
         */
        handleConsciousnessChange(payload) {
          const consciousnessLevels = {
            dormant: 0.5,
            aware: 0.7,
            focused: 0.9,
            transcendent: 1
          };
          const performanceLevel = consciousnessLevels[payload.newLevel] || 0.7;
          this.adjustPerformanceBudgets(performanceLevel);
        }
        /**
         * Adjust performance budgets based on consciousness level
         */
        adjustPerformanceBudgets(level) {
          const baseBudget = 16;
          const adjustedBudget = Math.floor(baseBudget * level);
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Adjusted performance budget to ${adjustedBudget} based on consciousness level`);
          }
        }
        /**
         * Handle performance flush completion
         */
        handlePerformanceFlush() {
          const currentTime = performance.now();
          if (this.lastFrameTime > 0) {
            const frameTime = currentTime - this.lastFrameTime;
            this.performanceMetrics.averageFrameTime = (this.performanceMetrics.averageFrameTime + frameTime) / 2;
          }
          this.lastFrameTime = currentTime;
          this.updateHealthStatus();
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics() {
          this.performanceMetrics.totalSystems = this.sidebarSystems.size;
          let activeSystems = 0;
          for (const [, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              activeSystems++;
            }
          }
          this.performanceMetrics.activeSystems = activeSystems;
          this.performanceMetrics.bilateralSyncEnabled = this.sidebarOrchestrator.getBilateralState().synchronization.enabled;
        }
        /**
         * Update health status based on performance metrics
         */
        updateHealthStatus() {
          if (this.performanceMetrics.averageFrameTime > 20) {
            this.performanceMetrics.healthStatus = "critical";
          } else if (this.performanceMetrics.averageFrameTime > 16.67) {
            this.performanceMetrics.healthStatus = "degraded";
          } else {
            this.performanceMetrics.healthStatus = "healthy";
          }
        }
        /**
         * Animation frame callback
         */
        onAnimate(deltaTime) {
          if (!this.integrationEnabled) return;
          this.updatePerformanceMetrics();
          this.updateHealthStatus();
          const currentTime = performance.now();
          if (currentTime - this.lastFrameTime > 1e3) {
            this.publishEvent("sidebar:integration-metrics", {
              metrics: this.performanceMetrics,
              timestamp: Date.now()
            });
          }
        }
        /**
         * Register all sidebar systems with Year3000System animation coordinator
         */
        registerWithAnimationCoordinator(animationCoordinator) {
          if (!animationCoordinator) {
            console.warn(`[${this.systemName}] Animation coordinator not available`);
            return;
          }
          for (const [systemName, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              try {
                animationCoordinator.registerAnimationSystem(
                  systemName,
                  systemDef.system,
                  systemDef.priority,
                  60
                  // Default FPS
                );
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Registered ${systemName} with animation coordinator`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to register ${systemName}:`, error);
              }
            }
          }
        }
        /**
         * Get all sidebar systems for external access
         */
        getSidebarSystems() {
          return new Map(this.sidebarSystems);
        }
        /**
         * Get performance metrics
         */
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Enable/disable specific sidebar system
         */
        setSidebarSystemEnabled(systemName, enabled) {
          const systemDef = this.sidebarSystems.get(systemName);
          if (systemDef) {
            systemDef.enabled = enabled;
            if (!enabled && systemDef.system.isInitialized) {
              systemDef.system._baseDestroy();
              this.performanceMetrics.activeSystems--;
            } else if (enabled && !systemDef.system.isInitialized) {
              systemDef.system._baseInitialize().catch((error) => {
                console.error(`[${this.systemName}] Failed to re-enable ${systemName}:`, error);
              });
            }
            this.publishEvent("sidebar:system-toggled", {
              systemName,
              enabled,
              timestamp: Date.now()
            });
          }
        }
        /**
         * System health check
         */
        async healthCheck() {
          const systemHealthChecks = {};
          for (const [systemName, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              try {
                systemHealthChecks[systemName] = await systemDef.system.healthCheck();
              } catch (error) {
                systemHealthChecks[systemName] = {
                  healthy: false,
                  ok: false,
                  details: `Health check failed: ${error.message}`,
                  issues: [`Health check failed: ${error.message}`],
                  system: systemName
                };
              }
            }
          }
          const unhealthySystems = Object.values(systemHealthChecks).filter((check) => !check.ok);
          const isHealthy = unhealthySystems.length === 0;
          return {
            healthy: isHealthy,
            ok: isHealthy,
            details: `Sidebar integration ${isHealthy ? "healthy" : "degraded"} - ${this.performanceMetrics.activeSystems}/${this.performanceMetrics.totalSystems} systems active, bilateral sync: ${this.performanceMetrics.bilateralSyncEnabled}`,
            issues: unhealthySystems.map((check) => check.details || "Unknown issue"),
            system: "SidebarSystemsIntegration"
          };
        }
        /**
         * Phase 3: Register sidebar systems with facade (UnifiedSystemRegistry is deprecated)
         */
        async registerWithUnifiedRegistry() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Sidebar systems are now managed by VisualSystemFacade`);
          }
        }
        /**
         * Phase 3: Connect to EventBus for system-wide communication
         */
        connectToEventBus() {
          this.subscribeToEvent("music:beat", (payload) => {
            this.handleMusicBeat(payload);
          });
          this.subscribeToEvent("music:energy", (payload) => {
            this.handleMusicEnergy(payload);
          });
          this.subscribeToEvent("performance:threshold-exceeded", (payload) => {
            this.handlePerformanceThreshold(payload);
          });
          this.subscribeToEvent("user:navigation", (payload) => {
            this.handleUserNavigation(payload);
          });
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Connected to EventBus for system-wide communication`);
          }
        }
        /**
         * Phase 3: Integrate with TimerConsolidationSystem and MasterAnimationCoordinator
         */
        integrateWithPerformanceSystems() {
          const year3000System2 = globalThis.year3000System;
          if (!year3000System2) {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Year3000System not available, skipping performance integration`);
            }
            return;
          }
          try {
            const timerSystem = year3000System2.timerConsolidationSystem;
            if (timerSystem) {
              timerSystem.registerTimer("sidebar-performance-monitor", 1e3, () => {
                this.updatePerformanceMetrics();
              });
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Integrated with TimerConsolidationSystem`);
              }
            }
            const animationCoordinator = year3000System2.enhancedMasterAnimationCoordinator;
            if (animationCoordinator) {
              animationCoordinator.registerFrameCallback(
                (deltaTime, timestamp) => {
                  this.bilateralConsciousnessFrameUpdate(deltaTime, timestamp);
                },
                "critical",
                "sidebar-bilateral-consciousness"
              );
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Integrated with EnhancedMasterAnimationCoordinator`);
              }
            }
          } catch (error) {
            console.error(`[${this.systemName}] Failed to integrate with performance systems:`, error);
          }
        }
        /**
         * Handle music beat events for consciousness synchronization
         */
        handleMusicBeat(payload) {
          if (!this.integrationEnabled) return;
          const beatData = {
            intensity: payload.intensity || 0.5,
            timestamp: payload.timestamp || Date.now(),
            bpm: payload.bpm || 120
          };
          this.sidebarOrchestrator.getBilateralState();
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Processed music beat:`, beatData);
          }
        }
        /**
         * Handle music energy changes for adaptive consciousness
         */
        handleMusicEnergy(payload) {
          if (!this.integrationEnabled) return;
          const energyLevel = payload.energy || 0.5;
          this.adjustPerformanceBudgets(0.5 + energyLevel * 0.5);
          if (this.interactiveFlow.isInitialized) {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Adapted consciousness to energy level: ${energyLevel}`);
            }
          }
        }
        /**
         * Handle performance threshold events
         */
        handlePerformanceThreshold(payload) {
          if (!this.integrationEnabled) return;
          if (payload.severity === "critical") {
            this.setSidebarSystemEnabled("interactiveFlow", false);
            this.performanceMetrics.healthStatus = "critical";
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Activated emergency performance mode`);
            }
          } else if (payload.severity === "warning" && this.performanceMetrics.healthStatus === "critical") {
            setTimeout(() => {
              this.setSidebarSystemEnabled("interactiveFlow", true);
            }, 2e3);
            this.performanceMetrics.healthStatus = "degraded";
          }
        }
        /**
         * Handle user navigation events for predictive consciousness
         */
        handleUserNavigation(payload) {
          if (!this.integrationEnabled) return;
          const navigationContext = {
            action: payload.action || "navigate",
            target: payload.target || "unknown",
            timestamp: payload.timestamp || Date.now()
          };
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Processing navigation context:`, navigationContext);
          }
        }
        /**
         * Bilateral consciousness frame update callback
         */
        bilateralConsciousnessFrameUpdate(deltaTime, timestamp) {
          if (!this.integrationEnabled) return;
          const leftState = this.leftSidebarConsciousness.getConsciousnessState();
          const rightState = this.rightSidebarConsciousness.getConsciousnessState();
          const leftTimestamp = timestamp;
          const rightTimestamp = timestamp;
          const syncMetrics = {
            leftLevel: leftState.level,
            rightLevel: rightState.level,
            timingDelta: Math.abs(leftTimestamp - rightTimestamp),
            frameTime: deltaTime
          };
          if (syncMetrics.timingDelta > 16.67) {
            this.publishEvent("sidebar:bilateral-desync-warning", {
              delta: syncMetrics.timingDelta,
              frameTime: deltaTime,
              timestamp
            });
          }
        }
        /**
         * Clean up all sidebar systems
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying sidebar systems integration`);
          }
          this.integrationEnabled = false;
          const year3000System2 = globalThis.year3000System;
          if (year3000System2?.timerConsolidationSystem) {
            year3000System2.timerConsolidationSystem.unregisterTimer("sidebar-performance-monitor");
          }
          const destructionOrder = this.calculateInitializationOrder().reverse();
          for (const systemName of destructionOrder) {
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.system.isInitialized) {
              try {
                systemDef.system._baseDestroy();
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Destroyed ${systemName}`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to destroy ${systemName}:`, error);
              }
            }
          }
          this.sidebarSystems.clear();
          this.performanceMetrics = {
            totalSystems: 0,
            activeSystems: 0,
            bilateralSyncEnabled: false,
            averageFrameTime: 0,
            totalMemoryUsage: 0,
            healthStatus: "healthy"
          };
          this.publishEvent("sidebar:integration-destroyed", {
            timestamp: Date.now()
          });
        }
      };
      __name(_SidebarSystemsIntegration, "SidebarSystemsIntegration");
      SidebarSystemsIntegration = _SidebarSystemsIntegration;
    }
  });

  // src-js/types/systemCreationStrategy.ts
  var _SystemCreationError, SystemCreationError, _DependencyValidationError, DependencyValidationError, _StrategySelectionError, StrategySelectionError;
  var init_systemCreationStrategy = __esm({
    "src-js/types/systemCreationStrategy.ts"() {
      "use strict";
      _SystemCreationError = class _SystemCreationError extends Error {
        constructor(message, systemKey, strategy, context, cause) {
          super(message);
          this.systemKey = systemKey;
          this.strategy = strategy;
          this.context = context;
          this.cause = cause;
          this.name = "SystemCreationError";
        }
      };
      __name(_SystemCreationError, "SystemCreationError");
      SystemCreationError = _SystemCreationError;
      _DependencyValidationError = class _DependencyValidationError extends SystemCreationError {
        constructor(systemKey, strategy, missingDependencies, context) {
          super(
            `Missing required dependencies for ${systemKey}: ${missingDependencies.join(", ")}`,
            systemKey,
            strategy,
            context
          );
          this.missingDependencies = missingDependencies;
          this.name = "DependencyValidationError";
        }
      };
      __name(_DependencyValidationError, "DependencyValidationError");
      DependencyValidationError = _DependencyValidationError;
      _StrategySelectionError = class _StrategySelectionError extends Error {
        constructor(systemKey, criteria, message = `No suitable creation strategy found for system: ${systemKey}`) {
          super(message);
          this.systemKey = systemKey;
          this.criteria = criteria;
          this.name = "StrategySelectionError";
        }
      };
      __name(_StrategySelectionError, "StrategySelectionError");
      StrategySelectionError = _StrategySelectionError;
    }
  });

  // src-js/core/creation/SystemCreationStrategies.ts
  var _BaseCreationStrategy, BaseCreationStrategy, _StandardConstructorStrategy, StandardConstructorStrategy, _EventDrivenCreationStrategy, EventDrivenCreationStrategy, _ObjectDependenciesStrategy, ObjectDependenciesStrategy, _SystemCreationStrategyRegistry, SystemCreationStrategyRegistry, globalSystemCreationRegistry;
  var init_SystemCreationStrategies = __esm({
    "src-js/core/creation/SystemCreationStrategies.ts"() {
      "use strict";
      init_EventBus();
      init_UnifiedDebugManager();
      init_systemCreationStrategy();
      _BaseCreationStrategy = class _BaseCreationStrategy {
        constructor() {
          this.systemConfigs = /* @__PURE__ */ new Map();
        }
        /**
         * Validate dependencies before creation
         */
        validateDependencies(context) {
          const required = this.getRequiredDependencies(context.systemKey);
          const optional = this.getOptionalDependencies(context.systemKey);
          const missing = [];
          const warnings = [];
          for (const dep of required) {
            if (!(dep in context.dependencies) || !context.dependencies[dep]) {
              missing.push(dep);
            }
          }
          for (const dep of optional) {
            if (!(dep in context.dependencies) || !context.dependencies[dep]) {
              warnings.push(`Optional dependency missing: ${dep}`);
            }
          }
          return {
            valid: missing.length === 0,
            missing,
            warnings
          };
        }
        /**
         * Get required dependencies for system
         */
        getRequiredDependencies(systemKey) {
          const config = this.systemConfigs.get(systemKey);
          return config?.requiredDependencies || [];
        }
        /**
         * Get optional dependencies for system
         */
        getOptionalDependencies(systemKey) {
          const config = this.systemConfigs.get(systemKey);
          return config?.optionalDependencies || [];
        }
        /**
         * Register system configuration
         */
        registerSystemConfig(config) {
          this.systemConfigs.set(config.systemKey, config);
        }
        /**
         * Create base result structure
         */
        createBaseResult(system, context, startTime, error) {
          const endTime = performance.now();
          const creationTime = endTime - startTime;
          return {
            system,
            success: !error && system !== null,
            creationTime,
            strategy: this.getStrategyName(),
            injectedDependencies: Object.keys(context.dependencies),
            warnings: [],
            error: error || void 0,
            metadata: {
              requiresInitialization: true,
              pendingDependencies: [],
              context
            }
          };
        }
      };
      __name(_BaseCreationStrategy, "BaseCreationStrategy");
      BaseCreationStrategy = _BaseCreationStrategy;
      _StandardConstructorStrategy = class _StandardConstructorStrategy extends BaseCreationStrategy {
        constructor() {
          super();
          this.registerKnownSystems();
        }
        getStrategyName() {
          return "StandardConstructor";
        }
        canCreate(context) {
          const config = this.systemConfigs.get(context.systemKey);
          return config !== void 0 && !config.creationPreferences.eventDriven;
        }
        getEstimatedCreationTime(context) {
          return 10;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const validation = this.validateDependencies(context);
            if (!validation.valid && context.preferences.validateDependencies !== false) {
              throw new DependencyValidationError(
                context.systemKey,
                this.getStrategyName(),
                validation.missing,
                context
              );
            }
            const params = this.getConstructorParameters(context);
            const system = new SystemClass(...params);
            const result = this.createBaseResult(system, context, startTime);
            result.warnings = validation.warnings;
            Y3K?.debug?.log("StandardConstructorStrategy", `Created ${context.systemKey}`, {
              creationTime: result.creationTime,
              parametersUsed: params.length
            });
            return result;
          } catch (error) {
            const result = this.createBaseResult(null, context, startTime, error);
            Y3K?.debug?.error("StandardConstructorStrategy", `Failed to create ${context.systemKey}:`, error);
            return result;
          }
        }
        /**
         * Get constructor parameters based on system configuration
         */
        getConstructorParameters(context) {
          const config = this.systemConfigs.get(context.systemKey);
          if (!config?.constructorMapping) {
            return this.getStandardParameters(context);
          }
          const params = [];
          const { parameterNames, dependencyMapping } = config.constructorMapping;
          for (const paramName of parameterNames) {
            const depKey = dependencyMapping[paramName] || paramName;
            switch (depKey) {
              case "config":
                params.push(context.config);
                break;
              case "utils":
                params.push(context.utils);
                break;
              case "performanceAnalyzer":
                params.push(context.dependencies.performanceAnalyzer);
                break;
              case "settingsManager":
                params.push(context.dependencies.settingsManager);
                break;
              case "musicSyncService":
                params.push(context.dependencies.musicSyncService);
                break;
              case "year3000System":
                params.push(context.dependencies.year3000System);
                break;
              case "cssConsciousnessController":
                params.push(context.dependencies.cssConsciousnessController);
                break;
              case "performanceCoordinator":
                params.push(context.dependencies.performanceCoordinator);
                break;
              default:
                params.push(void 0);
            }
          }
          return params;
        }
        /**
         * Get standard parameters for systems without explicit configuration
         */
        getStandardParameters(context) {
          return [
            context.config,
            context.utils,
            context.dependencies.performanceAnalyzer,
            context.dependencies.musicSyncService,
            context.dependencies.settingsManager,
            context.dependencies.year3000System
          ];
        }
        /**
         * Register known system configurations
         */
        registerKnownSystems() {
          this.registerSystemConfig({
            systemKey: "ColorHarmonyEngine",
            requiredDependencies: ["config", "utils", "performanceAnalyzer", "settingsManager"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "utils", "performanceAnalyzer", "settingsManager"],
              dependencyMapping: {
                "config": "config",
                "utils": "utils",
                "performanceAnalyzer": "performanceAnalyzer",
                "settingsManager": "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "EnhancedMasterAnimationCoordinator",
            requiredDependencies: ["config", "performanceCoordinator"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "performanceCoordinator"],
              dependencyMapping: {
                "config": "config",
                "performanceCoordinator": "performanceCoordinator"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedPerformanceCoordinator",
            requiredDependencies: ["config"],
            optionalDependencies: ["performanceAnalyzer"],
            constructorMapping: {
              parameterNames: ["config", "performanceAnalyzer"],
              dependencyMapping: {
                "config": "config",
                "performanceAnalyzer": "performanceAnalyzer"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          const simpleSystemKeys = [
            "DeviceCapabilityDetector",
            "PerformanceAnalyzer",
            "SettingsManager"
          ];
          for (const systemKey of simpleSystemKeys) {
            this.registerSystemConfig({
              systemKey,
              requiredDependencies: [],
              optionalDependencies: [],
              constructorMapping: {
                parameterNames: [],
                dependencyMapping: {}
              },
              creationPreferences: {
                useSingleton: false,
                lazyInit: false,
                eventDriven: false,
                builderPattern: false
              }
            });
          }
          this.registerSystemConfig({
            systemKey: "TimerConsolidationSystem",
            requiredDependencies: [],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [],
              dependencyMapping: {}
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "GlassmorphismManager",
            requiredDependencies: ["config", "utils", "cssConsciousnessController", "performanceAnalyzer", "settingsManager"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "utils", "cssConsciousnessController", "performanceAnalyzer", "settingsManager"],
              dependencyMapping: {
                "config": "config",
                "utils": "utils",
                "cssConsciousnessController": "cssConsciousnessController",
                "performanceAnalyzer": "performanceAnalyzer",
                "settingsManager": "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "Card3DManager",
            requiredDependencies: ["performanceAnalyzer", "settingsManager", "utils"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["performanceAnalyzer", "settingsManager", "utils"],
              dependencyMapping: {
                "performanceAnalyzer": "performanceAnalyzer",
                "settingsManager": "settingsManager",
                "utils": "utils"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedCSSConsciousnessController",
            requiredDependencies: ["config", "performanceCoordinator"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "performanceCoordinator"],
              dependencyMapping: {
                "config": "config",
                "performanceCoordinator": "performanceCoordinator"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "SidebarSystemsIntegration",
            requiredDependencies: ["cssConsciousnessController"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["cssConsciousnessController"],
              dependencyMapping: {
                "cssConsciousnessController": "cssConsciousnessController"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedSystemIntegration",
            requiredDependencies: ["year3000System"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["year3000System"],
              dependencyMapping: {
                "year3000System": "year3000System"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
        }
      };
      __name(_StandardConstructorStrategy, "StandardConstructorStrategy");
      StandardConstructorStrategy = _StandardConstructorStrategy;
      _EventDrivenCreationStrategy = class _EventDrivenCreationStrategy extends BaseCreationStrategy {
        getStrategyName() {
          return "EventDriven";
        }
        canCreate(context) {
          const config = this.systemConfigs.get(context.systemKey);
          return config?.creationPreferences.eventDriven === true;
        }
        getEstimatedCreationTime(context) {
          return 50;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const standardStrategy = new StandardConstructorStrategy();
            const standardResult = await standardStrategy.createSystem(SystemClass, context);
            if (!standardResult.success) {
              return standardResult;
            }
            this.setupEventSubscriptions(standardResult.system, context);
            const result = this.createBaseResult(standardResult.system, context, startTime);
            result.warnings = standardResult.warnings;
            Y3K?.debug?.log("EventDrivenCreationStrategy", `Created ${context.systemKey} with event subscriptions`);
            return result;
          } catch (error) {
            const result = this.createBaseResult(null, context, startTime, error);
            Y3K?.debug?.error("EventDrivenCreationStrategy", `Failed to create ${context.systemKey}:`, error);
            return result;
          }
        }
        /**
         * Setup event subscriptions during creation
         */
        setupEventSubscriptions(system, context) {
          const eventSubscriptions = this.getEventSubscriptions(context.systemKey);
          for (const eventType of eventSubscriptions) {
            if (typeof system.handleEvent === "function") {
              GlobalEventBus.subscribe(eventType, (event) => {
                system.handleEvent(event);
              });
            } else if (typeof system.handleColorExtraction === "function" && eventType === "colors/extracted") {
              GlobalEventBus.subscribe(eventType, system.handleColorExtraction.bind(system));
            }
          }
          Y3K?.debug?.log(
            "EventDrivenCreationStrategy",
            `Setup event subscriptions for ${context.systemKey}:`,
            eventSubscriptions
          );
        }
        /**
         * Get events that system will subscribe to
         */
        getEventSubscriptions(systemKey) {
          const config = this.systemConfigs.get(systemKey);
          return config?.eventSubscriptions || [];
        }
      };
      __name(_EventDrivenCreationStrategy, "EventDrivenCreationStrategy");
      EventDrivenCreationStrategy = _EventDrivenCreationStrategy;
      _ObjectDependenciesStrategy = class _ObjectDependenciesStrategy extends BaseCreationStrategy {
        constructor() {
          super();
          this.registerObjectDependencySystems();
        }
        getStrategyName() {
          return "ObjectDependencies";
        }
        canCreate(context) {
          return context.systemKey === "MusicSyncService";
        }
        getEstimatedCreationTime(context) {
          return 30;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const validation = this.validateDependencies(context);
            if (!validation.valid && context.preferences.validateDependencies !== false) {
              throw new DependencyValidationError(
                context.systemKey,
                this.getStrategyName(),
                validation.missing,
                context
              );
            }
            const dependencies = {
              YEAR3000_CONFIG: context.config,
              Year3000Utilities: context.utils,
              settingsManager: context.dependencies.settingsManager,
              year3000System: context.dependencies.year3000System
              // NOTE: colorHarmonyEngine deliberately omitted - using event-driven pattern instead
            };
            const system = new SystemClass(dependencies);
            const result = this.createBaseResult(system, context, startTime);
            result.warnings = validation.warnings;
            result.metadata.pendingDependencies = [];
            Y3K?.debug?.log("ObjectDependenciesStrategy", `Created ${context.systemKey} with event-driven dependencies`);
            return result;
          } catch (error) {
            const result = this.createBaseResult(null, context, startTime, error);
            Y3K?.debug?.error("ObjectDependenciesStrategy", `Failed to create ${context.systemKey}:`, error);
            return result;
          }
        }
        /**
         * Register systems that use object dependencies
         */
        registerObjectDependencySystems() {
          this.registerSystemConfig({
            systemKey: "MusicSyncService",
            requiredDependencies: ["config", "utils"],
            optionalDependencies: ["settingsManager", "year3000System"],
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
        }
      };
      __name(_ObjectDependenciesStrategy, "ObjectDependenciesStrategy");
      ObjectDependenciesStrategy = _ObjectDependenciesStrategy;
      _SystemCreationStrategyRegistry = class _SystemCreationStrategyRegistry {
        constructor() {
          this.strategies = /* @__PURE__ */ new Map();
          this.registerDefaultStrategies();
        }
        /**
         * Register a creation strategy
         */
        register(strategy) {
          this.strategies.set(strategy.getStrategyName(), strategy);
          Y3K?.debug?.log("SystemCreationStrategyRegistry", `Registered strategy: ${strategy.getStrategyName()}`);
        }
        /**
         * Select best strategy for given criteria
         */
        selectStrategy(systemKey, criteria) {
          const candidateStrategies = this.getStrategiesForSystem(systemKey);
          if (candidateStrategies.length === 0) {
            return null;
          }
          let bestStrategy = candidateStrategies[0];
          if (!bestStrategy) {
            return null;
          }
          let bestScore = this.scoreStrategy(bestStrategy, systemKey, criteria);
          for (let i = 1; i < candidateStrategies.length; i++) {
            const strategy = candidateStrategies[i];
            if (!strategy) continue;
            const score = this.scoreStrategy(strategy, systemKey, criteria);
            if (score > bestScore) {
              bestStrategy = strategy;
              bestScore = score;
            }
          }
          return bestStrategy;
        }
        /**
         * Get all registered strategies
         */
        getStrategies() {
          return Array.from(this.strategies.values());
        }
        /**
         * Get strategy by name
         */
        getStrategy(name) {
          return this.strategies.get(name) || null;
        }
        /**
         * Get strategies that can create a specific system
         */
        getStrategiesForSystem(systemKey) {
          const context = {
            systemKey,
            config: {},
            utils: {},
            dependencies: {},
            preferences: {},
            metadata: {
              timestamp: Date.now(),
              reason: "startup",
              priority: "medium"
            }
          };
          return this.getStrategies().filter((strategy) => strategy.canCreate(context));
        }
        /**
         * Score strategy based on selection criteria
         */
        scoreStrategy(strategy, systemKey, criteria) {
          let score = 0;
          score += 10;
          if (criteria.dependencyRequirements === "event-driven") {
            if (strategy.getStrategyName() === "EventDriven") score += 20;
            if (strategy.getStrategyName() === "ObjectDependencies") score += 15;
          } else if (criteria.dependencyRequirements === "basic") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 20;
          }
          if (criteria.performance === "lightweight") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 15;
          } else if (criteria.performance === "optimized") {
            if (strategy.getStrategyName() === "EventDriven") score += 10;
          }
          if (criteria.creationContext === "startup") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 5;
          }
          return score;
        }
        /**
         * Register default strategies
         */
        registerDefaultStrategies() {
          this.register(new StandardConstructorStrategy());
          this.register(new EventDrivenCreationStrategy());
          this.register(new ObjectDependenciesStrategy());
        }
        /**
         * Get registry status
         */
        getStatus() {
          return {
            strategyCount: this.strategies.size,
            strategies: Array.from(this.strategies.keys())
          };
        }
      };
      __name(_SystemCreationStrategyRegistry, "SystemCreationStrategyRegistry");
      SystemCreationStrategyRegistry = _SystemCreationStrategyRegistry;
      globalSystemCreationRegistry = new SystemCreationStrategyRegistry();
    }
  });

  // src-js/core/creation/StrategyBasedFactory.ts
  var _StrategyBasedFactory, StrategyBasedFactory, globalStrategyBasedFactory;
  var init_StrategyBasedFactory = __esm({
    "src-js/core/creation/StrategyBasedFactory.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_SystemCreationStrategies();
      init_systemCreationStrategy();
      _StrategyBasedFactory = class _StrategyBasedFactory {
        constructor(strategyRegistry) {
          this.systemConfigs = /* @__PURE__ */ new Map();
          this.creationMetrics = {
            totalCreations: 0,
            successfulCreations: 0,
            averageCreationTime: 0,
            strategyUsage: {}
          };
          this.strategyRegistry = strategyRegistry || globalSystemCreationRegistry;
          Y3K?.debug?.log("StrategyBasedFactory", "Factory initialized with strategy registry");
        }
        /**
         * Create system using best available strategy
         */
        async createSystem(systemKey, SystemClass, context) {
          const startTime = performance.now();
          try {
            this.creationMetrics.totalCreations++;
            const systemConfig = this.getSystemConfig(systemKey);
            const criteria = this.buildSelectionCriteria(systemKey, systemConfig, context);
            const strategy = this.strategyRegistry.selectStrategy(systemKey, criteria);
            if (!strategy) {
              throw new StrategySelectionError(systemKey, criteria);
            }
            const strategyName = strategy.getStrategyName();
            this.creationMetrics.strategyUsage[strategyName] = (this.creationMetrics.strategyUsage[strategyName] || 0) + 1;
            const result = await strategy.createSystem(SystemClass, context);
            if (result.success) {
              this.creationMetrics.successfulCreations++;
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            this.updateAverageCreationTime(totalTime);
            Y3K?.debug?.log("StrategyBasedFactory", `Created ${systemKey} using ${strategyName}`, {
              success: result.success,
              creationTime: result.creationTime,
              totalTime
            });
            return result;
          } catch (error) {
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            Y3K?.debug?.error("StrategyBasedFactory", `Failed to create ${systemKey}:`, error);
            return {
              system: null,
              success: false,
              creationTime: totalTime,
              strategy: "unknown",
              injectedDependencies: [],
              warnings: [],
              error,
              metadata: {
                requiresInitialization: false,
                pendingDependencies: [],
                context
              }
            };
          }
        }
        /**
         * Register system creation configuration
         */
        registerSystemConfig(config) {
          this.systemConfigs.set(config.systemKey, config);
          Y3K?.debug?.log("StrategyBasedFactory", `Registered config for ${config.systemKey}`);
        }
        /**
         * Get system creation configuration
         */
        getSystemConfig(systemKey) {
          return this.systemConfigs.get(systemKey) || null;
        }
        /**
         * Update creation strategy registry
         */
        setStrategyRegistry(registry2) {
          this.strategyRegistry = registry2;
          Y3K?.debug?.log("StrategyBasedFactory", "Strategy registry updated");
        }
        /**
         * Get factory performance metrics
         */
        getMetrics() {
          return { ...this.creationMetrics };
        }
        /**
         * Reset performance metrics
         */
        resetMetrics() {
          this.creationMetrics = {
            totalCreations: 0,
            successfulCreations: 0,
            averageCreationTime: 0,
            strategyUsage: {}
          };
        }
        // ============================================================================
        // Private Helper Methods
        // ============================================================================
        /**
         * Build selection criteria based on system key and context
         * No longer relies on factory's own systemConfig - strategies manage their own configurations
         */
        buildSelectionCriteria(systemKey, systemConfig, context) {
          let complexity = "medium";
          const simpleSystems = [
            "DeviceCapabilityDetector",
            "PerformanceAnalyzer",
            "UnifiedCSSConsciousnessController",
            "SettingsManager",
            "TimerConsolidationSystem"
          ];
          const complexSystems = [
            "GlassmorphismManager",
            "Card3DManager",
            "UnifiedCSSConsciousnessController",
            "EnhancedMasterAnimationCoordinator"
          ];
          if (simpleSystems.includes(systemKey)) {
            complexity = "simple";
          } else if (complexSystems.includes(systemKey)) {
            complexity = "complex";
          }
          let dependencyRequirements = "basic";
          if (systemKey === "MusicSyncService" || systemKey === "ColorHarmonyEngine") {
            dependencyRequirements = "event-driven";
          } else if (simpleSystems.includes(systemKey)) {
            dependencyRequirements = "none";
          }
          let performance2 = "standard";
          if (context.metadata.priority === "critical") {
            performance2 = "optimized";
          } else if (context.preferences.monitorCreation) {
            performance2 = "optimized";
          } else if (complexity === "simple") {
            performance2 = "lightweight";
          }
          return {
            complexity,
            dependencyRequirements,
            performance: performance2,
            resourceConstraints: {
              memoryLimited: context.metadata.resourceConstraints?.maxMemoryMB !== void 0,
              timeLimited: context.metadata.resourceConstraints?.maxInitTimeMs !== void 0,
              cpuLimited: context.metadata.priority === "low"
            },
            creationContext: context.metadata.reason
          };
        }
        /**
         * Update running average creation time
         */
        updateAverageCreationTime(newTime) {
          const totalCreations = this.creationMetrics.totalCreations;
          const currentAverage = this.creationMetrics.averageCreationTime;
          this.creationMetrics.averageCreationTime = (currentAverage * (totalCreations - 1) + newTime) / totalCreations;
        }
        /**
         * Register default system configurations for known systems
         * DEPRECATED: System configurations are now managed by individual strategies
         */
        registerDefaultSystemConfigs() {
        }
      };
      __name(_StrategyBasedFactory, "StrategyBasedFactory");
      StrategyBasedFactory = _StrategyBasedFactory;
      globalStrategyBasedFactory = new StrategyBasedFactory();
    }
  });

  // src-js/core/integration/FacadeAdapter.ts
  var _NonVisualSystemFacadeAdapter, NonVisualSystemFacadeAdapter, globalFacadeAdapter;
  var init_FacadeAdapter = __esm({
    "src-js/core/integration/FacadeAdapter.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_StrategyBasedFactory();
      _NonVisualSystemFacadeAdapter = class _NonVisualSystemFacadeAdapter {
        constructor(strategyBasedFactory) {
          this.adapted = false;
          this.originalFacade = null;
          this.migrationProgress = 0;
          this.systemsUsingStrategy = /* @__PURE__ */ new Set();
          this.systemsUsingLegacy = /* @__PURE__ */ new Set();
          this.strategyBasedFactory = strategyBasedFactory || globalStrategyBasedFactory;
          Y3K?.debug?.log("NonVisualSystemFacadeAdapter", "Facade adapter initialized");
        }
        /**
         * Adapt facade to use strategy-based creation
         */
        adaptToStrategyPattern(factory) {
          this.strategyBasedFactory = factory;
          this.adapted = true;
          this.migrationProgress = 1;
          Y3K?.debug?.log("NonVisualSystemFacadeAdapter", "Facade adapted to strategy pattern");
        }
        /**
         * Get migration status
         */
        getMigrationStatus() {
          return {
            adapted: this.adapted,
            systemsUsingStrategyPattern: Array.from(this.systemsUsingStrategy),
            systemsUsingLegacyPattern: Array.from(this.systemsUsingLegacy),
            migrationProgress: this.migrationProgress
          };
        }
        /**
         * Complete migration to strategy pattern
         */
        async completeMigration() {
          if (!this.adapted) {
            this.adaptToStrategyPattern(this.strategyBasedFactory);
          }
          this.migrationProgress = 1;
          this.systemsUsingLegacy.clear();
          Y3K?.debug?.log("NonVisualSystemFacadeAdapter", "Migration to strategy pattern completed");
        }
        /**
         * Create system using strategy-based factory (replaces hardcoded constructor logic)
         */
        async createSystemWithStrategy(systemKey, SystemClass, context) {
          const creationContext = {
            systemKey,
            config: context.config,
            utils: context.utils,
            dependencies: context.dependencies,
            preferences: {
              lazyInit: false,
              validateDependencies: true,
              creationTimeout: 5e3,
              monitorCreation: true
            },
            metadata: {
              timestamp: Date.now(),
              reason: "startup",
              priority: "medium",
              resourceConstraints: {
                maxMemoryMB: 50,
                maxInitTimeMs: 1e3
              }
            }
          };
          try {
            const result = await this.strategyBasedFactory.createSystem(
              systemKey,
              SystemClass,
              creationContext
            );
            if (result.success) {
              this.systemsUsingStrategy.add(systemKey);
              this.systemsUsingLegacy.delete(systemKey);
            } else {
              this.systemsUsingLegacy.add(systemKey);
            }
            this.updateMigrationProgress();
            Y3K?.debug?.log(
              "NonVisualSystemFacadeAdapter",
              `Created ${systemKey} via strategy pattern`,
              {
                strategy: result.strategy,
                success: result.success,
                creationTime: result.creationTime
              }
            );
            return result;
          } catch (error) {
            this.systemsUsingLegacy.add(systemKey);
            this.updateMigrationProgress();
            Y3K?.debug?.error(
              "NonVisualSystemFacadeAdapter",
              `Failed to create ${systemKey} via strategy pattern:`,
              error
            );
            return {
              system: null,
              success: false,
              creationTime: 0,
              strategy: "adapter-fallback",
              injectedDependencies: [],
              warnings: [`Strategy creation failed: ${error}`],
              error,
              metadata: {
                requiresInitialization: false,
                pendingDependencies: [],
                context: creationContext
              }
            };
          }
        }
        /**
         * Legacy compatibility method - creates system using old hardcoded logic
         * This should be gradually phased out as systems migrate to strategy pattern
         */
        createSystemLegacy(systemKey, SystemClass, context) {
          this.systemsUsingLegacy.add(systemKey);
          this.updateMigrationProgress();
          Y3K?.debug?.warn(
            "NonVisualSystemFacadeAdapter",
            `Using legacy creation for ${systemKey} - should migrate to strategy pattern`
          );
          switch (systemKey) {
            case "DeviceCapabilityDetector":
            case "PerformanceAnalyzer":
            case "SettingsManager":
            case "TimerConsolidationSystem":
              return new SystemClass();
            case "SidebarSystemsIntegration":
              return new SystemClass(context.dependencies.cssConsciousnessController);
            case "UnifiedCSSConsciousnessController":
              return new SystemClass(
                context.config,
                context.dependencies.performanceCoordinator
              );
            case "ColorHarmonyEngine":
              return new SystemClass(
                context.config,
                context.utils,
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager
              );
            case "EnhancedMasterAnimationCoordinator":
              return new SystemClass(
                context.config,
                context.dependencies.performanceCoordinator
              );
            case "UnifiedPerformanceCoordinator":
              return new SystemClass(
                context.config,
                context.dependencies.performanceAnalyzer
              );
            case "GlassmorphismManager":
              return new SystemClass(
                context.config,
                context.utils,
                context.dependencies.cssConsciousnessController,
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager
              );
            case "Card3DManager":
              return new SystemClass(
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager,
                context.utils
              );
            case "MusicSyncService":
              return new SystemClass({
                YEAR3000_CONFIG: context.config,
                Year3000Utilities: context.utils,
                settingsManager: context.dependencies.settingsManager,
                year3000System: context.year3000System
                // NOTE: colorHarmonyEngine deliberately omitted - using event-driven pattern
              });
            default:
              try {
                return new SystemClass();
              } catch (error) {
                return new SystemClass(
                  context.config,
                  context.utils,
                  context.dependencies.performanceAnalyzer,
                  context.dependencies.settingsManager
                );
              }
          }
        }
        /**
         * Update migration progress based on strategy vs legacy usage
         */
        updateMigrationProgress() {
          const totalSystems = this.systemsUsingStrategy.size + this.systemsUsingLegacy.size;
          if (totalSystems === 0) {
            this.migrationProgress = 0;
          } else {
            this.migrationProgress = this.systemsUsingStrategy.size / totalSystems;
          }
        }
        /**
         * Get adapter performance metrics
         */
        getAdapterMetrics() {
          const totalSystems = this.systemsUsingStrategy.size + this.systemsUsingLegacy.size;
          return {
            totalSystemsAdapted: this.systemsUsingStrategy.size,
            strategySuccessRate: totalSystems > 0 ? this.systemsUsingStrategy.size / totalSystems : 0,
            migrationProgress: this.migrationProgress,
            systemBreakdown: {
              strategy: Array.from(this.systemsUsingStrategy),
              legacy: Array.from(this.systemsUsingLegacy)
            }
          };
        }
        /**
         * Force migration of specific system to strategy pattern
         */
        async migrateSystemToStrategy(systemKey) {
          try {
            this.systemsUsingLegacy.delete(systemKey);
            Y3K?.debug?.log(
              "NonVisualSystemFacadeAdapter",
              `Migrated ${systemKey} to strategy pattern`
            );
            return true;
          } catch (error) {
            Y3K?.debug?.error(
              "NonVisualSystemFacadeAdapter",
              `Failed to migrate ${systemKey} to strategy pattern:`,
              error
            );
            return false;
          }
        }
        /**
         * Get recommended migration order for systems
         */
        getRecommendedMigrationOrder() {
          const migrationOrder = [
            // Simple systems (no dependencies)
            "PerformanceAnalyzer",
            "UnifiedCSSConsciousnessController",
            "DeviceCapabilityDetector",
            "SettingsManager",
            // Event-driven systems
            "ColorHarmonyEngine",
            "MusicSyncService",
            // Complex systems
            "UnifiedPerformanceCoordinator",
            "EnhancedMasterAnimationCoordinator",
            // Integration systems
            "UnifiedSystemIntegration",
            // UI systems
            "GlassmorphismManager",
            "Card3DManager"
          ];
          return migrationOrder.filter((system) => this.systemsUsingLegacy.has(system));
        }
      };
      __name(_NonVisualSystemFacadeAdapter, "NonVisualSystemFacadeAdapter");
      NonVisualSystemFacadeAdapter = _NonVisualSystemFacadeAdapter;
      globalFacadeAdapter = new NonVisualSystemFacadeAdapter();
    }
  });

  // src-js/core/integration/NonVisualSystemFacade.ts
  var _NonVisualSystemFacade, NonVisualSystemFacade;
  var init_NonVisualSystemFacade = __esm({
    "src-js/core/integration/NonVisualSystemFacade.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_EnhancedMasterAnimationCoordinator();
      init_TimerConsolidationSystem();
      init_UnifiedCSSConsciousnessController();
      init_UnifiedPerformanceCoordinator();
      init_DeviceCapabilityDetector();
      init_PerformanceAnalyzer();
      init_PerformanceOrchestrator();
      init_QualityScalingManager();
      init_PerformanceBudgetManager();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_ColorHarmonyEngine();
      init_MusicSyncService();
      init_GenreGradientEvolution();
      init_MusicEmotionAnalyzer();
      init_UnifiedConsciousnessCoordinator();
      init_ColorOrchestrator();
      init_UnifiedColorProcessingEngine();
      init_GlassmorphismManager();
      init_Card3DManager();
      init_SidebarSystemsIntegration();
      init_FacadeAdapter();
      _NonVisualSystemFacade = class _NonVisualSystemFacade {
        constructor(config, utils, year3000System2) {
          // Reference to main system
          // Core shared dependencies (will be injected from main system)
          this.cssConsciousnessController = null;
          this.performanceAnalyzer = null;
          this.performanceCoordinator = null;
          this.musicSyncService = null;
          this.settingsManager = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Monitoring intervals
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Event callbacks
          this.onSystemCreated = null;
          this.onSystemFailed = null;
          this.onHealthChange = null;
          // Strategy-based creation adapter
          this.facadeAdapter = globalFacadeAdapter;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System2;
          this.systemRegistry = /* @__PURE__ */ new Map();
          this.systemCache = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.facadeConfig = {
            mode: "progressive",
            enablePerformanceMonitoring: true,
            enableDependencyInjection: true,
            enableSystemHealthMonitoring: true,
            performanceThresholds: {
              maxInitTime: 5e3,
              // 5 seconds
              maxMemoryMB: 100,
              maxCPUPercent: 15
            },
            systemPreferences: {
              lazyInitialization: true,
              aggressiveCaching: true,
              performanceOptimization: true
            }
          };
          this.currentMetrics = this.createInitialMetrics();
          this.registerNonVisualSystems();
          Y3K?.debug?.log("NonVisualSystemFacade", "Non-visual systems facade initialized");
        }
        registerNonVisualSystems() {
          this.systemRegistry.set("EnhancedMasterAnimationCoordinator", EnhancedMasterAnimationCoordinator);
          this.systemDependencies.set("EnhancedMasterAnimationCoordinator", ["performanceAnalyzer", "cssConsciousnessController"]);
          this.systemRegistry.set("TimerConsolidationSystem", TimerConsolidationSystem);
          this.systemDependencies.set("TimerConsolidationSystem", ["performanceAnalyzer"]);
          this.systemRegistry.set("UnifiedCSSConsciousnessController", UnifiedCSSConsciousnessController);
          this.systemDependencies.set("UnifiedCSSConsciousnessController", ["performanceCoordinator"]);
          this.systemRegistry.set("UnifiedPerformanceCoordinator", UnifiedPerformanceCoordinator);
          this.systemDependencies.set("UnifiedPerformanceCoordinator", []);
          this.systemRegistry.set("DeviceCapabilityDetector", DeviceCapabilityDetector);
          this.systemDependencies.set("DeviceCapabilityDetector", []);
          this.systemRegistry.set("PerformanceAnalyzer", PerformanceAnalyzer);
          this.systemDependencies.set("PerformanceAnalyzer", []);
          this.systemRegistry.set("PerformanceBudgetManager", PerformanceBudgetManager);
          this.systemDependencies.set("PerformanceBudgetManager", ["performanceAnalyzer"]);
          this.systemRegistry.set("PerformanceOrchestrator", PerformanceOrchestrator);
          this.systemDependencies.set("PerformanceOrchestrator", ["performanceAnalyzer", "performanceCoordinator", "deviceCapabilityDetector", "performanceBudgetManager"]);
          this.systemRegistry.set("QualityScalingManager", QualityScalingManager);
          this.systemDependencies.set("QualityScalingManager", ["performanceAnalyzer", "deviceCapabilityDetector"]);
          this.systemDependencies.set("UnifiedDebugManager", []);
          this.systemRegistry.set("SettingsManager", SettingsManager);
          this.systemDependencies.set("SettingsManager", []);
          this.systemRegistry.set("ColorHarmonyEngine", ColorHarmonyEngine);
          this.systemDependencies.set("ColorHarmonyEngine", ["musicSyncService"]);
          this.systemRegistry.set("MusicSyncService", MusicSyncService);
          this.systemDependencies.set("MusicSyncService", []);
          this.systemDependencies.set("ColorOrchestrator", []);
          this.systemRegistry.set("UnifiedColorProcessingEngine", UnifiedColorProcessingEngine);
          this.systemDependencies.set("UnifiedColorProcessingEngine", ["settingsManager", "performanceAnalyzer"]);
          this.systemRegistry.set("GenreGradientEvolution", GenreGradientEvolution);
          this.systemDependencies.set("GenreGradientEvolution", ["cssConsciousnessController", "musicSyncService", "settingsManager"]);
          this.systemRegistry.set("MusicEmotionAnalyzer", MusicEmotionAnalyzer);
          this.systemDependencies.set("MusicEmotionAnalyzer", ["musicSyncService", "settingsManager"]);
          this.systemRegistry.set("UnifiedConsciousnessCoordinator", UnifiedConsciousnessCoordinator);
          this.systemDependencies.set("UnifiedConsciousnessCoordinator", ["settingsManager"]);
          this.systemRegistry.set("GlassmorphismManager", GlassmorphismManager);
          this.systemDependencies.set("GlassmorphismManager", ["cssConsciousnessController", "performanceAnalyzer", "settingsManager"]);
          this.systemRegistry.set("Card3DManager", Card3DManager);
          this.systemDependencies.set("Card3DManager", ["performanceAnalyzer", "settingsManager"]);
          this.systemRegistry.set("SidebarSystemsIntegration", SidebarSystemsIntegration);
          this.systemDependencies.set("SidebarSystemsIntegration", ["cssConsciousnessController"]);
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3K?.debug?.warn("NonVisualSystemFacade", "Already initialized");
            return;
          }
          try {
            const startTime = performance.now();
            this.facadeConfig = { ...this.facadeConfig, ...config };
            await this.initializeSharedDependencies();
            await this.applyConfiguration();
            this.startMonitoring();
            await this.performHealthCheck();
            const endTime = performance.now();
            this.currentMetrics.systemInitializationTime = endTime - startTime;
            this.isInitialized = true;
            Y3K?.debug?.log("NonVisualSystemFacade", "Non-visual systems facade fully initialized", {
              mode: this.facadeConfig.mode,
              systemsRegistered: this.systemRegistry.size,
              initTime: this.currentMetrics.systemInitializationTime
            });
          } catch (error) {
            Y3K?.debug?.error("NonVisualSystemFacade", "Initialization failed:", error);
            await this.cleanup();
            throw error;
          }
        }
        async initializeSharedDependencies() {
          const coreSystemsOrder = [
            "PerformanceAnalyzer",
            "UnifiedPerformanceCoordinator",
            "UnifiedCSSConsciousnessController",
            "SettingsManager",
            "UnifiedDebugManager",
            "MusicSyncService"
          ];
          for (const systemKey of coreSystemsOrder) {
            try {
              const system = await this.getSystem(systemKey);
              if (system && typeof system.initialize === "function") {
                await system.initialize();
              }
              switch (systemKey) {
                case "PerformanceAnalyzer":
                  this.performanceAnalyzer = system;
                  break;
                case "UnifiedCSSConsciousnessController":
                  this.cssConsciousnessController = system;
                  break;
                case "SettingsManager":
                  this.settingsManager = system;
                  break;
                case "UnifiedDebugManager":
                  break;
                case "MusicSyncService":
                  this.musicSyncService = system;
                  break;
                case "UnifiedPerformanceCoordinator":
                  this.performanceCoordinator = system;
                  break;
              }
            } catch (error) {
              Y3K?.debug?.error("NonVisualSystemFacade", `Failed to initialize ${systemKey}:`, error);
            }
          }
        }
        /**
         * Get system from cache (synchronous) - returns null if not cached
         * Use this for scenarios where the system should already be initialized
         */
        getCachedSystem(key) {
          return this.systemCache.get(key) || null;
        }
        /**
         * Factory method to create and return non-visual systems
         * This is the main interface for the facade pattern
         */
        async getSystem(key) {
          if (this.systemCache.has(key)) {
            return this.systemCache.get(key);
          }
          const system = await this.createSystem(key);
          this.systemCache.set(key, system);
          this.currentMetrics.activeSystems.push(key);
          this.currentMetrics.initializedSystems++;
          if (this.onSystemCreated) {
            this.onSystemCreated(key, system);
          }
          return system;
        }
        /**
         * Create a new non-visual system instance with strategy-based dependency injection
         */
        async createSystem(key) {
          const startTime = performance.now();
          try {
            if (key === "UnifiedDebugManager") {
              const system2 = UnifiedDebugManager_default.getInstance();
              this.injectDependencies(system2, key);
              this.integratePerformanceMonitoring(system2, key);
              const endTime2 = performance.now();
              this.currentMetrics.dependencyResolutionTime += endTime2 - startTime;
              return system2;
            }
            if (key === "ColorOrchestrator") {
              const system2 = globalColorOrchestrator;
              this.injectDependencies(system2, key);
              this.integratePerformanceMonitoring(system2, key);
              const endTime2 = performance.now();
              this.currentMetrics.dependencyResolutionTime += endTime2 - startTime;
              return system2;
            }
            const SystemClass = this.systemRegistry.get(key);
            if (!SystemClass) {
              throw new Error(`Non-visual system '${key}' not found in registry`);
            }
            const context = {
              systemKey: key,
              config: this.config,
              utils: this.utils,
              dependencies: {
                config: this.config,
                utils: this.utils,
                performanceAnalyzer: this.performanceAnalyzer,
                settingsManager: this.settingsManager,
                musicSyncService: this.musicSyncService,
                year3000System: this.year3000System,
                cssConsciousnessController: this.cssConsciousnessController,
                performanceCoordinator: this.performanceCoordinator
              },
              preferences: {
                lazyInit: false,
                validateDependencies: true,
                creationTimeout: 5e3,
                monitorCreation: true
              },
              metadata: {
                timestamp: Date.now(),
                reason: "startup",
                priority: "medium",
                resourceConstraints: {
                  maxMemoryMB: 50,
                  maxInitTimeMs: 1e3
                }
              },
              year3000System: this.year3000System
            };
            const result = await this.facadeAdapter.createSystemWithStrategy(key, SystemClass, context);
            if (!result.success) {
              Y3K?.debug?.warn(
                "NonVisualSystemFacade",
                `Strategy creation failed for ${key}, falling back to legacy pattern`
              );
              const system2 = this.facadeAdapter.createSystemLegacy(key, SystemClass, context);
              this.injectDependencies(system2, key);
              this.integratePerformanceMonitoring(system2, key);
              const endTime2 = performance.now();
              this.currentMetrics.dependencyResolutionTime += endTime2 - startTime;
              return system2;
            }
            const system = result.system;
            this.injectDependencies(system, key);
            this.integratePerformanceMonitoring(system, key);
            const endTime = performance.now();
            this.currentMetrics.dependencyResolutionTime += endTime - startTime;
            Y3K?.debug?.log("NonVisualSystemFacade", `Created ${key} using strategy: ${result.strategy}`, {
              creationTime: result.creationTime,
              totalTime: endTime - startTime,
              injectedDependencies: result.injectedDependencies
            });
            return system;
          } catch (error) {
            this.currentMetrics.failedSystems++;
            this.currentMetrics.failedSystemsList.push(key);
            this.currentMetrics.systemErrors++;
            if (this.onSystemFailed) {
              this.onSystemFailed(key, error);
            }
            Y3K?.debug?.error("NonVisualSystemFacade", `Failed to create system ${key}:`, error);
            throw error;
          }
        }
        /**
         * Inject dependencies into non-visual systems
         */
        injectDependencies(system, key) {
          if (!this.facadeConfig.enableDependencyInjection) return;
          const dependencies = this.systemDependencies.get(key) || [];
          if (dependencies.includes("performanceAnalyzer") && this.performanceAnalyzer && system.setPerformanceAnalyzer) {
            system.setPerformanceAnalyzer(this.performanceAnalyzer);
          }
          if (dependencies.includes("cssConsciousnessController") && this.cssConsciousnessController && system.setCSSConsciousnessController) {
            system.setCSSConsciousnessController(this.cssConsciousnessController);
          }
          if (dependencies.includes("musicSyncService") && this.musicSyncService && system.setMusicSyncService) {
            system.setMusicSyncService(this.musicSyncService);
          }
          if (dependencies.includes("settingsManager") && this.settingsManager && system.setSettingsManager) {
            system.setSettingsManager(this.settingsManager);
          }
          if (dependencies.includes("year3000System") && system.setYear3000System) {
            system.setYear3000System(this.year3000System);
          }
        }
        /**
         * Integrate performance monitoring for non-visual systems
         */
        integratePerformanceMonitoring(system, key) {
          if (!this.facadeConfig.enablePerformanceMonitoring || !this.performanceAnalyzer) return;
          const originalInitialize = system.initialize;
          if (typeof originalInitialize === "function") {
            system.initialize = async (...args) => {
              const startTime = performance.now();
              const result = await originalInitialize.call(system, ...args);
              const endTime = performance.now();
              this.performanceAnalyzer?.recordMetric(
                `NonVisual_${key}_Initialize`,
                endTime - startTime
              );
              return result;
            };
          }
          const originalUpdateAnimation = system.updateAnimation;
          if (typeof originalUpdateAnimation === "function") {
            system.updateAnimation = (deltaTime) => {
              const startTime = performance.now();
              originalUpdateAnimation.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer?.recordMetric(
                `NonVisual_${key}_Animation`,
                endTime - startTime
              );
            };
          }
        }
        /**
         * Initialize all cached non-visual systems
         */
        async initializeAllSystems() {
          const initPromises = Array.from(this.systemCache.entries()).map(async ([key, system]) => {
            try {
              if (system && typeof system.initialize === "function") {
                await system.initialize();
              }
              Y3K?.debug?.log("NonVisualSystemFacade", `Initialized system: ${key}`);
              return { key, success: true };
            } catch (error) {
              Y3K?.debug?.error("NonVisualSystemFacade", `Failed to initialize ${key}:`, error);
              return { key, success: false, error };
            }
          });
          const results = await Promise.allSettled(initPromises);
          const successCount = results.filter((r) => r.status === "fulfilled" && r.value.success).length;
          Y3K?.debug?.log("NonVisualSystemFacade", `Non-visual systems initialized: ${successCount}/${results.length}`);
        }
        /**
         * Perform health check on all non-visual systems
         */
        async performHealthCheck() {
          const healthCheck = {
            overall: "good",
            systems: /* @__PURE__ */ new Map(),
            recommendations: [],
            timestamp: performance.now(),
            metrics: { ...this.currentMetrics }
          };
          let healthyCount = 0;
          let totalCount = 0;
          for (const [key, system] of this.systemCache) {
            totalCount++;
            try {
              const systemHealth = system.healthCheck ? await system.healthCheck() : { status: "unknown", message: "No health check available" };
              const isHealthy = systemHealth.status === "healthy" || systemHealth.status === "good";
              if (isHealthy) healthyCount++;
              healthCheck.systems.set(key, {
                ok: isHealthy,
                details: systemHealth.message || systemHealth.details || "System operational"
              });
            } catch (error) {
              healthCheck.systems.set(key, {
                ok: false,
                details: `Health check failed: ${error}`
              });
            }
          }
          const healthPercentage = totalCount > 0 ? healthyCount / totalCount : 1;
          if (healthPercentage >= 0.9) {
            healthCheck.overall = "excellent";
          } else if (healthPercentage >= 0.7) {
            healthCheck.overall = "good";
          } else if (healthPercentage >= 0.5) {
            healthCheck.overall = "degraded";
            healthCheck.recommendations.push("Some non-visual systems are experiencing issues");
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push("Multiple non-visual system failures detected");
          }
          if (this.currentMetrics.systemInitializationTime > 3e3) {
            healthCheck.recommendations.push("High initialization time - consider optimizing system startup");
          }
          if (this.currentMetrics.memoryUsageMB > 80) {
            healthCheck.recommendations.push("High memory usage - consider optimizing system memory usage");
          }
          this.lastHealthCheck = healthCheck;
          this.currentMetrics.lastHealthCheckTime = performance.now();
          if (this.onHealthChange) {
            this.onHealthChange(healthCheck);
          }
          return healthCheck;
        }
        // Utility methods
        createInitialMetrics() {
          return {
            systemCount: this.systemRegistry.size,
            initializedSystems: 0,
            failedSystems: 0,
            totalInitTime: 0,
            averageInitTime: 0,
            memoryUsageMB: 0,
            systemHealth: "good",
            activeSystems: [],
            failedSystemsList: [],
            dependencyInjection: this.facadeConfig.enableDependencyInjection,
            performanceMonitoring: this.facadeConfig.enablePerformanceMonitoring,
            healthMonitoring: this.facadeConfig.enableSystemHealthMonitoring,
            systemInitializationTime: 0,
            dependencyResolutionTime: 0,
            lastHealthCheckTime: 0,
            systemErrors: 0
          };
        }
        async applyConfiguration() {
          switch (this.facadeConfig.mode) {
            case "performance-first":
              this.facadeConfig.systemPreferences.lazyInitialization = true;
              this.facadeConfig.systemPreferences.aggressiveCaching = true;
              break;
            case "quality-first":
              this.facadeConfig.systemPreferences.lazyInitialization = false;
              this.facadeConfig.systemPreferences.performanceOptimization = true;
              break;
            case "battery-optimized":
              this.facadeConfig.performanceThresholds.maxCPUPercent = 5;
              this.facadeConfig.systemPreferences.lazyInitialization = true;
              break;
          }
        }
        startMonitoring() {
          if (this.facadeConfig.enableSystemHealthMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performHealthCheck();
            }, 3e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 5e3);
          }
        }
        updateMetrics() {
          this.currentMetrics.systemCount = this.systemRegistry.size;
          this.currentMetrics.initializedSystems = this.systemCache.size;
          this.currentMetrics.averageInitTime = this.currentMetrics.totalInitTime / Math.max(1, this.currentMetrics.initializedSystems);
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.memoryUsageMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          const failureRate = this.currentMetrics.failedSystems / Math.max(1, this.currentMetrics.systemCount);
          if (failureRate === 0) {
            this.currentMetrics.systemHealth = "excellent";
          } else if (failureRate < 0.1) {
            this.currentMetrics.systemHealth = "good";
          } else if (failureRate < 0.3) {
            this.currentMetrics.systemHealth = "degraded";
          } else {
            this.currentMetrics.systemHealth = "critical";
          }
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          this.cssConsciousnessController = null;
          this.performanceAnalyzer = null;
          this.musicSyncService = null;
          this.settingsManager = null;
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.facadeConfig };
        }
        async setConfiguration(config) {
          this.facadeConfig = { ...this.facadeConfig, ...config };
          await this.applyConfiguration();
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        setOnSystemFailed(callback) {
          this.onSystemFailed = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            systemsActive: this.systemCache.size,
            healthy: this.currentMetrics.systemHealth === "excellent" || this.currentMetrics.systemHealth === "good"
          };
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          this.systemCache.clear();
          Y3K?.debug?.log("NonVisualSystemFacade", "Non-visual systems facade destroyed");
        }
      };
      __name(_NonVisualSystemFacade, "NonVisualSystemFacade");
      NonVisualSystemFacade = _NonVisualSystemFacade;
    }
  });

  // src-js/utils/graphics/NoiseField.ts
  function sample(u, v) {
    const x = Math.max(0, Math.min(0.9999, u)) * (GRID_SIZE - 1);
    const y = Math.max(0, Math.min(0.9999, v)) * (GRID_SIZE - 1);
    const x0 = Math.floor(x);
    const y0 = Math.floor(y);
    const x1 = x0 + 1;
    const y1 = y0 + 1;
    const sx = x - x0;
    const sy = y - y0;
    const v00 = vectors[y0 * GRID_SIZE + x0];
    const v10 = vectors[y0 * GRID_SIZE + x1 % GRID_SIZE];
    const v01 = vectors[y1 % GRID_SIZE * GRID_SIZE + x0];
    const v11 = vectors[y1 % GRID_SIZE * GRID_SIZE + x1 % GRID_SIZE];
    const lerp2 = /* @__PURE__ */ __name((a, b, t) => a + (b - a) * t, "lerp");
    const ix0x = lerp2(v00.x, v10.x, sx);
    const ix0y = lerp2(v00.y, v10.y, sx);
    const ix1x = lerp2(v01.x, v11.x, sx);
    const ix1y = lerp2(v01.y, v11.y, sx);
    return {
      x: lerp2(ix0x, ix1x, sy),
      y: lerp2(ix0y, ix1y, sy)
    };
  }
  var GRID_SIZE, vectors;
  var init_NoiseField = __esm({
    "src-js/utils/graphics/NoiseField.ts"() {
      "use strict";
      GRID_SIZE = 64;
      vectors = new Array(GRID_SIZE * GRID_SIZE);
      (/* @__PURE__ */ __name(function init() {
        for (let i = 0; i < vectors.length; i++) {
          const angle = Math.random() * Math.PI * 2;
          vectors[i] = {
            x: Math.cos(angle),
            y: Math.sin(angle)
          };
        }
      }, "init"))();
      __name(sample, "sample");
    }
  });

  // src-js/visual/consciousness/UnifiedSidebarConsciousnessController.ts
  var _UnifiedSidebarConsciousnessController, UnifiedSidebarConsciousnessController;
  var init_UnifiedSidebarConsciousnessController = __esm({
    "src-js/visual/consciousness/UnifiedSidebarConsciousnessController.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_UnifiedSystemBase();
      init_EventBus();
      init_UnifiedEventBus();
      init_globalConfig();
      init_NoiseField();
      _UnifiedSidebarConsciousnessController = class _UnifiedSidebarConsciousnessController extends UnifiedSystemBase {
        constructor(config) {
          super(config);
          // BackgroundSystemParticipant implementation
          this.systemName = "UnifiedSidebarConsciousnessController";
          // Infrastructure dependencies
          this.sidebarPerformanceCoordinator = null;
          this.consciousnessChoreographer = null;
          this.currentConsciousnessField = null;
          // Animation and timing
          this.animationFrameId = null;
          this.lastFrameTime = 0;
          this.frameTimeHistory = [];
          // Event subscriptions
          this.eventUnsubscribeFunctions = [];
          // Bilateral coordination (for enhanced functionality)
          this.bilateralState = null;
          // NEW: Enhanced properties (from SidebarConsciousnessSystem)
          this.rootNavBar = null;
          this.overlayContainer = null;
          this.consciousnessVisualizer = null;
          this.harmonicModeIndicator = null;
          this.resizeObserver = null;
          this.masterAnimationRegistered = false;
          this.isUsingMasterAnimation = false;
          // Performance monitoring (enhanced)
          this._lastMotionDisabled = false;
          this._navInteractionHandler = null;
          this.sidebarConfig = {
            enabled: true,
            bilateralMode: false,
            // Can be enabled for enhanced functionality
            consciousnessThreshold: 0.3,
            musicResponsiveness: 0.8,
            beatSensitivity: 0.7,
            energySmoothing: 0.85,
            animationIntensity: 0.6,
            smoothingFactor: 0.85,
            maxFrameTime: 1,
            // <1ms budget from original systems
            bilateralOffset: 150,
            // Enhanced system's 150ms offset
            crossChannelBleed: 0.15,
            enablePerformanceMonitoring: true,
            adaptiveQuality: true,
            debugMode: config.enableDebug || false,
            // NEW: Enhanced features
            echoIntensity: 2,
            // Default medium echo intensity
            enableTemporalEcho: true,
            enableHarmonicModes: true,
            enableDeviceDetection: true
          };
          this.consciousnessState = this.createInitialConsciousnessState();
          Y3K?.debug?.log("UnifiedSidebarConsciousnessController", "Enhanced unified sidebar consciousness controller created (Phase 2.5)");
        }
        get systemPriority() {
          return "normal";
        }
        createInitialConsciousnessState() {
          return {
            consciousnessLevel: "dormant",
            bilateralCoordination: false,
            musicSync: {
              energy: 0,
              valence: 0.5,
              beat: false,
              tempo: 120,
              lastBeatTime: 0
            },
            animation: {
              intensity: 0,
              phase: 0,
              lastFrameTime: 0,
              targetIntensity: 0,
              smoothingFactor: this.sidebarConfig.smoothingFactor,
              // NEW: Enhanced animation properties
              currentScale: 1,
              baseOpacity: 0.7,
              pulseDirection: 1,
              lastPulse: 0
            },
            performance: {
              frameTime: 0,
              avgFrameTime: 0,
              maxFrameTime: 0,
              healthStatus: "excellent"
            },
            // NEW: Device capabilities
            deviceCapabilities: {
              supportsCSSFilter: this._detectCSSFilterSupport(),
              supportsTransforms: this._detectTransformSupport(),
              performanceLevel: this._detectPerformanceLevel(),
              reducedMotion: this._detectReducedMotion(),
              memory: navigator.deviceMemory || 4,
              cores: navigator.hardwareConcurrency || 4
            },
            // NEW: Temporal echo system
            temporalEcho: {
              echoPool: [],
              currentEchoCount: 0,
              maxEchoes: this._getMaxEchoes(),
              echoTimerCounter: 0,
              activeEchoElements: /* @__PURE__ */ new Set()
            },
            // NEW: Harmonic mode system
            harmonicMode: {
              currentModeKey: "artist-vision",
              currentModeClass: "",
              currentEnergyClass: "",
              modeConfig: null
            }
          };
        }
        // UnifiedSystemBase implementation
        async initialize() {
          return this._baseInitialize();
        }
        onAnimate(deltaTime) {
        }
        async _baseInitialize() {
          try {
            Y3K?.debug?.log("UnifiedSidebarConsciousnessController", "Starting enhanced unified initialization...");
            await this.initializeDOMElements();
            await this.initializePerformanceCoordinator();
            await this.initializeConsciousnessIntegration();
            if (this.sidebarConfig.enableHarmonicModes) {
              this.createOverlayContainer();
              this.createConsciousnessVisualizer();
              this.createHarmonicModeDisplay();
              this.updateColors();
            }
            if (this.sidebarConfig.enableTemporalEcho) {
              this.setupInteractionHandling();
            }
            this.setupResizeObserver();
            this.subscribeToUnifiedEvents();
            if (this.sidebarConfig.bilateralMode) {
              this.initializeBilateralCoordination();
            }
            this.startUnifiedAnimationLoop();
            this.initialized = true;
            Y3K?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              `Enhanced unified sidebar consciousness initialized (bilateral: ${this.sidebarConfig.bilateralMode}, echo: ${this.sidebarConfig.enableTemporalEcho}, harmonic: ${this.sidebarConfig.enableHarmonicModes})`
            );
          } catch (error) {
            Y3K?.debug?.error("UnifiedSidebarConsciousnessController", "Failed to initialize:", error);
            throw error;
          }
        }
        async initializePerformanceCoordinator() {
          try {
            this.sidebarPerformanceCoordinator = globalThis.sidebarPerformanceCoordinator || null;
            if (!this.sidebarPerformanceCoordinator) {
              Y3K?.debug?.warn(
                "UnifiedSidebarConsciousnessController",
                "SidebarPerformanceCoordinator not available, CSS updates may be less efficient"
              );
            } else {
              Y3K?.debug?.log(
                "UnifiedSidebarConsciousnessController",
                "Connected to shared SidebarPerformanceCoordinator"
              );
            }
          } catch (error) {
            Y3K?.debug?.warn(
              "UnifiedSidebarConsciousnessController",
              "Performance coordinator initialization failed:",
              error
            );
          }
        }
        async initializeConsciousnessIntegration() {
          try {
            this.consciousnessChoreographer = globalThis.backgroundConsciousnessChoreographer || null;
            if (this.consciousnessChoreographer) {
              this.consciousnessChoreographer.registerConsciousnessParticipant(this);
              Y3K?.debug?.log(
                "UnifiedSidebarConsciousnessController",
                "Registered with consciousness choreographer"
              );
            } else {
              Y3K?.debug?.log(
                "UnifiedSidebarConsciousnessController",
                "Operating without consciousness choreographer integration"
              );
            }
          } catch (error) {
            Y3K?.debug?.warn(
              "UnifiedSidebarConsciousnessController",
              "Consciousness integration failed:",
              error
            );
          }
        }
        subscribeToUnifiedEvents() {
          const musicBeatUnsubscribe = GlobalEventBus.subscribe(
            "music:beat",
            this.handleMusicBeat.bind(this)
          );
          this.eventUnsubscribeFunctions.push(musicBeatUnsubscribe);
          const musicEnergyUnsubscribe = GlobalEventBus.subscribe(
            "music:energy",
            this.handleMusicEnergy.bind(this)
          );
          this.eventUnsubscribeFunctions.push(musicEnergyUnsubscribe);
          const settingsUnsubscribe = GlobalEventBus.subscribe(
            "settings:changed",
            this.handleSettingsChange.bind(this)
          );
          this.eventUnsubscribeFunctions.push(settingsUnsubscribe);
          const colorHarmonizedUnsubscribe = unifiedEventBus.subscribe(
            "colors:harmonized",
            this.handleColorsHarmonized.bind(this),
            "UnifiedSidebarConsciousnessController"
          );
          this.eventUnsubscribeFunctions.push(() => unifiedEventBus.unsubscribe(colorHarmonizedUnsubscribe));
          const colorExtractedUnsubscribe = unifiedEventBus.subscribe(
            "colors:extracted",
            this.handleColorsExtracted.bind(this),
            "UnifiedSidebarConsciousnessController"
          );
          this.eventUnsubscribeFunctions.push(() => unifiedEventBus.unsubscribe(colorExtractedUnsubscribe));
          const colorConsciousnessUnsubscribe = GlobalEventBus.subscribe(
            "colorConsciousnessUpdate",
            this.handleColorConsciousnessUpdate.bind(this)
          );
          this.eventUnsubscribeFunctions.push(colorConsciousnessUnsubscribe);
          Y3K?.debug?.log(
            "UnifiedSidebarConsciousnessController",
            `Subscribed to ${this.eventUnsubscribeFunctions.length} unified events (including color consciousness)`
          );
        }
        initializeBilateralCoordination() {
          this.bilateralState = {
            leftSide: this.createInitialConsciousnessState(),
            rightSide: this.createInitialConsciousnessState(),
            coordinationOffset: this.sidebarConfig.bilateralOffset,
            lastCoordinationTime: 0
          };
          this.consciousnessState.bilateralCoordination = true;
          Y3K?.debug?.log(
            "UnifiedSidebarConsciousnessController",
            `Bilateral coordination initialized with ${this.sidebarConfig.bilateralOffset}ms offset`
          );
        }
        startUnifiedAnimationLoop() {
          const animate = /* @__PURE__ */ __name((currentTime) => {
            if (!this.initialized) return;
            const deltaTime = currentTime - this.lastFrameTime;
            this.lastFrameTime = currentTime;
            const frameStartTime = performance.now();
            try {
              this.updateConsciousnessState(deltaTime);
              if (this.sidebarConfig.bilateralMode && this.bilateralState) {
                this.updateBilateralCoordination(deltaTime);
              }
              this.applyCSSUpdates();
              const frameTime = performance.now() - frameStartTime;
              this.updatePerformanceMetrics(frameTime);
              if (frameTime > this.sidebarConfig.maxFrameTime) {
                Y3K?.debug?.warn(
                  "UnifiedSidebarConsciousnessController",
                  `Frame time exceeded budget: ${frameTime.toFixed(2)}ms`
                );
              }
            } catch (error) {
              Y3K?.debug?.error("UnifiedSidebarConsciousnessController", "Animation loop error:", error);
            }
            this.animationFrameId = requestAnimationFrame(animate);
          }, "animate");
          this.animationFrameId = requestAnimationFrame(animate);
        }
        updateConsciousnessState(deltaTime) {
          const state = this.consciousnessState;
          const energyInfluence = state.musicSync.energy * this.sidebarConfig.musicResponsiveness;
          state.animation.targetIntensity = Math.min(energyInfluence, 1);
          state.animation.intensity = this.lerp(
            state.animation.intensity,
            state.animation.targetIntensity,
            state.animation.smoothingFactor
          );
          state.animation.phase += deltaTime * 1e-3;
          if (state.animation.phase > Math.PI * 2) {
            state.animation.phase -= Math.PI * 2;
          }
          this.updateConsciousnessLevel();
        }
        updateConsciousnessLevel() {
          const state = this.consciousnessState;
          const totalActivity = state.animation.intensity + (state.musicSync.beat ? 0.3 : 0);
          if (totalActivity > 0.8) {
            state.consciousnessLevel = "transcendent";
          } else if (totalActivity > 0.5) {
            state.consciousnessLevel = "focused";
          } else if (totalActivity > 0.2) {
            state.consciousnessLevel = "aware";
          } else {
            state.consciousnessLevel = "dormant";
          }
          if (this.sidebarConfig.bilateralMode) {
            GlobalEventBus.emit("sidebar:bilateral-consciousness-level", {
              level: state.consciousnessLevel,
              intensity: state.animation.intensity,
              timestamp: Date.now()
            });
          }
        }
        updateBilateralCoordination(deltaTime) {
          if (!this.bilateralState) return;
          const now = Date.now();
          if (now - this.bilateralState.lastCoordinationTime > this.bilateralState.coordinationOffset) {
            const leftIntensity = this.bilateralState.leftSide.animation.intensity;
            const rightIntensity = this.bilateralState.rightSide.animation.intensity;
            this.bilateralState.rightSide.animation.targetIntensity = leftIntensity * (1 - this.sidebarConfig.crossChannelBleed) + rightIntensity * this.sidebarConfig.crossChannelBleed;
            this.bilateralState.lastCoordinationTime = now;
            GlobalEventBus.emit("sidebar:bilateral-coordination", {
              leftIntensity,
              rightIntensity,
              offset: this.bilateralState.coordinationOffset
            });
          }
        }
        applyCSSUpdates() {
          if (!this.sidebarPerformanceCoordinator) {
            this.applyDirectCSSUpdates();
            return;
          }
          const state = this.consciousnessState;
          const updates = {
            "--sn-sidebar-consciousness-level": state.consciousnessLevel,
            "--sn-sidebar-intensity": state.animation.intensity.toFixed(3),
            "--sn-sidebar-phase": state.animation.phase.toFixed(3),
            "--sn-sidebar-energy": state.musicSync.energy.toFixed(3),
            "--sn-sidebar-valence": state.musicSync.valence.toFixed(3)
          };
          if (this.sidebarConfig.bilateralMode && this.bilateralState) {
            updates["--sn-sidebar-bilateral-left"] = this.bilateralState.leftSide.animation.intensity.toFixed(3);
            updates["--sn-sidebar-bilateral-right"] = this.bilateralState.rightSide.animation.intensity.toFixed(3);
          }
          try {
            for (const [variable, value] of Object.entries(updates)) {
              this.sidebarPerformanceCoordinator.queueUpdate(variable, value);
            }
          } catch (error) {
            Y3K?.debug?.warn("UnifiedSidebarConsciousnessController", "CSS update error:", error);
            this.applyDirectCSSUpdates();
          }
        }
        applyDirectCSSUpdates() {
          const root = document.documentElement;
          const state = this.consciousnessState;
          root.style.setProperty("--sn-sidebar-consciousness-level", state.consciousnessLevel);
          root.style.setProperty("--sn-sidebar-intensity", state.animation.intensity.toFixed(3));
          root.style.setProperty("--sn-sidebar-phase", state.animation.phase.toFixed(3));
          root.style.setProperty("--sn-sidebar-energy", state.musicSync.energy.toFixed(3));
          root.style.setProperty("--sn-sidebar-valence", state.musicSync.valence.toFixed(3));
        }
        updatePerformanceMetrics(frameTime) {
          const perf = this.consciousnessState.performance;
          perf.frameTime = frameTime;
          this.frameTimeHistory.push(frameTime);
          if (this.frameTimeHistory.length > 60) {
            this.frameTimeHistory.shift();
          }
          perf.avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
          perf.maxFrameTime = Math.max(...this.frameTimeHistory);
          if (perf.avgFrameTime > 2) {
            perf.healthStatus = "critical";
          } else if (perf.avgFrameTime > 1.5) {
            perf.healthStatus = "degraded";
          } else if (perf.avgFrameTime > 1) {
            perf.healthStatus = "good";
          } else {
            perf.healthStatus = "excellent";
          }
        }
        // Event handlers (consolidated from all systems)
        handleMusicBeat(event) {
          const state = this.consciousnessState.musicSync;
          state.beat = true;
          state.lastBeatTime = Date.now();
          setTimeout(() => {
            state.beat = false;
          }, 100);
          if (this.sidebarConfig.debugMode) {
            Y3K?.debug?.log("UnifiedSidebarConsciousnessController", "Music beat received");
          }
        }
        handleMusicEnergy(event) {
          const state = this.consciousnessState.musicSync;
          if (event.energy !== void 0) {
            state.energy = this.lerp(state.energy, event.energy, 1 - this.sidebarConfig.energySmoothing);
          }
          if (event.valence !== void 0) {
            state.valence = this.lerp(state.valence, event.valence, 1 - this.sidebarConfig.energySmoothing);
          }
          if (event.tempo !== void 0) {
            state.tempo = event.tempo;
          }
        }
        handleSettingsChange(event) {
          const { key, value } = event;
          if (key.startsWith("sn-sidebar-")) {
            this.updateConfigFromSettings(key, value);
          }
        }
        updateConfigFromSettings(key, value) {
          switch (key) {
            case "sn-sidebar-intensity":
              this.sidebarConfig.animationIntensity = parseFloat(value) || 0.6;
              break;
            case "sn-sidebar-bilateral":
              const enableBilateral = value === "true" || value === true;
              if (enableBilateral !== this.sidebarConfig.bilateralMode) {
                this.sidebarConfig.bilateralMode = enableBilateral;
                if (enableBilateral) {
                  this.initializeBilateralCoordination();
                } else {
                  this.bilateralState = null;
                  this.consciousnessState.bilateralCoordination = false;
                }
              }
              break;
            case "sn-sidebar-responsiveness":
              this.sidebarConfig.musicResponsiveness = parseFloat(value) || 0.8;
              break;
          }
        }
        // 🎨 COLOR CONSCIOUSNESS EVENT HANDLERS (NEW - Phase 3.5)
        handleColorsHarmonized(event) {
          const { processedColors, coordinationMetrics } = event;
          try {
            this.updateSidebarColorsFromOKLAB(processedColors);
            if (coordinationMetrics?.emotionalState) {
              this.adjustConsciousnessForColorState(coordinationMetrics);
            }
            Y3K?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              "\u{1F3A8} Updated sidebar colors from harmonized OKLAB data",
              {
                colorCount: Object.keys(processedColors).length,
                emotionalState: coordinationMetrics?.emotionalState
              }
            );
          } catch (error) {
            Y3K?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to handle colors:harmonized event:",
              error
            );
          }
        }
        handleColorsExtracted(event) {
          const { rawColors, musicData } = event;
          try {
            if (rawColors?.DOMINANT) {
              this.updateSidebarAccentColor(rawColors.DOMINANT);
            }
            if (musicData) {
              this.adjustMusicResponsivenessForColors(musicData);
            }
            Y3K?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              "\u{1F3A8} Applied immediate color feedback from extracted colors"
            );
          } catch (error) {
            Y3K?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to handle colors:extracted event:",
              error
            );
          }
        }
        handleColorConsciousnessUpdate(event) {
          const { palette, consciousnessLevel, emotionalTemperature } = event;
          try {
            const colorInfluence = consciousnessLevel * 0.4;
            if (colorInfluence > 0.8) {
              this.consciousnessState.consciousnessLevel = "transcendent";
            } else if (colorInfluence > 0.5) {
              this.consciousnessState.consciousnessLevel = "focused";
            } else if (colorInfluence > 0.2) {
              this.consciousnessState.consciousnessLevel = "aware";
            } else {
              this.consciousnessState.consciousnessLevel = "dormant";
            }
            if (emotionalTemperature !== void 0) {
              const temp = typeof emotionalTemperature === "string" ? parseFloat(emotionalTemperature) : emotionalTemperature;
              if (!isNaN(temp)) {
                this.updateSidebarTemperature(temp);
              }
            }
            Y3K?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              "\u{1F3A8} Synchronized sidebar consciousness with color state",
              {
                consciousnessLevel: colorInfluence,
                emotionalTemperature
              }
            );
          } catch (error) {
            Y3K?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to handle colorConsciousnessUpdate event:",
              error
            );
          }
        }
        // BackgroundSystemParticipant interface implementation
        getConsciousnessContribution() {
          return {
            systemName: this.systemName,
            consciousnessLevel: this.consciousnessState.consciousnessLevel,
            intensity: this.consciousnessState.animation.intensity,
            musicSync: this.consciousnessState.musicSync,
            bilateral: this.sidebarConfig.bilateralMode ? this.bilateralState : null,
            timestamp: Date.now()
          };
        }
        onConsciousnessFieldUpdate(field) {
          try {
            this.currentConsciousnessField = field;
            const fieldInfluence = field.rhythmicPulse * 0.3;
            this.consciousnessState.animation.targetIntensity = Math.min(
              this.consciousnessState.animation.targetIntensity + fieldInfluence,
              1
            );
            if (this.sidebarConfig.debugMode) {
              Y3K?.debug?.log(
                "UnifiedSidebarConsciousnessController",
                "Updated from consciousness field:",
                {
                  rhythmicPulse: field.rhythmicPulse,
                  sidebarIntensity: this.consciousnessState.animation.intensity
                }
              );
            }
          } catch (error) {
            Y3K?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Error updating from consciousness field:",
              error
            );
          }
        }
        onChoreographyEvent(eventType, data) {
          if (eventType === "transition:start") {
            this.consciousnessState.animation.targetIntensity = Math.min(
              this.consciousnessState.animation.targetIntensity + 0.2,
              1
            );
          }
          if (this.sidebarConfig.debugMode) {
            Y3K?.debug?.log(
              "UnifiedSidebarConsciousnessController",
              `Choreography event: ${eventType}`,
              data
            );
          }
        }
        // Utility methods
        lerp(current, target, factor) {
          return current + (target - current) * factor;
        }
        // Health check implementation
        async healthCheck() {
          const state = this.consciousnessState;
          const isHealthy = this.initialized && state.performance.healthStatus !== "critical" && state.performance.avgFrameTime < 2;
          return {
            healthy: isHealthy,
            ok: isHealthy,
            details: `Consciousness: ${state.consciousnessLevel}, Intensity: ${state.animation.intensity.toFixed(2)}, Avg Frame: ${state.performance.avgFrameTime.toFixed(2)}ms, Status: ${state.performance.healthStatus}` + (this.sidebarConfig.bilateralMode ? ", Bilateral: enabled" : ""),
            system: "UnifiedSidebarConsciousnessController"
          };
        }
        // NEW: Device capability detection methods (from SidebarConsciousnessSystem)
        _detectCSSFilterSupport() {
          try {
            const testElement = document.createElement("div");
            testElement.style.filter = "blur(1px)";
            return testElement.style.filter === "blur(1px)";
          } catch (error) {
            return false;
          }
        }
        _detectTransformSupport() {
          try {
            const testElement = document.createElement("div");
            testElement.style.transform = "translateX(1px)";
            return testElement.style.transform === "translateX(1px)";
          } catch (error) {
            return false;
          }
        }
        _detectPerformanceLevel() {
          const memory = navigator.deviceMemory || 4;
          const cores = navigator.hardwareConcurrency || 4;
          if (memory >= 8 && cores >= 8) {
            return "high";
          } else if (memory >= 4 && cores >= 4) {
            return "medium";
          } else {
            return "low";
          }
        }
        _detectReducedMotion() {
          if (typeof window !== "undefined" && window.matchMedia) {
            return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
          }
          return false;
        }
        _getMaxEchoes() {
          const deviceCapabilities = {
            memory: navigator.deviceMemory || 4,
            cores: navigator.hardwareConcurrency || 4
          };
          if (deviceCapabilities.memory >= 8 && deviceCapabilities.cores >= 8) {
            return 12;
          } else if (deviceCapabilities.memory >= 4 && deviceCapabilities.cores >= 4) {
            return 8;
          } else {
            return 4;
          }
        }
        // NEW: DOM initialization methods (from SidebarConsciousnessSystem)
        async initializeDOMElements() {
          try {
            this.rootNavBar = document.querySelector(".Root__nav-bar") || document.querySelector('[data-testid="rootlist-container"]') || document.querySelector(".main-navBar-navBar");
            if (!this.rootNavBar) {
              Y3K?.debug?.warn("UnifiedSidebarConsciousnessController", "Root navigation bar not found");
              return;
            }
            Y3K?.debug?.log("UnifiedSidebarConsciousnessController", "DOM elements initialized");
          } catch (error) {
            Y3K?.debug?.error("UnifiedSidebarConsciousnessController", "DOM initialization error:", error);
            throw error;
          }
        }
        createOverlayContainer() {
          if (!this.rootNavBar || this.overlayContainer) return;
          this.overlayContainer = document.createElement("div");
          this.overlayContainer.className = "sn-consciousness-overlay";
          this.overlayContainer.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 1;
      overflow: hidden;
    `;
          this.rootNavBar.style.position = "relative";
          this.rootNavBar.appendChild(this.overlayContainer);
        }
        createConsciousnessVisualizer() {
          if (!this.overlayContainer || this.consciousnessVisualizer) return;
          this.consciousnessVisualizer = document.createElement("div");
          this.consciousnessVisualizer.className = "sn-consciousness-visualizer";
          this.consciousnessVisualizer.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at var(--sn-consciousness-x, 50%) var(--sn-consciousness-y, 50%), 
                                  hsla(var(--sn-consciousness-hue, 280), 70%, 60%, var(--sn-consciousness-alpha, 0.1)) 0%,
                                  hsla(var(--sn-consciousness-hue, 280), 50%, 40%, var(--sn-consciousness-alpha, 0.05)) 30%,
                                  transparent 70%);
      mix-blend-mode: overlay;
      transition: all 0.3s ease;
      opacity: var(--sn-consciousness-intensity, 0);
    `;
          this.overlayContainer.appendChild(this.consciousnessVisualizer);
        }
        createHarmonicModeDisplay() {
          if (!this.overlayContainer || this.harmonicModeIndicator) return;
          this.harmonicModeIndicator = document.createElement("div");
          this.harmonicModeIndicator.className = "sn-harmonic-mode-indicator";
          this.harmonicModeIndicator.style.cssText = `
      position: absolute;
      top: 8px;
      right: 8px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--sn-harmonic-color, #a855f7);
      opacity: var(--sn-harmonic-intensity, 0);
      transition: all 0.3s ease;
      pointer-events: none;
    `;
          this.overlayContainer.appendChild(this.harmonicModeIndicator);
        }
        updateColors() {
          if (!this.sidebarPerformanceCoordinator) {
            this.applyDirectColorUpdates();
            return;
          }
          const state = this.consciousnessState;
          const harmonicMode = state.harmonicMode;
          try {
            const modeConfig = HARMONIC_MODES[harmonicMode.currentModeKey] || HARMONIC_MODES["artist-vision"];
            this.sidebarPerformanceCoordinator.queueUpdate("--sn-consciousness-hue", "280");
            this.sidebarPerformanceCoordinator.queueUpdate("--sn-harmonic-color", "#a855f7");
            this.sidebarPerformanceCoordinator.queueUpdate("--sn-consciousness-intensity", state.animation.intensity.toFixed(3));
          } catch (error) {
            Y3K?.debug?.warn("UnifiedSidebarConsciousnessController", "Color update error:", error);
            this.applyDirectColorUpdates();
          }
        }
        applyDirectColorUpdates() {
          const root = document.documentElement;
          const state = this.consciousnessState;
          root.style.setProperty("--sn-consciousness-hue", "280");
          root.style.setProperty("--sn-harmonic-color", "#a855f7");
          root.style.setProperty("--sn-consciousness-intensity", state.animation.intensity.toFixed(3));
        }
        setupInteractionHandling() {
          if (!this.rootNavBar) return;
          this._navInteractionHandler = (evt) => {
            if (this.sidebarConfig.enableTemporalEcho) {
              this._spawnNavEcho(evt);
            }
          };
          this.rootNavBar.addEventListener("click", this._navInteractionHandler, { passive: true });
          this.rootNavBar.addEventListener("mouseover", this._navInteractionHandler, { passive: true });
        }
        setupResizeObserver() {
          if (typeof ResizeObserver === "undefined" || !this.rootNavBar) return;
          this.resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
              this.updateConsciousnessVisualizerSize(entry.contentRect);
            }
          });
          this.resizeObserver.observe(this.rootNavBar);
        }
        updateConsciousnessVisualizerSize(rect) {
          if (!this.consciousnessVisualizer) return;
          const updates = {
            "--sn-sidebar-width": `${rect.width}px`,
            "--sn-sidebar-height": `${rect.height}px`
          };
          if (this.sidebarPerformanceCoordinator) {
            for (const [variable, value] of Object.entries(updates)) {
              this.sidebarPerformanceCoordinator.queueUpdate(variable, value);
            }
          } else {
            const root = document.documentElement;
            for (const [variable, value] of Object.entries(updates)) {
              root.style.setProperty(variable, value);
            }
          }
        }
        // NEW: Temporal echo system methods (from SidebarConsciousnessSystem)
        _spawnNavEcho(evt) {
          const state = this.consciousnessState;
          if (state.deviceCapabilities.reducedMotion || state.temporalEcho.currentEchoCount >= state.temporalEcho.maxEchoes) {
            return;
          }
          const target = evt.target;
          if (!target) return;
          const echoElement = this._acquireEchoElement();
          if (!echoElement) return;
          const rect = target.getBoundingClientRect();
          const parentRect = this.rootNavBar?.getBoundingClientRect();
          if (parentRect) {
            const x = rect.left - parentRect.left + rect.width / 2;
            const y = rect.top - parentRect.top + rect.height / 2;
            const noiseVector1 = sample(x * 0.01, Date.now() * 1e-3);
            const noiseVector2 = sample(y * 0.01, Date.now() * 1e-3 + 100);
            const noiseX = noiseVector1.x * 10;
            const noiseY = noiseVector2.y * 10;
            echoElement.style.left = `${x + noiseX}px`;
            echoElement.style.top = `${y + noiseY}px`;
          }
          const intensity = this.sidebarConfig.echoIntensity / 3;
          echoElement.style.opacity = intensity.toString();
          echoElement.classList.add("sn-echo-active");
          setTimeout(() => {
            this._releaseEchoElement(echoElement);
          }, 1500 + Math.random() * 1e3);
          state.temporalEcho.currentEchoCount++;
          state.temporalEcho.echoTimerCounter++;
        }
        _acquireEchoElement() {
          const state = this.consciousnessState;
          if (state.temporalEcho.echoPool.length > 0) {
            return state.temporalEcho.echoPool.pop() || null;
          }
          if (state.temporalEcho.currentEchoCount < state.temporalEcho.maxEchoes) {
            return this._createEchoElement();
          }
          return null;
        }
        _createEchoElement() {
          const echo = document.createElement("div");
          echo.className = "sn-temporal-echo";
          echo.style.cssText = `
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: radial-gradient(circle, var(--sn-harmonic-color, #a855f7) 0%, transparent 70%);
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: all 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      opacity: 0;
    `;
          if (this.overlayContainer) {
            this.overlayContainer.appendChild(echo);
          }
          const state = this.consciousnessState;
          state.temporalEcho.activeEchoElements.add(echo);
          return echo;
        }
        _releaseEchoElement(echo) {
          const state = this.consciousnessState;
          state.temporalEcho.activeEchoElements.delete(echo);
          echo.classList.remove("sn-echo-active");
          echo.style.opacity = "0";
          if (state.temporalEcho.echoPool.length < state.temporalEcho.maxEchoes) {
            state.temporalEcho.echoPool.push(echo);
          } else {
            echo.remove();
          }
          state.temporalEcho.currentEchoCount = Math.max(0, state.temporalEcho.currentEchoCount - 1);
        }
        // NEW: Harmonic mode management (from SidebarConsciousnessSystem)
        updateHarmonicModeDisplay() {
          const state = this.consciousnessState;
          const harmonicMode = state.harmonicMode;
          const modeConfig = HARMONIC_MODES[harmonicMode.currentModeKey] || HARMONIC_MODES["artist-vision"];
          harmonicMode.modeConfig = modeConfig;
          if (this.rootNavBar) {
            if (harmonicMode.currentModeClass) {
              this.rootNavBar.classList.remove(harmonicMode.currentModeClass);
            }
            const newModeClass = `sn-harmonic-${harmonicMode.currentModeKey}`;
            this.rootNavBar.classList.add(newModeClass);
            harmonicMode.currentModeClass = newModeClass;
          }
          this.updateColors();
          Y3K?.debug?.log(
            "UnifiedSidebarConsciousnessController",
            `Harmonic mode updated to: ${harmonicMode.currentModeKey}`
          );
        }
        // Configuration API
        updateConfiguration(updates) {
          Object.assign(this.sidebarConfig, updates);
          if (updates.bilateralMode !== void 0) {
            if (updates.bilateralMode && !this.bilateralState) {
              this.initializeBilateralCoordination();
            } else if (!updates.bilateralMode && this.bilateralState) {
              this.bilateralState = null;
              this.consciousnessState.bilateralCoordination = false;
            }
          }
          if (updates.enableHarmonicModes !== void 0) {
            if (updates.enableHarmonicModes && this.overlayContainer) {
              this.updateHarmonicModeDisplay();
            }
          }
          if (updates.enableTemporalEcho !== void 0) {
            if (updates.enableTemporalEcho && this.rootNavBar && !this._navInteractionHandler) {
              this.setupInteractionHandling();
            }
          }
          Y3K?.debug?.log("UnifiedSidebarConsciousnessController", "Configuration updated:", updates);
        }
        getConfiguration() {
          return { ...this.sidebarConfig };
        }
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        // Legacy compatibility methods (for migration)
        getBilateralState() {
          return this.bilateralState;
        }
        async destroy() {
          Y3K?.debug?.log("UnifiedSidebarConsciousnessController", "Destroying enhanced unified consciousness controller...");
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
          if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
          }
          if (this.rootNavBar && this._navInteractionHandler) {
            this.rootNavBar.removeEventListener("click", this._navInteractionHandler);
            this.rootNavBar.removeEventListener("mouseover", this._navInteractionHandler);
            this._navInteractionHandler = null;
          }
          const state = this.consciousnessState;
          if (state.temporalEcho) {
            state.temporalEcho.activeEchoElements.forEach((echo) => {
              echo.remove();
            });
            state.temporalEcho.activeEchoElements.clear();
            for (const echo of state.temporalEcho.echoPool) {
              echo.remove();
            }
            state.temporalEcho.echoPool = [];
            state.temporalEcho.currentEchoCount = 0;
          }
          if (this.overlayContainer) {
            this.overlayContainer.remove();
            this.overlayContainer = null;
          }
          this.consciousnessVisualizer = null;
          this.harmonicModeIndicator = null;
          this.rootNavBar = null;
          for (const unsubscribe of this.eventUnsubscribeFunctions) {
            unsubscribe();
          }
          this.eventUnsubscribeFunctions = [];
          if (this.consciousnessChoreographer) {
          }
          this.bilateralState = null;
          this.initialized = false;
          Y3K?.debug?.log("UnifiedSidebarConsciousnessController", "Enhanced unified consciousness controller destroyed");
        }
        // 🎨 COLOR CONSCIOUSNESS HELPER METHODS (NEW - Phase 3.5)
        updateSidebarColorsFromOKLAB(processedColors) {
          if (!this.sidebarPerformanceCoordinator) return;
          try {
            const accentColor = processedColors.VIBRANT || processedColors.PROMINENT || processedColors.DOMINANT;
            const secondaryColor = processedColors.LIGHT_VIBRANT || processedColors.LIGHT_MUTED || accentColor;
            const shadowColor = processedColors.DARK_VIBRANT || processedColors.DARK_MUTED || accentColor;
            if (accentColor) {
              this.sidebarPerformanceCoordinator.queueUpdate("--sn-sidebar-accent-color", accentColor);
              this.sidebarPerformanceCoordinator.queueUpdate("--sn-sidebar-dynamic-accent", accentColor);
              const accentRgb = this.hexToRgb(accentColor);
              if (accentRgb !== null) {
                this.sidebarPerformanceCoordinator.queueUpdate("--sn-sidebar-accent-rgb", accentRgb);
                this.sidebarPerformanceCoordinator.queueUpdate("--sn-sidebar-entanglement-color-rgb", accentRgb);
              }
            }
            if (secondaryColor) {
              this.sidebarPerformanceCoordinator.queueUpdate("--sn-sidebar-secondary-color", secondaryColor);
              const secondaryRgb = this.hexToRgb(secondaryColor);
              if (secondaryRgb !== null) {
                this.sidebarPerformanceCoordinator.queueUpdate("--sn-sidebar-secondary-rgb", secondaryRgb);
              }
            }
            if (shadowColor) {
              this.sidebarPerformanceCoordinator.queueUpdate("--sn-sidebar-shadow-color", shadowColor);
            }
          } catch (error) {
            Y3K?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to update sidebar colors from OKLAB:",
              error
            );
          }
        }
        updateSidebarAccentColor(dominantColor) {
          if (!this.sidebarPerformanceCoordinator) return;
          try {
            this.sidebarPerformanceCoordinator.queueUpdate("--sn-sidebar-accent-color", dominantColor);
            this.sidebarPerformanceCoordinator.queueUpdate("--sn-sidebar-dynamic-accent", dominantColor);
            const rgbValue = this.hexToRgb(dominantColor);
            if (rgbValue !== null) {
              this.sidebarPerformanceCoordinator.queueUpdate("--sn-sidebar-accent-rgb", rgbValue);
            }
          } catch (error) {
            Y3K?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to update sidebar accent color:",
              error
            );
          }
        }
        adjustConsciousnessForColorState(coordinationMetrics) {
          const { emotionalState, detectedGenre, oklabPreset } = coordinationMetrics;
          try {
            if (emotionalState) {
              switch (emotionalState) {
                case "energetic":
                case "aggressive":
                  this.consciousnessState.animation.intensity = Math.min(
                    1,
                    this.consciousnessState.animation.intensity * 1.3
                  );
                  break;
                case "calm":
                case "ambient":
                  this.consciousnessState.animation.intensity = Math.max(
                    0.2,
                    this.consciousnessState.animation.intensity * 0.7
                  );
                  break;
                case "mysterious":
                  this.consciousnessState.animation.intensity = Math.min(
                    0.8,
                    this.consciousnessState.animation.intensity * 1.1
                  );
                  break;
              }
            }
            if (detectedGenre) {
              switch (detectedGenre) {
                case "electronic":
                case "dance":
                  this.sidebarConfig.musicResponsiveness = Math.min(
                    1,
                    this.sidebarConfig.musicResponsiveness * 1.2
                  );
                  break;
                case "classical":
                case "ambient":
                  this.sidebarConfig.musicResponsiveness = Math.max(
                    0.3,
                    this.sidebarConfig.musicResponsiveness * 0.8
                  );
                  break;
              }
            }
          } catch (error) {
            Y3K?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to adjust consciousness for color state:",
              error
            );
          }
        }
        adjustMusicResponsivenessForColors(musicData) {
          try {
            if (musicData.tempo) {
              const tempoFactor = Math.max(0.5, Math.min(1.5, musicData.tempo / 120));
              this.sidebarConfig.musicResponsiveness = Math.min(
                1,
                this.sidebarConfig.musicResponsiveness * tempoFactor
              );
            }
            if (musicData.energy !== void 0) {
              const energyInfluence = musicData.energy * 0.3;
              this.consciousnessState.animation.intensity = Math.max(
                0.1,
                Math.min(1, this.consciousnessState.animation.intensity + energyInfluence)
              );
            }
          } catch (error) {
            Y3K?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to adjust music responsiveness for colors:",
              error
            );
          }
        }
        updateSidebarTemperature(emotionalTemperature) {
          if (!this.sidebarPerformanceCoordinator || !emotionalTemperature) return;
          try {
            let hueShift = 0;
            if (emotionalTemperature < 3e3) {
              hueShift = 180 + (3e3 - emotionalTemperature) / 100;
            } else if (emotionalTemperature > 6e3) {
              hueShift = (emotionalTemperature - 6e3) / 100;
            } else {
              hueShift = (emotionalTemperature - 4500) / 50;
            }
            this.sidebarPerformanceCoordinator.queueUpdate("--sn-sidebar-hue-shift", `${hueShift}deg`);
          } catch (error) {
            Y3K?.debug?.error(
              "UnifiedSidebarConsciousnessController",
              "Failed to update sidebar temperature:",
              error
            );
          }
        }
        hexToRgb(hex) {
          try {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (!result || result.length < 4) return null;
            const r = parseInt(result[1], 16);
            const g2 = parseInt(result[2], 16);
            const b = parseInt(result[3], 16);
            return `${r}, ${g2}, ${b}`;
          } catch (error) {
            return null;
          }
        }
      };
      __name(_UnifiedSidebarConsciousnessController, "UnifiedSidebarConsciousnessController");
      UnifiedSidebarConsciousnessController = _UnifiedSidebarConsciousnessController;
    }
  });

  // src-js/visual/consciousness/ConsciousnessUIEffectsController.ts
  var _ConsciousnessUIEffectsController, ConsciousnessUIEffectsController;
  var init_ConsciousnessUIEffectsController = __esm({
    "src-js/visual/consciousness/ConsciousnessUIEffectsController.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_BaseVisualSystem();
      init_UnifiedEventBus();
      _ConsciousnessUIEffectsController = class _ConsciousnessUIEffectsController extends BaseVisualSystem {
        constructor(config, utils, performanceAnalyzer, musicSyncService, settingsManager) {
          super(config, utils, performanceAnalyzer, musicSyncService, settingsManager);
          // BackgroundSystemParticipant implementation
          this.systemName = "ConsciousnessUIEffectsController";
          // Infrastructure dependencies
          this.cssConsciousness = null;
          this.consciousnessChoreographer = null;
          this.currentConsciousnessField = null;
          // Element management
          this.shimmerElements = /* @__PURE__ */ new Map();
          this.mutationObserver = null;
          this.intersectionObserver = null;
          // Animation and timing
          this.animationFrameId = null;
          this.lastFrameTime = 0;
          this.frameTimeHistory = [];
          // Event subscriptions
          this.eventUnsubscribeFunctions = [];
          // Performance monitoring (override base performance monitor with custom metrics)
          this.customPerformanceMonitor = {
            frameCount: 0,
            totalFrameTime: 0,
            lastPerformanceCheck: 0,
            adaptiveQualityLevel: 1
          };
          // Diagnostic state
          this.diagnosticTimerId = null;
          this.lastDiagnosticRun = 0;
          this.uiEffectsConfig = {
            enabled: true,
            consciousnessThreshold: 0.3,
            // Shimmer defaults (from IridescentShimmerEffectsSystem)
            shimmerEnabled: true,
            shimmerIntensity: 0.6,
            shimmerType: "mixed",
            shimmerPerformanceLevel: "balanced",
            // Interaction defaults (from InteractionTrackingSystem)
            interactionTrackingEnabled: true,
            digitalMeditationThreshold: 3e4,
            // 30 seconds
            scrollVelocityTracking: true,
            // Diagnostic defaults (from WhiteLayerDiagnosticSystem)
            diagnosticEnabled: true,
            autoFixWhiteLayer: true,
            diagnosticInterval: 5e3,
            // 5 seconds
            // Audio-visual defaults (from AudioVisualController)
            audioVisualEnabled: true,
            beatSynchronization: true,
            nebulaEffectIntensity: 0.7,
            // Scroll effects defaults (from PrismaticScrollSheenSystem)
            scrollEffectsEnabled: true,
            prismaticSheenIntensity: 0.5,
            // Performance defaults
            maxFrameTime: 1,
            // <1ms budget
            adaptiveQuality: true,
            debugMode: config.enableDebug || false
          };
          this.consciousnessState = this.createInitialConsciousnessState();
          Y3K?.debug?.log("ConsciousnessUIEffectsController", "Unified UI effects consciousness controller created");
        }
        get systemPriority() {
          return "normal";
        }
        createInitialConsciousnessState() {
          return {
            consciousnessLevel: "dormant",
            shimmer: {
              intensity: 0,
              effectType: "mixed",
              activeElements: /* @__PURE__ */ new Set(),
              performanceLevel: this.uiEffectsConfig.shimmerPerformanceLevel
            },
            interaction: {
              isActive: false,
              lastInteractionTime: 0,
              digitalMeditationDetected: false,
              scrollVelocity: { x: 0, y: 0, direction: "none" },
              nexusState: "idle"
            },
            diagnostic: {
              whiteLayerIssues: [],
              webglContextHealthy: true,
              lastDiagnosticTime: 0,
              autoFixEnabled: this.uiEffectsConfig.autoFixWhiteLayer,
              criticalIssuesDetected: 0
            },
            audioVisual: {
              beatIntensity: 0,
              genreChangeDetected: false,
              nebulaEffectIntensity: 0,
              lastBeatTime: 0,
              performanceAdaptive: this.uiEffectsConfig.adaptiveQuality
            },
            scroll: {
              sheenIntensity: 0,
              scrollRatio: 0,
              prismaticEffectActive: false,
              lastScrollTime: 0
            },
            performance: {
              frameTime: 0,
              avgFrameTime: 0,
              maxFrameTime: 0,
              healthStatus: "excellent",
              adaptiveQualityEnabled: this.uiEffectsConfig.adaptiveQuality
            }
          };
        }
        // BaseVisualSystem implementation
        async initialize() {
          try {
            Y3K?.debug?.log("ConsciousnessUIEffectsController", "Starting unified UI effects initialization...");
            await this.initializeCSSConsciousness();
            await this.initializeConsciousnessIntegration();
            this.subscribeToUnifiedEvents();
            if (this.uiEffectsConfig.shimmerEnabled) {
              await this.initializeShimmerEffects();
            }
            if (this.uiEffectsConfig.interactionTrackingEnabled) {
              await this.initializeInteractionTracking();
            }
            if (this.uiEffectsConfig.diagnosticEnabled) {
              await this.initializeDiagnosticSystem();
            }
            if (this.uiEffectsConfig.audioVisualEnabled) {
              await this.initializeAudioVisualEffects();
            }
            if (this.uiEffectsConfig.scrollEffectsEnabled) {
              await this.initializeScrollEffects();
            }
            this.startUnifiedAnimationLoop();
            this.initialized = true;
            Y3K?.debug?.log(
              "ConsciousnessUIEffectsController",
              "Unified UI effects consciousness initialized"
            );
          } catch (error) {
            Y3K?.debug?.error("ConsciousnessUIEffectsController", "Failed to initialize:", error);
            throw error;
          }
        }
        async initializeCSSConsciousness() {
          try {
            this.cssConsciousness = globalThis.unifiedCSSConsciousnessController || null;
            if (!this.cssConsciousness) {
              Y3K?.debug?.warn(
                "ConsciousnessUIEffectsController",
                "CSS consciousness not available, CSS updates may be less efficient"
              );
            } else {
              Y3K?.debug?.log(
                "ConsciousnessUIEffectsController",
                "Connected to unified CSS consciousness"
              );
            }
          } catch (error) {
            Y3K?.debug?.warn(
              "ConsciousnessUIEffectsController",
              "CSS consciousness initialization failed:",
              error
            );
          }
        }
        async initializeConsciousnessIntegration() {
          try {
            this.consciousnessChoreographer = globalThis.backgroundConsciousnessChoreographer || null;
            if (this.consciousnessChoreographer) {
              this.consciousnessChoreographer.registerConsciousnessParticipant(this);
              Y3K?.debug?.log(
                "ConsciousnessUIEffectsController",
                "Registered with consciousness choreographer"
              );
            } else {
              Y3K?.debug?.log(
                "ConsciousnessUIEffectsController",
                "Operating without consciousness choreographer integration"
              );
            }
          } catch (error) {
            Y3K?.debug?.warn(
              "ConsciousnessUIEffectsController",
              "Consciousness integration failed:",
              error
            );
          }
        }
        subscribeToUnifiedEvents() {
          const musicBeatUnsubscribe = unifiedEventBus.subscribe(
            "music:beat",
            this.handleMusicBeat.bind(this),
            "ConsciousnessUIEffectsController"
          );
          this.eventUnsubscribeFunctions.push(() => unifiedEventBus.unsubscribe(musicBeatUnsubscribe));
          const musicEnergyUnsubscribe = unifiedEventBus.subscribe(
            "music:energy",
            this.handleMusicEnergy.bind(this),
            "ConsciousnessUIEffectsController"
          );
          this.eventUnsubscribeFunctions.push(() => unifiedEventBus.unsubscribe(musicEnergyUnsubscribe));
          const settingsUnsubscribe = unifiedEventBus.subscribe(
            "settings:changed",
            this.handleSettingsChange.bind(this),
            "ConsciousnessUIEffectsController"
          );
          this.eventUnsubscribeFunctions.push(() => unifiedEventBus.unsubscribe(settingsUnsubscribe));
          Y3K?.debug?.log(
            "ConsciousnessUIEffectsController",
            `Subscribed to ${this.eventUnsubscribeFunctions.length} unified events`
          );
        }
        async initializeShimmerEffects() {
          try {
            this.setupElementObservers();
            await this.discoverShimmerElements();
            Y3K?.debug?.log(
              "ConsciousnessUIEffectsController",
              `Shimmer effects initialized with ${this.shimmerElements.size} elements`
            );
          } catch (error) {
            Y3K?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Shimmer effects initialization failed:",
              error
            );
          }
        }
        async initializeInteractionTracking() {
          try {
            this.setupInteractionListeners();
            Y3K?.debug?.log(
              "ConsciousnessUIEffectsController",
              "Interaction tracking initialized"
            );
          } catch (error) {
            Y3K?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Interaction tracking initialization failed:",
              error
            );
          }
        }
        async initializeDiagnosticSystem() {
          try {
            this.startDiagnosticMonitoring();
            Y3K?.debug?.log(
              "ConsciousnessUIEffectsController",
              "Diagnostic system initialized"
            );
          } catch (error) {
            Y3K?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Diagnostic system initialization failed:",
              error
            );
          }
        }
        async initializeAudioVisualEffects() {
          try {
            Y3K?.debug?.log(
              "ConsciousnessUIEffectsController",
              "Audio-visual effects initialized"
            );
          } catch (error) {
            Y3K?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Audio-visual effects initialization failed:",
              error
            );
          }
        }
        async initializeScrollEffects() {
          try {
            Y3K?.debug?.log(
              "ConsciousnessUIEffectsController",
              "Scroll effects initialized"
            );
          } catch (error) {
            Y3K?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Scroll effects initialization failed:",
              error
            );
          }
        }
        setupElementObservers() {
          if (typeof MutationObserver !== "undefined") {
            this.mutationObserver = new MutationObserver((mutations) => {
              let hasNewElements = false;
              mutations.forEach((mutation) => {
                if (mutation.type === "childList") {
                  mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                      hasNewElements = true;
                    }
                  });
                }
              });
              if (hasNewElements) {
                this.discoverShimmerElements();
              }
            });
            this.mutationObserver.observe(document.body, {
              childList: true,
              subtree: true
            });
          }
          if (typeof IntersectionObserver !== "undefined") {
            this.intersectionObserver = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  const elementId = entry.target.getAttribute("data-shimmer-id");
                  if (elementId) {
                    if (entry.isIntersecting) {
                      this.consciousnessState.shimmer.activeElements.add(elementId);
                    } else {
                      this.consciousnessState.shimmer.activeElements.delete(elementId);
                    }
                  }
                });
              },
              { threshold: [0, 0.1, 0.5, 1] }
            );
          }
        }
        async discoverShimmerElements() {
          const selectors = [
            ".main-card-card",
            ".main-trackList-trackListRow",
            ".main-button-primary",
            ".main-playButton-button",
            '[data-testid="card-click-handler"]'
          ];
          let elementCount = 0;
          selectors.forEach((selector) => {
            const elements = document.querySelectorAll(selector);
            elements.forEach((element, index) => {
              const elementId = `shimmer-${selector.replace(/[^\w]/g, "_")}-${index}`;
              const htmlElement = element;
              htmlElement.setAttribute("data-shimmer-id", elementId);
              this.shimmerElements.set(elementId, htmlElement);
              if (this.intersectionObserver) {
                this.intersectionObserver.observe(htmlElement);
              }
              elementCount++;
            });
          });
          if (this.uiEffectsConfig.debugMode && elementCount > 0) {
            Y3K?.debug?.log(
              "ConsciousnessUIEffectsController",
              `Discovered ${elementCount} shimmer elements`
            );
          }
        }
        setupInteractionListeners() {
          const interactionEvents = ["click", "keydown", "mousemove", "scroll", "touchstart"];
          interactionEvents.forEach((eventType) => {
            document.addEventListener(eventType, () => {
              this.consciousnessState.interaction.isActive = true;
              this.consciousnessState.interaction.lastInteractionTime = Date.now();
              this.consciousnessState.interaction.digitalMeditationDetected = false;
              this.updateNexusState();
            }, { passive: true });
          });
        }
        startDiagnosticMonitoring() {
          this.diagnosticTimerId = window.setInterval(() => {
            this.runDiagnosticCheck();
          }, this.uiEffectsConfig.diagnosticInterval);
        }
        startUnifiedAnimationLoop() {
          const animate = /* @__PURE__ */ __name((currentTime) => {
            if (!this.initialized) return;
            const deltaTime = currentTime - this.lastFrameTime;
            this.lastFrameTime = currentTime;
            const frameStartTime = performance.now();
            try {
              this.updateConsciousnessState(deltaTime);
              if (this.uiEffectsConfig.shimmerEnabled) {
                this.updateShimmerEffects(deltaTime);
              }
              if (this.uiEffectsConfig.interactionTrackingEnabled) {
                this.updateInteractionTracking(deltaTime);
              }
              if (this.uiEffectsConfig.audioVisualEnabled) {
                this.updateAudioVisualEffects(deltaTime);
              }
              if (this.uiEffectsConfig.scrollEffectsEnabled) {
                this.updateScrollEffects(deltaTime);
              }
              this.applyCSSUpdates();
              const frameTime = performance.now() - frameStartTime;
              this.updatePerformanceMetrics(frameTime);
              if (frameTime > this.uiEffectsConfig.maxFrameTime) {
                this.handlePerformanceIssue(frameTime);
              }
            } catch (error) {
              Y3K?.debug?.error("ConsciousnessUIEffectsController", "Animation loop error:", error);
            }
            this.animationFrameId = requestAnimationFrame(animate);
          }, "animate");
          this.animationFrameId = requestAnimationFrame(animate);
        }
        updateConsciousnessState(deltaTime) {
          const state = this.consciousnessState;
          const totalActivity = state.shimmer.intensity * 0.2 + (state.interaction.isActive ? 0.3 : 0) + state.audioVisual.beatIntensity * 0.3 + state.scroll.sheenIntensity * 0.2;
          if (totalActivity > 0.8) {
            state.consciousnessLevel = "transcendent";
          } else if (totalActivity > 0.5) {
            state.consciousnessLevel = "focused";
          } else if (totalActivity > 0.2) {
            state.consciousnessLevel = "aware";
          } else {
            state.consciousnessLevel = "dormant";
          }
        }
        updateShimmerEffects(deltaTime) {
          const shimmerState = this.consciousnessState.shimmer;
          const musicInfluence = this.consciousnessState.audioVisual.beatIntensity * 0.3;
          const interactionInfluence = this.consciousnessState.interaction.isActive ? 0.2 : 0;
          shimmerState.intensity = Math.min(
            this.uiEffectsConfig.shimmerIntensity + musicInfluence + interactionInfluence,
            1
          );
          if (this.consciousnessState.performance.healthStatus === "degraded") {
            shimmerState.intensity *= 0.7;
          } else if (this.consciousnessState.performance.healthStatus === "critical") {
            shimmerState.intensity *= 0.3;
          }
        }
        updateInteractionTracking(deltaTime) {
          const interactionState = this.consciousnessState.interaction;
          const now = Date.now();
          const inactiveTime = now - interactionState.lastInteractionTime;
          if (inactiveTime > this.uiEffectsConfig.digitalMeditationThreshold) {
            if (!interactionState.digitalMeditationDetected) {
              interactionState.digitalMeditationDetected = true;
              Y3K?.debug?.log("ConsciousnessUIEffectsController", "Digital meditation detected", { inactiveTime });
            }
          }
          this.updateNexusState();
        }
        updateNexusState() {
          const state = this.consciousnessState.interaction;
          const now = Date.now();
          const timeSinceInteraction = now - state.lastInteractionTime;
          if (state.digitalMeditationDetected) {
            state.nexusState = "meditation";
          } else if (timeSinceInteraction < 1e3) {
            state.nexusState = "active";
          } else if (timeSinceInteraction < 1e4) {
            state.nexusState = "flow";
          } else {
            state.nexusState = "idle";
          }
        }
        updateAudioVisualEffects(deltaTime) {
          const audioState = this.consciousnessState.audioVisual;
          const consciousnessBoost = this.consciousnessState.consciousnessLevel === "transcendent" ? 0.2 : 0;
          audioState.nebulaEffectIntensity = Math.min(
            this.uiEffectsConfig.nebulaEffectIntensity + audioState.beatIntensity * 0.3 + consciousnessBoost,
            1
          );
        }
        updateScrollEffects(deltaTime) {
          const scrollState = this.consciousnessState.scroll;
          const timeSinceScroll = Date.now() - scrollState.lastScrollTime;
          if (timeSinceScroll < 1e3) {
            scrollState.prismaticEffectActive = true;
            scrollState.sheenIntensity = Math.min(
              scrollState.scrollRatio * this.uiEffectsConfig.prismaticSheenIntensity,
              1
            );
          } else {
            scrollState.prismaticEffectActive = false;
            scrollState.sheenIntensity *= 0.95;
          }
        }
        applyCSSUpdates() {
          if (!this.cssConsciousness) {
            this.applyDirectCSSUpdates();
            return;
          }
          const state = this.consciousnessState;
          const updates = {
            // Core consciousness
            "--sn-ui-consciousness-level": state.consciousnessLevel,
            // Shimmer effects
            "--sn-shimmer-intensity": state.shimmer.intensity.toFixed(3),
            "--sn-shimmer-effect-type": state.shimmer.effectType,
            "--sn-shimmer-performance": state.shimmer.performanceLevel,
            // Interaction tracking
            "--sn-interaction-nexus-state": state.interaction.nexusState,
            "--sn-interaction-meditation": state.interaction.digitalMeditationDetected ? "1" : "0",
            "--sn-scroll-velocity-x": state.interaction.scrollVelocity.x.toFixed(2),
            "--sn-scroll-velocity-y": state.interaction.scrollVelocity.y.toFixed(2),
            // Audio-visual effects
            "--sn-beat-intensity": state.audioVisual.beatIntensity.toFixed(3),
            "--sn-nebula-intensity": state.audioVisual.nebulaEffectIntensity.toFixed(3),
            "--sn-genre-change": state.audioVisual.genreChangeDetected ? "1" : "0",
            // Scroll effects
            "--sn-scroll-sheen-intensity": state.scroll.sheenIntensity.toFixed(3),
            "--sn-scroll-ratio": state.scroll.scrollRatio.toFixed(3),
            "--sn-prismatic-active": state.scroll.prismaticEffectActive ? "1" : "0",
            // Diagnostic status
            "--sn-white-layer-issues": state.diagnostic.whiteLayerIssues.length.toString(),
            "--sn-webgl-healthy": state.diagnostic.webglContextHealthy ? "1" : "0"
          };
          try {
            for (const [variable, value] of Object.entries(updates)) {
              this.cssConsciousness.queueCSSVariableUpdate(variable, value);
            }
          } catch (error) {
            Y3K?.debug?.warn("ConsciousnessUIEffectsController", "CSS update error:", error);
            this.applyDirectCSSUpdates();
          }
        }
        applyDirectCSSUpdates() {
          const root = document.documentElement;
          const state = this.consciousnessState;
          root.style.setProperty("--sn-ui-consciousness-level", state.consciousnessLevel);
          root.style.setProperty("--sn-shimmer-intensity", state.shimmer.intensity.toFixed(3));
          root.style.setProperty("--sn-beat-intensity", state.audioVisual.beatIntensity.toFixed(3));
          root.style.setProperty("--sn-scroll-sheen-intensity", state.scroll.sheenIntensity.toFixed(3));
        }
        updatePerformanceMetrics(frameTime) {
          const perf = this.consciousnessState.performance;
          perf.frameTime = frameTime;
          this.frameTimeHistory.push(frameTime);
          if (this.frameTimeHistory.length > 60) {
            this.frameTimeHistory.shift();
          }
          perf.avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
          perf.maxFrameTime = Math.max(...this.frameTimeHistory);
          if (perf.avgFrameTime > 2) {
            perf.healthStatus = "critical";
          } else if (perf.avgFrameTime > 1.5) {
            perf.healthStatus = "degraded";
          } else if (perf.avgFrameTime > 1) {
            perf.healthStatus = "good";
          } else {
            perf.healthStatus = "excellent";
          }
        }
        handlePerformanceIssue(frameTime) {
          if (this.uiEffectsConfig.adaptiveQuality) {
            this.customPerformanceMonitor.adaptiveQualityLevel *= 0.9;
            if (this.customPerformanceMonitor.adaptiveQualityLevel < 0.5) {
              this.consciousnessState.shimmer.performanceLevel = "minimal";
            }
            if (this.uiEffectsConfig.debugMode) {
              Y3K?.debug?.warn(
                "ConsciousnessUIEffectsController",
                `Performance issue: ${frameTime.toFixed(2)}ms, reduced quality to ${this.customPerformanceMonitor.adaptiveQualityLevel.toFixed(2)}`
              );
            }
          }
        }
        runDiagnosticCheck() {
          const diagnosticState = this.consciousnessState.diagnostic;
          const now = Date.now();
          diagnosticState.lastDiagnosticTime = now;
          diagnosticState.whiteLayerIssues = [];
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            diagnosticState.webglContextHealthy = !!gl;
            const elements = document.querySelectorAll('[style*="background"], [style*="color"]');
            let whiteLayerCount = 0;
            elements.forEach((element) => {
              const style = window.getComputedStyle(element);
              if (style.backgroundColor === "rgb(255, 255, 255)" || style.color === "rgb(255, 255, 255)") {
                whiteLayerCount++;
              }
            });
            if (whiteLayerCount > 10) {
              diagnosticState.whiteLayerIssues.push(`Excessive white layers detected: ${whiteLayerCount}`);
              if (diagnosticState.autoFixEnabled) {
                this.autoFixWhiteLayerIssues();
              }
            }
            diagnosticState.criticalIssuesDetected = diagnosticState.whiteLayerIssues.length;
          } catch (error) {
            Y3K?.debug?.error("ConsciousnessUIEffectsController", "Diagnostic check failed:", error);
          }
        }
        autoFixWhiteLayerIssues() {
          try {
            document.documentElement.style.setProperty("--spice-text", "var(--spice-main)");
            document.documentElement.style.setProperty("--spice-subtext", "var(--catppuccin-text)");
            if (this.uiEffectsConfig.debugMode) {
              Y3K?.debug?.log("ConsciousnessUIEffectsController", "Applied white layer auto-fix");
            }
          } catch (error) {
            Y3K?.debug?.error("ConsciousnessUIEffectsController", "Auto-fix failed:", error);
          }
        }
        // Event handlers (consolidated from all systems)
        handleMusicBeat(event) {
          const audioState = this.consciousnessState.audioVisual;
          audioState.beatIntensity = event.intensity || 0.5;
          audioState.lastBeatTime = Date.now();
          if (this.uiEffectsConfig.shimmerEnabled) {
            const beatBoost = audioState.beatIntensity * 0.2;
            this.consciousnessState.shimmer.intensity = Math.min(
              this.consciousnessState.shimmer.intensity + beatBoost,
              1
            );
          }
        }
        handleMusicEnergy(event) {
          const audioState = this.consciousnessState.audioVisual;
          if (event.energy !== void 0) {
            audioState.beatIntensity = Math.max(audioState.beatIntensity, event.energy * 0.8);
          }
        }
        handleGenreChange(event) {
          const audioState = this.consciousnessState.audioVisual;
          audioState.genreChangeDetected = true;
          setTimeout(() => {
            audioState.genreChangeDetected = false;
          }, 2e3);
        }
        handleUserScroll(event) {
          const scrollState = this.consciousnessState.scroll;
          const interactionState = this.consciousnessState.interaction;
          scrollState.lastScrollTime = Date.now();
          scrollState.scrollRatio = event.scrollRatio || 0;
          if (event.velocity) {
            interactionState.scrollVelocity = {
              x: event.velocity.x || 0,
              y: event.velocity.y || 0,
              direction: event.direction || "none"
            };
          }
          this.handleUserInteraction({ type: "scroll", timestamp: Date.now() });
        }
        handleUserInteraction(event) {
          const interactionState = this.consciousnessState.interaction;
          interactionState.isActive = true;
          interactionState.lastInteractionTime = event.timestamp || Date.now();
          interactionState.digitalMeditationDetected = false;
          this.updateNexusState();
        }
        handleSettingsChange(event) {
          const { key, value } = event;
          if (key.startsWith("sn-ui-effects-")) {
            this.updateConfigFromSettings(key, value);
          }
        }
        updateConfigFromSettings(key, value) {
          switch (key) {
            case "sn-ui-effects-shimmer-intensity":
              this.uiEffectsConfig.shimmerIntensity = parseFloat(value) || 0.6;
              break;
            case "sn-ui-effects-diagnostic-enabled":
              this.uiEffectsConfig.diagnosticEnabled = value === "true" || value === true;
              break;
            case "sn-ui-effects-adaptive-quality":
              this.uiEffectsConfig.adaptiveQuality = value === "true" || value === true;
              break;
          }
        }
        // BackgroundSystemParticipant interface implementation
        getConsciousnessContribution() {
          return {
            systemName: this.systemName,
            consciousnessLevel: this.consciousnessState.consciousnessLevel,
            shimmerIntensity: this.consciousnessState.shimmer.intensity,
            interactionState: this.consciousnessState.interaction.nexusState,
            audioVisualIntensity: this.consciousnessState.audioVisual.nebulaEffectIntensity,
            scrollActivity: this.consciousnessState.scroll.sheenIntensity,
            timestamp: Date.now()
          };
        }
        onConsciousnessFieldUpdate(field) {
          try {
            this.currentConsciousnessField = field;
            const fieldInfluence = field.rhythmicPulse * 0.2;
            this.consciousnessState.shimmer.intensity = Math.min(
              this.consciousnessState.shimmer.intensity + fieldInfluence,
              1
            );
            this.consciousnessState.audioVisual.nebulaEffectIntensity = Math.min(
              this.consciousnessState.audioVisual.nebulaEffectIntensity + fieldInfluence * 0.3,
              1
            );
          } catch (error) {
            Y3K?.debug?.error(
              "ConsciousnessUIEffectsController",
              "Error updating from consciousness field:",
              error
            );
          }
        }
        onChoreographyEvent(eventType, data) {
          if (eventType === "transition:start") {
            this.consciousnessState.shimmer.intensity = Math.min(
              this.consciousnessState.shimmer.intensity + 0.2,
              1
            );
            this.consciousnessState.audioVisual.nebulaEffectIntensity = Math.min(
              this.consciousnessState.audioVisual.nebulaEffectIntensity + 0.15,
              1
            );
          }
          if (this.uiEffectsConfig.debugMode) {
            Y3K?.debug?.log(
              "ConsciousnessUIEffectsController",
              `Choreography event: ${eventType}`,
              data
            );
          }
        }
        // Health check implementation
        async healthCheck() {
          const state = this.consciousnessState;
          const isHealthy = this.initialized && state.performance.healthStatus !== "critical" && state.diagnostic.criticalIssuesDetected === 0;
          return {
            healthy: isHealthy,
            ok: isHealthy,
            details: `UI Effects Consciousness: ${state.consciousnessLevel}, Shimmer: ${state.shimmer.activeElements.size} elements, Interaction: ${state.interaction.nexusState}, Performance: ${state.performance.healthStatus}, Diagnostics: ${state.diagnostic.criticalIssuesDetected} issues`,
            system: "ConsciousnessUIEffectsController"
          };
        }
        // Configuration API
        updateConfiguration(updates) {
          Object.assign(this.uiEffectsConfig, updates);
          if (updates.shimmerEnabled !== void 0) {
            if (updates.shimmerEnabled && !this.consciousnessState.shimmer.activeElements.size) {
              this.discoverShimmerElements();
            }
          }
          if (updates.diagnosticEnabled !== void 0) {
            if (updates.diagnosticEnabled && !this.diagnosticTimerId) {
              this.startDiagnosticMonitoring();
            } else if (!updates.diagnosticEnabled && this.diagnosticTimerId) {
              clearInterval(this.diagnosticTimerId);
              this.diagnosticTimerId = null;
            }
          }
          Y3K?.debug?.log("ConsciousnessUIEffectsController", "Configuration updated:", updates);
        }
        getConfiguration() {
          return { ...this.uiEffectsConfig };
        }
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        // Legacy compatibility methods (for migration)
        getShimmerElements() {
          return new Map(this.shimmerElements);
        }
        getInteractionState() {
          return this.consciousnessState.interaction;
        }
        getDiagnosticState() {
          return this.consciousnessState.diagnostic;
        }
        async destroy() {
          Y3K?.debug?.log("ConsciousnessUIEffectsController", "Destroying unified UI effects controller...");
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
          if (this.diagnosticTimerId) {
            clearInterval(this.diagnosticTimerId);
            this.diagnosticTimerId = null;
          }
          if (this.mutationObserver) {
            this.mutationObserver.disconnect();
            this.mutationObserver = null;
          }
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            this.intersectionObserver = null;
          }
          for (const unsubscribe of this.eventUnsubscribeFunctions) {
            unsubscribe();
          }
          this.eventUnsubscribeFunctions = [];
          this.shimmerElements.clear();
          if (this.consciousnessChoreographer) {
          }
          this.initialized = false;
          Y3K?.debug?.log("ConsciousnessUIEffectsController", "Unified UI effects controller destroyed");
        }
      };
      __name(_ConsciousnessUIEffectsController, "ConsciousnessUIEffectsController");
      ConsciousnessUIEffectsController = _ConsciousnessUIEffectsController;
    }
  });

  // src-js/visual/consciousness/HeaderConsciousnessController.ts
  var _HeaderConsciousnessController, HeaderConsciousnessController;
  var init_HeaderConsciousnessController = __esm({
    "src-js/visual/consciousness/HeaderConsciousnessController.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_UnifiedSystemBase();
      init_UnifiedEventBus();
      _HeaderConsciousnessController = class _HeaderConsciousnessController extends UnifiedSystemBase {
        constructor(config) {
          super(config);
          this.consciousnessState = {
            energy: 0.5,
            valence: 0.5,
            tempo: 120,
            harmonyHue: 0,
            intensity: 0.8,
            lastUpdateTime: 0,
            animationActive: true,
            preferredMotion: true,
            frameRate: 60,
            lastFrameTime: 0
          };
          this.animationFrameId = 0;
          this.updateInterval = 0;
          // Performance optimization
          this.eventDebounceTimers = {
            musicEnergy: 0,
            colorHarmony: 0,
            beatSync: 0,
            cssUpdate: 0
          };
          this.eventDebounceMs = 100;
          // Reduced from 33ms to 100ms for better performance
          this.frameThrottleMs = 16;
          // 60fps target
          this.lastCSSUpdateTime = 0;
          // Change detection for CSS variables
          this.previousCSSValues = {
            energy: 0,
            valence: 0,
            harmonyHue: 0,
            intensity: 0,
            depth: 0
          };
          this.cssChangeThreshold = 0.01;
        }
        // =========================================================================
        // PERFORMANCE OPTIMIZATION HELPERS
        // =========================================================================
        /**
         * Debounced event handler to prevent excessive processing
         */
        debouncedEventHandler(eventType, handler) {
          const now = performance.now();
          if (now - this.eventDebounceTimers[eventType] >= this.eventDebounceMs) {
            handler();
            this.eventDebounceTimers[eventType] = now;
          }
        }
        /**
         * Check if CSS values have changed significantly
         */
        hasSignificantCSSChange() {
          const state = this.consciousnessState;
          const depthMultiplier = 1 + state.energy * 0.5;
          const currentValues = {
            energy: state.energy,
            valence: state.valence,
            harmonyHue: state.harmonyHue,
            intensity: state.intensity,
            depth: depthMultiplier
          };
          for (const [key, value] of Object.entries(currentValues)) {
            const previous = this.previousCSSValues[key];
            if (Math.abs(value - previous) >= this.cssChangeThreshold) {
              return true;
            }
          }
          return false;
        }
        /**
         * Update previous CSS values for change detection
         */
        updatePreviousCSSValues() {
          const state = this.consciousnessState;
          const depthMultiplier = 1 + state.energy * 0.5;
          this.previousCSSValues.energy = state.energy;
          this.previousCSSValues.valence = state.valence;
          this.previousCSSValues.harmonyHue = state.harmonyHue;
          this.previousCSSValues.intensity = state.intensity;
          this.previousCSSValues.depth = depthMultiplier;
        }
        /**
         * Batch apply CSS updates to minimize DOM layout thrashing
         */
        batchApplyCSSUpdates(updates) {
          for (const [property, value] of updates) {
            this.updateCSSVariableGroup("header-consciousness", {
              [property]: value
            });
          }
        }
        /**
         * Schedule consciousness variable update with change detection
         */
        scheduleConsciousnessUpdate() {
          this.debouncedEventHandler("cssUpdate", () => {
            if (this.hasSignificantCSSChange()) {
              this.updateHeaderConsciousnessVariables();
              this.updatePreviousCSSValues();
            }
          });
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            this.consciousnessState.preferredMotion = !window.matchMedia("(prefers-reduced-motion: reduce)").matches;
            this.setupMusicEventListeners();
            this.setupColorHarmonyListeners();
            this.updateHeaderConsciousnessVariables();
            if (this.consciousnessState.preferredMotion) {
              this.startAnimationLoop();
            }
            this.setupPerformanceMonitoring();
            Y3K?.debug?.log("HeaderConsciousnessController", "Header consciousness initialization complete");
          } catch (error) {
            Y3K?.debug?.error("HeaderConsciousnessController", "Initialization failed:", error);
          }
        }
        setupMusicEventListeners() {
          unifiedEventBus.subscribe("music:energy", (data) => {
            this.debouncedEventHandler("musicEnergy", () => {
              if (typeof data.energy === "number") {
                this.consciousnessState.energy = Math.max(0, Math.min(1, data.energy));
                this.scheduleConsciousnessUpdate();
              }
              if (typeof data.tempo === "number") {
                this.consciousnessState.tempo = Math.max(60, Math.min(200, data.tempo));
                this.updateAnimationSpeed();
              }
              if (typeof data.valence === "number") {
                this.consciousnessState.valence = Math.max(0, Math.min(1, data.valence));
                this.scheduleConsciousnessUpdate();
              }
            });
          }, "HeaderConsciousnessController");
          unifiedEventBus.subscribe("consciousness:beat-sync", (data) => {
            this.debouncedEventHandler("beatSync", () => {
              if (this.consciousnessState.animationActive) {
                const intensity = data.beatPhase || 0.8;
                this.onBeatDetected(intensity);
              }
            });
          }, "HeaderConsciousnessController");
          unifiedEventBus.subscribe("music:energy-changed", (data) => {
            this.debouncedEventHandler("musicEnergy", () => {
              if (typeof data.energy === "number") {
                this.consciousnessState.energy = Math.max(0, Math.min(1, data.energy));
                this.scheduleConsciousnessUpdate();
              }
            });
          }, "HeaderConsciousnessController");
        }
        setupColorHarmonyListeners() {
          unifiedEventBus.subscribe("colors:harmonized", (data) => {
            this.debouncedEventHandler("colorHarmony", () => {
              if (data.coordinationMetrics?.coordinationStrategy) {
                this.updateHarmonyHue(data.coordinationMetrics.coordinationStrategy);
              }
            });
          }, "HeaderConsciousnessController");
          unifiedEventBus.subscribe("colors:extracted", (data) => {
            this.debouncedEventHandler("colorHarmony", () => {
              if (data.musicData && typeof data.musicData.energy === "number") {
                const hue = data.musicData.energy * 360;
                this.consciousnessState.harmonyHue = hue;
                this.scheduleConsciousnessUpdate();
              }
            });
          }, "HeaderConsciousnessController");
        }
        updateHarmonyHue(harmonicMode) {
          const harmonyHueMap = {
            "monochromatic": 0,
            "complementary": 180,
            "triadic": 120,
            "analogous": 30,
            "tetradic": 90,
            "split-complementary": 150
          };
          const baseHue = harmonyHueMap[harmonicMode] || 0;
          this.consciousnessState.harmonyHue = baseHue;
          this.scheduleConsciousnessUpdate();
        }
        onBeatDetected(intensity) {
          const beatEnergy = Math.min(1, this.consciousnessState.energy + intensity * 0.3);
          this.batchApplyCSSUpdates([
            ["--header-consciousness-energy", beatEnergy.toString()]
          ]);
          const resetTime = performance.now() + 150;
          const resetBeatEffect = /* @__PURE__ */ __name(() => {
            if (performance.now() >= resetTime && this.initialized) {
              this.batchApplyCSSUpdates([
                ["--header-consciousness-energy", this.consciousnessState.energy.toString()]
              ]);
            } else if (this.initialized) {
              requestAnimationFrame(resetBeatEffect);
            }
          }, "resetBeatEffect");
          requestAnimationFrame(resetBeatEffect);
        }
        updateAnimationSpeed() {
          const tempoMultiplier = this.consciousnessState.tempo / 120;
          const baseSpeed = 8;
          const newSpeed = baseSpeed / tempoMultiplier;
          this.batchApplyCSSUpdates([
            ["--header-consciousness-flow-speed", `${Math.max(2, Math.min(16, newSpeed))}s`]
          ]);
        }
        updateHeaderConsciousnessVariables() {
          if (!this.initialized) return;
          const state = this.consciousnessState;
          const dynamicIntensity = state.intensity * (0.6 + state.valence * 0.4) * (0.8 + state.energy * 0.2);
          const depthMultiplier = 1 + state.energy * 0.5;
          this.batchApplyCSSUpdates([
            ["--header-consciousness-energy", state.energy.toString()],
            ["--header-consciousness-harmony", `${state.harmonyHue}deg`],
            ["--header-soul-intensity", dynamicIntensity.toString()],
            ["--header-consciousness-depth", depthMultiplier.toString()]
          ]);
          this.consciousnessState.lastUpdateTime = Date.now();
        }
        startAnimationLoop() {
          const animate = /* @__PURE__ */ __name((currentTime) => {
            if (!this.initialized || !this.consciousnessState.animationActive) return;
            if (currentTime - this.lastCSSUpdateTime < this.frameThrottleMs) {
              this.animationFrameId = requestAnimationFrame(animate);
              return;
            }
            const deltaTime = currentTime - this.consciousnessState.lastFrameTime;
            this.consciousnessState.frameRate = 1e3 / deltaTime;
            this.consciousnessState.lastFrameTime = currentTime;
            if (currentTime - this.consciousnessState.lastUpdateTime > 100) {
              if (this.hasSignificantCSSChange()) {
                this.updateHeaderConsciousnessVariables();
                this.updatePreviousCSSValues();
              }
            }
            this.lastCSSUpdateTime = currentTime;
            this.animationFrameId = requestAnimationFrame(animate);
          }, "animate");
          this.animationFrameId = requestAnimationFrame(animate);
        }
        setupPerformanceMonitoring() {
          this.updateInterval = window.setInterval(() => {
            if (!this.initialized) return;
            if (this.consciousnessState.frameRate < 30) {
              Y3K?.debug?.warn("HeaderConsciousnessController", "Performance degradation detected, reducing update frequency");
            }
            const root = document.documentElement;
            root.style.setProperty(
              "--header-consciousness-performance",
              this.consciousnessState.frameRate > 50 ? "1" : "0.5"
            );
          }, 2e3);
        }
        /**
         * Manually update header consciousness intensity
         */
        setConsciousnessIntensity(intensity) {
          this.consciousnessState.intensity = Math.max(0, Math.min(1, intensity));
          this.updateHeaderConsciousnessVariables();
        }
        /**
         * Enable or disable header consciousness animations
         */
        setAnimationActive(active) {
          this.consciousnessState.animationActive = active;
          if (!active && this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = 0;
          } else if (active && this.consciousnessState.preferredMotion) {
            this.startAnimationLoop();
          }
        }
        /**
         * Get current consciousness state for debugging
         */
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        async healthCheck() {
          const isHealthy = this.initialized && this.consciousnessState.frameRate > 20 && Date.now() - this.consciousnessState.lastUpdateTime < 5e3;
          return {
            healthy: isHealthy,
            issues: isHealthy ? [] : [
              this.consciousnessState.frameRate <= 20 ? "Low frame rate detected" : "",
              Date.now() - this.consciousnessState.lastUpdateTime >= 5e3 ? "No recent updates" : ""
            ].filter((issue) => issue),
            metrics: {
              frameRate: this.consciousnessState.frameRate,
              energy: this.consciousnessState.energy,
              intensity: this.consciousnessState.intensity,
              animationActive: this.consciousnessState.animationActive,
              lastUpdate: this.consciousnessState.lastUpdateTime
            }
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = 0;
          }
          if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = 0;
          }
          unifiedEventBus.unsubscribeAll("HeaderConsciousnessController");
          Y3K?.debug?.log("HeaderConsciousnessController", "Header consciousness system cleaned up");
        }
        // Required abstract method implementations
        async initialize() {
          return this._baseInitialize();
        }
        async destroy() {
          this._performSystemSpecificCleanup();
        }
        onAnimate(deltaTime) {
          if (this.consciousnessState.animationActive) {
            this.updateHeaderConsciousnessVariables();
          }
        }
      };
      __name(_HeaderConsciousnessController, "HeaderConsciousnessController");
      HeaderConsciousnessController = _HeaderConsciousnessController;
    }
  });

  // src-js/visual/consciousness/ConsolidatedShaderLibrary.ts
  var STANDARD_CONSCIOUSNESS_VERTEX_SHADER, SHARED_NOISE_FUNCTIONS, CONSCIOUSNESS_MODULATION_FUNCTIONS, STANDARD_CONSCIOUSNESS_UNIFORMS, _ConsciousnessShaderTemplate, ConsciousnessShaderTemplate, _ShaderLogicPatterns, ShaderLogicPatterns, _ConsciousnessShaderFragments, ConsciousnessShaderFragments, _ShaderOptimizationUtils, ShaderOptimizationUtils, CONSCIOUSNESS_SHADER_LIBRARY;
  var init_ConsolidatedShaderLibrary = __esm({
    "src-js/visual/consciousness/ConsolidatedShaderLibrary.ts"() {
      "use strict";
      STANDARD_CONSCIOUSNESS_VERTEX_SHADER = `#version 300 es
in vec2 a_position;
void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;
      SHARED_NOISE_FUNCTIONS = `
// Shared simplex noise implementation for consciousness effects
vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
  vec2 i = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);
  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod289(i);
  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m;
  m = m*m;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
  vec3 g;
  g.x = a0.x * x0.x + h.x * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}`;
      CONSCIOUSNESS_MODULATION_FUNCTIONS = `
// Consciousness-aware breathing effect
float consciousnessBreathing(float time, float phase, float intensity) {
  return sin(time * 0.05 + phase) * intensity;
}

// Rhythmic pulse modulation from consciousness field
float rhythmicPulseModulation(float baseValue, float rhythmicPulse, float intensity) {
  return baseValue * (1.0 + rhythmicPulse * intensity);
}

// Musical flow direction calculation
vec2 calculateMusicalFlow(vec2 baseDirection, vec2 musicFlow, float sensitivity) {
  return baseDirection + musicFlow * sensitivity;
}

// Energy resonance modulation
float energyResonanceModulation(float baseValue, float energyResonance, float minMult, float maxMult) {
  return baseValue * (minMult + energyResonance * (maxMult - minMult));
}

// Membrane fluidity effect
float membraneFluidityEffect(float value, float fluidityIndex) {
  return mix(value, value * 1.2, fluidityIndex);
}`;
      STANDARD_CONSCIOUSNESS_UNIFORMS = `
// Time and resolution (universal)
uniform float u_time;
uniform vec2 u_resolution;

// Consciousness field uniforms
uniform float u_rhythmicPulse;
uniform vec2 u_musicalFlow;
uniform float u_energyResonance;
uniform float u_breathingCycle;
uniform float u_membraneFluidityIndex;

// Music sync uniforms
uniform float u_musicEnergy;
uniform float u_musicValence;
uniform float u_beatIntensity;
uniform float u_bassResponse;`;
      _ConsciousnessShaderTemplate = class _ConsciousnessShaderTemplate {
        /**
         * Build a complete fragment shader from components
         */
        static buildFragmentShader(options) {
          const {
            precision = "precision mediump float;",
            additionalUniforms = "",
            additionalFunctions = "",
            mainShaderLogic,
            includeNoiseFunctions = true,
            includeConsciousnessFunctions = true
          } = options;
          let shader = `#version 300 es
${precision}

`;
          shader += STANDARD_CONSCIOUSNESS_UNIFORMS + "\n\n";
          if (additionalUniforms) {
            shader += additionalUniforms + "\n\n";
          }
          shader += "out vec4 fragColor;\n\n";
          if (includeNoiseFunctions) {
            shader += SHARED_NOISE_FUNCTIONS + "\n\n";
          }
          if (includeConsciousnessFunctions) {
            shader += CONSCIOUSNESS_MODULATION_FUNCTIONS + "\n\n";
          }
          if (additionalFunctions) {
            shader += additionalFunctions + "\n\n";
          }
          shader += "void main() {\n";
          shader += "  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n\n";
          shader += mainShaderLogic;
          shader += "\n}";
          return shader;
        }
        /**
         * Generate standard uniform names list for consciousness systems
         */
        static getStandardUniformNames() {
          return [
            "u_time",
            "u_resolution",
            "u_rhythmicPulse",
            "u_musicalFlow",
            "u_energyResonance",
            "u_breathingCycle",
            "u_membraneFluidityIndex",
            "u_musicEnergy",
            "u_musicValence",
            "u_beatIntensity",
            "u_bassResponse"
          ];
        }
        /**
         * Generate WebGL-specific uniform names (for WebGL system)
         */
        static getWebGLUniformNames() {
          return [
            ...this.getStandardUniformNames(),
            "u_gradientTex",
            "u_flowStrength",
            "u_noiseScale",
            "u_colorIntensity",
            "u_patternScale",
            "u_animationSpeed"
          ];
        }
        /**
         * Generate liquid-specific uniform names (for Liquid system)
         */
        static getLiquidUniformNames() {
          return [
            ...this.getStandardUniformNames(),
            "u_gradientTex",
            "u_flowStrength",
            "u_noiseScale",
            "u_liquidPhase",
            "u_breathingIntensity",
            "u_auroraFlow",
            "u_flowDirection",
            "u_liquidTurbulence",
            "u_consciousnessDepth",
            "u_waveY",
            "u_waveHeight",
            "u_waveOffset",
            "u_blurExp",
            "u_blurMax"
          ];
        }
      };
      __name(_ConsciousnessShaderTemplate, "ConsciousnessShaderTemplate");
      ConsciousnessShaderTemplate = _ConsciousnessShaderTemplate;
      _ShaderLogicPatterns = class _ShaderLogicPatterns {
        /**
         * Standard consciousness-driven flow calculation
         */
        static consciousnessFlowLogic() {
          return `
  // Calculate consciousness-driven flow
  vec2 flowDirection = calculateMusicalFlow(vec2(1.0, 0.5), u_musicalFlow, 0.5);
  float flowStrength = rhythmicPulseModulation(0.5, u_rhythmicPulse, 0.3);
  
  // Apply breathing modulation
  float breathingMod = consciousnessBreathing(u_time, 0.0, 0.2);
  flowStrength *= (1.0 + breathingMod);`;
        }
        /**
         * Standard noise-based texture sampling with consciousness
         */
        static consciousnessNoiseSampling() {
          return `
  // Generate consciousness-modulated noise
  vec2 noiseUV = uv + flowDirection * u_time * 0.03;
  float noise1 = snoise(noiseUV * 2.0);
  float noise2 = snoise(noiseUV * 4.0) * 0.5;
  
  // Combine noise with consciousness influence
  float t = (noise1 + noise2) * energyResonanceModulation(1.0, u_energyResonance, 0.5, 1.5);
  t = clamp(t * 0.5 + 0.5, 0.0, 1.0);`;
        }
        /**
         * Standard consciousness-aware vignette effect
         */
        static consciousnessVignette() {
          return `
  // Apply consciousness-aware vignette
  vec2 center = uv - 0.5;
  float breathing = consciousnessBreathing(u_time, u_breathingCycle, 0.1);
  float vignette = (0.9 + breathing) - dot(center, center) * 0.3;
  color.rgb *= vignette;`;
        }
        /**
         * Standard music-responsive alpha modulation
         */
        static musicResponsiveAlpha() {
          return `
  // Music-responsive alpha modulation
  float musicAlpha = 0.8 + u_beatIntensity * 0.2 + u_bassResponse * 0.1;
  color.a *= musicAlpha;`;
        }
        /**
         * Standard shimmer/aurora effect
         */
        static auroraShimmerEffect() {
          return `
  // Aurora shimmer overlay
  float shimmerPhase = u_time * 3.0 + uv.x * 15.0 + uv.y * 10.0;
  float shimmer = sin(shimmerPhase) * 0.03 + 0.97;
  color.rgb *= shimmer;`;
        }
      };
      __name(_ShaderLogicPatterns, "ShaderLogicPatterns");
      ShaderLogicPatterns = _ShaderLogicPatterns;
      _ConsciousnessShaderFragments = class _ConsciousnessShaderFragments {
        /**
         * WebGL gradient consciousness fragment
         * Optimized version of WebGL gradient shader logic
         */
        static webglGradientFragment() {
          return `
  ${ShaderLogicPatterns.consciousnessFlowLogic()}
  
  // WebGL-specific gradient sampling
  ${ShaderLogicPatterns.consciousnessNoiseSampling()}
  
  // Sample gradient texture
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));
  
  // Apply consciousness effects
  ${ShaderLogicPatterns.consciousnessVignette()}
  ${ShaderLogicPatterns.musicResponsiveAlpha()}
  
  fragColor = color;`;
        }
        /**
         * Liquid consciousness fragment
         * Core liquid effects with consciousness integration
         */
        static liquidConsciousnessFragment() {
          return `
  ${ShaderLogicPatterns.consciousnessFlowLogic()}
  
  // Liquid-specific turbulence and phase
  float liquidPhase = u_liquidPhase + u_rhythmicPulse * 0.5;
  vec2 turbulenceUV = uv * u_liquidTurbulence;
  float turbulence = snoise(turbulenceUV + u_time * 0.01);
  
  // Liquid consciousness noise
  vec2 liquidUV = uv + flowDirection * u_time * 0.03;
  liquidUV += vec2(sin(u_time * 0.04 + liquidPhase), cos(u_time * 0.03 + liquidPhase)) * 0.02;
  float liquidNoise = snoise(liquidUV * 2.0 + turbulence * 0.1);
  
  float t = clamp(liquidNoise * 0.5 + 0.5, 0.0, 1.0);
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));
  
  ${ShaderLogicPatterns.consciousnessVignette()}
  ${ShaderLogicPatterns.auroraShimmerEffect()}
  ${ShaderLogicPatterns.musicResponsiveAlpha()}
  
  fragColor = color;`;
        }
      };
      __name(_ConsciousnessShaderFragments, "ConsciousnessShaderFragments");
      ConsciousnessShaderFragments = _ConsciousnessShaderFragments;
      _ShaderOptimizationUtils = class _ShaderOptimizationUtils {
        /**
         * Generate optimized shader based on performance level
         */
        static generateOptimizedShader(baseShaderLogic, performanceLevel) {
          switch (performanceLevel) {
            case "high":
              return baseShaderLogic;
            case "medium":
              return baseShaderLogic.replace(/snoise\(.*?\)/g, "snoise($1)").replace(/\* 0\.0[1-9]/g, "* 0.02");
            case "low":
              return baseShaderLogic.replace(/snoise\(.*?\) \* 0\.[0-9]+/g, "0.5").replace(/sin\(.*?\) \* 0\.[0-9]+/g, "0.0");
            default:
              return baseShaderLogic;
          }
        }
        /**
         * Calculate shader complexity score for performance monitoring
         */
        static calculateShaderComplexity(shaderSource) {
          let complexity = 0;
          complexity += (shaderSource.match(/snoise/g) || []).length * 10;
          complexity += (shaderSource.match(/sin|cos|tan/g) || []).length * 2;
          complexity += (shaderSource.match(/texture/g) || []).length * 3;
          complexity += (shaderSource.match(/mix|smoothstep/g) || []).length * 1;
          return complexity;
        }
        /**
         * Generate fallback shader for low-performance situations
         */
        static generateFallbackShader() {
          return ConsciousnessShaderTemplate.buildFragmentShader({
            includeNoiseFunctions: false,
            includeConsciousnessFunctions: false,
            additionalUniforms: "uniform sampler2D u_gradientTex;",
            mainShaderLogic: `
  // Minimal fallback consciousness shader
  float t = uv.x + sin(u_time * 0.5 + u_rhythmicPulse) * 0.1;
  t = clamp(t, 0.0, 1.0);
  
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));
  color.a *= 0.8 + u_beatIntensity * 0.2;
  
  fragColor = color;`
          });
        }
      };
      __name(_ShaderOptimizationUtils, "ShaderOptimizationUtils");
      ShaderOptimizationUtils = _ShaderOptimizationUtils;
      CONSCIOUSNESS_SHADER_LIBRARY = {
        // Templates and builders
        Template: ConsciousnessShaderTemplate,
        // Shared components
        VERTEX_SHADER: STANDARD_CONSCIOUSNESS_VERTEX_SHADER,
        NOISE_FUNCTIONS: SHARED_NOISE_FUNCTIONS,
        CONSCIOUSNESS_FUNCTIONS: CONSCIOUSNESS_MODULATION_FUNCTIONS,
        STANDARD_UNIFORMS: STANDARD_CONSCIOUSNESS_UNIFORMS,
        // Logic patterns
        LogicPatterns: ShaderLogicPatterns,
        // Consciousness fragments
        Fragments: ConsciousnessShaderFragments,
        // Optimization utilities
        Optimization: ShaderOptimizationUtils
      };
    }
  });

  // src-js/visual/backgrounds/WebGLGradientBackgroundSystem.ts
  var webglConsciousnessShader, _WebGLGradientBackgroundSystem, WebGLGradientBackgroundSystem;
  var init_WebGLGradientBackgroundSystem = __esm({
    "src-js/visual/backgrounds/WebGLGradientBackgroundSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_UnifiedEventBus();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_ShaderLoader();
      init_BaseVisualSystem();
      init_ConsolidatedShaderLibrary();
      webglConsciousnessShader = ConsciousnessShaderTemplate.buildFragmentShader({
        additionalUniforms: `
// WebGL-specific uniforms
uniform sampler2D u_gradientTex;
uniform float u_flowStrength;
uniform float u_noiseScale;
uniform float u_colorIntensity;
uniform float u_patternScale;
uniform float u_animationSpeed;

// Wave stack uniforms
uniform float u_waveY[2];
uniform float u_waveHeight[2];
uniform float u_waveOffset[2];
uniform float u_blurExp;
uniform float u_blurMax;`,
        additionalFunctions: `
// Octave noise for richer detail
float octaveNoise(vec2 uv, float octaves, float persistence, float scale) {
  float value = 0.0;
  float amplitude = 1.0;
  float frequency = scale;
  float maxValue = 0.0;

  for(float i = 0.0; i < octaves; i++) {
    value += snoise(uv * frequency) * amplitude;
    maxValue += amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return value / maxValue;
}

// Wave alpha calculation
float waveAlpha(vec2 uv, int waveIndex) {
  float y = uv.y;
  float waveCenter = u_waveY[waveIndex];
  float waveHeight = u_waveHeight[waveIndex];

  float distance = abs(y - waveCenter);
  return 1.0 - smoothstep(0.0, waveHeight * 0.5, distance);
}

// Dynamic blur calculation
float calculateBlur(vec2 uv) {
  vec2 center = vec2(0.5, 0.5);
  float distance = length(uv - center);
  float blur = pow(distance, u_blurExp);
  return clamp(blur, 0.0, u_blurMax);
}`,
        mainShaderLogic: CONSCIOUSNESS_SHADER_LIBRARY.Fragments.webglGradientFragment()
      });
      _WebGLGradientBackgroundSystem = class _WebGLGradientBackgroundSystem extends BaseVisualSystem {
        constructor(config = YEAR3000_CONFIG, utils, performanceMonitor, musicSyncService = null, settingsManager = null, year3000System2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager);
          this.canvas = null;
          this.wrapper = null;
          this.gl = null;
          this.shaderProgram = null;
          this.uniforms = {};
          this.gradientTexture = null;
          this.vertexBuffer = null;
          this.vao = null;
          this.settings = {
            enabled: true,
            intensity: "balanced",
            flowStrength: 0.7,
            noiseScale: 1.2,
            waveY: [0.25, 0.75],
            // Wave positions from theme metrics
            waveHeight: [0.4, 0.3],
            // Wave heights for smooth blending
            waveOffset: [2.5, -1.8],
            // Time offsets for wave independence
            blurExp: 1.2,
            // Blur power function exponent
            blurMax: 0.6
            // Maximum blur amount
          };
          this.isWebGLAvailable = false;
          this.animationId = null;
          this.startTime = 0;
          this.lastFrameTime = 0;
          this.frameThrottleInterval = 1e3 / 45;
          // 45 FPS target
          this.colorHarmonyEngine = null;
          this.cssConsciousnessController = null;
          this.eventSubscriptionIds = [];
          this.prefersReducedMotion = false;
          // Consciousness choreographer integration
          this.consciousnessChoreographer = null;
          this.currentConsciousnessField = null;
          this.webglReady = false;
          // Texture creation throttling and debouncing
          this.textureUpdatePending = false;
          this.lastTextureUpdate = 0;
          this.textureUpdateDebounceTimer = null;
          this.textureUpdateThrottleMs = 50;
          // Minimum time between texture updates
          this.textureUpdateDebounceMs = 300;
          // Debounce time for rapid events
          this.textureCreationInProgress = false;
          // WebGL context management
          this.contextLost = false;
          this.pendingContextRestore = false;
          // Quality scaling properties
          this.currentQualityLevel = null;
          this.qualityCapabilities = [
            { name: "webgl-rendering", impact: "high", enabled: true, canToggle: true },
            {
              name: "shader-complexity",
              impact: "high",
              enabled: true,
              canToggle: true
            },
            { name: "noise-octaves", impact: "medium", enabled: true, canToggle: true },
            { name: "wave-layers", impact: "medium", enabled: true, canToggle: true },
            { name: "blur-effects", impact: "low", enabled: true, canToggle: true },
            { name: "flow-strength", impact: "low", enabled: true, canToggle: true }
          ];
          this.qualityAdjustments = {};
          // Required BackgroundSystemParticipant implementation
          this.systemName = "WebGLGradientBackgroundSystem";
          // Event deduplication tracking
          this.lastColorHarmonizedData = null;
          this.lastColorHarmonizedTime = 0;
          this.animate = /* @__PURE__ */ __name(() => {
            if (!this.isActive || !this.gl || !this.canvas) return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.lastFrameTime;
            if (deltaTime < this.frameThrottleInterval) {
              this.animationId = requestAnimationFrame(this.animate);
              return;
            }
            this.lastFrameTime = currentTime;
            this.render(currentTime);
            this.animationId = requestAnimationFrame(this.animate);
          }, "animate");
          this.resize = /* @__PURE__ */ __name(() => {
            if (!this.canvas) return;
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            this.canvas.width = displayWidth * dpr;
            this.canvas.height = displayHeight * dpr;
            this.canvas.style.width = displayWidth + "px";
            this.canvas.style.height = displayHeight + "px";
          }, "resize");
          this.colorHarmonyEngine = year3000System2?.colorHarmonyEngine || null;
          this.consciousnessChoreographer = year3000System2?.backgroundConsciousnessChoreographer || null;
          this.prefersReducedMotion = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;
        }
        get systemPriority() {
          return "high";
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          this.isWebGLAvailable = this.checkWebGL2Support();
          if (!this.isWebGLAvailable) {
            this.fallbackToCSSGradient();
            return;
          }
          const deviceDetector = new DeviceCapabilityDetector();
          if (deviceDetector.recommendPerformanceQuality() === "low") {
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Low performance device detected, falling back to CSS gradient"
            );
            this.fallbackToCSSGradient();
            return;
          }
          this.loadSettings();
          if (!this.settings.enabled) {
            this.fallbackToCSSGradient();
            return;
          }
          try {
            await this.initializeWebGL();
            this.subscribeToEvents();
            this.registerWithConsciousnessChoreographer();
            this.startAnimation();
            document.documentElement.style.setProperty("--sn-webgl-ready", "1");
            document.documentElement.style.setProperty("--sn-webgl-enabled", "1");
            document.documentElement.style.setProperty(
              "--sn-current-backend",
              "hybrid"
            );
            document.documentElement.style.setProperty(
              "--sn-gradient-crossfade-opacity",
              "0.5"
            );
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL gradient system initialized successfully"
            );
          } catch (error) {
            Y3K?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Failed to initialize WebGL gradient:",
              error
            );
            this.fallbackToCSSGradient();
          }
        }
        checkWebGL2Support() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl2");
            if (!gl) {
              Y3K?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "WebGL2 context creation failed"
              );
              return false;
            }
            const requiredExtensions = ["EXT_color_buffer_float"];
            const missingExtensions = [];
            for (const ext of requiredExtensions) {
              if (!gl.getExtension(ext)) {
                missingExtensions.push(ext);
              }
            }
            if (missingExtensions.length > 0) {
              Y3K?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "Missing WebGL2 extensions:",
                missingExtensions
              );
            }
            const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            const maxRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL2 capability check:",
              {
                maxTextureSize,
                maxRenderbufferSize,
                missingExtensions: missingExtensions.length > 0 ? missingExtensions : "none"
              }
            );
            return true;
          } catch (error) {
            Y3K?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "WebGL2 support check failed:",
              error
            );
            return false;
          }
        }
        findSpotifyContainer() {
          const containers = [
            ".Root__main-view",
            ".main-view-container",
            ".main-gridContainer-gridContainer",
            ".Root__top-container",
            "body"
          ];
          for (const selector of containers) {
            const element = document.querySelector(selector);
            if (element) {
              Y3K?.debug?.log(
                "WebGLGradientBackgroundSystem",
                `Found container: ${selector}`
              );
              return element;
            }
          }
          Y3K?.debug?.warn(
            "WebGLGradientBackgroundSystem",
            "No Spotify container found, falling back to body"
          );
          return document.body;
        }
        loadSettings() {
          if (!this.settingsManager) return;
          try {
            const intensitySetting = this.settingsManager.get(
              "sn-flow-gradient"
            );
            if (intensitySetting === "disabled") {
              this.settings.enabled = false;
              return;
            }
            this.settings.intensity = intensitySetting || "balanced";
            switch (this.settings.intensity) {
              case "minimal":
                this.settings.flowStrength = 0.4;
                this.settings.noiseScale = 0.8;
                this.settings.waveHeight = [0.3, 0.2];
                this.settings.waveOffset = [1.5, -1];
                this.settings.blurExp = 1;
                this.settings.blurMax = 0.4;
                break;
              case "balanced":
                this.settings.flowStrength = 0.7;
                this.settings.noiseScale = 1.2;
                this.settings.waveHeight = [0.4, 0.3];
                this.settings.waveOffset = [2.5, -1.8];
                this.settings.blurExp = 1.2;
                this.settings.blurMax = 0.6;
                break;
              case "intense":
                this.settings.flowStrength = 1;
                this.settings.noiseScale = 1.6;
                this.settings.waveHeight = [0.5, 0.4];
                this.settings.waveOffset = [3.5, -2.5];
                this.settings.blurExp = 1.4;
                this.settings.blurMax = 0.8;
                break;
            }
          } catch (error) {
            Y3K?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "Failed to load settings, using defaults:",
              error
            );
          }
        }
        async initializeWebGL() {
          this.wrapper = document.createElement("div");
          this.wrapper.className = "sn-flow-gradient-wrapper";
          this.wrapper.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -11;
      pointer-events: none;
      overflow: hidden;
    `;
          this.canvas = document.createElement("canvas");
          this.canvas.id = "sn-webgl-gradient";
          this.canvas.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    `;
          this.wrapper.appendChild(this.canvas);
          try {
            this.gl = this.canvas.getContext("webgl2", {
              alpha: true,
              antialias: false,
              depth: false,
              stencil: false,
              powerPreference: "default"
            });
            if (!this.gl) {
              throw new Error(
                "WebGL2 context creation returned null - likely unsupported"
              );
            }
            this.setupContextLossHandlers();
            const testResult = this.gl.getParameter(this.gl.VERSION);
            if (!testResult) {
              throw new Error(
                "WebGL2 context appears non-functional - getParameter failed"
              );
            }
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL2 context created successfully:",
              {
                version: testResult,
                renderer: this.gl.getParameter(this.gl.RENDERER),
                vendor: this.gl.getParameter(this.gl.VENDOR)
              }
            );
          } catch (error) {
            Y3K?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "WebGL2 context creation failed:",
              error
            );
            throw new Error(
              `Failed to create WebGL2 context: ${error instanceof Error ? error.message : "Unknown error"}`
            );
          }
          await this.compileShaders();
          this.createGeometry();
          await this.updateGradientTexture();
          this.setupUniforms();
          this.resize();
          const targetContainer = this.findSpotifyContainer();
          targetContainer.appendChild(this.wrapper);
          window.addEventListener("resize", this.resize.bind(this));
        }
        async compileShaders() {
          if (!this.gl) throw new Error("WebGL context not available");
          const vertexShader = ShaderLoader.loadVertex(
            this.gl,
            DEFAULT_VERTEX_SHADER
          );
          const fragmentShader = ShaderLoader.loadFragment(
            this.gl,
            webglConsciousnessShader
          );
          if (!vertexShader || !fragmentShader) {
            throw new Error("Failed to compile shaders");
          }
          this.shaderProgram = ShaderLoader.createProgram(
            this.gl,
            vertexShader,
            fragmentShader
          );
          if (!this.shaderProgram) {
            throw new Error("Failed to create shader program");
          }
        }
        createGeometry() {
          if (!this.gl || !this.shaderProgram) return;
          const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
          this.vertexBuffer = this.gl.createBuffer();
          this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
          this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
          this.vao = this.gl.createVertexArray();
          this.gl.bindVertexArray(this.vao);
          const positionLocation = this.gl.getAttribLocation(
            this.shaderProgram,
            "a_position"
          );
          this.gl.enableVertexAttribArray(positionLocation);
          this.gl.vertexAttribPointer(
            positionLocation,
            2,
            this.gl.FLOAT,
            false,
            0,
            0
          );
          this.gl.bindVertexArray(null);
        }
        setupUniforms() {
          if (!this.gl || !this.shaderProgram) return;
          this.uniforms.u_time = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_time"
          );
          this.uniforms.u_gradientTex = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_gradientTex"
          );
          this.uniforms.u_resolution = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_resolution"
          );
          this.uniforms.u_flowStrength = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_flowStrength"
          );
          this.uniforms.u_noiseScale = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_noiseScale"
          );
          this.uniforms.u_waveY = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveY"
          );
          this.uniforms.u_waveHeight = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveHeight"
          );
          this.uniforms.u_waveOffset = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveOffset"
          );
          this.uniforms.u_blurExp = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_blurExp"
          );
          this.uniforms.u_blurMax = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_blurMax"
          );
        }
        async updateGradientTexture() {
          if (!this.gl) {
            Y3K?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "No WebGL context available"
            );
            return;
          }
          if (!this.isContextValid()) {
            Y3K?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "WebGL context invalid, attempting recovery"
            );
            if (this.contextLost && !this.pendingContextRestore) {
              Y3K?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "Attempting WebGL context recovery"
              );
              this.fallbackToCSSGradient();
            }
            return;
          }
          const preError = this.gl.getError();
          if (preError !== this.gl.NO_ERROR) {
            Y3K?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              `WebGL error detected before texture update: ${preError}`
            );
            while (this.gl.getError() !== this.gl.NO_ERROR) {
            }
          }
          if (this.textureCreationInProgress) {
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Texture creation already in progress, skipping update"
            );
            return;
          }
          this.textureCreationInProgress = true;
          try {
            let colorStops = this.getDefaultGradientStops();
            let colorSource = "default";
            if (this.colorHarmonyEngine) {
              try {
                const currentGradient = this.colorHarmonyEngine.getCurrentGradient(5);
                if (currentGradient && currentGradient.length > 0) {
                  colorStops = currentGradient.map((color2, index) => ({
                    r: color2.r / 255,
                    g: color2.g / 255,
                    b: color2.b / 255,
                    a: 1,
                    position: index / (currentGradient.length - 1)
                  }));
                  colorSource = "ColorHarmonyEngine";
                  Y3K?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    `Updated gradient texture with ${colorStops.length} stops from ColorHarmonyEngine`
                  );
                } else {
                  const cssColorStops = this.getCSSGradientStops();
                  if (cssColorStops && cssColorStops.length > 0) {
                    colorStops = cssColorStops;
                    colorSource = "CSS variables";
                    Y3K?.debug?.log(
                      "WebGLGradientBackgroundSystem",
                      `ColorHarmonyEngine returned empty, using CSS gradient fallback with ${colorStops.length} stops`
                    );
                  }
                }
              } catch (error) {
                Y3K?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  "Failed to get gradient from ColorHarmonyEngine, trying CSS fallback:",
                  error
                );
                const cssColorStops = this.getCSSGradientStops();
                if (cssColorStops && cssColorStops.length > 0) {
                  colorStops = cssColorStops;
                  colorSource = "CSS variables (engine failed)";
                  Y3K?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    `Using CSS gradient fallback after ColorHarmonyEngine error with ${colorStops.length} stops`
                  );
                }
              }
            } else {
              const cssColorStops = this.getCSSGradientStops();
              if (cssColorStops && cssColorStops.length > 0) {
                colorStops = cssColorStops;
                colorSource = "CSS variables (no engine)";
                Y3K?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `No ColorHarmonyEngine available, using CSS gradient fallback with ${colorStops.length} stops`
                );
              }
            }
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Final color source: ${colorSource}, stops: ${colorStops.length}`
            );
            if (this.gl.isContextLost()) {
              throw new Error("WebGL context was lost during gradient preparation");
            }
            if (this.gradientTexture) {
              try {
                this.gl.deleteTexture(this.gradientTexture);
              } catch (error) {
                Y3K?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  "Error deleting old texture:",
                  error
                );
              }
              this.gradientTexture = null;
            }
            if (!colorStops || colorStops.length === 0) {
              Y3K?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "No valid color stops, using defaults"
              );
              colorStops = this.getDefaultGradientStops();
            }
            let newTexture = null;
            let attempts = 0;
            const maxAttempts = 3;
            while (!newTexture && attempts < maxAttempts) {
              attempts++;
              try {
                if (this.gl.isContextLost()) {
                  throw new Error(
                    "WebGL context lost during texture creation attempt"
                  );
                }
                newTexture = createGradientTexture(this.gl, colorStops);
                if (newTexture) {
                  Y3K?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    `Gradient texture created successfully on attempt ${attempts}`
                  );
                  break;
                }
              } catch (error) {
                Y3K?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  `Texture creation attempt ${attempts} failed:`,
                  error
                );
                if (attempts < maxAttempts) {
                  await new Promise((resolve) => setTimeout(resolve, attempts * 10));
                }
              }
            }
            if (!newTexture) {
              Y3K?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Failed to create gradient texture after all attempts - trying default colors"
              );
              try {
                const defaultStops = this.getDefaultGradientStops();
                const fallbackTexture = createGradientTexture(this.gl, defaultStops);
                if (!fallbackTexture) {
                  throw new Error(
                    "Failed to create gradient texture even with default colors"
                  );
                }
                this.gradientTexture = fallbackTexture;
                colorStops = defaultStops;
                Y3K?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  "Using default gradient fallback after all attempts failed"
                );
              } catch (fallbackError) {
                Y3K?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "Default gradient fallback failed:",
                  fallbackError
                );
                throw new Error(
                  `Gradient texture creation completely failed: ${fallbackError}`
                );
              }
            } else {
              this.gradientTexture = newTexture;
            }
            this.lastTextureUpdate = performance.now();
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Gradient texture updated successfully using ${colorSource}`,
              {
                colorStops: colorStops.length,
                source: colorSource,
                firstColor: colorStops[0] ? `rgb(${Math.round(colorStops[0].r * 255)},${Math.round(
                  colorStops[0].g * 255
                )},${Math.round(colorStops[0].b * 255)})` : "none"
              }
            );
          } catch (error) {
            Y3K?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Critical error in updateGradientTexture:",
              error
            );
            if (error instanceof Error && error.message.includes("context")) {
              Y3K?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "WebGL context-related error detected, switching to CSS fallback"
              );
              this.fallbackToCSSGradient();
            } else {
              Y3K?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "Attempting simple texture recovery with default colors"
              );
              try {
                this.gradientTexture = null;
                const defaultStops = this.getDefaultGradientStops();
                if (this.gl && !this.gl.isContextLost()) {
                  this.gradientTexture = createGradientTexture(this.gl, defaultStops);
                  if (this.gradientTexture) {
                    Y3K?.debug?.log(
                      "WebGLGradientBackgroundSystem",
                      "Successfully recovered with default gradient"
                    );
                  } else {
                    throw new Error("Recovery attempt failed");
                  }
                } else {
                  throw new Error("WebGL context unavailable for recovery");
                }
              } catch (recoveryError) {
                Y3K?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "Recovery attempt failed, falling back to CSS:",
                  recoveryError
                );
                this.fallbackToCSSGradient();
              }
            }
          } finally {
            this.textureCreationInProgress = false;
          }
        }
        /**
         * Throttled texture update to prevent rapid-fire texture creation
         */
        async updateGradientTextureThrottled() {
          const now = performance.now();
          if (now - this.lastTextureUpdate < this.textureUpdateThrottleMs) {
            if (!this.textureUpdatePending) {
              this.textureUpdatePending = true;
              const timeToWait = this.textureUpdateThrottleMs - (now - this.lastTextureUpdate);
              setTimeout(() => {
                this.textureUpdatePending = false;
                this.updateGradientTexture().catch((error) => {
                  Y3K?.debug?.error(
                    "WebGLGradientBackgroundSystem",
                    "Throttled texture update failed:",
                    error
                  );
                });
              }, timeToWait);
            }
            return;
          }
          await this.updateGradientTexture();
        }
        /**
         * Debounced texture update to handle rapid event sequences
         */
        debouncedUpdateGradientTexture() {
          if (this.textureUpdateDebounceTimer) {
            clearTimeout(this.textureUpdateDebounceTimer);
          }
          this.textureUpdateDebounceTimer = window.setTimeout(() => {
            this.textureUpdateDebounceTimer = null;
            this.updateGradientTextureThrottled().catch((error) => {
              Y3K?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Debounced texture update failed:",
                error
              );
            });
          }, this.textureUpdateDebounceMs);
        }
        /**
         * Setup WebGL context loss and restore event handlers
         */
        setupContextLossHandlers() {
          if (!this.canvas) return;
          this.canvas.addEventListener(
            "webglcontextlost",
            async (event) => {
              Y3K?.debug?.warn("WebGLGradientBackgroundSystem", "WebGL context lost");
              event.preventDefault();
              this.contextLost = true;
              this.textureCreationInProgress = false;
              if (this.gl) {
                try {
                  const { ShaderLoader: ShaderLoader2 } = await Promise.resolve().then(() => (init_ShaderLoader(), ShaderLoader_exports));
                  ShaderLoader2.clearContextCache(this.gl);
                } catch (e) {
                }
              }
              if (this.textureUpdateDebounceTimer) {
                clearTimeout(this.textureUpdateDebounceTimer);
                this.textureUpdateDebounceTimer = null;
              }
              this.textureUpdatePending = false;
              if (this.animationId) {
                cancelAnimationFrame(this.animationId);
                this.animationId = null;
              }
            },
            false
          );
          this.canvas.addEventListener(
            "webglcontextrestored",
            async () => {
              Y3K?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "WebGL context restored, reinitializing"
              );
              this.contextLost = false;
              this.pendingContextRestore = true;
              try {
                if (!this.gl || this.gl.isContextLost()) {
                  throw new Error("Context is still lost after restore event");
                }
                await this.reinitializeWebGLResources();
                this.startAnimation();
                this.pendingContextRestore = false;
                Y3K?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  "WebGL context restore completed successfully"
                );
              } catch (error) {
                Y3K?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "Failed to restore WebGL context:",
                  error
                );
                this.pendingContextRestore = false;
                this.fallbackToCSSGradient();
              }
            },
            false
          );
        }
        /**
         * Reinitialize WebGL resources after context restore
         */
        async reinitializeWebGLResources() {
          if (!this.gl) throw new Error("WebGL context not available");
          this.shaderProgram = null;
          this.vertexBuffer = null;
          this.vao = null;
          this.gradientTexture = null;
          const { ShaderLoader: ShaderLoader2 } = await Promise.resolve().then(() => (init_ShaderLoader(), ShaderLoader_exports));
          ShaderLoader2.clearContextCache(this.gl);
          await this.compileShaders();
          this.createGeometry();
          await this.updateGradientTexture();
          this.setupUniforms();
          Y3K?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "WebGL resources reinitialized after context restore"
          );
        }
        /**
         * Check if WebGL context is available and functional
         */
        isContextValid() {
          if (!this.gl) return false;
          if (this.contextLost) return false;
          if (this.gl.isContextLost()) {
            this.contextLost = true;
            return false;
          }
          return true;
        }
        getDefaultGradientStops() {
          return [
            { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 0 },
            // Base
            { r: 0.549, g: 0.408, b: 0.878, a: 1, position: 0.3 },
            // Mauve
            { r: 0.788, g: 0.557, b: 0.902, a: 1, position: 0.6 },
            // Pink
            { r: 0.957, g: 0.761, b: 0.494, a: 1, position: 1 }
            // Peach
          ];
        }
        /**
         * Get gradient color stops from CSS variables that inherit from ColorHarmonyEngine
         * These variables are set by OKLAB processing and represent the actual background gradient colors
         */
        getCSSGradientStops() {
          try {
            const root = document.documentElement;
            const computedStyle = getComputedStyle(root);
            const gradientVariables = [
              "--sn-bg-gradient-primary-rgb",
              "--sn-bg-gradient-secondary-rgb",
              "--sn-bg-gradient-tertiary-rgb"
            ];
            const colorStops = [];
            for (let i = 0; i < gradientVariables.length; i++) {
              const variableName = gradientVariables[i] || "--sn-bg-gradient-primary-rgb";
              const rgbStr = computedStyle.getPropertyValue(variableName).trim();
              if (!rgbStr) {
                Y3K?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `CSS variable ${variableName} not set, trying without CSS fallback`
                );
                continue;
              }
              const rgbValues = rgbStr.split(",").map((v) => parseInt(v.trim(), 10));
              if (rgbValues.length !== 3 || rgbValues.some((v) => isNaN(v) || v < 0 || v > 255)) {
                Y3K?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  `Invalid RGB values in ${variableName}: ${rgbStr}, skipping this color`
                );
                continue;
              }
              colorStops.push({
                r: (rgbValues[0] ?? 0) / 255,
                g: (rgbValues[1] ?? 0) / 255,
                b: (rgbValues[2] ?? 0) / 255,
                a: 1,
                position: i / (gradientVariables.length - 1)
              });
            }
            if (colorStops.length < 2) {
              Y3K?.debug?.log(
                "WebGLGradientBackgroundSystem",
                `Only ${colorStops.length} valid CSS colors found, need at least 2 for gradient`
              );
              return null;
            }
            const opacityStr = computedStyle.getPropertyValue("--sn-bg-gradient-opacity").trim();
            const opacity = opacityStr ? parseFloat(opacityStr) : 1;
            if (opacity !== 1 && opacity > 0 && opacity <= 1) {
              colorStops.forEach((stop) => {
                stop.a = opacity;
              });
            }
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Successfully parsed ${colorStops.length} CSS background gradient stops from OKLAB inheritance`,
              {
                colors: colorStops.map(
                  (stop) => `rgba(${Math.round(stop.r * 255)},${Math.round(
                    stop.g * 255
                  )},${Math.round(stop.b * 255)},${stop.a})`
                ),
                opacity: opacity !== 1 ? opacity : "default"
              }
            );
            return colorStops;
          } catch (error) {
            Y3K?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "Failed to parse CSS background gradient variables:",
              error
            );
            return null;
          }
        }
        subscribeToEvents() {
          const colorHarmonizedSub = unifiedEventBus.subscribe(
            "colors:harmonized",
            this.handleColorHarmonized.bind(this),
            "WebGLGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(colorHarmonizedSub);
          const colorAppliedSub = unifiedEventBus.subscribe(
            "colors:applied",
            this.handleColorApplied.bind(this),
            "WebGLGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(colorAppliedSub);
          Y3K?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Subscribed to unified events",
            {
              subscriptionCount: this.eventSubscriptionIds.length
            }
          );
        }
        handleColorHarmonized(data) {
          const currentTime = performance.now();
          const dataHash = `${data.accentHex}-${data.processingTime}-${data.strategies.join(",")}`;
          if (this.lastColorHarmonizedData === dataHash && currentTime - this.lastColorHarmonizedTime < 100) {
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Duplicate color harmonization event detected, skipping"
            );
            return;
          }
          this.lastColorHarmonizedData = dataHash;
          this.lastColorHarmonizedTime = currentTime;
          this.debouncedUpdateGradientTexture();
          Y3K?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Color harmonization processed",
            {
              strategies: data.strategies,
              processingTime: data.processingTime,
              accentHex: data.accentHex,
              deduplicationHash: dataHash.substring(0, 16) + "..."
            }
          );
        }
        handleColorApplied(data) {
          Y3K?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Color application coordinated",
            {
              accentHex: data.accentHex,
              appliedAt: data.appliedAt
            }
          );
        }
        startAnimation() {
          this.startTime = performance.now();
          this.lastFrameTime = this.startTime;
          this.animate();
        }
        render(currentTime) {
          if (!this.gl || !this.shaderProgram || !this.vao || !this.gradientTexture)
            return;
          this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
          this.gl.clearColor(0, 0, 0, 0);
          this.gl.clear(this.gl.COLOR_BUFFER_BIT);
          this.gl.useProgram(this.shaderProgram);
          this.gl.bindVertexArray(this.vao);
          if (!this.webglReady) {
            this.webglReady = true;
            document.documentElement.style.setProperty("--sn-webgl-ready", "1");
            document.documentElement.style.setProperty("--sn-webgl-enabled", "1");
            document.documentElement.style.setProperty(
              "--sn-current-backend",
              "hybrid"
            );
            document.documentElement.style.setProperty(
              "--sn-gradient-crossfade-opacity",
              "0.5"
            );
          }
          const time = this.prefersReducedMotion ? 0 : (currentTime - this.startTime) / 1e3;
          if (this.uniforms.u_time) {
            this.gl.uniform1f(this.uniforms.u_time, time);
          }
          if (this.uniforms.u_resolution) {
            this.gl.uniform2f(
              this.uniforms.u_resolution,
              this.canvas.width,
              this.canvas.height
            );
          }
          if (this.uniforms.u_flowStrength) {
            const rootStyle = document.documentElement;
            const flowStrengthValue = rootStyle.style.getPropertyValue("--sn-flow-strength").trim();
            const flowStrength = flowStrengthValue ? parseFloat(flowStrengthValue) : this.settings.flowStrength;
            this.gl.uniform1f(this.uniforms.u_flowStrength, flowStrength);
          }
          if (this.uniforms.u_noiseScale) {
            this.gl.uniform1f(this.uniforms.u_noiseScale, this.settings.noiseScale);
          }
          if (this.uniforms.u_waveY) {
            this.gl.uniform1fv(this.uniforms.u_waveY, this.settings.waveY);
          }
          if (this.uniforms.u_waveHeight) {
            this.gl.uniform1fv(this.uniforms.u_waveHeight, this.settings.waveHeight);
          }
          if (this.uniforms.u_waveOffset) {
            this.gl.uniform1fv(this.uniforms.u_waveOffset, this.settings.waveOffset);
          }
          if (this.uniforms.u_blurExp) {
            this.gl.uniform1f(this.uniforms.u_blurExp, this.settings.blurExp);
          }
          if (this.uniforms.u_blurMax) {
            this.gl.uniform1f(this.uniforms.u_blurMax, this.settings.blurMax);
          }
          this.gl.activeTexture(this.gl.TEXTURE0);
          this.gl.bindTexture(this.gl.TEXTURE_2D, this.gradientTexture);
          if (this.uniforms.u_gradientTex) {
            this.gl.uniform1i(this.uniforms.u_gradientTex, 0);
          }
          this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
          this.gl.bindVertexArray(null);
        }
        fallbackToCSSGradient() {
          document.documentElement.style.setProperty("--sn-webgl-ready", "0");
          document.documentElement.style.setProperty("--sn-webgl-enabled", "0");
          document.documentElement.style.setProperty("--sn-current-backend", "css");
          document.documentElement.style.setProperty(
            "--sn-gradient-crossfade-opacity",
            "0"
          );
          if (this.cssConsciousnessController) {
            this.startCSSFallbackAnimation();
          }
          Y3K?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Using CSS gradient fallback"
          );
        }
        startCSSFallbackAnimation() {
          if (!this.cssConsciousnessController) return;
          const animateCSS = /* @__PURE__ */ __name(() => {
            if (!this.isActive) return;
            const time = performance.now() / 1e3;
            const flowX = Math.sin(time * 0.04) * 20 + Math.sin(time * 0.07) * 8;
            const flowY = Math.cos(time * 0.05) * 20 + Math.cos(time * 0.09) * 6;
            const scale = 1.15 + Math.sin(time * 0.03) * 0.2;
            const batcher = this.cssConsciousnessController;
            if (!batcher) return;
            batcher.queueCSSVariableUpdate("--sn-gradient-flow-x", `${flowX}%`);
            batcher.queueCSSVariableUpdate("--sn-gradient-flow-y", `${flowY}%`);
            batcher.queueCSSVariableUpdate(
              "--sn-gradient-flow-scale",
              scale.toString()
            );
            setTimeout(animateCSS, this.frameThrottleInterval);
          }, "animateCSS");
          animateCSS();
        }
        handleSettingsChange(event) {
          super.handleSettingsChange(event);
          const customEvent = event;
          const { key, value } = customEvent.detail;
          if (key === "sn-flow-gradient") {
            const wasEnabled = this.settings.enabled;
            this.settings.intensity = value;
            this.loadSettings();
            if (value === "disabled" && wasEnabled) {
              this.settings.enabled = false;
              this.destroy();
              this.fallbackToCSSGradient();
            } else if (this.settings.enabled && !wasEnabled && this.isWebGLAvailable) {
              this.initialize();
            }
          }
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.consciousnessChoreographer) {
            try {
              this.consciousnessChoreographer.unregisterConsciousnessParticipant(
                "WebGLGradientBackgroundSystem"
              );
              Y3K?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "Unregistered from consciousness choreographer"
              );
            } catch (error) {
              Y3K?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Error unregistering from consciousness choreographer:",
                error
              );
            }
          }
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
          if (this.textureUpdateDebounceTimer) {
            clearTimeout(this.textureUpdateDebounceTimer);
            this.textureUpdateDebounceTimer = null;
          }
          this.textureUpdatePending = false;
          this.textureCreationInProgress = false;
          this.lastColorHarmonizedData = null;
          if (this.gl) {
            if (this.gradientTexture) {
              this.gl.deleteTexture(this.gradientTexture);
              this.gradientTexture = null;
            }
            if (this.vertexBuffer) {
              this.gl.deleteBuffer(this.vertexBuffer);
              this.vertexBuffer = null;
            }
            if (this.vao) {
              this.gl.deleteVertexArray(this.vao);
              this.vao = null;
            }
            if (this.shaderProgram) {
              this.gl.deleteProgram(this.shaderProgram);
              this.shaderProgram = null;
            }
            ShaderLoader.clearCache(this.gl);
          }
          if (this.wrapper && this.wrapper.parentNode) {
            this.wrapper.parentNode.removeChild(this.wrapper);
            this.wrapper = null;
          }
          this.canvas = null;
          this.eventSubscriptionIds.forEach((subscriptionId) => {
            unifiedEventBus.unsubscribe(subscriptionId);
          });
          this.eventSubscriptionIds = [];
          Y3K?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Unified event subscriptions cleaned up"
          );
          window.removeEventListener("resize", this.resize);
          this.gl = null;
          document.documentElement.style.setProperty("--sn-webgl-ready", "0");
          document.documentElement.style.setProperty("--sn-webgl-enabled", "0");
          document.documentElement.style.setProperty("--sn-current-backend", "css");
          document.documentElement.style.setProperty(
            "--sn-gradient-crossfade-opacity",
            "0"
          );
        }
        forceRepaint(_reason = "settings-change") {
          if (this.isActive && this.gradientTexture) {
            this.updateGradientTexture().catch((error) => {
              Y3K?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Failed to repaint gradient:",
                error
              );
            });
          }
        }
        // Public setters for wave parameters
        setWaveY(waveY) {
          this.settings.waveY = waveY;
        }
        setWaveHeight(waveHeight) {
          this.settings.waveHeight = waveHeight;
        }
        setWaveOffset(waveOffset) {
          this.settings.waveOffset = waveOffset;
        }
        setBlurSettings(blurExp, blurMax) {
          this.settings.blurExp = blurExp;
          this.settings.blurMax = blurMax;
        }
        getMetrics() {
          return {
            fps: this.performanceMonitor?.getMedianFPS?.() || 0,
            compileErrors: 0,
            // TODO: Track compilation errors
            isActive: this.isActive,
            settings: { ...this.settings }
          };
        }
        /**
         * Gracefully stop the animation loop.  Exposed for backplane adapters.
         */
        stopAnimation() {
          if (this.animationId !== null) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
        }
        /**
         * Lightweight health check used by adapters; returns OK if WebGL is ready.
         */
        async healthCheck() {
          return {
            ok: this.webglReady,
            details: this.webglReady ? "WebGL system nominal" : "WebGL not initialized"
          };
        }
        /**
         * Alternative resize helper that allows explicit dimensions while leaving
         * the original `resize` listener (no-arg) intact.
         */
        resizeTo(width, height) {
          if (!this.canvas) return;
          this.canvas.width = width;
          this.canvas.height = height;
          this.resize?.();
        }
        // ===================================================================
        // CONSCIOUSNESS CHOREOGRAPHER INTEGRATION
        // ===================================================================
        /**
         * Register this WebGL system as a consciousness participant
         */
        registerWithConsciousnessChoreographer() {
          if (!this.consciousnessChoreographer) {
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Consciousness choreographer not available, skipping registration"
            );
            return;
          }
          try {
            this.consciousnessChoreographer.registerConsciousnessParticipant(this);
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Successfully registered with consciousness choreographer"
            );
          } catch (error) {
            Y3K?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Failed to register with consciousness choreographer:",
              error
            );
          }
        }
        // ===================================================================
        // BACKGROUND SYSTEM PARTICIPANT INTERFACE IMPLEMENTATION
        // ===================================================================
        // SystemName and systemPriority already declared above
        getConsciousnessContribution() {
          return {
            webglLuminosity: this.settings.flowStrength || 0.5,
            shaderComplexity: this.isWebGLAvailable ? 0.8 : 0,
            gpuUtilization: this.isWebGLAvailable ? 0.6 : 0,
            renderingPipeline: "forward",
            textureResolution: 1
          };
        }
        onConsciousnessFieldUpdate(field) {
          if (!this.isWebGLAvailable || !this.webglReady) return;
          try {
            this.currentConsciousnessField = field;
            this.updateShaderFromConsciousness(field);
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Updated from consciousness field:",
              {
                rhythmicPulse: field.rhythmicPulse,
                webglLuminosity: field.webglLuminosity,
                emotionalTemperature: field.emotionalTemperature
              }
            );
          } catch (error) {
            Y3K?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Error updating from consciousness field:",
              error
            );
          }
        }
        onChoreographyEvent(eventType, payload) {
          if (!this.isWebGLAvailable || !this.webglReady) return;
          try {
            switch (eventType) {
              case "choreography:rhythm-shift":
                this.frameThrottleInterval = 1e3 / Math.max(30, Math.min(60, payload.newRhythm?.bpm / 2 || 45));
                break;
              case "choreography:energy-surge":
                if (this.cssConsciousnessController) {
                  const surgeIntensity = payload.intensity || 1;
                  this.cssConsciousnessController.queueCSSVariableUpdate(
                    "--sn-webgl-energy-surge",
                    surgeIntensity.toString()
                  );
                }
                break;
              case "consciousness:breathing-cycle":
                const breathingPhase = payload.phase || 0;
                if (this.cssConsciousnessController) {
                  this.cssConsciousnessController.queueCSSVariableUpdate(
                    "--sn-webgl-breathing-sync",
                    breathingPhase.toString()
                  );
                }
                break;
            }
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Handled choreography event: ${eventType}`,
              payload
            );
          } catch (error) {
            Y3K?.debug?.error(
              "WebGLGradientBackgroundSystem",
              `Error handling choreography event ${eventType}:`,
              error
            );
          }
        }
        /**
         * Update WebGL shader parameters based on consciousness field
         */
        updateShaderFromConsciousness(field) {
          if (!this.gl || !this.shaderProgram) return;
          const consciousFlowStrength = this.settings.flowStrength * (0.5 + field.rhythmicPulse * 0.5);
          const flowStrengthLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_flowStrength"
          );
          if (flowStrengthLocation) {
            this.gl.uniform1f(flowStrengthLocation, consciousFlowStrength);
          }
          const consciousNoiseScale = this.settings.noiseScale * (0.8 + field.musicalFlow.x * 0.4);
          const noiseScaleLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_noiseScale"
          );
          if (noiseScaleLocation) {
            this.gl.uniform1f(noiseScaleLocation, consciousNoiseScale);
          }
          const breathingModulation = Math.sin(Date.now() * 1e-3 * field.breathingCycle) * 0.1;
          const waveYLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveY"
          );
          if (waveYLocation) {
            const modulatedWaveY = [
              this.settings.waveY[0] + breathingModulation,
              this.settings.waveY[1] - breathingModulation
            ];
            this.gl.uniform1fv(waveYLocation, modulatedWaveY);
          }
          if (this.cssConsciousnessController) {
            this.cssConsciousnessController.queueCSSVariableUpdate(
              "--sn-webgl-consciousness-flow",
              consciousFlowStrength.toString()
            );
            this.cssConsciousnessController.queueCSSVariableUpdate(
              "--sn-webgl-consciousness-noise",
              consciousNoiseScale.toString()
            );
            this.cssConsciousnessController.queueCSSVariableUpdate(
              "--sn-webgl-breathing-phase",
              breathingModulation.toString()
            );
          }
        }
        // ========================================================================
        // QUALITY SCALING INTERFACE IMPLEMENTATION
        // ========================================================================
        /**
         * Set quality level for WebGL rendering
         */
        setQualityLevel(level) {
          this.currentQualityLevel = level;
          switch (level.level) {
            case "minimal":
              this.settings.flowStrength = 0.3;
              this.settings.noiseScale = 0.8;
              this.settings.waveHeight = [0.2, 0.15];
              this.settings.blurExp = 0.8;
              this.settings.blurMax = 0.3;
              this.frameThrottleInterval = 1e3 / 20;
              if (!level.features.webgl) {
                this.fallbackToCSSGradient();
                return;
              }
              break;
            case "low":
              this.settings.flowStrength = 0.5;
              this.settings.noiseScale = 1;
              this.settings.waveHeight = [0.3, 0.2];
              this.settings.blurExp = 1;
              this.settings.blurMax = 0.4;
              this.frameThrottleInterval = 1e3 / 30;
              break;
            case "medium":
              this.settings.flowStrength = 0.7;
              this.settings.noiseScale = 1.2;
              this.settings.waveHeight = [0.4, 0.3];
              this.settings.blurExp = 1.2;
              this.settings.blurMax = 0.6;
              this.frameThrottleInterval = 1e3 / 45;
              break;
            case "high":
              this.settings.flowStrength = 0.9;
              this.settings.noiseScale = 1.4;
              this.settings.waveHeight = [0.5, 0.4];
              this.settings.blurExp = 1.3;
              this.settings.blurMax = 0.7;
              this.frameThrottleInterval = 1e3 / 60;
              break;
            case "ultra":
              this.settings.flowStrength = 1;
              this.settings.noiseScale = 1.6;
              this.settings.waveHeight = [0.6, 0.5];
              this.settings.blurExp = 1.4;
              this.settings.blurMax = 0.8;
              this.frameThrottleInterval = 1e3 / 60;
              break;
          }
          this.updateQualityCapabilities(level);
          Y3K?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Quality level set to: ${level.level}`,
            {
              flowStrength: this.settings.flowStrength,
              frameRate: 1e3 / this.frameThrottleInterval
            }
          );
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const currentFPS = this.lastFrameTime > 0 ? 1e3 / this.lastFrameTime : 60;
          const memoryUsage = this.estimateMemoryUsage();
          return {
            fps: currentFPS,
            frameTime: this.lastFrameTime,
            memoryUsageMB: memoryUsage,
            cpuUsagePercent: this.estimateCPUUsage(),
            gpuUsagePercent: this.isWebGLAvailable ? 25 : 5,
            renderTime: this.lastFrameTime,
            timestamp: performance.now()
          };
        }
        /**
         * Reduce quality by specified amount
         */
        reduceQuality(amount) {
          this.qualityAdjustments["flow-reduction"] = (this.qualityAdjustments["flow-reduction"] || 0) + amount;
          this.qualityAdjustments["noise-reduction"] = (this.qualityAdjustments["noise-reduction"] || 0) + amount * 0.8;
          this.qualityAdjustments["wave-reduction"] = (this.qualityAdjustments["wave-reduction"] || 0) + amount * 0.6;
          this.settings.flowStrength = Math.max(
            0.1,
            this.settings.flowStrength * (1 - amount)
          );
          this.settings.noiseScale = Math.max(
            0.5,
            this.settings.noiseScale * (1 - amount * 0.8)
          );
          this.settings.waveHeight = [
            Math.max(0.1, this.settings.waveHeight[0] * (1 - amount * 0.6)),
            Math.max(0.1, this.settings.waveHeight[1] * (1 - amount * 0.6))
          ];
          if (amount > 0.5) {
            this.frameThrottleInterval = Math.min(
              1e3 / 15,
              this.frameThrottleInterval * (1 + amount)
            );
          }
          Y3K?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Quality reduced by ${amount}`,
            this.settings
          );
        }
        /**
         * Increase quality by specified amount
         */
        increaseQuality(amount) {
          Object.keys(this.qualityAdjustments).forEach((key) => {
            this.qualityAdjustments[key] = Math.max(
              0,
              (this.qualityAdjustments[key] || 0) - amount
            );
          });
          if (this.currentQualityLevel) {
            const baseSettings = this.getBaseSettingsForLevel(this.currentQualityLevel.level) || this.settings;
            this.settings.flowStrength = Math.min(
              baseSettings.flowStrength,
              this.settings.flowStrength * (1 + amount * 0.5)
            );
            this.settings.noiseScale = Math.min(
              baseSettings.noiseScale,
              this.settings.noiseScale * (1 + amount * 0.3)
            );
            this.frameThrottleInterval = Math.max(
              1e3 / this.currentQualityLevel.targetFPS,
              this.frameThrottleInterval * (1 - amount * 0.3)
            );
          }
          Y3K?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Quality increased by ${amount}`,
            this.settings
          );
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          return [...this.qualityCapabilities];
        }
        // ========================================================================
        // QUALITY SCALING HELPER METHODS
        // ========================================================================
        updateQualityCapabilities(level) {
          this.qualityCapabilities.forEach((capability) => {
            switch (capability.name) {
              case "webgl-rendering":
                capability.enabled = level.features.webgl;
                break;
              case "shader-complexity":
                capability.enabled = level.features.shaders;
                break;
              case "blur-effects":
                capability.enabled = level.features.blur;
                break;
              default:
                capability.enabled = level.level !== "minimal";
            }
          });
        }
        getBaseSettingsForLevel(level) {
          const baseSettings = { ...this.settings };
          switch (level) {
            case "minimal":
              return { ...baseSettings, flowStrength: 0.3, noiseScale: 0.8 };
            case "low":
              return { ...baseSettings, flowStrength: 0.5, noiseScale: 1 };
            case "medium":
              return { ...baseSettings, flowStrength: 0.7, noiseScale: 1.2 };
            case "high":
              return { ...baseSettings, flowStrength: 0.9, noiseScale: 1.4 };
            case "ultra":
              return { ...baseSettings, flowStrength: 1, noiseScale: 1.6 };
            default:
              return baseSettings;
          }
        }
        estimateMemoryUsage() {
          let usage = 5;
          if (this.canvas && this.gl) {
            const pixels = this.canvas.width * this.canvas.height;
            usage += pixels * 4 / (1024 * 1024);
            if (this.gradientTexture) usage += 1;
            if (this.vertexBuffer) usage += 0.1;
          }
          return usage;
        }
        estimateCPUUsage() {
          const baseUsage = this.isWebGLAvailable ? 5 : 15;
          const qualityMultiplier = this.settings.flowStrength + this.settings.noiseScale / 2;
          return Math.min(50, baseUsage * qualityMultiplier);
        }
      };
      __name(_WebGLGradientBackgroundSystem, "WebGLGradientBackgroundSystem");
      WebGLGradientBackgroundSystem = _WebGLGradientBackgroundSystem;
    }
  });

  // src-js/visual/organic-consciousness/OrganicBeatSyncConsciousness.ts
  var _OrganicBeatSyncConsciousness, OrganicBeatSyncConsciousness;
  var init_OrganicBeatSyncConsciousness = __esm({
    "src-js/visual/organic-consciousness/OrganicBeatSyncConsciousness.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_Year3000Utilities();
      init_MusicalLerpOrchestrator();
      _OrganicBeatSyncConsciousness = class _OrganicBeatSyncConsciousness extends UnifiedSystemBase {
        constructor(config) {
          super(config);
          // =========================================================================
          // ORGANIC CONSCIOUSNESS STATE
          // =========================================================================
          // Core organic properties (current values)
          this.organicIntensity = 0;
          this.cellularGrowth = 1;
          this.breathingPhase = 0;
          this.emotionalTemperature = 4e3;
          // 1000K-20000K range
          this.membraneFluidityLevel = 0.5;
          // Target values for smooth LERP interpolation
          this.targetOrganicIntensity = 0;
          this.targetCellularGrowth = 1;
          this.targetEmotionalTemperature = 4e3;
          this.targetMembraneFluidityLevel = 0.5;
          // LERP smoothing half-life values (in seconds)
          this.lerpHalfLifeValues = {
            intensityAttack: 0.05,
            // Fast attack for beat response
            intensityDecay: 0.15,
            // Smooth decay
            cellularGrowth: 0.08,
            // Organic cellular response  
            emotionalTemperature: 0.3,
            // Gradual temperature shifts
            membraneFluidty: 0.12
            // Fluid membrane transitions
          };
          // Timing and rhythm
          this.lastBeatTime = 0;
          this.currentBPM = 120;
          this.breathingCycleDuration = 2e3;
          // 2 seconds default
          // Breathing controller (CSS-based, performance optimized)
          this.breathingController = null;
          // Will be injected by facade
          // Musical consciousness integration
          this.musicSyncService = null;
          this.currentMusicalContext = null;
          this.lastBeatPhaseUpdate = 0;
          // Performance metrics
          this.performanceMetrics = {
            organicUpdates: 0,
            cellularGrowthEvents: 0,
            breathingCycles: 0,
            emotionalShifts: 0,
            averageFrameTime: 0,
            memoryUsage: 0
          };
          // Organic consciousness configuration
          this.organicConfig = {
            cellularResponseSensitivity: 0.7,
            breathingRhythmIntensity: 0.8,
            emotionalTemperatureRange: { min: 1e3, max: 2e4 },
            membraneFluidityEnabled: true,
            atmosphericParticlesEnabled: true,
            cinematicEffectsEnabled: true
          };
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F30A} Organic consciousness awakening...");
          }
        }
        /**
         * Inject MusicSyncService for musical consciousness integration
         */
        setMusicSyncService(musicSyncService) {
          this.musicSyncService = musicSyncService;
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F3B5} Musical consciousness integration activated");
          }
        }
        // =========================================================================
        // UNIFIED SYSTEM LIFECYCLE
        // =========================================================================
        /**
         * Initialize organic consciousness system
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F9EC} Initializing organic consciousness...");
          }
          this.registerCSSVariableGroup("organic-core", "critical");
          this.registerCSSVariableGroup("cellular-growth", "high");
          this.registerCSSVariableGroup("breathing-rhythm", "high");
          this.registerCSSVariableGroup("emotional-temperature", "normal");
          this.registerCSSVariableGroup("membrane-fluidity", "normal");
          this.subscribeToEvent("music:beat", (payload) => this.onBeatConsciousness(payload));
          this.subscribeToEvent("music:energy", (payload) => this.onEnergyConsciousness(payload));
          this.subscribeToEvent("music:emotion", (payload) => this.onEmotionalConsciousness(payload));
          this.subscribeToEvent("music:bpm-change", (payload) => this.onTempoConsciousness(payload));
          this.registerAnimation(60);
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F31F} Organic consciousness fully awakened");
          }
        }
        /**
         * Clean up organic consciousness
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F343} Dissolving organic consciousness...");
          }
          this.organicIntensity = 0;
          this.cellularGrowth = 1;
          this.breathingPhase = 0;
          this.emotionalTemperature = 4e3;
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F30C} Organic consciousness peacefully dissolved");
          }
        }
        /**
         * Organic consciousness animation frame
         */
        onAnimate(deltaTime) {
          const startTime = performance.now();
          this.updateMusicalContext();
          this.updateOrganicConsciousness(deltaTime);
          this.processCellularGrowth(deltaTime);
          this.updateEmotionalTemperature(deltaTime);
          this.animateMembraneFluidty(deltaTime);
          this.delegateBreathingEvents();
          this.applyOrganicCSSVariables();
          const frameTime = performance.now() - startTime;
          this.performanceMetrics.averageFrameTime = this.performanceMetrics.averageFrameTime * 0.9 + frameTime * 0.1;
          this.performanceMetrics.organicUpdates++;
          if (frameTime > 2 && this.config.enableDebug) {
            console.warn(`[OrganicBeatSyncConsciousness] \u{1F40C} Organic consciousness frame took ${frameTime.toFixed(2)}ms (target: <2ms)`);
          }
        }
        /**
         * Health check for organic consciousness
         */
        async healthCheck() {
          const issues = [];
          if (!this.breathingController) {
            issues.push("Breathing controller not injected by facade");
          }
          if (this.performanceMetrics.averageFrameTime > 2) {
            issues.push(`Average frame time ${this.performanceMetrics.averageFrameTime.toFixed(2)}ms exceeds 2ms target`);
          }
          if (this.organicIntensity === 0 && Date.now() - this.lastBeatTime > 1e4) {
            issues.push("No organic consciousness activity detected in last 10 seconds");
          }
          if (this.emotionalTemperature < 1e3 || this.emotionalTemperature > 2e4) {
            issues.push(`Emotional temperature ${this.emotionalTemperature}K outside 1000K-20000K range`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Organic consciousness health: ${issues.length === 0 ? "thriving" : "needs attention"}`,
            issues,
            system: "OrganicBeatSyncConsciousness"
          };
        }
        // =========================================================================
        // ORGANIC CONSCIOUSNESS BEHAVIORS
        // =========================================================================
        /**
         * Handle beat consciousness - organic response to music beats
         */
        onBeatConsciousness(payload) {
          const { intensity, bpm, energy, timestamp } = payload;
          this.lastBeatTime = timestamp || Date.now();
          this.currentBPM = bpm || this.currentBPM;
          this.targetOrganicIntensity = Math.min(1, intensity * this.organicConfig.cellularResponseSensitivity);
          this.targetCellularGrowth = 1 + (energy || 0.5) * 0.3;
          this.synchronizeBreathingRhythm(bpm || 120);
          this.performanceMetrics.cellularGrowthEvents++;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F3B5} Beat consciousness: intensity=${intensity}, energy=${energy}, bpm=${bpm}`);
          }
        }
        /**
         * Handle energy consciousness - organic response to music energy
         */
        onEnergyConsciousness(payload) {
          const { energy, valence, timestamp } = payload;
          this.targetCellularGrowth = 1 + energy * 0.3;
          this.targetMembraneFluidityLevel = 0.3 + valence * 0.4;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u26A1 Energy consciousness: energy=${energy}, valence=${valence}`);
          }
        }
        /**
         * Handle emotional consciousness - organic response to music emotion
         */
        onEmotionalConsciousness(payload) {
          const { emotion, valence, energy, arousal } = payload;
          const baseTemp = 4e3;
          const energyModulation = (energy - 0.5) * 8e3;
          const valenceModulation = (valence - 0.5) * 6e3;
          this.targetEmotionalTemperature = Math.max(1e3, Math.min(
            2e4,
            baseTemp + energyModulation + valenceModulation
          ));
          this.performanceMetrics.emotionalShifts++;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F308} Emotional consciousness: ${this.emotionalTemperature}K temperature`);
          }
        }
        /**
         * Handle tempo consciousness - organic response to BPM changes
         */
        onTempoConsciousness(payload) {
          const { bpm, tempo, enhancedBPM } = payload;
          this.currentBPM = enhancedBPM || bpm || tempo || 120;
          const bpmFactor = Math.max(0.3, Math.min(3, this.currentBPM / 120));
          this.breathingCycleDuration = 2e3 / bpmFactor;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F3B6} Tempo consciousness: ${this.currentBPM} BPM, ${this.breathingCycleDuration.toFixed(0)}ms breathing cycle`);
          }
        }
        // =========================================================================
        // BREATHING INTEGRATION METHODS
        // =========================================================================
        /**
         * Set breathing controller (injected by facade)
         */
        setBreathingController(controller) {
          this.breathingController = controller;
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1FAC1} Breathing controller injected");
          }
        }
        /**
         * Synchronize breathing rhythm (delegates to breathing controller)
         */
        synchronizeBreathingRhythm(bpm) {
          if (this.breathingController?.onTempoConsciousness) {
            this.breathingController.onTempoConsciousness({ bpm, enhancedBPM: bpm });
          }
          this.performanceMetrics.breathingCycles++;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F3B6} Delegated breathing rhythm to controller: ${bpm} BPM`);
          }
        }
        /**
         * Delegate breathing events to controller
         */
        delegateBreathingEvents() {
          if (!this.breathingController) return;
          if (this.breathingController.onEnergyConsciousness) {
            this.breathingController.onEnergyConsciousness({
              energy: this.cellularGrowth - 1,
              // Convert cellular growth back to energy
              valence: this.membraneFluidityLevel
            });
          }
          if (this.breathingController.onEmotionalConsciousness) {
            this.breathingController.onEmotionalConsciousness({
              emotion: "organic",
              valence: this.membraneFluidityLevel,
              energy: (this.cellularGrowth - 1) / 0.3,
              // Normalize back to 0-1
              arousal: this.organicIntensity
            });
          }
        }
        // =========================================================================
        // ANIMATION UPDATE METHODS
        // =========================================================================
        /**
         * Update organic consciousness state using framerate-independent LERP smoothing
         */
        updateOrganicConsciousness(deltaTime) {
          this.breathingPhase += deltaTime / this.breathingCycleDuration * 2 * Math.PI;
          if (this.breathingPhase > 2 * Math.PI) {
            this.breathingPhase -= 2 * Math.PI;
          }
          const deltaTimeSeconds = deltaTime / 1e3;
          const halfLife = this.targetOrganicIntensity > this.organicIntensity ? this.lerpHalfLifeValues.intensityAttack : this.lerpHalfLifeValues.intensityDecay;
          this.organicIntensity = lerpSmooth(
            this.organicIntensity,
            this.targetOrganicIntensity,
            deltaTimeSeconds,
            halfLife
          );
          const timeSinceLastBeat = Date.now() - this.lastBeatTime;
          if (timeSinceLastBeat > 2e3) {
            this.targetOrganicIntensity = lerpSmooth(
              this.targetOrganicIntensity,
              0,
              // Decay to zero
              deltaTimeSeconds,
              this.lerpHalfLifeValues.intensityDecay
            );
          }
        }
        /**
         * Process cellular growth using framerate-independent LERP smoothing
         */
        processCellularGrowth(deltaTime) {
          const deltaTimeSeconds = deltaTime / 1e3;
          this.cellularGrowth = lerpSmooth(
            this.cellularGrowth,
            this.targetCellularGrowth,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.cellularGrowth
          );
          this.targetCellularGrowth = lerpSmooth(
            this.targetCellularGrowth,
            1,
            // Baseline growth
            deltaTimeSeconds,
            this.lerpHalfLifeValues.cellularGrowth * 2
            // Slower decay
          );
        }
        /**
         * Update emotional temperature using framerate-independent LERP smoothing
         */
        updateEmotionalTemperature(deltaTime) {
          const deltaTimeSeconds = deltaTime / 1e3;
          this.emotionalTemperature = lerpSmooth(
            this.emotionalTemperature,
            this.targetEmotionalTemperature,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.emotionalTemperature
          );
          const neutral = 4e3;
          this.targetEmotionalTemperature = lerpSmooth(
            this.targetEmotionalTemperature,
            neutral,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.emotionalTemperature * 3
            // Slower neutral decay
          );
        }
        /**
         * Animate membrane fluidity using framerate-independent LERP smoothing
         */
        animateMembraneFluidty(deltaTime) {
          if (!this.organicConfig.membraneFluidityEnabled) return;
          const deltaTimeSeconds = deltaTime / 1e3;
          this.membraneFluidityLevel = lerpSmooth(
            this.membraneFluidityLevel,
            this.targetMembraneFluidityLevel,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.membraneFluidty
          );
          const fluidityWave = Math.sin(this.breathingPhase * 0.5) * 0.1;
          const currentFluidity = this.membraneFluidityLevel + fluidityWave;
        }
        /**
         * Apply organic CSS variables
         */
        applyOrganicCSSVariables() {
          this.updateCSSVariableGroup("organic-core", {
            "--organic-intensity": this.organicIntensity.toFixed(3),
            "--organic-bpm": this.currentBPM.toString(),
            "--organic-breathing-phase": this.breathingPhase.toFixed(4)
          });
          this.updateCSSVariableGroup("cellular-growth", {
            "--cellular-growth-scale": this.cellularGrowth.toFixed(3),
            "--cellular-response-sensitivity": this.organicConfig.cellularResponseSensitivity.toFixed(2)
          });
          this.updateCSSVariableGroup("breathing-rhythm", {
            "--breathing-cycle-duration": `${this.breathingCycleDuration.toFixed(0)}ms`,
            "--breathing-rhythm-intensity": this.organicConfig.breathingRhythmIntensity.toFixed(2)
          });
          this.updateCSSVariableGroup("emotional-temperature", {
            "--emotional-temperature": `${this.emotionalTemperature.toFixed(0)}K`,
            "--emotional-temperature-normalized": ((this.emotionalTemperature - 1e3) / 19e3).toFixed(3)
          });
          this.updateCSSVariableGroup("membrane-fluidity", {
            "--membrane-fluidity-level": this.membraneFluidityLevel.toFixed(3),
            "--membrane-fluidity-enabled": this.organicConfig.membraneFluidityEnabled ? "1" : "0"
          });
        }
        // =========================================================================
        // CLEANUP METHODS
        // =========================================================================
        // =========================================================================
        // PUBLIC API METHODS
        // =========================================================================
        /**
         * Get organic consciousness metrics
         */
        getOrganicMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Update organic consciousness configuration
         */
        updateOrganicConfig(config) {
          this.organicConfig = { ...this.organicConfig, ...config };
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F527} Organic configuration updated:", this.organicConfig);
          }
        }
        /**
         * Get current organic consciousness state
         */
        getOrganicState() {
          return {
            organicIntensity: this.organicIntensity,
            cellularGrowth: this.cellularGrowth,
            breathingPhase: this.breathingPhase,
            emotionalTemperature: this.emotionalTemperature,
            membraneFluidityLevel: this.membraneFluidityLevel,
            lastBeatTime: this.lastBeatTime,
            currentBPM: this.currentBPM
          };
        }
        /**
         * Force organic consciousness repaint
         */
        forceRepaint(reason) {
          super.forceRepaint(reason);
          this.organicIntensity = 0;
          this.cellularGrowth = 1;
          this.breathingPhase = 0;
          this.applyOrganicCSSVariables();
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F504} Organic consciousness repaint: ${reason}`);
          }
        }
        // =========================================================================
        // MUSICAL CONSCIOUSNESS INTEGRATION
        // =========================================================================
        /**
         * Update musical consciousness context for music-aware LERP calculations
         */
        updateMusicalContext() {
          if (!this.musicSyncService) {
            this.currentMusicalContext = null;
            return;
          }
          const now = Date.now();
          if (now - this.lastBeatPhaseUpdate < 16) {
            return;
          }
          this.lastBeatPhaseUpdate = now;
          this.currentMusicalContext = musicalLerpOrchestrator.createMusicalContext(
            this.musicSyncService,
            this.lastBeatTime
          );
          if (this.config.enableDebug && this.currentMusicalContext) {
            const ctx = this.currentMusicalContext;
            console.log(`[OrganicBeatSyncConsciousness] \u{1F3B5} Musical context: tempo=${ctx.tempo}, energy=${ctx.energy.toFixed(2)}, phase=${ctx.beatPhase}`);
          }
        }
      };
      __name(_OrganicBeatSyncConsciousness, "OrganicBeatSyncConsciousness");
      OrganicBeatSyncConsciousness = _OrganicBeatSyncConsciousness;
    }
  });

  // src-js/visual/consciousness/OrganicBreathingController.ts
  var _OrganicBreathingController, OrganicBreathingController;
  var init_OrganicBreathingController = __esm({
    "src-js/visual/consciousness/OrganicBreathingController.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_Year3000Utilities();
      _OrganicBreathingController = class _OrganicBreathingController extends UnifiedSystemBase {
        constructor(config) {
          super(config);
          // =========================================================================
          // BREATHING CONSCIOUSNESS STATE
          // =========================================================================
          // Core breathing properties
          this.breathingPhase = 0;
          this.breathingAmplitude = 0.05;
          // Base breathing amplitude
          this.breathingCycleDuration = 2e3;
          // 2 seconds default
          this.emotionalSaturation = 1;
          this.organicWarmth = 0.8;
          this.membraneThickness = 2;
          this.membraneOpacity = 0.3;
          this.fogOpacity = 0.02;
          this.shimmerOpacity = 0.05;
          this.glowOpacity = 0.1;
          // Target values for smooth LERP interpolation
          this.targetBreathingAmplitude = 0.05;
          this.targetEmotionalSaturation = 1;
          this.targetOrganicWarmth = 0.8;
          // LERP smoothing half-life values (in seconds)
          this.lerpHalfLifeValues = {
            breathingAmplitude: 0.08,
            // Organic breathing response
            emotionalSaturation: 0.3,
            // Gradual emotional shifts
            organicWarmth: 0.25
            // Warmth transitions
          };
          // Breathing type configuration
          this.breathingType = "gentle";
          this.breathingTypeMultipliers = {
            gentle: { amplitude: 0.6, intensity: 0.8, duration: 1.2 },
            energetic: { amplitude: 1.5, intensity: 1.3, duration: 0.8 },
            meditative: { amplitude: 0.4, intensity: 0.6, duration: 1.5 },
            cosmic: { amplitude: 1.8, intensity: 1.5, duration: 0.6 }
          };
          // Performance metrics
          this.performanceMetrics = {
            breathingUpdates: 0,
            cssVariableUpdates: 0,
            averageFrameTime: 0,
            qualityScalingActive: false
          };
          // Debug logging throttling
          this.debugThrottleTimers = {
            energy: 0,
            emotion: 0,
            beat: 0,
            tempo: 0
          };
          this.debugThrottleInterval = 2e3;
          // Increased from 500ms to 2000ms for better performance
          // Change detection for CSS variables
          this.previousCSSValues = {
            breathingAmplitude: 0,
            breathingPhase: 0,
            emotionalSaturation: 0,
            organicWarmth: 0,
            membraneOpacity: 0,
            shimmerOpacity: 0,
            glowOpacity: 0
          };
          this.cssUpdateThreshold = 1e-3;
          // Minimum change required for update
          // Intersection observer for viewport optimization
          this.intersectionObserver = null;
          this.isVisible = true;
          if (this.config.enableDebug) {
            console.log("[OrganicBreathingController] \u{1FAC1} Initializing CSS-based breathing consciousness...");
          }
        }
        // =========================================================================
        // UNIFIED SYSTEM LIFECYCLE
        // =========================================================================
        /**
         * Initialize organic breathing system
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log("[OrganicBreathingController] \u{1F30A} Initializing organic breathing system...");
          }
          this.registerCSSVariableGroup("organic-breathing-core", "critical");
          this.registerCSSVariableGroup("membrane-breathing", "high");
          this.registerCSSVariableGroup("atmospheric-breathing", "normal");
          this.setupIntersectionObserver();
          this.subscribeToEvent("music:beat", (payload) => this.onBeatConsciousness(payload));
          this.subscribeToEvent("music:energy", (payload) => this.onEnergyConsciousness(payload));
          this.subscribeToEvent("music:emotion", (payload) => this.onEmotionalConsciousness(payload));
          this.subscribeToEvent("music:bpm-change", (payload) => this.onTempoConsciousness(payload));
          this.subscribeToEvent("performance:quality-scale", (payload) => this.onQualityScale(payload));
          this.subscribeToEvent("performance:device-tier", (payload) => this.onDeviceTier(payload));
          this.registerAnimation(60);
          this.applyBreathingCSSVariables();
          if (this.config.enableDebug) {
            console.log("[OrganicBreathingController] \u{1F31F} Organic breathing consciousness fully awakened");
          }
        }
        /**
         * Clean up organic breathing system
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log("[OrganicBreathingController] \u{1F343} Dissolving breathing consciousness...");
          }
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            this.intersectionObserver = null;
          }
          this.breathingPhase = 0;
          this.breathingAmplitude = 0.05;
          this.emotionalSaturation = 1;
          if (this.config.enableDebug) {
            console.log("[OrganicBreathingController] \u{1F30C} Breathing consciousness peacefully dissolved");
          }
        }
        /**
         * Organic breathing animation frame
         */
        onAnimate(deltaTime) {
          if (!this.isVisible) return;
          const startTime = performance.now();
          this.updateBreathingConsciousness(deltaTime);
          if (this.hasSignificantChange()) {
            this.applyBreathingCSSVariables();
            this.updatePreviousValues();
          }
          const frameTime = performance.now() - startTime;
          this.performanceMetrics.averageFrameTime = this.performanceMetrics.averageFrameTime * 0.9 + frameTime * 0.1;
          this.performanceMetrics.breathingUpdates++;
          if (frameTime > 1 && this.config.enableDebug) {
            console.warn(`[OrganicBreathingController] \u{1F40C} Breathing frame took ${frameTime.toFixed(2)}ms (target: <1ms)`);
          }
        }
        /**
         * Health check for organic breathing system
         */
        async healthCheck() {
          const issues = [];
          if (this.performanceMetrics.averageFrameTime > 1) {
            issues.push(`Average frame time ${this.performanceMetrics.averageFrameTime.toFixed(2)}ms exceeds 1ms target`);
          }
          if (this.breathingAmplitude < 0 || this.breathingAmplitude > 0.2) {
            issues.push(`Breathing amplitude ${this.breathingAmplitude} outside 0-0.2 range`);
          }
          if (this.emotionalSaturation < 0.5 || this.emotionalSaturation > 2) {
            issues.push(`Emotional saturation ${this.emotionalSaturation} outside 0.5-2.0 range`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Organic breathing health: ${issues.length === 0 ? "flowing naturally" : "needs attention"}`,
            issues,
            system: "OrganicBreathingController"
          };
        }
        // =========================================================================
        // DEBUG LOGGING HELPERS
        // =========================================================================
        /**
         * Throttled debug logging to prevent console spam
         */
        throttledDebugLog(category, message, ...args) {
          if (!this.config.enableDebug) return;
          const now = performance.now();
          if (now - this.debugThrottleTimers[category] >= this.debugThrottleInterval) {
            console.log(`[OrganicBreathingController] ${message}`, ...args);
            this.debugThrottleTimers[category] = now;
          }
        }
        /**
         * Check if CSS values have changed significantly enough to warrant an update
         */
        hasSignificantChange() {
          const breathingIntensity = (Math.sin(this.breathingPhase) + 1) / 2;
          const currentValues = {
            breathingAmplitude: this.breathingAmplitude,
            breathingPhase: this.breathingPhase,
            emotionalSaturation: this.emotionalSaturation,
            organicWarmth: this.organicWarmth,
            membraneOpacity: this.membraneOpacity,
            shimmerOpacity: this.shimmerOpacity,
            glowOpacity: this.glowOpacity
          };
          for (const [key, value] of Object.entries(currentValues)) {
            const previous = this.previousCSSValues[key];
            if (Math.abs(value - previous) >= this.cssUpdateThreshold) {
              return true;
            }
          }
          return false;
        }
        /**
         * Update previous CSS values for change detection
         */
        updatePreviousValues() {
          this.previousCSSValues.breathingAmplitude = this.breathingAmplitude;
          this.previousCSSValues.breathingPhase = this.breathingPhase;
          this.previousCSSValues.emotionalSaturation = this.emotionalSaturation;
          this.previousCSSValues.organicWarmth = this.organicWarmth;
          this.previousCSSValues.membraneOpacity = this.membraneOpacity;
          this.previousCSSValues.shimmerOpacity = this.shimmerOpacity;
          this.previousCSSValues.glowOpacity = this.glowOpacity;
        }
        // =========================================================================
        // BREATHING CONSCIOUSNESS BEHAVIORS
        // =========================================================================
        /**
         * Handle beat consciousness - breathing response to music beats
         */
        onBeatConsciousness(payload) {
          const { intensity, bpm, energy } = payload;
          this.targetBreathingAmplitude = Math.min(0.15, 0.05 + intensity * 0.1);
          if (energy > 0.8) {
            this.breathingType = "energetic";
          } else if (energy > 0.6) {
            this.breathingType = "cosmic";
          } else if (energy < 0.3) {
            this.breathingType = "meditative";
          } else {
            this.breathingType = "gentle";
          }
          this.throttledDebugLog("beat", `\u{1F3B5} Beat consciousness: amplitude=${this.targetBreathingAmplitude.toFixed(3)}, type=${this.breathingType}`);
        }
        /**
         * Handle energy consciousness - breathing response to music energy
         */
        onEnergyConsciousness(payload) {
          const { energy, valence } = payload;
          this.targetEmotionalSaturation = 0.7 + energy * 0.8;
          this.targetOrganicWarmth = 0.5 + valence * 0.6;
          this.throttledDebugLog("energy", `\u26A1 Energy consciousness: saturation=${this.targetEmotionalSaturation.toFixed(2)}, warmth=${this.targetOrganicWarmth.toFixed(2)}`);
        }
        /**
         * Handle emotional consciousness - breathing response to music emotion
         */
        onEmotionalConsciousness(payload) {
          const { emotion, valence, energy, arousal } = payload;
          const emotionFactor = (valence + energy + arousal) / 3;
          this.membraneOpacity = 0.2 + emotionFactor * 0.3;
          this.shimmerOpacity = 0.03 + emotionFactor * 0.05;
          this.glowOpacity = 0.05 + emotionFactor * 0.15;
          this.throttledDebugLog("emotion", `\u{1F308} Emotional consciousness: membrane=${this.membraneOpacity.toFixed(2)}, shimmer=${this.shimmerOpacity.toFixed(3)}`);
        }
        /**
         * Handle tempo consciousness - breathing response to BPM changes
         */
        onTempoConsciousness(payload) {
          const { bpm, enhancedBPM } = payload;
          const currentBPM = enhancedBPM || bpm || 120;
          const bpmFactor = Math.max(0.3, Math.min(3, currentBPM / 120));
          this.breathingCycleDuration = 2e3 / bpmFactor;
          this.throttledDebugLog("tempo", `\u{1F3B6} Tempo consciousness: ${currentBPM} BPM, ${this.breathingCycleDuration.toFixed(0)}ms breathing cycle`);
        }
        /**
         * Handle quality scaling for performance optimization
         */
        onQualityScale(payload) {
          const { scale, reason } = payload;
          this.performanceMetrics.qualityScalingActive = scale < 1;
          if (scale < 0.5) {
            this.targetBreathingAmplitude *= 0.6;
            this.membraneThickness = Math.max(1, this.membraneThickness * 0.7);
          } else if (scale < 0.8) {
            this.targetBreathingAmplitude *= 0.8;
          }
          if (this.config.enableDebug) {
            console.log(`[OrganicBreathingController] \u{1F4CA} Quality scaling: ${scale.toFixed(2)}, reason: ${reason}`);
          }
        }
        /**
         * Handle device tier changes
         */
        onDeviceTier(payload) {
          const { tier, capabilities } = payload;
          switch (tier) {
            case "low":
              this.fogOpacity = 0.01;
              this.shimmerOpacity = 0.02;
              break;
            case "medium":
              this.fogOpacity = 0.015;
              this.shimmerOpacity = 0.04;
              break;
            case "high":
              this.fogOpacity = 0.02;
              this.shimmerOpacity = 0.05;
              break;
          }
          if (this.config.enableDebug) {
            console.log(`[OrganicBreathingController] \u{1F5A5}\uFE0F Device tier: ${tier}, fog opacity: ${this.fogOpacity}`);
          }
        }
        // =========================================================================
        // ANIMATION UPDATE METHODS
        // =========================================================================
        /**
         * Update breathing consciousness state using framerate-independent LERP smoothing
         */
        updateBreathingConsciousness(deltaTime) {
          const deltaTimeSeconds = deltaTime / 1e3;
          this.breathingPhase += deltaTime / this.breathingCycleDuration * 2 * Math.PI;
          if (this.breathingPhase > 2 * Math.PI) {
            this.breathingPhase -= 2 * Math.PI;
          }
          this.breathingAmplitude = lerpSmooth(
            this.breathingAmplitude,
            this.targetBreathingAmplitude,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.breathingAmplitude
          );
          this.emotionalSaturation = lerpSmooth(
            this.emotionalSaturation,
            this.targetEmotionalSaturation,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.emotionalSaturation
          );
          this.organicWarmth = lerpSmooth(
            this.organicWarmth,
            this.targetOrganicWarmth,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.organicWarmth
          );
          this.targetBreathingAmplitude = lerpSmooth(
            this.targetBreathingAmplitude,
            0.05,
            // Baseline amplitude
            deltaTimeSeconds,
            this.lerpHalfLifeValues.breathingAmplitude * 2
          );
          this.targetEmotionalSaturation = lerpSmooth(
            this.targetEmotionalSaturation,
            1,
            // Baseline saturation
            deltaTimeSeconds,
            this.lerpHalfLifeValues.emotionalSaturation * 2
          );
          this.targetOrganicWarmth = lerpSmooth(
            this.targetOrganicWarmth,
            0.8,
            // Baseline warmth
            deltaTimeSeconds,
            this.lerpHalfLifeValues.organicWarmth * 2
          );
        }
        /**
         * Apply organic breathing CSS variables through CSSVariableBatcher
         */
        applyBreathingCSSVariables() {
          const multipliers = this.breathingTypeMultipliers[this.breathingType];
          const breathingIntensity = (Math.sin(this.breathingPhase) + 1) / 2;
          this.updateCSSVariableGroup("organic-breathing-core", {
            "--organic-breathing-amplitude": (this.breathingAmplitude * multipliers.amplitude).toFixed(4),
            "--organic-breathing-cycle": `${(this.breathingCycleDuration * multipliers.duration).toFixed(0)}ms`,
            "--organic-breathing-phase": this.breathingPhase.toFixed(4),
            "--organic-breathing-intensity": breathingIntensity.toFixed(3),
            "--organic-emotional-saturation": (this.emotionalSaturation * multipliers.intensity).toFixed(3),
            "--organic-warmth": this.organicWarmth.toFixed(3)
          });
          this.updateCSSVariableGroup("membrane-breathing", {
            "--organic-membrane-thickness": `${this.membraneThickness}px`,
            "--organic-membrane-opacity": this.membraneOpacity.toFixed(3),
            "--organic-glow-opacity": this.glowOpacity.toFixed(3),
            "--organic-shimmer-opacity": this.shimmerOpacity.toFixed(3)
          });
          this.updateCSSVariableGroup("atmospheric-breathing", {
            "--organic-fog-opacity": this.fogOpacity.toFixed(4),
            "--organic-growth-scale": (1 + this.breathingAmplitude * 0.3).toFixed(3),
            "--breathing-type-amplitude": (this.breathingAmplitude * multipliers.amplitude).toFixed(4),
            "--breathing-type-intensity": (this.emotionalSaturation * multipliers.intensity).toFixed(3)
          });
          this.performanceMetrics.cssVariableUpdates++;
        }
        // =========================================================================
        // PERFORMANCE OPTIMIZATION METHODS
        // =========================================================================
        /**
         * Setup intersection observer for viewport optimization
         */
        setupIntersectionObserver() {
          if (typeof IntersectionObserver === "undefined") return;
          this.intersectionObserver = new IntersectionObserver(
            (entries) => {
              const entry = entries[0];
              if (entry) {
                this.isVisible = entry.isIntersecting || entry.intersectionRatio > 0;
                if (this.config.enableDebug && !this.isVisible) {
                  console.log("[OrganicBreathingController] \u{1F441}\uFE0F Breathing consciousness paused (not visible)");
                }
              }
            },
            {
              threshold: 0.01,
              // Trigger when even 1% is visible
              rootMargin: "50px"
              // Start animating 50px before entering viewport
            }
          );
          const mainView = document.querySelector(".main-view-container__scroll-node") || document.body;
          this.intersectionObserver.observe(mainView);
        }
        // =========================================================================
        // PUBLIC API METHODS
        // =========================================================================
        /**
         * Get breathing performance metrics
         */
        getBreathingMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Update breathing type
         */
        setBreathingType(type) {
          this.breathingType = type;
          if (this.config.enableDebug) {
            console.log(`[OrganicBreathingController] \u{1F527} Breathing type changed to: ${type}`);
          }
        }
        /**
         * Get current breathing state
         */
        getBreathingState() {
          return {
            breathingPhase: this.breathingPhase,
            breathingAmplitude: this.breathingAmplitude,
            breathingType: this.breathingType,
            emotionalSaturation: this.emotionalSaturation,
            organicWarmth: this.organicWarmth,
            isVisible: this.isVisible
          };
        }
        /**
         * Force breathing consciousness repaint
         */
        forceRepaint(reason) {
          super.forceRepaint(reason);
          this.breathingPhase = 0;
          this.breathingAmplitude = 0.05;
          this.emotionalSaturation = 1;
          this.organicWarmth = 0.8;
          this.applyBreathingCSSVariables();
          if (this.config.enableDebug) {
            console.log(`[OrganicBreathingController] \u{1F504} Breathing consciousness repaint: ${reason}`);
          }
        }
      };
      __name(_OrganicBreathingController, "OrganicBreathingController");
      OrganicBreathingController = _OrganicBreathingController;
    }
  });

  // src-js/visual/ui-effects/InteractionTrackingSystem.ts
  var _InteractionTrackingSystem, InteractionTrackingSystem;
  var init_InteractionTrackingSystem = __esm({
    "src-js/visual/ui-effects/InteractionTrackingSystem.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_BaseVisualSystem();
      _InteractionTrackingSystem = class _InteractionTrackingSystem extends BaseVisualSystem {
        constructor(config, utils, performanceMonitor, musicSyncService, settingsManager, year3000System2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager);
          this._scrollContainerElements = [];
          // Stored throttled interaction handler for proper cleanup.
          this._interactionHandler = null;
          this.year3000System = year3000System2;
          this.nexusState = {
            currentNavigationScale: 1,
            targetNavigationScale: 1,
            userInfluence: 0,
            lastEnergy: 0.5,
            lastValence: 0.5,
            lastVisualIntensity: 0.5,
            lastMoodIdentifier: "neutral"
          };
          this.biometricState = {
            isMeditating: false,
            lastUserInteractionTime: Date.now(),
            meditationGracePeriod: 5e3,
            interactionCooldown: 1e3,
            lastMeditationUpdateTime: null,
            desaturation: 0,
            slowdown: 1,
            targetDesaturation: 0,
            targetSlowdown: 1
          };
          this.lastHeavyUpdateTime = 0;
          this.heavyUpdateInterval = 1e3 / 10;
          this.lastBiometricCheckTime = 0;
          this.biometricCheckInterval = 1e3;
          this.lastInteractionRecordTime = 0;
          this.interactionRecordInterval = 200;
          this._animationRegistered = false;
          this._performanceMode = "auto";
          this._frameSkipCounter = 0;
          this._maxFrameSkip = 2;
          this.systemIntegrationMetrics = {
            lastSystemsCheck: Date.now(),
            integrationHealth: "healthy",
            crossSystemErrors: 0,
            meditationTransitions: 0,
            navigationScaleUpdates: 0
          };
          const healthMonitor = this.utils.getHealthMonitor();
          if (healthMonitor) {
            healthMonitor.registerSystem("InteractionTrackingSystem", this);
          }
          this.rootElement = this.utils.getRootStyle();
          this.modalObserver = null;
          this._lastScrollTime = null;
          this._lastScrollTop = null;
        }
        /**
         * Frame callback invoked by the MasterAnimationCoordinator.
         * Delegates to the existing `updateAnimation` implementation which
         * contains the system's main per-frame logic (including internal
         * frame-skipping and heavy-update cadence).
         *
         * @param deltaMs  Milliseconds elapsed since the previous animation frame.
         */
        onAnimate(deltaMs) {
          if (!this.initialized) return;
          this.updateAnimation(performance.now(), deltaMs);
        }
        async initialize() {
          await super.initialize();
          this.initializeOptimizedQuantumSpace();
          this.setupModalObserver();
          this.setupOptimizedInteractionListener();
          this._registerWithAnimationCoordinator();
        }
        _registerWithAnimationCoordinator() {
          if (this.year3000System && this.year3000System.registerAnimationSystem) {
            this.year3000System.registerAnimationSystem(
              "InteractionTrackingSystem",
              this,
              "normal",
              30
            );
            this._animationRegistered = true;
          } else {
            this._startFallbackAnimationLoops();
          }
        }
        initializeOptimizedQuantumSpace() {
          const root = this.utils.getRootStyle();
          if (!root) return;
          const safeSetProperty = /* @__PURE__ */ __name((name, value) => {
            try {
              root.style.setProperty(name, value);
            } catch (e) {
              console.warn(`[InteractionTrackingSystem] Failed to set CSS property ${name}:`, e);
            }
          }, "safeSetProperty");
          safeSetProperty("--sn-nav-item-transform-scale", "1.0");
          safeSetProperty("--sn-sidebar-meditation-desaturation", "0");
          safeSetProperty("--sn-sidebar-meditation-slowdown", "1");
        }
        recordUserInteraction(event) {
          const eventType = event.type;
          if (eventType === "scroll") {
            const target = event.target;
            if (target) {
              const newTop = target.scrollTop;
              const now2 = performance.now();
              const velocity = this._lastScrollTime ? (newTop - (this._lastScrollTop ?? 0)) / (now2 - this._lastScrollTime) : 0;
              const direction = velocity < 0 ? "up" : "down";
              unifiedEventBus.emit("user:scroll", {
                velocity: { x: 0, y: velocity * 1e3 },
                // pixels per second, normalized to x/y format
                direction,
                element: target.tagName || "unknown",
                timestamp: now2
              });
              this._lastScrollTop = newTop;
              this._lastScrollTime = now2;
            }
          }
          const now = performance.now();
          if (now - this.lastInteractionRecordTime < this.interactionRecordInterval) {
            return;
          }
          this.lastInteractionRecordTime = now;
          this.nexusState.userInfluence += 5e-3;
          this.nexusState.userInfluence = Math.min(0.5, this.nexusState.userInfluence);
          this.biometricState.lastUserInteractionTime = Date.now();
          this.biometricState.isMeditating = false;
        }
        setupModalObserver() {
          const modalRoot = document.querySelector(".main-modal-container");
          if (!modalRoot) return;
          const observerCallback = /* @__PURE__ */ __name((mutationsList, observer) => {
            for (const mutation of mutationsList) {
              if (mutation.type === "childList") {
                const hasModal = modalRoot.children.length > 0;
                this.nexusState.targetNavigationScale = hasModal ? 0.95 : 1;
              }
            }
          }, "observerCallback");
          this.modalObserver = new MutationObserver(observerCallback);
          this.modalObserver.observe(modalRoot, { childList: true });
        }
        setupOptimizedInteractionListener() {
          this._interactionHandler = this.utils.throttle(
            (event) => this.recordUserInteraction(event),
            100
          );
          const genericEvents = ["click", "mousemove", "keydown"];
          genericEvents.forEach((eventType) => {
            document.addEventListener(
              eventType,
              this._interactionHandler,
              { passive: true }
            );
          });
          const scrollSelectors = [
            ".main-view-container__scroll-node",
            ".main-view-container__scroll-node-child",
            "section[data-testid='playlist-page']"
          ];
          const foundContainers = [];
          scrollSelectors.forEach((sel) => {
            document.querySelectorAll(sel).forEach((el) => {
              foundContainers.push(el);
            });
          });
          const targets = foundContainers.length ? foundContainers : [document];
          targets.forEach((el) => {
            el.addEventListener("scroll", this._interactionHandler, {
              passive: true
            });
          });
          this._scrollContainerElements = foundContainers;
        }
        updateFromMusicAnalysis(processedMusicData, rawFeatures, trackUri) {
          if (!this.initialized || !this.validateMusicData(processedMusicData)) {
            this.applySafeDefaults();
            return;
          }
          this.updateNexusTargets(processedMusicData);
        }
        updateNexusTargets(processedMusicData) {
          const {
            energy,
            valence,
            visualIntensity,
            moodIdentifier
          } = processedMusicData;
          this.nexusState.lastEnergy = energy;
          this.nexusState.lastValence = valence;
          this.nexusState.lastVisualIntensity = visualIntensity;
          this.nexusState.lastMoodIdentifier = moodIdentifier;
          this.nexusState.targetNavigationScale = this.calculateOptimizedNavigationScale(visualIntensity, moodIdentifier);
        }
        updateDigitalMeditationState(processedMusicData) {
          const now = Date.now();
          if (now - this.lastBiometricCheckTime < this.biometricCheckInterval) {
            return;
          }
          this.lastBiometricCheckTime = now;
          const timeSinceLastInteraction = now - this.biometricState.lastUserInteractionTime;
          if (timeSinceLastInteraction > this.biometricState.meditationGracePeriod && processedMusicData.energy < 0.3 && processedMusicData.valence > 0.6) {
            this.biometricState.isMeditating = true;
            this.biometricState.targetDesaturation = 0.6;
            this.biometricState.targetSlowdown = 0.5;
          } else {
            this.biometricState.isMeditating = false;
            this.biometricState.targetDesaturation = 0;
            this.biometricState.targetSlowdown = 1;
          }
        }
        updateAnimation(timestamp, deltaTime) {
          if (!this.initialized) return;
          this._frameSkipCounter++;
          if (this._frameSkipCounter < this._maxFrameSkip) {
            return;
          }
          this._frameSkipCounter = 0;
          this.animateOptimizedNexusFrame(deltaTime);
          if (timestamp - this.lastHeavyUpdateTime > this.heavyUpdateInterval) {
            const latestMusicData = this.musicSyncService?.getLatestProcessedData();
            if (latestMusicData) this.updateDigitalMeditationState(latestMusicData);
            this.updateIntegrationMetrics();
            this.lastHeavyUpdateTime = timestamp;
          }
        }
        onPerformanceModeChange(mode) {
          this._performanceMode = mode;
          if (mode === "performance") {
            this.heavyUpdateInterval = 1e3 / 5;
            this._maxFrameSkip = 3;
            this.interactionRecordInterval = 500;
          } else {
            this.heavyUpdateInterval = 1e3 / 10;
            this._maxFrameSkip = 2;
            this.interactionRecordInterval = 200;
          }
        }
        _startFallbackAnimationLoops() {
          const loop = /* @__PURE__ */ __name(() => {
            this.updateAnimation(performance.now(), 16.67);
            requestAnimationFrame(loop);
          }, "loop");
          requestAnimationFrame(loop);
        }
        animateOptimizedNexusFrame(deltaTimeMs) {
          const lerpFactor = Math.min((deltaTimeMs ?? 16.67) / 1e3 * 5, 1);
          this.nexusState.currentNavigationScale = this.utils.lerp(
            this.nexusState.currentNavigationScale,
            this.nexusState.targetNavigationScale,
            lerpFactor
          );
          this.biometricState.desaturation = this.utils.lerp(
            this.biometricState.desaturation,
            this.biometricState.targetDesaturation,
            lerpFactor
          );
          this.biometricState.slowdown = this.utils.lerp(
            this.biometricState.slowdown,
            this.biometricState.targetSlowdown,
            lerpFactor
          );
          this.applyOptimizedStateToCSS();
        }
        applyOptimizedStateToCSS() {
          const safeSetProperty = /* @__PURE__ */ __name((property, value) => {
            try {
              this.rootElement.style.setProperty(property, value);
            } catch (e) {
              console.warn(`[InteractionTrackingSystem] Failed to set CSS property ${property}:`, e);
            }
          }, "safeSetProperty");
          safeSetProperty("--sn-nav-item-transform-scale", this.nexusState.currentNavigationScale.toFixed(3));
          safeSetProperty("--sn-sidebar-meditation-desaturation", this.biometricState.desaturation.toFixed(3));
          safeSetProperty("--sn-sidebar-meditation-slowdown", this.biometricState.slowdown.toFixed(3));
        }
        validateMusicData(data) {
          return data && typeof data.energy === "number" && typeof data.valence === "number" && typeof data.visualIntensity === "number";
        }
        applySafeDefaults() {
          const safeSetProperty = /* @__PURE__ */ __name((name, value) => {
            if (this.rootElement) this.rootElement.style.setProperty(name, value);
          }, "safeSetProperty");
          safeSetProperty("--sn-nav-item-transform-scale", "1.0");
          safeSetProperty("--sn-sidebar-meditation-desaturation", "0");
          safeSetProperty("--sn-sidebar-meditation-slowdown", "1");
        }
        updateIntegrationMetrics() {
        }
        calculateIntegrationComplexity() {
          let complexity = 0;
          complexity += this.nexusState.userInfluence * 10;
          complexity += this.nexusState.lastVisualIntensity * 5;
          if (this.biometricState.isMeditating) complexity += 5;
          return complexity;
        }
        performCleanup() {
          if (this.nexusState.userInfluence > 0) {
            this.nexusState.userInfluence = Math.max(
              0,
              this.nexusState.userInfluence - 0.01
            );
          }
        }
        calculateOptimizedNavigationScale(visualIntensity = 0.5, moodIdentifier = "neutral") {
          let scale = 1;
          if (visualIntensity > 0.7) scale = 1.02;
          if (moodIdentifier === "energetic") scale *= 1.01;
          return scale;
        }
        getNavigationScalingReport() {
          return {
            target: this.nexusState.targetNavigationScale,
            current: this.nexusState.currentNavigationScale,
            intensity: this.nexusState.lastVisualIntensity,
            mood: this.nexusState.lastMoodIdentifier
          };
        }
        getMeditationReport() {
          return {
            isMeditating: this.biometricState.isMeditating,
            timeSinceInteraction: (Date.now() - this.biometricState.lastUserInteractionTime) / 1e3,
            desaturation: this.biometricState.desaturation,
            slowdown: this.biometricState.slowdown
          };
        }
        destroy() {
          if (this._interactionHandler) {
            ["click", "mousemove", "keydown"].forEach((evt) => {
              document.removeEventListener(
                evt,
                this._interactionHandler
              );
            });
            this._scrollContainerElements.forEach((el) => {
              el.removeEventListener(
                "scroll",
                this._interactionHandler
              );
            });
            this._interactionHandler = null;
          }
          super.destroy();
        }
      };
      __name(_InteractionTrackingSystem, "InteractionTrackingSystem");
      InteractionTrackingSystem = _InteractionTrackingSystem;
    }
  });

  // src-js/visual/ui-effects/SpotifyUIApplicationSystem.ts
  var _SpotifyUIApplicationSystem, SpotifyUIApplicationSystem;
  var init_SpotifyUIApplicationSystem = __esm({
    "src-js/visual/ui-effects/SpotifyUIApplicationSystem.ts"() {
      "use strict";
      init_EventBus();
      _SpotifyUIApplicationSystem = class _SpotifyUIApplicationSystem {
        constructor(year3000System2) {
          this.year3000System = year3000System2;
          this.systemName = "SpotifyUIApplicationSystem";
          this.initialized = false;
          this.effectLayers = [];
          this.observerRegistry = /* @__PURE__ */ new Map();
          // Performance optimization
          this.lastDiscoveryLogTime = 0;
          this.lastRefreshLogTime = 0;
          // Increased debounce time to reduce frequency
          this.debounceRefresh = this.debounce(() => {
            this.refreshUITargets();
          }, 2e3);
          this.targets = this.initializeEmptyTargets();
        }
        /**
         * Required by IManagedSystem - periodic animation updates
         */
        updateAnimation(deltaTime) {
        }
        /**
         * Required by IManagedSystem - health check
         */
        async healthCheck() {
          try {
            const targetStats = this.getTargetStats();
            const totalElements = Object.values(targetStats).reduce(
              (sum, count) => sum + count,
              0
            );
            const isHealthy = this.initialized && totalElements > 0;
            const issues = [];
            if (totalElements === 0) {
              issues.push("No UI elements discovered");
            }
            return {
              healthy: isHealthy,
              ok: isHealthy,
              details: `UI Application System ${this.initialized ? "active" : "inactive"}, ${totalElements} elements enhanced`,
              issues,
              system: "SpotifyUIApplicationSystem"
            };
          } catch (error) {
            return {
              healthy: false,
              ok: false,
              details: "Health check failed",
              issues: [error instanceof Error ? error.message : "Unknown error"],
              system: "SpotifyUIApplicationSystem"
            };
          }
        }
        /**
         * Force repaint - implements optional IManagedSystem method
         * Cascade Coordination - Ensures proper layering of effects
         */
        forceRepaint(reason) {
          console.log(`\u{1F3A8} Force repaint requested: ${reason || "manual trigger"}`);
          this.forceEffectCascade();
        }
        initializeEmptyTargets() {
          return {
            nowPlaying: [],
            sidebar: [],
            mainContent: [],
            buttons: [],
            cards: [],
            headers: [],
            textElements: [],
            iconElements: [],
            playbackControls: [],
            trackRows: []
          };
        }
        async initialize() {
          if (this.initialized) return;
          try {
            await this.discoverUITargets();
            this.setupEffectLayers();
            this.applyUnifiedState();
            this.setupDOMObservers();
            this.registerSystemCallbacks();
            this.initialized = true;
            console.log("\u2728 SpotifyUIApplicationSystem initialized successfully");
          } catch (error) {
            console.error("Failed to initialize SpotifyUIApplicationSystem", error);
            throw error;
          }
        }
        /**
         * DOM Intelligence Layer - Discovers current Spotify UI elements (OPTIMIZED)
         */
        async discoverUITargets() {
          const selectors = {
            nowPlaying: [
              '[data-testid="now-playing-widget"]',
              ".main-nowPlayingWidget-nowPlaying",
              ".Root__now-playing-bar"
            ],
            sidebar: [
              '[data-testid="nav-bar"]',
              ".main-navBar-navBar",
              ".Root__nav-bar"
            ],
            mainContent: [
              '[data-testid="main"]',
              ".main-view-container",
              ".Root__main-view"
            ],
            buttons: [
              'button[class*="Button"]',
              '[role="button"]',
              ".main-playButton-PlayButton"
            ],
            cards: [
              '[data-testid*="card"]',
              ".main-card-card",
              ".main-entityCard-container"
            ],
            headers: [
              "h1, h2, h3, h4, h5, h6",
              '[data-testid*="header"]',
              ".main-entityHeader-titleText"
            ],
            textElements: [
              '[data-testid="track-name"]',
              '[data-testid="artist-name"]',
              ".main-trackList-trackName",
              ".main-trackList-artistName"
            ],
            iconElements: [
              'svg[class*="Icon"]',
              '[data-testid*="icon"]',
              ".Svg-sc-ytk21e-0"
            ],
            playbackControls: [
              '[data-testid="control-button"]',
              ".main-playPauseButton-button",
              ".player-controls__buttons"
            ],
            trackRows: [
              '[data-testid="tracklist-row"]',
              ".main-trackList-trackListRow",
              ".main-rootlist-rootlistItem"
            ]
          };
          const combinedQueries = {};
          for (const [category, selectorArray] of Object.entries(selectors)) {
            combinedQueries[category] = selectorArray.join(", ");
          }
          const elementMap = /* @__PURE__ */ new Map();
          for (const [category, combinedSelector] of Object.entries(combinedQueries)) {
            try {
              const found = document.querySelectorAll(combinedSelector);
              for (const element of found) {
                if (!elementMap.has(element)) {
                  elementMap.set(element, []);
                }
                elementMap.get(element).push(category);
              }
            } catch (error) {
              continue;
            }
          }
          this.targets = this.initializeEmptyTargets();
          for (const [element, categories] of elementMap) {
            for (const category of categories) {
              this.targets[category].push(element);
            }
          }
          if (performance.now() - this.lastDiscoveryLogTime >= 5e3) {
            console.log("\u{1F3AF} UI targets discovered", {
              nowPlaying: this.targets.nowPlaying.length,
              sidebar: this.targets.sidebar.length,
              mainContent: this.targets.mainContent.length,
              buttons: this.targets.buttons.length,
              cards: this.targets.cards.length,
              headers: this.targets.headers.length,
              textElements: this.targets.textElements.length,
              iconElements: this.targets.iconElements.length,
              playbackControls: this.targets.playbackControls.length,
              trackRows: this.targets.trackRows.length
            });
            this.lastDiscoveryLogTime = performance.now();
          }
        }
        /**
         * Effect Application Pipeline - Sets up cascade layers from background to foreground
         */
        setupEffectLayers() {
          this.effectLayers = [
            // Layer 1: Background & Container Effects
            {
              name: "background-containers",
              elements: [...this.targets.mainContent, ...this.targets.sidebar],
              priority: 10,
              cssVariables: {
                "--sn-bg-primary": "var(--sn-accent-primary)",
                "--sn-bg-secondary": "var(--sn-accent-secondary)",
                "--sn-gradient-start": "var(--sn-gradient-primary-rgb)",
                "--sn-gradient-end": "var(--sn-gradient-secondary-rgb)"
              }
            },
            // Layer 2: Card & Content Effects
            {
              name: "ui-cards",
              elements: this.targets.cards,
              priority: 20,
              cssVariables: {
                "--sn-card-bg": "var(--sn-accent-primary)",
                "--sn-card-border": "var(--sn-accent-secondary)",
                "--sn-card-glow": "var(--sn-accent-tertiary)",
                "--sn-glassmorphism-intensity": "var(--sn-effect-intensity)"
              },
              interactionEffects: true
            },
            // Layer 3: Interactive Elements
            {
              name: "interactive-elements",
              elements: [...this.targets.buttons, ...this.targets.playbackControls],
              priority: 30,
              cssVariables: {
                "--sn-button-bg": "var(--sn-accent-primary)",
                "--sn-button-hover": "var(--sn-accent-secondary)",
                "--sn-button-active": "var(--sn-accent-tertiary)",
                "--sn-beat-sync-intensity": "var(--sn-music-intensity)"
              },
              interactionEffects: true
            },
            // Layer 4: Text & Icon Enhancement
            {
              name: "text-icon-effects",
              elements: [
                ...this.targets.textElements,
                ...this.targets.iconElements,
                ...this.targets.headers
              ],
              priority: 40,
              cssVariables: {
                "--sn-text-primary": "var(--sn-accent-primary)",
                "--sn-text-secondary": "var(--sn-accent-secondary)",
                "--sn-text-glow": "var(--sn-accent-tertiary)",
                "--sn-icon-color": "var(--sn-accent-primary)",
                "--sn-icon-glow": "var(--sn-accent-secondary)"
              }
            },
            // Layer 5: Now Playing Special Effects
            {
              name: "now-playing-effects",
              elements: this.targets.nowPlaying,
              priority: 50,
              cssVariables: {
                "--sn-now-playing-bg": "var(--sn-accent-primary)",
                "--sn-now-playing-glow": "var(--sn-accent-secondary)",
                "--sn-beat-pulse": "var(--sn-music-intensity)",
                "--sn-track-progress": "var(--sn-accent-tertiary)"
              },
              interactionEffects: true
            }
          ];
        }
        /**
         * Applies unified state from existing systems to discovered UI elements
         */
        applyUnifiedState() {
          this.effectLayers.forEach((layer) => {
            layer.elements.forEach((element) => {
              this.applyEffectToElement(element, layer);
            });
          });
        }
        /**
         * Helper method to safely call Year3000System's queueCSSVariableUpdate
         */
        safeQueueCSSVariableUpdate(property, value, element) {
          if (this.year3000System?.queueCSSVariableUpdate) {
            this.year3000System.queueCSSVariableUpdate(property, value, element || null);
          } else {
            const target = element || document.documentElement;
            target.style.setProperty(property, value);
          }
        }
        applyEffectToElement(element, layer) {
          if (!(element instanceof HTMLElement)) return;
          Object.entries(layer.cssVariables).forEach(([property, value]) => {
            this.safeQueueCSSVariableUpdate(property, value, element);
          });
          element.classList.add(`sn-${layer.name}`);
          element.classList.add("sn-ui-enhanced");
          if (layer.interactionEffects) {
            this.addInteractionEffects(element, layer);
          }
          element.setAttribute("data-sn-layer", layer.name);
          element.setAttribute("data-sn-priority", layer.priority.toString());
        }
        addInteractionEffects(element, layer) {
          if (layer.name === "interactive-elements" || layer.name === "now-playing-effects") {
            this.safeQueueCSSVariableUpdate(
              "--sn-beat-response",
              "var(--sn-music-intensity)",
              element
            );
            element.classList.add("sn-beat-responsive");
          }
          element.addEventListener("mouseenter", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-hover-intensity",
              "1",
              element
            );
            element.classList.add("sn-hover-active");
          });
          element.addEventListener("mouseleave", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-hover-intensity",
              "0",
              element
            );
            element.classList.remove("sn-hover-active");
          });
          element.addEventListener("click", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-click-intensity",
              "1",
              element
            );
            element.classList.add("sn-click-active");
            setTimeout(() => {
              this.safeQueueCSSVariableUpdate(
                "--sn-click-intensity",
                "0",
                element
              );
              element.classList.remove("sn-click-active");
            }, 300);
          });
        }
        /**
         * Sets up DOM mutation observers for dynamic Spotify UI updates (OPTIMIZED)
         */
        setupDOMObservers() {
          const observerConfig = {
            childList: true,
            subtree: false,
            // Reduced to immediate children only
            attributes: false
            // Disabled attribute watching for performance
          };
          const mainObserver = new MutationObserver((mutations) => {
            let significantChange = false;
            mutations.forEach((mutation) => {
              if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
                const hasSignificantNodes = Array.from(mutation.addedNodes).some((node) => {
                  if (node.nodeType === Node.ELEMENT_NODE) {
                    const element = node;
                    return element.matches('[data-testid*="card"], [data-testid*="track"], [data-testid*="header"], [role="button"]') || element.querySelector('[data-testid*="card"], [data-testid*="track"], [data-testid*="header"], [role="button"]');
                  }
                  return false;
                });
                if (hasSignificantNodes) {
                  significantChange = true;
                }
              }
            });
            if (significantChange) {
              this.debounceRefresh();
            }
          });
          const mainElement = document.querySelector('[data-testid="main"]') || document.body;
          mainObserver.observe(mainElement, observerConfig);
          this.observerRegistry.set("main", mainObserver);
        }
        // Increased from 500ms to 2000ms
        debounce(func, wait) {
          let timeout;
          return /* @__PURE__ */ __name(function executedFunction(...args) {
            const later = /* @__PURE__ */ __name(() => {
              clearTimeout(timeout);
              func(...args);
            }, "later");
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          }, "executedFunction");
        }
        async refreshUITargets() {
          try {
            const previousTargetHash = this.calculateTargetHash();
            await this.discoverUITargets();
            const currentTargetHash = this.calculateTargetHash();
            if (previousTargetHash !== currentTargetHash) {
              this.applyUnifiedState();
              if (performance.now() - this.lastRefreshLogTime >= 1e4) {
                console.log("\u{1F504} UI targets refreshed");
                this.lastRefreshLogTime = performance.now();
              }
            }
          } catch (error) {
            console.error("Failed to refresh UI targets", error);
          }
        }
        calculateTargetHash() {
          const counts = Object.values(this.targets).map((arr) => arr.length);
          return counts.join("-");
        }
        /**
         * Registers for updates from unified systems - connects to event-driven architecture
         */
        registerSystemCallbacks() {
          try {
            GlobalEventBus.subscribe("colors/harmonized", (event) => {
              this.handleColorHarmonizedEvent(event);
            });
            console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Subscribed to colors/harmonized events");
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to subscribe to colors/harmonized events:", error);
            if (this.year3000System.colorHarmonyEngine) {
              const originalApplyColors = this.year3000System.applyColorsToTheme.bind(
                this.year3000System
              );
              this.year3000System.applyColorsToTheme = (extractedColors = {}) => {
                originalApplyColors(extractedColors);
                this.updateColorVariables(extractedColors);
              };
              console.warn("[SpotifyUIApplicationSystem] Using legacy color application hook as fallback");
            }
          }
          if (this.year3000System.musicSyncService) {
            const originalUpdateFromAnalysis = this.year3000System.updateFromMusicAnalysis.bind(this.year3000System);
            this.year3000System.updateFromMusicAnalysis = (processedData, rawFeatures, trackUri) => {
              originalUpdateFromAnalysis(processedData, rawFeatures, trackUri);
              this.updateMusicIntensity(processedData);
            };
          }
          if (this.year3000System.beatSyncVisualSystem) {
            if (this.year3000System.timerConsolidationSystem) {
              this.year3000System.timerConsolidationSystem.registerConsolidatedTimer(
                "SpotifyUIApplicationSystem-beatEffects",
                () => {
                  const intensity = this.getCurrentMusicIntensity();
                  if (intensity > 0.5) {
                    this.triggerBeatEffects({ intensity });
                  }
                },
                200,
                "normal"
              );
            } else {
              setInterval(() => {
                const intensity = this.getCurrentMusicIntensity();
                if (intensity > 0.5) {
                  this.triggerBeatEffects({ intensity });
                }
              }, 200);
            }
          }
        }
        getCurrentMusicIntensity() {
          const root = document.documentElement;
          const intensity = getComputedStyle(root).getPropertyValue("--sn-kinetic-energy").trim();
          return parseFloat(intensity) || 0;
        }
        /**
         * Handle colors/harmonized event from ColorOrchestrator (Event-driven architecture)
         */
        handleColorHarmonizedEvent(event) {
          if (event.type !== "colors/harmonized") return;
          const { processedColors, cssVariables, metadata } = event.payload;
          console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Received harmonized colors via event-driven pattern", {
            strategy: metadata.strategy,
            colorsCount: Object.keys(processedColors).length,
            cssVariablesCount: Object.keys(cssVariables).length
          });
          try {
            this.updateColorVariables(processedColors);
            if (cssVariables && Object.keys(cssVariables).length > 0) {
              this.applyCSSVariablesToSpotifyUI(cssVariables);
            }
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to apply harmonized colors from event:", error);
            this.updateColorVariables(processedColors);
          }
        }
        /**
         * Apply CSS variables directly to Spotify UI elements (optimization for event-driven pattern)
         */
        applyCSSVariablesToSpotifyUI(cssVariables) {
          try {
            const root = document.documentElement;
            const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
            for (const [variable, value] of Object.entries(cssVariables)) {
              if (variable && value) {
                root.style.setProperty(variable, value);
              }
            }
            enhancedElements.forEach((element) => {
              if (element instanceof HTMLElement) {
                for (const [variable, value] of Object.entries(cssVariables)) {
                  if (variable && value) {
                    element.style.setProperty(variable, value);
                  }
                }
              }
            });
            console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Applied CSS variables to Spotify UI", {
              variablesCount: Object.keys(cssVariables).length,
              enhancedElementsCount: enhancedElements.length
            });
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to apply CSS variables to Spotify UI:", error);
          }
        }
        updateColorVariables(colorData) {
          const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
          enhancedElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-primary",
                colorData.primary || "var(--spice-accent)",
                element
              );
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-secondary",
                colorData.secondary || "var(--spice-accent)",
                element
              );
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-tertiary",
                colorData.tertiary || "var(--spice-accent)",
                element
              );
            }
          });
        }
        updateMusicIntensity(processedData) {
          const intensity = processedData?.processedEnergy || 0;
          const intensityElements = document.querySelectorAll(".sn-beat-responsive");
          intensityElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-music-intensity",
                intensity.toString(),
                element
              );
            }
          });
        }
        triggerBeatEffects(beatData) {
          const beatElements = document.querySelectorAll(".sn-beat-responsive");
          beatElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-beat-pulse",
                "1",
                element
              );
              element.classList.add("sn-beat-active");
              setTimeout(() => {
                this.safeQueueCSSVariableUpdate(
                  "--sn-beat-pulse",
                  "0",
                  element
                );
                element.classList.remove("sn-beat-active");
              }, 200);
            }
          });
        }
        /**
         * Cascade Coordination - Ensures proper layering of effects
         */
        forceEffectCascade() {
          this.effectLayers.sort((a, b) => a.priority - b.priority).forEach((layer) => {
            layer.elements.forEach((element) => {
              this.applyEffectToElement(element, layer);
            });
          });
        }
        async destroy() {
          if (this.year3000System?.timerConsolidationSystem) {
            this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer("SpotifyUIApplicationSystem-beatEffects");
          }
          this.observerRegistry.forEach((observer) => {
            observer.disconnect();
          });
          this.observerRegistry.clear();
          const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
          enhancedElements.forEach((element) => {
            element.classList.remove("sn-ui-enhanced");
            element.removeAttribute("data-sn-layer");
            element.removeAttribute("data-sn-priority");
          });
          this.initialized = false;
        }
        // Debug utility
        getTargetStats() {
          return Object.fromEntries(
            Object.entries(this.targets).map(([key, elements]) => [
              key,
              elements.length
            ])
          );
        }
      };
      __name(_SpotifyUIApplicationSystem, "SpotifyUIApplicationSystem");
      SpotifyUIApplicationSystem = _SpotifyUIApplicationSystem;
    }
  });

  // src-js/visual/backbone/GradientConductor.ts
  var _BackendSelector, BackendSelector, _GradientConductor, GradientConductor;
  var init_GradientConductor = __esm({
    "src-js/visual/backbone/GradientConductor.ts"() {
      "use strict";
      init_EventBus();
      _BackendSelector = class _BackendSelector {
        static selectOptimalBackend(registrations) {
          const sorted = registrations.filter((reg) => reg.backend.isReady && reg.backend.capabilities).sort((a, b) => b.priority - a.priority);
          for (const registration of sorted) {
            const caps = registration.capabilities;
            if (caps.webgl2 && caps.maxTextureSize >= 2048) {
              return registration.backend;
            }
            if (caps.webgl && caps.maxTextureSize >= 1024) {
              return registration.backend;
            }
            if (registration.backend.backendId === "css") {
              return registration.backend;
            }
          }
          return null;
        }
      };
      __name(_BackendSelector, "BackendSelector");
      BackendSelector = _BackendSelector;
      _GradientConductor = class _GradientConductor {
        constructor(eventBus, cssConsciousnessController, colorHarmonyEngine, musicSyncService, performanceAnalyzer, config = {}) {
          this.initialized = false;
          this.registeredBackends = /* @__PURE__ */ new Map();
          this.activeBackend = null;
          this.rootElement = null;
          this.currentPalette = [];
          this.currentMusicMetrics = null;
          // Performance monitoring
          this.lastFrameTime = 0;
          this.frameCount = 0;
          this.performanceCheckInterval = null;
          this.eventBus = eventBus || GlobalEventBus;
          this.cssConsciousnessController = cssConsciousnessController;
          this.colorHarmonyEngine = colorHarmonyEngine;
          this.musicSyncService = musicSyncService;
          this.performanceAnalyzer = performanceAnalyzer;
          this.config = {
            enabledBackends: ["webgl", "css"],
            defaultQuality: "high",
            transitionDuration: 500,
            performanceMonitoring: true,
            autoQualityScaling: true,
            ...config
          };
          this.currentConstraints = {
            targetFPS: 60,
            maxMemoryMB: 50,
            cpuBudgetPercent: 10,
            gpuBudgetPercent: 25,
            qualityLevel: this.config.defaultQuality
          };
        }
        /**
         * Initialize the GradientConductor and set up event listeners
         */
        async initialize() {
          try {
            this.setupEventListeners();
            this.setupCSSVariableUpdates();
            if (this.config.performanceMonitoring) {
              this.startPerformanceMonitoring();
            }
            this.updateGlobalStatus();
            this.initialized = true;
            console.log("[GradientConductor] Initialized successfully", {
              enabledBackends: this.config.enabledBackends,
              registeredBackends: Array.from(this.registeredBackends.keys())
            });
          } catch (error) {
            console.error("[GradientConductor] Initialization failed:", error);
            throw error;
          }
        }
        /**
         * Register a visual backend with the conductor
         */
        registerBackend(backend, priority = 0) {
          const registration = {
            backend,
            priority,
            capabilities: backend.capabilities,
            lastHealthCheck: /* @__PURE__ */ new Date(),
            isActive: false
          };
          this.registeredBackends.set(backend.backendId, registration);
          console.log(
            `[GradientConductor] Registered backend: ${backend.backendId}`,
            {
              priority,
              capabilities: backend.capabilities
            }
          );
          this.evaluateActiveBackend();
        }
        /**
         * Unregister a visual backend
         */
        unregisterBackend(backendId) {
          const registration = this.registeredBackends.get(backendId);
          if (registration) {
            registration.backend.setEnabled(false);
            this.registeredBackends.delete(backendId);
            if (this.activeBackend?.backendId === backendId) {
              this.activeBackend = null;
              this.evaluateActiveBackend();
            }
            console.log(`[GradientConductor] Unregistered backend: ${backendId}`);
          }
        }
        /**
         * Initialize all backends with the root element
         */
        async initializeBackends(rootElement) {
          this.rootElement = rootElement;
          const initPromises = Array.from(this.registeredBackends.values()).map(
            async (registration) => {
              try {
                await registration.backend.init(rootElement, this.currentConstraints);
                console.log(
                  `[GradientConductor] Backend ${registration.backend.backendId} initialized`
                );
              } catch (error) {
                console.error(
                  `[GradientConductor] Failed to initialize backend ${registration.backend.backendId}:`,
                  error
                );
              }
            }
          );
          await Promise.allSettled(initPromises);
          this.evaluateActiveBackend();
          if (this.activeBackend) {
            if (this.currentPalette.length > 0) {
              this.activeBackend.setPalette(this.currentPalette);
            }
            if (this.currentMusicMetrics) {
              this.activeBackend.setMusicMetrics(this.currentMusicMetrics);
            }
          }
        }
        /**
         * Update the color palette across all systems
         */
        setPalette(stops, transition = this.config.transitionDuration) {
          this.currentPalette = [...stops];
          this.updateCSSGradientVariables(stops);
          if (this.activeBackend) {
            this.activeBackend.setPalette(stops, transition);
          }
          this.updateGlobalStatus();
          console.log("[GradientConductor] Palette updated", {
            stops: stops.length,
            activeBackend: this.activeBackend?.backendId,
            transition
          });
        }
        /**
         * Update music synchronization metrics
         */
        setMusicMetrics(metrics) {
          this.currentMusicMetrics = metrics;
          this.updateCSSMusicVariables(metrics);
          if (this.activeBackend) {
            this.activeBackend.setMusicMetrics(metrics);
          }
          this.eventBus.emit("musicMetricsUpdated", metrics);
        }
        /**
         * Update performance constraints and trigger quality scaling
         */
        setPerformanceConstraints(constraints) {
          this.currentConstraints = { ...constraints };
          for (const registration of this.registeredBackends.values()) {
            registration.backend.setPerformanceConstraints(constraints);
          }
          if (constraints.qualityLevel !== this.currentConstraints.qualityLevel) {
            this.evaluateActiveBackend();
          }
          console.log(
            "[GradientConductor] Performance constraints updated",
            constraints
          );
        }
        /**
         * Get the currently active backend
         */
        getActiveBackend() {
          return this.activeBackend;
        }
        /**
         * Trigger music emotion analysis through ColorHarmonyEngine
         * This completes the Music → Emotion → Color → Visual flow
         */
        async triggerMusicEmotionAnalysis(audioFeatures, audioData) {
          try {
            if (this.colorHarmonyEngine && typeof this.colorHarmonyEngine.analyzeMusicEmotion === "function") {
              const emotion = await this.colorHarmonyEngine.analyzeMusicEmotion(audioFeatures, audioData);
              if (emotion && this.config.performanceMonitoring) {
                console.log(`[GradientConductor] Music emotion analysis triggered: ${emotion.primary} (${emotion.intensity.toFixed(2)} intensity)`);
              }
            } else {
              console.warn("[GradientConductor] ColorHarmonyEngine not available for music emotion analysis");
            }
          } catch (error) {
            console.error("[GradientConductor] Error triggering music emotion analysis:", error);
          }
        }
        /**
         * Get all registered backends
         */
        getRegisteredBackends() {
          return Array.from(this.registeredBackends.values());
        }
        /**
         * Force a specific backend to be active (for testing/debugging)
         */
        setActiveBackend(backendId) {
          const registration = this.registeredBackends.get(backendId);
          if (!registration || !registration.backend.isReady) {
            return false;
          }
          if (this.activeBackend) {
            this.activeBackend.setEnabled(false);
            const currentReg = this.registeredBackends.get(
              this.activeBackend.backendId
            );
            if (currentReg) currentReg.isActive = false;
          }
          this.activeBackend = registration.backend;
          registration.isActive = true;
          registration.backend.setEnabled(true, this.config.transitionDuration);
          this.updateGlobalStatus();
          console.log(`[GradientConductor] Forced backend switch to: ${backendId}`);
          return true;
        }
        /**
         * Perform health checks on all backends
         */
        async healthCheck() {
          const issues = [];
          for (const [backendId, registration] of this.registeredBackends) {
            try {
              const result = await registration.backend.healthCheck();
              registration.lastHealthCheck = /* @__PURE__ */ new Date();
              if (!result.ok) {
                issues.push(
                  `Backend ${backendId}: ${result.details || "Health check failed"}`
                );
              }
            } catch (error) {
              issues.push(`Backend ${backendId}: Health check error - ${error}`);
            }
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: issues.length > 0 ? `${issues.length} backend issues detected` : "All backends healthy",
            issues,
            system: "GradientConductor"
          };
        }
        /**
         * Animation update tick for performance monitoring
         */
        updateAnimation(deltaTime) {
          this.frameCount++;
          this.lastFrameTime = deltaTime;
          if (this.activeBackend) {
            this.activeBackend.updateAnimation(deltaTime);
          }
        }
        /**
         * Clean up resources and event listeners
         */
        destroy() {
          if (this.performanceCheckInterval) {
            clearInterval(this.performanceCheckInterval);
            this.performanceCheckInterval = null;
          }
          for (const registration of this.registeredBackends.values()) {
            registration.backend.destroy();
          }
          this.registeredBackends.clear();
          this.activeBackend = null;
          this.initialized = false;
          console.log("[GradientConductor] Destroyed");
        }
        // ========================================================================
        // PRIVATE METHODS
        // ========================================================================
        setupEventListeners() {
          this.eventBus.on("colorHarmonyUpdated", (palette) => {
            if (palette && palette.length > 0) {
              const stops = palette.map((color2, index) => ({
                r: color2.r,
                g: color2.g,
                b: color2.b,
                position: index / (palette.length - 1)
              }));
              this.setPalette(stops);
            }
          });
          this.eventBus.on(
            "musicSyncUpdated",
            (metrics) => {
              this.setMusicMetrics(metrics);
            }
          );
          this.eventBus.on(
            "performanceConstraintsChanged",
            (constraints) => {
              this.setPerformanceConstraints(constraints);
            }
          );
          this.eventBus.on(
            "accessibilityPreferencesChanged",
            (preferences) => {
              for (const registration of this.registeredBackends.values()) {
                registration.backend.applyAccessibilityPreferences?.(preferences);
              }
            }
          );
          this.eventBus.on(
            "emotion:analyzed",
            (emotionData) => {
              this.handleEmotionUpdate(emotionData);
            }
          );
          this.eventBus.on(
            "emotionalColorContext:updated",
            (context) => {
              this.handleEmotionalColorContext(context);
            }
          );
        }
        setupCSSVariableUpdates() {
          const criticalVariables = [
            "--sn.music.beat.pulse.intensity",
            "--sn.music.rhythm.phase",
            "--sn.music.breathing.scale",
            "--sn.bg.webgl.ready",
            "--sn.bg.active-backend",
            // Year 3000 consciousness variables (emotion-aware)
            "--sn-emotion-primary",
            "--sn-emotion-intensity",
            "--sn-color-temperature",
            "--sn-consciousness-level",
            "--sn-organic-flow",
            "--sn-cinematic-depth"
          ];
          criticalVariables.forEach((variable) => {
            this.cssConsciousnessController.addCriticalVariable(variable);
          });
        }
        /**
         * Handle emotion analysis updates from ColorHarmonyEngine
         * Part of the Year 3000 consciousness-aware flow
         */
        handleEmotionUpdate(emotionData) {
          try {
            const { emotion, colorTemperature, consciousnessLevel, organicFlow, cinematicDepth } = emotionData;
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-primary",
              emotion.primary || "neutral"
            );
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-intensity",
              (emotion.intensity || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-confidence",
              (emotion.confidence || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-color-temperature",
              (colorTemperature || 6500).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-consciousness-level",
              (consciousnessLevel || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-organic-flow",
              (organicFlow || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-cinematic-depth",
              (cinematicDepth || 0.5).toString()
            );
            for (const registration of this.registeredBackends.values()) {
              if (registration.backend.setEmotionalState) {
                registration.backend.setEmotionalState(emotion);
              }
            }
            console.log(`[GradientConductor] Emotion updated: ${emotion.primary} (intensity: ${emotion.intensity?.toFixed(2) || "N/A"})`);
          } catch (error) {
            console.error("[GradientConductor] Error handling emotion update:", error);
          }
        }
        /**
         * Handle emotional color context updates
         * Triggers consciousness-aware color processing across all backends
         */
        handleEmotionalColorContext(context) {
          try {
            const {
              primaryEmotion,
              emotionIntensity,
              colorTemperature,
              valence,
              arousal,
              dominance,
              organicFlow,
              cinematicDepth,
              consciousnessResonance
            } = context;
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-valence",
              (valence || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-arousal",
              (arousal || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-emotion-dominance",
              (dominance || 0.5).toString()
            );
            this.cssConsciousnessController.setProperty(
              "--sn-consciousness-resonance",
              (consciousnessResonance || 0.5).toString()
            );
            for (const registration of this.registeredBackends.values()) {
              if (registration.backend.setEmotionalContext) {
                registration.backend.setEmotionalContext(context);
              }
            }
            console.log(`[GradientConductor] Emotional context updated: ${primaryEmotion} (temp: ${colorTemperature}K)`);
          } catch (error) {
            console.error("[GradientConductor] Error handling emotional color context:", error);
          }
        }
        updateCSSGradientVariables(stops) {
          if (stops.length === 0) return;
          const primary = stops[0];
          const secondary = stops[Math.floor(stops.length / 2)];
          const accent = stops[stops.length - 1];
          this.cssConsciousnessController.setProperty(
            "--sn.bg.gradient.primary.rgb",
            `${primary.r}, ${primary.g}, ${primary.b}`
          );
          this.cssConsciousnessController.setProperty(
            "--sn.bg.gradient.secondary.rgb",
            `${secondary.r}, ${secondary.g}, ${secondary.b}`
          );
          this.cssConsciousnessController.setProperty(
            "--sn.bg.gradient.accent.rgb",
            `${accent.r}, ${accent.g}, ${accent.b}`
          );
          this.cssConsciousnessController.setProperty(
            "--sn.color.accent.rgb",
            `${accent.r}, ${accent.g}, ${accent.b}`
          );
          this.cssConsciousnessController.setProperty(
            "--sn.color.accent.hex",
            `#${Math.round(accent.r).toString(16).padStart(2, "0")}${Math.round(
              accent.g
            ).toString(16).padStart(2, "0")}${Math.round(accent.b).toString(16).padStart(2, "0")}`
          );
        }
        updateCSSMusicVariables(metrics) {
          if (metrics.beatIntensity !== void 0) {
            this.cssConsciousnessController.setProperty(
              "--sn.music.beat.pulse.intensity",
              metrics.beatIntensity.toString()
            );
          }
          if (metrics.rhythmPhase !== void 0) {
            this.cssConsciousnessController.setProperty(
              "--sn.music.rhythm.phase",
              `${metrics.rhythmPhase}deg`
            );
          }
          if (metrics.breathingScale !== void 0) {
            this.cssConsciousnessController.setProperty(
              "--sn.music.breathing.scale",
              metrics.breathingScale.toString()
            );
          }
          this.cssConsciousnessController.setProperty(
            "--sn.music.energy.level",
            metrics.energy.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn.music.valence",
            metrics.valence.toString()
          );
          this.cssConsciousnessController.setProperty(
            "--sn.music.tempo.bpm",
            metrics.bpm.toString()
          );
        }
        updateGlobalStatus() {
          this.cssConsciousnessController.setProperty(
            "--sn.bg.webgl.ready",
            this.registeredBackends.has("webgl") ? "1" : "0"
          );
          this.cssConsciousnessController.setProperty(
            "--sn.bg.active-backend",
            this.activeBackend?.backendId || "none"
          );
          if (typeof window !== "undefined") {
            window.snActiveBackend = this.activeBackend?.backendId || "none";
          }
        }
        evaluateActiveBackend() {
          const optimal = BackendSelector.selectOptimalBackend(
            Array.from(this.registeredBackends.values())
          );
          if (optimal && optimal !== this.activeBackend) {
            if (this.activeBackend) {
              this.activeBackend.setEnabled(false, this.config.transitionDuration);
              const currentReg = this.registeredBackends.get(
                this.activeBackend.backendId
              );
              if (currentReg) currentReg.isActive = false;
            }
            this.activeBackend = optimal;
            const newReg = this.registeredBackends.get(optimal.backendId);
            if (newReg) {
              newReg.isActive = true;
              optimal.setEnabled(true, this.config.transitionDuration);
            }
            this.updateGlobalStatus();
            console.log(
              `[GradientConductor] Switched to backend: ${optimal.backendId}`
            );
            this.eventBus.emit("activeBackendChanged", {
              previousBackend: this.activeBackend?.backendId,
              newBackend: optimal.backendId,
              capabilities: optimal.capabilities
            });
          }
        }
        startPerformanceMonitoring() {
          this.performanceCheckInterval = window.setInterval(() => {
            if (!this.activeBackend) return;
            try {
              const metrics = this.activeBackend.getPerformanceMetrics();
              if (this.config.autoQualityScaling) {
                this.evaluateQualityScaling(metrics);
              }
              this.performanceAnalyzer.recordMetric(
                "gradientConductor.fps",
                metrics.fps
              );
              this.performanceAnalyzer.recordMetric(
                "gradientConductor.memory",
                metrics.memoryUsageMB
              );
            } catch (error) {
              console.warn(
                "[GradientConductor] Performance monitoring error:",
                error
              );
            }
          }, 2e3);
        }
        evaluateQualityScaling(metrics) {
          const constraints = this.currentConstraints;
          if (metrics.fps < constraints.targetFPS * 0.8 || metrics.memoryUsageMB > constraints.maxMemoryMB * 1.2) {
            let newQuality = constraints.qualityLevel;
            switch (constraints.qualityLevel) {
              case "ultra":
                newQuality = "high";
                break;
              case "high":
                newQuality = "medium";
                break;
              case "medium":
                newQuality = "low";
                break;
              case "low":
                this.evaluateActiveBackend();
                return;
            }
            console.log(
              `[GradientConductor] Auto-scaling quality: ${constraints.qualityLevel} \u2192 ${newQuality}`
            );
            this.setPerformanceConstraints({
              ...constraints,
              qualityLevel: newQuality
            });
          }
        }
      };
      __name(_GradientConductor, "GradientConductor");
      GradientConductor = _GradientConductor;
    }
  });

  // src-js/core/performance/AdaptivePerformanceSystem.ts
  var _AdaptivePerformanceSystem, AdaptivePerformanceSystem;
  var init_AdaptivePerformanceSystem = __esm({
    "src-js/core/performance/AdaptivePerformanceSystem.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_DeviceCapabilityDetector();
      init_PerformanceAnalyzer();
      _AdaptivePerformanceSystem = class _AdaptivePerformanceSystem {
        constructor(deviceDetector, performanceAnalyzer) {
          // Performance monitoring
          this.performanceHistory = [];
          this.monitoringInterval = null;
          this.adaptationTimer = null;
          this.lastAdaptation = 0;
          this.adaptationCooldown = 5e3;
          // 5 seconds between adaptations
          // Thermal and power management
          this.thermalHistory = [];
          this.powerObserver = null;
          this.batteryAPI = null;
          // Event handling
          this.eventListeners = [];
          this.boundPerformanceCheck = null;
          this.boundThermalCheck = null;
          // Circuit breaker for dependency validation
          this.dependencyCircuitBreaker = {
            failures: 0,
            lastFailure: 0,
            isOpen: false,
            openDuration: 3e4,
            // 30 seconds
            maxFailures: 5
          };
          // Quality scaling algorithms
          this.qualityScales = {
            ultra: { complexity: 1, particles: 1, fps: 60, precision: "highp" },
            high: { complexity: 0.8, particles: 0.8, fps: 60, precision: "highp" },
            medium: { complexity: 0.6, particles: 0.6, fps: 45, precision: "mediump" },
            low: { complexity: 0.4, particles: 0.4, fps: 30, precision: "mediump" },
            minimal: { complexity: 0.2, particles: 0.2, fps: 24, precision: "lowp" }
          };
          this.deviceDetector = deviceDetector || new DeviceCapabilityDetector();
          this.performanceAnalyzer = performanceAnalyzer || new PerformanceAnalyzer();
          this.hardwareMetrics = this.detectHardware();
          this.currentProfile = this.determineOptimalProfile();
          this.currentBudget = this.calculatePerformanceBudget();
          this.currentQuality = this.deriveQualitySettings();
          this.boundPerformanceCheck = this.performanceCheck.bind(this);
          this.boundThermalCheck = this.thermalCheck.bind(this);
          Y3K?.debug?.log("AdaptivePerformanceSystem", "Initialized with profile:", this.currentProfile.tier);
        }
        async initialize() {
          await this.initializeHardwareMonitoring();
          this.startPerformanceMonitoring();
          await this.initializePowerManagement();
          this.initializeThermalMonitoring();
          Y3K?.debug?.log("AdaptivePerformanceSystem", "Performance monitoring started");
        }
        detectHardware() {
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
          const cpuCores = navigator.hardwareConcurrency || 4;
          const cpuArchitecture = this.detectCPUArchitecture();
          const memoryInfo = performance.memory;
          const totalMemoryGB = memoryInfo ? memoryInfo.jsHeapSizeLimit / (1024 * 1024 * 1024) : 4;
          const availableMemoryMB = memoryInfo ? (memoryInfo.jsHeapSizeLimit - memoryInfo.usedJSHeapSize) / (1024 * 1024) : 1024;
          let gpuVendor = "unknown";
          let gpuRenderer = "unknown";
          let maxTextureSize = 2048;
          let webglVersion = "none";
          if (gl) {
            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            if (debugInfo) {
              gpuVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || "unknown";
              gpuRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || "unknown";
            }
            maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            webglVersion = gl instanceof WebGL2RenderingContext ? "2.0" : "1.0";
          }
          const devicePixelRatio = window.devicePixelRatio || 1;
          const screenResolution = {
            width: screen.width * devicePixelRatio,
            height: screen.height * devicePixelRatio
          };
          return {
            cpuCores,
            cpuFrequency: 0,
            // Not directly detectable
            cpuArchitecture,
            totalMemoryGB,
            availableMemoryMB,
            memoryPressure: availableMemoryMB < 512 ? "high" : availableMemoryMB < 1024 ? "medium" : "low",
            gpuVendor,
            gpuRenderer,
            maxTextureSize,
            webglVersion,
            devicePixelRatio,
            screenResolution,
            powerLevel: "balanced",
            // Will be updated by power management
            thermalState: "nominal"
          };
        }
        detectCPUArchitecture() {
          const userAgent = navigator.userAgent.toLowerCase();
          if (userAgent.includes("arm64") || userAgent.includes("aarch64")) {
            return "arm64";
          } else if (userAgent.includes("arm")) {
            return "arm32";
          } else if (userAgent.includes("x86_64") || userAgent.includes("amd64")) {
            return "x64";
          } else if (userAgent.includes("x86")) {
            return "x86";
          }
          return "unknown";
        }
        determineOptimalProfile() {
          const deviceTier = this.deviceDetector.recommendPerformanceQuality();
          const isMobile = /Mobi|Android/i.test(navigator.userAgent);
          const isLowMemory = this.hardwareMetrics.memoryPressure === "high";
          const hasWebGL2 = this.hardwareMetrics.webglVersion === "2.0";
          let tier;
          if (isLowMemory || !hasWebGL2) {
            tier = "minimal";
          } else if (isMobile) {
            tier = deviceTier === "high" ? "medium" : "low";
          } else {
            switch (deviceTier) {
              case "high":
                tier = this.hardwareMetrics.cpuCores >= 8 ? "ultra" : "high";
                break;
              case "balanced":
                tier = "medium";
                break;
              default:
                tier = "low";
            }
          }
          const profiles = {
            ultra: {
              tier: "ultra",
              targetFPS: 60,
              memoryBudgetMB: 100,
              cpuBudgetPercent: 20,
              gpuBudgetPercent: 40,
              thermalLimit: 75,
              adaptiveScaling: true
            },
            high: {
              tier: "high",
              targetFPS: 60,
              memoryBudgetMB: 75,
              cpuBudgetPercent: 15,
              gpuBudgetPercent: 30,
              thermalLimit: 70,
              adaptiveScaling: true
            },
            medium: {
              tier: "medium",
              targetFPS: 45,
              memoryBudgetMB: 50,
              cpuBudgetPercent: 10,
              gpuBudgetPercent: 20,
              thermalLimit: 65,
              adaptiveScaling: true
            },
            low: {
              tier: "low",
              targetFPS: 30,
              memoryBudgetMB: 32,
              cpuBudgetPercent: 8,
              gpuBudgetPercent: 15,
              thermalLimit: 60,
              adaptiveScaling: false
            },
            minimal: {
              tier: "minimal",
              targetFPS: 24,
              memoryBudgetMB: 20,
              cpuBudgetPercent: 5,
              gpuBudgetPercent: 10,
              thermalLimit: 55,
              adaptiveScaling: false
            }
          };
          return profiles[tier];
        }
        calculatePerformanceBudget() {
          const frameTimeMs = 1e3 / this.currentProfile.targetFPS;
          return {
            frameTimeMs,
            memoryLimitMB: this.currentProfile.memoryBudgetMB,
            cpuTimeSliceMs: frameTimeMs * 0.8,
            // 80% of frame time for CPU
            gpuUtilizationPercent: this.currentProfile.gpuBudgetPercent,
            networkBandwidthKBps: 100
            // Conservative network budget
          };
        }
        deriveQualitySettings() {
          const scale = this.qualityScales[this.currentProfile.tier];
          return {
            gradientComplexity: scale.complexity,
            particleDensity: scale.particles,
            shaderPrecision: scale.precision,
            textureResolution: scale.complexity,
            animationFPS: scale.fps,
            transitionQuality: this.currentProfile.tier === "ultra" ? "cinematic" : this.currentProfile.tier === "high" ? "smooth" : this.currentProfile.tier === "medium" ? "basic" : "instant",
            motionBlur: this.currentProfile.tier === "ultra",
            bloomEnabled: scale.complexity > 0.6,
            shadowQuality: this.currentProfile.tier === "ultra" ? "high" : this.currentProfile.tier === "high" ? "medium" : this.currentProfile.tier === "medium" ? "low" : "off",
            antiAliasing: this.currentProfile.tier === "ultra" ? "msaa4x" : this.currentProfile.tier === "high" ? "msaa2x" : this.currentProfile.tier === "medium" ? "fxaa" : "none",
            postProcessing: scale.complexity > 0.5
          };
        }
        async initializeHardwareMonitoring() {
          if ("memory" in performance) {
          }
          if ("connection" in navigator) {
            const connection = navigator.connection;
            if (connection) {
              connection.addEventListener("change", () => {
                this.adaptToConnectionSpeed(connection.effectiveType);
              });
            }
          }
        }
        startPerformanceMonitoring() {
          if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
          }
          this.monitoringInterval = window.setInterval(this.boundPerformanceCheck, 1e3);
        }
        performanceCheck() {
          const fps = this.performanceAnalyzer.getMedianFPS() || 0;
          const frameTime = fps > 0 ? 1e3 / fps : 1e3;
          const memoryInfo = performance.memory;
          const memoryUsage = memoryInfo ? memoryInfo.usedJSHeapSize / (1024 * 1024) : 0;
          const cpuUsage = this.estimateCPUUsage(fps, frameTime);
          const gpuUsage = this.estimateGPUUsage(fps, frameTime);
          this.performanceHistory.push({
            timestamp: performance.now(),
            fps,
            frameTime,
            memoryUsage,
            cpuUsage,
            gpuUsage,
            thermalState: this.hardwareMetrics.thermalState
          });
          const cutoff = performance.now() - 3e4;
          this.performanceHistory = this.performanceHistory.filter((entry) => entry.timestamp > cutoff);
          this.checkAdaptationNeeded();
        }
        estimateCPUUsage(fps, frameTime) {
          const targetFrameTime = this.currentBudget.frameTimeMs;
          const usage = Math.min(frameTime / targetFrameTime * 100, 100);
          return Math.max(usage, 5);
        }
        estimateGPUUsage(fps, frameTime) {
          const complexity = this.currentQuality.gradientComplexity;
          const baseUsage = complexity * 20;
          const frameTimeImpact = frameTime > this.currentBudget.frameTimeMs ? 10 : 0;
          return Math.min(baseUsage + frameTimeImpact, 100);
        }
        checkAdaptationNeeded() {
          if (!this.currentProfile.adaptiveScaling) return;
          if (performance.now() - this.lastAdaptation < this.adaptationCooldown) return;
          if (this.performanceHistory.length < 5) return;
          if (!this.validateCoreDependencies()) {
            Y3K?.debug?.log("AdaptivePerformanceSystem", "Skipping adaptation - core dependencies not ready");
            return;
          }
          const recent = this.performanceHistory.slice(-5);
          const avgFPS = recent.reduce((sum, entry) => sum + entry.fps, 0) / recent.length;
          const avgMemory = recent.reduce((sum, entry) => sum + entry.memoryUsage, 0) / recent.length;
          const avgFrameTime = recent.reduce((sum, entry) => sum + entry.frameTime, 0) / recent.length;
          if (this.isInDegradedState(avgFPS, avgFrameTime)) {
            Y3K?.debug?.log("AdaptivePerformanceSystem", "Skipping adaptation - system in degraded state");
            return;
          }
          const fpsIssue = avgFPS < this.currentProfile.targetFPS * 0.8;
          const memoryIssue = avgMemory > this.currentBudget.memoryLimitMB;
          const frameTimeIssue = avgFrameTime > this.currentBudget.frameTimeMs * 1.2;
          const thermalIssue = this.hardwareMetrics.thermalState !== "nominal";
          if (fpsIssue || memoryIssue || frameTimeIssue || thermalIssue) {
            this.adaptPerformanceDown();
          } else if (this.canScaleUp(avgFPS, avgMemory, avgFrameTime)) {
            this.adaptPerformanceUp();
          }
        }
        canScaleUp(fps, memory, frameTime) {
          const fpsHeadroom = fps > this.currentProfile.targetFPS * 1.1;
          const memoryHeadroom = memory < this.currentBudget.memoryLimitMB * 0.7;
          const frameTimeHeadroom = frameTime < this.currentBudget.frameTimeMs * 0.8;
          const noThermalIssues = this.hardwareMetrics.thermalState === "nominal";
          return fpsHeadroom && memoryHeadroom && frameTimeHeadroom && noThermalIssues;
        }
        /**
         * Check if circuit breaker is open (preventing dependency checks)
         */
        isCircuitBreakerOpen() {
          const now = performance.now();
          if (this.dependencyCircuitBreaker.isOpen) {
            if (now - this.dependencyCircuitBreaker.lastFailure > this.dependencyCircuitBreaker.openDuration) {
              this.dependencyCircuitBreaker.isOpen = false;
              this.dependencyCircuitBreaker.failures = 0;
              Y3K?.debug?.log("AdaptivePerformanceSystem", "Circuit breaker reset - attempting dependency validation");
              return false;
            }
            return true;
          }
          return false;
        }
        /**
         * Record dependency validation failure
         */
        recordDependencyFailure() {
          this.dependencyCircuitBreaker.failures++;
          this.dependencyCircuitBreaker.lastFailure = performance.now();
          if (this.dependencyCircuitBreaker.failures >= this.dependencyCircuitBreaker.maxFailures) {
            this.dependencyCircuitBreaker.isOpen = true;
            Y3K?.debug?.warn("AdaptivePerformanceSystem", `Circuit breaker opened after ${this.dependencyCircuitBreaker.failures} failures`);
          }
        }
        /**
         * Validate that core dependencies are properly initialized before making performance adaptations
         * Prevents cascade loops when systems report as "loaded" but not fully initialized
         */
        validateCoreDependencies() {
          if (this.isCircuitBreakerOpen()) {
            return false;
          }
          try {
            const year3000System2 = globalThis.year3000System;
            if (!year3000System2) {
              this.recordDependencyFailure();
              return false;
            }
            const facadeCoordinator = year3000System2.facadeCoordinator;
            if (!facadeCoordinator) {
              this.recordDependencyFailure();
              return false;
            }
            const criticalSystems = [
              "MusicSyncService",
              "ColorHarmonyEngine",
              "UnifiedCSSConsciousnessController",
              "PerformanceAnalyzer"
            ];
            for (const systemName of criticalSystems) {
              try {
                let system = null;
                try {
                  system = facadeCoordinator.getCachedNonVisualSystem?.(systemName);
                } catch (e) {
                  const camelCaseName = systemName.charAt(0).toLowerCase() + systemName.slice(1);
                  system = year3000System2[camelCaseName];
                }
                if (!system) {
                  this.recordDependencyFailure();
                  return false;
                }
                if (typeof system.initialized === "boolean" && !system.initialized) {
                  this.recordDependencyFailure();
                  return false;
                }
              } catch (error) {
                this.recordDependencyFailure();
                return false;
              }
            }
            this.dependencyCircuitBreaker.failures = 0;
            return true;
          } catch (error) {
            Y3K?.debug?.error("AdaptivePerformanceSystem", "Dependency validation failed:", error);
            this.recordDependencyFailure();
            return false;
          }
        }
        /**
         * Check if system is in a degraded state that should prevent performance adaptations
         * Prevents endless downgrading when performance data is unreliable
         */
        isInDegradedState(avgFPS, avgFrameTime) {
          const isMinimalQuality = this.currentQuality.gradientComplexity <= 0.15 && this.currentQuality.particleDensity <= 0.15 && this.currentQuality.animationFPS <= 20;
          const isExtremelyPoor = avgFPS < 10 || avgFrameTime > 100;
          const recentAdaptations = this.performanceHistory.filter(
            (entry) => entry.timestamp > performance.now() - 3e4
            // Last 30 seconds
          ).length;
          const tooManyAdaptations = recentAdaptations > 10;
          return isMinimalQuality || isExtremelyPoor || tooManyAdaptations;
        }
        adaptPerformanceDown() {
          const oldQuality = { ...this.currentQuality };
          if (this.isInDegradedState(0, 0)) {
            Y3K?.debug?.warn("AdaptivePerformanceSystem", "Circuit breaker activated - preventing further quality reduction");
            return;
          }
          this.currentQuality.gradientComplexity = Math.max(0.1, this.currentQuality.gradientComplexity * 0.8);
          this.currentQuality.particleDensity = Math.max(0.1, this.currentQuality.particleDensity * 0.8);
          if (this.currentQuality.animationFPS > 24) {
            this.currentQuality.animationFPS = Math.max(15, this.currentQuality.animationFPS - 15);
          }
          if (this.currentQuality.postProcessing) {
            this.currentQuality.postProcessing = false;
          } else if (this.currentQuality.bloomEnabled) {
            this.currentQuality.bloomEnabled = false;
          } else if (this.currentQuality.antiAliasing !== "none") {
            this.currentQuality.antiAliasing = this.currentQuality.antiAliasing === "msaa4x" ? "msaa2x" : this.currentQuality.antiAliasing === "msaa2x" ? "fxaa" : "none";
          }
          this.lastAdaptation = performance.now();
          this.emitAdaptationEvent({
            type: "quality-change",
            reason: "Performance optimization",
            oldSettings: oldQuality,
            newSettings: { ...this.currentQuality },
            timestamp: performance.now()
          });
          Y3K?.debug?.log("AdaptivePerformanceSystem", "Adapted performance down", {
            complexity: this.currentQuality.gradientComplexity,
            fps: this.currentQuality.animationFPS
          });
        }
        adaptPerformanceUp() {
          const oldQuality = { ...this.currentQuality };
          if (!this.canRecoverQuality()) {
            Y3K?.debug?.log("AdaptivePerformanceSystem", "Skipping quality recovery - conditions not met");
            return;
          }
          this.currentQuality.gradientComplexity = Math.min(1, this.currentQuality.gradientComplexity * 1.1);
          this.currentQuality.particleDensity = Math.min(1, this.currentQuality.particleDensity * 1.1);
          if (this.currentQuality.animationFPS < this.currentProfile.targetFPS) {
            this.currentQuality.animationFPS = Math.min(this.currentProfile.targetFPS, this.currentQuality.animationFPS + 15);
          }
          if (!this.currentQuality.bloomEnabled && this.currentQuality.gradientComplexity > 0.6) {
            this.currentQuality.bloomEnabled = true;
          } else if (!this.currentQuality.postProcessing && this.currentQuality.gradientComplexity > 0.7) {
            this.currentQuality.postProcessing = true;
          }
          this.lastAdaptation = performance.now();
          this.emitAdaptationEvent({
            type: "quality-change",
            reason: "Performance headroom available",
            oldSettings: oldQuality,
            newSettings: { ...this.currentQuality },
            timestamp: performance.now()
          });
          Y3K?.debug?.log("AdaptivePerformanceSystem", "Adapted performance up", {
            complexity: this.currentQuality.gradientComplexity,
            fps: this.currentQuality.animationFPS
          });
        }
        /**
         * Determine if quality can be recovered safely
         * Prevents premature scaling up when system is still unstable
         */
        canRecoverQuality() {
          const stableHistoryRequired = 10;
          const stabilityWindow = performance.now() - 1e4;
          const stableHistory = this.performanceHistory.filter(
            (entry) => entry.timestamp > stabilityWindow && entry.fps >= this.currentProfile.targetFPS * 0.9 && entry.frameTime <= this.currentBudget.frameTimeMs
          );
          const hasStableHistory = stableHistory.length >= stableHistoryRequired;
          const recentAdaptationDown = performance.now() - this.lastAdaptation < 2e4;
          const dependenciesValid = this.validateCoreDependencies();
          return hasStableHistory && !recentAdaptationDown && dependenciesValid;
        }
        async initializePowerManagement() {
          if ("getBattery" in navigator) {
            try {
              this.batteryAPI = await navigator.getBattery();
              this.batteryAPI.addEventListener("chargingchange", () => this.updatePowerLevel());
              this.batteryAPI.addEventListener("levelchange", () => this.updatePowerLevel());
              this.updatePowerLevel();
            } catch (error) {
              Y3K?.debug?.warn("AdaptivePerformanceSystem", "Battery API not available:", error);
            }
          }
        }
        updatePowerLevel() {
          if (!this.batteryAPI) return;
          const charging = this.batteryAPI.charging;
          const level = this.batteryAPI.level;
          if (charging) {
            this.hardwareMetrics.powerLevel = "high";
          } else if (level > 0.5) {
            this.hardwareMetrics.powerLevel = "balanced";
          } else {
            this.hardwareMetrics.powerLevel = "battery-saver";
            if (level < 0.2) {
              this.adaptToBatterySaver();
            }
          }
        }
        adaptToBatterySaver() {
          const oldQuality = { ...this.currentQuality };
          this.currentQuality.gradientComplexity = 0.2;
          this.currentQuality.particleDensity = 0.1;
          this.currentQuality.animationFPS = 24;
          this.currentQuality.postProcessing = false;
          this.currentQuality.bloomEnabled = false;
          this.currentQuality.antiAliasing = "none";
          this.currentQuality.shadowQuality = "off";
          this.emitAdaptationEvent({
            type: "quality-change",
            reason: "Battery conservation mode",
            oldSettings: oldQuality,
            newSettings: { ...this.currentQuality },
            timestamp: performance.now()
          });
        }
        initializeThermalMonitoring() {
          setInterval(this.boundThermalCheck, 1e4);
        }
        thermalCheck() {
          if (this.performanceHistory.length < 10) return;
          const recent = this.performanceHistory.slice(-10);
          const avgFPS = recent.reduce((sum, entry) => sum + entry.fps, 0) / recent.length;
          const fpsDecline = this.performanceHistory.length > 20 ? this.performanceHistory.slice(-20, -10).reduce((sum, entry) => sum + entry.fps, 0) / 10 - avgFPS : 0;
          let newThermalState = "nominal";
          if (fpsDecline > 10) {
            newThermalState = "critical";
          } else if (fpsDecline > 5) {
            newThermalState = "hot";
          } else if (fpsDecline > 2) {
            newThermalState = "warm";
          }
          if (newThermalState !== this.hardwareMetrics.thermalState) {
            this.hardwareMetrics.thermalState = newThermalState;
            if (newThermalState !== "nominal") {
              this.handleThermalThrottling(newThermalState);
            }
          }
          this.thermalHistory.push(avgFPS);
          if (this.thermalHistory.length > 20) {
            this.thermalHistory.shift();
          }
        }
        handleThermalThrottling(thermalState) {
          const oldQuality = { ...this.currentQuality };
          switch (thermalState) {
            case "warm":
              this.currentQuality.animationFPS = Math.max(30, this.currentQuality.animationFPS);
              this.currentQuality.postProcessing = false;
              break;
            case "hot":
              this.currentQuality.animationFPS = 24;
              this.currentQuality.gradientComplexity *= 0.7;
              this.currentQuality.particleDensity *= 0.5;
              break;
            case "critical":
              this.currentQuality.animationFPS = 15;
              this.currentQuality.gradientComplexity = 0.2;
              this.currentQuality.particleDensity = 0.1;
              this.currentQuality.postProcessing = false;
              this.currentQuality.bloomEnabled = false;
              break;
          }
          this.emitAdaptationEvent({
            type: "thermal-throttle",
            reason: `Thermal throttling: ${thermalState}`,
            oldSettings: oldQuality,
            newSettings: { ...this.currentQuality },
            timestamp: performance.now()
          });
          Y3K?.debug?.warn("AdaptivePerformanceSystem", `Thermal throttling activated: ${thermalState}`);
        }
        adaptToConnectionSpeed(effectiveType) {
          const isSlowConnection = effectiveType === "slow-2g" || effectiveType === "2g";
          if (isSlowConnection) {
            this.currentBudget.networkBandwidthKBps = 20;
          } else if (effectiveType === "3g") {
            this.currentBudget.networkBandwidthKBps = 50;
          } else {
            this.currentBudget.networkBandwidthKBps = 100;
          }
        }
        emitAdaptationEvent(event) {
          this.eventListeners.forEach((listener) => {
            try {
              listener(event);
            } catch (error) {
              Y3K?.debug?.error("AdaptivePerformanceSystem", "Event listener error:", error);
            }
          });
        }
        // Public API
        getHardwareMetrics() {
          return { ...this.hardwareMetrics };
        }
        getCurrentProfile() {
          return { ...this.currentProfile };
        }
        getCurrentBudget() {
          return { ...this.currentBudget };
        }
        getCurrentQuality() {
          return { ...this.currentQuality };
        }
        getPerformanceHistory() {
          return [...this.performanceHistory];
        }
        addEventListener(listener) {
          this.eventListeners.push(listener);
        }
        removeEventListener(listener) {
          const index = this.eventListeners.indexOf(listener);
          if (index > -1) {
            this.eventListeners.splice(index, 1);
          }
        }
        setProfile(profile) {
          this.currentProfile = { ...this.currentProfile, ...profile };
          this.currentBudget = this.calculatePerformanceBudget();
          this.currentQuality = this.deriveQualitySettings();
        }
        setQuality(quality) {
          const oldQuality = { ...this.currentQuality };
          this.currentQuality = { ...this.currentQuality, ...quality };
          this.emitAdaptationEvent({
            type: "quality-change",
            reason: "Manual quality adjustment",
            oldSettings: oldQuality,
            newSettings: { ...this.currentQuality },
            timestamp: performance.now()
          });
        }
        forceAdaptation() {
          this.lastAdaptation = 0;
          this.checkAdaptationNeeded();
        }
        destroy() {
          if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
          }
          if (this.adaptationTimer) {
            clearTimeout(this.adaptationTimer);
            this.adaptationTimer = null;
          }
          if (this.batteryAPI) {
            this.batteryAPI.removeEventListener("chargingchange", this.updatePowerLevel);
            this.batteryAPI.removeEventListener("levelchange", this.updatePowerLevel);
          }
          this.eventListeners = [];
          this.performanceHistory = [];
          this.thermalHistory = [];
          Y3K?.debug?.log("AdaptivePerformanceSystem", "Destroyed");
        }
      };
      __name(_AdaptivePerformanceSystem, "AdaptivePerformanceSystem");
      AdaptivePerformanceSystem = _AdaptivePerformanceSystem;
    }
  });

  // src-js/visual/integration/VisualSystemFacade.ts
  var _VisualSystemFacade, VisualSystemFacade;
  var init_VisualSystemFacade = __esm({
    "src-js/visual/integration/VisualSystemFacade.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_DeviceCapabilityDetector();
      init_UnifiedSidebarConsciousnessController();
      init_ConsciousnessUIEffectsController();
      init_HeaderConsciousnessController();
      init_WebGLGradientBackgroundSystem();
      init_OrganicBeatSyncConsciousness();
      init_OrganicBreathingController();
      init_InteractionTrackingSystem();
      init_SpotifyUIApplicationSystem();
      init_GradientConductor();
      init_AdaptivePerformanceSystem();
      _VisualSystemFacade = class _VisualSystemFacade {
        constructor(config, utils, year3000System2, cssConsciousnessController, performanceAnalyzer, musicSyncService, settingsManager, colorHarmonyEngine, eventBus) {
          this.colorHarmonyEngine = null;
          this.eventBus = null;
          this.adaptivePerformanceSystem = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Event handlers
          this.boundAdaptationHandler = null;
          this.boundSettingsHandler = null;
          // Monitoring intervals
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Event callbacks
          this.onSystemAdaptation = null;
          this.onHealthChange = null;
          this.onSystemCreated = null;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System2;
          this.cssConsciousnessController = cssConsciousnessController;
          this.performanceAnalyzer = performanceAnalyzer;
          this.musicSyncService = musicSyncService;
          this.settingsManager = settingsManager;
          this.colorHarmonyEngine = colorHarmonyEngine || null;
          this.eventBus = eventBus || null;
          this.deviceDetector = new DeviceCapabilityDetector();
          this.systemRegistry = /* @__PURE__ */ new Map();
          this.systemCache = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.bridgeConfig = {
            mode: "progressive",
            enablePerformanceMonitoring: true,
            enableAdaptiveQuality: true,
            enableEventCoordination: true,
            performanceThresholds: {
              minFPS: 45,
              maxMemoryMB: 50,
              thermalLimit: 70
            },
            qualityPreferences: {
              preferHighQuality: true,
              allowDynamicScaling: true,
              batteryConservation: false
            }
          };
          this.currentMetrics = this.createInitialMetrics();
          this.boundAdaptationHandler = this.handleAdaptationEvent.bind(this);
          this.boundSettingsHandler = this.handleSettingsChange.bind(this);
          this.registerVisualSystems();
          Y3K?.debug?.log("VisualSystemFacade", "Factory facade initialized with visual systems");
        }
        registerVisualSystems() {
          this.systemRegistry.set("SidebarConsciousness", UnifiedSidebarConsciousnessController);
          this.systemDependencies.set("SidebarConsciousness", ["eventBus", "musicSyncService"]);
          this.systemRegistry.set("UIEffectsConsciousness", ConsciousnessUIEffectsController);
          this.systemDependencies.set("UIEffectsConsciousness", ["eventBus", "musicSyncService", "cssConsciousnessController"]);
          this.systemRegistry.set("HeaderConsciousness", HeaderConsciousnessController);
          this.systemDependencies.set("HeaderConsciousness", ["eventBus", "musicSyncService", "colorHarmonyEngine"]);
          this.systemRegistry.set("WebGLBackground", WebGLGradientBackgroundSystem);
          this.systemDependencies.set("WebGLBackground", ["performanceAnalyzer", "eventBus"]);
          this.systemRegistry.set("OrganicBeatSync", OrganicBeatSyncConsciousness);
          this.systemDependencies.set("OrganicBeatSync", ["performanceAnalyzer", "cssConsciousnessController", "eventBus", "musicSyncService", "colorHarmonyEngine"]);
          this.systemRegistry.set("OrganicBreathing", OrganicBreathingController);
          this.systemDependencies.set("OrganicBreathing", ["performanceAnalyzer", "cssConsciousnessController", "eventBus", "musicSyncService"]);
          this.systemRegistry.set("InteractionTracking", InteractionTrackingSystem);
          this.systemDependencies.set("InteractionTracking", ["performanceAnalyzer", "cssConsciousnessController"]);
          this.systemRegistry.set("SpotifyUIApplication", SpotifyUIApplicationSystem);
          this.systemDependencies.set("SpotifyUIApplication", ["year3000System"]);
          this.systemRegistry.set("GradientConductor", GradientConductor);
          this.systemDependencies.set("GradientConductor", ["cssConsciousnessController", "colorHarmonyEngine", "musicSyncService", "performanceAnalyzer", "eventBus"]);
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3K?.debug?.warn("VisualSystemFacade", "Already initialized");
            return;
          }
          try {
            this.bridgeConfig = { ...this.bridgeConfig, ...config };
            await this.deviceDetector.initialize();
            if (this.bridgeConfig.enablePerformanceMonitoring) {
              this.adaptivePerformanceSystem = new AdaptivePerformanceSystem(
                this.deviceDetector,
                this.performanceAnalyzer
              );
              await this.adaptivePerformanceSystem.initialize();
              this.adaptivePerformanceSystem.addEventListener(this.boundAdaptationHandler);
            }
            await this.applyConfiguration();
            this.subscribeToEvents();
            this.startMonitoring();
            await this.performVisualHealthCheck();
            this.isInitialized = true;
            this.cssConsciousnessController.queueCSSVariableUpdate("--sn-visual-bridge-active", "1");
            this.cssConsciousnessController.queueCSSVariableUpdate("--sn-visual-bridge-mode", this.bridgeConfig.mode);
            Y3K?.debug?.log("VisualSystemFacade", "Facade fully initialized", {
              mode: this.bridgeConfig.mode,
              systemsRegistered: this.systemRegistry.size,
              performanceMonitoring: this.bridgeConfig.enablePerformanceMonitoring
            });
          } catch (error) {
            Y3K?.debug?.error("VisualSystemFacade", "Initialization failed:", error);
            await this.cleanup();
            throw error;
          }
        }
        /**
         * Factory method to create and return visual systems
         * This is the main interface for the facade pattern
         */
        getVisualSystem(key) {
          if (this.systemCache.has(key)) {
            return this.systemCache.get(key);
          }
          const system = this.createVisualSystem(key);
          this.systemCache.set(key, system);
          this.currentMetrics.activeVisualSystems.push(key);
          if (this.onSystemCreated) {
            this.onSystemCreated(key, system);
          }
          return system;
        }
        /**
         * Create a new visual system instance with proper dependency injection
         */
        createVisualSystem(key) {
          const SystemClass = this.systemRegistry.get(key);
          if (!SystemClass) {
            throw new Error(`Visual system '${key}' not found in registry`);
          }
          const testInstance = new SystemClass(this.config);
          if (typeof testInstance._baseInitialize === "function") {
            const system2 = testInstance;
            this.injectUnifiedSystemDependencies(system2, key);
            return system2;
          }
          if (key === "SpotifyUIApplication") {
            const system2 = new SystemClass(this.year3000System);
            this.injectDependencies(system2, key);
            return system2;
          }
          if (key === "GradientConductor") {
            const system2 = new SystemClass(
              this.eventBus,
              this.cssConsciousnessController,
              this.colorHarmonyEngine,
              this.musicSyncService,
              this.performanceAnalyzer,
              {}
              // Default config
            );
            this.injectDependencies(system2, key);
            return system2;
          }
          const system = new SystemClass(
            this.config,
            this.utils,
            this.performanceAnalyzer,
            this.musicSyncService,
            this.settingsManager,
            this.year3000System
          );
          this.injectDependencies(system, key);
          return system;
        }
        /**
         * Inject dependencies into visual systems
         */
        injectDependencies(system, key) {
          const dependencies = this.systemDependencies.get(key) || [];
          if (dependencies.includes("performanceAnalyzer") && system.setPerformanceAnalyzer) {
            system.setPerformanceAnalyzer(this.performanceAnalyzer);
          }
          if (dependencies.includes("cssConsciousnessController") && system.setUnifiedCSSConsciousnessController) {
            system.setUnifiedCSSConsciousnessController(this.cssConsciousnessController);
          }
          if (dependencies.includes("eventBus") && this.eventBus && system.setEventBus) {
            system.setEventBus(this.eventBus);
          }
          if (this.colorHarmonyEngine && system.setColorHarmonyEngine) {
            system.setColorHarmonyEngine(this.colorHarmonyEngine);
          }
          if (dependencies.includes("musicSyncService") && system.setMusicSyncService) {
            system.setMusicSyncService(this.musicSyncService);
          }
          this.integratePerformanceMonitoring(system, key);
        }
        /**
         * Inject dependencies into UnifiedSystemBase-derived systems
         */
        injectUnifiedSystemDependencies(system, key) {
          if (this.cssConsciousnessController) {
            system.cssConsciousnessController = this.cssConsciousnessController;
          }
          if (this.performanceAnalyzer) {
            system.performanceAnalyzer = this.performanceAnalyzer;
          }
          if (this.year3000System) {
            globalThis.year3000System = this.year3000System;
          }
          if (key === "OrganicBeatSync" && system.setBreathingController) {
            const breathingController = this.getVisualSystem("OrganicBreathing");
            system.setBreathingController(breathingController);
          }
          this.integratePerformanceMonitoring(system, key);
        }
        /**
         * Integrate performance monitoring for visual systems
         */
        integratePerformanceMonitoring(system, key) {
          if (!this.bridgeConfig.enablePerformanceMonitoring) return;
          const originalUpdateAnimation = system.updateAnimation;
          if (typeof originalUpdateAnimation === "function") {
            system.updateAnimation = (deltaTime) => {
              const startTime = performance.now();
              originalUpdateAnimation.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer.recordMetric(
                `Visual_${key}`,
                endTime - startTime
              );
            };
          }
          const originalOnAnimate = system.onAnimate;
          if (typeof originalOnAnimate === "function") {
            system.onAnimate = (deltaTime) => {
              const startTime = performance.now();
              originalOnAnimate.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer.recordMetric(
                `Visual_${key}_Animate`,
                endTime - startTime
              );
            };
          }
          if (this.adaptivePerformanceSystem) {
            this.adaptiveQualityControl(system, key);
          }
        }
        /**
         * Apply adaptive quality control to visual systems
         */
        adaptiveQualityControl(system, key) {
          if (!this.eventBus) return;
          this.eventBus.subscribe("performance:degradation", (event) => {
            if (system.reduceQuality) {
              system.reduceQuality(event.reductionLevel);
            }
          });
          this.eventBus.subscribe("performance:improvement", (event) => {
            if (system.increaseQuality) {
              system.increaseQuality(event.improvementLevel);
            }
          });
        }
        /**
         * Handle adaptation events from the performance system
         */
        handleAdaptationEvent(event) {
          Y3K?.debug?.log("VisualSystemFacade", `Adaptation event: ${event.type}`, event.reason);
          this.currentMetrics.currentQuality = event.newSettings;
          this.systemCache.forEach((system, key) => {
            if (system.handleAdaptationEvent) {
              system.handleAdaptationEvent(event);
            }
          });
          if (this.onSystemAdaptation) {
            this.onSystemAdaptation(this.currentMetrics);
          }
          this.cssConsciousnessController.queueCSSVariableUpdate("--sn-adaptive-quality", event.newSettings.gradientComplexity.toString());
          this.cssConsciousnessController.queueCSSVariableUpdate("--sn-adaptive-fps", event.newSettings.animationFPS.toString());
        }
        /**
         * Propagate visual events to all systems
         */
        propagateVisualEvent(event) {
          if (!this.bridgeConfig.enableEventCoordination) return;
          this.systemCache.forEach((system, key) => {
            if (system.handleVisualEvent) {
              try {
                system.handleVisualEvent(event);
              } catch (error) {
                Y3K?.debug?.warn("VisualSystemFacade", `Error propagating event to ${key}:`, error);
              }
            }
          });
          this.currentMetrics.eventCount++;
          this.currentMetrics.lastEventTime = performance.now();
        }
        /**
         * Initialize all visual systems at once
         */
        async initializeVisualSystems() {
          const initPromises = Array.from(this.systemCache.entries()).map(async ([key, system]) => {
            try {
              if (typeof system._baseInitialize === "function") {
                await system._baseInitialize();
              } else {
                await system.initialize();
              }
              Y3K?.debug?.log("VisualSystemFacade", `Initialized visual system: ${key}`);
              return { key, success: true };
            } catch (error) {
              Y3K?.debug?.error("VisualSystemFacade", `Failed to initialize ${key}:`, error);
              return { key, success: false, error };
            }
          });
          const results = await Promise.allSettled(initPromises);
          const successCount = results.filter((r) => r.status === "fulfilled" && r.value.success).length;
          Y3K?.debug?.log("VisualSystemFacade", `Visual systems initialized: ${successCount}/${results.length}`);
          await this.registerQualityScalingSystems();
        }
        /**
         * Register QualityScalingCapable systems with PerformanceOrchestrator
         */
        async registerQualityScalingSystems() {
          try {
            const performanceOrchestrator = this.year3000System?.getCachedNonVisualSystem?.("PerformanceOrchestrator");
            const qualityScalingManager = this.year3000System?.getCachedNonVisualSystem?.("QualityScalingManager");
            if (!performanceOrchestrator) {
              Y3K?.debug?.warn("VisualSystemFacade", "PerformanceOrchestrator not available for quality scaling registration");
              return;
            }
            if (!qualityScalingManager) {
              Y3K?.debug?.warn("VisualSystemFacade", "QualityScalingManager not available for quality scaling registration");
              return;
            }
            for (const [key, system] of this.systemCache.entries()) {
              try {
                const qualityScalingSystem = system;
                if (typeof qualityScalingSystem.setQualityLevel === "function" && typeof qualityScalingSystem.getPerformanceImpact === "function" && typeof qualityScalingSystem.getQualityCapabilities === "function") {
                  performanceOrchestrator.registerSystem(key, qualityScalingSystem);
                  qualityScalingManager.registerSystem(key, qualityScalingSystem);
                  Y3K?.debug?.log("VisualSystemFacade", `Registered ${key} for quality scaling and performance orchestration`);
                }
              } catch (error) {
                Y3K?.debug?.error("VisualSystemFacade", `Failed to register ${key} for quality scaling:`, error);
              }
            }
            await this.initializeConsciousnessAwareAdaptation(qualityScalingManager);
          } catch (error) {
            Y3K?.debug?.error("VisualSystemFacade", "Failed to register quality scaling systems:", error);
          }
        }
        /**
         * Initialize consciousness-aware quality adaptation with music sync integration
         */
        async initializeConsciousnessAwareAdaptation(qualityScalingManager) {
          try {
            const musicSyncService = this.year3000System?.getCachedNonVisualSystem?.("MusicSyncService");
            if (!musicSyncService) {
              Y3K?.debug?.warn("VisualSystemFacade", "MusicSyncService not available for consciousness-aware adaptation");
              return;
            }
            const adaptationInterval = setInterval(() => {
              try {
                const consciousnessIntensity = musicSyncService.getOverallIntensity?.() || 0.5;
                const musicEnergy = musicSyncService.getBeatStrength?.() || 0.5;
                qualityScalingManager.adaptToConsciousnessState(consciousnessIntensity, musicEnergy);
              } catch (error) {
                Y3K?.debug?.error("VisualSystemFacade", "Error in consciousness-aware adaptation:", error);
              }
            }, 2e3);
            this._consciousnessAdaptationInterval = adaptationInterval;
            Y3K?.debug?.log("VisualSystemFacade", "Consciousness-aware quality adaptation initialized");
          } catch (error) {
            Y3K?.debug?.error("VisualSystemFacade", "Failed to initialize consciousness-aware adaptation:", error);
          }
        }
        /**
         * Perform health check on all visual systems
         */
        async performVisualHealthCheck() {
          const healthCheck = {
            overall: "good",
            systems: /* @__PURE__ */ new Map(),
            recommendations: [],
            timestamp: performance.now()
          };
          let healthyCount = 0;
          let totalCount = 0;
          for (const [key, system] of this.systemCache) {
            totalCount++;
            try {
              const systemHealth = system.healthCheck ? await system.healthCheck() : { status: "unknown", message: "No health check available" };
              const isHealthy = systemHealth.status === "healthy" || systemHealth.status === "good";
              if (isHealthy) healthyCount++;
              healthCheck.systems.set(key, {
                ok: isHealthy,
                details: systemHealth.message || systemHealth.details || "System operational"
              });
            } catch (error) {
              healthCheck.systems.set(key, {
                ok: false,
                details: `Health check failed: ${error}`
              });
            }
          }
          const healthPercentage = totalCount > 0 ? healthyCount / totalCount : 1;
          if (healthPercentage >= 0.9) {
            healthCheck.overall = "excellent";
          } else if (healthPercentage >= 0.7) {
            healthCheck.overall = "good";
          } else if (healthPercentage >= 0.5) {
            healthCheck.overall = "degraded";
            healthCheck.recommendations.push("Some visual systems are experiencing issues");
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push("Multiple visual system failures detected");
          }
          if (this.currentMetrics.currentFPS < 30) {
            healthCheck.recommendations.push("Low FPS detected - consider reducing visual quality");
          }
          if (this.currentMetrics.memoryUsageMB > 40) {
            healthCheck.recommendations.push("High memory usage - consider optimizing visual systems");
          }
          this.lastHealthCheck = healthCheck;
          this.cssConsciousnessController.queueCSSVariableUpdate("--sn-visual-health", healthCheck.overall);
          return healthCheck;
        }
        // Utility methods
        createInitialMetrics() {
          return {
            currentFPS: 0,
            averageFPS: 0,
            frameTime: 0,
            memoryUsageMB: 0,
            systemHealth: "good",
            activeVisualSystems: [],
            currentQuality: {
              gradientComplexity: 0.6,
              particleDensity: 0.6,
              shaderPrecision: "mediump",
              textureResolution: 1,
              animationFPS: 60,
              transitionQuality: "smooth",
              motionBlur: false,
              bloomEnabled: true,
              shadowQuality: "medium",
              antiAliasing: "fxaa",
              postProcessing: true
            },
            adaptiveScaling: true,
            performanceMonitoring: true,
            eventCoordination: true,
            lastEventTime: 0,
            eventCount: 0
          };
        }
        async applyConfiguration() {
          if (this.adaptivePerformanceSystem) {
            const profile = this.adaptivePerformanceSystem.getCurrentProfile();
            profile.targetFPS = this.bridgeConfig.performanceThresholds.minFPS;
            profile.memoryBudgetMB = this.bridgeConfig.performanceThresholds.maxMemoryMB;
            profile.adaptiveScaling = this.bridgeConfig.enableAdaptiveQuality;
            this.adaptivePerformanceSystem.setProfile(profile);
          }
        }
        subscribeToEvents() {
          if (this.settingsManager && this.boundSettingsHandler) {
            document.addEventListener("year3000SystemSettingsChanged", this.boundSettingsHandler);
          }
        }
        startMonitoring() {
          if (this.bridgeConfig.enablePerformanceMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performVisualHealthCheck();
            }, 1e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 1e3);
          }
        }
        updateMetrics() {
          this.currentMetrics.currentFPS = this.performanceAnalyzer.getMedianFPS() || 0;
          this.currentMetrics.frameTime = this.currentMetrics.currentFPS > 0 ? 1e3 / this.currentMetrics.currentFPS : 1e3;
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.memoryUsageMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          if (this.currentMetrics.currentFPS < 20) {
            this.currentMetrics.systemHealth = "critical";
          } else if (this.currentMetrics.currentFPS < 30) {
            this.currentMetrics.systemHealth = "degraded";
          } else if (this.currentMetrics.currentFPS > 55) {
            this.currentMetrics.systemHealth = "excellent";
          } else {
            this.currentMetrics.systemHealth = "good";
          }
        }
        handleSettingsChange(event) {
          const customEvent = event;
          const { key, value } = customEvent.detail;
          if (key.startsWith("sn-visual-")) {
            this.updateConfigurationFromSettings(key, value);
          }
        }
        updateConfigurationFromSettings(key, value) {
          switch (key) {
            case "sn-visual-quality":
              this.bridgeConfig.qualityPreferences.preferHighQuality = value === "high";
              break;
            case "sn-visual-performance":
              this.bridgeConfig.enableAdaptiveQuality = value === "adaptive";
              break;
          }
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          if (this._consciousnessAdaptationInterval) {
            clearInterval(this._consciousnessAdaptationInterval);
            this._consciousnessAdaptationInterval = null;
          }
          if (this.boundSettingsHandler) {
            document.removeEventListener("year3000SystemSettingsChanged", this.boundSettingsHandler);
          }
          if (this.adaptivePerformanceSystem) {
            this.adaptivePerformanceSystem.removeEventListener(this.boundAdaptationHandler);
            this.adaptivePerformanceSystem.destroy();
            this.adaptivePerformanceSystem = null;
          }
          this.cssConsciousnessController.queueCSSVariableUpdate("--sn-visual-bridge-active", "0");
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.bridgeConfig };
        }
        async setConfiguration(config) {
          this.bridgeConfig = { ...this.bridgeConfig, ...config };
          await this.applyConfiguration();
        }
        setOnSystemAdaptation(callback) {
          this.onSystemAdaptation = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            systemsActive: this.systemCache.size,
            healthy: this.currentMetrics.systemHealth === "excellent" || this.currentMetrics.systemHealth === "good"
          };
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          this.systemCache.clear();
          Y3K?.debug?.log("VisualSystemFacade", "Facade destroyed");
        }
      };
      __name(_VisualSystemFacade, "VisualSystemFacade");
      VisualSystemFacade = _VisualSystemFacade;
    }
  });

  // src-js/core/integration/SystemCoordinator.ts
  var _SystemCoordinator, SystemCoordinator;
  var init_SystemCoordinator = __esm({
    "src-js/core/integration/SystemCoordinator.ts"() {
      "use strict";
      init_ColorHarmonyEngine();
      init_MusicSyncService();
      init_UnifiedCSSConsciousnessController();
      init_NonVisualSystemFacade();
      init_PerformanceAnalyzer();
      init_UnifiedPerformanceCoordinator();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_SemanticColorManager();
      init_VisualSystemFacade();
      _SystemCoordinator = class _SystemCoordinator {
        constructor(config, utils, year3000System2) {
          // Facade instances
          this.visualBridge = null;
          this.nonVisualFacade = null;
          // Shared dependencies (centrally managed)
          this.sharedUnifiedCSSConsciousnessController = null;
          this.sharedUnifiedPerformanceCoordinator = null;
          this.sharedPerformanceAnalyzer = null;
          this.sharedMusicSyncService = null;
          this.sharedSettingsManager = null;
          this.sharedColorHarmonyEngine = null;
          this.sharedSemanticColorManager = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Color system coordination
          this.colorDependentSystems = /* @__PURE__ */ new Set();
          this.colorSystemRefreshCallbacks = /* @__PURE__ */ new Map();
          // Orchestration state
          this.currentPhase = "core";
          this.systemStates = /* @__PURE__ */ new Map();
          this.phaseCompletionPromises = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.initializationOrder = /* @__PURE__ */ new Map();
          // Event coordination
          this.eventBus = null;
          this.crossFacadeEventListeners = /* @__PURE__ */ new Map();
          // Monitoring
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Event callbacks
          this.onSystemCreated = null;
          this.onHealthChange = null;
          this.onPerformanceChange = null;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System2;
          this.coordinationConfig = {
            mode: "unified",
            enableSharedDependencies: true,
            enableCrossFacadeCommunication: true,
            enableUnifiedPerformanceMonitoring: true,
            enableResourceOptimization: true,
            orchestration: {
              enforceSequentialInitialization: true,
              dependencyValidation: true,
              enableInitializationGates: true,
              systemReadinessTimeout: 5e3,
              phaseTransitionTimeout: 1e4
            },
            performanceThresholds: {
              maxTotalMemoryMB: 150,
              maxTotalInitTime: 8e3,
              maxCrossCommLatency: 10
            },
            coordinationPreferences: {
              preferSharedResources: true,
              enableEventPropagation: true,
              enableHealthCoordination: true
            }
          };
          this.setupOrchestrationPhases();
          this.currentMetrics = this.createInitialMetrics();
          Y3K?.debug?.log("SystemCoordinator", "System coordinator initialized");
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3K?.debug?.warn("SystemCoordinator", "Already initialized");
            return;
          }
          try {
            const startTime = performance.now();
            this.coordinationConfig = { ...this.coordinationConfig, ...config };
            if (this.coordinationConfig.orchestration.enforceSequentialInitialization) {
              Y3K?.debug?.log("SystemCoordinator", "Starting orchestrated initialization");
              await this.executeOrchestredInitialization();
            } else {
              Y3K?.debug?.log("SystemCoordinator", "Starting legacy initialization");
              await this.executeLegacyInitialization();
            }
            const endTime = performance.now();
            this.currentMetrics.totalInitTime = endTime - startTime;
            this.isInitialized = true;
            Y3K?.debug?.log(
              "SystemCoordinator",
              "System coordination fully initialized",
              {
                mode: this.coordinationConfig.mode,
                orchestrationEnabled: this.coordinationConfig.orchestration.enforceSequentialInitialization,
                currentPhase: this.currentPhase,
                visualSystems: this.currentMetrics.visualSystems,
                nonVisualSystems: this.currentMetrics.nonVisualSystems,
                initTime: this.currentMetrics.totalInitTime
              }
            );
          } catch (error) {
            Y3K?.debug?.error("SystemCoordinator", "Initialization failed:", error);
            await this.cleanup();
            throw error;
          }
        }
        async initializeSharedDependencies() {
          if (!this.coordinationConfig.enableSharedDependencies) return;
          Y3K?.debug?.log("SystemCoordinator", "Initializing shared dependencies");
          try {
            this.sharedPerformanceAnalyzer = new PerformanceAnalyzer();
            this.sharedUnifiedPerformanceCoordinator = new UnifiedPerformanceCoordinator(
              this.config,
              this.sharedPerformanceAnalyzer
            );
            try {
              this.sharedUnifiedCSSConsciousnessController = UnifiedCSSConsciousnessController.getInstance(
                this.config,
                this.sharedUnifiedPerformanceCoordinator
              );
              if (this.sharedUnifiedCSSConsciousnessController) {
                await this.sharedUnifiedCSSConsciousnessController.initialize();
              }
            } catch (error) {
              Y3K?.debug?.warn(
                "SystemCoordinator",
                "Failed to initialize UnifiedCSSConsciousnessController:",
                error
              );
              this.sharedUnifiedCSSConsciousnessController = null;
            }
            this.sharedSettingsManager = new SettingsManager();
            await this.sharedSettingsManager.initialize();
            this.sharedMusicSyncService = new MusicSyncService();
            await this.sharedMusicSyncService.initialize();
            this.sharedColorHarmonyEngine = new ColorHarmonyEngine();
            await this.sharedColorHarmonyEngine.initialize();
            Y3K?.debug?.log(
              "SystemCoordinator",
              "Shared dependencies initialized successfully"
            );
          } catch (error) {
            Y3K?.debug?.error(
              "SystemCoordinator",
              "Failed to initialize shared dependencies:",
              error
            );
            throw error;
          }
        }
        async initializeFacades() {
          Y3K?.debug?.log("SystemCoordinator", "Initializing facades");
          try {
            this.visualBridge = new VisualSystemFacade(
              this.config,
              this.utils,
              this.year3000System,
              this.sharedUnifiedCSSConsciousnessController,
              this.sharedPerformanceAnalyzer,
              this.sharedMusicSyncService,
              this.sharedSettingsManager,
              this.sharedColorHarmonyEngine,
              this.eventBus
            );
            await this.visualBridge.initialize({
              mode: this.coordinationConfig.mode === "performance-optimized" ? "performance-first" : "progressive",
              enablePerformanceMonitoring: this.coordinationConfig.enableUnifiedPerformanceMonitoring,
              enableEventCoordination: this.coordinationConfig.enableCrossFacadeCommunication
            });
            this.visualBridge.setOnSystemCreated((key, system) => {
              this.handleSystemCreated("visual", key, system);
            });
            this.nonVisualFacade = new NonVisualSystemFacade(
              this.config,
              this.utils,
              this.year3000System
            );
            await this.nonVisualFacade.initialize({
              mode: this.coordinationConfig.mode === "performance-optimized" ? "performance-first" : "progressive",
              enablePerformanceMonitoring: this.coordinationConfig.enableUnifiedPerformanceMonitoring,
              enableDependencyInjection: this.coordinationConfig.enableSharedDependencies
            });
            this.nonVisualFacade.setOnSystemCreated((key, system) => {
              this.handleSystemCreated("non-visual", key, system);
            });
            this.injectSharedDependencies();
            Y3K?.debug?.log("SystemCoordinator", "Facades initialized successfully");
          } catch (error) {
            Y3K?.debug?.error(
              "SystemCoordinator",
              "Failed to initialize facades:",
              error
            );
            throw error;
          }
        }
        injectSharedDependencies() {
          if (!this.coordinationConfig.enableSharedDependencies || !this.nonVisualFacade)
            return;
          if (this.sharedPerformanceAnalyzer) {
            this.nonVisualFacade.performanceAnalyzer = this.sharedPerformanceAnalyzer;
          }
          if (this.sharedUnifiedCSSConsciousnessController) {
            this.nonVisualFacade.cssConsciousnessController = this.sharedUnifiedCSSConsciousnessController;
          }
          if (this.sharedMusicSyncService) {
            this.nonVisualFacade.musicSyncService = this.sharedMusicSyncService;
          }
          if (this.sharedSettingsManager) {
            this.nonVisualFacade.settingsManager = this.sharedSettingsManager;
          }
          if (this.sharedColorHarmonyEngine) {
            this.nonVisualFacade.colorHarmonyEngine = this.sharedColorHarmonyEngine;
          }
          if (this.sharedSemanticColorManager) {
            this.nonVisualFacade.semanticColorManager = this.sharedSemanticColorManager;
          }
        }
        setupCrossFacadeCommunication() {
          if (!this.coordinationConfig.enableCrossFacadeCommunication) return;
          Y3K?.debug?.log(
            "SystemCoordinator",
            "Setting up cross-facade communication"
          );
          this.addEventListener("visual-event", (event) => {
            if (this.visualBridge) {
              this.visualBridge.propagateVisualEvent(event);
            }
          });
          this.addEventListener("performance-event", (event) => {
            if (this.visualBridge) {
              this.visualBridge.handleAdaptationEvent(event);
            }
          });
          if (this.coordinationConfig.coordinationPreferences.enableHealthCoordination) {
            this.addEventListener("health-degradation", (event) => {
              this.handleHealthDegradation(event);
            });
          }
        }
        handleSystemCreated(type, key, system) {
          if (type === "visual") {
            this.currentMetrics.visualSystems++;
          } else {
            this.currentMetrics.nonVisualSystems++;
          }
          this.currentMetrics.activeSystems++;
          if (this.onSystemCreated) {
            this.onSystemCreated(type, key, system);
          }
          Y3K?.debug?.log("SystemCoordinator", `System created: ${type}/${key}`);
        }
        handleHealthDegradation(event) {
          Y3K?.debug?.warn(
            "SystemCoordinator",
            "Health degradation detected:",
            event
          );
          if (this.coordinationConfig.mode === "performance-optimized") {
            this.optimizeForPerformance();
          }
        }
        optimizeForPerformance() {
          if (this.visualBridge) {
            this.visualBridge.setConfiguration({
              mode: "performance-first",
              enableAdaptiveQuality: true,
              qualityPreferences: {
                preferHighQuality: false,
                allowDynamicScaling: true,
                batteryConservation: true
              }
            });
          }
          if (this.nonVisualFacade) {
            this.nonVisualFacade.setConfiguration({
              mode: "performance-first",
              systemPreferences: {
                lazyInitialization: true,
                aggressiveCaching: true,
                performanceOptimization: true
              }
            });
          }
        }
        // Public API for facade access
        getVisualSystem(key) {
          if (!this.visualBridge) return null;
          return this.visualBridge.getVisualSystem(key);
        }
        getCachedNonVisualSystem(key) {
          if (!this.nonVisualFacade) return null;
          return this.nonVisualFacade.getCachedSystem(key);
        }
        async getNonVisualSystem(key) {
          if (!this.nonVisualFacade) return null;
          return await this.nonVisualFacade.getSystem(key);
        }
        async getSystem(key) {
          if (this.visualBridge) {
            try {
              return this.visualBridge.getVisualSystem(key);
            } catch (error) {
            }
          }
          if (this.nonVisualFacade) {
            try {
              return await this.nonVisualFacade.getSystem(
                key
              );
            } catch (error) {
            }
          }
          return null;
        }
        // Cross-facade event system
        addEventListener(eventType, listener) {
          if (!this.crossFacadeEventListeners.has(eventType)) {
            this.crossFacadeEventListeners.set(eventType, []);
          }
          this.crossFacadeEventListeners.get(eventType).push(listener);
        }
        removeEventListener(eventType, listener) {
          const listeners = this.crossFacadeEventListeners.get(eventType);
          if (listeners) {
            const index = listeners.indexOf(listener);
            if (index !== -1) {
              listeners.splice(index, 1);
            }
          }
        }
        emitEvent(eventType, event) {
          const listeners = this.crossFacadeEventListeners.get(eventType);
          if (listeners) {
            listeners.forEach((listener) => {
              try {
                listener(event);
              } catch (error) {
                Y3K?.debug?.error(
                  "SystemCoordinator",
                  `Error in event listener for ${eventType}:`,
                  error
                );
              }
            });
          }
          this.currentMetrics.crossFacadeEvents++;
        }
        // Health monitoring
        async performHealthCheck() {
          const healthCheck = {
            overall: "good",
            facades: {
              visual: {
                ok: true,
                details: "Visual systems operational",
                systemCount: 0
              },
              nonVisual: {
                ok: true,
                details: "Non-visual systems operational",
                systemCount: 0
              }
            },
            sharedResources: {
              performanceAnalyzer: {
                ok: true,
                details: "Performance analyzer operational"
              },
              cssConsciousnessController: {
                ok: true,
                details: "CSS variable batcher operational"
              },
              musicSyncService: {
                ok: true,
                details: "Music sync service operational"
              }
            },
            recommendations: [],
            timestamp: performance.now()
          };
          if (this.visualBridge) {
            try {
              const visualHealth = await this.visualBridge.performVisualHealthCheck();
              healthCheck.facades.visual.ok = visualHealth.overall === "excellent" || visualHealth.overall === "good";
              healthCheck.facades.visual.details = `Visual systems: ${visualHealth.overall}`;
              healthCheck.facades.visual.systemCount = visualHealth.systems.size;
            } catch (error) {
              healthCheck.facades.visual.ok = false;
              healthCheck.facades.visual.details = `Visual facade error: ${error}`;
            }
          }
          if (this.nonVisualFacade) {
            try {
              const nonVisualHealth = await this.nonVisualFacade.performHealthCheck();
              healthCheck.facades.nonVisual.ok = nonVisualHealth.overall === "excellent" || nonVisualHealth.overall === "good";
              healthCheck.facades.nonVisual.details = `Non-visual systems: ${nonVisualHealth.overall}`;
              healthCheck.facades.nonVisual.systemCount = nonVisualHealth.systems.size;
            } catch (error) {
              healthCheck.facades.nonVisual.ok = false;
              healthCheck.facades.nonVisual.details = `Non-visual facade error: ${error}`;
            }
          }
          if (this.sharedPerformanceAnalyzer) {
            try {
              healthCheck.sharedResources.performanceAnalyzer.ok = true;
              healthCheck.sharedResources.performanceAnalyzer.details = "Performance analyzer operational";
            } catch (error) {
              healthCheck.sharedResources.performanceAnalyzer.ok = false;
              healthCheck.sharedResources.performanceAnalyzer.details = `Performance analyzer error: ${error}`;
            }
          }
          if (this.sharedUnifiedCSSConsciousnessController) {
            try {
              const cssHealth = await this.sharedUnifiedCSSConsciousnessController.healthCheck();
              healthCheck.sharedResources.cssConsciousnessController.ok = cssHealth.healthy || cssHealth.ok || false;
              healthCheck.sharedResources.cssConsciousnessController.details = cssHealth.details || "CSS consciousness controller operational";
            } catch (error) {
              healthCheck.sharedResources.cssConsciousnessController.ok = false;
              healthCheck.sharedResources.cssConsciousnessController.details = `CSS consciousness controller error: ${error}`;
            }
          }
          if (this.sharedMusicSyncService) {
            try {
              const musicHealth = await this.sharedMusicSyncService.healthCheck();
              healthCheck.sharedResources.musicSyncService.ok = musicHealth.status === "healthy";
              healthCheck.sharedResources.musicSyncService.details = musicHealth.message || "Music sync service operational";
            } catch (error) {
              healthCheck.sharedResources.musicSyncService.ok = false;
              healthCheck.sharedResources.musicSyncService.details = `Music sync service error: ${error}`;
            }
          }
          if (this.sharedSemanticColorManager) {
            try {
              const semanticColorHealth = await this.sharedSemanticColorManager.healthCheck();
              const semanticColorOk = semanticColorHealth.healthy;
              healthCheck.sharedResources.semanticColorManager = {
                ok: semanticColorOk,
                details: semanticColorHealth.details || "Semantic color manager operational"
              };
            } catch (error) {
              healthCheck.sharedResources.semanticColorManager = {
                ok: false,
                details: `Semantic color manager error: ${error}`
              };
            }
          }
          const facadeHealthy = healthCheck.facades.visual.ok && healthCheck.facades.nonVisual.ok;
          const resourcesHealthy = healthCheck.sharedResources.performanceAnalyzer.ok && healthCheck.sharedResources.cssConsciousnessController.ok && healthCheck.sharedResources.musicSyncService.ok && healthCheck.sharedResources.semanticColorManager?.ok !== false;
          if (facadeHealthy && resourcesHealthy) {
            healthCheck.overall = "excellent";
          } else if (facadeHealthy || resourcesHealthy) {
            healthCheck.overall = "good";
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push(
              "Multiple system failures detected - consider system restart"
            );
          }
          if (this.currentMetrics.totalMemoryMB > 120) {
            healthCheck.recommendations.push(
              "High memory usage - consider optimizing system memory"
            );
          }
          if (this.currentMetrics.totalInitTime > 6e3) {
            healthCheck.recommendations.push(
              "High initialization time - consider optimizing system startup"
            );
          }
          this.lastHealthCheck = healthCheck;
          if (this.onHealthChange) {
            this.onHealthChange(healthCheck);
          }
          return healthCheck;
        }
        // Utility methods
        createInitialMetrics() {
          return {
            totalSystems: 0,
            visualSystems: 0,
            nonVisualSystems: 0,
            activeSystems: 0,
            failedSystems: 0,
            totalMemoryMB: 0,
            totalInitTime: 0,
            averageSystemInitTime: 0,
            crossFacadeLatency: 0,
            overallHealth: "good",
            visualHealth: "good",
            nonVisualHealth: "good",
            sharedDependencies: 6,
            // Number of shared dependencies
            crossFacadeEvents: 0,
            resourceOptimization: 0
          };
        }
        startMonitoring() {
          if (this.coordinationConfig.enableUnifiedPerformanceMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performHealthCheck();
            }, 2e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 2e3);
          }
        }
        updateMetrics() {
          if (this.visualBridge) {
            const visualMetrics = this.visualBridge.getMetrics();
            this.currentMetrics.visualHealth = visualMetrics.systemHealth;
          }
          if (this.nonVisualFacade) {
            const nonVisualMetrics = this.nonVisualFacade.getMetrics();
            this.currentMetrics.nonVisualHealth = nonVisualMetrics.systemHealth;
          }
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.totalMemoryMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          if (this.currentMetrics.visualHealth === "excellent" && this.currentMetrics.nonVisualHealth === "excellent") {
            this.currentMetrics.overallHealth = "excellent";
          } else if (this.currentMetrics.visualHealth === "critical" || this.currentMetrics.nonVisualHealth === "critical") {
            this.currentMetrics.overallHealth = "critical";
          } else if (this.currentMetrics.visualHealth === "degraded" || this.currentMetrics.nonVisualHealth === "degraded") {
            this.currentMetrics.overallHealth = "degraded";
          } else {
            this.currentMetrics.overallHealth = "good";
          }
          if (this.onPerformanceChange) {
            this.onPerformanceChange(this.currentMetrics);
          }
        }
        // ============================================================================
        // Orchestration Methods - Enhanced Coordination Logic
        // ============================================================================
        setupOrchestrationPhases() {
          this.systemDependencies.set("MusicSyncService", []);
          this.systemDependencies.set("ColorHarmonyEngine", ["MusicSyncService", "SemanticColorManager"]);
          this.systemDependencies.set("PerformanceAnalyzer", []);
          this.systemDependencies.set("UnifiedCSSConsciousnessController", ["PerformanceAnalyzer"]);
          this.systemDependencies.set("SettingsManager", []);
          this.systemDependencies.set("SemanticColorManager", ["UnifiedCSSConsciousnessController"]);
          this.initializationOrder.set("core", [
            "PerformanceAnalyzer",
            "UnifiedCSSConsciousnessController"
          ]);
          this.initializationOrder.set("services", [
            "SettingsManager",
            "MusicSyncService",
            "SemanticColorManager"
          ]);
          this.initializationOrder.set("visual-systems", [
            "ColorHarmonyEngine"
          ]);
          this.initializationOrder.set("integration", [
            "VisualSystemFacade",
            "NonVisualSystemFacade"
          ]);
          for (const [phase, systems] of this.initializationOrder.entries()) {
            for (const system of systems) {
              this.systemStates.set(system, "uninitialized");
            }
          }
          Y3K?.debug?.log("SystemCoordinator", "Orchestration phases configured", {
            phases: Array.from(this.initializationOrder.keys()),
            totalSystems: this.systemStates.size,
            dependencies: Object.fromEntries(this.systemDependencies)
          });
        }
        async executeOrchestredInitialization() {
          const phases = ["core", "services", "visual-systems", "integration"];
          for (const phase of phases) {
            Y3K?.debug?.log("SystemCoordinator", `Starting phase: ${phase}`);
            this.currentPhase = phase;
            try {
              await this.executePhase(phase);
              Y3K?.debug?.log("SystemCoordinator", `Phase ${phase} completed successfully`);
            } catch (error) {
              Y3K?.debug?.error("SystemCoordinator", `Phase ${phase} failed:`, error);
              throw new Error(`Orchestration failed at phase ${phase}: ${error}`);
            }
          }
          this.currentPhase = "completed";
          this.setupCrossFacadeCommunication();
          await this.setupGradientSystemCoordination();
          this.setupDefaultColorDependentSystems();
          this.startMonitoring();
          await this.performHealthCheck();
        }
        async executePhase(phase) {
          const systems = this.initializationOrder.get(phase);
          if (!systems) {
            throw new Error(`Unknown phase: ${phase}`);
          }
          const initPromises = [];
          for (const systemName of systems) {
            initPromises.push(this.initializeSystemWithDependencies(systemName));
          }
          await Promise.all(initPromises);
          for (const systemName of systems) {
            const state = this.systemStates.get(systemName);
            if (state !== "ready") {
              throw new Error(`System ${systemName} not ready after phase ${phase} (state: ${state})`);
            }
          }
        }
        async initializeSystemWithDependencies(systemName) {
          if (this.systemStates.get(systemName) === "ready") {
            return;
          }
          this.systemStates.set(systemName, "initializing");
          try {
            const dependencies = this.systemDependencies.get(systemName) || [];
            for (const dependency of dependencies) {
              await this.waitForSystemReady(dependency);
            }
            switch (systemName) {
              case "PerformanceAnalyzer":
                await this.initializePerformanceAnalyzer();
                break;
              case "UnifiedCSSConsciousnessController":
                await this.initializeUnifiedCSSController();
                break;
              case "SettingsManager":
                await this.initializeSettingsManager();
                break;
              case "MusicSyncService":
                await this.initializeMusicSyncService();
                break;
              case "ColorHarmonyEngine":
                await this.initializeColorHarmonyEngine();
                break;
              case "SemanticColorManager":
                await this.initializeSemanticColorManager();
                break;
              case "VisualSystemFacade":
                await this.initializeVisualFacade();
                break;
              case "NonVisualSystemFacade":
                await this.initializeNonVisualFacade();
                break;
              default:
                throw new Error(`Unknown system: ${systemName}`);
            }
            this.systemStates.set(systemName, "ready");
            Y3K?.debug?.log("SystemCoordinator", `System ${systemName} initialized successfully`);
          } catch (error) {
            this.systemStates.set(systemName, "failed");
            Y3K?.debug?.error("SystemCoordinator", `System ${systemName} initialization failed:`, error);
            throw error;
          }
        }
        async waitForSystemReady(systemName) {
          const timeout = this.coordinationConfig.orchestration.systemReadinessTimeout;
          const startTime = Date.now();
          while (Date.now() - startTime < timeout) {
            const state = this.systemStates.get(systemName);
            if (state === "ready") {
              return;
            }
            if (state === "failed") {
              throw new Error(`Dependency ${systemName} failed to initialize`);
            }
            await new Promise((resolve) => setTimeout(resolve, 50));
          }
          throw new Error(`Timeout waiting for dependency ${systemName} to be ready`);
        }
        // Individual system initialization methods
        async initializePerformanceAnalyzer() {
          this.sharedPerformanceAnalyzer = new PerformanceAnalyzer();
        }
        async initializeUnifiedCSSController() {
          if (!this.sharedPerformanceAnalyzer) {
            throw new Error("PerformanceAnalyzer dependency not available");
          }
          try {
            this.sharedUnifiedPerformanceCoordinator = new UnifiedPerformanceCoordinator(
              this.config,
              this.sharedPerformanceAnalyzer
            );
            this.sharedUnifiedCSSConsciousnessController = UnifiedCSSConsciousnessController.getInstance(
              this.config,
              this.sharedUnifiedPerformanceCoordinator
            );
            if (this.sharedUnifiedCSSConsciousnessController) {
              await this.sharedUnifiedCSSConsciousnessController.initialize();
            }
          } catch (error) {
            Y3K?.debug?.warn("SystemCoordinator", "Failed to initialize UnifiedCSSController:", error);
            this.sharedUnifiedCSSConsciousnessController = null;
          }
        }
        async initializeSettingsManager() {
          this.sharedSettingsManager = new SettingsManager();
          await this.sharedSettingsManager.initialize();
        }
        async initializeMusicSyncService() {
          this.sharedMusicSyncService = new MusicSyncService({
            YEAR3000_CONFIG: this.config,
            Year3000Utilities: this.utils,
            performanceMonitor: this.sharedPerformanceAnalyzer,
            settingsManager: this.sharedSettingsManager,
            year3000System: this.year3000System
          });
          await this.sharedMusicSyncService.initialize();
        }
        async initializeSemanticColorManager() {
          if (!this.sharedUnifiedCSSConsciousnessController) {
            throw new Error("UnifiedCSSConsciousnessController dependency not available");
          }
          this.sharedSemanticColorManager = new SemanticColorManager({
            enableDebug: this.config.enableDebug || false,
            fallbackToSpiceColors: true,
            cacheDuration: 5e3
          });
          await this.sharedSemanticColorManager.initialize(this.sharedUnifiedCSSConsciousnessController);
          Y3K?.debug?.log("SystemCoordinator", "SemanticColorManager initialized successfully", {
            systemMetrics: this.sharedSemanticColorManager.getSystemMetrics()
          });
        }
        async initializeColorHarmonyEngine() {
          if (!this.sharedMusicSyncService) {
            throw new Error("MusicSyncService dependency not available");
          }
          if (!this.sharedSemanticColorManager) {
            throw new Error("SemanticColorManager dependency not available");
          }
          this.sharedColorHarmonyEngine = new ColorHarmonyEngine(
            this.config,
            this.utils,
            this.sharedPerformanceAnalyzer || void 0,
            this.sharedSettingsManager || void 0
          );
          await this.sharedColorHarmonyEngine.initialize();
        }
        async initializeVisualFacade() {
          this.visualBridge = new VisualSystemFacade(
            this.config,
            this.utils,
            this,
            // year3000System
            this.sharedUnifiedCSSConsciousnessController,
            // cssConsciousnessController
            this.sharedPerformanceAnalyzer,
            this.sharedMusicSyncService,
            this.sharedSettingsManager,
            this.sharedColorHarmonyEngine || void 0,
            // optional
            this.eventBus
            // optional
          );
          await this.visualBridge.initialize();
        }
        async initializeNonVisualFacade() {
          this.nonVisualFacade = new NonVisualSystemFacade(
            this.config,
            this.utils,
            {
              performanceAnalyzer: this.sharedPerformanceAnalyzer,
              unifiedCSSConsciousnessController: this.sharedUnifiedCSSConsciousnessController,
              musicSyncService: this.sharedMusicSyncService,
              settingsManager: this.sharedSettingsManager,
              colorHarmonyEngine: this.sharedColorHarmonyEngine,
              unifiedPerformanceCoordinator: this.sharedUnifiedPerformanceCoordinator,
              semanticColorManager: this.sharedSemanticColorManager
            }
          );
          await this.nonVisualFacade.initialize();
        }
        async executeLegacyInitialization() {
          await this.initializeSharedDependencies();
          await this.initializeFacades();
          this.setupCrossFacadeCommunication();
          await this.setupGradientSystemCoordination();
          this.setupDefaultColorDependentSystems();
          this.startMonitoring();
          await this.performHealthCheck();
        }
        // Public orchestration API
        getCurrentPhase() {
          return this.currentPhase;
        }
        getSystemState(systemName) {
          return this.systemStates.get(systemName);
        }
        getAllSystemStates() {
          return new Map(this.systemStates);
        }
        isOrchestrationEnabled() {
          return this.coordinationConfig.orchestration.enforceSequentialInitialization;
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          if (this.visualBridge) {
            await this.visualBridge.destroy();
            this.visualBridge = null;
          }
          if (this.nonVisualFacade) {
            await this.nonVisualFacade.destroy();
            this.nonVisualFacade = null;
          }
          if (this.sharedSemanticColorManager) {
            this.sharedSemanticColorManager.destroy();
            this.sharedSemanticColorManager = null;
          }
          if (this.sharedColorHarmonyEngine) {
            this.sharedColorHarmonyEngine.destroy();
            this.sharedColorHarmonyEngine = null;
          }
          if (this.sharedMusicSyncService) {
            this.sharedMusicSyncService.destroy();
            this.sharedMusicSyncService = null;
          }
          if (this.sharedSettingsManager) {
            this.sharedSettingsManager.destroy();
            this.sharedSettingsManager = null;
          }
          if (this.sharedPerformanceAnalyzer) {
            this.sharedPerformanceAnalyzer.destroy();
            this.sharedPerformanceAnalyzer = null;
          }
          if (this.sharedUnifiedCSSConsciousnessController) {
            this.sharedUnifiedCSSConsciousnessController.destroy();
            this.sharedUnifiedCSSConsciousnessController = null;
          }
          if (this.sharedUnifiedPerformanceCoordinator) {
            this.sharedUnifiedPerformanceCoordinator.destroy();
            this.sharedUnifiedPerformanceCoordinator = null;
          }
          this.crossFacadeEventListeners.clear();
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.coordinationConfig };
        }
        async setConfiguration(config) {
          this.coordinationConfig = { ...this.coordinationConfig, ...config };
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        setOnPerformanceChange(callback) {
          this.onPerformanceChange = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            visualSystems: this.visualBridge?.getSystemStatus().systemsActive || 0,
            nonVisualSystems: this.nonVisualFacade?.getSystemStatus().systemsActive || 0,
            healthy: this.currentMetrics.overallHealth === "excellent" || this.currentMetrics.overallHealth === "good"
          };
        }
        // ============================================================================
        // Gradient System Coordination Methods
        // ============================================================================
        /**
         * Setup comprehensive gradient system coordination
         * This method coordinates all gradient-related systems after facades are initialized
         */
        async setupGradientSystemCoordination() {
          if (!this.visualBridge) {
            Y3K?.debug?.warn("SystemCoordinator", "VisualSystemFacade not available - skipping gradient system coordination");
            return;
          }
          Y3K?.debug?.log("SystemCoordinator", "Setting up gradient system coordination");
          const gradientCoordinationStartTime = performance.now();
          let coordinatedSystems = 0;
          try {
            await this.coordinateGradientConductor();
            coordinatedSystems++;
            await this.coordinateWebGLGradientSystem();
            coordinatedSystems++;
            this.setupGradientSystemRefreshCallbacks();
            this.setupGradientSystemCommunication();
            const coordinationDuration = performance.now() - gradientCoordinationStartTime;
            Y3K?.debug?.log("SystemCoordinator", "Gradient system coordination completed", {
              coordinatedSystems,
              duration: `${coordinationDuration.toFixed(2)}ms`,
              systems: ["GradientConductor", "WebGLGradientBackgroundSystem", "GradientTransitionOrchestrator"]
            });
          } catch (error) {
            Y3K?.debug?.error("SystemCoordinator", "Failed to setup gradient system coordination:", error);
            throw error;
          }
        }
        /**
         * Coordinate GradientConductor system through VisualSystemFacade
         */
        async coordinateGradientConductor() {
          try {
            const gradientConductor = this.visualBridge.getVisualSystem("GradientConductor");
            if (!gradientConductor) {
              Y3K?.debug?.warn("SystemCoordinator", "GradientConductor not available via VisualSystemFacade");
              return;
            }
            this.addEventListener("gradient-conductor-event", (event) => {
              if (gradientConductor && typeof gradientConductor.handleSystemEvent === "function") {
                gradientConductor.handleSystemEvent(event);
              }
            });
            this.registerColorDependentSystem("GradientConductor", async (trigger) => {
              if (gradientConductor && typeof gradientConductor.refreshColorState === "function") {
                await gradientConductor.refreshColorState(trigger);
              } else if (gradientConductor && typeof gradientConductor.setPalette === "function") {
                const colorHarmonyEngine = this.sharedColorHarmonyEngine;
                if (colorHarmonyEngine) {
                  try {
                    const currentGradient = await colorHarmonyEngine.getCurrentGradient();
                    if (currentGradient) {
                      gradientConductor.setPalette(currentGradient);
                    }
                  } catch (error) {
                    Y3K?.debug?.warn("SystemCoordinator", "Failed to refresh GradientConductor colors:", error);
                  }
                }
              }
            });
            Y3K?.debug?.log("SystemCoordinator", "GradientConductor coordination established");
          } catch (error) {
            Y3K?.debug?.error("SystemCoordinator", "Failed to coordinate GradientConductor:", error);
          }
        }
        /**
         * Coordinate WebGL gradient background system
         */
        async coordinateWebGLGradientSystem() {
          try {
            const webglSystem = this.visualBridge.getVisualSystem("WebGLBackground");
            if (!webglSystem) {
              Y3K?.debug?.warn("SystemCoordinator", "WebGLGradientBackgroundSystem not available via VisualSystemFacade");
              return;
            }
            this.addEventListener("webgl-gradient-event", (event) => {
              if (webglSystem && typeof webglSystem.handleSystemEvent === "function") {
                webglSystem.handleSystemEvent(event);
              }
            });
            this.registerColorDependentSystem("WebGLGradientBackgroundSystem", async (trigger) => {
              if (webglSystem && typeof webglSystem.refreshColorState === "function") {
                await webglSystem.refreshColorState(trigger);
              } else if (webglSystem && typeof webglSystem.updateGradientTexture === "function") {
                await webglSystem.updateGradientTexture();
              }
            });
            Y3K?.debug?.log("SystemCoordinator", "WebGLGradientBackgroundSystem coordination established");
          } catch (error) {
            Y3K?.debug?.error("SystemCoordinator", "Failed to coordinate WebGLGradientBackgroundSystem:", error);
          }
        }
        /**
         * Setup refresh callbacks for all gradient systems
         */
        setupGradientSystemRefreshCallbacks() {
          try {
            this.registerColorDependentSystem("GradientTransitionOrchestrator");
            Y3K?.debug?.log("SystemCoordinator", "GradientTransitionOrchestrator registered for color updates");
          } catch (error) {
            Y3K?.debug?.warn("SystemCoordinator", "Failed to register GradientTransitionOrchestrator:", error);
          }
        }
        /**
         * Setup communication between gradient systems
         */
        setupGradientSystemCommunication() {
          this.addEventListener("color-harmony-updated", async (event) => {
            try {
              await this.refreshColorDependentSystems("color-harmony-update");
              this.emitEvent("gradient-systems-updated", {
                trigger: "color-harmony-update",
                timestamp: Date.now(),
                systems: ["GradientConductor", "WebGLGradientBackgroundSystem", "GradientTransitionOrchestrator"]
              });
            } catch (error) {
              Y3K?.debug?.error("SystemCoordinator", "Failed to propagate color harmony update to gradient systems:", error);
            }
          });
          this.addEventListener("performance-event", (event) => {
            try {
              this.emitEvent("gradient-performance-event", {
                ...event,
                timestamp: Date.now()
              });
            } catch (error) {
              Y3K?.debug?.error("SystemCoordinator", "Failed to propagate performance event to gradient systems:", error);
            }
          });
          Y3K?.debug?.log("SystemCoordinator", "Gradient system communication established");
        }
        /**
         * Get gradient system coordination status
         */
        getGradientSystemStatus() {
          const gradientSystems = ["GradientConductor", "WebGLGradientBackgroundSystem", "GradientTransitionOrchestrator"];
          const colorDependentGradientSystems = gradientSystems.filter(
            (system) => this.colorDependentSystems.has(system)
          );
          return {
            coordinatedSystems: gradientSystems,
            colorDependentGradientSystems,
            communicationActive: this.crossFacadeEventListeners.size > 0
          };
        }
        // ============================================================================
        // Color System Coordination Methods
        // ============================================================================
        /**
         * Register a system as color-dependent for targeted updates
         */
        registerColorDependentSystem(systemKey, refreshCallback) {
          this.colorDependentSystems.add(systemKey);
          if (refreshCallback) {
            this.colorSystemRefreshCallbacks.set(systemKey, refreshCallback);
          }
          Y3K?.debug?.log("SystemCoordinator", `Registered color-dependent system: ${systemKey}`);
        }
        /**
         * Unregister a color-dependent system
         */
        unregisterColorDependentSystem(systemKey) {
          this.colorDependentSystems.delete(systemKey);
          this.colorSystemRefreshCallbacks.delete(systemKey);
          Y3K?.debug?.log("SystemCoordinator", `Unregistered color-dependent system: ${systemKey}`);
        }
        /**
         * Get list of color-dependent systems
         */
        getColorDependentSystems() {
          return Array.from(this.colorDependentSystems);
        }
        /**
         * Refresh only color-dependent systems efficiently
         */
        async refreshColorDependentSystems(trigger) {
          if (this.colorDependentSystems.size === 0) {
            Y3K?.debug?.log("SystemCoordinator", "No color-dependent systems to refresh");
            return;
          }
          const startTime = performance.now();
          const refreshPromises = [];
          let successCount = 0;
          let failureCount = 0;
          Y3K?.debug?.log("SystemCoordinator", `Refreshing ${this.colorDependentSystems.size} color-dependent systems for trigger: ${trigger}`);
          for (const systemKey of this.colorDependentSystems) {
            const refreshCallback = this.colorSystemRefreshCallbacks.get(systemKey);
            if (refreshCallback) {
              refreshPromises.push(
                refreshCallback(trigger).then(() => {
                  successCount++;
                  Y3K?.debug?.log("SystemCoordinator", `Successfully refreshed color system: ${systemKey}`);
                }).catch((error) => {
                  failureCount++;
                  Y3K?.debug?.warn("SystemCoordinator", `Failed to refresh color system ${systemKey}:`, error);
                })
              );
            } else {
              refreshPromises.push(
                this.getSystemAndRefresh(systemKey, trigger).then(() => {
                  successCount++;
                }).catch((error) => {
                  failureCount++;
                  Y3K?.debug?.warn("SystemCoordinator", `Failed to refresh color system ${systemKey}:`, error);
                })
              );
            }
          }
          await Promise.all(refreshPromises);
          const endTime = performance.now();
          const duration = endTime - startTime;
          Y3K?.debug?.log("SystemCoordinator", `Color system refresh completed`, {
            trigger,
            duration: `${duration.toFixed(2)}ms`,
            success: successCount,
            failures: failureCount,
            totalSystems: this.colorDependentSystems.size
          });
          this.emitEvent("color-systems-refreshed", {
            trigger,
            duration,
            successCount,
            failureCount,
            totalSystems: this.colorDependentSystems.size,
            timestamp: Date.now()
          });
        }
        /**
         * Helper method to get system and call refresh method
         */
        async getSystemAndRefresh(systemKey, trigger) {
          if (this.visualBridge) {
            try {
              const system = this.visualBridge.getVisualSystem(systemKey);
              if (system && typeof system.refreshColorState === "function") {
                await system.refreshColorState(trigger);
                return;
              }
            } catch (error) {
            }
          }
          if (this.nonVisualFacade) {
            try {
              const system = await this.nonVisualFacade.getSystem(systemKey);
              if (system && typeof system.refreshColorState === "function") {
                await system.refreshColorState(trigger);
                return;
              }
            } catch (error) {
            }
          }
          Y3K?.debug?.warn("SystemCoordinator", `System ${systemKey} not found or doesn't support color refresh`);
        }
        /**
         * Auto-register common color-dependent systems
         */
        setupDefaultColorDependentSystems() {
          const defaultColorSystems = [
            "CinematicDramaEngine",
            "EtherealBeautyEngine",
            "NaturalHarmonyEngine",
            "FlowingLiquidConsciousnessSystem",
            "WebGLGradientBackgroundSystem",
            "IridescentShimmerEffectsSystem",
            "ColorHarmonyEngine",
            "GradientTransitionOrchestrator",
            "GradientConductor",
            "SemanticColorManager",
            // UI Managers with consciousness integration
            "Card3DManager",
            "GlassmorphismManager"
          ];
          for (const systemKey of defaultColorSystems) {
            this.registerColorDependentSystem(systemKey);
          }
          Y3K?.debug?.log("SystemCoordinator", `Auto-registered ${defaultColorSystems.length} default color-dependent systems`);
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          Y3K?.debug?.log("SystemCoordinator", "System coordinator destroyed");
        }
        // Shared service getter methods for testing and integration
        getSharedMusicSyncService() {
          return this.sharedMusicSyncService || void 0;
        }
        getSharedColorHarmonyEngine() {
          return this.sharedColorHarmonyEngine || void 0;
        }
        getSharedPerformanceAnalyzer() {
          return this.sharedPerformanceAnalyzer || void 0;
        }
        getSharedSettingsManager() {
          return this.sharedSettingsManager || void 0;
        }
        getSharedSemanticColorManager() {
          return this.sharedSemanticColorManager || void 0;
        }
      };
      __name(_SystemCoordinator, "SystemCoordinator");
      SystemCoordinator = _SystemCoordinator;
    }
  });

  // src-js/utils/color/CatppuccinPalettes.ts
  function color(hex, h, s, l) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g2 = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    const brightness = (0.299 * r + 0.587 * g2 + 0.114 * b) / 255;
    return {
      hex,
      rgb: `${r}, ${g2}, ${b}`,
      hsl: [h, s, l],
      brightness
    };
  }
  function getBrightnessAdjustedBaseColor(flavor, brightnessMode) {
    const palette = CATPPUCCIN_PALETTES[flavor];
    const config = BRIGHTNESS_CONFIGS[brightnessMode];
    switch (brightnessMode) {
      case "bright":
        return flavor === "latte" ? palette.surface1 : palette.surface0;
      case "balanced":
        return flavor === "latte" ? palette.base : palette.surface0;
      case "dark":
        return flavor === "latte" ? palette.mantle : palette.base;
      default:
        return palette.base;
    }
  }
  function getBrightnessAdjustedSurfaceColor(flavor, brightnessMode) {
    const palette = CATPPUCCIN_PALETTES[flavor];
    switch (brightnessMode) {
      case "bright":
        return flavor === "latte" ? palette.surface2 : palette.surface1;
      case "balanced":
        return flavor === "latte" ? palette.surface0 : palette.surface1;
      case "dark":
        return flavor === "latte" ? palette.surface0 : palette.surface0;
      default:
        return palette.surface1;
    }
  }
  function getCatppuccinAccentColor(flavor, accentName) {
    return CATPPUCCIN_PALETTES[flavor][accentName];
  }
  function getDefaultAccentColor(flavor) {
    const palette = CATPPUCCIN_PALETTES[flavor];
    return flavor === "latte" ? palette.blue : palette.mauve;
  }
  var CATPPUCCIN_PALETTES, BRIGHTNESS_CONFIGS;
  var init_CatppuccinPalettes = __esm({
    "src-js/utils/color/CatppuccinPalettes.ts"() {
      "use strict";
      __name(color, "color");
      CATPPUCCIN_PALETTES = {
        mocha: {
          rosewater: color("#f5e0dc", 10, 56, 91),
          flamingo: color("#f2cdcd", 0, 59, 88),
          pink: color("#f5c2e7", 316, 72, 86),
          mauve: color("#cba6f7", 267, 84, 81),
          red: color("#f38ba8", 343, 81, 75),
          maroon: color("#eba0ac", 350, 65, 77),
          peach: color("#fab387", 23, 92, 75),
          yellow: color("#f9e2af", 41, 86, 83),
          green: color("#a6e3a1", 115, 54, 76),
          teal: color("#94e2d5", 174, 57, 73),
          sky: color("#89dceb", 189, 71, 73),
          sapphire: color("#74c7ec", 199, 76, 69),
          blue: color("#89b4fa", 217, 92, 76),
          lavender: color("#b4befe", 232, 97, 85),
          text: color("#cdd6f4", 226, 64, 88),
          subtext1: color("#bac2de", 227, 35, 80),
          subtext0: color("#a6adc8", 228, 24, 72),
          overlay2: color("#9399b2", 228, 17, 64),
          overlay1: color("#7f849c", 230, 13, 55),
          overlay0: color("#6c7086", 231, 11, 47),
          surface2: color("#585b70", 233, 12, 39),
          surface1: color("#45475a", 234, 13, 31),
          surface0: color("#313244", 237, 16, 23),
          base: color("#1e1e2e", 240, 21, 15),
          mantle: color("#181825", 240, 18, 13),
          crust: color("#11111b", 240, 23, 9)
        },
        latte: {
          rosewater: color("#dc8a78", 11, 59, 67),
          flamingo: color("#dd7878", 0, 60, 67),
          pink: color("#ea76cb", 316, 73, 69),
          mauve: color("#8839ef", 266, 85, 58),
          red: color("#d20f39", 347, 87, 44),
          maroon: color("#e64553", 355, 76, 59),
          peach: color("#fe640b", 22, 99, 52),
          yellow: color("#df8e1d", 35, 77, 49),
          green: color("#40a02b", 109, 58, 40),
          teal: color("#179299", 183, 74, 35),
          sky: color("#04a5e5", 197, 97, 46),
          sapphire: color("#209fb5", 189, 70, 42),
          blue: color("#1e66f5", 220, 91, 54),
          lavender: color("#7287fd", 231, 97, 72),
          text: color("#4c4f69", 234, 16, 35),
          subtext1: color("#5c5f77", 233, 13, 41),
          subtext0: color("#6c6f85", 233, 10, 47),
          overlay2: color("#7c7f93", 232, 10, 53),
          overlay1: color("#8c8fa1", 231, 10, 59),
          overlay0: color("#9ca0b0", 228, 11, 65),
          surface2: color("#acb0be", 227, 12, 71),
          surface1: color("#bcc0cc", 226, 14, 77),
          surface0: color("#ccd0da", 225, 16, 83),
          base: color("#eff1f5", 220, 23, 95),
          mantle: color("#e6e9ef", 220, 22, 92),
          crust: color("#dce0e8", 220, 21, 89)
        },
        frappe: {
          rosewater: color("#f2d5cf", 10, 57, 88),
          flamingo: color("#eebebe", 0, 58, 84),
          pink: color("#f4b8e4", 316, 73, 84),
          mauve: color("#ca9ee6", 277, 59, 76),
          red: color("#e78284", 359, 68, 71),
          maroon: color("#ea999c", 358, 56, 76),
          peach: color("#ef9f76", 20, 79, 70),
          yellow: color("#e5c890", 40, 62, 73),
          green: color("#a6d189", 96, 44, 68),
          teal: color("#81c8be", 172, 39, 65),
          sky: color("#99d1db", 189, 48, 73),
          sapphire: color("#85c1dc", 199, 55, 69),
          blue: color("#8caaee", 222, 74, 74),
          lavender: color("#babbf1", 239, 66, 84),
          text: color("#c6d0f5", 227, 70, 87),
          subtext1: color("#b5bfe2", 229, 44, 80),
          subtext0: color("#a5adce", 230, 34, 72),
          overlay2: color("#949cbb", 231, 19, 64),
          overlay1: color("#838ba7", 232, 16, 56),
          overlay0: color("#737994", 232, 13, 49),
          surface2: color("#626880", 233, 16, 42),
          surface1: color("#51576d", 234, 16, 35),
          surface0: color("#414559", 235, 16, 30),
          base: color("#303446", 229, 19, 23),
          mantle: color("#292c3c", 231, 19, 20),
          crust: color("#232634", 229, 20, 17)
        },
        macchiato: {
          rosewater: color("#f4dbd6", 10, 58, 90),
          flamingo: color("#f0c6c6", 0, 58, 86),
          pink: color("#f5bde6", 316, 74, 85),
          mauve: color("#c6a0f6", 267, 83, 79),
          red: color("#ed8796", 351, 74, 73),
          maroon: color("#ee99a0", 357, 70, 77),
          peach: color("#f5a97f", 21, 86, 73),
          yellow: color("#eed49f", 42, 79, 78),
          green: color("#a6da95", 105, 48, 72),
          teal: color("#8bd5ca", 172, 47, 69),
          sky: color("#91d7e3", 189, 59, 73),
          sapphire: color("#7dc4e4", 199, 66, 69),
          blue: color("#8aadf4", 220, 83, 75),
          lavender: color("#b7bdf8", 238, 82, 84),
          text: color("#cad3f5", 227, 68, 88),
          subtext1: color("#b8c0e0", 228, 39, 81),
          subtext0: color("#a5adcb", 227, 27, 72),
          overlay2: color("#939ab7", 228, 20, 64),
          overlay1: color("#8087a2", 230, 15, 56),
          overlay0: color("#6e738d", 230, 12, 48),
          surface2: color("#5b6078", 233, 16, 40),
          surface1: color("#494d64", 234, 15, 33),
          surface0: color("#363a4f", 235, 16, 26),
          base: color("#24273a", 232, 23, 19),
          mantle: color("#1e2030", 233, 23, 16),
          crust: color("#181926", 236, 23, 13)
        }
      };
      BRIGHTNESS_CONFIGS = {
        bright: {
          baseColorTarget: 0.25,
          // Lighter base colors
          surfaceColorTarget: 0.35,
          textContrastMin: 4.5
        },
        balanced: {
          baseColorTarget: 0.15,
          // Standard base colors  
          surfaceColorTarget: 0.25,
          textContrastMin: 4.5
        },
        dark: {
          baseColorTarget: 0.08,
          // Darker base colors
          surfaceColorTarget: 0.15,
          textContrastMin: 3
          // Slightly lower contrast for dark mode comfort
        }
      };
      __name(getBrightnessAdjustedBaseColor, "getBrightnessAdjustedBaseColor");
      __name(getBrightnessAdjustedSurfaceColor, "getBrightnessAdjustedSurfaceColor");
      __name(getCatppuccinAccentColor, "getCatppuccinAccentColor");
      __name(getDefaultAccentColor, "getDefaultAccentColor");
    }
  });

  // src-js/core/css/ColorStateManager.ts
  var _ColorStateManager, ColorStateManager, globalColorStateManager;
  var init_ColorStateManager = __esm({
    "src-js/core/css/ColorStateManager.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_CatppuccinPalettes();
      _ColorStateManager = class _ColorStateManager {
        constructor(settingsManager) {
          this.initialized = false;
          this.settingsManager = null;
          this.currentState = null;
          this.isUpdating = false;
          // 🔧 PHASE 2: CSS Authority Consolidation - Batched CSS Updates
          this.cssBatcher = null;
          this.pendingCSSUpdates = /* @__PURE__ */ new Map();
          this.cssUpdateTimer = null;
          // Performance tracking
          this.updateCount = 0;
          this.lastUpdateTime = 0;
          this.settingsManager = settingsManager || null;
        }
        async initialize() {
          if (this.initialized) return;
          unifiedEventBus.subscribe("settings:changed", this.handleSettingsChange.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("colors:harmonized", this.handleProcessedColors.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("colors:extracted", this.handleExtractedColors.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("consciousness:updated", this.handleConsciousnessUpdate.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("music:energy", this.handleMusicEnergyUpdate.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("system:css-variables", this.handleSystemCSSVariables.bind(this), "ColorStateManager");
          if (!this.settingsManager) {
            this.settingsManager = globalThis.__SN_settingsManager || globalThis.Y3K?.system?.settingsManager;
          }
          if (this.settingsManager) {
            await this.applyInitialColorState();
          }
          this.initialized = true;
          console.log("\u{1F3A8} [ColorStateManager] Initialized successfully");
        }
        async healthCheck() {
          const issues = [];
          if (!this.settingsManager) {
            issues.push("SettingsManager not available");
          }
          if (!this.currentState) {
            issues.push("No current color state");
          }
          if (this.updateCount === 0) {
            issues.push("No color updates performed yet");
          }
          const timeSinceLastUpdate = Date.now() - this.lastUpdateTime;
          if (timeSinceLastUpdate > 3e5) {
            issues.push(`Last update was ${Math.round(timeSinceLastUpdate / 1e3)}s ago`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Color state manager - ${this.updateCount} updates performed`,
            issues,
            system: "ColorStateManager"
          };
        }
        updateAnimation(deltaTime) {
        }
        destroy() {
          unifiedEventBus.unsubscribeAll("ColorStateManager");
          if (this.cssUpdateTimer) {
            clearTimeout(this.cssUpdateTimer);
            this.cssUpdateTimer = null;
          }
          this.pendingCSSUpdates.clear();
          this.cssBatcher = null;
          this.currentState = null;
          this.initialized = false;
        }
        /**
         * Get current color state configuration from settings
         */
        getCurrentConfig() {
          if (!this.settingsManager) {
            return {
              catppuccinFlavor: "mocha",
              brightnessMode: "bright",
              accentColor: "mauve",
              preserveAlbumArt: true,
              enableTransitions: true
            };
          }
          return {
            catppuccinFlavor: this.settingsManager.get("catppuccin-flavor"),
            brightnessMode: this.settingsManager.get("sn-brightness-mode"),
            accentColor: this.settingsManager.get("catppuccin-accentColor"),
            preserveAlbumArt: true,
            // TODO: Add setting for this
            enableTransitions: true
          };
        }
        /**
         * Calculate the effective color state based on current configuration
         */
        calculateColorState(config) {
          const { catppuccinFlavor, brightnessMode, accentColor, dynamicAlbumColors } = config;
          const baseColor = getBrightnessAdjustedBaseColor(catppuccinFlavor, brightnessMode);
          const surfaceColor = getBrightnessAdjustedSurfaceColor(catppuccinFlavor, brightnessMode);
          let effectiveAccentColor;
          if (accentColor === "dynamic" && dynamicAlbumColors) {
            effectiveAccentColor = dynamicAlbumColors.accent;
          } else if (accentColor === "dynamic") {
            effectiveAccentColor = getDefaultAccentColor(catppuccinFlavor);
          } else {
            effectiveAccentColor = getCatppuccinAccentColor(catppuccinFlavor, accentColor);
          }
          const palette = CATPPUCCIN_PALETTES[catppuccinFlavor];
          const textColor = palette["text"];
          return {
            baseColor,
            surfaceColor,
            accentColor: effectiveAccentColor,
            textColor,
            effectiveConfig: config,
            timestamp: Date.now()
          };
        }
        /**
         * 🔧 PHASE 2: Enhanced CSS application with batching and priority support
         * Apply color state to CSS variables with batching optimization
         */
        async applyColorStateToCSSVariables(state) {
          const startTime = performance.now();
          const cssUpdates = {
            // === CRITICAL PRIORITY: Core color variables ===
            "--sn-cosmic-base-hex": state.baseColor.hex,
            "--sn-cosmic-accent-hex": state.accentColor.hex,
            "--spice-accent": state.accentColor.hex,
            "--spice-base": state.baseColor.hex,
            // === HIGH PRIORITY: Primary gradients and surfaces ===
            "--sn-color-base-hex": state.baseColor.hex,
            "--sn-color-base-rgb": state.baseColor.rgb,
            "--sn-color-surface-hex": state.surfaceColor.hex,
            "--sn-color-surface-rgb": state.surfaceColor.rgb,
            "--sn-color-accent-hex": state.accentColor.hex,
            "--sn-color-accent-rgb": state.accentColor.rgb,
            "--sn-dynamic-accent-hex": state.accentColor.hex,
            "--sn-dynamic-accent-rgb": state.accentColor.rgb,
            // === NORMAL PRIORITY: Extended color systems ===
            "--sn-cosmic-base-rgb": state.baseColor.rgb,
            "--sn-cosmic-surface-hex": state.surfaceColor.hex,
            "--sn-cosmic-surface-rgb": state.surfaceColor.rgb,
            "--sn-cosmic-accent-rgb": state.accentColor.rgb,
            "--sn-color-text-hex": state.textColor.hex,
            "--sn-color-text-rgb": state.textColor.rgb,
            "--sn-cosmic-text-hex": state.textColor.hex,
            "--sn-cosmic-text-rgb": state.textColor.rgb,
            // === NORMAL PRIORITY: Spicetify compatibility ===
            "--spice-surface1": state.surfaceColor.hex,
            "--spice-text": state.textColor.hex,
            "--spice-rgb-base": state.baseColor.rgb,
            "--spice-rgb-surface1": state.surfaceColor.rgb,
            "--spice-rgb-accent": state.accentColor.rgb,
            "--spice-rgb-text": state.textColor.rgb,
            // === NORMAL PRIORITY: Gradient system integration ===
            "--sn-bg-gradient-primary-rgb": state.accentColor.rgb,
            "--sn-bg-gradient-secondary-rgb": state.surfaceColor.rgb,
            "--sn-bg-gradient-accent-rgb": state.accentColor.rgb,
            // === LOW PRIORITY: Meta information for debugging ===
            "--sn-color-state-flavor": `"${state.effectiveConfig.catppuccinFlavor}"`,
            "--sn-color-state-brightness": `"${state.effectiveConfig.brightnessMode}"`,
            "--sn-color-state-accent": `"${state.effectiveConfig.accentColor}"`,
            "--sn-color-state-timestamp": state.timestamp.toString()
          };
          await this.applyCSSVariablesBatched(cssUpdates);
          const endTime = performance.now();
          const updateDuration = endTime - startTime;
          console.log(`\u{1F3A8} [ColorStateManager] Applied ${Object.keys(cssUpdates).length} CSS variables in ${updateDuration.toFixed(2)}ms (batched: ${!!this.cssBatcher})`);
        }
        /**
         * 🔧 PHASE 2: Batched CSS variable application with priority support
         */
        async applyCSSVariablesBatched(cssUpdates) {
          if (!this.cssBatcher) {
            Object.entries(cssUpdates).forEach(([key, value]) => {
              document.documentElement.style.setProperty(key, value);
            });
            return;
          }
          const criticalVars = ["--sn-cosmic-base-hex", "--sn-cosmic-accent-hex", "--spice-accent", "--spice-base"];
          const highPriorityVars = ["--sn-color-", "--sn-dynamic-accent-"];
          Object.entries(cssUpdates).forEach(([property, value]) => {
            this.cssBatcher.queueCSSVariableUpdate(property, value);
          });
        }
        /**
         * 🔧 PHASE 2: Generic method for other systems to queue CSS updates through ColorStateManager
         * This makes ColorStateManager the single CSS authority for all color-related variables
         */
        queueCSSVariableUpdate(property, value, priority = "normal") {
          if (this.cssBatcher) {
            this.cssBatcher.queueCSSVariableUpdate(property, value);
          } else {
            this.pendingCSSUpdates.set(property, value);
            this.scheduleBatchUpdate();
          }
        }
        /**
         * 🔧 PHASE 2: Schedule batched updates for pending CSS variables
         */
        scheduleBatchUpdate() {
          if (this.cssUpdateTimer) return;
          this.cssUpdateTimer = window.setTimeout(() => {
            this.flushPendingCSSUpdates();
            this.cssUpdateTimer = null;
          }, 16);
        }
        /**
         * 🔧 PHASE 2: Flush pending CSS updates when no batcher is available
         */
        flushPendingCSSUpdates() {
          if (this.pendingCSSUpdates.size === 0) return;
          const startTime = performance.now();
          this.pendingCSSUpdates.forEach((value, property) => {
            document.documentElement.style.setProperty(property, value);
          });
          const updateDuration = performance.now() - startTime;
          console.log(`\u{1F3A8} [ColorStateManager] Flushed ${this.pendingCSSUpdates.size} pending CSS variables in ${updateDuration.toFixed(2)}ms`);
          this.pendingCSSUpdates.clear();
        }
        /**
         * 🔧 PHASE 2: Set CSS batcher for optimized performance
         */
        setCSSBatcher(batcher) {
          this.cssBatcher = batcher;
          if (this.pendingCSSUpdates.size > 0) {
            this.pendingCSSUpdates.forEach((value, property) => {
              this.cssBatcher.queueCSSVariableUpdate(property, value);
            });
            this.pendingCSSUpdates.clear();
          }
        }
        /**
         * Verify that critical CSS variables were actually applied to the DOM
         */
        async verifyCSSVariablesApplied(cssUpdates) {
          const criticalVars = [
            "--sn-cosmic-base-hex",
            "--sn-cosmic-accent-hex",
            "--spice-base"
          ];
          for (const varName of criticalVars) {
            if (cssUpdates[varName]) {
              const computedValue = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
              const expectedValue = cssUpdates[varName];
              if (computedValue !== expectedValue) {
                console.warn(`\u{1F3A8} [ColorStateManager] Variable verification failed: ${varName} = "${computedValue}" (expected "${expectedValue}")`);
                return false;
              }
            }
          }
          return true;
        }
        /**
         * Update color state with change detection
         */
        async updateColorState(trigger = "settings") {
          if (this.isUpdating) return;
          this.isUpdating = true;
          try {
            const config = this.getCurrentConfig();
            const newState = this.calculateColorState(config);
            const hasChanged = !this.currentState || this.currentState.baseColor.hex !== newState.baseColor.hex || this.currentState.surfaceColor.hex !== newState.surfaceColor.hex || this.currentState.accentColor.hex !== newState.accentColor.hex || this.currentState.effectiveConfig.catppuccinFlavor !== newState.effectiveConfig.catppuccinFlavor || this.currentState.effectiveConfig.brightnessMode !== newState.effectiveConfig.brightnessMode;
            if (hasChanged) {
              const oldState = this.currentState;
              await this.applyColorStateToCSSVariables(newState);
              this.currentState = newState;
              this.updateCount++;
              this.lastUpdateTime = Date.now();
              unifiedEventBus.emit("colors:applied", {
                oldState,
                newState,
                trigger,
                cssVariables: {
                  "--sn-cosmic-base-hex": newState.baseColor.hex,
                  "--sn-cosmic-accent-hex": newState.accentColor.hex
                },
                accentHex: newState.accentColor.hex,
                accentRgb: newState.accentColor.rgb,
                appliedAt: Date.now()
              });
              console.log(`\u{1F3A8} [ColorStateManager] Color state updated (${trigger}):`, {
                flavor: newState.effectiveConfig.catppuccinFlavor,
                brightness: newState.effectiveConfig.brightnessMode,
                accent: newState.effectiveConfig.accentColor,
                base: newState.baseColor.hex,
                surface: newState.surfaceColor.hex,
                accentHex: newState.accentColor.hex
              });
            }
          } finally {
            this.isUpdating = false;
          }
        }
        /**
         * Apply initial color state during system initialization
         */
        async applyInitialColorState() {
          await this.updateColorState("initialization");
        }
        /**
         * Handle settings changes
         */
        async handleSettingsChange(event) {
          const { settingKey, newValue, oldValue } = event;
          if (["catppuccin-flavor", "sn-brightness-mode", "catppuccin-accentColor"].includes(settingKey)) {
            let trigger = "settings";
            if (settingKey === "catppuccin-flavor") trigger = "flavor";
            else if (settingKey === "sn-brightness-mode") trigger = "brightness";
            else if (settingKey === "catppuccin-accentColor") trigger = "accent";
            unifiedEventBus.emit(`colorState:${trigger}Changed`, {
              settingKey,
              newValue,
              oldValue,
              timestamp: Date.now()
            });
            await this.updateColorState(trigger);
          }
        }
        /**
         * 🔧 PHASE 2: Handle processed color events from unified color processing
         * This replaces individual CSS application in ColorHarmonyEngine and orchestrators
         */
        async handleProcessedColors(event) {
          const { processedColors, accentHex, accentRgb, strategies, coordinationMetrics } = event;
          const colorVariables = {};
          Object.entries(processedColors).forEach(([key, value]) => {
            if (value) {
              const cssVar = key.startsWith("--") ? key : `--sn-${key.toLowerCase().replace(/_/g, "-")}`;
              colorVariables[cssVar] = value;
            }
          });
          if (accentHex) {
            colorVariables["--sn-accent-hex"] = accentHex;
            colorVariables["--sn-processed-accent-hex"] = accentHex;
          }
          if (accentRgb) {
            colorVariables["--sn-accent-rgb"] = accentRgb;
            colorVariables["--sn-processed-accent-rgb"] = accentRgb;
          }
          if (coordinationMetrics) {
            if (coordinationMetrics.emotionalState) {
              colorVariables["--sn-emotional-state"] = `"${coordinationMetrics.emotionalState}"`;
            }
            if (coordinationMetrics.musicInfluenceStrength !== void 0) {
              colorVariables["--sn-music-influence"] = coordinationMetrics.musicInfluenceStrength.toFixed(3);
            }
          }
          Object.entries(colorVariables).forEach(([property, value]) => {
            let priority = "normal";
            if (property.includes("accent-hex") || property.includes("accent-rgb")) {
              priority = "high";
            } else if (property.includes("debug") || property.includes("state") || property.includes("influence")) {
              priority = "low";
            }
            this.queueCSSVariableUpdate(property, value, priority);
          });
          console.log(`\u{1F3A8} [ColorStateManager] Applied ${Object.keys(colorVariables).length} processed color variables`);
        }
        /**
         * 🔧 PHASE 2: Handle extracted colors from album art
         */
        async handleExtractedColors(event) {
          const { rawColors, trackUri, musicData } = event;
          const extractedVariables = {};
          Object.entries(rawColors).forEach(([key, value]) => {
            if (value) {
              extractedVariables[`--sn-extracted-${key.toLowerCase()}`] = value;
            }
          });
          if (trackUri) {
            extractedVariables["--sn-current-track-id"] = `"${trackUri}"`;
          }
          Object.entries(extractedVariables).forEach(([property, value]) => {
            this.queueCSSVariableUpdate(property, value, "low");
          });
        }
        /**
         * 🔧 PHASE 2: Handle consciousness updates and apply consciousness CSS variables
         */
        async handleConsciousnessUpdate(event) {
          const { payload } = event;
          if (!payload) return;
          const consciousnessVariables = {
            "--sn-consciousness-level": (payload.consciousnessLevel || 0).toFixed(3),
            "--sn-emotional-temperature": (payload.emotionalTemperature || 6500).toString(),
            "--sn-transcendence-level": (payload.transcendenceLevel || 0).toFixed(3),
            "--sn-volumetric-depth": (payload.volumetricDepth || 0).toFixed(3),
            "--sn-data-stream-intensity": (payload.dataStreamIntensity || 0).toFixed(3),
            "--sn-cosmic-resonance": (payload.cosmicResonance || 0).toFixed(3)
          };
          Object.entries(consciousnessVariables).forEach(([property, value]) => {
            this.queueCSSVariableUpdate(property, value, "normal");
          });
        }
        /**
         * 🔧 PHASE 2: Handle music energy updates for dynamic CSS variables
         */
        async handleMusicEnergyUpdate(event) {
          const { energy, valence, tempo } = event;
          const musicVariables = {};
          if (energy !== void 0) {
            musicVariables["--sn-music-energy"] = energy.toFixed(3);
          }
          if (valence !== void 0) {
            musicVariables["--sn-music-valence"] = valence.toFixed(3);
          }
          if (tempo !== void 0) {
            musicVariables["--sn-music-tempo"] = tempo.toString();
          }
          Object.entries(musicVariables).forEach(([property, value]) => {
            this.queueCSSVariableUpdate(property, value, "high");
          });
        }
        /**
         * 🔧 PHASE 2: Handle CSS variable events from other systems (ColorHarmonyEngine, etc.)
         * This makes ColorStateManager the single CSS authority for all systems
         */
        async handleSystemCSSVariables(event) {
          const { source, variables, timestamp } = event;
          if (!variables || typeof variables !== "object") return;
          Object.entries(variables).forEach(([property, value]) => {
            let priority = "normal";
            if (property.includes("harmony") || property.includes("glow") || property.includes("pulse")) {
              priority = "high";
            } else if (property.includes("debug") || property.includes("breathing")) {
              priority = "low";
            }
            this.queueCSSVariableUpdate(property, value, priority);
          });
          console.log(`\u{1F3A8} [ColorStateManager] Applied ${Object.keys(variables).length} CSS variables from ${source}`);
        }
        /**
         * Get current color state (read-only)
         */
        getCurrentState() {
          return this.currentState ? { ...this.currentState } : null;
        }
        /**
         * Force refresh of color state
         */
        async refresh() {
          await this.updateColorState("settings");
        }
      };
      __name(_ColorStateManager, "ColorStateManager");
      ColorStateManager = _ColorStateManager;
      globalColorStateManager = new ColorStateManager();
    }
  });

  // src-js/core/events/EventMigrationManager.ts
  var _EventMigrationManager, EventMigrationManager, eventMigrationManager;
  var init_EventMigrationManager = __esm({
    "src-js/core/events/EventMigrationManager.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_UnifiedEventBus();
      _EventMigrationManager = class _EventMigrationManager {
        constructor() {
          // Legacy event mappings
          this.eventMappings = [
            // Color processing events
            {
              legacyEvent: "colors-extracted",
              unifiedEvent: "colors:extracted",
              transform: /* @__PURE__ */ __name((data) => ({
                rawColors: data.colors || data.rawColors || {},
                trackUri: data.trackUri || data.uri || "unknown",
                timestamp: data.timestamp || Date.now(),
                musicData: data.musicData
              }), "transform")
            },
            {
              legacyEvent: "colors-harmonized",
              unifiedEvent: "colors:harmonized",
              transform: /* @__PURE__ */ __name((data) => ({
                processedColors: data.colors || data.processedColors || {},
                accentHex: data.accentHex || data.accent || "#cba6f7",
                accentRgb: data.accentRgb || data.rgb || "203,166,247",
                strategies: data.strategies || ["unknown"],
                processingTime: data.processingTime || 0,
                trackUri: data.trackUri || data.uri || "unknown"
              }), "transform")
            },
            {
              legacyEvent: "colors/extracted",
              unifiedEvent: "colors:extracted",
              transform: /* @__PURE__ */ __name((data) => ({
                rawColors: data.colors || data.rawColors || {},
                trackUri: data.trackUri || data.uri || "unknown",
                timestamp: data.timestamp || Date.now(),
                musicData: data.musicData
              }), "transform")
            },
            {
              legacyEvent: "colors/harmonized",
              unifiedEvent: "colors:harmonized",
              transform: /* @__PURE__ */ __name((data) => ({
                processedColors: data.colors || data.processedColors || {},
                accentHex: data.accentHex || data.accent || "#cba6f7",
                accentRgb: data.accentRgb || data.rgb || "203,166,247",
                strategies: data.strategies || ["unknown"],
                processingTime: data.processingTime || 0,
                trackUri: data.trackUri || data.uri || "unknown"
              }), "transform")
            },
            // Music sync events
            {
              legacyEvent: "music-sync:beat",
              unifiedEvent: "music:beat",
              transform: /* @__PURE__ */ __name((data) => ({
                bpm: data.bpm || data.tempo || 120,
                intensity: data.intensity || data.energy || 0.5,
                timestamp: data.timestamp || Date.now(),
                confidence: data.confidence || 0.8
              }), "transform")
            },
            {
              legacyEvent: "music-sync:energy-changed",
              unifiedEvent: "music:energy",
              transform: /* @__PURE__ */ __name((data) => ({
                energy: data.energy || 0.5,
                valence: data.valence || 0.5,
                tempo: data.tempo || data.bpm || 120,
                timestamp: data.timestamp || Date.now()
              }), "transform")
            },
            {
              legacyEvent: "beat/frame",
              unifiedEvent: "music:beat",
              transform: /* @__PURE__ */ __name((data) => ({
                bpm: data.bpm || 120,
                intensity: data.intensity || 0.5,
                timestamp: data.timestamp || Date.now(),
                confidence: data.confidence || 0.8
              }), "transform")
            },
            {
              legacyEvent: "beat/bpm",
              unifiedEvent: "music:beat",
              transform: /* @__PURE__ */ __name((data) => ({
                bpm: data.bpm || data.value || 120,
                intensity: data.intensity || 0.5,
                timestamp: data.timestamp || Date.now(),
                confidence: data.confidence || 0.8
              }), "transform")
            },
            {
              legacyEvent: "beat/intensity",
              unifiedEvent: "music:energy",
              transform: /* @__PURE__ */ __name((data) => ({
                energy: data.intensity || data.energy || 0.5,
                valence: data.valence || 0.5,
                tempo: data.tempo || 120,
                timestamp: data.timestamp || Date.now()
              }), "transform")
            },
            // Settings events
            {
              legacyEvent: "year3000SystemSettingsChanged",
              unifiedEvent: "settings:changed",
              transform: /* @__PURE__ */ __name((data) => ({
                settingKey: data.setting || data.key || "unknown",
                oldValue: data.oldValue,
                newValue: data.newValue || data.value,
                timestamp: data.timestamp || Date.now()
              }), "transform")
            },
            {
              legacyEvent: "year3000ArtisticModeChanged",
              unifiedEvent: "settings:visual-guide-changed",
              transform: /* @__PURE__ */ __name((data) => ({
                oldMode: data.oldMode || data.from || "cosmic",
                newMode: data.newMode || data.to || data.mode || "cosmic",
                timestamp: data.timestamp || Date.now()
              }), "transform")
            },
            // Performance events
            {
              legacyEvent: "colorharmony/frame",
              unifiedEvent: "performance:frame",
              transform: /* @__PURE__ */ __name((data) => ({
                deltaTime: data.deltaTime || 16,
                fps: data.fps || 60,
                memoryUsage: data.memoryUsage || 0,
                timestamp: data.timestamp || Date.now()
              }), "transform"),
              deprecated: true,
              removalVersion: "2.0.0"
            },
            // System lifecycle events
            {
              legacyEvent: "music-state-change",
              unifiedEvent: "music:state-changed",
              transform: /* @__PURE__ */ __name((data) => ({
                isPlaying: data.isPlaying || data.playing || false,
                position: data.position || data.currentTime || 0,
                duration: data.duration || data.totalTime || 0,
                timestamp: data.timestamp || Date.now()
              }), "transform")
            },
            // Additional GlobalEventBus events that need migration
            {
              legacyEvent: "music:now-playing-changed",
              unifiedEvent: "music:track-changed",
              transform: /* @__PURE__ */ __name((data) => ({
                trackUri: data.trackUri || "unknown",
                albumArt: data.albumArt,
                artist: data.artist || "Unknown Artist",
                title: data.title || "Unknown Title",
                timestamp: data.timestamp || Date.now()
              }), "transform")
            },
            {
              legacyEvent: "music:beat",
              unifiedEvent: "music:beat",
              transform: /* @__PURE__ */ __name((data) => data, "transform")
              // Pass through as-is for unified events
            },
            {
              legacyEvent: "music:energy",
              unifiedEvent: "music:energy",
              transform: /* @__PURE__ */ __name((data) => data, "transform")
              // Pass through as-is for unified events
            },
            {
              legacyEvent: "music:genre-change",
              unifiedEvent: "music:energy",
              // Map to closest unified event
              transform: /* @__PURE__ */ __name((data) => ({
                energy: data.energy || 0.5,
                valence: data.valence || 0.5,
                tempo: data.tempo || 120,
                timestamp: data.timestamp || Date.now()
              }), "transform")
            },
            {
              legacyEvent: "user:scroll",
              unifiedEvent: "user:scroll",
              transform: /* @__PURE__ */ __name((data) => data, "transform")
              // Pass through as-is
            },
            {
              legacyEvent: "colorConsciousnessUpdate",
              unifiedEvent: "colors:harmonized",
              transform: /* @__PURE__ */ __name((data) => ({
                processedColors: data.colors || {},
                accentHex: data.accentHex || "#cba6f7",
                accentRgb: data.accentRgb || "203,166,247",
                strategies: ["ColorConsciousness"],
                processingTime: 0,
                trackUri: data.trackUri || "unknown"
              }), "transform")
            },
            {
              legacyEvent: "emotionalMoment",
              unifiedEvent: "consciousness:intensity-changed",
              transform: /* @__PURE__ */ __name((data) => ({
                intensity: data.intensity || 0.5,
                userEngagement: data.userEngagement || 0.5,
                timestamp: data.timestamp || Date.now()
              }), "transform")
            },
            {
              legacyEvent: "gentleTransition",
              unifiedEvent: "consciousness:field-updated",
              transform: /* @__PURE__ */ __name((data) => ({
                rhythmicPulse: data.rhythmicPulse || 0.5,
                musicalFlow: data.musicalFlow || { x: 0, y: 0 },
                energyResonance: data.energyResonance || 0.5,
                depthPerception: data.depthPerception || 0.5,
                breathingCycle: data.breathingCycle || 0.5
              }), "transform")
            }
          ];
          // Migration metrics
          this.metrics = {
            totalLegacyEvents: 0,
            totalUnifiedEvents: 0,
            conversionRate: 0,
            deprecatedEventsUsed: 0,
            systemsMigrated: 0,
            systemsPending: 0
          };
          // Legacy event listeners for DOM events
          this.legacyDOMListeners = /* @__PURE__ */ new Map();
          // Legacy GlobalEventBus compatibility (if it exists)
          this.globalEventBusCompatibility = false;
          this.setupLegacyEventBridge();
          this.setupGlobalEventBusCompatibility();
          Y3K?.debug?.log("EventMigrationManager", "Event migration manager initialized", {
            mappingsCount: this.eventMappings.length,
            deprecatedMappings: this.eventMappings.filter((m) => m.deprecated).length
          });
        }
        /**
         * Get singleton instance
         */
        static getInstance() {
          if (!_EventMigrationManager.instance) {
            _EventMigrationManager.instance = new _EventMigrationManager();
          }
          return _EventMigrationManager.instance;
        }
        /**
         * Setup legacy DOM event bridge
         */
        setupLegacyEventBridge() {
          this.eventMappings.forEach((mapping) => {
            const listener = /* @__PURE__ */ __name((event) => {
              const customEvent = event;
              this.handleLegacyDOMEvent(mapping, customEvent.detail);
            }, "listener");
            this.legacyDOMListeners.set(mapping.legacyEvent, listener);
            document.addEventListener(mapping.legacyEvent, listener);
            Y3K?.debug?.log("EventMigrationManager", `Legacy DOM listener registered: ${mapping.legacyEvent} -> ${mapping.unifiedEvent}`);
          });
        }
        /**
         * Setup GlobalEventBus compatibility if it exists
         */
        setupGlobalEventBusCompatibility() {
          try {
            let globalEventBus = window.GlobalEventBus;
            if (!globalEventBus) {
              try {
                const { GlobalEventBus: ImportedGlobalEventBus } = (init_EventBus(), __toCommonJS(EventBus_exports));
                globalEventBus = ImportedGlobalEventBus;
              } catch (importError) {
                globalEventBus = globalThis.GlobalEventBus;
              }
            }
            if (globalEventBus && typeof globalEventBus.subscribe === "function") {
              this.globalEventBusCompatibility = true;
              this.setupGlobalEventBusSubscriptions(globalEventBus);
              Y3K?.debug?.log("EventMigrationManager", "GlobalEventBus compatibility enabled");
            }
          } catch (error) {
            Y3K?.debug?.log("EventMigrationManager", "GlobalEventBus not found - DOM-only compatibility mode");
          }
        }
        /**
         * Setup GlobalEventBus subscriptions
         */
        setupGlobalEventBusSubscriptions(globalEventBus) {
          this.eventMappings.forEach((mapping) => {
            if (mapping.legacyEvent.includes("/")) {
              try {
                globalEventBus.subscribe(mapping.legacyEvent, (data) => {
                  this.handleLegacyGlobalEvent(mapping, data);
                });
                Y3K?.debug?.log("EventMigrationManager", `GlobalEventBus listener registered: ${mapping.legacyEvent} -> ${mapping.unifiedEvent}`);
              } catch (error) {
                Y3K?.debug?.warn("EventMigrationManager", `Failed to register GlobalEventBus listener for ${mapping.legacyEvent}:`, error);
              }
            }
          });
        }
        /**
         * Handle legacy DOM events
         */
        handleLegacyDOMEvent(mapping, data) {
          try {
            this.metrics.totalLegacyEvents++;
            if (mapping.deprecated) {
              this.metrics.deprecatedEventsUsed++;
              Y3K?.debug?.warn("EventMigrationManager", `Deprecated event used: ${mapping.legacyEvent}`, {
                removalVersion: mapping.removalVersion,
                useInstead: mapping.unifiedEvent
              });
            }
            const transformedData = mapping.transform ? mapping.transform(data) : data;
            unifiedEventBus.emit(mapping.unifiedEvent, transformedData);
            this.metrics.totalUnifiedEvents++;
            this.updateConversionRate();
            Y3K?.debug?.log("EventMigrationManager", `Legacy event converted: ${mapping.legacyEvent} -> ${mapping.unifiedEvent}`, {
              originalData: data,
              transformedData
            });
          } catch (error) {
            Y3K?.debug?.error("EventMigrationManager", `Failed to convert legacy event ${mapping.legacyEvent}:`, error);
          }
        }
        /**
         * Handle legacy GlobalEventBus events
         */
        handleLegacyGlobalEvent(mapping, data) {
          try {
            this.metrics.totalLegacyEvents++;
            const transformedData = mapping.transform ? mapping.transform(data) : data;
            unifiedEventBus.emit(mapping.unifiedEvent, transformedData);
            this.metrics.totalUnifiedEvents++;
            this.updateConversionRate();
            Y3K?.debug?.log("EventMigrationManager", `GlobalEventBus event converted: ${mapping.legacyEvent} -> ${mapping.unifiedEvent}`);
          } catch (error) {
            Y3K?.debug?.error("EventMigrationManager", `Failed to convert GlobalEventBus event ${mapping.legacyEvent}:`, error);
          }
        }
        /**
         * Provide legacy event emission compatibility
         */
        emitLegacyEvent(eventName, data) {
          try {
            const mapping = this.eventMappings.find((m) => m.legacyEvent === eventName);
            if (mapping) {
              const transformedData = mapping.transform ? mapping.transform(data) : data;
              unifiedEventBus.emit(mapping.unifiedEvent, transformedData);
              Y3K?.debug?.log("EventMigrationManager", `Legacy event emitted through unified bus: ${eventName} -> ${mapping.unifiedEvent}`);
            } else {
              document.dispatchEvent(new CustomEvent(eventName, { detail: data }));
              Y3K?.debug?.warn("EventMigrationManager", `Unmapped legacy event emitted as DOM event: ${eventName}`);
            }
          } catch (error) {
            Y3K?.debug?.error("EventMigrationManager", `Failed to emit legacy event ${eventName}:`, error);
          }
        }
        /**
         * Register a new system as migrated
         */
        registerMigratedSystem(systemName) {
          this.metrics.systemsMigrated++;
          Y3K?.debug?.log("EventMigrationManager", `System migrated to unified events: ${systemName}`, {
            totalMigrated: this.metrics.systemsMigrated
          });
        }
        /**
         * Register a system as pending migration
         */
        registerPendingSystem(systemName) {
          this.metrics.systemsPending++;
          Y3K?.debug?.log("EventMigrationManager", `System pending migration: ${systemName}`, {
            totalPending: this.metrics.systemsPending
          });
        }
        /**
         * Add custom event mapping
         */
        addEventMapping(mapping) {
          this.eventMappings.push(mapping);
          const listener = /* @__PURE__ */ __name((event) => {
            const customEvent = event;
            this.handleLegacyDOMEvent(mapping, customEvent.detail);
          }, "listener");
          this.legacyDOMListeners.set(mapping.legacyEvent, listener);
          document.addEventListener(mapping.legacyEvent, listener);
          Y3K?.debug?.log("EventMigrationManager", `Custom event mapping added: ${mapping.legacyEvent} -> ${mapping.unifiedEvent}`);
        }
        /**
         * Remove event mapping (for systems that have been fully migrated)
         */
        removeEventMapping(legacyEventName) {
          const index = this.eventMappings.findIndex((m) => m.legacyEvent === legacyEventName);
          if (index !== -1) {
            const mapping = this.eventMappings[index];
            this.eventMappings.splice(index, 1);
            const listener = this.legacyDOMListeners.get(legacyEventName);
            if (listener) {
              document.removeEventListener(legacyEventName, listener);
              this.legacyDOMListeners.delete(legacyEventName);
            }
            Y3K?.debug?.log("EventMigrationManager", `Event mapping removed: ${legacyEventName} (system fully migrated)`);
            return true;
          }
          return false;
        }
        /**
         * Update conversion rate
         */
        updateConversionRate() {
          const totalEvents = this.metrics.totalLegacyEvents;
          this.metrics.conversionRate = totalEvents > 0 ? this.metrics.totalUnifiedEvents / totalEvents * 100 : 0;
        }
        /**
         * Get migration metrics
         */
        getMetrics() {
          return { ...this.metrics };
        }
        /**
         * Get list of deprecated events still being used
         */
        getDeprecatedEventsReport() {
          return this.eventMappings.filter((m) => m.deprecated).map((m) => ({
            eventName: m.legacyEvent,
            unifiedEquivalent: String(m.unifiedEvent),
            ...m.removalVersion && { removalVersion: m.removalVersion },
            usageCount: 0
            // Would need to track usage per event
          }));
        }
        /**
         * Get migration progress report
         */
        getMigrationReport() {
          const totalSystems = this.metrics.systemsMigrated + this.metrics.systemsPending;
          const migrationProgress = totalSystems > 0 ? this.metrics.systemsMigrated / totalSystems * 100 : 0;
          return {
            totalMappings: this.eventMappings.length,
            deprecatedMappings: this.eventMappings.filter((m) => m.deprecated).length,
            conversionRate: this.metrics.conversionRate,
            systemsMigrated: this.metrics.systemsMigrated,
            systemsPending: this.metrics.systemsPending,
            migrationProgress
          };
        }
        /**
         * Generate migration guide for a specific system
         */
        generateMigrationGuide(systemName, currentEvents) {
          let guide = `# Event Migration Guide for ${systemName}

`;
          guide += `## Current Events Used
`;
          currentEvents.forEach((eventName) => {
            const mapping = this.eventMappings.find((m) => m.legacyEvent === eventName);
            if (mapping) {
              guide += `- \`${eventName}\` \u2192 \`${String(mapping.unifiedEvent)}\``;
              if (mapping.deprecated) {
                guide += ` \u26A0\uFE0F **DEPRECATED** (will be removed in ${mapping.removalVersion || "future version"})`;
              }
              guide += `
`;
            } else {
              guide += `- \`${eventName}\` \u2192 \u274C **NO MAPPING FOUND** - needs custom migration
`;
            }
          });
          guide += `
## Migration Steps
`;
          guide += `1. Replace \`document.addEventListener\` with \`unifiedEventBus.subscribe\`
`;
          guide += `2. Replace \`document.dispatchEvent\` with \`unifiedEventBus.emit\`
`;
          guide += `3. Update event names to use unified naming convention
`;
          guide += `4. Update event data structures to match unified interfaces
`;
          guide += `5. Register system as migrated: \`eventMigrationManager.registerMigratedSystem('${systemName}')\`
`;
          return guide;
        }
        /**
         * Destroy migration manager and clean up all listeners
         */
        destroy() {
          this.legacyDOMListeners.forEach((listener, eventName) => {
            document.removeEventListener(eventName, listener);
          });
          this.legacyDOMListeners.clear();
          this.eventMappings = [];
          this.metrics = {
            totalLegacyEvents: 0,
            totalUnifiedEvents: 0,
            conversionRate: 0,
            deprecatedEventsUsed: 0,
            systemsMigrated: 0,
            systemsPending: 0
          };
          Y3K?.debug?.log("EventMigrationManager", "Event migration manager destroyed");
          _EventMigrationManager.instance = null;
        }
      };
      __name(_EventMigrationManager, "EventMigrationManager");
      _EventMigrationManager.instance = null;
      EventMigrationManager = _EventMigrationManager;
      eventMigrationManager = EventMigrationManager.getInstance();
    }
  });

  // src-js/utils/dom/NowPlayingDomWatcher.ts
  function startNowPlayingWatcher(onChange, enableDebug = false) {
    const bar = document.querySelector(
      MODERN_SELECTORS["nowPlayingBar"]
    );
    if (!bar) {
      if (enableDebug) {
        console.warn(
          "\u{1F3B5} [NowPlayingDomWatcher] nowPlayingBar element not found \u2013 watcher inactive"
        );
      }
      return () => {
      };
    }
    const mObserver = new MutationObserver(() => {
      onChange();
      if (enableDebug)
        console.log(
          "\u{1F3B5} [NowPlayingDomWatcher] DOM mutation detected \u2192 onChange dispatched"
        );
    });
    mObserver.observe(bar, { childList: true, subtree: true });
    if (enableDebug) console.log("\u{1F3B5} [NowPlayingDomWatcher] watcher active");
    return () => {
      mObserver.disconnect();
      if (enableDebug) console.log("\u{1F3B5} [NowPlayingDomWatcher] watcher disposed");
    };
  }
  var init_NowPlayingDomWatcher = __esm({
    "src-js/utils/dom/NowPlayingDomWatcher.ts"() {
      "use strict";
      init_SpotifyDOMSelectors();
      __name(startNowPlayingWatcher, "startNowPlayingWatcher");
    }
  });

  // src-js/visual/base/starryNightEffects.ts
  function injectStarContainer() {
    const existingContainer = document.querySelector(
      ".sn-stars-container"
    );
    if (existingContainer) {
      return existingContainer;
    }
    const starContainer = document.createElement("div");
    starContainer.className = "sn-stars-container";
    for (let i = 1; i <= 5; i++) {
      const star = document.createElement("div");
      star.className = "star";
      if (Math.random() > 0.7) star.classList.add("twinkle");
      starContainer.appendChild(star);
    }
    document.body.appendChild(starContainer);
    return starContainer;
  }
  function applyStarryNightSettings(gradientIntensity, starDensity) {
    if (YEAR3000_CONFIG.enableDebug) {
      console.log("[StarryNightEffects] Applying settings:", {
        gradientIntensity,
        starDensity
      });
    }
    const body = document.body;
    const gradientClasses = [
      "sn-gradient-disabled",
      "sn-gradient-minimal",
      "sn-gradient-balanced",
      "sn-gradient-intense"
    ];
    const starClasses = [
      "sn-stars-disabled",
      "sn-stars-minimal",
      "sn-stars-balanced",
      "sn-stars-intense"
    ];
    body.classList.remove(...gradientClasses, ...starClasses);
    if (gradientIntensity !== "balanced") {
      body.classList.add(`sn-gradient-${gradientIntensity}`);
    }
    if (starDensity !== "balanced") {
      body.classList.add(`sn-stars-${starDensity}`);
    }
    const existingContainer = document.querySelector(".sn-stars-container");
    if (starDensity === "disabled") {
      existingContainer?.remove();
    } else {
      if (!existingContainer) {
        injectStarContainer();
      }
    }
  }
  var init_starryNightEffects = __esm({
    "src-js/visual/base/starryNightEffects.ts"() {
      "use strict";
      init_SettingsManager();
      init_globalConfig();
      __name(injectStarContainer, "injectStarContainer");
      __name(applyStarryNightSettings, "applyStarryNightSettings");
    }
  });

  // src-js/core/lifecycle/year3000System.ts
  var _Year3000System, Year3000System, year3000System, year3000System_default;
  var init_year3000System = __esm({
    "src-js/core/lifecycle/year3000System.ts"() {
      "use strict";
      init_SystemCoordinator();
      init_ColorOrchestrator();
      init_ColorStateManager();
      init_EventBus();
      init_EventMigrationManager();
      init_UnifiedEventBus();
      init_globalConfig();
      init_Year3000Utilities();
      init_NowPlayingDomWatcher();
      init_starryNightEffects();
      _Year3000System = class _Year3000System {
        constructor(config = YEAR3000_CONFIG) {
          this.healthCheckInterval = null;
          // Phase 4: Facade Coordination System (replaces direct system properties)
          this.facadeCoordinator = null;
          // Color State Management System
          this.colorStateManager = null;
          // Private initialization results storage
          this._initializationResults = null;
          // Phase 1: Loop Prevention System - Processing State Tracking
          this.processingState = {
            isProcessingSongChange: false,
            lastProcessedTrackUri: null,
            lastProcessingTime: 0,
            processingChain: [],
            eventLoopDetected: false
          };
          this.colorEventState = {
            processedEvents: /* @__PURE__ */ new Map(),
            isProcessingColorEvent: false,
            eventTimeout: null
          };
          this.PROCESSING_TIMEOUT = 5e3;
          // 5 second safety timeout
          this.MAX_CHAIN_LENGTH = 10;
          // Prevent infinite chains
          this.COLOR_EVENT_CACHE_TTL = 2e3;
          // API availability tracking
          this.availableAPIs = null;
          this._songChangeHandler = null;
          // Stats
          this._lastInitializationTime = null;
          this._initializationRetryHistory = [];
          this._systemStartTime = null;
          this._disposeNowPlayingWatcher = null;
          /**
           * Indicates whether automatic harmonic evolution is permitted. This mirrors the
           * `sn-harmonic-evolution` setting and `YEAR3000_CONFIG.harmonicEvolution`.
           * Sub-systems can read this flag instead of accessing the config directly so
           * that future scheduling logic (e.g. TimerConsolidationSystem) can rely on a
           * guaranteed field.
           */
          this.allowHarmonicEvolution = true;
          /** Global switch other systems can read to know guardrails are active */
          this.performanceGuardActive = false;
          this.YEAR3000_CONFIG = this._deepCloneConfig(config);
          if (typeof this.YEAR3000_CONFIG.init === "function") {
            this.YEAR3000_CONFIG.init();
          }
          this.utils = Year3000Utilities_exports;
          this.initialized = false;
          this._systemStartTime = Date.now();
          this._initializationResults = null;
          if (this.YEAR3000_CONFIG?.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Constructor: Instance created with Enhanced Master Animation Coordinator"
            );
          }
          this._boundExternalSettingsHandler = this._handleExternalSettingsChange.bind(this);
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this._boundExternalSettingsHandler
          );
          this._boundArtisticModeHandler = this._onArtisticModeChanged.bind(this);
          document.addEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          this._boundVisibilityChangeHandler = this._handleVisibilityChange.bind(this);
          document.addEventListener(
            "visibilitychange",
            this._boundVisibilityChangeHandler
          );
          this._disposeNowPlayingWatcher = startNowPlayingWatcher(() => {
            const timestamp = Date.now().toString();
            this.queueCSSVariableUpdate("--sn-force-refresh", timestamp);
            GlobalEventBus.emit("music:now-playing-changed", {
              timestamp: parseInt(timestamp),
              source: "NowPlayingDomWatcher",
              reason: "Music track or state changed"
            });
          }, this.YEAR3000_CONFIG.enableDebug);
          this.allowHarmonicEvolution = this.YEAR3000_CONFIG.harmonicEvolution ?? true;
          setTimeout(() => {
            this._applyPerformanceProfile();
          }, 0);
        }
        // 2 second cache
        // Phase 4: Pure Facade Access Property Getters
        // Performance Systems
        get enhancedMasterAnimationCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("EnhancedMasterAnimationCoordinator") || null;
        }
        get timerConsolidationSystem() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("TimerConsolidationSystem") || null;
        }
        get cssConsciousnessController() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedCSSConsciousnessController") || null;
        }
        // Legacy compatibility getters
        get unifiedCSSManager() {
          return this.cssConsciousnessController || null;
        }
        get performanceCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedPerformanceCoordinator") || null;
        }
        get deviceCapabilityDetector() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("DeviceCapabilityDetector") || null;
        }
        get performanceAnalyzer() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("PerformanceAnalyzer") || null;
        }
        get unifiedPerformanceCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedPerformanceCoordinator") || null;
        }
        get performanceCSSIntegration() {
          return this.cssConsciousnessController || null;
        }
        get performanceOrchestrator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("PerformanceOrchestrator") || null;
        }
        get qualityScalingManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("QualityScalingManager") || null;
        }
        get performanceBudgetManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("PerformanceBudgetManager") || null;
        }
        // Managers and Services
        get systemHealthMonitor() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedDebugManager") || null;
        }
        get settingsManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("SettingsManager") || null;
        }
        get colorHarmonyEngine() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("ColorHarmonyEngine") || null;
        }
        // 🔧 PHASE 3: Unified Color Processing Access 
        get unifiedColorProcessingEngine() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedColorProcessingEngine") || null;
        }
        get musicColorIntegrationBridge() {
          return null;
        }
        // 🔧 PHASE 3: Legacy Compatibility - Delegate to Unified Systems
        get colorEventOrchestrator() {
          const unified = this.unifiedColorProcessingEngine;
          return unified ? unified : null;
        }
        get colorOrchestrator() {
          const unified = this.unifiedColorProcessingEngine;
          return unified ? unified : null;
        }
        get enhancedColorOrchestrator() {
          const unified = this.unifiedColorProcessingEngine;
          return unified ? unified : null;
        }
        get colorConsciousnessState() {
          return this.unifiedConsciousnessCoordinator || null;
        }
        get musicSyncService() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("MusicSyncService") || null;
        }
        get glassmorphismManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("GlassmorphismManager") || null;
        }
        get card3DManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("Card3DManager") || null;
        }
        // Consciousness Systems
        get genreGradientEvolution() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("GenreGradientEvolution") || null;
        }
        get musicEmotionAnalyzer() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("MusicEmotionAnalyzer") || null;
        }
        // 🔧 PHASE 4: Unified Consciousness Coordination
        get unifiedConsciousnessCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedConsciousnessCoordinator") || null;
        }
        // 🔧 PHASE 4: Backward compatibility delegation for consolidated consciousness systems
        get colorConsciousnessManager() {
          return this.unifiedConsciousnessCoordinator || null;
        }
        get dynamicCatppuccinBridge() {
          return this.unifiedConsciousnessCoordinator || null;
        }
        // Visual Systems
        get particleConsciousnessModule() {
          return this.facadeCoordinator?.getVisualSystem("Particle") || null;
        }
        get sidebarConsciousnessController() {
          return this.facadeCoordinator?.getVisualSystem("SidebarConsciousness") || null;
        }
        get uiEffectsConsciousnessController() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get headerConsciousnessController() {
          return this.facadeCoordinator?.getVisualSystem("HeaderConsciousness") || null;
        }
        // Legacy compatibility getters
        get lightweightParticleSystem() {
          return this.facadeCoordinator?.getVisualSystem("Particle") || null;
        }
        // UI Effects systems now consolidated into ConsciousnessUIEffectsController
        get iridescentShimmerEffectsSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get interactionTrackingSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get whiteLayerDiagnosticSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get audioVisualController() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get prismaticScrollSheenSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIEffectsConsciousness") || null;
        }
        get beatSyncVisualSystem() {
          return this.facadeCoordinator?.getVisualSystem("OrganicBeatSync") || null;
        }
        get webGLGradientBackgroundSystem() {
          return this.facadeCoordinator?.getVisualSystem("WebGLBackground") || null;
        }
        // Legacy compatibility - particleFieldSystem consolidated into particleConsciousnessModule
        get particleFieldSystem() {
          return this.facadeCoordinator?.getVisualSystem("Particle") || null;
        }
        get emergentChoreographyEngine() {
          return this.enhancedMasterAnimationCoordinator || null;
        }
        get spotifyUIApplicationSystem() {
          return this.facadeCoordinator?.getVisualSystem("SpotifyUIApplication") || null;
        }
        // Organic Consciousness System (Year 3000 Philosophy)
        get organicBeatSyncConsciousness() {
          return this.facadeCoordinator?.getVisualSystem("OrganicBeatSync") || this.beatSyncVisualSystem;
        }
        // Integration Systems Getters
        get sidebarSystemsIntegration() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("SidebarSystemsIntegration") || null;
        }
        _deepCloneConfig(config) {
          return config;
        }
        updateConfiguration(key, value) {
          if (!this.YEAR3000_CONFIG) {
            console.warn(
              "[Year3000System] Cannot update configuration - config not initialized"
            );
            return;
          }
          const keyPath = key.split(".").filter(Boolean);
          if (!keyPath.length) {
            return;
          }
          let current = this.YEAR3000_CONFIG;
          const finalKey = keyPath.pop();
          if (!finalKey) {
            return;
          }
          for (const pathKey of keyPath) {
            if (typeof current[pathKey] !== "object" || current[pathKey] === null) {
              current[pathKey] = {};
            }
            current = current[pathKey];
          }
          const oldValue = current[finalKey];
          current[finalKey] = value;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `[Year3000System] Configuration updated: ${key} = ${value} (was: ${oldValue})`
            );
          }
          this._notifyConfigurationChange(key, value, oldValue);
        }
        _notifyConfigurationChange(key, newValue, oldValue) {
        }
        async initializeAllSystems() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F30C} [Year3000System] initializeAllSystems(): Starting full system initialization..."
            );
          }
          this._systemStartTime = Date.now();
          const startTime = performance.now();
          const initializationResults = {
            success: [],
            failed: [],
            skipped: []
          };
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F30C} [Year3000System] Initializing Facade Coordination System...");
          }
          try {
            this.facadeCoordinator = new SystemCoordinator(
              this.YEAR3000_CONFIG,
              this.utils,
              this
            );
            await this.facadeCoordinator.initialize({
              mode: "unified",
              enableSharedDependencies: true,
              enableCrossFacadeCommunication: true,
              enableUnifiedPerformanceMonitoring: true,
              enableResourceOptimization: true,
              orchestration: {
                enforceSequentialInitialization: true,
                dependencyValidation: true,
                enableInitializationGates: true,
                systemReadinessTimeout: 5e3,
                phaseTransitionTimeout: 1e4
              },
              performanceThresholds: {
                maxTotalMemoryMB: 100,
                maxTotalInitTime: 5e3,
                maxCrossCommLatency: 50
              },
              coordinationPreferences: {
                preferSharedResources: true,
                enableEventPropagation: true,
                enableHealthCoordination: true
              }
            });
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Facade Coordination System initialized successfully");
            }
            const eventMigrationManager2 = EventMigrationManager.getInstance();
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] EventMigrationManager initialized for event bridging");
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing ColorStateManager...");
            }
            try {
              this.colorStateManager = globalColorStateManager;
              if (!this.colorStateManager.initialized) {
                await this.colorStateManager.initialize();
              }
              initializationResults.success.push("ColorStateManager");
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] ColorStateManager initialized successfully");
              }
            } catch (error) {
              console.error("\u{1F30C} [Year3000System] Failed to initialize ColorStateManager:", error);
              initializationResults.failed.push("ColorStateManager");
            }
            await this._initializeFacadeSystems();
          } catch (error) {
            console.error("\u{1F30C} [Year3000System] Failed to initialize Facade Coordination System:", error);
            throw error;
          }
          initializationResults.success.push("FacadeCoordinationSystem");
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.startMonitoring();
            this.performanceGuardActive = true;
          }
          if (this.enhancedMasterAnimationCoordinator) {
            await this._registerEnhancedAnimationSystems();
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F3AC} [Year3000System] Enhanced animation system registration phase complete"
              );
            }
          } else {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for enhanced registration phase"
            );
          }
          this._initializationResults = initializationResults;
          this.initialized = true;
          const endTime = performance.now();
          this._lastInitializationTime = endTime - startTime;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `[Year3000System] System initialization complete in ${this._lastInitializationTime.toFixed(
                2
              )}ms.`
            );
            console.log(
              `[Year3000System] Results: ${initializationResults.success.length} success, ${initializationResults.failed.length} failed.`
            );
            if (initializationResults.failed.length > 0) {
              console.warn(
                `[Year3000System] Failed systems: ${initializationResults.failed.join(
                  ", "
                )}`
              );
            }
            if (initializationResults.skipped && initializationResults.skipped.length > 0) {
              console.info(
                `[Year3000System] Skipped systems: ${initializationResults.skipped.join(
                  ", "
                )}`
              );
            }
            if (initializationResults.success.length > 0) {
              console.info(
                `[Year3000System] Successful systems: ${initializationResults.success.join(
                  ", "
                )}`
              );
            }
            if (this.systemHealthMonitor) {
              this.systemHealthMonitor.logHealthReport();
            }
          }
        }
        /**
         * Initialize essential systems for degraded mode (no Spicetify APIs)
         * Phase 4: Essential system initialization for degraded mode
         */
        async _initializeEssentialFacadeSystems() {
          if (!this.facadeCoordinator) {
            throw new Error("Facade coordinator not available for essential system initialization");
          }
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F30C} [Year3000System] Initializing essential systems for degraded mode...");
          }
          try {
            const essentialSystems = [
              "PerformanceAnalyzer",
              "UnifiedCSSConsciousnessController",
              "UnifiedDebugManager",
              "DeviceCapabilityDetector",
              "TimerConsolidationSystem"
            ];
            for (const systemKey of essentialSystems) {
              try {
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] Essential: Initialized ${systemKey} via facade`);
                  }
                }
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] Failed to initialize essential ${systemKey}:`, error);
              }
            }
            if (this.performanceAnalyzer) {
              this.performanceAnalyzer.startMonitoring();
              this.performanceGuardActive = true;
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] Essential: Performance monitoring started");
              }
            }
          } catch (error) {
            console.error("\u{1F30C} [Year3000System] Essential facade system initialization failed:", error);
            throw error;
          }
        }
        /**
         * Initialize essential systems through facade pattern
         * Phase 4: Core system initialization via facades
         */
        async _initializeFacadeSystems() {
          if (!this.facadeCoordinator) {
            throw new Error("Facade coordinator not available for system initialization");
          }
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F30C} [Year3000System] Initializing essential systems through facades...");
          }
          try {
            const essentialNonVisualSystems = [
              "PerformanceAnalyzer",
              "UnifiedCSSConsciousnessController",
              "UnifiedDebugManager",
              "SettingsManager",
              "DeviceCapabilityDetector",
              "TimerConsolidationSystem",
              "UnifiedPerformanceCoordinator",
              "MusicSyncService",
              "ColorHarmonyEngine",
              "GenreGradientEvolution",
              // 🎵 Genre-specific visual consciousness
              "MusicEmotionAnalyzer",
              // 🎭 Emotional intelligence for music analysis
              "GlassmorphismManager",
              // 🌊 Essential glassmorphism effects
              "Card3DManager"
              // 🎴 Essential 3D card transformations
            ];
            for (const systemKey of essentialNonVisualSystems) {
              try {
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] Initialized ${systemKey} via facade`);
                  }
                }
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] Failed to initialize ${systemKey}:`, error);
              }
            }
            try {
              await globalColorOrchestrator.initialize();
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F3A8} [Year3000System] ColorOrchestrator initialized for strategy pattern coordination");
              }
            } catch (error) {
              console.error("\u{1F3A8} [Year3000System] Failed to initialize ColorOrchestrator:", error);
            }
            if (this.performanceAnalyzer) {
              this.performanceAnalyzer.startMonitoring();
              this.performanceGuardActive = true;
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] Performance monitoring started");
              }
            }
            const essentialVisualSystems = [
              "Particle",
              // ParticleField consolidated into Particle (ParticleConsciousnessModule)
              "WebGLBackground",
              // 🌌 Enable WebGL gradient backgrounds
              "SpotifyUIApplication",
              // 🎨 Core UI color application
              "OrganicBeatSync",
              "HeaderConsciousness",
              // 🎭 Music-responsive header consciousness animations
              "InteractionTracking"
              // EmergentChoreography integrated into EnhancedMasterAnimationCoordinator
            ];
            for (const systemKey of essentialVisualSystems) {
              try {
                const system = this.facadeCoordinator.getVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] Initialized visual ${systemKey} via facade`);
                  }
                }
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] Failed to initialize visual ${systemKey}:`, error);
              }
            }
            await this._linkSystemDependencies();
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Facade system initialization complete");
            }
          } catch (error) {
            console.error("\u{1F30C} [Year3000System] Facade system initialization failed:", error);
            throw error;
          }
        }
        /**
         * Link system dependencies after facade initialization
         * Phase 4: Connect systems that need cross-references
         */
        async _linkSystemDependencies() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F30C} [Year3000System] Linking system dependencies...");
          }
          try {
            if (this.musicSyncService && this.colorHarmonyEngine) {
              this.musicSyncService.setColorHarmonyEngine(this.colorHarmonyEngine);
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] ColorHarmonyEngine linked to MusicSyncService");
              }
            }
            if (this.colorHarmonyEngine && this.enhancedMasterAnimationCoordinator) {
              this.colorHarmonyEngine.setEmergentEngine(this.enhancedMasterAnimationCoordinator);
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] EnhancedMasterAnimationCoordinator (with emergent functionality) linked to ColorHarmonyEngine");
              }
            }
            if (this.systemHealthMonitor) {
              const systemsToRegister = [
                { name: "MusicSyncService", system: this.musicSyncService },
                { name: "ColorHarmonyEngine", system: this.colorHarmonyEngine },
                { name: "SettingsManager", system: this.settingsManager }
              ];
              for (const { name, system } of systemsToRegister) {
                if (system) {
                  this.systemHealthMonitor.registerSystem(name, system);
                }
              }
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] Systems registered with health monitor");
              }
            }
          } catch (error) {
            console.error("\u{1F30C} [Year3000System] Failed to link system dependencies:", error);
          }
        }
        /**
         * Legacy function - removed prediction systems entirely for performance optimization
         */
        _shouldSkipPredictionSystem(systemName) {
          return false;
          if (!this.deviceCapabilityDetector) {
            return false;
          }
          const performanceLevel = this.deviceCapabilityDetector.recommendPerformanceQuality();
          if (performanceLevel === "low") {
            return true;
          }
          if (this.deviceCapabilityDetector.deviceCapabilities?.display?.reducedMotion) {
            return true;
          }
          return false;
        }
        async _initializeVisualSystems(results) {
          if (!this.performanceAnalyzer || !this.musicSyncService || !this.settingsManager) {
            console.error(
              "[Year3000System] Cannot initialize visual systems due to missing core dependencies (PerformanceAnalyzer, MusicSyncService, or SettingsManager)."
            );
            const visualSystems = [
              "LightweightParticleSystem",
              "InteractionTrackingSystem",
              "BeatSyncVisualSystem",
              "SidebarSystemsIntegration"
              // "EmergentChoreographyEngine", // Consolidated into EnhancedMasterAnimationCoordinator
            ];
            visualSystems.forEach((s) => results.skipped.push(s));
            return;
          }
          if (this.colorHarmonyEngine && this.enhancedMasterAnimationCoordinator) {
            this.colorHarmonyEngine.setEmergentEngine(
              this.enhancedMasterAnimationCoordinator
            );
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F517} [Year3000System] EnhancedMasterAnimationCoordinator (emergent functionality) linked to ColorHarmonyEngine."
              );
            }
          }
        }
        async destroyAllSystems() {
          if (this.facadeCoordinator) {
            await this.facadeCoordinator.destroy();
            this.facadeCoordinator = null;
          }
          this._initializationResults = null;
          if (Spicetify.Player && this._songChangeHandler) {
            Spicetify.Player.removeEventListener(
              "songchange",
              this._songChangeHandler
            );
          }
          this.initialized = false;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F525} [Year3000System] All systems have been destroyed.");
          }
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this._boundExternalSettingsHandler
          );
          document.removeEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          document.removeEventListener(
            "visibilitychange",
            this._boundVisibilityChangeHandler
          );
          if (this._disposeNowPlayingWatcher) {
            this._disposeNowPlayingWatcher();
            this._disposeNowPlayingWatcher = null;
          }
        }
        async applyInitialSettings(trigger) {
          if (!this.settingsManager) {
            console.warn(
              "[Year3000System] SettingsManager not ready, cannot apply initial settings."
            );
            return;
          }
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `\u{1F3A8} [Year3000System] Inside applyInitialSettings. Trigger: ${trigger || "full"}, SettingsManager valid:`,
              !!this.settingsManager
            );
          }
          try {
            if (trigger === "flavor" || trigger === "brightness" || trigger === "accent") {
              console.log(`\u{1F3A8} [Year3000System] Selective update for trigger: ${trigger}`);
              await this.updateColorStateOnly(trigger);
              await this.refreshColorDependentSystems(trigger);
              return;
            }
            console.log(
              "\u{1F3A8} [Year3000System] applyInitialSettings: Getting initial settings..."
            );
            if (this.colorStateManager && !this.colorStateManager.initialized) {
              console.log("\u{1F3A8} [Year3000System] Initializing ColorStateManager...");
              await this.colorStateManager.initialize();
            }
            if (this.colorStateManager?.initialized) {
              console.log("\u{1F3A8} [Year3000System] Applying initial color state via ColorStateManager...");
              await this.colorStateManager.applyInitialColorState();
            } else {
              console.warn("\u{1F3A8} [Year3000System] ColorStateManager not available, using legacy color application");
              const accent = this.settingsManager.get("catppuccin-accentColor");
              if (accent !== "dynamic") {
                await this._applyCatppuccinAccent(accent);
              }
            }
            const gradient = this.settingsManager.get("sn-gradient-intensity");
            const stars = this.settingsManager.get("sn-star-density");
            const intensityRaw = this.settingsManager.get("sn-harmonic-intensity");
            const evolutionRaw = this.settingsManager.get("sn-harmonic-evolution");
            const harmonicModeKey = this.settingsManager.get(
              "sn-current-harmonic-mode"
            );
            if (harmonicModeKey) {
              this.YEAR3000_CONFIG.currentHarmonicMode = String(harmonicModeKey);
            }
            console.log(
              `\u{1F3A8} [Year3000System] applyInitialSettings: Gradient=${gradient}, Stars=${stars}, ColorState=${!!this.colorStateManager?.initialized}`
            );
            await this._applyStarryNightSettings(
              gradient,
              stars
            );
            const intensity = parseFloat(intensityRaw);
            if (!Number.isNaN(intensity)) {
              if (this.colorHarmonyEngine) {
                this.colorHarmonyEngine.setIntensity?.(intensity);
              }
              this.YEAR3000_CONFIG.harmonicIntensity = intensity;
            }
            const evolutionEnabled = evolutionRaw === "true";
            this.allowHarmonicEvolution = evolutionEnabled;
            this.YEAR3000_CONFIG.harmonicEvolution = evolutionEnabled;
            console.log(
              "\u{1F3A8} [Year3000System] applyInitialSettings: Successfully applied initial settings."
            );
          } catch (error) {
            console.error("[Year3000System] Error applying initial settings:", error);
          }
        }
        /**
         * Update only color state without full settings reload
         */
        async updateColorStateOnly(trigger) {
          if (!this.colorStateManager?.initialized) {
            console.warn(`\u{1F3A8} [Year3000System] ColorStateManager not available for ${trigger} update`);
            return;
          }
          console.log(`\u{1F3A8} [Year3000System] Updating color state for trigger: ${trigger}`);
          await this.colorStateManager.updateColorState(trigger);
        }
        /**
         * Refresh only color-dependent systems efficiently
         */
        async refreshColorDependentSystems(trigger) {
          if (!this.facadeCoordinator) {
            console.warn(`\u{1F3A8} [Year3000System] No facade coordinator available for ${trigger} refresh`);
            return;
          }
          console.log(`\u{1F3A8} [Year3000System] Refreshing color-dependent systems for trigger: ${trigger}`);
          await this.facadeCoordinator.refreshColorDependentSystems(trigger);
        }
        async _applyCatppuccinAccent(selectedAccent) {
          if (selectedAccent === "dynamic") {
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F3A8} [Year3000System] _applyCatppuccinAccent: 'dynamic' accent selected \u2013 skipping static accent overrides."
              );
            }
            return;
          }
          console.log(
            `\u{1F3A8} [Year3000System] _applyCatppuccinAccent: Applying accent color '${selectedAccent}'`
          );
          const accent = selectedAccent === "none" ? "text" : selectedAccent;
          const colorScheme = Spicetify.Config.color_scheme || "mocha";
          const equalizerUrl = document.querySelector(
            "body > script.marketplaceScript"
          ) ? `url('https://github.com/catppuccin/spicetify/blob/main/catppuccin/assets/${colorScheme}/equalizer-animated-${accent}.gif?raw=true')` : `url('${colorScheme}/equalizer-animated-${accent}.gif')`;
          this.cssConsciousnessController?.queueCSSVariableUpdate(
            "--spice-text",
            `var(--spice-${accent})`
          );
          this.cssConsciousnessController?.queueCSSVariableUpdate(
            "--spice-button-active",
            `var(--spice-${accent})`
          );
          this.cssConsciousnessController?.queueCSSVariableUpdate(
            "--spice-equalizer",
            equalizerUrl
          );
          this.cssConsciousnessController?.flushCSSVariableBatch();
          console.log(
            `\u{1F3A8} [Year3000System] _applyCatppuccinAccent: Flushed CSS variables for accent color.`
          );
        }
        async _applyStarryNightSettings(gradientIntensity, starDensity) {
          try {
            applyStarryNightSettings(gradientIntensity, starDensity);
          } catch (error) {
            console.error("[Year3000System] Failed to apply starry night settings");
          }
        }
        applyColorsToTheme(extractedColors = {}) {
          let harmonizedColors = extractedColors;
          if (this.colorHarmonyEngine) {
            try {
              harmonizedColors = this.colorHarmonyEngine.blendWithCatppuccin(extractedColors);
            } catch (error) {
              console.error(
                "[Year3000System] ColorHarmonyEngine blend failed:",
                error
              );
            }
          }
          const accentHex = harmonizedColors.accentHex || harmonizedColors.VIBRANT || harmonizedColors.PROMINENT || Object.values(harmonizedColors)[0] || "#a6adc8";
          const accentRgb = harmonizedColors.accentRgb || (() => {
            const rgb = this.utils.hexToRgb(accentHex);
            return rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "166,173,200";
          })();
          this._applyColorsViaFacadeSystem(harmonizedColors, accentHex, accentRgb);
        }
        /**
         * Handle colors:harmonized event from ColorHarmonyEngine (Event-driven architecture)
         * 🔧 PHASE 1: Enhanced with loop prevention and recursion protection
         */
        handleColorHarmonizedEvent(data) {
          if (this.colorEventState.isProcessingColorEvent) {
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.warn("\u{1F504} [Year3000System] Already processing color event - skipping to prevent recursion");
            }
            return;
          }
          const eventContext = JSON.stringify(data).substring(0, 100);
          const eventHash = this._generateEventHash(eventContext);
          const now = Date.now();
          if (this.colorEventState.processedEvents.has(eventHash)) {
            const lastProcessed = this.colorEventState.processedEvents.get(eventHash);
            if (now - lastProcessed < this.COLOR_EVENT_CACHE_TTL) {
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.warn("\u{1F504} [Year3000System] Event recently processed - skipping duplicate");
              }
              return;
            }
          }
          this.colorEventState.isProcessingColorEvent = true;
          this.colorEventState.processedEvents.set(eventHash, now);
          this.colorEventState.eventTimeout = window.setTimeout(() => {
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.warn("\u{1F504} [Year3000System] Color event processing timeout - resetting state");
            }
            this._resetColorEventState();
          }, this.PROCESSING_TIMEOUT);
          try {
            this.processingState.processingChain.push("handleColorHarmonizedEvent");
            if (this.processingState.processingChain.length > this.MAX_CHAIN_LENGTH) {
              this.processingState.eventLoopDetected = true;
              console.error("\u{1F504} [Year3000System] CRITICAL: Event loop detected - chain length exceeded", this.processingState.processingChain);
              this._resetProcessingState();
              return;
            }
            let processedColors;
            let accentHex;
            let accentRgb;
            let strategies;
            let processingTime;
            if (data.processedColors && data.accentHex && data.accentRgb) {
              processedColors = data.processedColors;
              accentHex = data.accentHex;
              accentRgb = data.accentRgb;
              strategies = data.strategies || ["ColorHarmonyEngine"];
              processingTime = data.processingTime || 0;
            } else if (data.payload && data.payload.processedColors) {
              processedColors = data.payload.processedColors;
              accentHex = data.payload.accentHex || Object.values(processedColors)[0] || "#a6adc8";
              accentRgb = this.utils.hexToRgb(accentHex)?.r + "," + this.utils.hexToRgb(accentHex)?.g + "," + this.utils.hexToRgb(accentHex)?.b || "166,173,200";
              strategies = [data.payload.metadata?.strategy || "Unknown"];
              processingTime = data.payload.metadata?.processingTime || 0;
            } else if (data.type === "colors/harmonized") {
              return;
            } else {
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.warn("\u{1F3A8} [Year3000System] Unrecognized colors:harmonized event format:", data);
              }
              return;
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Processing colors:harmonized event:", {
                strategies,
                processingTime,
                colorsCount: Object.keys(processedColors).length,
                accentHex,
                accentRgb,
                chainLength: this.processingState.processingChain.length
              });
            }
            this._applyColorsViaFacadeSystem(processedColors, accentHex, accentRgb);
          } catch (error) {
            console.error("[Year3000System] Failed to handle colors:harmonized event:", error);
          } finally {
            this._resetColorEventState();
            const chainIndex = this.processingState.processingChain.indexOf("handleColorHarmonizedEvent");
            if (chainIndex > -1) {
              this.processingState.processingChain.splice(chainIndex, 1);
            }
          }
        }
        /**
         * Phase 1: Helper method to generate simple hash for event caching
         */
        _generateEventHash(context) {
          let hash = 0;
          for (let i = 0; i < context.length; i++) {
            const char = context.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
          }
          return hash.toString();
        }
        /**
         * Phase 1: Reset color event processing state
         */
        _resetColorEventState() {
          this.colorEventState.isProcessingColorEvent = false;
          if (this.colorEventState.eventTimeout) {
            clearTimeout(this.colorEventState.eventTimeout);
            this.colorEventState.eventTimeout = null;
          }
          const now = Date.now();
          for (const [hash, timestamp] of this.colorEventState.processedEvents.entries()) {
            if (now - timestamp > this.COLOR_EVENT_CACHE_TTL) {
              this.colorEventState.processedEvents.delete(hash);
            }
          }
        }
        /**
         * Phase 1: Reset processing state after loop detection or timeout
         */
        _resetProcessingState() {
          this.processingState.isProcessingSongChange = false;
          this.processingState.processingChain = [];
          this.processingState.eventLoopDetected = false;
          this.processingState.lastProcessingTime = Date.now();
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F504} [Year3000System] Processing state reset");
          }
        }
        /**
         * Apply colors via the facade system for comprehensive UI component update
         * 🔧 CRITICAL FIX: New method to ensure colors reach all UI components
         */
        _applyColorsViaFacadeSystem(processedColors, accentHex, accentRgb) {
          try {
            const cssVariables = {
              // Core accent variables
              "--sn-accent-hex": accentHex,
              "--sn-accent-rgb": accentRgb,
              "--sn-dynamic-accent-hex": accentHex,
              "--sn-dynamic-accent-rgb": accentRgb,
              // Spicetify core variables for broad compatibility
              "--spice-accent": accentHex,
              "--spice-button": accentHex,
              "--spice-button-active": accentHex,
              "--spice-rgb-accent": accentRgb,
              "--spice-rgb-button": accentRgb,
              "--spice-text-accent": accentHex,
              // Sidebar-specific variables
              "--sn-sidebar-entanglement-color-rgb": accentRgb,
              "--sn-sidebar-accent-color": accentHex,
              "--sn-sidebar-accent-rgb": accentRgb,
              "--sn-sidebar-dynamic-accent": accentHex,
              // Now-playing specific variables
              "--sn-nowplaying-accent-color": accentHex,
              "--sn-nowplaying-accent-rgb": accentRgb,
              "--sn-nowplaying-primary-color": accentHex,
              "--sn-nowplaying-primary-rgb": accentRgb,
              // Main feed / content variables
              "--sn-main-feed-accent-color": accentHex,
              "--sn-main-feed-accent-rgb": accentRgb,
              "--sn-content-accent-color": accentHex,
              "--sn-content-accent-rgb": accentRgb
            };
            Object.entries(processedColors).forEach(([key, value]) => {
              if (this.utils.isValidHexColor(value)) {
                const rgb = this.utils.hexToRgb(value);
                if (rgb) {
                  cssVariables[`--sn-processed-${key.toLowerCase()}-hex`] = value;
                  cssVariables[`--sn-processed-${key.toLowerCase()}-rgb`] = `${rgb.r},${rgb.g},${rgb.b}`;
                }
              } else if (this.YEAR3000_CONFIG.enableDebug) {
                console.debug(`[Year3000System] Skipping non-hex processedColor: ${key}=${value}`);
              }
            });
            const oklabMapping = {
              // Primary album colors from OKLAB processing - fixed key mapping
              "--sn-musical-oklab-primary-rgb": processedColors.VIBRANT || processedColors.PRIMARY || processedColors.PROMINENT || accentRgb,
              "--sn-musical-oklab-accent-rgb": processedColors.DARK_VIBRANT || processedColors.DESATURATED || accentRgb,
              "--sn-musical-oklab-highlight-rgb": processedColors.VIBRANT_NON_ALARMING || processedColors.LIGHT_VIBRANT || accentRgb,
              "--sn-musical-oklab-shadow-rgb": processedColors.DARK_VIBRANT || processedColors.DESATURATED || accentRgb,
              // Complementary colors for advanced harmony - fixed key mapping
              "--sn-musical-oklab-complementary-rgb": processedColors.SECONDARY || processedColors.EMOTIONAL_BLEND || accentRgb,
              "--sn-musical-oklab-triadic-rgb": processedColors.LIGHT_VIBRANT || processedColors.VIBRANT_NON_ALARMING || accentRgb
            };
            const musicalHarmonyMapping = {
              // Musical harmony RGB variables for complete CSS chain
              "--sn-musical-harmony-primary-rgb": processedColors.VIBRANT || processedColors.PRIMARY || accentRgb,
              "--sn-musical-harmony-secondary-rgb": processedColors.DARK_VIBRANT || processedColors.SECONDARY || accentRgb,
              "--sn-musical-harmony-tertiary-rgb": processedColors.VIBRANT_NON_ALARMING || processedColors.LIGHT_VIBRANT || accentRgb,
              "--sn-musical-harmony-quaternary-rgb": processedColors.DESATURATED || processedColors.EMOTIONAL_BLEND || accentRgb,
              // Musical harmony hex variables for complete coverage
              "--sn-musical-harmony-primary-hex": processedColors.VIBRANT || processedColors.PRIMARY || accentHex,
              "--sn-musical-harmony-secondary-hex": processedColors.DARK_VIBRANT || processedColors.SECONDARY || accentHex,
              "--sn-musical-harmony-tertiary-hex": processedColors.VIBRANT_NON_ALARMING || processedColors.LIGHT_VIBRANT || accentHex,
              "--sn-musical-harmony-quaternary-hex": processedColors.DESATURATED || processedColors.EMOTIONAL_BLEND || accentHex
            };
            Object.entries(oklabMapping).forEach(([cssVar, colorValue]) => {
              if (!colorValue || typeof colorValue !== "string") return;
              if (cssVar.includes("-rgb")) {
                if (this.utils.isValidHexColor(colorValue)) {
                  const rgb = this.utils.hexToRgb(colorValue);
                  if (rgb) {
                    cssVariables[cssVar] = `${rgb.r},${rgb.g},${rgb.b}`;
                  }
                } else if (colorValue.includes(",")) {
                  cssVariables[cssVar] = colorValue;
                }
              }
            });
            Object.entries(musicalHarmonyMapping).forEach(([cssVar, colorValue]) => {
              if (!colorValue || typeof colorValue !== "string") return;
              if (cssVar.includes("-hex")) {
                cssVariables[cssVar] = colorValue;
              } else if (cssVar.includes("-rgb")) {
                if (this.utils.isValidHexColor(colorValue)) {
                  const rgb = this.utils.hexToRgb(colorValue);
                  if (rgb) {
                    cssVariables[cssVar] = `${rgb.r},${rgb.g},${rgb.b}`;
                  }
                } else if (colorValue.includes(",")) {
                  cssVariables[cssVar] = colorValue;
                }
              }
            });
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Complete Album Color Flow:", {
                // ColorHarmonyEngine output
                colorHarmonyKeys: Object.keys(processedColors),
                colorHarmonyValues: processedColors,
                // OKLAB variable mapping
                oklabVariables: oklabMapping,
                // Musical harmony bridge
                musicalHarmonyVariables: musicalHarmonyMapping,
                // CSS variable chain status
                expectedCSSChain: [
                  "--sn-musical-oklab-primary-rgb",
                  "--sn-musical-harmony-primary-rgb",
                  "--sn-gradient-primary-rgb"
                ],
                // Total variables set
                totalVariablesSet: Object.keys(cssVariables).length
              });
            }
            if (this.cssConsciousnessController && typeof this.cssConsciousnessController.batchSetVariables === "function") {
              this.cssConsciousnessController.batchSetVariables(
                "Year3000System-ColorHarmonized",
                cssVariables,
                "high",
                "color-harmony-event-application"
              );
            } else {
              this._applyCSSVariables(cssVariables);
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F527} [Year3000System] Applied colors via facade system:", {
                totalVariables: Object.keys(cssVariables).length,
                accentColor: accentHex,
                facadeSystemUsed: !!this.cssConsciousnessController
              });
            }
          } catch (error) {
            console.error("[Year3000System] Failed to apply colors via facade system:", error);
            const fallbackVariables = {
              "--spice-accent": accentHex,
              "--sn-accent-hex": accentHex,
              "--sn-accent-rgb": accentRgb
            };
            this._applyCSSVariables(fallbackVariables);
          }
        }
        /**
         * Apply CSS variables directly (optimization for event-driven pattern)
         */
        _applyCSSVariables(cssVariables) {
          try {
            const root = document.documentElement;
            for (const [variable, value] of Object.entries(cssVariables)) {
              if (variable && value) {
                root.style.setProperty(variable, value);
              }
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Applied CSS variables directly", {
                variablesCount: Object.keys(cssVariables).length,
                variables: Object.keys(cssVariables)
              });
            }
          } catch (error) {
            console.error("[Year3000System] Failed to apply CSS variables:", error);
          }
        }
        // =============================================
        // 🎨 LEGACY METHOD REMOVED: _applyHarmonizedColorsToCss()
        // Replaced by comprehensive OKLAB-enabled _applyColorsViaFacadeSystem()
        // =============================================
        // =============================================
        // 🆕 PUBLIC WRAPPER – UNIFIED CSS VARIABLE BATCH API
        // =============================================
        /**
         * Queue a CSS variable update through the shared UnifiedCSSConsciousnessController. Falls
         * back to an immediate style mutation when the batcher is unavailable
         * (degraded mode or very early boot).
         *
         * @param property  The CSS custom property name (e.g. "--sn-nav-intensity")
         * @param value     The value to assign (raw string, keep units if needed)
         * @param element   Optional specific HTMLElement target. When omitted the
         *                  root <html> element is used so variables cascade.
         */
        queueCSSVariableUpdate(property, value, element = null) {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueUpdate(
              property,
              value,
              "normal",
              "Year3000System"
            );
          } else if (this.cssConsciousnessController) {
            this.cssConsciousnessController.queueCSSVariableUpdate(
              property,
              value,
              element || void 0
            );
          } else {
            const target = element || document.documentElement;
            target.style.setProperty(property, value);
          }
        }
        setGradientParameters() {
          if (this.colorHarmonyEngine) {
          }
        }
        async updateColorsFromCurrentTrack() {
          if (this.musicSyncService) {
            await this.musicSyncService.processSongUpdate();
          }
        }
        evolveHarmonicSignature(selectedModeKey, baseSourceHex) {
          if (this.colorHarmonyEngine) {
            const rgb = this.utils.hexToRgb(baseSourceHex);
            if (rgb) {
              const variations = this.colorHarmonyEngine.generateHarmonicVariations(rgb);
              return {
                derivedDarkVibrantHex: variations.darkVibrantHex,
                derivedLightVibrantHex: variations.lightVibrantHex
              };
            }
          }
          return null;
        }
        async waitForTrackData(maxRetries = 10, delayMs = 100) {
          for (let i = 0; i < maxRetries; i++) {
            if (Spicetify.Player.data?.track?.uri) {
              return Spicetify.Player.data;
            }
            await this.utils.sleep(delayMs);
          }
          return null;
        }
        updateHarmonicBaseColor(hexColor) {
          if (this.colorHarmonyEngine && this.cssConsciousnessController) {
            const rgb = this.utils.hexToRgb(hexColor);
            if (rgb) {
              const variations = this.colorHarmonyEngine.generateHarmonicVariations(rgb);
              this.cssConsciousnessController.queueCSSVariableUpdate(
                "--sn-harmonic-base-dark-vibrant",
                variations.darkVibrantHex
              );
              this.cssConsciousnessController.queueCSSVariableUpdate(
                "--sn-harmonic-base-light-vibrant",
                variations.lightVibrantHex
              );
              this.cssConsciousnessController.flushCSSVariableBatch();
            }
          }
        }
        /**
         * Process colors through the existing facade pattern architecture
         * Phase 1: Integration with SystemCoordinator and ColorOrchestrator
         */
        async processColorsViaFacade(context) {
          try {
            const colorOrchestrator = await this.facadeCoordinator?.getNonVisualSystem("ColorOrchestrator");
            if (colorOrchestrator && typeof colorOrchestrator.handleColorExtraction === "function") {
              await colorOrchestrator.handleColorExtraction(context);
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F3A8} [Year3000System] Color processing routed through facade pattern - ColorOrchestrator", {
                  context: context?.trackUri || "unknown",
                  rawColorsCount: context?.rawColors ? Object.keys(context.rawColors).length : 0
                });
              }
            } else {
              if (this.colorHarmonyEngine && typeof this.colorHarmonyEngine.processColors === "function") {
                await this.colorHarmonyEngine.processColors(context);
                if (this.YEAR3000_CONFIG.enableDebug) {
                  console.log("\u{1F3A8} [Year3000System] Color processing fallback to direct ColorHarmonyEngine");
                }
              } else {
                console.warn("[Year3000System] No color processing system available via facade pattern");
              }
            }
          } catch (error) {
            console.error("[Year3000System] Failed to process colors via facade pattern:", error);
            if (context?.rawColors) {
              this.applyColorsToTheme(context.rawColors);
            }
          }
        }
        setupMusicAnalysisAndColorExtraction() {
          console.log("\u{1F3B5} [Year3000System] setupMusicAnalysisAndColorExtraction called");
          if (!this.musicSyncService) {
            console.error(
              "[Year3000System] MusicSyncService is not available to set up song change handler."
            );
            return;
          }
          console.log("\u{1F3B5} [Year3000System] MusicSyncService available, checking Spicetify Player...");
          if (!window.Spicetify?.Player) {
            console.warn(
              "[Year3000System] Spicetify.Player not available - music analysis disabled"
            );
            return;
          }
          try {
            unifiedEventBus.subscribe("colors:harmonized", (data) => {
              this.handleColorHarmonizedEvent(data);
            }, "Year3000System");
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Subscribed to colors:harmonized events for event-driven color application");
            }
          } catch (error) {
            console.error("[Year3000System] Failed to subscribe to colors:harmonized events:", error);
          }
          const processSongUpdate = /* @__PURE__ */ __name(async () => {
            console.log("\u{1F3B5} [Year3000System] processSongUpdate triggered - checking MusicSyncService...");
            if (this.musicSyncService) {
              console.log("\u{1F3B5} [Year3000System] Calling musicSyncService.processSongUpdate()");
              await this.musicSyncService.processSongUpdate();
              console.log("\u2705 [Year3000System] musicSyncService.processSongUpdate() completed");
            } else {
              console.error("\u274C [Year3000System] MusicSyncService not available in processSongUpdate");
            }
          }, "processSongUpdate");
          this._songChangeHandler = processSongUpdate;
          try {
            console.log("\u{1F3B5} [Year3000System] Adding songchange event listener...");
            window.Spicetify.Player.addEventListener(
              "songchange",
              this._songChangeHandler
            );
            console.log("\u2705 [Year3000System] Music analysis and color extraction set up successfully - song change listener active");
            console.log("\u{1F3B5} [Year3000System] Triggering initial song processing...");
            setTimeout(processSongUpdate, 1e3);
          } catch (error) {
            console.error("[Year3000System] Failed to set up music analysis:", error);
            this._songChangeHandler = null;
          }
        }
        updateFromMusicAnalysis(processedData, rawFeatures, trackUri) {
          if (!processedData) return;
          this._updateGlobalKinetics(processedData);
        }
        _updateGlobalKinetics(data) {
          const root = this.utils.getRootStyle();
          if (!root) return;
          const safe = /* @__PURE__ */ __name((value, fallback = 0) => Number.isFinite(value) ? value : fallback, "safe");
          const processedEnergy = safe(data.processedEnergy);
          const valence = safe(data.valence);
          const enhancedBPM = safe(data.enhancedBPM);
          const beatInterval = safe(data.beatInterval);
          const animationSpeed = safe(data.animationSpeedFactor, 1);
          root.style.setProperty("--sn-kinetic-energy", processedEnergy.toFixed(3));
          root.style.setProperty("--sn-kinetic-valence", valence.toFixed(3));
          root.style.setProperty("--sn-kinetic-bpm", enhancedBPM.toFixed(2));
          root.style.setProperty(
            "--sn-kinetic-beat-interval",
            `${beatInterval.toFixed(0)}ms`
          );
          root.style.setProperty(
            "--sn-kinetic-animation-speed",
            animationSpeed.toFixed(3)
          );
        }
        // Animation System Registration Methods
        registerAnimationSystem(name, system, priority = "normal", targetFPS = 60) {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              `[Year3000System] Cannot register ${name} - EnhancedMasterAnimationCoordinator not ready`
            );
            return false;
          }
          this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
            name,
            system,
            priority,
            targetFPS
          );
          return true;
        }
        unregisterAnimationSystem(name) {
          if (!this.enhancedMasterAnimationCoordinator) {
            return false;
          }
          this.enhancedMasterAnimationCoordinator.unregisterAnimationSystem(name);
          return true;
        }
        /**
         * Public accessor that returns a subsystem instance by its constructor name or
         * by the conventional camel-cased property key. This is primarily used for
         * loose coupling between visual systems (e.g. BehaviouralPredictionEngine ⇆
         * PredictiveMaterializationSystem). Returns `null` when the requested system
         * is not available or not yet initialised.
         */
        getSystem(name) {
          if (!name) return null;
          if (this.facadeCoordinator) {
            const visualSystem2 = this.facadeCoordinator.getVisualSystem(name);
            if (visualSystem2) return visualSystem2;
            const nonVisualSystem = this.facadeCoordinator.getCachedNonVisualSystem(name);
            if (nonVisualSystem) return nonVisualSystem;
          }
          const camel = name.charAt(0).toLowerCase() + name.slice(1);
          if (this[camel]) return this[camel];
          for (const key of Object.keys(this)) {
            const maybeInstance = this[key];
            if (maybeInstance && maybeInstance.constructor?.name === name) {
              return maybeInstance;
            }
          }
          return null;
        }
        /**
         * Get health status of all facade systems
         */
        async getFacadeSystemHealthStatus() {
          if (!this.facadeCoordinator) return null;
          return await this.facadeCoordinator.performHealthCheck();
        }
        async _registerAnimationSystems() {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for visual system registration"
            );
            return;
          }
          const visualSystems = [
            {
              name: "BeatSyncVisualSystem",
              system: this.beatSyncVisualSystem,
              priority: "critical"
            },
            // EmergentChoreographyEngine consolidated into EnhancedMasterAnimationCoordinator
            {
              name: "SidebarSystemsIntegration",
              system: this.sidebarSystemsIntegration,
              priority: "normal"
            },
            {
              name: "ParticleConsciousnessModule",
              system: this.particleConsciousnessModule,
              priority: "background"
            },
            {
              name: "InteractionTrackingSystem",
              system: this.interactionTrackingSystem,
              priority: "background"
            },
            {
              name: "SpotifyUIApplicationSystem",
              system: this.spotifyUIApplicationSystem,
              priority: "normal"
            }
          ];
          for (const { name, system, priority } of visualSystems) {
            if (system && (typeof system.onAnimate === "function" || typeof system.updateAnimation === "function")) {
              let optimizedPriority = priority;
              let targetFPS = 60;
              const currentProfile = system.currentPerformanceProfile;
              if (currentProfile?.frameRate) {
                targetFPS = currentProfile.frameRate;
              } else if (currentProfile?.quality) {
                const quality = currentProfile.quality;
                targetFPS = quality === "high" ? 60 : quality === "low" ? 30 : 45;
              }
              if (name.includes("BeatSync")) {
                optimizedPriority = "critical";
              } else if (name.includes("Particle") || name.includes("DataGlyph")) {
                optimizedPriority = "background";
                targetFPS = Math.min(targetFPS, 30);
              }
              this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
                name,
                system,
                optimizedPriority,
                targetFPS
              );
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  `\u{1F3AC} [Year3000System] Registered ${name} with Enhanced Master Animation Coordinator (${optimizedPriority} priority, ${targetFPS}fps) - using ${typeof system.onAnimate === "function" ? "onAnimate" : "updateAnimation"} hook`
                );
              }
            }
          }
        }
        /**
         * Register visual systems with the EnhancedMasterAnimationCoordinator
         * Phase 4: Animation System Consolidation
         */
        async _registerEnhancedAnimationSystems() {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for enhanced visual system registration"
            );
            return;
          }
          const enhancedVisualSystems = [
            {
              name: "BeatSyncVisualSystem",
              system: this.beatSyncVisualSystem,
              priority: "critical",
              type: "animation"
            },
            // EmergentChoreographyEngine consolidated into EnhancedMasterAnimationCoordinator
            {
              name: "SidebarSystemsIntegration",
              system: this.sidebarSystemsIntegration,
              priority: "normal",
              type: "animation"
            },
            {
              name: "ParticleConsciousnessModule",
              system: this.particleConsciousnessModule,
              priority: "background",
              type: "animation"
            },
            {
              name: "InteractionTrackingSystem",
              system: this.interactionTrackingSystem,
              priority: "background",
              type: "animation"
            },
            {
              name: "SpotifyUIApplicationSystem",
              system: this.spotifyUIApplicationSystem,
              priority: "normal",
              type: "animation"
            }
          ];
          for (const { name, system, priority, type } of enhancedVisualSystems) {
            if (system) {
              try {
                let registered = false;
                if (type === "animation" && (typeof system.onAnimate === "function" || typeof system.updateAnimation === "function")) {
                  registered = this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
                    name,
                    system,
                    priority,
                    60
                    // Default 60fps
                  );
                }
                if (registered && this.YEAR3000_CONFIG.enableDebug) {
                  console.log(
                    `\u{1F3AC} [Year3000System] Enhanced registration: ${name} (${priority} priority, ${type} type)`
                  );
                } else if (!registered) {
                  console.warn(
                    `[Year3000System] Failed to register ${name} with EnhancedMasterAnimationCoordinator`
                  );
                }
              } catch (error) {
                console.error(
                  `[Year3000System] Error registering ${name} with EnhancedMasterAnimationCoordinator:`,
                  error
                );
              }
            }
          }
        }
        // Progressive Loading Methods for Extension Support
        async initializeWithAvailableAPIs(availableAPIs) {
          this.availableAPIs = availableAPIs;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `\u{1F31F} [Year3000System] Progressive initialization mode: ${availableAPIs.degradedMode ? "DEGRADED" : "FULL"}`
            );
            console.log(`\u{1F31F} [Year3000System] Available APIs:`, {
              player: !!availableAPIs.player,
              platform: !!availableAPIs.platform,
              config: !!availableAPIs.config
            });
          }
          if (availableAPIs.degradedMode) {
            console.log(
              "\u{1F31F} [Year3000System] Initializing in degraded mode (visual-only systems)"
            );
            await this.initializeVisualOnlySystems();
          } else {
            console.log(
              "\u{1F31F} [Year3000System] Initializing in full mode (all systems)"
            );
            await this.initializeAllSystems();
          }
          if (availableAPIs.degradedMode) {
            this.setupProgressiveEnhancement();
          }
        }
        async initializeVisualOnlySystems() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Starting visual-only system initialization..."
            );
          }
          const startTime = performance.now();
          const initializationResults = {
            success: [],
            failed: [],
            skipped: []
          };
          try {
            this.facadeCoordinator = new SystemCoordinator(
              this.YEAR3000_CONFIG,
              this.utils,
              this
            );
            await this.facadeCoordinator.initialize({
              mode: "performance-optimized",
              enableSharedDependencies: true,
              enableCrossFacadeCommunication: false,
              enableUnifiedPerformanceMonitoring: true,
              enableResourceOptimization: true,
              performanceThresholds: {
                maxTotalMemoryMB: 50,
                maxTotalInitTime: 3e3,
                maxCrossCommLatency: 100
              },
              coordinationPreferences: {
                preferSharedResources: true,
                enableEventPropagation: false,
                enableHealthCoordination: true
              }
            });
            await this._initializeEssentialFacadeSystems();
            initializationResults.success.push("FacadeCoordinationSystem");
          } catch (error) {
            console.error("\u{1F30C} [Year3000System] Failed to initialize degraded facade system:", error);
            initializationResults.failed.push("FacadeCoordinationSystem");
          }
          const skippedSystems = [
            "SettingsManager",
            "MusicSyncService",
            "ColorHarmonyEngine",
            "GlassmorphismManager",
            "Card3DManager",
            "All Visual Systems"
          ];
          initializationResults.skipped.push(...skippedSystems);
          this._initializationResults = initializationResults;
          this.initialized = true;
          const endTime = performance.now();
          const initTime = endTime - startTime;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `\u{1F31F} [Year3000System] Visual-only initialization complete in ${initTime.toFixed(
                2
              )}ms`
            );
            console.log(
              `\u{1F31F} [Year3000System] Results: ${initializationResults.success.length} success, ${initializationResults.failed.length} failed, ${initializationResults.skipped.length} skipped`
            );
          }
        }
        setupProgressiveEnhancement() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Setting up progressive enhancement monitoring..."
            );
          }
          let enhancementAttempts = 0;
          const maxEnhancementAttempts = 30;
          const enhancementInterval = setInterval(() => {
            enhancementAttempts++;
            const playerAvailable = !!window.Spicetify?.Player;
            const platformAvailable = !!window.Spicetify?.Platform;
            if (playerAvailable && platformAvailable && this.availableAPIs?.degradedMode) {
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F31F} [Year3000System] APIs now available! Triggering upgrade to full mode..."
                );
              }
              clearInterval(enhancementInterval);
              this.upgradeToFullMode().catch((error) => {
                console.error("[Year3000System] Upgrade to full mode failed:", error);
              });
            }
            if (enhancementAttempts >= maxEnhancementAttempts) {
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F31F} [Year3000System] Progressive enhancement monitoring stopped (timeout)"
                );
              }
              clearInterval(enhancementInterval);
            }
          }, 2e3);
        }
        async upgradeToFullMode() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Upgrading from degraded mode to full mode..."
            );
          }
          this.availableAPIs = {
            player: window.Spicetify?.Player,
            platform: window.Spicetify?.Platform,
            config: window.Spicetify?.Config,
            degradedMode: false
          };
          try {
            const upgradeResults = {
              success: [],
              failed: [],
              skipped: []
            };
            try {
              if (this.systemHealthMonitor) {
                this.systemHealthMonitor.registerSystem(
                  "SettingsManager",
                  this.settingsManager
                );
              }
              upgradeResults.success.push("SettingsManager");
            } catch (error) {
              upgradeResults.failed.push("SettingsManager");
              console.error(
                `[Year3000System] Failed to upgrade SettingsManager:`,
                error
              );
            }
            if (this.settingsManager) {
              try {
              } catch (error) {
              }
            }
            if (this.performanceAnalyzer && this.settingsManager) {
              try {
              } catch (error) {
              }
              if (this.enhancedMasterAnimationCoordinator) {
                await this._registerAnimationSystems();
              }
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("[Year3000System] Checking music analysis setup conditions:", {
                musicSyncService: !!this.musicSyncService,
                playerAPI: !!this.availableAPIs.player,
                musicSyncInitialized: this.musicSyncService?.initialized
              });
            }
            if (this.musicSyncService && this.availableAPIs.player) {
              console.log("\u{1F3B5} [Year3000System] Setting up music analysis and color extraction...");
              this.setupMusicAnalysisAndColorExtraction();
            } else {
              console.warn("\u26A0\uFE0F [Year3000System] Music analysis setup skipped - missing dependencies:", {
                musicSyncService: !!this.musicSyncService,
                playerAPI: !!this.availableAPIs.player
              });
            }
            if (this.settingsManager) {
              await this.applyInitialSettings();
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                `\u{1F31F} [Year3000System] Upgrade complete: ${upgradeResults.success.length} success, ${upgradeResults.failed.length} failed`
              );
              if (upgradeResults.failed.length > 0) {
                console.warn(
                  `\u{1F31F} [Year3000System] Upgrade failed systems: ${upgradeResults.failed.join(
                    ", "
                  )}`
                );
              }
              if (upgradeResults.skipped && upgradeResults.skipped.length > 0) {
                console.info(
                  `\u{1F31F} [Year3000System] Upgrade skipped systems: ${upgradeResults.skipped.join(
                    ", "
                  )}`
                );
              }
              if (upgradeResults.success.length > 0) {
                console.info(
                  `\u{1F31F} [Year3000System] Upgrade successful systems: ${upgradeResults.success.join(
                    ", "
                  )}`
                );
              }
            }
          } catch (error) {
            console.error(
              "[Year3000System] Error during upgrade to full mode:",
              error
            );
          }
        }
        _handleExternalSettingsChange(event) {
          const { key, value } = event.detail || {};
          if (!key) return;
          switch (key) {
            case "artisticMode": {
              try {
                if (typeof this.YEAR3000_CONFIG.safeSetArtisticMode === "function") {
                  this.YEAR3000_CONFIG.safeSetArtisticMode(value);
                }
              } catch (e) {
                console.warn("[Year3000System] Failed to apply artistic mode", e);
              }
              break;
            }
            case "harmonicIntensity": {
              const num = parseFloat(value);
              if (!Number.isNaN(num)) {
                this.YEAR3000_CONFIG.harmonicIntensity = num;
                if (this.colorHarmonyEngine) {
                  this.colorHarmonyEngine.setIntensity?.(num);
                  this.updateColorsFromCurrentTrack?.();
                }
              }
              break;
            }
            case "harmonicEvolution": {
              const enabled = value === "true" || value === true;
              this.allowHarmonicEvolution = enabled;
              this.YEAR3000_CONFIG.harmonicEvolution = enabled;
              break;
            }
            case "manualBaseColor": {
              if (typeof value === "string" && value.trim() !== "" && value.startsWith("#")) {
                this.updateHarmonicBaseColor(value);
                if (this.YEAR3000_CONFIG.enableDebug) {
                  console.log("\u{1F3A8} [Year3000System] Manual base color applied:", value);
                }
              } else if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F3A8} [Year3000System] Manual base color cleared - using album art colors");
              }
              break;
            }
            case "harmonicMode": {
              if (value !== null && value !== void 0) {
                this.YEAR3000_CONFIG.currentHarmonicMode = String(value);
                this.updateColorsFromCurrentTrack?.();
              }
              break;
            }
            default:
              break;
          }
          this._broadcastSettingChange(key, value);
          this._refreshConditionalSystems();
        }
        /**
         * Notify all subsystems that implement applyUpdatedSettings so they can
         * adjust behaviour immediately after a SettingsManager change.
         */
        _broadcastSettingChange(key, value) {
          const systems = [
            this.colorHarmonyEngine,
            this.glassmorphismManager,
            this.card3DManager,
            this.lightweightParticleSystem,
            this.interactionTrackingSystem,
            this.beatSyncVisualSystem,
            this.sidebarSystemsIntegration,
            this.particleFieldSystem
            // contextMenuSystem removed
          ];
          systems.forEach((sys) => {
            if (sys && typeof sys.applyUpdatedSettings === "function") {
              try {
                sys.applyUpdatedSettings(key, value);
              } catch (err) {
                console.warn(
                  `[Year3000System] ${sys.systemName || sys.constructor?.name || "UnknownSystem"} failed to applyUpdatedSettings`,
                  err
                );
              }
            }
          });
        }
        // ---------------------------------------------------------------------------
        // 🔧  Placeholder implementations restored after merge conflict
        // ---------------------------------------------------------------------------
        /**
         * Apply the current performance profile to subsystems.
         * NOTE: Full implementation was lost in a previous edit; this stub preserves
         *        compile-time integrity until the original logic is reinstated.
         */
        _applyPerformanceProfile() {
        }
        /**
         * Refresh conditional visual systems (WebGL, ParticleField, etc.) depending
         * on capability and artistic mode settings.
         */
        _refreshConditionalSystems() {
        }
        /**
         * Handle artistic-mode changes by triggering a colour refresh.
         */
        _onArtisticModeChanged() {
          try {
            this.updateColorsFromCurrentTrack?.();
          } catch (e) {
            console.warn("[Year3000System] _onArtisticModeChanged stub error", e);
          }
        }
        _handleVisibilityChange() {
          if (document.visibilityState !== "hidden") return;
          try {
            this.cssConsciousnessController?.flushCSSVariableBatch?.();
            try {
            } catch {
            }
            if (this.YEAR3000_CONFIG?.enableDebug) {
              console.log(
                "\u{1F31F} [Year3000System] Visibility hidden \u2192 forced flush of pending style updates"
              );
            }
          } catch (e) {
            if (this.YEAR3000_CONFIG?.enableDebug) {
              console.warn("[Year3000System] VisibilityChange flush error", e);
            }
          }
        }
        /**
         * Destroy method for proper cleanup during testing
         */
        async destroy() {
          try {
            await this.destroyAllSystems();
            document.removeEventListener("visibilitychange", this._handleVisibilityChange.bind(this));
            this.initialized = false;
            console.log("\u{1F31F} [Year3000System] System destroyed successfully");
          } catch (error) {
            console.error("\u274C [Year3000System] Error during destroy:", error);
          }
        }
      };
      __name(_Year3000System, "Year3000System");
      Year3000System = _Year3000System;
      year3000System = new Year3000System();
      if (typeof window !== "undefined") {
        window.year3000System = year3000System;
      }
      year3000System_default = year3000System;
    }
  });

  // src-js/visual/ui-effects/prismaticScrollSheen.ts
  var prismaticScrollSheen_exports = {};
  __export(prismaticScrollSheen_exports, {
    PrismaticScrollSheenSystem: () => PrismaticScrollSheenSystem,
    initializePrismaticScrollSheen: () => initializePrismaticScrollSheen
  });
  function initializePrismaticScrollSheen() {
    try {
      const sys = new PrismaticScrollSheenSystem();
      year3000System_default?.registerVisualSystem?.(sys, "background");
    } catch (err) {
      console.error("[PrismaticScrollSheen] Failed to init:", err);
    }
  }
  var DEFAULT_CYCLE_PX, _PrismaticScrollSheenSystem, PrismaticScrollSheenSystem;
  var init_prismaticScrollSheen = __esm({
    "src-js/visual/ui-effects/prismaticScrollSheen.ts"() {
      "use strict";
      init_year3000System();
      DEFAULT_CYCLE_PX = 6e3;
      _PrismaticScrollSheenSystem = class _PrismaticScrollSheenSystem {
        constructor(cyclePx = DEFAULT_CYCLE_PX) {
          this.cyclePx = cyclePx;
          this.systemName = "PrismaticScrollSheen";
          this._lastRatio = -1;
          document.documentElement.style.setProperty(
            "--sn-scroll-cycle-px",
            String(cyclePx)
          );
        }
        /**
         * Called each animation frame by VisualSystemRegistry.
         */
        onAnimate(_delta, context) {
          const ratio = context.scrollRatio ?? 0;
          if (Math.abs(ratio - this._lastRatio) < 1e-3) return;
          this._lastRatio = ratio;
          const root = document.documentElement;
          root.style.setProperty("--sn-cdf-scroll-ratio", ratio.toFixed(4));
          root.style.setProperty("--sn-scroll-ratio", ratio.toFixed(4));
        }
        onPerformanceModeChange() {
        }
        destroy() {
        }
      };
      __name(_PrismaticScrollSheenSystem, "PrismaticScrollSheenSystem");
      PrismaticScrollSheenSystem = _PrismaticScrollSheenSystem;
      __name(initializePrismaticScrollSheen, "initializePrismaticScrollSheen");
      if (window.Y3K?.system?.registerVisualSystem) {
        initializePrismaticScrollSheen();
      }
    }
  });

  // src-js/debug/DragCartographer.ts
  var DragCartographer_exports = {};
  __export(DragCartographer_exports, {
    enableDragCartography: () => enableDragCartography,
    getDragMap: () => getDragMap
  });
  function enableDragCartography() {
    const g2 = globalThis;
    if (g2.__SN_dragCartographer) return;
    g2.__SN_dragCartographer = new DragCartographer();
    console.info("\u{1F6F0}\uFE0F  DragCartographer enabled \u2013 logging dragstart events");
  }
  function getDragMap() {
    return DragCartographer.getDragMap();
  }
  var _DragCartographer, DragCartographer;
  var init_DragCartographer = __esm({
    "src-js/debug/DragCartographer.ts"() {
      "use strict";
      _DragCartographer = class _DragCartographer {
        constructor() {
          this.seen = /* @__PURE__ */ new WeakSet();
          this.handleDragStart = /* @__PURE__ */ __name((event) => {
            const target = event.target;
            if (!target) return;
            if (this.seen.has(target)) return;
            this.seen.add(target);
            const selector = _DragCartographer.buildSelectorPath(target);
            const detail = {
              time: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
              selector
            };
            try {
              const dt = event.dataTransfer;
              if (dt) {
                const uris = dt.getData("text/spotify") || dt.getData("text/uri-list");
                if (uris) {
                  detail.uris = uris.split(/\n|,/).filter(Boolean);
                }
                const label = dt.getData("text/plain");
                if (label) detail.label = label;
              }
            } catch {
            }
            const agg = _DragCartographer.aggregate;
            const entry = agg.get(selector);
            if (entry) {
              entry.count += 1;
              if (entry.samples.length < 3) entry.samples.push(detail);
            } else {
              agg.set(selector, { selector, count: 1, samples: [detail] });
            }
            console.groupCollapsed(
              `%c[DragCartographer] dragstart \u2192 ${selector}`,
              "color:#7dd3fc;font-weight:600"
            );
            console.table(detail);
            console.log("Event:", event);
            console.log("Target element snapshot:", target);
            console.groupEnd();
          }, "handleDragStart");
          document.addEventListener("dragstart", this.handleDragStart, true);
        }
        static buildSelectorPath(el) {
          const path = [];
          let current = el;
          let depth = 0;
          while (current && depth < _DragCartographer.MAX_PATH_DEPTH) {
            const tag = current.tagName.toLowerCase();
            const id = current.id ? `#${current.id}` : "";
            const cls = current.className && typeof current.className === "string" ? "." + current.className.split(/\s+/).slice(0, 2).join(".") : "";
            path.push(`${tag}${id}${cls}`);
            current = current.parentElement;
            depth += 1;
          }
          return path.join(" > ");
        }
        // Public helper to fetch map
        static getDragMap() {
          return Array.from(_DragCartographer.aggregate.values()).sort(
            (a, b) => b.count - a.count
          );
        }
      };
      __name(_DragCartographer, "DragCartographer");
      _DragCartographer.MAX_PATH_DEPTH = 4;
      _DragCartographer.aggregate = /* @__PURE__ */ new Map();
      DragCartographer = _DragCartographer;
      __name(enableDragCartography, "enableDragCartography");
      __name(getDragMap, "getDragMap");
    }
  });

  // src-js/utils/graphics/CanvasGhostBuilder.ts
  function buildDragGhostCanvas(label, imgSrc, opts = {}) {
    const key = `${label}|${imgSrc}|${opts.size}|${opts.dpr}`;
    const cached = cache.get(key);
    if (cached) return cached;
    const size = opts.size ?? 72;
    const dpr = opts.dpr ?? (window.devicePixelRatio || 1);
    const borderRadius = opts.borderRadius ?? 8;
    const canvas = document.createElement("canvas");
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    const ctx = canvas.getContext("2d");
    ctx.scale(dpr, dpr);
    ctx.fillStyle = "rgba(32,32,35,0.9)";
    ctx.roundRect(0, 0, size, size, borderRadius);
    ctx.fill();
    if (opts.shadow !== false) {
      ctx.shadowColor = "rgba(0,0,0,0.4)";
      ctx.shadowBlur = 6;
    }
    const inner = size - 16;
    if (imgSrc) {
      const img = new Image();
      img.src = imgSrc;
      const drawImage = /* @__PURE__ */ __name(() => {
        ctx.save();
        ctx.beginPath();
        ctx.roundRect(8, 8, inner, inner, borderRadius - 2);
        ctx.clip();
        ctx.drawImage(img, 8, 8, inner, inner);
        ctx.restore();
        drawLabel();
      }, "drawImage");
      if (img.complete) {
        drawImage();
      } else {
        img.onload = drawImage;
        img.onerror = drawLabel;
      }
    } else {
      drawLabel();
    }
    function drawLabel() {
      ctx.fillStyle = "#fff";
      ctx.font = `500 12px Inter, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const maxWidth = size - 10;
      let text = label;
      while (ctx.measureText(text).width > maxWidth && text.length > 4) {
        text = text.slice(0, -2);
      }
      if (text !== label) text = text.slice(0, -1) + "\u2026";
      ctx.fillText(text, size / 2, size - 10);
    }
    __name(drawLabel, "drawLabel");
    cache.set(key, canvas);
    return canvas;
  }
  var cache;
  var init_CanvasGhostBuilder = __esm({
    "src-js/utils/graphics/CanvasGhostBuilder.ts"() {
      "use strict";
      cache = /* @__PURE__ */ new Map();
      __name(buildDragGhostCanvas, "buildDragGhostCanvas");
    }
  });

  // src-js/ui/interactions/EnhancedDragPreview.ts
  var EnhancedDragPreview_exports = {};
  __export(EnhancedDragPreview_exports, {
    enableEnhancedDragPreview: () => enableEnhancedDragPreview
  });
  function createGhost(label, imgSrc) {
    try {
      return buildDragGhostCanvas(label, imgSrc);
    } catch {
      const div = document.createElement("div");
      div.textContent = label;
      div.style.padding = "4px 6px";
      div.style.fontSize = "12px";
      div.style.background = "rgba(32,32,35,0.9)";
      div.style.color = "#fff";
      return div;
    }
  }
  function extractImageSrc(el) {
    const img = el.querySelector("img[src]");
    if (img?.src) return img.src;
    const bg = getComputedStyle(el).backgroundImage;
    const match = bg && /url\("?([^\"]+)"?\)/.exec(bg);
    return match ? match[1] : void 0;
  }
  function findFallbackLabel(el) {
    const attrLabel = el.getAttribute("aria-label") || el.getAttribute("title");
    if (attrLabel) return attrLabel;
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
      acceptNode(node) {
        const text = node.textContent?.trim();
        return text ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    const n = walker.nextNode();
    return (n?.textContent?.trim() || "").slice(0, 60);
  }
  function getPreviewData(target) {
    if (cache2.has(target)) return cache2.get(target);
    const label = findFallbackLabel(target);
    if (!label) return null;
    const img = extractImageSrc(target);
    const data = img ? { label, img } : { label };
    cache2.set(target, data);
    return data;
  }
  function onDragStart(event) {
    try {
      if (!event.dataTransfer || typeof event.dataTransfer.setDragImage !== "function")
        return;
      const target = event.target;
      if (!target) return;
      let label = event.dataTransfer.getData("text/plain");
      let imgSrc;
      if (!label) {
        const data = getPreviewData(target);
        if (!data) return;
        label = data.label;
        imgSrc = data.img;
      } else {
        imgSrc = extractImageSrc(target);
      }
      const ghostEl = createGhost(label, imgSrc);
      document.body.appendChild(ghostEl);
      const offset = ghostEl.offsetWidth / 2;
      event.dataTransfer.setDragImage(ghostEl, offset, offset);
      const cleanup = /* @__PURE__ */ __name(() => {
        ghostEl.remove();
        window.removeEventListener("dragend", cleanup, true);
      }, "cleanup");
      window.addEventListener("dragend", cleanup, true);
    } catch (err) {
      console.debug("[StarryNight] EnhancedDragPreview failed:", err);
    }
  }
  function enableEnhancedDragPreview(opts = {}) {
    const g2 = globalThis;
    if (g2.__SN_enhancedDragPreview) return;
    g2.__SN_enhancedDragPreview = true;
    Object.assign(DEFAULT_OPTS, opts);
    document.addEventListener("dragstart", onDragStart, true);
    console.info("\u{1F320} Enhanced drag preview enabled");
  }
  var DEFAULT_OPTS, cache2;
  var init_EnhancedDragPreview = __esm({
    "src-js/ui/interactions/EnhancedDragPreview.ts"() {
      "use strict";
      init_CanvasGhostBuilder();
      DEFAULT_OPTS = {
        size: 72,
        borderRadius: 8,
        fontSize: 12
      };
      cache2 = /* @__PURE__ */ new WeakMap();
      __name(createGhost, "createGhost");
      __name(extractImageSrc, "extractImageSrc");
      __name(findFallbackLabel, "findFallbackLabel");
      __name(getPreviewData, "getPreviewData");
      __name(onDragStart, "onDragStart");
      __name(enableEnhancedDragPreview, "enableEnhancedDragPreview");
    }
  });

  // src-js/utils/animation/flipSpring.ts
  function spring(config) {
    const k = config.stiffness ?? 260;
    const d = config.damping ?? 24;
    const m = config.mass ?? 1;
    let current = {};
    let velocity = {};
    let target = {};
    let animId = null;
    function step() {
      let done = true;
      const dt = 1 / 60;
      for (const key in target) {
        const x = current[key] ?? 0;
        const v = velocity[key] ?? 0;
        const goal = target[key] ?? 0;
        const Fspring = -k * (x - goal);
        const Fdamp = -d * v;
        const a = (Fspring + Fdamp) / m;
        const newV = v + a * dt;
        const newX = x + newV * dt;
        velocity[key] = newV;
        current[key] = newX;
        if (Math.abs(newV) > 0.1 || Math.abs(newX - goal) > 0.1) done = false;
      }
      config.onUpdate(current);
      if (!done) animId = requestAnimationFrame(step);
    }
    __name(step, "step");
    return {
      to(newTarget) {
        target = newTarget;
        if (!animId) animId = requestAnimationFrame(step);
      }
    };
  }
  var init_flipSpring = __esm({
    "src-js/utils/animation/flipSpring.ts"() {
      "use strict";
      __name(spring, "spring");
      window.snFlipSpringLoaded = true;
    }
  });

  // src-js/utils/dom/sidebarDetector.ts
  function querySidebar() {
    const node = document.querySelector(SIDEBAR_SELECTOR);
    if (!node) return null;
    const rect = node.getBoundingClientRect();
    return { node, rect };
  }
  function isSidebarCloneCapable() {
    const hasSidebar = !!querySidebar();
    const canClone = typeof Element.prototype.cloneNode === "function";
    const springReady = !!window.snFlipSpringLoaded;
    return hasSidebar && canClone && springReady;
  }
  var SIDEBAR_SELECTOR;
  var init_sidebarDetector = __esm({
    "src-js/utils/dom/sidebarDetector.ts"() {
      "use strict";
      SIDEBAR_SELECTOR = '[data-testid="rootlist-container"]';
      __name(querySidebar, "querySidebar");
      __name(isSidebarCloneCapable, "isSidebarCloneCapable");
    }
  });

  // src-js/ui/interactions/SidebarCloneOverlay.ts
  var SidebarCloneOverlay_exports = {};
  __export(SidebarCloneOverlay_exports, {
    destroySidebarClone: () => destroySidebarClone,
    launchSidebarClone: () => launchSidebarClone
  });
  function launchSidebarClone(context) {
    if (animationAbortController) {
      animationAbortController.abort();
      animationAbortController = null;
    }
    if (activeClone) {
      destroySidebarClone();
    }
    animationAbortController = new AbortController();
    const { signal } = animationAbortController;
    if (activeClone) return;
    const sidebar = querySidebar();
    if (!sidebar) return;
    const clone = sidebar.node.cloneNode(true);
    clone.id = "";
    clone.setAttribute("aria-hidden", "true");
    clone.classList.add("sn-clone-overlay");
    clone.style.position = "fixed";
    clone.style.top = `${sidebar.rect.top}px`;
    clone.style.left = `${sidebar.rect.left}px`;
    clone.style.width = `${sidebar.rect.width}px`;
    clone.style.height = `${sidebar.rect.height}px`;
    clone.style.zIndex = "9999";
    clone.style.willChange = "transform, opacity";
    clone.style.contain = "paint";
    (/* @__PURE__ */ __name(function stripCloneArtefacts(root) {
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
      while (walker.nextNode()) {
        const el = walker.currentNode;
        if (el.hasAttribute("aria-label")) el.removeAttribute("aria-label");
        if (el.tabIndex >= 0) el.tabIndex = -1;
      }
    }, "stripCloneArtefacts"))(clone);
    document.body.appendChild(clone);
    activeClone = clone;
    const firstX = 0;
    const firstY = 0;
    const firstS = 1;
    const lastX = context.cursorX - sidebar.rect.left - sidebar.rect.width * 0.2;
    const lastY = context.cursorY - sidebar.rect.top - sidebar.rect.height * 0.2;
    const lastS = 0.6;
    const prefersReduced = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    if (prefersReduced) {
      clone.style.transform = `translate(${lastX}px, ${lastY}px) scale(${lastS})`;
      pruneCloneItems(clone, context);
      return;
    }
    const anim = spring({
      stiffness: 220,
      damping: 20,
      onUpdate: /* @__PURE__ */ __name((v) => {
        if (signal.aborted) return;
        clone.style.transform = `translate(${v.x}px, ${v.y}px) scale(${v.s})`;
      }, "onUpdate")
    });
    clone.style.transformOrigin = "top left";
    clone.style.transform = `translate(${firstX}px, ${firstY}px) scale(${firstS})`;
    requestAnimationFrame(() => anim.to({ x: lastX, y: lastY, s: lastS }));
    const pruneTimeout = setTimeout(() => {
      if (!signal.aborted && activeClone) pruneCloneItems(activeClone, context);
    }, 400);
    signal.addEventListener("abort", () => clearTimeout(pruneTimeout));
    signal.addEventListener("abort", () => destroySidebarClone());
  }
  function destroySidebarClone() {
    cleanupFns.forEach((fn) => fn());
    cleanupFns.length = 0;
    if (activeClone) {
      activeClone.remove();
      activeClone = null;
    }
    if (animationAbortController) {
      animationAbortController.abort();
      animationAbortController = null;
    }
  }
  function addTracksToPlaylist(uri, trackUris) {
    try {
      const Cosmos = window.Spicetify?.CosmosAsync;
      if (!Cosmos) return;
      const endpoint = `/v1/playlists/${uri.split(":").pop()}/tracks`;
      Cosmos.post(endpoint, { uris: trackUris });
    } catch {
    }
  }
  function pruneCloneItems(root, context) {
    const all = Array.from(
      root.querySelectorAll('[data-uri^="spotify:playlist:"]')
    );
    if (!all.length) return;
    const keep = all.slice(0, 5);
    all.slice(5).forEach((el) => {
      el.classList.add("sn-prune-out");
      setTimeout(() => el.remove(), 180);
    });
    keep.forEach((el, idx) => {
      el.setAttribute("data-index", String(idx + 1));
      el.setAttribute("role", "button");
      el.tabIndex = 0;
      el.style.setProperty("--sn-glow-level", "0");
      el.style.backgroundImage = "paint(sn-aura)";
      el.addEventListener(
        "mouseenter",
        () => el.style.setProperty("--sn-glow-level", "1")
      );
      el.addEventListener(
        "mouseleave",
        () => el.style.setProperty("--sn-glow-level", "0")
      );
      const uriVal = el.getAttribute("data-uri");
      if (!uriVal) {
        return;
      }
      const trackUris = context.uris;
      const clickHandler = /* @__PURE__ */ __name((ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        const img = el.querySelector("img");
        pushRecentPlaylist(
          uriVal,
          img?.src || "",
          el.textContent?.trim() || "Playlist"
        );
        addTracksToPlaylist(uriVal, trackUris);
        announce("Track added to " + (el.textContent?.trim() || "playlist"));
        destroySidebarClone();
      }, "clickHandler");
      el.addEventListener("click", clickHandler);
      el.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          clickHandler(e);
        }
      });
    });
    const keyListener = /* @__PURE__ */ __name((e) => {
      const n = parseInt(e.key, 10);
      if (n >= 1 && n <= keep.length) {
        keep[n - 1]?.click();
      }
    }, "keyListener");
    window.addEventListener("keydown", keyListener, { capture: true });
    cleanupFns.push(
      () => window.removeEventListener("keydown", keyListener, { capture: true })
    );
  }
  function pushRecentPlaylist(uri, image, name) {
    try {
      const raw = localStorage.getItem(MRU_KEY);
      const list = raw ? JSON.parse(raw) : [];
      const existing = list.findIndex((p) => p.uri === uri);
      if (existing !== -1) list.splice(existing, 1);
      list.unshift({ uri, image, name });
      localStorage.setItem(MRU_KEY, JSON.stringify(list.slice(0, 10)));
    } catch {
    }
  }
  function announce(message) {
    const live = document.getElementById("sn-live");
    if (live) live.textContent = message;
  }
  var activeClone, cleanupFns, animationAbortController, MRU_KEY;
  var init_SidebarCloneOverlay = __esm({
    "src-js/ui/interactions/SidebarCloneOverlay.ts"() {
      "use strict";
      init_flipSpring();
      init_sidebarDetector();
      activeClone = null;
      cleanupFns = [];
      animationAbortController = null;
      MRU_KEY = "sn-recent-playlists";
      __name(launchSidebarClone, "launchSidebarClone");
      __name(destroySidebarClone, "destroySidebarClone");
      __name(addTracksToPlaylist, "addTracksToPlaylist");
      __name(pruneCloneItems, "pruneCloneItems");
      __name(pushRecentPlaylist, "pushRecentPlaylist");
      __name(announce, "announce");
    }
  });

  // src-js/ui/interactions/QuickAddRadialMenu.ts
  var QuickAddRadialMenu_exports = {};
  __export(QuickAddRadialMenu_exports, {
    enableQuickAddRadialMenu: () => enableQuickAddRadialMenu
  });
  function ensureLiveRegion() {
    let live = document.getElementById(LIVE_ID);
    if (!live) {
      live = document.createElement("div");
      live.id = LIVE_ID;
      live.setAttribute("aria-live", "polite");
      live.style.position = "absolute";
      live.style.width = "1px";
      live.style.height = "1px";
      live.style.overflow = "hidden";
      live.style.clipPath = "inset(100%)";
      live.style.clip = "rect(1px,1px,1px,1px)";
      live.style.whiteSpace = "nowrap";
      document.body.appendChild(live);
    }
    return live;
  }
  function distance(x1, y1, x2, y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function fetchRecentPlaylists() {
    try {
      const raw = localStorage.getItem("sn-recent-playlists");
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr.slice(0, MAX_PLAYLISTS_SHOWN) : [];
    } catch {
      return [];
    }
  }
  function addTracksToPlaylist2(playlistUri, trackUris) {
    try {
      const endpoint = `/v1/playlists/${playlistUri.split(":").pop()}/tracks`;
      window.Spicetify?.CosmosAsync.post(endpoint, {
        uris: trackUris
      });
    } catch (e) {
      console.warn("[StarryNight] QuickAddRadial failed to add tracks:", e);
    }
  }
  function pushRecentPlaylist2(pl) {
    try {
      const list = fetchRecentPlaylists();
      const existingIdx = list.findIndex((p) => p.uri === pl.uri);
      if (existingIdx !== -1) list.splice(existingIdx, 1);
      list.unshift(pl);
      const trimmed = list.slice(0, 10);
      localStorage.setItem("sn-recent-playlists", JSON.stringify(trimmed));
    } catch {
    }
  }
  function createOverlay(x, y, playlists) {
    if (!playlists.length) return;
    destroyOverlay();
    overlayEl = document.createElement("div");
    overlayEl.className = "sn-quick-add-overlay";
    overlayEl.style.position = "fixed";
    overlayEl.style.inset = "0";
    overlayEl.style.pointerEvents = "none";
    overlayEl.style.zIndex = "9999";
    const center = document.createElement("div");
    center.className = "sn-quick-add-center";
    center.style.position = "absolute";
    center.style.left = `${x}px`;
    center.style.top = `${y}px`;
    center.style.width = "0";
    center.style.height = "0";
    overlayEl.appendChild(center);
    document.body.appendChild(overlayEl);
    const radius = 90;
    const angleStep = Math.PI * 2 / playlists.length;
    playlists.forEach((pl, idx) => {
      const angle = angleStep * idx - Math.PI / 2;
      const btn = document.createElement("button");
      btn.className = "sn-quick-add-btn";
      btn.style.position = "absolute";
      btn.style.width = "64px";
      btn.style.height = "64px";
      btn.style.borderRadius = "50%";
      btn.style.border = "2px solid rgba(255,255,255,0.4)";
      btn.style.background = `url('${pl.image}') center/cover no-repeat`;
      btn.style.cursor = "pointer";
      btn.style.pointerEvents = "auto";
      const cx = radius * Math.cos(angle);
      const cy = radius * Math.sin(angle);
      btn.style.transform = `translate(${cx - 32}px, ${cy - 32}px)`;
      btn.style.transformOrigin = "center center";
      const firstX = 0;
      const firstY = 0;
      btn.style.transform = `translate(${firstX}px, ${firstY}px) scale(0.1)`;
      requestAnimationFrame(() => {
        const animator = spring({
          stiffness: 220,
          damping: 20,
          onUpdate: /* @__PURE__ */ __name((v) => {
            btn.style.transform = `translate(${v.x}px, ${v.y}px) scale(${v.s})`;
          }, "onUpdate")
        });
        animator.to({ x: cx - 32, y: cy - 32, s: 1 });
      });
      btn.title = `Add to ${pl.name}`;
      btn.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        if (currentDragDataUris) addTracksToPlaylist2(pl.uri, currentDragDataUris);
        pushRecentPlaylist2(pl);
        destroyOverlay();
      });
      center.appendChild(btn);
    });
    const live = ensureLiveRegion();
    live.textContent = "Quick-add menu open. Press number keys 1 to 5 to pick a playlist or continue dragging.";
  }
  function destroyOverlay() {
    overlayEl?.remove();
    overlayEl = null;
    const live = document.getElementById(LIVE_ID);
    if (live) live.textContent = "";
  }
  function clearHoldTimer() {
    if (holdTimer) {
      clearTimeout(holdTimer);
      holdTimer = null;
    }
  }
  function onDragStart2(e) {
    startX = e.clientX;
    startY = e.clientY;
    currentDragDataUris = (e.dataTransfer?.getData("text/spotify") || "").split(/[\n,]/).filter(Boolean);
    const cloneCapable = isSidebarCloneCapable();
    clearHoldTimer();
    holdTimer = window.setTimeout(async () => {
      if (cloneCapable) {
        const overlay = await Promise.resolve().then(() => (init_SidebarCloneOverlay(), SidebarCloneOverlay_exports));
        overlay.launchSidebarClone({
          cursorX: currentPointer.x,
          cursorY: currentPointer.y,
          uris: currentDragDataUris ?? []
        });
      } else {
        const playlists = await getRadialPlaylists();
        createOverlay(startX, startY, playlists);
      }
    }, HOLD_MS);
  }
  function onDragEnd() {
    clearHoldTimer();
    destroyOverlay();
    currentDragDataUris = null;
  }
  function onPointerMove(e) {
    currentPointer = { x: e.clientX, y: e.clientY };
    if (!holdTimer) return;
    if (distance(startX, startY, e.clientX, e.clientY) > MOVE_THRESHOLD) {
      clearHoldTimer();
    }
  }
  async function fetchPlaylistsFromAPI() {
    try {
      const Cosmos = window.Spicetify?.CosmosAsync;
      if (!Cosmos) return [];
      const resp = await Cosmos.get(
        "https://api.spotify.com/v1/me/playlists?limit=10"
      );
      if (!resp?.items) return [];
      return resp.items.slice(0, MAX_PLAYLISTS_SHOWN).map((pl) => ({
        uri: pl.uri,
        name: pl.name,
        image: pl.images?.[0]?.url || ""
      }));
    } catch {
      return [];
    }
  }
  function scrapeSidebarPlaylists() {
    try {
      const items = Array.from(
        document.querySelectorAll('[data-testid="rootlist-card"]')
      );
      const res = [];
      for (const el of items) {
        const uri = el.getAttribute("data-uri") || el.querySelector("a")?.getAttribute("href")?.replace("/playlist/", "spotify:playlist:");
        if (!uri) continue;
        const img = el.querySelector("img");
        const image = img?.src || "";
        const name = img?.alt || el.textContent?.trim() || "Playlist";
        res.push({ uri, image, name });
        if (res.length >= MAX_PLAYLISTS_SHOWN) break;
      }
      return res;
    } catch {
      return [];
    }
  }
  async function getRadialPlaylists() {
    const local = fetchRecentPlaylists();
    if (local.length) return local;
    const sidebar = scrapeSidebarPlaylists();
    if (sidebar.length) return sidebar;
    const api = await fetchPlaylistsFromAPI();
    return api;
  }
  function enableQuickAddRadialMenu() {
    const g2 = globalThis;
    if (g2.__SN_quickAddRadial) return;
    g2.__SN_quickAddRadial = true;
    window.addEventListener("dragstart", onDragStart2, true);
    window.addEventListener("dragend", onDragEnd, true);
    window.addEventListener("pointermove", onPointerMove, true);
    console.info("\u{1F30C} Quick-Add radial menu enabled");
    console.info(
      `[StarryNight] Sidebar clone capability: ${isSidebarCloneCapable()}`
    );
  }
  var HOLD_MS, MOVE_THRESHOLD, MAX_PLAYLISTS_SHOWN, holdTimer, startX, startY, overlayEl, currentDragDataUris, currentPointer, LIVE_ID;
  var init_QuickAddRadialMenu = __esm({
    "src-js/ui/interactions/QuickAddRadialMenu.ts"() {
      "use strict";
      init_flipSpring();
      init_sidebarDetector();
      HOLD_MS = 250;
      MOVE_THRESHOLD = 8;
      MAX_PLAYLISTS_SHOWN = 5;
      holdTimer = null;
      startX = 0;
      startY = 0;
      overlayEl = null;
      currentDragDataUris = null;
      currentPointer = { x: 0, y: 0 };
      LIVE_ID = "sn-live";
      __name(ensureLiveRegion, "ensureLiveRegion");
      __name(distance, "distance");
      __name(fetchRecentPlaylists, "fetchRecentPlaylists");
      __name(addTracksToPlaylist2, "addTracksToPlaylist");
      __name(pushRecentPlaylist2, "pushRecentPlaylist");
      __name(createOverlay, "createOverlay");
      __name(destroyOverlay, "destroyOverlay");
      __name(clearHoldTimer, "clearHoldTimer");
      __name(onDragStart2, "onDragStart");
      __name(onDragEnd, "onDragEnd");
      __name(onPointerMove, "onPointerMove");
      document.addEventListener("keydown", (e) => {
        if (!overlayEl) return;
        const num = parseInt(e.key, 10);
        if (num >= 1 && num <= MAX_PLAYLISTS_SHOWN) {
          const btn = overlayEl.querySelectorAll(".sn-quick-add-btn")[num - 1];
          btn?.click();
        }
      });
      __name(fetchPlaylistsFromAPI, "fetchPlaylistsFromAPI");
      __name(scrapeSidebarPlaylists, "scrapeSidebarPlaylists");
      __name(getRadialPlaylists, "getRadialPlaylists");
      __name(enableQuickAddRadialMenu, "enableQuickAddRadialMenu");
    }
  });

  // src-js/ui/components/SettingsSection.tsx
  var import_react, import_react_dom, _SettingsSection, SettingsSection;
  var init_SettingsSection = __esm({
    "src-js/ui/components/SettingsSection.tsx"() {
      "use strict";
      import_react = __toESM(__require("react"));
      import_react_dom = __toESM(__require("react-dom"));
      _SettingsSection = class _SettingsSection {
        constructor(name, settingsId, initialSettingsFields = {}) {
          this.name = name;
          this.settingsId = settingsId;
          this.initialSettingsFields = initialSettingsFields;
          this.settingsFields = this.initialSettingsFields;
          this.setRerender = null;
          /** Mounts the section when the user visits the Spotify settings route */
          this.pushSettings = /* @__PURE__ */ __name(async () => {
            Object.entries(this.settingsFields).forEach(([nameId, field]) => {
              if (field.type !== "button" && this.getFieldValue(nameId) === void 0) {
                this.setFieldValue(nameId, field.defaultValue);
              }
            });
            while (!window.Spicetify?.Platform?.History?.listen) {
              await new Promise((r) => setTimeout(r, 100));
            }
            if (this.stopHistoryListener) this.stopHistoryListener();
            this.stopHistoryListener = window.Spicetify.Platform.History.listen((e) => {
              if (e.pathname === "/preferences") this.render();
            });
            if (window.Spicetify.Platform.History.location.pathname === "/preferences") {
              await this.render();
            }
          }, "pushSettings");
          this.rerender = /* @__PURE__ */ __name(() => {
            this.setRerender?.(Math.random());
          }, "rerender");
          /* ----------------------- field creators ---------------------------- */
          this.addDropDown = /* @__PURE__ */ __name((nameId, description, options, defaultIndex, _onSelect, events) => {
            this.settingsFields[nameId] = {
              type: "dropdown",
              description,
              defaultValue: options[defaultIndex],
              options,
              events
            };
          }, "addDropDown");
          /** Toggle (checkbox) */
          this.addToggle = /* @__PURE__ */ __name((nameId, description, defaultValue, events) => {
            this.settingsFields[nameId] = {
              type: "toggle",
              description,
              defaultValue,
              events
            };
          }, "addToggle");
          /** Text / number / color input */
          this.addInput = /* @__PURE__ */ __name((nameId, description, defaultValue, inputType = "text", events) => {
            this.settingsFields[nameId] = {
              type: "input",
              description,
              defaultValue,
              inputType,
              events
            };
          }, "addInput");
          this.getFieldValue = /* @__PURE__ */ __name((nameId) => {
            return JSON.parse(
              window.Spicetify?.LocalStorage.get(this.storageKey(nameId)) || "null"
            )?.value;
          }, "getFieldValue");
          /* ---------------------- React wrappers ----------------------------- */
          this.FieldsContainer = /* @__PURE__ */ __name(() => {
            const [nonce, setNonce] = (0, import_react.useState)(0);
            this.setRerender = setNonce;
            return /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-section", key: nonce }, /* @__PURE__ */ import_react.default.createElement("h2", { className: "TypeElement-cello-textBase-type" }, this.name), Object.entries(this.settingsFields).map(([nameId, field]) => /* @__PURE__ */ import_react.default.createElement(this.Field, { key: nameId, nameId, field })));
          }, "FieldsContainer");
          this.Field = /* @__PURE__ */ __name(({
            nameId,
            field
          }) => {
            const id = `${this.settingsId}.${nameId}`;
            const initial = field.type === "button" ? field.value : this.getFieldValue(nameId) ?? field.defaultValue;
            const [value, setVal] = (0, import_react.useState)(initial);
            const setValue = /* @__PURE__ */ __name((v) => {
              setVal(v);
              this.setFieldValue(nameId, v);
            }, "setValue");
            if (field.type === "hidden") return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null);
            const Label = /* @__PURE__ */ import_react.default.createElement("label", { className: "TypeElement-viola-textSubdued-type", htmlFor: id }, field.description || "");
            let Control = null;
            switch (field.type) {
              case "dropdown":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "select",
                  {
                    className: "main-dropDown-dropDown",
                    id,
                    ...field.events,
                    onChange: (e) => {
                      const idx = e.currentTarget.selectedIndex;
                      const newVal = field.options[idx];
                      setValue(newVal);
                      field.events?.onChange?.(e);
                    }
                  },
                  field.options.map((opt, i) => /* @__PURE__ */ import_react.default.createElement("option", { key: opt, value: opt, selected: opt === value }, opt))
                );
                break;
              case "toggle":
                Control = /* @__PURE__ */ import_react.default.createElement("label", { className: "x-settings-secondColumn x-toggle-wrapper" }, /* @__PURE__ */ import_react.default.createElement(
                  "input",
                  {
                    id,
                    className: "x-toggle-input",
                    type: "checkbox",
                    checked: !!value,
                    ...field.events,
                    onClick: (e) => {
                      const checked = e.currentTarget.checked;
                      setValue(checked);
                      field.events?.onClick?.(e);
                    }
                  }
                ), /* @__PURE__ */ import_react.default.createElement("span", { className: "x-toggle-indicatorWrapper" }, /* @__PURE__ */ import_react.default.createElement("span", { className: "x-toggle-indicator" })));
                break;
              case "input":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "input",
                  {
                    className: "x-settings-input",
                    id,
                    dir: "ltr",
                    value,
                    type: field.inputType || "text",
                    ...field.events,
                    onChange: (e) => {
                      setValue(e.currentTarget.value);
                      field.events?.onChange?.(e);
                    }
                  }
                );
                break;
              case "button":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "button",
                  {
                    id,
                    className: "Button-sc-y0gtbx-0 Button-small-buttonSecondary-useBrowserDefaultFocusStyle x-settings-button",
                    ...field.events,
                    onClick: (e) => {
                      field.events?.onClick?.(e);
                    },
                    type: "button"
                  },
                  value
                );
                break;
              default:
                Control = null;
            }
            return /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-row" }, /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-firstColumn" }, Label), /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-secondColumn" }, Control));
          }, "Field");
        }
        /* --------------------- internal render helpers --------------------- */
        async render() {
          while (!document.getElementById("desktop.settings.selectLanguage")) {
            if (window.Spicetify.Platform.History.location.pathname !== "/preferences")
              return;
            await new Promise((r) => setTimeout(r, 100));
          }
          const container = document.querySelector(
            ".main-view-container__scroll-node-child main div"
          );
          if (!container)
            return console.error("[StarryNight] settings container not found");
          let host = Array.from(container.children).find(
            (c) => c.id === this.settingsId
          );
          if (!host) {
            host = document.createElement("div");
            host.id = this.settingsId;
            container.appendChild(host);
          }
          import_react_dom.default.render(/* @__PURE__ */ import_react.default.createElement(this.FieldsContainer, null), host);
        }
        /* ----- generic storage helpers (use Spicetify.LocalStorage) -------- */
        storageKey(nameId) {
          return `${this.settingsId}.${nameId}`;
        }
        setFieldValue(nameId, newValue) {
          window.Spicetify?.LocalStorage.set(
            this.storageKey(nameId),
            JSON.stringify({ value: newValue })
          );
        }
      };
      __name(_SettingsSection, "SettingsSection");
      SettingsSection = _SettingsSection;
    }
  });

  // src-js/ui/components/StarryNightSettings.ts
  var StarryNightSettings_exports = {};
  __export(StarryNightSettings_exports, {
    initializeStarryNightSettings: () => initializeStarryNightSettings
  });
  async function initializeStarryNightSettings() {
    const section = new SettingsSection(
      "StarryNight Theme",
      "starrynight-settings"
    );
    const accentOptions = [
      "dynamic",
      // 🎨 Album-based accent (Year 3000)
      "rosewater",
      "flamingo",
      "pink",
      "mauve",
      "red",
      "maroon",
      "peach",
      "yellow",
      "green",
      "teal",
      "sky",
      "sapphire",
      "blue",
      "lavender"
    ];
    function getSettingsManager() {
      const existing = window.Y3K?.system?.settingsManager;
      if (existing) return existing;
      const cached = globalThis.__SN_settingsManager;
      if (cached) return cached;
      const manager = new SettingsManager();
      globalThis.__SN_settingsManager = manager;
      return manager;
    }
    __name(getSettingsManager, "getSettingsManager");
    const settingsManager = getSettingsManager();
    const currentAccent = settingsManager.get("catppuccin-accentColor");
    section.addDropDown(
      "catppuccin-accentColor",
      // settings key (nameId)
      "Accent colour",
      // user-visible label
      accentOptions,
      // option list
      Math.max(0, accentOptions.indexOf(currentAccent)),
      // default index
      void 0,
      // onSelect (unused – we use onChange)
      {
        onChange: /* @__PURE__ */ __name((e) => {
          try {
            const idx = e?.currentTarget?.selectedIndex ?? 0;
            const newAccent = accentOptions[idx] ?? "mauve";
            settingsManager.set("catppuccin-accentColor", newAccent);
            const grad = settingsManager.get("sn-gradient-intensity");
            const stars = settingsManager.get("sn-star-density");
            applyStarryNightSettings(grad, stars);
            try {
              globalThis.Y3K?.system?.applyInitialSettings?.("accent");
            } catch (applyErr) {
              console.warn(
                "[StarryNight] Unable to trigger Year3000System colour refresh",
                applyErr
              );
            }
          } catch (err) {
            console.error("[StarryNight] Failed to update accent colour", err);
          }
        }, "onChange")
      }
    );
    const intensityOptions = [
      "disabled",
      "minimal",
      "balanced",
      "intense"
    ];
    const currentGradient = settingsManager.get("sn-gradient-intensity");
    section.addDropDown(
      "sn-gradient-intensity",
      "Gradient intensity",
      intensityOptions,
      Math.max(0, intensityOptions.indexOf(currentGradient)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const newGrad = intensityOptions[idx] ?? "balanced";
          settingsManager.set("sn-gradient-intensity", newGrad);
          const stars = settingsManager.get("sn-star-density");
          applyStarryNightSettings(newGrad, stars);
        }, "onChange")
      }
    );
    const currentFlowGradient = settingsManager.get("sn-flow-gradient");
    section.addDropDown(
      "sn-flow-gradient",
      "Flow gradient intensity (WebGL)",
      intensityOptions,
      Math.max(0, intensityOptions.indexOf(currentFlowGradient)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const newFlow = intensityOptions[idx] ?? "balanced";
          settingsManager.set("sn-flow-gradient", newFlow);
        }, "onChange")
      }
    );
    const currentStars = settingsManager.get("sn-star-density");
    section.addDropDown(
      "sn-star-density",
      "Star density",
      intensityOptions,
      Math.max(0, intensityOptions.indexOf(currentStars)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const newStars = intensityOptions[idx] ?? "balanced";
          settingsManager.set("sn-star-density", newStars);
          const grad = settingsManager.get("sn-gradient-intensity");
          applyStarryNightSettings(grad, newStars);
        }, "onChange")
      }
    );
    const brightnessOptions = ["bright", "balanced", "dark"];
    const currentBrightness = settingsManager.get("sn-brightness-mode") || "dark";
    section.addDropDown(
      "sn-brightness-mode",
      "Brightness mode",
      brightnessOptions,
      Math.max(0, brightnessOptions.indexOf(currentBrightness)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const newBrightness = brightnessOptions[idx] ?? "bright";
          settingsManager.set("sn-brightness-mode", newBrightness);
          document.documentElement.style.setProperty(
            "--sn-brightness-mode",
            `"${newBrightness}"`
          );
          document.documentElement.setAttribute(
            "data-sn-brightness",
            newBrightness
          );
          try {
            globalThis.Y3K?.system?.applyInitialSettings?.("brightness");
            console.log(`[StarryNight] Brightness mode changed to: ${newBrightness}`);
          } catch (applyErr) {
            console.warn(
              "[StarryNight] Unable to trigger Year3000System brightness refresh",
              applyErr
            );
          }
        }, "onChange")
      }
    );
    const flavourOptions = ["latte", "frappe", "macchiato", "mocha"];
    const currentFlavor = settingsManager.get("catppuccin-flavor");
    section.addDropDown(
      "catppuccin-flavor",
      "Catppuccin flavour",
      flavourOptions,
      Math.max(0, flavourOptions.indexOf(currentFlavor)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager.set("catppuccin-flavor", flavourOptions[idx]);
          try {
            globalThis.Y3K?.system?.applyInitialSettings?.("flavor");
          } catch (applyErr) {
            console.warn("[StarryNight] Unable to trigger flavor refresh", applyErr);
          }
        }, "onChange")
      }
    );
    const glassOptions = ["disabled", "minimal", "moderate", "intense"];
    const currentGlass = settingsManager.get("sn-glassmorphism-level");
    section.addDropDown(
      "sn-glassmorphism-level",
      "Glassmorphism",
      glassOptions,
      Math.max(0, glassOptions.indexOf(currentGlass)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager.set("sn-glassmorphism-level", glassOptions[idx]);
        }, "onChange")
      }
    );
    const fx3dOptions = ["full", "minimal", "disabled"];
    const current3d = settingsManager.get("sn-3d-effects-level");
    section.addDropDown(
      "sn-3d-effects-level",
      "3D card effects",
      fx3dOptions,
      Math.max(0, fx3dOptions.indexOf(current3d)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager.set("sn-3d-effects-level", fx3dOptions[idx]);
        }, "onChange")
      }
    );
    const artisticOptions = [
      "corporate-safe",
      "artist-vision",
      "cosmic-maximum"
    ];
    const currentArtistic = settingsManager.get("sn-artistic-mode");
    section.addDropDown(
      "sn-artistic-mode",
      "Artistic mode",
      artisticOptions,
      Math.max(0, artisticOptions.indexOf(currentArtistic)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const mode = artisticOptions[idx];
          settingsManager.set("sn-artistic-mode", mode);
          globalThis.year3000System?.YEAR3000_CONFIG?.safeSetArtisticMode?.(mode);
        }, "onChange")
      }
    );
    const harmonicModes = Object.keys(HARMONIC_MODES);
    const currentHarmMode = settingsManager.get("sn-current-harmonic-mode");
    if (harmonicModes.length) {
      section.addDropDown(
        "sn-current-harmonic-mode",
        "Harmonic colour mode",
        harmonicModes,
        Math.max(0, harmonicModes.indexOf(currentHarmMode)),
        void 0,
        {
          onChange: /* @__PURE__ */ __name((e) => {
            const idx = e?.currentTarget?.selectedIndex ?? 0;
            const modeKey = harmonicModes[idx];
            settingsManager.set("sn-current-harmonic-mode", modeKey);
            globalThis.Y3K?.system?.evolveHarmonicSignature?.(modeKey);
          }, "onChange")
        }
      );
    }
    const currentHarmInt = settingsManager.get("sn-harmonic-intensity") || "0.7";
    section.addInput(
      "sn-harmonic-intensity",
      "Harmonic intensity (0-1)",
      currentHarmInt,
      "number",
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const val = e.currentTarget.value;
          settingsManager.set("sn-harmonic-intensity", val);
        }, "onChange")
      }
    );
    const currentEvolution = settingsManager.get("sn-harmonic-evolution") === "true";
    section.addToggle(
      "sn-harmonic-evolution",
      "Allow harmonic evolution",
      currentEvolution,
      {
        onClick: /* @__PURE__ */ __name((e) => {
          const checked = e.currentTarget.checked;
          settingsManager.set(
            "sn-harmonic-evolution",
            checked ? "true" : "false"
          );
        }, "onClick")
      }
    );
    const currentManual = settingsManager.get("sn-harmonic-manual-base-color") || "";
    section.addInput(
      "sn-harmonic-manual-base-color",
      "Manual base colour",
      currentManual,
      "color",
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const val = e.currentTarget.value;
          settingsManager.set("sn-harmonic-manual-base-color", val);
          globalThis.Y3K?.system?.updateHarmonicBaseColor?.(val);
        }, "onChange")
      }
    );
    const enableAb = settingsManager.get("sn-enable-aberration") === "true";
    section.addToggle(
      "sn-enable-aberration",
      "Chromatic aberration effect",
      enableAb,
      {
        onClick: /* @__PURE__ */ __name((e) => {
          const checked = e.currentTarget.checked;
          settingsManager.set(
            "sn-enable-aberration",
            checked ? "true" : "false"
          );
        }, "onClick")
      }
    );
    const echoOptions = ["Off", "Subtle", "Balanced", "Intense"];
    const currentEcho = settingsManager.get("sn-echo-intensity") ?? "2";
    section.addDropDown(
      "sn-echo-intensity",
      "Temporal Echo Intensity",
      echoOptions,
      Math.min(3, parseInt(currentEcho, 10)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 2;
          settingsManager.set("sn-echo-intensity", `${idx}`);
        }, "onChange")
      }
    );
    const currentVisualInt = settingsManager.get("sn-visual-intensity") || "0.8";
    section.addInput(
      "sn-visual-intensity",
      "Visual intensity (0-1)",
      currentVisualInt,
      "number",
      {
        min: 0,
        max: 1,
        step: 0.05,
        onChange: /* @__PURE__ */ __name((e) => {
          const val = e.currentTarget.value;
          let num = parseFloat(val);
          if (isNaN(num)) num = 0.8;
          num = Math.max(0, Math.min(1, num));
          settingsManager.set("sn-visual-intensity", num.toFixed(2));
        }, "onChange")
      }
    );
    const animQualityOptions = ["auto", "low", "high"];
    const currentAnimQ = settingsManager.get("sn-animation-quality") || "auto";
    section.addDropDown(
      "sn-animation-quality",
      "Animation quality",
      animQualityOptions,
      Math.max(0, animQualityOptions.indexOf(currentAnimQ)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const val = animQualityOptions[idx] ?? "auto";
          settingsManager.set("sn-animation-quality", val);
        }, "onChange")
      }
    );
    const enableGlassPulse = settingsManager.get("sn-glass-beat-pulse") === "true";
    section.addToggle(
      "sn-glass-beat-pulse",
      "Glass Pulse (beat-synchronized glass effects)",
      enableGlassPulse,
      {
        onClick: /* @__PURE__ */ __name((e) => {
          const checked = e.currentTarget.checked;
          settingsManager.set(
            "sn-glass-beat-pulse",
            checked ? "true" : "false"
          );
          console.info("[StarryNight] Glass Pulse setting changed");
        }, "onClick")
      }
    );
    const currentGlassIntensity = settingsManager.get("sn-glass-base-intensity") || "0.5";
    section.addInput(
      "sn-glass-base-intensity",
      "Glass Base Intensity (0-1)",
      currentGlassIntensity,
      "number",
      {
        min: 0,
        max: 1,
        step: 0.1,
        onChange: /* @__PURE__ */ __name((e) => {
          const val = e.currentTarget.value;
          let num = parseFloat(val);
          if (isNaN(num)) num = 0.5;
          num = Math.max(0, Math.min(1, num));
          settingsManager.set("sn-glass-base-intensity", num.toFixed(1));
        }, "onChange")
      }
    );
    await section.pushSettings();
    console.log("\u2728 [StarryNight] spcr-settings panel initialised");
    const initialBrightness = settingsManager.get("sn-brightness-mode") || "dark";
    document.documentElement.style.setProperty(
      "--sn-brightness-mode",
      `"${initialBrightness}"`
    );
    document.documentElement.setAttribute(
      "data-sn-brightness",
      initialBrightness
    );
    console.log(`[StarryNight] Initial brightness mode set to: ${initialBrightness}`);
    const rerender = /* @__PURE__ */ __name(() => section.rerender(), "rerender");
    const history = globalThis.Spicetify?.Platform?.History;
    try {
      if (history?.listen) {
        history.listen(({ location }) => {
          if (location?.pathname === "/settings") {
            setTimeout(rerender, 100);
          }
        });
      }
    } catch (err) {
      console.warn("[StarryNight] Could not hook navigation for settings", err);
    }
    if (window.location.pathname === "/settings") {
      setTimeout(rerender, 300);
    }
  }
  var init_StarryNightSettings = __esm({
    "src-js/ui/components/StarryNightSettings.ts"() {
      "use strict";
      init_globalConfig();
      init_SettingsSection();
      init_SettingsManager();
      init_starryNightEffects();
      __name(initializeStarryNightSettings, "initializeStarryNightSettings");
    }
  });

  // src-js/visual/ui-effects/RightSidebarConsciousnessSystem.ts
  var RightSidebarConsciousnessSystem_exports = {};
  __export(RightSidebarConsciousnessSystem_exports, {
    RightSidebarConsciousnessSystem: () => RightSidebarConsciousnessSystem
  });
  var _RightSidebarConsciousnessSystem, RightSidebarConsciousnessSystem;
  var init_RightSidebarConsciousnessSystem = __esm({
    "src-js/visual/ui-effects/RightSidebarConsciousnessSystem.ts"() {
      "use strict";
      init_EventBus();
      init_BaseVisualSystem();
      init_SidebarPerformanceCoordinator();
      _RightSidebarConsciousnessSystem = class _RightSidebarConsciousnessSystem extends BaseVisualSystem {
        constructor(config, utils, perf, musicSync, settings, year3000System2 = null, coordinator) {
          super(config, utils, perf, musicSync, settings);
          // Current → target state for smooth lerp
          this.currentBeatIntensity = 0;
          this.targetBeatIntensity = 0;
          this.currentHueShift = 0;
          // degrees
          this.targetHueShift = 0;
          // Lerp smoothing factors
          this.INTENSITY_LERP = 0.25;
          this.HUE_LERP = 0.05;
          // Loop control
          this.fallbackRafId = null;
          this.lastTimestamp = performance.now();
          // Unsubscribe functions
          this.unsubBeat = null;
          this.unsubEnergy = null;
          this.year3000System = year3000System2;
          this.coordinator = coordinator || SidebarPerformanceCoordinator.getInstance({
            enableDebug: config.enableDebug,
            performanceAnalyzer: perf,
            onFlushComplete: /* @__PURE__ */ __name(() => {
              perf?.emitTrace?.(
                "[RightSidebarConsciousnessSystem] Coordinator flush completed"
              );
            }, "onFlushComplete")
          });
        }
        /* ------------------------------------------------------------------ */
        /* Initialization                                                     */
        /* ------------------------------------------------------------------ */
        async _performSystemSpecificInitialization() {
          this.unsubBeat = GlobalEventBus.subscribe(
            "music:beat",
            (payload) => this._handleBeat(payload)
          );
          this.unsubEnergy = GlobalEventBus.subscribe(
            "music:energy",
            (payload) => this._handleEnergy(payload)
          );
          this._tryRegisterWithMasterAnimation();
        }
        _tryRegisterWithMasterAnimation() {
          if (this.year3000System?.registerAnimationSystem && this.year3000System.enhancedMasterAnimationCoordinator) {
            const ok = this.year3000System.registerAnimationSystem(
              "RightSidebarConsciousnessSystem",
              this,
              "background",
              60
            );
            if (ok) return;
          }
          this._startFallbackLoop();
        }
        /* ------------------------------------------------------------------ */
        /* Event Handlers                                                     */
        /* ------------------------------------------------------------------ */
        _handleBeat({ intensity }) {
          this.targetBeatIntensity = Math.min(Math.max(intensity, 0), 1);
        }
        _handleEnergy({ energy }) {
          const deg = Math.round(energy * 120);
          this.targetHueShift = deg;
        }
        /* ------------------------------------------------------------------ */
        /* Animation Loop                                                     */
        /* ------------------------------------------------------------------ */
        onAnimate(deltaMs) {
          this._tick(deltaMs);
        }
        _startFallbackLoop() {
          const loop = /* @__PURE__ */ __name((ts) => {
            const delta = ts - this.lastTimestamp;
            this.lastTimestamp = ts;
            this._tick(delta);
            this.fallbackRafId = requestAnimationFrame(loop);
          }, "loop");
          this.fallbackRafId = requestAnimationFrame(loop);
        }
        _tick(_deltaMs) {
          this.currentBeatIntensity = this._lerp(
            this.currentBeatIntensity,
            this.targetBeatIntensity,
            this.INTENSITY_LERP
          );
          this.currentHueShift = this._lerp(
            this.currentHueShift,
            this.targetHueShift,
            this.HUE_LERP
          );
          this._queueCssVar("--sn-rs-beat-intensity", this.currentBeatIntensity);
          const glowAlpha = (0.15 + this.currentBeatIntensity * 0.45).toFixed(3);
          this._queueCssVar("--sn-rs-glow-alpha", glowAlpha);
          this._queueCssVar("--sn-rs-hue-shift", `${this.currentHueShift}deg`);
        }
        _queueCssVar(property, value) {
          this.coordinator.queueUpdate(property, String(value));
        }
        _lerp(from, to, alpha) {
          return from + (to - from) * alpha;
        }
        /* ------------------------------------------------------------------ */
        /* Cleanup                                                            */
        /* ------------------------------------------------------------------ */
        destroy() {
          super.destroy();
          this.unsubBeat?.();
          this.unsubEnergy?.();
          if (this.fallbackRafId) cancelAnimationFrame(this.fallbackRafId);
        }
      };
      __name(_RightSidebarConsciousnessSystem, "RightSidebarConsciousnessSystem");
      RightSidebarConsciousnessSystem = _RightSidebarConsciousnessSystem;
    }
  });

  // src-js/visual/consciousness/DepthConsciousnessController.ts
  var DepthConsciousnessController_exports = {};
  __export(DepthConsciousnessController_exports, {
    DepthConsciousnessController: () => DepthConsciousnessController
  });
  var _DepthConsciousnessController, DepthConsciousnessController;
  var init_DepthConsciousnessController = __esm({
    "src-js/visual/consciousness/DepthConsciousnessController.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_BaseVisualSystem();
      init_globalConfig();
      init_Year3000Utilities();
      _DepthConsciousnessController = class _DepthConsciousnessController extends BaseVisualSystem {
        // Max 10fps for consciousness updates
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, performanceMonitor = null, musicSyncService = null, settingsManager = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager);
          this.contentAreas = /* @__PURE__ */ new Map();
          this.chromeAreas = /* @__PURE__ */ new Set();
          this.userState = {
            isScrolling: false,
            isHovering: false,
            lastInteractionTime: 0,
            readingModeActive: false,
            interactionTarget: null
          };
          this.musicalState = {
            energy: 0.5,
            valence: 0.5,
            instrumental: false,
            tempo: 120
          };
          this.readingModeTimer = 0;
          this.interactionTimer = 0;
          this.consciousnessUpdateInterval = 0;
          // Performance optimization
          this.lastUpdate = 0;
          this.updateThreshold = 100;
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            this.detectContentAndChromeAreas();
            this.setupInteractionListeners();
            this.initializeConsciousnessVariables();
            this.startConsciousnessUpdate();
            Y3K?.debug?.log("DepthConsciousnessController", "Consciousness system awakened");
          } catch (error) {
            Y3K?.debug?.error("DepthConsciousnessController", "Failed to initialize consciousness:", error);
          }
        }
        /**
         * Detect content areas that need protection and chrome areas that can handle full effects
         */
        detectContentAndChromeAreas() {
          const contentSelectors = [
            ".main-view-container__scroll-node",
            ".main-trackList-trackListRow",
            '[data-testid*="tracklist"]',
            '[data-testid*="playlist"]',
            ".main-entityHeader-titleText",
            ".main-entityHeader-subtitle",
            ".main-trackList-rowTitle",
            ".main-trackList-rowSubTitle",
            "h1, h2, h3, h4, h5, h6",
            "p",
            ".lyrics-lyricsContainer-container"
          ];
          const chromeSelectors = [
            ".Root__nav-bar",
            ".Root__top-bar",
            ".Root__now-playing-bar",
            ".main-topBar-container",
            ".main-navBar-navBar",
            ".main-entityHeader-container",
            ".main-actionBar-container"
          ];
          contentSelectors.forEach((selector) => {
            document.querySelectorAll(selector).forEach((element) => {
              const contentArea = {
                element,
                type: this.determineContentType(element),
                protectionLevel: this.calculateProtectionLevel(element),
                lastInteraction: 0
              };
              this.contentAreas.set(element, contentArea);
              element.classList.add("content-sanctuary");
              element.setAttribute("data-consciousness-protected", "true");
              element.setAttribute("data-content-type", contentArea.type);
            });
          });
          chromeSelectors.forEach((selector) => {
            document.querySelectorAll(selector).forEach((element) => {
              this.chromeAreas.add(element);
              element.classList.add("ui-chrome-area");
              element.setAttribute("data-consciousness-enhanced", "true");
            });
          });
          Y3K?.debug?.log(
            "DepthConsciousnessController",
            `Detected ${this.contentAreas.size} content areas and ${this.chromeAreas.size} chrome areas`
          );
        }
        /**
         * Determine content type for appropriate protection level
         */
        determineContentType(element) {
          if (element.matches("h1, h2, h3, h4, h5, h6, .main-entityHeader-titleText")) {
            return "text";
          }
          if (element.matches('button, a, [role="button"], [tabindex], input, select')) {
            return "interactive";
          }
          if (element.matches(".main-image-container, .main-entityHeader-image, .cover-art")) {
            return "visual";
          }
          if (element.matches(".Root__nav-bar, .Root__top-bar, .main-topBar-container")) {
            return "chrome";
          }
          return "text";
        }
        /**
         * Calculate protection level based on content type and context
         */
        calculateProtectionLevel(element) {
          const contentType = this.determineContentType(element);
          switch (contentType) {
            case "text":
              return 0.95;
            case "interactive":
              return 0.9;
            case "visual":
              return 0.6;
            case "chrome":
              return 0.3;
            default:
              return 0.85;
          }
        }
        /**
         * Setup interaction listeners for consciousness awareness
         */
        setupInteractionListeners() {
          let scrollTimer;
          document.addEventListener("scroll", () => {
            this.userState.isScrolling = true;
            this.userState.lastInteractionTime = Date.now();
            clearTimeout(scrollTimer);
            scrollTimer = window.setTimeout(() => {
              this.userState.isScrolling = false;
            }, 150);
            this.updateUserInteractionState();
          }, { passive: true });
          this.contentAreas.forEach((contentArea, element) => {
            element.addEventListener("mouseenter", () => {
              this.userState.isHovering = true;
              this.userState.interactionTarget = element;
              this.userState.lastInteractionTime = Date.now();
              contentArea.lastInteraction = Date.now();
              this.updateUserInteractionState();
            });
            element.addEventListener("mouseleave", () => {
              this.userState.isHovering = false;
              this.userState.interactionTarget = null;
              this.updateUserInteractionState();
            });
          });
          document.addEventListener("mousemove", () => {
            clearTimeout(this.readingModeTimer);
            this.userState.readingModeActive = false;
            this.readingModeTimer = window.setTimeout(() => {
              if (this.userState.interactionTarget && this.contentAreas.has(this.userState.interactionTarget)) {
                this.userState.readingModeActive = true;
                this.updateUserInteractionState();
              }
            }, 2e3);
          });
          document.addEventListener("music-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.syncWithMusic(customEvent.detail);
            }
          });
          document.addEventListener("beat-detected", () => {
            this.handleBeatPulse();
          });
        }
        /**
         * Initialize CSS consciousness variables
         */
        initializeConsciousnessVariables() {
          const root = document.documentElement;
          root.style.setProperty("--consciousness-system-active", "1");
          root.style.setProperty("--content-protection-level", "0.95");
          root.style.setProperty("--chrome-enhancement-level", "2.0");
          root.style.setProperty("--consciousness-breath-rate", "4s");
          root.style.setProperty("--musical-sync-intensity", "0.5");
          root.style.setProperty("--reading-mode-active", "0");
          root.style.setProperty("--user-interaction-detected", "0");
        }
        /**
         * Start consciousness update loop
         */
        startConsciousnessUpdate() {
          const updateConsciousness = /* @__PURE__ */ __name(() => {
            if (!this.isActive) return;
            const now = performance.now();
            if (now - this.lastUpdate >= this.updateThreshold) {
              this.updateConsciousnessState();
              this.lastUpdate = now;
            }
            requestAnimationFrame(updateConsciousness);
          }, "updateConsciousness");
          updateConsciousness();
        }
        /**
         * Update consciousness state based on current conditions
         */
        updateConsciousnessState() {
          const root = document.documentElement;
          const baseIntensity = 0.5;
          const musicalModifier = this.musicalState.energy * 0.3;
          const interactionModifier = this.userState.isHovering ? -0.2 : 0;
          const readingModifier = this.userState.readingModeActive ? -0.4 : 0;
          const consciousnessIntensity = Math.max(
            0.1,
            baseIntensity + musicalModifier + interactionModifier + readingModifier
          );
          root.style.setProperty("--consciousness-intensity", consciousnessIntensity.toString());
          root.style.setProperty("--musical-sync-intensity", this.musicalState.energy.toString());
          root.style.setProperty("--reading-mode-active", this.userState.readingModeActive ? "1" : "0");
          root.style.setProperty(
            "--user-interaction-detected",
            this.userState.isScrolling || this.userState.isHovering ? "1" : "0"
          );
          root.classList.remove("music-energy-high", "music-energy-calm");
          if (this.musicalState.energy > 0.7) {
            root.classList.add("music-energy-high");
          } else if (this.musicalState.energy < 0.3) {
            root.classList.add("music-energy-calm");
          }
          root.setAttribute(
            "data-user-interacting",
            (this.userState.isScrolling || this.userState.isHovering).toString()
          );
          root.setAttribute("data-reading-mode", this.userState.readingModeActive.toString());
        }
        /**
         * Update user interaction state
         */
        updateUserInteractionState() {
          this.updateConsciousnessState();
        }
        /**
         * Sync consciousness with musical state
         */
        syncWithMusic(musicState) {
          Object.assign(this.musicalState, musicState);
          if (musicState.tempo) {
            const breathRate = Math.max(2, Math.min(8, 60 / (musicState.tempo / 60) * 4));
            document.documentElement.style.setProperty("--consciousness-breath-rate", `${breathRate}s`);
          }
          this.updateConsciousnessState();
          Y3K?.debug?.log(
            "DepthConsciousnessController",
            `Musical consciousness sync: energy=${musicState.energy}, tempo=${musicState.tempo}`
          );
        }
        /**
         * Handle beat pulse for consciousness effects
         */
        handleBeatPulse() {
          if (this.userState.readingModeActive) return;
          const root = document.documentElement;
          const currentIntensity = parseFloat(root.style.getPropertyValue("--consciousness-intensity") || "0.5");
          const pulseIntensity = Math.min(1, currentIntensity + 0.1);
          root.style.setProperty("--consciousness-intensity", pulseIntensity.toString());
          setTimeout(() => {
            if (this.isActive) {
              this.updateConsciousnessState();
            }
          }, 100);
        }
        /**
         * Dynamically add content protection to new elements
         */
        protectNewContent(element) {
          if (this.contentAreas.has(element)) return;
          const contentArea = {
            element,
            type: this.determineContentType(element),
            protectionLevel: this.calculateProtectionLevel(element),
            lastInteraction: 0
          };
          this.contentAreas.set(element, contentArea);
          element.classList.add("content-sanctuary");
          element.setAttribute("data-consciousness-protected", "true");
          element.setAttribute("data-content-type", contentArea.type);
          Y3K?.debug?.log(
            "DepthConsciousnessController",
            `Protected new content element: ${element.tagName}.${element.className}`
          );
        }
        /**
         * Enhanced chrome area
         */
        enhanceNewChrome(element) {
          if (this.chromeAreas.has(element)) return;
          this.chromeAreas.add(element);
          element.classList.add("ui-chrome-area");
          element.setAttribute("data-consciousness-enhanced", "true");
          Y3K?.debug?.log(
            "DepthConsciousnessController",
            `Enhanced new chrome element: ${element.tagName}.${element.className}`
          );
        }
        /**
         * Force reading mode for accessibility
         */
        forceReadingMode(active) {
          this.userState.readingModeActive = active;
          this.updateUserInteractionState();
          Y3K?.debug?.log(
            "DepthConsciousnessController",
            `Reading mode ${active ? "activated" : "deactivated"}`
          );
        }
        /**
         * Get consciousness metrics for monitoring
         */
        getConsciousnessMetrics() {
          return {
            contentAreas: this.contentAreas.size,
            chromeAreas: this.chromeAreas.size,
            consciousnessIntensity: parseFloat(
              document.documentElement.style.getPropertyValue("--consciousness-intensity") || "0.5"
            ),
            readingModeActive: this.userState.readingModeActive,
            userInteracting: this.userState.isScrolling || this.userState.isHovering,
            musicalEnergy: this.musicalState.energy
          };
        }
        async healthCheck() {
          const metrics = this.getConsciousnessMetrics();
          const isHealthy = metrics.contentAreas > 0 && metrics.chromeAreas > 0;
          return {
            healthy: isHealthy,
            issues: isHealthy ? [] : ["Consciousness system not properly initialized"],
            metrics: {
              consciousnessLevel: metrics.contentAreas > 0 ? 1 : 0,
              protectedAreas: metrics.contentAreas,
              enhancedAreas: metrics.chromeAreas,
              musicalEnergy: metrics.musicalEnergy
            }
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          clearTimeout(this.readingModeTimer);
          clearTimeout(this.interactionTimer);
          this.contentAreas.forEach((_, element) => {
            element.classList.remove("content-sanctuary");
            element.removeAttribute("data-consciousness-protected");
            element.removeAttribute("data-content-type");
          });
          this.chromeAreas.forEach((element) => {
            element.classList.remove("ui-chrome-area");
            element.removeAttribute("data-consciousness-enhanced");
          });
          const root = document.documentElement;
          root.style.removeProperty("--consciousness-system-active");
          root.style.removeProperty("--consciousness-intensity");
          root.style.removeProperty("--reading-mode-active");
          root.style.removeProperty("--user-interaction-detected");
          root.classList.remove("music-energy-high", "music-energy-calm");
          root.removeAttribute("data-user-interacting");
          root.removeAttribute("data-reading-mode");
          Y3K?.debug?.log("DepthConsciousnessController", "Consciousness system deactivated");
        }
      };
      __name(_DepthConsciousnessController, "DepthConsciousnessController");
      DepthConsciousnessController = _DepthConsciousnessController;
    }
  });

  // src-js/visual/consciousness/DynamicCatppuccinBridge.ts
  var DynamicCatppuccinBridge_exports = {};
  __export(DynamicCatppuccinBridge_exports, {
    DynamicCatppuccinBridge: () => DynamicCatppuccinBridge
  });
  var _DynamicCatppuccinBridge, DynamicCatppuccinBridge;
  var init_DynamicCatppuccinBridge = __esm({
    "src-js/visual/consciousness/DynamicCatppuccinBridge.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_BaseVisualSystem();
      init_globalConfig();
      init_Year3000Utilities();
      init_UnifiedEventBus();
      _DynamicCatppuccinBridge = class _DynamicCatppuccinBridge extends BaseVisualSystem {
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, performanceMonitor = null, musicSyncService = null, settingsManager = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager);
          this.colorHarmonyEngine = null;
          this.depthConsciousnessController = null;
          this.dynamicColorState = {
            currentAccentHex: "#cba6f7",
            // Default Catppuccin Mocha mauve (proper fallback)
            currentAccentRgb: "203,166,247",
            baseBackgroundHex: "#0d1117",
            // Default StarryNight deep space black
            baseBackgroundRgb: "13,17,23",
            lastUpdateTime: 0,
            musicEnergy: 0.5,
            transitionInProgress: false
          };
          this.integrationConfig = {
            accentUpdateEnabled: true,
            baseTransformationEnabled: true,
            consciousnessIntegrationEnabled: true,
            smoothTransitionDuration: 800,
            // 0.8s smooth transitions
            energyResponseMultiplier: 1.2
          };
          // Transition management
          this.transitionTimer = 0;
          this.lastTransitionStartTime = 0;
          this.transitionFromAccent = "";
          this.transitionToAccent = "";
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            this.setupColorExtractionListeners();
            this.setupSettingsListeners();
            this.initializeCurrentState();
            const isEnabled = this.checkDynamicAccentEnabled();
            this.integrationConfig.accentUpdateEnabled = isEnabled;
            if (isEnabled) {
              Y3K?.debug?.log("DynamicCatppuccinBridge", "Dynamic accent enabled - bridge active");
            } else {
              Y3K?.debug?.log("DynamicCatppuccinBridge", "Dynamic accent disabled - bridge standby (will activate when enabled)");
            }
            Y3K?.debug?.log("DynamicCatppuccinBridge", "Color Extension Facade initialized successfully");
          } catch (error) {
            Y3K?.debug?.error("DynamicCatppuccinBridge", "Failed to initialize facade:", error);
          }
        }
        /**
         * Check if dynamic accent is enabled in settings
         */
        checkDynamicAccentEnabled() {
          try {
            if (!this.settingsManager) return false;
            const accentSetting = this.settingsManager.get("catppuccin-accentColor");
            const isDynamic = String(accentSetting) === "dynamic";
            if (this.config.enableDebug) {
              Y3K?.debug?.log("DynamicCatppuccinBridge", `Accent setting: ${accentSetting}, Dynamic: ${isDynamic}`);
            }
            return isDynamic;
          } catch (error) {
            Y3K?.debug?.error("DynamicCatppuccinBridge", "Error checking dynamic accent setting:", error);
            return false;
          }
        }
        /**
         * Setup listeners for color extraction events
         * 🔧 CRITICAL FIX: Enhanced with UnifiedEventBus integration
         */
        setupColorExtractionListeners() {
          unifiedEventBus.subscribe("colors:extracted", (data) => {
            if (data.rawColors) {
              this.handleExtractedColors(data.rawColors);
            }
          }, "DynamicCatppuccinBridge");
          unifiedEventBus.subscribe("colors:harmonized", (data) => {
            if (data.processedColors) {
              this.handleHarmonizedColors(data.processedColors);
            }
          }, "DynamicCatppuccinBridge");
          unifiedEventBus.subscribe("colors:applied", (data) => {
            if (data.cssVariables && this.integrationConfig.accentUpdateEnabled) {
              this.handleCSSVariablesApplied(data.cssVariables, data.accentHex, data.accentRgb);
            }
          }, "DynamicCatppuccinBridge");
          document.addEventListener("colors-extracted", (event) => {
            const customEvent = event;
            if (customEvent.detail && customEvent.detail.extractedColors) {
              this.handleExtractedColors(customEvent.detail.extractedColors);
            }
          });
          document.addEventListener("colors-harmonized", (event) => {
            const customEvent = event;
            if (customEvent.detail && customEvent.detail.harmonizedColors) {
              this.handleHarmonizedColors(customEvent.detail.harmonizedColors);
            }
          });
          document.addEventListener("music-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.handleMusicStateChange(customEvent.detail);
            }
          });
          document.addEventListener("spice-colors/update-request", (event) => {
            const customEvent = event;
            if (customEvent.detail && this.integrationConfig.accentUpdateEnabled) {
              this.handleSpiceColorUpdateRequest(customEvent.detail);
            }
          });
          Y3K?.debug?.log("DynamicCatppuccinBridge", "Enhanced color extraction and coordination listeners setup complete (UnifiedEventBus + DOM)");
        }
        /**
         * Handle requests from other systems to update spice colors
         */
        handleSpiceColorUpdateRequest(colorData) {
          const { accentHex, primaryHex, secondaryHex, source } = colorData;
          if (this.config.enableDebug) {
            Y3K?.debug?.log("DynamicCatppuccinBridge", `Received spice color update request from ${source}:`, {
              accent: accentHex,
              primary: primaryHex,
              secondary: secondaryHex
            });
          }
          if (accentHex && accentHex !== this.dynamicColorState.currentAccentHex) {
            this.scheduleSmoothAccentTransition(accentHex);
          }
          if (primaryHex) {
            this.updateLivingBaseBackground(primaryHex);
          }
          document.dispatchEvent(new CustomEvent("spice-colors/updated", {
            detail: {
              source: "DynamicCatppuccinBridge",
              applied: {
                accent: accentHex,
                primary: primaryHex,
                secondary: secondaryHex
              },
              timestamp: Date.now()
            }
          }));
        }
        /**
         * Setup settings change listeners
         */
        setupSettingsListeners() {
          document.addEventListener("year3000SystemSettingsChanged", (event) => {
            const customEvent = event;
            const { key, value } = customEvent.detail || {};
            if (key === "catppuccin-accentColor") {
              const isDynamic = String(value) === "dynamic";
              this.integrationConfig.accentUpdateEnabled = isDynamic;
              if (isDynamic && !this.isActive) {
                this.initialize();
              } else if (!isDynamic && this.isActive) {
                this.destroy();
              }
              Y3K?.debug?.log("DynamicCatppuccinBridge", `Accent setting changed to: ${value}, Bridge active: ${this.isActive}`);
            }
          });
        }
        /**
         * Initialize current state from existing CSS variables
         * Prioritizes ColorHarmonyEngine variables, then falls back to Catppuccin defaults
         */
        initializeCurrentState() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentAccent = computedStyle.getPropertyValue("--sn-accent-hex").trim() || computedStyle.getPropertyValue("--sn-musical-harmony-primary-hex").trim() || computedStyle.getPropertyValue("--sn-dynamic-accent-hex").trim() || computedStyle.getPropertyValue("--sn-cosmic-accent-hex").trim() || computedStyle.getPropertyValue("--spice-accent").trim();
          if (currentAccent) {
            this.dynamicColorState.currentAccentHex = currentAccent;
            const rgb = this.utils.hexToRgb(currentAccent);
            if (rgb) {
              this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
            }
          }
          const currentBase = computedStyle.getPropertyValue("--sn-cosmic-base-hex").trim() || computedStyle.getPropertyValue("--spice-base").trim() || "#0d1117";
          this.dynamicColorState.baseBackgroundHex = currentBase;
          const baseRgb = this.utils.hexToRgb(currentBase);
          if (baseRgb) {
            this.dynamicColorState.baseBackgroundRgb = `${baseRgb.r},${baseRgb.g},${baseRgb.b}`;
          }
          this.dynamicColorState.lastUpdateTime = Date.now();
          Y3K?.debug?.log("DynamicCatppuccinBridge", "Current state initialized:", {
            accent: this.dynamicColorState.currentAccentHex,
            base: this.dynamicColorState.baseBackgroundHex
          });
        }
        /**
         * Handle extracted colors from ColorHarmonyEngine
         */
        handleExtractedColors(extractedColors) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            const newAccentHex = this.selectBestAccentColor(extractedColors);
            if (newAccentHex && newAccentHex !== this.dynamicColorState.currentAccentHex) {
              this.scheduleSmoothAccentTransition(newAccentHex);
            }
            Y3K?.debug?.log("DynamicCatppuccinBridge", "Processed extracted colors:", {
              input: Object.keys(extractedColors),
              selectedAccent: newAccentHex
            });
          } catch (error) {
            Y3K?.debug?.error("DynamicCatppuccinBridge", "Error handling extracted colors:", error);
          }
        }
        /**
         * Handle harmonized colors (post-processing)
         * Extract accent color from ColorHarmonyEngine and apply it immediately
         */
        handleHarmonizedColors(harmonizedColors) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            const newAccentHex = harmonizedColors["VIBRANT"] || harmonizedColors["PROMINENT"] || harmonizedColors["VIBRANT_NON_ALARMING"] || harmonizedColors["LIGHT_VIBRANT"] || harmonizedColors["PRIMARY"] || Object.values(harmonizedColors)[0];
            if (newAccentHex && newAccentHex !== this.dynamicColorState.currentAccentHex) {
              if (this.config.enableDebug) {
                console.log("\u{1F3A8} [DynamicCatppuccinBridge] Applying harmonized accent color:", {
                  from: this.dynamicColorState.currentAccentHex,
                  to: newAccentHex,
                  source: "ColorHarmonyEngine harmonized colors"
                });
              }
              this.scheduleSmoothAccentTransition(newAccentHex);
            }
            this.applyHarmonizedColorsToDynamicSystem(harmonizedColors);
          } catch (error) {
            console.error("\u{1F3A8} [DynamicCatppuccinBridge] Error handling harmonized colors:", error);
          }
        }
        /**
         * Handle CSS variables applied event from ColorHarmonyEngine
         * 🔧 CRITICAL FIX: New handler for colors:applied events
         */
        handleCSSVariablesApplied(cssVariables, accentHex, accentRgb) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            if (accentHex && accentHex !== this.dynamicColorState.currentAccentHex) {
              this.dynamicColorState.currentAccentHex = accentHex;
              this.dynamicColorState.currentAccentRgb = accentRgb;
              this.dynamicColorState.lastUpdateTime = Date.now();
            }
            const enhancedVariables = {};
            const accent = cssVariables["--sn-accent-hex"] || cssVariables["--spice-accent"] || accentHex;
            const accentRgbVar = cssVariables["--sn-accent-rgb"] || cssVariables["--spice-rgb-accent"] || accentRgb;
            if (accent && accentRgbVar) {
              enhancedVariables["--sn-dynamic-accent-hex"] = accent;
              enhancedVariables["--sn-dynamic-accent-rgb"] = accentRgbVar;
              enhancedVariables["--sn-dynamic-primary-hex"] = accent;
              enhancedVariables["--sn-dynamic-primary-rgb"] = accentRgbVar;
              const root = document.documentElement;
              Object.entries(enhancedVariables).forEach(([property, value]) => {
                root.style.setProperty(property, value);
              });
            }
            Y3K?.debug?.log("DynamicCatppuccinBridge", "Processed colors:applied event:", {
              accentHex: accent,
              accentRgb: accentRgbVar,
              variablesProcessed: Object.keys(cssVariables).length,
              enhancedVariables: Object.keys(enhancedVariables).length
            });
          } catch (error) {
            Y3K?.debug?.error("DynamicCatppuccinBridge", "Error handling CSS variables applied:", error);
          }
        }
        /**
         * Handle music state changes for energy-responsive effects
         */
        handleMusicStateChange(musicState) {
          if (musicState.energy !== void 0) {
            this.dynamicColorState.musicEnergy = musicState.energy;
            if (this.integrationConfig.consciousnessIntegrationEnabled) {
              this.updateConsciousnessWithMusicEnergy(musicState.energy);
            }
          }
        }
        /**
         * Select best accent color from extracted colors
         */
        selectBestAccentColor(colors) {
          const priorities = [
            "VIBRANT_NON_ALARMING",
            // Best for UI - vibrant but not overwhelming
            "VIBRANT",
            // Strong and lively
            "LIGHT_VIBRANT",
            // Lighter variant
            "PROMINENT",
            // Most noticeable color
            "PRIMARY",
            // Primary extracted color
            "DARK_VIBRANT"
            // Darker variant as fallback
          ];
          for (const key of priorities) {
            const color2 = colors[key];
            if (color2 && this.utils.hexToRgb(color2)) {
              return color2;
            }
          }
          return null;
        }
        /**
         * Schedule smooth transition between accent colors
         */
        scheduleSmoothAccentTransition(newAccentHex) {
          if (this.dynamicColorState.transitionInProgress) {
            this.transitionToAccent = newAccentHex;
            return;
          }
          this.transitionFromAccent = this.dynamicColorState.currentAccentHex;
          this.transitionToAccent = newAccentHex;
          this.dynamicColorState.transitionInProgress = true;
          this.lastTransitionStartTime = Date.now();
          this.animateAccentTransition();
          Y3K?.debug?.log("DynamicCatppuccinBridge", `Accent transition scheduled: ${this.transitionFromAccent} \u2192 ${newAccentHex}`);
        }
        /**
         * Animate smooth accent color transitions
         */
        animateAccentTransition() {
          const animate = /* @__PURE__ */ __name(() => {
            if (!this.dynamicColorState.transitionInProgress) return;
            const elapsed = Date.now() - this.lastTransitionStartTime;
            const progress = Math.min(elapsed / this.integrationConfig.smoothTransitionDuration, 1);
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const currentColor = this.interpolateColors(
              this.transitionFromAccent,
              this.transitionToAccent,
              easeProgress
            );
            if (currentColor) {
              this.applyDynamicAccent(currentColor);
            }
            if (progress >= 1) {
              this.dynamicColorState.transitionInProgress = false;
              this.dynamicColorState.currentAccentHex = this.transitionToAccent;
              this.dynamicColorState.lastUpdateTime = Date.now();
              const rgb = this.utils.hexToRgb(this.transitionToAccent);
              if (rgb) {
                this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
              }
              Y3K?.debug?.log("DynamicCatppuccinBridge", `Accent transition complete: ${this.transitionToAccent}`);
            } else {
              requestAnimationFrame(animate);
            }
          }, "animate");
          requestAnimationFrame(animate);
        }
        /**
         * Interpolate between two hex colors
         */
        interpolateColors(fromHex, toHex, progress) {
          const fromRgb = this.utils.hexToRgb(fromHex);
          const toRgb = this.utils.hexToRgb(toHex);
          if (!fromRgb || !toRgb) return null;
          const r = Math.round(fromRgb.r + (toRgb.r - fromRgb.r) * progress);
          const g2 = Math.round(fromRgb.g + (toRgb.g - fromRgb.g) * progress);
          const b = Math.round(fromRgb.b + (toRgb.b - fromRgb.b) * progress);
          return this.utils.rgbToHex(r, g2, b);
        }
        /**
         * Apply dynamic accent using Color Extension Facade
         * Updates both core Spicetify variables AND consciousness extensions
         */
        applyDynamicAccent(accentHex) {
          console.log("\u{1F3A8} [DynamicCatppuccinBridge] Applying dynamic accent color:", {
            accentHex,
            previousAccent: this.dynamicColorState.currentAccentHex,
            timestamp: Date.now()
          });
          const root = document.documentElement;
          const rgb = this.utils.hexToRgb(accentHex);
          if (!rgb) {
            console.error("\u{1F3A8} [DynamicCatppuccinBridge] Failed to convert accent hex to RGB:", accentHex);
            return;
          }
          const rgbString = `${rgb.r},${rgb.g},${rgb.b}`;
          const variablesToSet = {
            "--sn-dynamic-accent-hex": accentHex,
            "--sn-dynamic-accent-rgb": rgbString,
            "--sn-dynamic-primary-hex": accentHex,
            "--sn-dynamic-primary-rgb": rgbString,
            "--spice-accent": accentHex,
            "--spice-button": accentHex,
            "--spice-button-active": accentHex,
            "--spice-rgb-accent": rgbString,
            "--spice-rgb-button": rgbString,
            "--sn-color-extracted-primary-rgb": rgbString,
            "--sn-color-extracted-vibrant-rgb": rgbString,
            "--sn-color-extracted-dominant-rgb": rgbString
          };
          console.log("\u{1F3A8} [DynamicCatppuccinBridge] Setting CSS variables:", variablesToSet);
          root.style.setProperty("--sn-dynamic-accent-hex", accentHex);
          root.style.setProperty("--sn-dynamic-accent-rgb", rgbString);
          root.style.setProperty("--sn-dynamic-primary-hex", accentHex);
          root.style.setProperty("--sn-dynamic-primary-rgb", rgbString);
          root.style.setProperty("--spice-accent", accentHex);
          root.style.setProperty("--spice-button", accentHex);
          root.style.setProperty("--spice-button-active", accentHex);
          root.style.setProperty("--spice-rgb-accent", rgbString);
          root.style.setProperty("--spice-rgb-button", rgbString);
          root.style.setProperty("--sn-color-extracted-primary-rgb", rgbString);
          root.style.setProperty("--sn-color-extracted-vibrant-rgb", rgbString);
          root.style.setProperty("--sn-color-extracted-dominant-rgb", rgbString);
          if (this.integrationConfig.consciousnessIntegrationEnabled) {
            this.updateConsciousnessWithAccent(accentHex, rgbString);
          }
          if (this.config.enableDebug) {
            Y3K?.debug?.log("DynamicCatppuccinBridge", `Applied gradient colors: --sn-gradient-primary=${accentHex}, --sn-gradient-primary-rgb=${rgbString}`);
          }
        }
        /**
         * Apply harmonized colors to the dynamic system
         */
        applyHarmonizedColorsToDynamicSystem(harmonizedColors) {
          const primaryHex = harmonizedColors.VIBRANT || harmonizedColors.PRIMARY;
          if (primaryHex) {
            if (this.integrationConfig.baseTransformationEnabled) {
              this.updateLivingBaseBackground(primaryHex);
            }
          }
        }
        /**
         * Update consciousness system with new accent awareness
         */
        updateConsciousnessWithAccent(accentHex, accentRgb) {
          const root = document.documentElement;
          root.style.setProperty("--organic-holographic-rgb", accentRgb);
          root.style.setProperty("--holographic-scanline-rgb", accentRgb);
          root.style.setProperty(
            "--consciousness-intensity",
            `calc(0.5 + var(--musical-sync-intensity) * ${this.integrationConfig.energyResponseMultiplier})`
          );
          if (this.depthConsciousnessController) {
            Y3K?.debug?.log("DynamicCatppuccinBridge", "Notifying depth consciousness of accent change");
          }
        }
        /**
         * Update consciousness with music energy
         */
        updateConsciousnessWithMusicEnergy(energy) {
          const root = document.documentElement;
          const adjustedEnergy = energy * this.integrationConfig.energyResponseMultiplier;
          root.style.setProperty("--musical-sync-intensity", adjustedEnergy.toString());
          root.style.setProperty("--holographic-music-flicker-intensity", adjustedEnergy.toString());
          const baseIntensity = 0.5;
          const consciousnessIntensity = Math.max(0.1, Math.min(1, baseIntensity + adjustedEnergy * 0.3));
          root.style.setProperty("--consciousness-intensity", consciousnessIntensity.toString());
        }
        /**
         * Update living base background using Color Extension Facade
         * Preserves Spicetify base while adding consciousness layers
         */
        updateLivingBaseBackground(primaryHex) {
          const root = document.documentElement;
          const primaryRgb = this.utils.hexToRgb(primaryHex);
          if (!primaryRgb) return;
          const primaryRgbString = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          root.style.setProperty("--sn-dynamic-secondary-hex", primaryHex);
          root.style.setProperty("--sn-dynamic-secondary-rgb", primaryRgbString);
          root.style.setProperty("--sn-color-extracted-secondary-rgb", primaryRgbString);
          root.style.setProperty("--sn-color-harmony-complementary-rgb", primaryRgbString);
          const consciousnessGradient = `
      linear-gradient(135deg, 
        var(--spice-base) 0%,
        rgba(${primaryRgbString}, 0.08) 30%,
        var(--spice-base) 70%
      ),
      var(--spice-base)
    `;
          root.style.setProperty("--living-base-gradient", consciousnessGradient);
          root.style.setProperty("--consciousness-base-gradient", consciousnessGradient);
          if (this.config.enableDebug) {
            Y3K?.debug?.log("DynamicCatppuccinBridge", `Living base updated: --sn-gradient-secondary=${primaryHex}, --sn-gradient-secondary-rgb=${primaryRgbString}`);
          }
        }
        /**
         * Link with other consciousness systems
         */
        linkWithColorHarmonyEngine(engine) {
          this.colorHarmonyEngine = engine;
          Y3K?.debug?.log("DynamicCatppuccinBridge", "Linked with ColorHarmonyEngine");
        }
        linkWithDepthConsciousness(controller) {
          this.depthConsciousnessController = controller;
          Y3K?.debug?.log("DynamicCatppuccinBridge", "Linked with DepthConsciousnessController");
        }
        /**
         * Get current dynamic color state for debugging
         */
        getDynamicColorState() {
          return { ...this.dynamicColorState };
        }
        /**
         * Debug utility: Get current facade variable values
         */
        getFacadeVariableStatus() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          return {
            // Core Spicetify Variables
            spicetifyVars: {
              accent: computedStyle.getPropertyValue("--spice-accent").trim(),
              button: computedStyle.getPropertyValue("--spice-button").trim(),
              rgbAccent: computedStyle.getPropertyValue("--spice-rgb-accent").trim(),
              base: computedStyle.getPropertyValue("--spice-base").trim()
            },
            // Consciousness Extensions
            consciousnessVars: {
              gradientPrimary: computedStyle.getPropertyValue("--sn-gradient-primary-rgb").trim(),
              accentHex: computedStyle.getPropertyValue("--sn-color-accent-hex").trim(),
              accentRgb: computedStyle.getPropertyValue("--sn-color-accent-rgb").trim(),
              extractedPrimary: computedStyle.getPropertyValue("--sn-color-extracted-primary-rgb").trim(),
              livingBaseGradient: computedStyle.getPropertyValue("--living-base-gradient").trim()
            },
            // Configuration Status
            config: {
              dynamicAccentEnabled: this.checkDynamicAccentEnabled(),
              accentUpdateEnabled: this.integrationConfig.accentUpdateEnabled,
              consciousnessEnabled: this.integrationConfig.consciousnessIntegrationEnabled,
              isActive: this.isActive
            }
          };
        }
        /**
         * Update integration configuration
         */
        updateConfig(newConfig) {
          this.integrationConfig = { ...this.integrationConfig, ...newConfig };
          Y3K?.debug?.log("DynamicCatppuccinBridge", "Configuration updated:", newConfig);
        }
        async healthCheck() {
          const isDynamicEnabled = this.checkDynamicAccentEnabled();
          const hasRecentUpdate = Date.now() - this.dynamicColorState.lastUpdateTime < 3e4;
          return {
            healthy: this.isActive && isDynamicEnabled,
            issues: this.isActive && !isDynamicEnabled ? ["Dynamic accent not enabled in settings"] : [],
            metrics: {
              dynamicAccentEnabled: isDynamicEnabled,
              currentAccent: this.dynamicColorState.currentAccentHex,
              lastUpdateAge: Date.now() - this.dynamicColorState.lastUpdateTime,
              hasRecentUpdate,
              transitionInProgress: this.dynamicColorState.transitionInProgress,
              musicEnergy: this.dynamicColorState.musicEnergy
            }
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.transitionTimer) {
            clearTimeout(this.transitionTimer);
            this.transitionTimer = 0;
          }
          this.dynamicColorState.transitionInProgress = false;
          unifiedEventBus.unsubscribeAll("DynamicCatppuccinBridge");
          Y3K?.debug?.log("DynamicCatppuccinBridge", "Dynamic Catppuccin bridge cleaned up (including UnifiedEventBus subscriptions)");
        }
      };
      __name(_DynamicCatppuccinBridge, "DynamicCatppuccinBridge");
      DynamicCatppuccinBridge = _DynamicCatppuccinBridge;
    }
  });

  // src-js/visual/consciousness/LivingGradientBaseSystem.ts
  var LivingGradientBaseSystem_exports = {};
  __export(LivingGradientBaseSystem_exports, {
    LivingGradientBaseSystem: () => LivingGradientBaseSystem
  });
  var _LivingGradientBaseSystem, LivingGradientBaseSystem;
  var init_LivingGradientBaseSystem = __esm({
    "src-js/visual/consciousness/LivingGradientBaseSystem.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_BaseVisualSystem();
      init_globalConfig();
      init_Year3000Utilities();
      init_UnifiedEventBus();
      _LivingGradientBaseSystem = class _LivingGradientBaseSystem extends BaseVisualSystem {
        // Increased from 33ms to 100ms for better performance
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, performanceMonitor = null, musicSyncService = null, settingsManager = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager);
          this.livingBaseState = {
            currentBaseHex: "#1e1e2e",
            // Catppuccin base
            currentBaseRgb: "30,30,46",
            currentPrimaryHex: "#cba6f7",
            // Default mauve
            currentPrimaryRgb: "203,166,247",
            consciousnessIntensity: 0.5,
            breathingPhase: 0,
            musicEnergy: 0.5,
            lastUpdateTime: 0,
            webglIntegrationActive: false
          };
          this.gradientConfig = {
            baseTransformationEnabled: true,
            webglIntegrationEnabled: true,
            breathingAnimationEnabled: true,
            consciousnessLayerOpacity: 0.08,
            // Subtle but visible
            organicFlowIntensity: 1.2,
            musicResponsiveness: 1
          };
          // Animation control
          this.animationFrameId = 0;
          this.breathingStartTime = 0;
          // Performance throttling
          this.lastFrameTime = 0;
          this.frameThrottleMs = 16;
          // 60fps = 16.67ms
          this.previousGradientValues = {
            breathingPhase: 0,
            consciousnessIntensity: 0,
            musicEnergy: 0,
            flowX: 0,
            flowY: 0,
            flowScale: 0
          };
          this.gradientChangeThreshold = 0.01;
          // Minimum change for update
          // Event debouncing
          this.musicEventDebounceTimers = {
            musicState: 0,
            harmonizedColors: 0,
            webglState: 0,
            consciousnessIntensity: 0
          };
          this.eventDebounceMs = 100;
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            this.setupConsciousnessListeners();
            this.setupWebGLIntegrationListeners();
            this.initializeBaseState();
            this.startLivingGradientAnimation();
            this.applyLivingConsciousnessBase();
            Y3K?.debug?.log("LivingGradientBaseSystem", "Living gradient base system awakened");
          } catch (error) {
            Y3K?.debug?.error("LivingGradientBaseSystem", "Failed to initialize living base system:", error);
          }
        }
        /**
         * Setup listeners for consciousness and dynamic color changes
         * Phase 2: Migrated from DOM events to UnifiedEventBus for proper facade coordination
         */
        setupConsciousnessListeners() {
          if (typeof unifiedEventBus !== "undefined") {
            unifiedEventBus.subscribe("colors:harmonized", (data) => {
              if (data && data.processedColors) {
                this.handleHarmonizedColorUpdate(data.processedColors);
              }
            }, "LivingGradientBaseSystem");
          }
          document.addEventListener("music-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.handleMusicStateChange(customEvent.detail);
            }
          });
          document.addEventListener("consciousness-intensity-change", (event) => {
            const customEvent = event;
            if (customEvent.detail && typeof customEvent.detail.intensity === "number") {
              this.updateConsciousnessIntensity(customEvent.detail.intensity);
            }
          });
          Y3K?.debug?.log("LivingGradientBaseSystem", "Consciousness listeners established");
        }
        /**
         * Setup WebGL integration listeners
         */
        setupWebGLIntegrationListeners() {
          document.addEventListener("webgl-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.handleWebGLStateChange(customEvent.detail);
            }
          });
          document.addEventListener("webgl-gradient-update", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.coordinateWithWebGLGradient(customEvent.detail);
            }
          });
          Y3K?.debug?.log("LivingGradientBaseSystem", "WebGL integration listeners established");
        }
        /**
         * Initialize current base state from CSS variables
         */
        initializeBaseState() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentBase = computedStyle.getPropertyValue("--spice-base").trim() || "#1e1e2e";
          this.livingBaseState.currentBaseHex = currentBase;
          const baseRgb = this.utils.hexToRgb(currentBase);
          if (baseRgb) {
            this.livingBaseState.currentBaseRgb = `${baseRgb.r},${baseRgb.g},${baseRgb.b}`;
          }
          const currentAccent = computedStyle.getPropertyValue("--sn-dynamic-accent").trim() || computedStyle.getPropertyValue("--spice-accent").trim() || "#cba6f7";
          this.livingBaseState.currentPrimaryHex = currentAccent;
          const accentRgb = this.utils.hexToRgb(currentAccent);
          if (accentRgb) {
            this.livingBaseState.currentPrimaryRgb = `${accentRgb.r},${accentRgb.g},${accentRgb.b}`;
          }
          this.livingBaseState.lastUpdateTime = Date.now();
          Y3K?.debug?.log("LivingGradientBaseSystem", "Base state initialized:", {
            base: this.livingBaseState.currentBaseHex,
            primary: this.livingBaseState.currentPrimaryHex
          });
        }
        /**
         * Handle harmonized color updates from Dynamic Catppuccin Bridge
         */
        handleHarmonizedColorUpdate(harmonizedColors) {
          this.debouncedEventHandler("harmonizedColors", () => {
            const primaryColor = harmonizedColors.VIBRANT || harmonizedColors.PRIMARY || harmonizedColors.PROMINENT;
            if (primaryColor && primaryColor !== this.livingBaseState.currentPrimaryHex) {
              this.livingBaseState.currentPrimaryHex = primaryColor;
              const primaryRgb = this.utils.hexToRgb(primaryColor);
              if (primaryRgb) {
                this.livingBaseState.currentPrimaryRgb = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
              }
              this.updateLivingConsciousnessBase();
              Y3K?.debug?.log("LivingGradientBaseSystem", "Living base updated with harmonized colors:", primaryColor);
            }
          });
        }
        /**
         * Handle music state changes for energy-responsive base
         */
        handleMusicStateChange(musicState) {
          this.debouncedEventHandler("musicState", () => {
            if (musicState.energy !== void 0) {
              this.livingBaseState.musicEnergy = musicState.energy;
              const baseIntensity = 0.5;
              const energyBoost = musicState.energy * this.gradientConfig.musicResponsiveness;
              this.livingBaseState.consciousnessIntensity = Math.max(0.1, Math.min(1, baseIntensity + energyBoost * 0.3));
              this.updateMusicResponsiveVariables();
            }
          });
        }
        /**
         * Handle WebGL system state changes
         */
        handleWebGLStateChange(webglState) {
          this.debouncedEventHandler("webglState", () => {
            if (webglState.enabled !== void 0) {
              this.livingBaseState.webglIntegrationActive = webglState.enabled;
              this.coordinateWithWebGLSystem(webglState.enabled);
              Y3K?.debug?.log("LivingGradientBaseSystem", `WebGL integration ${webglState.enabled ? "activated" : "deactivated"}`);
            }
          });
        }
        /**
         * Update consciousness intensity
         */
        updateConsciousnessIntensity(intensity) {
          this.debouncedEventHandler("consciousnessIntensity", () => {
            this.livingBaseState.consciousnessIntensity = Math.max(0, Math.min(1, intensity));
            this.updateConsciousnessVariables();
          });
        }
        /**
         * Start living gradient animation system
         */
        startLivingGradientAnimation() {
          if (!this.gradientConfig.breathingAnimationEnabled) return;
          this.breathingStartTime = Date.now();
          const animate = /* @__PURE__ */ __name(() => {
            if (!this.isActive) return;
            const currentTime = performance.now();
            if (currentTime - this.lastFrameTime < this.frameThrottleMs) {
              this.animationFrameId = requestAnimationFrame(animate);
              return;
            }
            const elapsed = currentTime - this.breathingStartTime;
            const breathingCycle = 4e3;
            const phase = elapsed % breathingCycle / breathingCycle;
            const newBreathingPhase = Math.sin(phase * 2 * Math.PI);
            const baseIntensity = this.gradientConfig.consciousnessLayerOpacity;
            const breathingMultiplier = 1 + newBreathingPhase * 0.1;
            const musicMultiplier = 1 + this.livingBaseState.musicEnergy * 0.2;
            const finalIntensity = baseIntensity * breathingMultiplier * musicMultiplier;
            const flowX = Math.sin(currentTime * 5e-4) * 2;
            const flowY = Math.cos(currentTime * 3e-4) * 1.5;
            const flowScale = 1 + newBreathingPhase * 0.05;
            const currentValues = {
              breathingPhase: newBreathingPhase,
              consciousnessIntensity: finalIntensity,
              musicEnergy: this.livingBaseState.musicEnergy,
              flowX,
              flowY,
              flowScale
            };
            if (this.hasGradientChanged(currentValues)) {
              this.livingBaseState.breathingPhase = newBreathingPhase;
              this.updateLivingGradientFrame();
              this.updatePreviousGradientValues(currentValues);
            }
            this.lastFrameTime = currentTime;
            this.animationFrameId = requestAnimationFrame(animate);
          }, "animate");
          this.animationFrameId = requestAnimationFrame(animate);
          Y3K?.debug?.log("LivingGradientBaseSystem", "Living gradient animation started");
        }
        /**
         * Check if gradient values have changed significantly
         */
        hasGradientChanged(currentValues) {
          for (const [key, value] of Object.entries(currentValues)) {
            const previous = this.previousGradientValues[key];
            if (Math.abs(value - previous) >= this.gradientChangeThreshold) {
              return true;
            }
          }
          return false;
        }
        /**
         * Update previous gradient values for change detection
         */
        updatePreviousGradientValues(currentValues) {
          Object.assign(this.previousGradientValues, currentValues);
        }
        /**
         * Update living gradient for each animation frame
         */
        updateLivingGradientFrame() {
          const root = document.documentElement;
          const baseIntensity = this.gradientConfig.consciousnessLayerOpacity;
          const breathingMultiplier = 1 + this.livingBaseState.breathingPhase * 0.1;
          const musicMultiplier = 1 + this.livingBaseState.musicEnergy * 0.2;
          const finalIntensity = baseIntensity * breathingMultiplier * musicMultiplier;
          const cssUpdates = [
            ["--consciousness-breathing-intensity", finalIntensity.toString()],
            ["--consciousness-breathing-phase", this.livingBaseState.breathingPhase.toString()]
          ];
          if (this.gradientConfig.webglIntegrationEnabled) {
            const flowX = Math.sin(Date.now() * 5e-4) * 2;
            const flowY = Math.cos(Date.now() * 3e-4) * 1.5;
            const flowScale = 1 + this.livingBaseState.breathingPhase * 0.05;
            cssUpdates.push(
              ["--consciousness-flow-x", `${flowX}%`],
              ["--consciousness-flow-y", `${flowY}%`],
              ["--consciousness-flow-scale", flowScale.toString()]
            );
          }
          this.batchApplyCSSUpdates(root, cssUpdates);
        }
        /**
         * Apply CSS updates in batch to minimize DOM layout thrashing
         */
        batchApplyCSSUpdates(element, updates) {
          for (const [property, value] of updates) {
            element.style.setProperty(property, value);
          }
        }
        /**
         * Debounced event handler to prevent excessive processing of high-frequency events
         */
        debouncedEventHandler(eventType, handler) {
          const now = performance.now();
          if (now - this.musicEventDebounceTimers[eventType] >= this.eventDebounceMs) {
            handler();
            this.musicEventDebounceTimers[eventType] = now;
          }
        }
        /**
         * Apply living consciousness base to the system
         */
        applyLivingConsciousnessBase() {
          const root = document.documentElement;
          const livingBaseGradient = this.createLivingBaseGradient();
          const cssUpdates = [
            ["--living-base-gradient", livingBaseGradient],
            ["--consciousness-base-primary-rgb", this.livingBaseState.currentPrimaryRgb],
            ["--consciousness-base-rgb", this.livingBaseState.currentBaseRgb]
          ];
          this.batchApplyCSSUpdates(root, cssUpdates);
          Y3K?.debug?.log("LivingGradientBaseSystem", "Living consciousness base applied");
        }
        /**
         * Update living consciousness base when colors change
         */
        updateLivingConsciousnessBase() {
          this.applyLivingConsciousnessBase();
          const updateEvent = new CustomEvent("living-base-update", {
            detail: {
              baseHex: this.livingBaseState.currentBaseHex,
              primaryHex: this.livingBaseState.currentPrimaryHex,
              consciousnessIntensity: this.livingBaseState.consciousnessIntensity,
              timestamp: Date.now()
            }
          });
          document.dispatchEvent(updateEvent);
        }
        /**
         * Create living base gradient that transforms static #1e1e2e
         */
        createLivingBaseGradient() {
          const primaryRgb = this.livingBaseState.currentPrimaryRgb;
          const baseRgb = this.livingBaseState.currentBaseRgb;
          const intensity = this.livingBaseState.consciousnessIntensity;
          return `
      radial-gradient(
        ellipse at 50% 50%,
        rgba(${primaryRgb}, ${0.12 * intensity}) 0%,
        rgba(${primaryRgb}, ${0.08 * intensity}) 25%,
        rgba(${baseRgb}, 0.95) 50%,
        var(--spice-base) 100%
      ),
      linear-gradient(
        135deg,
        rgba(${primaryRgb}, ${0.06 * intensity}) 0%,
        transparent 30%,
        rgba(${primaryRgb}, ${0.04 * intensity}) 70%,
        transparent 100%
      ),
      var(--spice-base)
    `;
        }
        /**
         * Update music-responsive variables
         */
        updateMusicResponsiveVariables() {
          const root = document.documentElement;
          const baseCycle = 4e3;
          const energyMultiplier = 0.5 + this.livingBaseState.musicEnergy * 1.5;
          const musicCycle = baseCycle / energyMultiplier;
          const cssUpdates = [
            ["--consciousness-music-energy", this.livingBaseState.musicEnergy.toString()],
            ["--consciousness-music-intensity", this.livingBaseState.consciousnessIntensity.toString()],
            ["--consciousness-breathing-duration", `${musicCycle}ms`]
          ];
          this.batchApplyCSSUpdates(root, cssUpdates);
        }
        /**
         * Update consciousness variables
         */
        updateConsciousnessVariables() {
          const root = document.documentElement;
          const cssUpdates = [
            ["--consciousness-intensity-global", this.livingBaseState.consciousnessIntensity.toString()],
            ["--consciousness-layer-opacity", (this.gradientConfig.consciousnessLayerOpacity * this.livingBaseState.consciousnessIntensity).toString()]
          ];
          this.batchApplyCSSUpdates(root, cssUpdates);
        }
        /**
         * Coordinate with WebGL gradient system
         */
        coordinateWithWebGLSystem(webglEnabled) {
          const root = document.documentElement;
          const cssUpdates = webglEnabled ? [
            // Reduce CSS layer opacity to allow WebGL to dominate
            ["--consciousness-webgl-coordination", "0.7"],
            ["--consciousness-css-fallback", "0.3"]
          ] : [
            // Full CSS consciousness when WebGL is disabled
            ["--consciousness-webgl-coordination", "0"],
            ["--consciousness-css-fallback", "1.0"]
          ];
          this.batchApplyCSSUpdates(root, cssUpdates);
          Y3K?.debug?.log("LivingGradientBaseSystem", `WebGL coordination ${webglEnabled ? "enabled" : "disabled"}`);
        }
        /**
         * Coordinate with WebGL gradient updates
         */
        coordinateWithWebGLGradient(webglData) {
          if (!this.gradientConfig.webglIntegrationEnabled) return;
          if (webglData.flowState) {
            this.updateFlowStateFromWebGL(webglData.flowState);
          }
          if (webglData.colorState) {
            this.updateColorStateFromWebGL(webglData.colorState);
          }
        }
        /**
         * Update flow state from WebGL system
         */
        updateFlowStateFromWebGL(flowState) {
          const root = document.documentElement;
          const cssUpdates = [];
          if (flowState.flowX !== void 0) {
            cssUpdates.push(["--consciousness-webgl-flow-x", `${flowState.flowX}%`]);
          }
          if (flowState.flowY !== void 0) {
            cssUpdates.push(["--consciousness-webgl-flow-y", `${flowState.flowY}%`]);
          }
          if (flowState.flowScale !== void 0) {
            cssUpdates.push(["--consciousness-webgl-scale", flowState.flowScale.toString()]);
          }
          if (cssUpdates.length > 0) {
            this.batchApplyCSSUpdates(root, cssUpdates);
          }
        }
        /**
         * Update color state from WebGL system
         */
        updateColorStateFromWebGL(colorState) {
          if (colorState.primaryColor) {
            this.livingBaseState.currentPrimaryRgb = colorState.primaryColor;
            this.updateLivingConsciousnessBase();
          }
        }
        /**
         * Get current living base state for debugging
         */
        getLivingBaseState() {
          return { ...this.livingBaseState };
        }
        /**
         * Update gradient configuration
         */
        updateGradientConfig(newConfig) {
          this.gradientConfig = { ...this.gradientConfig, ...newConfig };
          if (newConfig.breathingAnimationEnabled !== void 0) {
            if (newConfig.breathingAnimationEnabled && this.animationFrameId === 0) {
              this.startLivingGradientAnimation();
            } else if (!newConfig.breathingAnimationEnabled && this.animationFrameId !== 0) {
              cancelAnimationFrame(this.animationFrameId);
              this.animationFrameId = 0;
            }
          }
          Y3K?.debug?.log("LivingGradientBaseSystem", "Gradient configuration updated:", newConfig);
        }
        async healthCheck() {
          const hasRecentUpdate = Date.now() - this.livingBaseState.lastUpdateTime < 3e4;
          const animationActive = this.animationFrameId !== 0;
          return {
            healthy: this.isActive && this.gradientConfig.baseTransformationEnabled,
            issues: this.isActive && !animationActive ? ["Animation system not running"] : [],
            metrics: {
              baseTransformationEnabled: this.gradientConfig.baseTransformationEnabled,
              webglIntegrationActive: this.livingBaseState.webglIntegrationActive,
              currentBase: this.livingBaseState.currentBaseHex,
              currentPrimary: this.livingBaseState.currentPrimaryHex,
              consciousnessIntensity: this.livingBaseState.consciousnessIntensity,
              breathingPhase: this.livingBaseState.breathingPhase,
              musicEnergy: this.livingBaseState.musicEnergy,
              hasRecentUpdate,
              animationActive
            }
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = 0;
          }
          Y3K?.debug?.log("LivingGradientBaseSystem", "Living gradient base system cleaned up");
        }
      };
      __name(_LivingGradientBaseSystem, "LivingGradientBaseSystem");
      LivingGradientBaseSystem = _LivingGradientBaseSystem;
    }
  });

  // src-js/core/performance/CDFVariableBridge.ts
  var CDFVariableBridge_exports = {};
  __export(CDFVariableBridge_exports, {
    CDFVariableBridge: () => CDFVariableBridge
  });
  var _CDFVariableBridge, CDFVariableBridge;
  var init_CDFVariableBridge = __esm({
    "src-js/core/performance/CDFVariableBridge.ts"() {
      "use strict";
      init_EventBus();
      _CDFVariableBridge = class _CDFVariableBridge {
        constructor(batcher) {
          this.batcher = batcher;
          this.reduceMotionMQ = null;
          this._mqHandler = null;
          this.unsubscribe = GlobalEventBus.subscribe(
            "cdf:frameContext",
            (ctx) => this._handleFrame(ctx)
          );
          if (typeof window !== "undefined" && window.matchMedia) {
            this.reduceMotionMQ = window.matchMedia(
              "(prefers-reduced-motion: reduce)"
            );
            this._syncReducedMotion(this.reduceMotionMQ.matches);
            this._mqHandler = (e) => {
              this._syncReducedMotion(e.matches);
            };
            try {
              this.reduceMotionMQ.addEventListener("change", this._mqHandler);
            } catch {
              this.reduceMotionMQ.addListener(this._mqHandler);
            }
          }
        }
        destroy() {
          this.unsubscribe?.();
          if (this.reduceMotionMQ && this._mqHandler) {
            try {
              this.reduceMotionMQ.removeEventListener("change", this._mqHandler);
            } catch {
              this.reduceMotionMQ.removeListener(this._mqHandler);
            }
          }
        }
        // -------------------------------------------------------------------------
        // Internal helpers
        // -------------------------------------------------------------------------
        _handleFrame(ctx) {
          if (typeof ctx.scrollRatio === "number") {
            this.batcher.queueCSSVariableUpdate(
              "--sn-cdf-scroll-ratio",
              ctx.scrollRatio.toFixed(3)
            );
            this.batcher.queueCSSVariableUpdate(
              "--sn-scroll-ratio",
              ctx.scrollRatio.toFixed(3)
            );
          }
          if (typeof ctx.beatIntensity === "number") {
            const val = ctx.beatIntensity.toFixed(3);
            this.batcher.queueCSSVariableUpdate("--sn-cdf-energy", val);
            this.batcher.queueCSSVariableUpdate("--sn-nebula-beat-intensity", val);
          }
        }
        _syncReducedMotion(reduce) {
          this.batcher.queueCSSVariableUpdate("--sn-cdf-enabled", reduce ? "0" : "1");
        }
      };
      __name(_CDFVariableBridge, "CDFVariableBridge");
      CDFVariableBridge = _CDFVariableBridge;
    }
  });

  // src-js/theme.entry.ts
  init_globalConfig();
  init_year3000System();
  init_UnifiedDebugManager();

  // src-js/visual/ui-effects/Aberration/AberrationCanvas.ts
  var _AberrationCanvas = class _AberrationCanvas {
    constructor(parent, y3k = null) {
      this.parent = parent;
      this.y3k = y3k;
      this.gl = null;
      this.program = null;
      this.tex = null;
      this.strength = 0.4;
      // default; overridden via CSS var
      this.rafId = null;
      this.frameStart = 0;
      this._defaultSize = 256;
      // Bound handlers so we can remove them in destroy()
      this._boundContextLost = /* @__PURE__ */ __name((e) => this._handleContextLost(e), "_boundContextLost");
      this._boundContextRestored = /* @__PURE__ */ __name(() => this._handleContextRestored(), "_boundContextRestored");
      this.canvas = document.createElement("canvas");
      this.canvas.width = this._defaultSize;
      this.canvas.height = this._defaultSize;
      this.canvas.style.width = "100%";
      this.canvas.style.height = "100%";
      Object.assign(this.canvas.style, {
        position: "absolute",
        inset: "0",
        pointerEvents: "none",
        mixBlendMode: "overlay",
        // Changed from "screen" to prevent white bleeding
        zIndex: "-1",
        opacity: "0.6"
        // Reduced opacity to prevent harsh effects
      });
      this.parent.appendChild(this.canvas);
      this.perf = y3k?.performanceAnalyzer ?? null;
      this.canvas.addEventListener(
        "webglcontextlost",
        this._boundContextLost,
        false
      );
      this.canvas.addEventListener(
        "webglcontextrestored",
        this._boundContextRestored,
        false
      );
      this._initGL();
    }
    _initGL() {
      const gl = this.canvas.getContext("webgl", {
        premultipliedAlpha: false,
        alpha: true,
        antialias: false
      });
      if (!gl) {
        console.warn("[AberrationCanvas] WebGL not available \u2013 effect disabled");
        return;
      }
      this.gl = gl;
      const vsSource = `attribute vec2 aPos; varying vec2 vUv; void main(){ vUv = (aPos+1.0)*0.5; gl_Position = vec4(aPos,0.0,1.0); }`;
      const fsSource = `precision mediump float; uniform sampler2D uTex; uniform float uStrength; uniform float uTime; varying vec2 vUv; void main(){ float freq = 8.0; vec2 offset = vec2(sin(vUv.y*freq+uTime)*uStrength, 0.0); vec4 c; c.r = texture2D(uTex, vUv + offset).r; c.g = texture2D(uTex, vUv).g; c.b = texture2D(uTex, vUv - offset).b; c.a = clamp(uStrength * 1.5, 0.0, 0.6); gl_FragColor = c; }`;
      const compile = /* @__PURE__ */ __name((type, src) => {
        const sh = gl.createShader(type);
        gl.shaderSource(sh, src);
        gl.compileShader(sh);
        return sh;
      }, "compile");
      const vs = compile(gl.VERTEX_SHADER, vsSource);
      const fs = compile(gl.FRAGMENT_SHADER, fsSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error("[AberrationCanvas] Shader link failed");
        return;
      }
      this.program = prog;
      gl.useProgram(prog);
      const verts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
      const loc = gl.getAttribLocation(prog, "aPos");
      gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        1,
        1,
        0,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        new Uint8Array([0, 0, 0, 0])
        // Changed from white [255,255,255,255] to transparent [0,0,0,0]
      );
      this.tex = tex;
    }
    /** Public API: update strength via CSS variable (0–1) */
    setStrength(value) {
      this.strength = value;
    }
    /** Uploads a bitmap (e.g., gradient snapshot) into the shader texture. */
    updateSourceBitmap(bmp) {
      if (!this.gl || !this.tex) return;
      const gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, this.tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bmp);
    }
    /**
     * Public render hook – called by AberrationVisualSystem.onAnimate().
     * All original rendering logic from the private _render loop lives here so
     * that the effect can be orchestrated by MasterAnimationCoordinator.
     */
    render(time) {
      if (!this.gl || !this.program) return;
      const gl = this.gl;
      if (this.perf) this.frameStart = performance.now();
      gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.useProgram(this.program);
      const uTexLoc = gl.getUniformLocation(this.program, "uTex");
      const uStrLoc = gl.getUniformLocation(this.program, "uStrength");
      const uTimeLoc = gl.getUniformLocation(this.program, "uTime");
      gl.uniform1i(uTexLoc, 0);
      gl.uniform1f(uStrLoc, this.strength);
      gl.uniform1f(uTimeLoc, time * 1e-3);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      if (this.perf) {
        const dur = performance.now() - this.frameStart;
        this.perf.shouldUpdate("aberration", 500) && this.perf.endTiming("AberrationCanvas", this.frameStart);
        if (dur > 0.5) {
          console.warn(
            `[AberrationCanvas] Frame ${dur.toFixed(2)} ms exceeds 0.5 ms budget`
          );
        }
      }
    }
    destroy() {
      if (this.rafId) cancelAnimationFrame(this.rafId);
      if (this.gl) {
        const lose = this.gl.getExtension("WEBGL_lose_context");
        lose?.loseContext();
      }
      this.canvas.removeEventListener("webglcontextlost", this._boundContextLost);
      this.canvas.removeEventListener(
        "webglcontextrestored",
        this._boundContextRestored
      );
      this.canvas.remove();
    }
    /**
     * Dynamically adjusts the off-screen buffer resolution. Caller should use
     * powers of two (64–256) to keep GPU happy. Safe to call every time
     * performance mode toggles – texture & buffers are reused.
     */
    setPixelSize(size) {
      if (size === this.canvas.width) return;
      this.canvas.width = size;
      this.canvas.height = size;
    }
    // ────────────────────────────────────────────────────────────────
    // Context-loss life-cycle helpers (Phase-5)
    // ────────────────────────────────────────────────────────────────
    _handleContextLost(e) {
      e.preventDefault();
      console.warn("[AberrationCanvas] WebGL context lost \u2013 waiting for restore");
      this.gl = null;
      this.program = null;
    }
    _handleContextRestored() {
      console.info(
        "[AberrationCanvas] WebGL context restored \u2013 re-initializing GL"
      );
      this._initGL();
    }
  };
  __name(_AberrationCanvas, "AberrationCanvas");
  var AberrationCanvas = _AberrationCanvas;

  // src-js/visual/ui-effects/Aberration/AberrationVisualSystem.ts
  var _AberrationVisualSystem = class _AberrationVisualSystem {
    constructor(canvas, perf) {
      this.systemName = "AberrationCanvas";
      this._elapsed = 0;
      this._canvas = canvas;
      this._perf = perf;
    }
    /* --------------------------------------------------------------- */
    /* MasterAnimationCoordinator hooks                                */
    /* --------------------------------------------------------------- */
    /**
     * Called by the coordinator every frame (subject to frame budgeting).
     * @param deltaMs Time in milliseconds since last call.
     * @param _context Shared FrameContext from VisualSystemRegistry (unused for now).
     */
    onAnimate(deltaMs, _context) {
      this._elapsed += deltaMs;
      let start = 0;
      if (this._perf) start = this._perf.startTiming("AberrationVisualSystem");
      this._canvas.render(this._elapsed);
      if (this._perf && start) {
        this._perf.endTiming("AberrationVisualSystem", start);
      }
    }
    /**
     * Optional hook – will be invoked when MAC toggles performance modes.
     * We keep it for future Phase-2 improvements (dynamic resolution scaling).
     */
    onPerformanceModeChange(mode) {
      if (mode === "performance") {
        this._canvas.setPixelSize(128);
        this._canvas.setStrength(0.25);
      } else {
        this._canvas.setPixelSize(256);
        this._canvas.setStrength(0.4);
      }
    }
    /* --------------------------------------------------------------- */
    /* Lifecycle helpers                                               */
    /* --------------------------------------------------------------- */
    destroy() {
      this._canvas.destroy();
    }
  };
  __name(_AberrationVisualSystem, "AberrationVisualSystem");
  var AberrationVisualSystem = _AberrationVisualSystem;

  // src-js/utils/dom/getScrollNode.ts
  var SCROLL_NODE_SELECTORS = [
    ".main-view-container__scroll-node",
    // 2023-era builds
    ".main-viewContainer-scrollNode",
    // 2024 dash variant
    ".main-viewContainer__scrollNode"
    // 2024 double-underscore variant
  ].join(", ");
  function getScrollNode() {
    return document.querySelector(SCROLL_NODE_SELECTORS);
  }
  __name(getScrollNode, "getScrollNode");

  // src-js/visual/ui-effects/Aberration/AberrationManager.ts
  var instance = null;
  var visualSystem = null;
  function isAberrationEnabled() {
    try {
      const val = window.Spicetify?.LocalStorage?.get?.(
        "sn-enable-aberration"
      );
      return val !== "false";
    } catch {
      return true;
    }
  }
  __name(isAberrationEnabled, "isAberrationEnabled");
  function attach(y3k) {
    if (!isAberrationEnabled()) {
      setNebulaNoiseEnabled(false, y3k);
      setCSSAberrationEnabled(false, y3k);
      return;
    }
    const node = getScrollNode();
    if (!node) return;
    if (instance && instance.parent === node) return;
    instance?.destroy();
    instance = new AberrationCanvas(node, y3k);
    if (window.__SN_DEBUG_ABERRATION) {
      console.log("[AberrationManager] canvas attached", node);
    }
    setNebulaNoiseEnabled(true, y3k);
    setCSSAberrationEnabled(true, y3k);
    if (y3k && instance) {
      visualSystem = new AberrationVisualSystem(
        instance,
        y3k.performanceAnalyzer || void 0
      );
      y3k?.registerVisualSystem?.(visualSystem, "critical");
      y3k.performanceAnalyzer?.emitTrace("AberrationCanvasAttached");
    }
  }
  __name(attach, "attach");
  function setNebulaNoiseEnabled(enabled, y3k) {
    if (y3k) {
      y3k.queueCSSVariableUpdate(
        "--sn-nebula-noise-opacity",
        enabled ? "0.03" : "0"
      );
    } else {
      document.documentElement.style.setProperty(
        "--sn-nebula-noise-opacity",
        enabled ? "0.03" : "0"
      );
    }
  }
  __name(setNebulaNoiseEnabled, "setNebulaNoiseEnabled");
  function setCSSAberrationEnabled(enabled, y3k) {
    const variables = {
      "--aberration-webgl-active": enabled ? "1" : "0",
      "--aberration-css-enabled": enabled ? "1" : "0",
      "--aberration-hybrid-mode": enabled ? "1" : "0"
    };
    if (y3k) {
      Object.entries(variables).forEach(([key, value]) => {
        y3k.queueCSSVariableUpdate(key, value);
      });
    } else {
      Object.entries(variables).forEach(([key, value]) => {
        document.documentElement.style.setProperty(key, value);
      });
    }
  }
  __name(setCSSAberrationEnabled, "setCSSAberrationEnabled");
  function initializeAberrationManager(y3k = null) {
    attach(y3k);
    if (!instance) {
      setNebulaNoiseEnabled(false, y3k);
      setCSSAberrationEnabled(false, y3k);
    }
    const history = window.Spicetify?.Platform?.History;
    if (history?.listen) {
      history.listen(() => setTimeout(() => attach(y3k), 0));
    }
    document.addEventListener("spicetify:appchange", () => attach(y3k));
    const observer = new MutationObserver(() => {
      if (!instance) {
        attach(y3k);
        if (!instance) {
          setNebulaNoiseEnabled(false, y3k);
          setCSSAberrationEnabled(false, y3k);
        }
      } else {
        observer.disconnect();
      }
    });
    observer.observe(document.documentElement, {
      childList: true,
      subtree: true
    });
    document.addEventListener("year3000SystemSettingsChanged", (e) => {
      const { key, value } = e.detail || {};
      if (key === "sn-enable-aberration") {
        const enable = value === "true";
        if (enable && !instance) {
          attach(y3k);
        } else if (!enable && instance) {
          instance.destroy();
          instance = null;
          y3k?.unregisterAnimationSystem("AberrationCanvas");
          visualSystem?.destroy();
          visualSystem = null;
          y3k?.performanceAnalyzer?.emitTrace("AberrationCanvasDetached");
        }
        setNebulaNoiseEnabled(enable && !!instance, y3k);
        setCSSAberrationEnabled(enable && !!instance, y3k);
      }
      if (key === "sn-nebula-aberration-strength") {
        const num = parseFloat(value);
        if (!Number.isNaN(num) && instance) {
          instance.setStrength(num);
        }
        y3k?.queueCSSVariableUpdate(
          "--sn-nebula-aberration-strength",
          String(value)
        );
      }
    });
  }
  __name(initializeAberrationManager, "initializeAberrationManager");

  // src-js/visual/ui-effects/AudioVisualController.ts
  init_settingKeys();
  init_UnifiedCSSConsciousnessController();
  init_EventBus();

  // src-js/utils/platform/UserHistory.ts
  var LS_KEY = "sn_seen_genres_v1";
  var _UserGenreHistory = class _UserGenreHistory {
    constructor() {
      const raw = typeof localStorage !== "undefined" ? localStorage.getItem(LS_KEY) : null;
      this.seen = new Set(raw ? JSON.parse(raw) : []);
    }
    hasSeen(genre) {
      return this.seen.has(genre.toLowerCase());
    }
    markSeen(genre) {
      const key = genre.toLowerCase();
      if (!this.seen.has(key)) {
        this.seen.add(key);
        this._persist();
      }
    }
    _persist() {
      try {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(LS_KEY, JSON.stringify([...this.seen]));
        }
      } catch (_e) {
      }
    }
  };
  __name(_UserGenreHistory, "UserGenreHistory");
  var UserGenreHistory = _UserGenreHistory;

  // src-js/visual/ui-effects/AudioVisualController.ts
  init_UnifiedDebugManager();
  function median(values) {
    if (!values.length) return 0;
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 !== 0) {
      return sorted[mid] ?? 0;
    }
    const lower = sorted[mid - 1] ?? 0;
    const upper = sorted[mid] ?? 0;
    return (lower + upper) / 2;
  }
  __name(median, "median");
  var _AudioVisualController = class _AudioVisualController {
    constructor(y3k = null, batcher, perf) {
      // TODO: Expand settings integration in Phase 4 (intensity toggle)
      this.batcher = null;
      this.perf = null;
      this.unsubscribers = [];
      this.frameDurations = [];
      // rolling window for medians
      this.enabled = true;
      this.intensitySetting = "balanced";
      this.intensityFactor = 1;
      this.genreHistory = new UserGenreHistory();
      this.activeGlowTimeout = null;
      this.interactionOffHandler = null;
      this.year3000System = y3k;
      if (batcher) {
        this.batcher = batcher;
      } else {
        const sharedBatcher = y3k?.cssConsciousnessController;
        if (sharedBatcher) {
          this.batcher = sharedBatcher;
        } else {
          const fallbackController = UnifiedCSSConsciousnessController.getInstance();
          if (fallbackController) {
            this.batcher = fallbackController;
          } else {
            this.enabled = false;
            this.batcher = null;
            Y3K?.debug?.warn("AudioVisualController", "No UnifiedCSSConsciousnessController available, disabling audio visual effects");
          }
        }
      }
      this.perf = perf ? perf : y3k?.performanceAnalyzer ?? null;
      const prefersReducedMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;
      const capabilityOverall = y3k?.deviceCapabilityDetector?.deviceCapabilities?.overall;
      const settings = y3k?.settingsManager;
      if (settings) {
        this.intensitySetting = settings.get(NEBULA_INTENSITY_KEY) ?? "balanced";
      }
      switch (this.intensitySetting) {
        case "disabled":
          this.enabled = false;
          break;
        case "minimal":
          this.intensityFactor = 0.6;
          break;
        case "balanced":
          this.intensityFactor = 1;
          break;
        case "intense":
          this.intensityFactor = 1.4;
          break;
      }
      if (prefersReducedMotion || capabilityOverall === "low") {
        this.enabled = false;
      }
      if (this.enabled) {
        this._subscribe();
      } else {
        if (typeof document !== "undefined") {
          document.documentElement.style.setProperty(
            "--sn-nebula-beat-intensity",
            "0"
          );
        }
      }
    }
    _subscribe() {
      this.unsubscribers.push(
        GlobalEventBus.subscribe(
          "music:beat",
          (p) => this._handleBeat(p)
        ),
        GlobalEventBus.subscribe(
          "music:genre-change",
          (p) => this._handleGenreChange(p)
        ),
        GlobalEventBus.subscribe(
          "user:scroll",
          (p) => this._handleScroll(p)
        )
      );
    }
    // ---------------------------------------------------------------------------
    // Event Handlers – all lightweight calculations to stay under 2 ms median.
    // ---------------------------------------------------------------------------
    _handleBeat(payload) {
      const t0 = performance.now();
      const safeEnergy = typeof payload.energy === "number" ? payload.energy : 0.5;
      const intensity = (0.8 + Math.min(Math.max(safeEnergy, 0), 1) * 0.6) * this.intensityFactor;
      this._queueVar("--sn-nebula-beat-intensity", intensity.toFixed(3));
      const aberrationStrength = (safeEnergy * 0.6).toFixed(3);
      this._queueVar("--sn-nebula-aberration-strength", aberrationStrength);
      this._recordDuration(t0);
    }
    _handleGenreChange(payload) {
      const t0 = performance.now();
      if (this.genreHistory.hasSeen(payload.genre)) {
        return;
      }
      this.genreHistory.markSeen(payload.genre);
      const cueOpacity = 0.18 * this.intensityFactor;
      this._queueVar("--sn-nebula-layer-0-opacity", cueOpacity.toFixed(3));
      const clearCue = /* @__PURE__ */ __name(() => {
        if (this.year3000System?.timerConsolidationSystem) {
          this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer("AudioVisualController-glowTimeout");
        } else if (this.activeGlowTimeout) {
          clearTimeout(this.activeGlowTimeout);
          this.activeGlowTimeout = null;
        }
        this._queueVar("--sn-nebula-layer-0-opacity", "0.05");
        if (this.interactionOffHandler) {
          document.removeEventListener("pointerdown", this.interactionOffHandler);
          document.removeEventListener("keydown", this.interactionOffHandler);
          this.interactionOffHandler = null;
        }
      }, "clearCue");
      if (this.year3000System?.timerConsolidationSystem) {
        this.year3000System.timerConsolidationSystem.registerConsolidatedTimer(
          "AudioVisualController-glowTimeout",
          clearCue,
          4e3,
          "normal"
        );
        this.activeGlowTimeout = null;
      } else {
        this.activeGlowTimeout = setTimeout(clearCue, 4e3);
      }
      this.interactionOffHandler = () => clearCue();
      document.addEventListener("pointerdown", this.interactionOffHandler, {
        once: true
      });
      document.addEventListener("keydown", this.interactionOffHandler, {
        once: true
      });
      this._queueVar("--sn-nebula-ease-t", "1");
      this._recordDuration(t0);
    }
    _handleScroll(payload) {
      const t0 = performance.now();
      const safeVel = typeof payload.velocity === "number" ? payload.velocity : 0;
      const vel = Math.min(Math.abs(safeVel), 50);
      const blurBoost = vel / 50 * 2 * this.intensityFactor;
      this._queueVar(
        "--sn-nebula-layer-3-blur",
        `calc(var(--sn-depth-layer-3-blur) + ${blurBoost.toFixed(2)}px)`
      );
      const baseScaleY = 150;
      let clampedVel = Math.max(Math.min(payload.velocity ?? 0, 50), -50);
      const deltaScale = clampedVel / 50 * 50;
      const noiseScale = Math.max(140, Math.min(200, baseScaleY + deltaScale));
      this._queueVar("--sn-nebula-noise-scale-y", `${noiseScale.toFixed(1)}%`);
      this._recordDuration(t0);
    }
    // ---------------------------------------------------------------------------
    // Helpers
    // ---------------------------------------------------------------------------
    _queueVar(prop, value) {
      if (!this.enabled) return;
      if (this.year3000System) {
        this.year3000System.queueCSSVariableUpdate(prop, value);
      } else if (this.batcher) {
        this.batcher.queueCSSVariableUpdate(prop, value);
      } else {
        document.documentElement.style.setProperty(prop, value);
      }
    }
    _recordDuration(start) {
      const duration = performance.now() - start;
      this.frameDurations.push(duration);
      if (this.frameDurations.length > _AudioVisualController.FRAME_HISTORY) {
        this.frameDurations.shift();
      }
      if (this.frameDurations.length === _AudioVisualController.FRAME_HISTORY) {
        const med = median(this.frameDurations);
        if (med > 2) {
          console.warn(
            `[AudioVisualController] Median scripting cost ${med.toFixed(
              2
            )} ms exceeds 2 ms budget.`
          );
          this._queueVar("--sn-nebula-blend-mode", "screen");
        }
      }
      this.perf?.shouldUpdate("nebulaCtr", 1e3) && this.perf?.endTiming("AudioVisualController", start);
    }
    destroy() {
      if (this.year3000System?.timerConsolidationSystem) {
        this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer("AudioVisualController-glowTimeout");
      }
      if (this.activeGlowTimeout) {
        clearTimeout(this.activeGlowTimeout);
        this.activeGlowTimeout = null;
      }
      if (this.interactionOffHandler) {
        document.removeEventListener("pointerdown", this.interactionOffHandler);
        document.removeEventListener("keydown", this.interactionOffHandler);
        this.interactionOffHandler = null;
      }
      this.unsubscribers.forEach((u) => u());
      this.unsubscribers = [];
    }
  };
  __name(_AudioVisualController, "AudioVisualController");
  _AudioVisualController.FRAME_HISTORY = 120;
  var AudioVisualController = _AudioVisualController;
  function initializeAudioVisualController(y3k = null) {
    const g2 = globalThis;
    if (g2.__SN_audioVisualController)
      return g2.__SN_audioVisualController;
    const instance2 = new AudioVisualController(y3k);
    g2.__SN_audioVisualController = instance2;
    return instance2;
  }
  __name(initializeAudioVisualController, "initializeAudioVisualController");

  // src-js/utils/platform/spicetifyReady.ts
  async function waitForSpicetifyReady(timeout = 1e4, checkInterval = 100) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      const spicetify = window.Spicetify;
      if (spicetify?.showNotification && spicetify?.Platform) {
        return true;
      }
      await new Promise((res) => setTimeout(res, checkInterval));
    }
    return false;
  }
  __name(waitForSpicetifyReady, "waitForSpicetifyReady");

  // src-js/theme.entry.ts
  init_Year3000Utilities();
  async function waitForAPI(apiPath, timeout = 5e3) {
    const start = Date.now();
    let lastError = null;
    let attemptCount = 0;
    while (Date.now() - start < timeout) {
      attemptCount++;
      try {
        const api = apiPath.split(".").reduce((obj, prop) => obj?.[prop], window);
        if (api) {
          console.log(`\u2705 [StarryNight] API ${apiPath} available after ${attemptCount} attempts (${Date.now() - start}ms)`);
          return api;
        }
      } catch (e) {
        lastError = e;
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    console.warn(`\u274C [StarryNight] API ${apiPath} timeout after ${timeout}ms (${attemptCount} attempts)`);
    if (lastError) {
      console.warn(`\u274C [StarryNight] Last error for ${apiPath}:`, lastError.message);
    }
    const pathParts = apiPath.split(".");
    let currentObj = window;
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      if (!part || !currentObj || typeof currentObj !== "object" || currentObj[part] === void 0) {
        console.warn(`\u274C [StarryNight] API path ${apiPath} breaks at '${part}' (step ${i + 1}/${pathParts.length})`);
        break;
      }
      currentObj = currentObj[part];
    }
    return null;
  }
  __name(waitForAPI, "waitForAPI");
  async function waitForDOMElement(selector, timeout = 5e3) {
    const start = Date.now();
    let attemptCount = 0;
    while (Date.now() - start < timeout) {
      attemptCount++;
      try {
        const element = document.querySelector(selector);
        if (element) {
          console.log(`\u2705 [StarryNight] DOM element '${selector}' found after ${attemptCount} attempts (${Date.now() - start}ms)`);
          return element;
        }
      } catch (e) {
        console.warn(`\u274C [StarryNight] DOM query error for '${selector}':`, e);
      }
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
    console.warn(`\u274C [StarryNight] DOM element '${selector}' not found after ${timeout}ms (${attemptCount} attempts)`);
    return null;
  }
  __name(waitForDOMElement, "waitForDOMElement");
  async function waitForCatppuccinTheme(timeout = 5e3) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      try {
        const rootStyle = getComputedStyle(document.documentElement);
        const baseColor = rootStyle.getPropertyValue("--spice-base").trim();
        const accentColor = rootStyle.getPropertyValue("--spice-accent").trim();
        const textColor = rootStyle.getPropertyValue("--spice-text").trim();
        const isValidColor = /* @__PURE__ */ __name((color2) => {
          const normalized = color2.toLowerCase();
          return color2 && !normalized.includes("#ffffff") && !normalized.includes("#fff") && !normalized.includes("white") && normalized.match(/^#[0-9a-f]{6}$/i);
        }, "isValidColor");
        if (isValidColor(baseColor) && isValidColor(accentColor) && isValidColor(textColor)) {
          console.log(`\u{1F3A8} [StarryNight] Catppuccin theme loaded: base=${baseColor}, accent=${accentColor}, text=${textColor}`);
          return true;
        }
        console.log(`\u{1F3A8} [StarryNight] Waiting for Catppuccin theme... (base=${baseColor}, accent=${accentColor})`);
      } catch (e) {
      }
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
    console.warn(`\u{1F3A8} [StarryNight] Catppuccin theme not fully loaded after ${timeout}ms - proceeding with fallbacks`);
    return false;
  }
  __name(waitForCatppuccinTheme, "waitForCatppuccinTheme");
  function patchReactRequire() {
    const g2 = globalThis;
    if (g2.__STARLIGHT_REACT_SHIM__) return;
    const shim = /* @__PURE__ */ __name((name) => {
      if (name === "react") return g2.Spicetify?.React;
      if (name === "react-dom") return g2.Spicetify?.ReactDOM;
      throw new Error(`[StarryNight shim] Module '${name}' not available`);
    }, "shim");
    if (typeof g2.require === "function") {
      const original = g2.require.bind(g2);
      g2.require = (name) => {
        if (name === "react" || name === "react-dom") return shim(name);
        return original(name);
      };
    } else {
      g2.require = shim;
    }
    g2.__STARLIGHT_REACT_SHIM__ = true;
  }
  __name(patchReactRequire, "patchReactRequire");
  patchReactRequire();
  (/* @__PURE__ */ __name(async function catppuccinStarryNight() {
    const startTime = Date.now();
    console.log("\u{1F31F} [Catppuccin StarryNight] Theme entry point starting...");
    const spicetifyReady = await waitForSpicetifyReady(1e4);
    if (!spicetifyReady) {
      console.error(
        "\u274C [StarryNight] CRITICAL: Spicetify not fully ready after 10s \u2013 proceeding with degraded visual-only mode."
      );
      console.error("\u274C [StarryNight] Available Spicetify objects:", {
        Spicetify: !!window.Spicetify,
        showNotification: !!window.Spicetify?.showNotification,
        Platform: !!window.Spicetify?.Platform
      });
    } else {
      console.log("\u2705 [StarryNight] Spicetify platform fully ready");
    }
    const themeReady = await waitForCatppuccinTheme(8e3);
    if (!themeReady) {
      console.error(
        "\u274C [StarryNight] CRITICAL: Catppuccin theme not fully loaded after 8s \u2013 may experience color issues"
      );
      const rootStyle = getComputedStyle(document.documentElement);
      console.error("\u274C [StarryNight] Current CSS variables:", {
        base: rootStyle.getPropertyValue("--spice-base").trim(),
        accent: rootStyle.getPropertyValue("--spice-accent").trim(),
        text: rootStyle.getPropertyValue("--spice-text").trim()
      });
    } else {
      console.log("\u2705 [StarryNight] Catppuccin theme fully loaded");
    }
    const requiredAPIs = {
      player: await waitForAPI("Spicetify.Player", 3e3),
      platform: await waitForAPI("Spicetify.Platform", 3e3),
      menu: await waitForAPI("Spicetify.Menu", 2e3),
      react: await waitForAPI("Spicetify.React", 2e3),
      reactDOM: await waitForAPI("Spicetify.ReactDOM", 2e3)
    };
    const mainContainerSelectors = [
      ".main-viewContainer-scrollNode",
      ".main-view-container__scroll-node-child",
      ".main-view-container",
      ".main-container",
      "#main",
      "[data-testid='main-container']"
    ];
    let mainContainer = null;
    for (const selector of mainContainerSelectors) {
      mainContainer = await waitForDOMElement(selector, 1e3);
      if (mainContainer) {
        console.log(`\u2705 [StarryNight] Found main container using selector: ${selector}`);
        break;
      }
    }
    if (mainContainer) {
      try {
        Promise.resolve().then(() => (init_prismaticScrollSheen(), prismaticScrollSheen_exports)).then(
          (m) => m.initializePrismaticScrollSheen?.()
        );
        console.log("\u2705 [StarryNight] Enhanced UI features initialized with DOM container");
      } catch (error) {
        console.warn("\u26A0\uFE0F [StarryNight] Failed to initialize enhanced UI features:", error);
      }
    } else {
      console.warn("\u26A0\uFE0F [StarryNight] No suitable main container found - enhanced UI features disabled");
      console.warn("\u26A0\uFE0F [StarryNight] Tried selectors:", mainContainerSelectors.join(", "));
      console.warn("\u26A0\uFE0F [StarryNight] Core functionality (music sync, color extraction) will still work");
    }
    const hasRequiredAPIs = requiredAPIs.player && requiredAPIs.platform;
    const degradedMode = !hasRequiredAPIs;
    if (degradedMode) {
      console.error(
        "\u274C [StarryNight] DEGRADED MODE: Initializing with limited functionality due to missing APIs"
      );
      console.error("\u274C [StarryNight] API availability status:", {
        player: !!requiredAPIs.player,
        platform: !!requiredAPIs.platform,
        menu: !!requiredAPIs.menu,
        react: !!requiredAPIs.react,
        reactDOM: !!requiredAPIs.reactDOM,
        mainContainer: !!mainContainer + " (optional)"
      });
      console.error("\u274C [StarryNight] DEGRADED MODE limitations:");
      console.error("  - Music synchronization disabled");
      console.error("  - Advanced visual effects may not function");
      console.error("  - UI integration features disabled");
      console.error("  - Color extraction from album art disabled");
    } else {
      console.log(
        "\u2705 [StarryNight] FULL MODE: All required APIs available - initializing complete functionality"
      );
    }
    const ENABLE_GLOBAL_DEBUGGING = true;
    if (ENABLE_GLOBAL_DEBUGGING) {
      YEAR3000_CONFIG.enableDebug = true;
      Promise.resolve().then(() => (init_DragCartographer(), DragCartographer_exports)).then((m) => {
        m.enableDragCartography?.();
        window.getDragMap = m.getDragMap;
      });
    }
    const year3000System2 = new Year3000System(YEAR3000_CONFIG);
    initializeAudioVisualController(year3000System2);
    initializeAberrationManager(year3000System2);
    Promise.resolve().then(() => (init_EnhancedDragPreview(), EnhancedDragPreview_exports)).then(
      (m) => m.enableEnhancedDragPreview?.()
    );
    Promise.resolve().then(() => (init_QuickAddRadialMenu(), QuickAddRadialMenu_exports)).then(
      (m) => m.enableQuickAddRadialMenu?.()
    );
    try {
      if (degradedMode) {
        await year3000System2.initializeWithAvailableAPIs({
          player: requiredAPIs.player,
          platform: requiredAPIs.platform,
          config: window.Spicetify?.Config,
          degradedMode: true
        });
        console.log(
          "\u{1F31F} [StarryNight] Initialized in degraded mode - visual systems only"
        );
        setupProgressiveEnhancement(year3000System2, requiredAPIs);
      } else {
        await year3000System2.initializeAllSystems();
        year3000System2.setupMusicAnalysisAndColorExtraction();
        console.log("\u{1F31F} [StarryNight] Full initialization complete");
      }
    } catch (error) {
      console.error("[StarryNight] System initialization failed:", error);
    }
    try {
      if (requiredAPIs.react && requiredAPIs.reactDOM) {
        const settingsUiModule = await Promise.resolve().then(() => (init_StarryNightSettings(), StarryNightSettings_exports));
        await settingsUiModule.initializeStarryNightSettings?.();
        console.log(
          "\u{1F31F} [StarryNight] Spicetify native settings with Year3000System integration initialized"
        );
      } else {
        console.warn(
          "\u{1F31F} [StarryNight] React APIs not available - continuing with CSS-only theme"
        );
      }
    } catch (e) {
      console.error("[StarryNight] Failed to initialize native settings:", e);
      console.warn(
        "\u{1F31F} [StarryNight] Continuing with CSS-only theme (no settings UI)"
      );
    }
    if (YEAR3000_CONFIG.enableDebug) {
      window.Y3K = {
        system: year3000System2,
        // Expose internal modules for easier debugging
        music: year3000System2.musicSyncService,
        settings: year3000System2.settingsManager,
        // Expose the superior, specialized debug tools directly
        debug: Y3K.debug,
        health: year3000System2.systemHealthMonitor,
        // Add degraded mode info
        mode: degradedMode ? "degraded" : "full",
        availableAPIs: requiredAPIs
      };
    }
    try {
      const { RightSidebarConsciousnessSystem: RightSidebarConsciousnessSystem2 } = await Promise.resolve().then(() => (init_RightSidebarConsciousnessSystem(), RightSidebarConsciousnessSystem_exports));
      const { SidebarPerformanceCoordinator: SidebarPerformanceCoordinator2 } = await Promise.resolve().then(() => (init_SidebarPerformanceCoordinator(), SidebarPerformanceCoordinator_exports));
      if (year3000System2.performanceAnalyzer) {
        const coordinator = SidebarPerformanceCoordinator2.getInstance({
          enableDebug: YEAR3000_CONFIG.enableDebug,
          performanceAnalyzer: year3000System2.performanceAnalyzer,
          onFlushComplete: /* @__PURE__ */ __name(() => {
            year3000System2.performanceAnalyzer?.emitTrace?.(
              "[SidebarPerformanceCoordinator] Flush completed"
            );
          }, "onFlushComplete")
        });
        coordinator.setupDOMObservation();
        const rsSystem = new RightSidebarConsciousnessSystem2(
          YEAR3000_CONFIG,
          Year3000Utilities_exports,
          year3000System2.performanceAnalyzer,
          year3000System2.musicSyncService,
          year3000System2.settingsManager,
          year3000System2,
          coordinator
        );
        await rsSystem.initialize();
        year3000System2.rightSidebarConsciousnessSystem = rsSystem;
        year3000System2.rightSidebarCoordinator = coordinator;
      }
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize RightSidebarConsciousnessSystem",
        err
      );
    }
    try {
      const { DepthConsciousnessController: DepthConsciousnessController2 } = await Promise.resolve().then(() => (init_DepthConsciousnessController(), DepthConsciousnessController_exports));
      const depthConsciousness = new DepthConsciousnessController2(
        YEAR3000_CONFIG,
        Year3000Utilities_exports,
        year3000System2.performanceAnalyzer,
        year3000System2.musicSyncService,
        year3000System2.settingsManager
      );
      await depthConsciousness.initialize();
      year3000System2.depthConsciousnessController = depthConsciousness;
      console.log("\u{1F30A} [StarryNight] Depth Consciousness Controller awakened");
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize DepthConsciousnessController",
        err
      );
    }
    try {
      const { DynamicCatppuccinBridge: DynamicCatppuccinBridge2 } = await Promise.resolve().then(() => (init_DynamicCatppuccinBridge(), DynamicCatppuccinBridge_exports));
      const dynamicBridge = new DynamicCatppuccinBridge2(
        YEAR3000_CONFIG,
        Year3000Utilities_exports,
        year3000System2.performanceAnalyzer,
        year3000System2.musicSyncService,
        year3000System2.settingsManager
      );
      await dynamicBridge.initialize();
      if (year3000System2.colorHarmonyEngine) {
        dynamicBridge.linkWithColorHarmonyEngine(year3000System2.colorHarmonyEngine);
      }
      if (year3000System2.depthConsciousnessController) {
        dynamicBridge.linkWithDepthConsciousness(year3000System2.depthConsciousnessController);
      }
      year3000System2.dynamicCatppuccinBridge = dynamicBridge;
      console.log("\u{1F3A8} [StarryNight] Dynamic Catppuccin Bridge connected");
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize DynamicCatppuccinBridge",
        err
      );
    }
    try {
      const { LivingGradientBaseSystem: LivingGradientBaseSystem2 } = await Promise.resolve().then(() => (init_LivingGradientBaseSystem(), LivingGradientBaseSystem_exports));
      const livingBase = new LivingGradientBaseSystem2(
        YEAR3000_CONFIG,
        Year3000Utilities_exports,
        year3000System2.performanceAnalyzer,
        year3000System2.musicSyncService,
        year3000System2.settingsManager
      );
      await livingBase.initialize();
      if (year3000System2.dynamicCatppuccinBridge) {
        console.log("\u{1F30A} [StarryNight] Living Gradient Base linked with Dynamic Catppuccin Bridge");
      }
      if (year3000System2.depthConsciousnessController) {
        console.log("\u{1F30A} [StarryNight] Living Gradient Base linked with Depth Consciousness");
      }
      year3000System2.livingGradientBaseSystem = livingBase;
      console.log("\u{1F30A} [StarryNight] Living Gradient Base System awakened - static #1e1e2e transformed into organic consciousness");
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize LivingGradientBaseSystem",
        err
      );
    }
    try {
      const { CDFVariableBridge: CDFVariableBridge2 } = await Promise.resolve().then(() => (init_CDFVariableBridge(), CDFVariableBridge_exports));
      if (year3000System2.cssConsciousnessController) {
        new CDFVariableBridge2(year3000System2.cssConsciousnessController);
      }
    } catch (err) {
      console.error("[StarryNight] Failed to initialize CDFVariableBridge", err);
    }
    const initTime = Date.now() - startTime;
    console.log(
      `\u{1F30C} Catppuccin StarryNight Theme initialized in ${initTime}ms (${degradedMode ? "degraded" : "full"} mode). Welcome to the future of sound!`
    );
  }, "catppuccinStarryNight"))();
  function setupProgressiveEnhancement(year3000System2, requiredAPIs) {
    console.log("\u{1F504} [StarryNight] Setting up progressive enhancement monitoring...");
    let upgradeAttempts = 0;
    const maxUpgradeAttempts = 30;
    const upgradeCheckInterval = 1e4;
    const checkForUpgrade = /* @__PURE__ */ __name(() => {
      upgradeAttempts++;
      const currentAPIs = {
        player: window.Spicetify?.Player,
        platform: window.Spicetify?.Platform,
        menu: window.Spicetify?.Menu,
        react: window.Spicetify?.React,
        reactDOM: window.Spicetify?.ReactDOM
      };
      const hasRequiredAPIs = currentAPIs.player && currentAPIs.platform;
      if (hasRequiredAPIs) {
        console.log("\u2705 [StarryNight] Required APIs now available - upgrading to full mode!");
        clearInterval(upgradeInterval);
        upgradeToFullMode(year3000System2, currentAPIs).then(() => {
          console.log("\u{1F31F} [StarryNight] Successfully upgraded from degraded mode to full mode!");
          if (window.Y3K) {
            window.Y3K.mode = "full";
            window.Y3K.availableAPIs = currentAPIs;
          }
        }).catch((error) => {
          console.error("\u274C [StarryNight] Failed to upgrade to full mode:", error);
        });
        return;
      }
      if (upgradeAttempts >= maxUpgradeAttempts) {
        console.log(`\u23F0 [StarryNight] Progressive enhancement monitoring ended after ${upgradeAttempts} attempts (${upgradeAttempts * upgradeCheckInterval / 1e3}s)`);
        clearInterval(upgradeInterval);
        return;
      }
      if (upgradeAttempts % 5 === 0) {
        console.log(`\u{1F504} [StarryNight] Still monitoring for API availability... (attempt ${upgradeAttempts}/${maxUpgradeAttempts})`);
        console.log("\u{1F504} [StarryNight] Current API status:", {
          player: !!currentAPIs.player,
          platform: !!currentAPIs.platform,
          menu: !!currentAPIs.menu,
          react: !!currentAPIs.react,
          reactDOM: !!currentAPIs.reactDOM
        });
      }
    }, "checkForUpgrade");
    const upgradeInterval = setInterval(checkForUpgrade, upgradeCheckInterval);
    const spicetifyReadyHandler = /* @__PURE__ */ __name(() => {
      console.log("\u{1F3B5} [StarryNight] Spicetify ready event detected - checking for upgrade...");
      checkForUpgrade();
    }, "spicetifyReadyHandler");
    if (window.Spicetify) {
      if (window.Spicetify.Player) {
        window.Spicetify.Player.addEventListener?.("songchange", spicetifyReadyHandler);
      }
    }
    setTimeout(() => {
      if (window.Spicetify?.Player) {
        window.Spicetify.Player.removeEventListener?.("songchange", spicetifyReadyHandler);
      }
    }, maxUpgradeAttempts * upgradeCheckInterval);
  }
  __name(setupProgressiveEnhancement, "setupProgressiveEnhancement");
  async function upgradeToFullMode(year3000System2, availableAPIs) {
    try {
      console.log("\u{1F680} [StarryNight] Beginning upgrade to full mode...");
      if (!year3000System2) {
        throw new Error("Year3000System instance not available");
      }
      if (typeof year3000System2.upgradeToFullMode === "function") {
        console.log("\u{1F527} [StarryNight] Using system's built-in upgrade method...");
        await year3000System2.upgradeToFullMode({
          player: availableAPIs.player,
          platform: availableAPIs.platform,
          config: window.Spicetify?.Config,
          degradedMode: false
        });
      } else {
        console.log("\u{1F527} [StarryNight] System upgrade method not available - attempting manual initialization...");
        if (year3000System2.setupMusicAnalysisAndColorExtraction) {
          console.log("\u{1F3B5} [StarryNight] Setting up music analysis and color extraction...");
          await year3000System2.setupMusicAnalysisAndColorExtraction();
        }
        if (availableAPIs.react && availableAPIs.reactDOM) {
          try {
            console.log("\u2699\uFE0F [StarryNight] Initializing settings UI...");
            const settingsUiModule = await Promise.resolve().then(() => (init_StarryNightSettings(), StarryNightSettings_exports));
            await settingsUiModule.initializeStarryNightSettings?.();
            console.log("\u2705 [StarryNight] Settings UI initialized successfully");
          } catch (error) {
            console.warn("\u26A0\uFE0F [StarryNight] Failed to initialize settings UI during upgrade:", error);
          }
        }
      }
      if (year3000System2.eventBus?.emitSync) {
        year3000System2.eventBus.emitSync("system:upgraded-to-full-mode", {
          timestamp: Date.now(),
          availableAPIs: {
            player: !!availableAPIs.player,
            platform: !!availableAPIs.platform,
            menu: !!availableAPIs.menu,
            react: !!availableAPIs.react,
            reactDOM: !!availableAPIs.reactDOM
          }
        });
      }
      console.log("\u{1F31F} [StarryNight] Upgrade to full mode completed successfully!");
    } catch (error) {
      console.error("\u274C [StarryNight] Upgrade to full mode failed:", error);
      throw error;
    }
  }
  __name(upgradeToFullMode, "upgradeToFullMode");
})();
//# sourceMappingURL=theme.js.map
