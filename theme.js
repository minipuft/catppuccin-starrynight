"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // src-js/utils/platform/StorageManager.ts
  var LEGACY_KEY_MAPPINGS, VALID_KEY_PREFIXES, _StorageManager, StorageManager;
  var init_StorageManager = __esm({
    "src-js/utils/platform/StorageManager.ts"() {
      "use strict";
      LEGACY_KEY_MAPPINGS = {
        "sn-starDensity": "sn-star-density",
        "year3000-artistic-mode": "sn-artistic-mode",
        "MusicSyncService-prefs": "sn-music-sync-prefs"
      };
      VALID_KEY_PREFIXES = ["sn-", "catppuccin-"];
      _StorageManager = class _StorageManager {
        /**
         * Check if Spicetify.LocalStorage is available
         */
        static isSpicetifyStorageAvailable() {
          if (this._spicetifyAvailable !== null) {
            return this._spicetifyAvailable;
          }
          try {
            this._spicetifyAvailable = typeof Spicetify !== "undefined" && typeof Spicetify.LocalStorage?.get === "function" && typeof Spicetify.LocalStorage?.set === "function";
            if (this._spicetifyAvailable) {
              Spicetify.LocalStorage.get("__test__");
            }
            return this._spicetifyAvailable;
          } catch (error) {
            console.warn(
              "[StorageManager] Spicetify.LocalStorage not available:",
              error
            );
            this._spicetifyAvailable = false;
            return false;
          }
        }
        /**
         * Validate storage key follows theme conventions
         */
        static validateKey(key) {
          if (!key || typeof key !== "string") return false;
          return VALID_KEY_PREFIXES.some((prefix) => key.startsWith(prefix));
        }
        /**
         * Get value from storage with fallback to native localStorage
         */
        static get(key) {
          try {
            if (this.isSpicetifyStorageAvailable()) {
              return Spicetify.LocalStorage.get(key);
            } else {
              console.warn(
                `[StorageManager] Using fallback localStorage for key: ${key}`
              );
              return localStorage.getItem(key);
            }
          } catch (error) {
            console.error(`[StorageManager] Error reading key ${key}:`, error);
            return null;
          }
        }
        /**
         * Set value in storage with fallback to native localStorage
         */
        static set(key, value) {
          try {
            if (this.isSpicetifyStorageAvailable()) {
              Spicetify.LocalStorage.set(key, value);
              return true;
            } else {
              console.warn(
                `[StorageManager] Using fallback localStorage for key: ${key}`
              );
              localStorage.setItem(key, value);
              return true;
            }
          } catch (error) {
            console.error(`[StorageManager] Error setting key ${key}:`, error);
            return false;
          }
        }
        /**
         * Remove value from storage
         */
        static remove(key) {
          try {
            if (this.isSpicetifyStorageAvailable()) {
              Spicetify.LocalStorage.remove?.(key) || Spicetify.LocalStorage.set(key, null);
              return true;
            } else {
              localStorage.removeItem(key);
              return true;
            }
          } catch (error) {
            console.error(`[StorageManager] Error removing key ${key}:`, error);
            return false;
          }
        }
        /**
         * Migrate values from native localStorage to Spicetify.LocalStorage
         */
        static migrateFromNativeLocalStorage(keyMappings) {
          if (!this.isSpicetifyStorageAvailable()) {
            console.warn(
              "[StorageManager] Cannot migrate - Spicetify.LocalStorage unavailable"
            );
            return;
          }
          let migratedCount = 0;
          for (const [oldKey, newKey] of Object.entries(keyMappings)) {
            try {
              const value = localStorage.getItem(oldKey);
              if (value !== null) {
                const existingValue = Spicetify.LocalStorage.get(newKey);
                if (existingValue === null) {
                  Spicetify.LocalStorage.set(newKey, value);
                  migratedCount++;
                  console.log(`[StorageManager] Migrated: ${oldKey} \u2192 ${newKey}`);
                }
              }
            } catch (error) {
              console.error(
                `[StorageManager] Migration failed for ${oldKey}:`,
                error
              );
            }
          }
          if (migratedCount > 0) {
            console.log(
              `[StorageManager] Migration completed: ${migratedCount} keys migrated`
            );
          }
        }
        /**
         * Migrate all known theme settings from localStorage
         */
        static migrateThemeSettings() {
          if (this._migrationCompleted) return;
          console.log("[StorageManager] Starting theme settings migration...");
          this.migrateFromNativeLocalStorage(LEGACY_KEY_MAPPINGS);
          try {
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith("sn-") && !Object.values(LEGACY_KEY_MAPPINGS).includes(key)) {
                const value = localStorage.getItem(key);
                if (value !== null && this.get(key) === null) {
                  this.set(key, value);
                  console.log(`[StorageManager] Auto-migrated legacy key: ${key}`);
                }
              }
            }
          } catch (error) {
            console.error("[StorageManager] Auto-migration error:", error);
          }
          this._migrationCompleted = true;
          console.log("[StorageManager] Theme settings migration completed");
        }
        /**
         * Get all keys with a specific prefix
         */
        static getKeysWithPrefix(prefix) {
          const keys = [];
          if (this.isSpicetifyStorageAvailable()) {
            const commonSuffixes = [
              "star-density",
              "gradient-intensity",
              "glassmorphism-level",
              "3d-effects-level",
              "artistic-mode",
              "current-harmonic-mode",
              "harmonic-intensity",
              "harmonic-evolution",
              "harmonic-manual-base-color"
            ];
            for (const suffix of commonSuffixes) {
              const key = `${prefix}${suffix}`;
              if (this.get(key) !== null) {
                keys.push(key);
              }
            }
          }
          return keys;
        }
        /**
         * Validate storage health and report issues
         */
        static validateStorageHealth() {
          const result = {
            isHealthy: true,
            issues: [],
            recommendations: []
          };
          if (!this.isSpicetifyStorageAvailable()) {
            result.isHealthy = false;
            result.issues.push("Spicetify.LocalStorage not available");
            result.recommendations.push(
              "Ensure theme is running in Spicetify environment"
            );
          }
          try {
            const orphanedKeys = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && (key.startsWith("sn-") || key.startsWith("catppuccin-"))) {
                orphanedKeys.push(key);
              }
            }
            if (orphanedKeys.length > 0) {
              result.issues.push(
                `Found ${orphanedKeys.length} orphaned localStorage keys`
              );
              result.recommendations.push(
                "Run StorageManager.migrateThemeSettings() to migrate them"
              );
            }
          } catch (error) {
            result.issues.push("Cannot access localStorage for health check");
          }
          return result;
        }
        /**
         * Run comprehensive integration tests
         */
        static runIntegrationTests() {
          const results = {
            storageAvailable: false,
            migrationWorking: false,
            settingsResponse: false,
            keyValidation: false,
            errorHandling: false,
            issues: [],
            summary: ""
          };
          console.log("[StorageManager] Running integration tests...");
          try {
            results.storageAvailable = this.isSpicetifyStorageAvailable();
            if (!results.storageAvailable) {
              results.issues.push("Spicetify.LocalStorage not available");
            }
          } catch (error) {
            results.issues.push(`Storage availability test failed: ${error}`);
          }
          try {
            const validKey = this.validateKey("sn-test-key");
            const invalidKey = this.validateKey("invalid-key");
            results.keyValidation = validKey && !invalidKey;
            if (!results.keyValidation) {
              results.issues.push("Key validation not working correctly");
            }
          } catch (error) {
            results.issues.push(`Key validation test failed: ${error}`);
          }
          try {
            const testKey = "sn-integration-test";
            const testValue = "test-value-" + Date.now();
            const setSuccess = this.set(testKey, testValue);
            const getValue = this.get(testKey);
            const removeSuccess = this.remove(testKey);
            results.settingsResponse = setSuccess && getValue === testValue && removeSuccess;
            if (!results.settingsResponse) {
              results.issues.push("Basic set/get/remove operations failed");
            }
          } catch (error) {
            results.issues.push(`Settings response test failed: ${error}`);
          }
          try {
            const legacyKey = "test-legacy-key";
            const newKey = "sn-migrated-key";
            const testValue = "migration-test-" + Date.now();
            localStorage.setItem(legacyKey, testValue);
            this.migrateFromNativeLocalStorage({ [legacyKey]: newKey });
            const migratedValue = this.get(newKey);
            results.migrationWorking = migratedValue === testValue;
            localStorage.removeItem(legacyKey);
            this.remove(newKey);
            if (!results.migrationWorking) {
              results.issues.push("Migration functionality not working");
            }
          } catch (error) {
            results.issues.push(`Migration test failed: ${error}`);
          }
          try {
            const nullResult = this.get("");
            const invalidSetResult = this.set("", "");
            results.errorHandling = nullResult === null && !invalidSetResult;
            if (!results.errorHandling) {
              results.issues.push("Error handling not working correctly");
            }
          } catch (error) {
            results.issues.push(`Error handling test failed: ${error}`);
          }
          const passedTests = [
            results.storageAvailable,
            results.migrationWorking,
            results.settingsResponse,
            results.keyValidation,
            results.errorHandling
          ].filter(Boolean).length;
          results.summary = `${passedTests}/5 tests passed. ${results.issues.length} issues found.`;
          console.log("[StorageManager] Integration test results:", results);
          return results;
        }
        /**
         * Get diagnostic information for debugging
         */
        static getDiagnosticInfo() {
          const legacyKeys = [];
          try {
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && Object.keys(LEGACY_KEY_MAPPINGS).includes(key)) {
                legacyKeys.push(key);
              }
            }
          } catch (error) {
          }
          return {
            spicetifyAvailable: this.isSpicetifyStorageAvailable(),
            migrationCompleted: this._migrationCompleted,
            knownKeys: this.getKeysWithPrefix("sn-"),
            legacyKeysFound: legacyKeys,
            storageHealth: this.validateStorageHealth()
          };
        }
      };
      __name(_StorageManager, "StorageManager");
      _StorageManager._migrationCompleted = false;
      _StorageManager._spicetifyAvailable = null;
      StorageManager = _StorageManager;
      if (typeof Spicetify !== "undefined") {
        setTimeout(() => {
          StorageManager.migrateThemeSettings();
        }, 100);
      }
    }
  });

  // src-js/config/globalConfig.ts
  var HARMONIC_MODES, ARTISTIC_MODE_PROFILES, YEAR3000_CONFIG;
  var init_globalConfig = __esm({
    "src-js/config/globalConfig.ts"() {
      "use strict";
      init_StorageManager();
      HARMONIC_MODES = {
        "analogous-flow": {
          rule: "analogous",
          angle: 30,
          description: "Gentle rivers of adjacent hues"
        },
        "triadic-trinity": {
          rule: "triadic",
          angle: 120,
          description: "Three-point stellar equilibrium"
        },
        "complementary-yin-yang": {
          rule: "complementary",
          angle: 180,
          description: "Opposing forces in harmony"
        },
        "tetradic-cosmic-cross": {
          rule: "tetradic",
          angle: 90,
          description: "Four-dimensional color matrix"
        },
        "split-complementary-aurora": {
          rule: "split-complementary",
          angle: 150,
          description: "Dancing polar opposites"
        },
        "monochromatic-meditation": {
          rule: "monochromatic",
          angle: 0,
          description: "Single-hue consciousness expansion"
        }
      };
      ARTISTIC_MODE_PROFILES = {
        "corporate-safe": {
          displayName: "Corporate Safe",
          description: "Elegant professional choreography with subtle Year 3000 enhancements",
          philosophy: "Refined efficiency that respects workspace harmony while providing gentle predictive assistance",
          multipliers: {
            opacity: 0.15,
            saturation: 1.05,
            brightness: 1.02,
            contrast: 1.01,
            musicEnergyBoost: 0.3,
            // Year 3000 Kinetic Parameters
            kineticIntensity: 0.2,
            temporalPlayFactor: 0.1,
            quantumEmpathyLevel: 0.3,
            aestheticGravityStrength: 0.1,
            emergentChoreography: false,
            visualIntensityBase: 0.8
          },
          features: {
            rippleEffects: false,
            temporalEcho: false,
            particleStreams: false,
            predictiveHighlights: true,
            // Subtle only
            glassEffects: true,
            // Minimal
            dataGlyphs: true,
            // Professional styling
            beatSync: false,
            colorHarmony: false,
            dimensionalEffects: false,
            quantumEmpathy: false,
            // Disabled for professional environments
            aestheticGravity: false
            // Disabled for professional environments
          },
          performance: {
            maxParticles: 0,
            animationThrottle: 32,
            // 30fps for efficiency
            enableGPUAcceleration: false,
            reducedMotion: true
          }
        },
        "artist-vision": {
          displayName: "Artist Vision",
          description: "Balanced creative expression that enhances musical experience without overwhelming",
          philosophy: "Harmonic amplification that honors artistic intent while providing musical visual synchronization",
          multipliers: {
            opacity: 0.25,
            saturation: 1.25,
            brightness: 1.15,
            contrast: 1.2,
            musicEnergyBoost: 1,
            // Year 3000 Kinetic Parameters
            kineticIntensity: 0.7,
            temporalPlayFactor: 0.5,
            quantumEmpathyLevel: 0.6,
            aestheticGravityStrength: 0.4,
            emergentChoreography: true,
            visualIntensityBase: 1
          },
          features: {
            rippleEffects: true,
            // Moderate intensity
            temporalEcho: true,
            // Subtle trails
            particleStreams: true,
            // Music-responsive
            predictiveHighlights: true,
            glassEffects: true,
            dataGlyphs: true,
            beatSync: true,
            // Musical harmony
            colorHarmony: true,
            // Respectful blending
            dimensionalEffects: true,
            // Moderate
            quantumEmpathy: true,
            // Balanced empathy assistance
            aestheticGravity: true
            // Balanced gravitational effects
          },
          performance: {
            maxParticles: 20,
            animationThrottle: 16,
            // 60fps
            enableGPUAcceleration: true,
            reducedMotion: false
          }
        },
        "cosmic-maximum": {
          displayName: "Cosmic Maximum",
          description: "Full Year 3000 emergent systems choreography with kinetic beauty and aesthetic gravity",
          philosophy: "Gravitational optimism through aesthetic attractor fields that create quantum empathy and temporal play",
          multipliers: {
            opacity: 0.45,
            saturation: 1.75,
            brightness: 1.5,
            contrast: 1.6,
            musicEnergyBoost: 2,
            // Year 3000 Kinetic Parameters
            kineticIntensity: 1.8,
            temporalPlayFactor: 2.5,
            quantumEmpathyLevel: 0.85,
            aestheticGravityStrength: 1.6,
            emergentChoreography: true,
            visualIntensityBase: 1.4
          },
          features: {
            rippleEffects: true,
            // Full intensity
            temporalEcho: true,
            // Visible trails
            particleStreams: true,
            // Attention flow
            predictiveHighlights: true,
            // Advanced prediction
            glassEffects: true,
            // Intense
            dataGlyphs: true,
            // Full animation
            beatSync: true,
            // Full synchronization
            colorHarmony: true,
            // Dynamic evolution
            dimensionalEffects: true,
            // Full 3D
            aestheticGravity: true,
            // Visual magnetism
            quantumEmpathy: true
            // Full prediction
          },
          performance: {
            maxParticles: 50,
            animationThrottle: 8,
            // 120fps for smoothness
            enableGPUAcceleration: true,
            reducedMotion: false
          }
        }
      };
      YEAR3000_CONFIG = {
        enableDebug: true,
        enableContextualIntelligence: true,
        performanceProfiles: {
          low: {
            maxParticles: 15,
            animationThrottle: 32,
            // ~30fps
            enableGPUAcceleration: false,
            enableAdvancedShaders: false,
            textureResolution: 0.5
          },
          balanced: {
            maxParticles: 40,
            animationThrottle: 16,
            // ~60fps
            enableGPUAcceleration: true,
            enableAdvancedShaders: false,
            textureResolution: 1
          },
          high: {
            maxParticles: 75,
            animationThrottle: 16,
            // ~60fps
            enableGPUAcceleration: true,
            enableAdvancedShaders: true,
            textureResolution: 1
          },
          ultra: {
            maxParticles: 150,
            animationThrottle: 8,
            // ~120fps
            enableGPUAcceleration: true,
            enableAdvancedShaders: true,
            textureResolution: 2
            // High-res textures
          }
        },
        // Enhanced logging configuration
        logging: {
          level: "info",
          // "off", "error", "warn", "info", "debug", "verbose"
          performance: {
            enableFrameBudgetWarnings: true,
            throttleWarnings: true,
            // Throttle frequent warnings
            throttleInterval: 5e3,
            // ms between repeated warnings
            enableAdaptiveDegradation: true
            // Auto-reduce quality when needed
          }
        },
        healthCheckInterval: 1e4,
        visual: {
          lightweightParticleSystem: { mode: "artist-vision" },
          dimensionalNexusSystem: { mode: "artist-vision" },
          dataGlyphSystem: { mode: "artist-vision" },
          beatSyncVisualSystem: { mode: "artist-vision" },
          behavioralPredictionEngine: { mode: "artist-vision" },
          predictiveMaterializationSystem: { mode: "artist-vision" },
          sidebarConsciousnessSystem: { mode: "artist-vision" }
        },
        enableColorExtraction: true,
        enableMusicAnalysis: true,
        enableCosmicSync: true,
        // NEW: Music-driven visual intensity
        musicModulationIntensity: 0.25,
        // Active artistic mode for UX / visual presets
        artisticMode: "artist-vision",
        // "corporate-safe" | "artist-vision" | "cosmic-maximum"
        // Context-bound method references for external calling
        boundGetCurrentMultipliers: null,
        boundGetCurrentFeatures: null,
        boundGetCurrentPerformanceSettings: null,
        // Pending artistic mode for deferred application
        _pendingArtisticMode: null,
        // Initialize bound methods to preserve context
        init() {
          this.boundGetCurrentMultipliers = this.getCurrentMultipliers.bind(this);
          this.boundGetCurrentFeatures = this.getCurrentFeatures.bind(this);
          this.boundGetCurrentPerformanceSettings = this.getCurrentPerformanceSettings.bind(this);
          if (this._pendingArtisticMode && this.isFullyInitialized()) {
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] Applying pending artistic mode: ${this._pendingArtisticMode}`
              );
            }
            this.setArtisticMode(this._pendingArtisticMode);
            this._pendingArtisticMode = null;
          }
          if (this.enableDebug) {
            console.log(
              "\u{1F527} [YEAR3000_CONFIG] Initialized with context-bound methods"
            );
          }
          return this;
        },
        currentHarmonicMode: "analogous-flow",
        harmonicBaseColor: null,
        harmonicIntensity: 0.7,
        harmonicEvolution: true,
        musicVisualSync: {
          energyScaling: {
            low: 0.6,
            medium: 1,
            high: 1.4
          },
          valenceScaling: {
            sad: 0.8,
            neutral: 1,
            happy: 1.3
          },
          danceabilityEffects: {
            enable: true,
            animationSpeedMultiplier: 1.5,
            blurVariation: 0.3
          },
          // NEW: Enhanced BPM calculation (inspired by Cat Jam extension)
          enhancedBPM: {
            enable: true,
            useSmartCalculation: true,
            // Toggle for enhanced vs basic tempo
            useRealisticData: true,
            // Use actual Spicetify-available data only
            // Tempo-based danceability estimation ranges
            danceabilityEstimation: {
              highDance: { min: 120, max: 140, value: 0.8 },
              // House/Dance music
              mediumDance: { min: 100, max: 160, value: 0.6 },
              // Pop/Electronic
              lowMediumDance: { min: 80, max: 180, value: 0.4 },
              // General music
              lowDance: { value: 0.2 }
              // Very slow/fast
            },
            // Energy estimation from tempo + loudness
            energyEstimation: {
              tempoWeight: 0.6,
              // How much tempo affects energy estimate
              loudnessWeight: 0.4,
              // How much loudness affects energy estimate
              tempoRange: { min: 60, max: 180 },
              // Expected tempo range
              loudnessRange: { min: -60, max: 0 }
              // Expected loudness range (dB)
            },
            // Enhanced BPM calculation parameters
            danceabilityThresholds: {
              high: 0.7,
              // High danceability - use full tempo
              low: 0.3
              // Low danceability - may reduce tempo
            },
            energyMultiplierRange: {
              min: 0.8,
              // Minimum energy multiplier
              max: 1.4
              // Maximum energy multiplier
            },
            tempoMultipliers: {
              highDance: 1,
              // Full tempo for danceable tracks
              mediumDance: 0.75,
              // Moderate reduction
              lowDance: 0.5
              // Significant reduction for smooth visuals
            },
            // Fallback values when audio data is unavailable
            fallbacks: {
              tempo: 120,
              loudness: -10,
              danceability: 0.5,
              energy: 0.5,
              key: 0,
              timeSignature: 4
            }
          }
        },
        // Enhanced: Get current mode profile with full Year3000 parameters
        getCurrentModeProfile() {
          const mode = this.artisticMode || "artist-vision";
          return ARTISTIC_MODE_PROFILES[mode] || ARTISTIC_MODE_PROFILES["artist-vision"];
        },
        // Enhanced: Get current multipliers from active mode profile
        getCurrentMultipliers() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[YEAR3000_CONFIG] getCurrentModeProfile method not available, using fallback multipliers"
              );
              return this["artisticMultipliers"];
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.multipliers) {
              console.warn(
                "[YEAR3000_CONFIG] Invalid profile or missing multipliers, using fallback"
              );
              return this["artisticMultipliers"];
            }
            return currentProfile.multipliers;
          } catch (error) {
            console.error("[YEAR3000_CONFIG] Error in getCurrentMultipliers:", error);
            return this["artisticMultipliers"];
          }
        },
        // Enhanced: Get current features from active mode profile
        getCurrentFeatures() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[YEAR3000_CONFIG] getCurrentModeProfile method not available, using fallback features"
              );
              return {
                enableAdvancedEffects: true,
                enableHarmony: true,
                beatSync: true,
                colorHarmony: true
              };
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.features) {
              console.warn(
                "[YEAR3000_CONFIG] Invalid profile or missing features, using fallback"
              );
              return {
                enableAdvancedEffects: true,
                enableHarmony: true,
                beatSync: true,
                colorHarmony: true
              };
            }
            return currentProfile.features;
          } catch (error) {
            console.error("[YEAR3000_CONFIG] Error in getCurrentFeatures:", error);
            return {
              enableAdvancedEffects: true,
              enableHarmony: true,
              beatSync: true,
              colorHarmony: true
            };
          }
        },
        // Enhanced: Get current performance settings from active mode profile
        getCurrentPerformanceSettings() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[YEAR3000_CONFIG] getCurrentModeProfile method not available, using fallback performance settings"
              );
              return {
                maxParticles: 20,
                animationThrottle: 16,
                enableGPUAcceleration: true,
                reducedMotion: false
              };
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.performance) {
              console.warn(
                "[YEAR3000_CONFIG] Invalid profile or missing performance settings, using fallback"
              );
              return {
                maxParticles: 20,
                animationThrottle: 16,
                enableGPUAcceleration: true,
                reducedMotion: false
              };
            }
            return currentProfile.performance;
          } catch (error) {
            console.error(
              "[YEAR3000_CONFIG] Error in getCurrentPerformanceSettings:",
              error
            );
            return {
              maxParticles: 20,
              animationThrottle: 16,
              enableGPUAcceleration: true,
              reducedMotion: false
            };
          }
        },
        // Check if YEAR3000_CONFIG is fully initialized with all required methods
        isFullyInitialized() {
          const requiredMethods = [
            "setArtisticMode",
            "getCurrentModeProfile",
            "getCurrentMultipliers",
            "getCurrentFeatures",
            "getCurrentPerformanceSettings"
          ];
          return requiredMethods.every(
            (method) => typeof this[method] === "function"
          );
        },
        // Safe setArtisticMode wrapper that validates state
        safeSetArtisticMode(mode) {
          if (!this.isFullyInitialized()) {
            console.warn(
              "[YEAR3000_CONFIG] Not fully initialized, deferring artistic mode change"
            );
            this._pendingArtisticMode = mode;
            return false;
          }
          return this.setArtisticMode(mode);
        },
        setArtisticMode(mode) {
          const validModes = Object.keys(ARTISTIC_MODE_PROFILES);
          if (validModes.includes(mode)) {
            const previousMode = this.artisticMode;
            this.artisticMode = mode;
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] Artistic mode changed: ${previousMode} \u2192 ${mode}`
              );
              console.log(
                `\u{1F3A8} [YEAR3000_CONFIG] New profile:`,
                this.getCurrentModeProfile()
              );
            }
            if (typeof document !== "undefined") {
              document.dispatchEvent(
                new CustomEvent("year3000ArtisticModeChanged", {
                  detail: {
                    previousMode,
                    newMode: mode,
                    profile: this.getCurrentModeProfile()
                  }
                })
              );
            }
            if (typeof globalThis.year3000System !== "undefined" && globalThis.year3000System.setGradientParameters) {
              globalThis.year3000System.setGradientParameters(
                document.documentElement
              );
            }
            return true;
          }
          console.warn(
            `[YEAR3000_CONFIG] Invalid artistic mode: ${mode}. Valid modes:`,
            validModes
          );
          return false;
        },
        // ===========================================
        // 🔧 LOGGING & PERFORMANCE CONFIGURATION HELPERS
        // ===========================================
        // Set logging level for all Year 3000 systems
        setLoggingLevel(level) {
          const validLevels = ["off", "error", "warn", "info", "debug", "verbose"];
          if (validLevels.includes(level)) {
            this.logging.level = level;
            if (level !== "off") {
              console.log(`\u{1F527} [YEAR3000_CONFIG] Logging level set to: ${level}`);
            }
            return true;
          }
          console.warn(
            `[YEAR3000_CONFIG] Invalid logging level: ${level}. Valid levels:`,
            validLevels
          );
          return false;
        },
        // Disable performance warnings (useful for production or when performance is acceptable)
        disablePerformanceWarnings() {
          this.logging.performance.enableFrameBudgetWarnings = false;
          console.log("\u{1F527} [YEAR3000_CONFIG] Performance warnings disabled");
        },
        // Enable performance warnings
        enablePerformanceWarnings() {
          this.logging.performance.enableFrameBudgetWarnings = true;
          console.log("\u{1F527} [YEAR3000_CONFIG] Performance warnings enabled");
        },
        // Set performance warning throttle interval (ms)
        setPerformanceWarningThrottle(intervalMs) {
          if (typeof intervalMs === "number" && intervalMs >= 0) {
            this.logging.performance.throttleInterval = intervalMs;
            this.logging.performance.throttleWarnings = intervalMs > 0;
            console.log(
              `\u{1F527} [YEAR3000_CONFIG] Performance warning throttle set to: ${intervalMs}ms`
            );
            return true;
          }
          console.warn(
            "[YEAR3000_CONFIG] Invalid throttle interval. Must be a non-negative number."
          );
          return false;
        },
        // Quick setup for different environments
        setupForProduction() {
          this.setLoggingLevel("warn");
          this.disablePerformanceWarnings();
          this.logging.performance.enableAdaptiveDegradation = true;
          console.log("\u{1F527} [YEAR3000_CONFIG] Configured for production environment");
        },
        setupForDevelopment() {
          this.setLoggingLevel("debug");
          this.enablePerformanceWarnings();
          this.setPerformanceWarningThrottle(2e3);
          this.logging.performance.enableAdaptiveDegradation = true;
          console.log("\u{1F527} [YEAR3000_CONFIG] Configured for development environment");
        },
        setupForDebugging() {
          this.setLoggingLevel("verbose");
          this.enablePerformanceWarnings();
          this.setPerformanceWarningThrottle(500);
          this.logging.performance.enableAdaptiveDegradation = false;
          console.log("\u{1F527} [YEAR3000_CONFIG] Configured for debugging environment");
        },
        // Validate configuration health and functionality
        validateConfigHealth() {
          const healthReport = {
            overallStatus: "healthy",
            issues: [],
            dynamicChecks: {}
          };
          const configKeys = Object.keys(this).filter(
            (k) => typeof k === "string"
          );
          const functionProperties = configKeys.filter(
            (key) => typeof this[key] === "function"
          );
          for (const key of functionProperties) {
            if (!this.hasOwnProperty(key)) {
              healthReport.issues.push({
                key: String(key),
                severity: "warning",
                message: `Method ${key} is not an own property, may indicate prototype chain issues.`
              });
            }
          }
          const checkProfile = /* @__PURE__ */ __name((mode) => {
            if (!ARTISTIC_MODE_PROFILES[mode]) {
              healthReport.issues.push({
                key: `artisticMode:${mode}`,
                severity: "critical",
                message: `Artistic mode profile for '${mode}' is missing.`
              });
              return;
            }
            healthReport.dynamicChecks[`${mode}Profile`] = "ok";
          }, "checkProfile");
          checkProfile(this.artisticMode);
          checkProfile("artist-vision");
          checkProfile("corporate-safe");
          if (healthReport.issues.length > 0) {
            healthReport.overallStatus = healthReport.issues.some(
              (i) => i.severity === "critical"
            ) ? "critical" : "unhealthy";
          }
          if (this.enableDebug) {
            console.log("[YEAR3000_CONFIG] Health Check Report:", healthReport);
          }
          return healthReport;
        },
        loadArtisticPreference() {
          const saved = StorageManager.get("sn-artistic-mode");
          const validModes = Object.keys(ARTISTIC_MODE_PROFILES);
          if (saved && validModes.includes(saved)) {
            this.artisticMode = saved;
          } else {
            this.artisticMode = "artist-vision";
          }
          if (this.enableDebug) {
            console.log(
              `\u{1F3A8} [YEAR3000_CONFIG] Loaded artistic preference: ${this.artisticMode}`
            );
          }
        }
      };
      if (typeof YEAR3000_CONFIG.init === "function") {
        YEAR3000_CONFIG.init();
      }
    }
  });

  // src-js/debug/UnifiedDebugManager.ts
  var _UnifiedDebugManager, UnifiedDebugManager, Y3K, UnifiedDebugManager_default;
  var init_UnifiedDebugManager = __esm({
    "src-js/debug/UnifiedDebugManager.ts"() {
      "use strict";
      init_globalConfig();
      _UnifiedDebugManager = class _UnifiedDebugManager {
        constructor(config = {}) {
          this.registeredSystems = /* @__PURE__ */ new Map();
          this.reportHistory = [];
          this.monitoring = false;
          this.monitoringInterval = null;
          this.performanceMetrics = /* @__PURE__ */ new Map();
          this.config = {
            enableConsoleReporting: YEAR3000_CONFIG.enableDebug,
            reportingInterval: 3e4,
            // 30 seconds
            enablePerformanceTracking: true,
            enableSystemHealthMonitoring: true,
            maxHistoryEntries: 50,
            verboseLogging: YEAR3000_CONFIG.enableDebug,
            ...config
          };
          if (this.config.enableConsoleReporting) {
            console.log("\u{1F527} [UnifiedDebugManager] Debug system initialized");
          }
        }
        static getInstance(config) {
          if (!_UnifiedDebugManager.instance) {
            _UnifiedDebugManager.instance = new _UnifiedDebugManager(config);
          }
          return _UnifiedDebugManager.instance;
        }
        // =========================================================================
        // SYSTEM REGISTRATION & MANAGEMENT
        // =========================================================================
        /**
         * Register a system for debug monitoring
         */
        registerSystem(name, system, type = "unified") {
          const debugInfo = {
            name,
            type,
            initialized: system.initialized || false,
            healthy: true,
            lastUpdate: Date.now(),
            issues: [],
            metrics: {}
          };
          this.registeredSystems.set(name, debugInfo);
          if (this.config.verboseLogging) {
            console.log(`\u{1F527} [UnifiedDebugManager] Registered system: ${name} (${type})`);
          }
          if (this.registeredSystems.size === 1 && !this.monitoring) {
            this.startMonitoring();
          }
        }
        /**
         * Unregister a system from debug monitoring
         */
        unregisterSystem(name) {
          this.registeredSystems.delete(name);
          this.performanceMetrics.delete(name);
          if (this.config.verboseLogging) {
            console.log(`\u{1F527} [UnifiedDebugManager] Unregistered system: ${name}`);
          }
          if (this.registeredSystems.size === 0) {
            this.stopMonitoring();
          }
        }
        /**
         * Update system debug information
         */
        updateSystem(name, updates) {
          const system = this.registeredSystems.get(name);
          if (!system) return;
          Object.assign(system, updates, { lastUpdate: Date.now() });
          this.registeredSystems.set(name, system);
        }
        /**
         * Record performance metric for a system
         */
        recordMetric(systemName, metricName, value) {
          if (!this.config.enablePerformanceTracking) return;
          const system = this.registeredSystems.get(systemName);
          if (system) {
            system.metrics[metricName] = value;
            system.lastUpdate = Date.now();
          }
          const key = `${systemName}_${metricName}`;
          const history = this.performanceMetrics.get(key) || [];
          history.push(value);
          if (history.length > 100) {
            history.splice(0, history.length - 100);
          }
          this.performanceMetrics.set(key, history);
        }
        /**
         * Record system issue
         */
        recordIssue(systemName, issue) {
          const system = this.registeredSystems.get(systemName);
          if (system) {
            system.issues.push(issue);
            system.healthy = false;
            system.lastUpdate = Date.now();
            if (this.config.verboseLogging) {
              console.warn(`\u26A0\uFE0F [${systemName}] ${issue}`);
            }
          }
        }
        // =========================================================================
        // SYSTEM HEALTH CHECKING
        // =========================================================================
        /**
         * Perform health check on all registered systems
         */
        async performHealthCheck() {
          const timestamp = Date.now();
          const systemDetails = [];
          let healthySystems = 0;
          let totalIssues = 0;
          let totalFrameTime = 0;
          let totalMemory = 0;
          let frameTimeCount = 0;
          for (const [name, system] of this.registeredSystems) {
            try {
              const actualSystem = globalThis.year3000System?.[name] || globalThis[name];
              if (actualSystem && typeof actualSystem.healthCheck === "function") {
                const healthResult = await actualSystem.healthCheck();
                system.healthy = healthResult.healthy ?? healthResult.ok;
                if (!healthResult.ok) {
                  system.issues = [healthResult.details || "Health check failed"];
                } else {
                  system.issues = [];
                }
              }
              if (system.frameTime) {
                totalFrameTime += system.frameTime;
                frameTimeCount++;
              }
              if (system.memoryUsage) {
                totalMemory += system.memoryUsage;
              }
              if (system.healthy) {
                healthySystems++;
              } else {
                totalIssues += system.issues.length;
              }
              systemDetails.push({ ...system });
            } catch (error) {
              system.healthy = false;
              system.issues = [`Health check error: ${error}`];
              totalIssues++;
              if (this.config.verboseLogging) {
                console.error(`\u274C [${name}] Health check failed:`, error);
              }
            }
          }
          const healthPercentage = this.registeredSystems.size > 0 ? healthySystems / this.registeredSystems.size : 1;
          let overallHealth;
          if (healthPercentage >= 0.9) overallHealth = "excellent";
          else if (healthPercentage >= 0.7) overallHealth = "good";
          else if (healthPercentage >= 0.5) overallHealth = "degraded";
          else overallHealth = "critical";
          const recommendations = this.generateRecommendations(systemDetails, overallHealth);
          const report = {
            timestamp,
            overallHealth,
            systemCount: this.registeredSystems.size,
            healthySystems,
            totalIssues,
            systemDetails,
            performance: {
              avgFrameTime: frameTimeCount > 0 ? totalFrameTime / frameTimeCount : 0,
              totalMemoryMB: totalMemory,
              cpuUsageEstimate: this.estimateCPUUsage()
            },
            recommendations
          };
          this.reportHistory.push(report);
          if (this.reportHistory.length > this.config.maxHistoryEntries) {
            this.reportHistory.splice(0, this.reportHistory.length - this.config.maxHistoryEntries);
          }
          return report;
        }
        /**
         * Generate actionable recommendations based on system state
         */
        generateRecommendations(systems, overallHealth) {
          const recommendations = [];
          if (overallHealth === "critical") {
            recommendations.push("\u{1F6A8} Critical: Multiple systems failing - check console for errors");
          }
          const uninitializedSystems = systems.filter((s) => !s.initialized);
          if (uninitializedSystems.length > 0) {
            recommendations.push(`\u26A0\uFE0F ${uninitializedSystems.length} systems not initialized: ${uninitializedSystems.map((s) => s.name).join(", ")}`);
          }
          const highFrameTimes = systems.filter((s) => s.frameTime && s.frameTime > 16.67);
          if (highFrameTimes.length > 0) {
            recommendations.push(`\u{1F40C} Performance: ${highFrameTimes.length} systems exceeding 16.67ms frame time`);
          }
          const memoryIssues = systems.filter((s) => s.memoryUsage && s.memoryUsage > 50);
          if (memoryIssues.length > 0) {
            recommendations.push(`\u{1F4BE} Memory: ${memoryIssues.length} systems using >50MB`);
          }
          if (recommendations.length === 0) {
            recommendations.push("\u2705 All systems operating within normal parameters");
          }
          return recommendations;
        }
        /**
         * Estimate CPU usage based on frame times and system activity
         */
        estimateCPUUsage() {
          let totalFrameTime = 0;
          let count = 0;
          for (const system of this.registeredSystems.values()) {
            if (system.frameTime) {
              totalFrameTime += system.frameTime;
              count++;
            }
          }
          if (count === 0) return 0;
          const avgFrameTime = totalFrameTime / count;
          return Math.min(100, avgFrameTime / 16.67 * 5);
        }
        // =========================================================================
        // MONITORING & REPORTING
        // =========================================================================
        /**
         * Start automatic monitoring
         */
        startMonitoring() {
          if (this.monitoring) return;
          this.monitoring = true;
          this.monitoringInterval = window.setInterval(() => {
            this.performHealthCheck().then((report) => {
              if (this.config.enableConsoleReporting) {
                this.logHealthReport(report);
              }
            });
          }, this.config.reportingInterval);
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Monitoring started");
          }
        }
        /**
         * Stop automatic monitoring
         */
        stopMonitoring() {
          if (!this.monitoring) return;
          this.monitoring = false;
          if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
          }
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Monitoring stopped");
          }
        }
        /**
         * Log health report to console in a readable format
         */
        logHealthReport(report) {
          if (!report) {
            this.performHealthCheck().then((r) => this.logHealthReport(r));
            return;
          }
          const statusEmoji = {
            excellent: "\u{1F31F}",
            good: "\u2705",
            degraded: "\u26A0\uFE0F",
            critical: "\u{1F6A8}"
          }[report.overallHealth];
          console.group(`${statusEmoji} Year 3000 System Health Report - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}`);
          console.log(`\u{1F4CA} Overall: ${report.overallHealth.toUpperCase()} (${report.healthySystems}/${report.systemCount} healthy)`);
          if (report.totalIssues > 0) {
            console.log(`\u{1F6A8} Issues: ${report.totalIssues} total`);
          }
          console.log(`\u26A1 Performance: ${report.performance.avgFrameTime.toFixed(2)}ms avg frame, ${report.performance.totalMemoryMB.toFixed(1)}MB memory, ~${report.performance.cpuUsageEstimate.toFixed(1)}% CPU`);
          if (report.systemDetails.length > 0) {
            console.group("\u{1F527} System Details");
            report.systemDetails.forEach((system) => {
              const emoji = system.healthy ? "\u2705" : "\u274C";
              const frameInfo = system.frameTime ? ` (${system.frameTime.toFixed(2)}ms)` : "";
              console.log(`${emoji} ${system.name} [${system.type}]${frameInfo}`);
              if (system.issues.length > 0) {
                system.issues.forEach((issue) => {
                  console.log(`    \u26A0\uFE0F ${issue}`);
                });
              }
            });
            console.groupEnd();
          }
          if (report.recommendations.length > 0) {
            console.group("\u{1F4A1} Recommendations");
            report.recommendations.forEach((rec) => console.log(`  ${rec}`));
            console.groupEnd();
          }
          console.groupEnd();
        }
        // =========================================================================
        // PUBLIC API & UTILITIES
        // =========================================================================
        /**
         * Get the latest debug report
         */
        getLatestReport() {
          return this.reportHistory[this.reportHistory.length - 1] || null;
        }
        /**
         * Get all report history
         */
        getReportHistory() {
          return [...this.reportHistory];
        }
        /**
         * Get system information
         */
        getSystemInfo(name) {
          return this.registeredSystems.get(name) || null;
        }
        /**
         * Get all registered systems
         */
        getAllSystems() {
          return Array.from(this.registeredSystems.values());
        }
        /**
         * Manual health check trigger
         */
        async checkHealth() {
          const report = await this.performHealthCheck();
          this.logHealthReport(report);
        }
        /**
         * Update debug configuration
         */
        updateConfig(config) {
          this.config = { ...this.config, ...config };
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Configuration updated:", config);
          }
        }
        /**
         * Clear all data and reset
         */
        reset() {
          this.stopMonitoring();
          this.registeredSystems.clear();
          this.reportHistory = [];
          this.performanceMetrics.clear();
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] System reset");
          }
        }
        /**
         * Destroy the debug manager
         */
        destroy() {
          this.reset();
          _UnifiedDebugManager.instance = null;
        }
      };
      __name(_UnifiedDebugManager, "UnifiedDebugManager");
      UnifiedDebugManager = _UnifiedDebugManager;
      Y3K = {
        debug: {
          log: /* @__PURE__ */ __name((component, message, ...args) => {
            if (YEAR3000_CONFIG?.enableDebug) {
              console.log(`[${component}] ${message}`, ...args);
            }
          }, "log"),
          error: /* @__PURE__ */ __name((component, message, error) => {
            console.error(`[${component}] ${message}`, error);
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordIssue(component, `${message}${error ? `: ${error}` : ""}`);
          }, "error"),
          warn: /* @__PURE__ */ __name((component, message, ...args) => {
            console.warn(`[${component}] ${message}`, ...args);
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordIssue(component, message);
          }, "warn"),
          metric: /* @__PURE__ */ __name((system, metric, value) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordMetric(system, metric, value);
          }, "metric"),
          register: /* @__PURE__ */ __name((name, system, type) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.registerSystem(name, system, type);
          }, "register"),
          unregister: /* @__PURE__ */ __name((name) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.unregisterSystem(name);
          }, "unregister"),
          checkHealth: /* @__PURE__ */ __name(() => {
            const debugManager = UnifiedDebugManager.getInstance();
            return debugManager.checkHealth();
          }, "checkHealth"),
          getReport: /* @__PURE__ */ __name(() => {
            const debugManager = UnifiedDebugManager.getInstance();
            return debugManager.getLatestReport();
          }, "getReport")
        }
      };
      if (typeof window !== "undefined") {
        window.UnifiedDebugManager = UnifiedDebugManager;
        window.Y3K = Y3K;
        console.log("\u{1F527} [UnifiedDebugManager] Global debug interface available:");
        console.log("  Y3K.debug.checkHealth() - Check system health");
        console.log("  Y3K.debug.getReport() - Get latest debug report");
        console.log("  UnifiedDebugManager.getInstance() - Get debug manager");
      }
      UnifiedDebugManager_default = UnifiedDebugManager;
    }
  });

  // src-js/core/performance/DeviceCapabilityDetector.ts
  var _DeviceCapabilityDetector, DeviceCapabilityDetector;
  var init_DeviceCapabilityDetector = __esm({
    "src-js/core/performance/DeviceCapabilityDetector.ts"() {
      "use strict";
      _DeviceCapabilityDetector = class _DeviceCapabilityDetector {
        constructor(config = {}) {
          this.deviceCapabilities = null;
          this.isInitialized = false;
          this.config = {
            enableDebug: config.enableDebug || false,
            runStressTests: config.runStressTests !== false,
            ...config
          };
          if (this.config.enableDebug) {
            console.log("\u{1F50D} [DeviceCapabilityDetector] Initialized");
          }
        }
        async initialize() {
          if (this.isInitialized) {
            return this.deviceCapabilities;
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F50D} [DeviceCapabilityDetector] Starting capability detection..."
            );
          }
          this.deviceCapabilities = {
            memory: {
              total: navigator.deviceMemory || 4,
              level: this._detectMemoryLevel(),
              jsHeapSizeLimit: performance.memory?.jsHeapSizeLimit || 0,
              estimatedAvailable: this._estimateAvailableMemory()
            },
            cpu: {
              cores: navigator.hardwareConcurrency || 2,
              level: this._detectCPULevel(),
              estimatedScore: this._calculateCPUScore()
            },
            gpu: {
              supportsWebGL: this._detectWebGLSupport(),
              supportsWebGL2: this._detectWebGL2Support(),
              maxTextureSize: this._getMaxTextureSize(),
              level: this._detectGPULevel(),
              vendor: this._getGPUVendor(),
              renderer: this._getGPURenderer()
            },
            browser: {
              supportsOffscreenCanvas: this._detectOffscreenCanvasSupport(),
              supportsWorkers: this._detectWorkerSupport(),
              supportsSharedArrayBuffer: this._detectSharedArrayBufferSupport(),
              supportsWASM: this._detectWASMSupport(),
              supportsCSSHoudini: this._detectCSSHoudiniSupport()
            },
            display: {
              pixelRatio: window.devicePixelRatio || 1,
              refreshRate: await this._detectRefreshRate(),
              colorGamut: this._detectColorGamut(),
              contrastRatio: this._detectContrastCapability(),
              reducedMotion: this._detectReducedMotion()
            },
            network: {
              effectiveType: navigator.connection?.effectiveType || "unknown",
              downlink: navigator.connection?.downlink || 0,
              rtt: navigator.connection?.rtt || 0,
              saveData: navigator.connection?.saveData || false
            },
            overall: "detecting"
          };
          if (this.config.runStressTests) {
            await this._runCapabilityTests();
          }
          this.deviceCapabilities.overall = this._calculateOverallPerformanceLevel();
          this.isInitialized = true;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F4CA} [DeviceCapabilityDetector] Capabilities detected:",
              this.deviceCapabilities
            );
          }
          return this.deviceCapabilities;
        }
        _detectMemoryLevel() {
          const memory = navigator.deviceMemory || 4;
          if (memory >= 8) return "high";
          if (memory >= 4) return "medium";
          return "low";
        }
        _estimateAvailableMemory() {
          if (performance.memory) {
            return performance.memory.jsHeapSizeLimit - performance.memory.usedJSHeapSize;
          }
          return (navigator.deviceMemory || 4) * 1024 * 1024 * 1024 * 0.7;
        }
        _detectCPULevel() {
          const cores = navigator.hardwareConcurrency || 2;
          if (cores >= 8) return "high";
          if (cores >= 4) return "medium";
          return "low";
        }
        _calculateCPUScore() {
          const start = performance.now();
          let result = 0;
          for (let i = 0; i < 1e5; i++) {
            result += Math.sin(i) * Math.cos(i);
          }
          const duration = performance.now() - start;
          if (duration < 10) return "high";
          if (duration < 25) return "medium";
          return "low";
        }
        _detectWebGLSupport() {
          try {
            const canvas = document.createElement("canvas");
            return !!(canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
          } catch (e) {
            return false;
          }
        }
        _detectWebGL2Support() {
          try {
            const canvas = document.createElement("canvas");
            return !!canvas.getContext("webgl2");
          } catch (e) {
            return false;
          }
        }
        _getMaxTextureSize() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            return gl ? gl.getParameter(gl.MAX_TEXTURE_SIZE) : 0;
          } catch (e) {
            return 0;
          }
        }
        _getGPUVendor() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) return "unknown";
            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            return debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "unknown";
          } catch (e) {
            return "unknown";
          }
        }
        _getGPURenderer() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) return "unknown";
            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            return debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "unknown";
          } catch (e) {
            return "unknown";
          }
        }
        _detectGPULevel() {
          const renderer = this._getGPURenderer().toLowerCase();
          if (/rtx|radeon rx|gtx 16|gtx 20|apple m[1-9]/.test(renderer)) {
            return "high";
          }
          if (/gtx|radeon|intel iris|intel uhd/.test(renderer)) {
            return "medium";
          }
          return "low";
        }
        _detectOffscreenCanvasSupport() {
          return typeof OffscreenCanvas !== "undefined";
        }
        _detectWorkerSupport() {
          return typeof Worker !== "undefined";
        }
        _detectSharedArrayBufferSupport() {
          return typeof SharedArrayBuffer !== "undefined";
        }
        _detectWASMSupport() {
          return typeof WebAssembly !== "undefined";
        }
        _detectCSSHoudiniSupport() {
          return typeof CSS !== "undefined" && CSS.paintWorklet !== void 0;
        }
        async _detectRefreshRate() {
          return new Promise((resolve) => {
            let lastTime = performance.now();
            let frameCount = 0;
            const samples = [];
            const measure = /* @__PURE__ */ __name(() => {
              const currentTime = performance.now();
              const delta = currentTime - lastTime;
              samples.push(1e3 / delta);
              lastTime = currentTime;
              frameCount++;
              if (frameCount < 10) {
                requestAnimationFrame(measure);
              } else {
                const avgFPS = samples.reduce((a, b) => a + b, 0) / samples.length;
                resolve(Math.round(avgFPS));
              }
            }, "measure");
            requestAnimationFrame(measure);
          });
        }
        _detectColorGamut() {
          if (window.matchMedia("(color-gamut: p3)").matches) return "p3";
          if (window.matchMedia("(color-gamut: srgb)").matches) return "srgb";
          return "limited";
        }
        _detectContrastCapability() {
          if (window.matchMedia("(dynamic-range: high)").matches) return "high";
          if (window.matchMedia("(contrast: high)").matches) return "high";
          return "standard";
        }
        _detectReducedMotion() {
          return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        }
        async _runCapabilityTests() {
          if (this.deviceCapabilities) {
            this.deviceCapabilities.gpu.stressTestScore = await this._runGPUStressTest();
            this.deviceCapabilities.memory.stressTestScore = await this._runMemoryStressTest();
          }
          if (this.config.enableDebug) {
            console.log("\u26A1 [DeviceCapabilityDetector] Capability tests completed");
          }
        }
        async _runGPUStressTest() {
          return 0;
        }
        async _runMemoryStressTest() {
          return 0;
        }
        _calculateOverallPerformanceLevel() {
          if (!this.deviceCapabilities) return "low";
          const scores = {
            memory: this.deviceCapabilities.memory.level === "high" ? 3 : this.deviceCapabilities.memory.level === "medium" ? 2 : 1,
            cpu: this.deviceCapabilities.cpu.level === "high" ? 3 : this.deviceCapabilities.cpu.level === "medium" ? 2 : 1,
            gpu: this.deviceCapabilities.gpu.level === "high" ? 3 : this.deviceCapabilities.gpu.level === "medium" ? 2 : 1,
            browser: (this.deviceCapabilities.gpu.supportsWebGL ? 1 : 0) + (this.deviceCapabilities.browser.supportsWorkers ? 1 : 0) + (this.deviceCapabilities.browser.supportsOffscreenCanvas ? 1 : 0)
          };
          const totalScore = scores.memory + scores.cpu + scores.gpu + Math.min(scores.browser, 3);
          if (totalScore >= 10) return "high";
          if (totalScore >= 7) return "medium";
          return "low";
        }
        getCapabilities() {
          if (!this.isInitialized) {
            console.warn(
              "[DeviceCapabilityDetector] Not initialized - call initialize() first"
            );
            return null;
          }
          return this.deviceCapabilities;
        }
        destroy() {
          this.deviceCapabilities = null;
          this.isInitialized = false;
          if (this.config.enableDebug) {
            console.log("\u{1F50D} [DeviceCapabilityDetector] Destroyed");
          }
        }
        /**
         * Recommend a performance-quality label that callers (e.g., visual systems)
         * can use to pick an appropriate performance profile.
         * Returns one of `"low" | "balanced" | "high"`.
         */
        recommendPerformanceQuality() {
          if (!this.isInitialized || !this.deviceCapabilities) {
            return "balanced";
          }
          switch (this.deviceCapabilities.overall) {
            case "high":
              return "high";
            case "medium":
              return "balanced";
            case "low":
            default:
              return "low";
          }
        }
      };
      __name(_DeviceCapabilityDetector, "DeviceCapabilityDetector");
      DeviceCapabilityDetector = _DeviceCapabilityDetector;
    }
  });

  // src-js/utils/graphics/VisualCanvasFactory.ts
  function detectWebGL2Support() {
    try {
      const testCanvas = document.createElement("canvas");
      const gl = testCanvas.getContext("webgl2");
      if (!gl) return false;
      const hasRequiredExtensions = gl.getExtension("EXT_color_buffer_float") !== null;
      return true;
    } catch (e) {
      return false;
    }
  }
  function createWebGL2Context(canvas, options) {
    try {
      const contextOptions = {
        alpha: options.alpha ?? true,
        antialias: options.antialias ?? true,
        preserveDrawingBuffer: options.preserveDrawingBuffer ?? false,
        powerPreference: "high-performance",
        failIfMajorPerformanceCaveat: false
      };
      const gl = canvas.getContext(
        "webgl2",
        contextOptions
      );
      if (!gl) return null;
      const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      return {
        canvas,
        ctx: gl,
        type: "webgl2",
        capabilities: {
          supportsGPUAcceleration: true,
          supports3D: true,
          maxTextureSize
        }
      };
    } catch (error) {
      console.warn(
        "[VisualCanvasFactory] WebGL2 context creation failed:",
        error
      );
      return null;
    }
  }
  function create2DContext(canvas, options) {
    const contextOptions = {
      alpha: options.alpha ?? true,
      desynchronized: true
      // Optimize for animations
    };
    const ctx = canvas.getContext(
      "2d",
      contextOptions
    );
    return {
      canvas,
      ctx,
      type: "2d",
      capabilities: {
        supportsGPUAcceleration: false,
        supports3D: false
      }
    };
  }
  async function createOptimizedCanvas(options) {
    const canvas = document.createElement("canvas");
    canvas.id = options.id;
    canvas.width = options.width ?? window.innerWidth;
    canvas.height = options.height ?? window.innerHeight;
    const fallbackChain = options.fallbackChain ?? ["webgl2", "2d"];
    if (options.preferredType) {
      const chain = [
        options.preferredType,
        ...fallbackChain.filter((t) => t !== options.preferredType)
      ];
      fallbackChain.splice(0, fallbackChain.length, ...chain);
    }
    for (const contextType of fallbackChain) {
      let result = null;
      switch (contextType) {
        case "webgl2":
          if (detectWebGL2Support()) {
            result = createWebGL2Context(canvas, options);
          }
          break;
        case "2d":
          result = create2DContext(canvas, options);
          break;
      }
      if (result) {
        return result;
      }
    }
    return create2DContext(canvas, options);
  }
  function detectRenderingCapabilities() {
    const webgl2 = detectWebGL2Support();
    let recommendedType = "2d";
    if (webgl2) {
      recommendedType = "webgl2";
    }
    return { webgl2, recommendedType };
  }
  var init_VisualCanvasFactory = __esm({
    "src-js/utils/graphics/VisualCanvasFactory.ts"() {
      "use strict";
      __name(detectWebGL2Support, "detectWebGL2Support");
      __name(createWebGL2Context, "createWebGL2Context");
      __name(create2DContext, "create2DContext");
      __name(createOptimizedCanvas, "createOptimizedCanvas");
      __name(detectRenderingCapabilities, "detectRenderingCapabilities");
    }
  });

  // src-js/utils/core/Year3000Utilities.ts
  var Year3000Utilities_exports = {};
  __export(Year3000Utilities_exports, {
    adjustColor: () => adjustColor,
    bpmToAnimationFrameRate: () => bpmToAnimationFrameRate,
    bpmToInterval: () => bpmToInterval,
    calculateBreathingScale: () => calculateBreathingScale,
    calculateContrastRatio: () => calculateContrastRatio,
    calculateNavigationScale: () => calculateNavigationScale,
    calculateOklabDerivedProperties: () => calculateOklabDerivedProperties,
    calculateRhythmPhase: () => calculateRhythmPhase,
    colorDifference: () => colorDifference,
    debounce: () => debounce,
    easeBeatAnimation: () => easeBeatAnimation,
    findRequiredLuminance: () => findRequiredLuminance,
    generateHarmonicOklabColors: () => generateHarmonicOklabColors,
    getBeatPhase: () => getBeatPhase,
    getCanonicalAccent: () => getCanonicalAccent,
    getHealthMonitor: () => getHealthMonitor,
    getNextBeatTime: () => getNextBeatTime,
    getRootStyle: () => getRootStyle,
    hexToRgb: () => hexToRgb,
    hslToRgb: () => hslToRgb,
    intervalToBpm: () => intervalToBpm,
    isOnBeat: () => isOnBeat,
    lerp: () => lerp,
    lerpSmooth: () => lerpSmooth,
    oklabToRgb: () => oklabToRgb,
    processOklabColor: () => processOklabColor,
    rgbToHex: () => rgbToHex,
    rgbToHsl: () => rgbToHsl,
    rgbToOklab: () => rgbToOklab,
    sanitizeColorMap: () => sanitizeColorMap,
    sleep: () => sleep,
    throttle: () => throttle
  });
  function getRootStyle() {
    return document.documentElement;
  }
  function throttle(func, limit) {
    let inThrottle;
    return /* @__PURE__ */ __name(function throttled(...args) {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    }, "throttled");
  }
  function debounce(func, delay) {
    let timeoutId;
    return /* @__PURE__ */ __name(function debounced(...args) {
      clearTimeout(timeoutId);
      timeoutId = window.setTimeout(() => func(...args), delay);
    }, "debounced");
  }
  function hexToRgb(hex) {
    if (typeof hex !== "string") {
      console.warn(
        "[StarryNight hexToRgb] Input is not a string. Using fallback color (black). Hex:",
        hex
      );
      return { r: 0, g: 0, b: 0 };
    }
    const sanitizedHex = hex.trim();
    let processedHex = sanitizedHex.startsWith("#") ? sanitizedHex : `#${sanitizedHex}`;
    processedHex = processedHex.replace(/##+/g, "#");
    if (processedHex.length === 4) {
      processedHex = `#${processedHex[1]}${processedHex[1]}${processedHex[2]}${processedHex[2]}${processedHex[3]}${processedHex[3]}`;
    }
    const result = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(processedHex);
    if (result) {
      try {
        const rgb = {
          r: parseInt(result[1] || "0", 16),
          g: parseInt(result[2] || "0", 16),
          b: parseInt(result[3] || "0", 16)
        };
        return rgb;
      } catch (e) {
        console.error(
          "[StarryNight hexToRgb] ERROR during parseInt:",
          e,
          "for hex:",
          processedHex,
          ". Using fallback color (black)."
        );
        return { r: 0, g: 0, b: 0 };
      }
    } else {
      console.warn(
        "[StarryNight hexToRgb] REGEX failed for hex:",
        processedHex,
        ". Using fallback color (black)."
      );
      return { r: 0, g: 0, b: 0 };
    }
  }
  function sanitizeColorMap(input) {
    const validHex = /^#?[0-9a-fA-F]{3}(?:[0-9a-fA-F]{3})?$/;
    const sanitized = {};
    if (!input || typeof input !== "object") {
      return sanitized;
    }
    Object.entries(input).forEach(([key, value]) => {
      if (typeof value !== "string") return;
      const trimmed = value.trim();
      if (!trimmed || trimmed === "undefined") return;
      if (!validHex.test(trimmed)) return;
      const normalised = trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
      sanitized[key] = normalised;
    });
    if (YEAR3000_CONFIG?.enableDebug && Object.keys(input).length !== Object.keys(sanitized).length) {
      console.warn(
        `[StarryNight sanitizeColorMap] Dropped ${Object.keys(input).length - Object.keys(sanitized).length} invalid colour entries.`
      );
    }
    return sanitized;
  }
  function rgbToHsl(r, g2, b) {
    r /= 255;
    g2 /= 255;
    b /= 255;
    const max = Math.max(r, g2, b), min = Math.min(r, g2, b);
    let h = 0, s = 0, l = (max + min) / 2;
    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g2 - b) / d + (g2 < b ? 6 : 0);
          break;
        case g2:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g2) / d + 4;
          break;
      }
      h /= 6;
    }
    return { h: h * 360, s: s * 100, l: l * 100 };
  }
  function hslToRgb(h, s, l) {
    h /= 360;
    s /= 100;
    l /= 100;
    const hue2rgb = /* @__PURE__ */ __name((p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }, "hue2rgb");
    let r_val, g_val, b_val;
    if (s === 0) {
      r_val = g_val = b_val = l;
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r_val = hue2rgb(p, q, h + 1 / 3);
      g_val = hue2rgb(p, q, h);
      b_val = hue2rgb(p, q, h - 1 / 3);
    }
    return {
      r: Math.round(r_val * 255),
      g: Math.round(g_val * 255),
      b: Math.round(b_val * 255)
    };
  }
  function rgbToHex(r, g2, b) {
    const normalize = /* @__PURE__ */ __name((c) => {
      if (!Number.isFinite(c)) return 0;
      const scaled = c <= 1 ? c * 255 : c;
      return Math.min(255, Math.max(0, Math.round(scaled)));
    }, "normalize");
    const [nr, ng, nb] = [normalize(r), normalize(g2), normalize(b)];
    return "#" + [nr, ng, nb].map((channel) => channel.toString(16).padStart(2, "0")).join("");
  }
  function calculateContrastRatio(color1, color2) {
    const getLuminance = /* @__PURE__ */ __name((rgb) => {
      const [r_val = 0, g_val = 0, b_val = 0] = [rgb.r, rgb.g, rgb.b].map((c) => {
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * r_val + 0.7152 * g_val + 0.0722 * b_val;
    }, "getLuminance");
    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color2);
    if (!rgb1 || !rgb2) return 1;
    const lum1 = getLuminance(rgb1);
    const lum2 = getLuminance(rgb2);
    const brightest = Math.max(lum1, lum2);
    const darkest = Math.min(lum1, lum2);
    return (brightest + 0.05) / (darkest + 0.05);
  }
  function lerpSmooth(current, target, deltaTime, halfLife) {
    const EPSILON = 1e-5;
    if (halfLife <= EPSILON || deltaTime <= 0) {
      if (YEAR3000_CONFIG?.enableDebug) {
        if (halfLife <= EPSILON) {
        }
      }
      return target;
    }
    const result = target + (current - target) * Math.pow(2, -deltaTime / halfLife);
    return result;
  }
  function bpmToInterval(bpm) {
    if (!bpm || bpm <= 0) return 500;
    return 6e4 / bpm;
  }
  function intervalToBpm(intervalMs) {
    if (!intervalMs || intervalMs <= 0) return 120;
    return 6e4 / intervalMs;
  }
  function bpmToAnimationFrameRate(bpm, framesPerBeat = 4) {
    const beatInterval = bpmToInterval(bpm);
    return beatInterval / framesPerBeat;
  }
  function isOnBeat(currentTime, trackStartTime, bpm, tolerance = 50) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatPosition = timeSinceStart % beatInterval;
    return beatPosition <= tolerance || beatPosition >= beatInterval - tolerance;
  }
  function getBeatPhase(currentTime, trackStartTime, bpm) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatPosition = timeSinceStart % beatInterval;
    return beatPosition / beatInterval;
  }
  function getNextBeatTime(currentTime, trackStartTime, bpm) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatsElapsed = Math.floor(timeSinceStart / beatInterval);
    return trackStartTime + (beatsElapsed + 1) * beatInterval;
  }
  function easeBeatAnimation(beatPhase, easingType = "ease-out") {
    switch (easingType) {
      case "ease-in":
        return beatPhase * beatPhase;
      case "linear":
        return beatPhase;
      case "ease-out":
      default:
        return beatPhase * (2 - beatPhase);
    }
  }
  function calculateRhythmPhase(currentTime, animationSpeedFactor = 1) {
    const speed = 1e-3 * animationSpeedFactor;
    return currentTime * speed % (2 * Math.PI);
  }
  function calculateBreathingScale(rhythmPhase, processedEnergy = 0.5) {
    const baseScale = 1;
    const pulseAmount = 0.02 * processedEnergy;
    const breath = Math.sin(rhythmPhase) * pulseAmount;
    return baseScale + breath;
  }
  function calculateNavigationScale(visualIntensity = 0.5, moodIdentifier = "neutral") {
    const baseScale = 1;
    const moodFactor = moodIdentifier === "energetic" ? 1.2 : moodIdentifier === "calm" ? 0.8 : 1;
    return baseScale + 0.05 * visualIntensity * moodFactor;
  }
  function rgbToOklab(r_srgb, g_srgb, b_srgb) {
    const r = r_srgb / 255;
    const g2 = g_srgb / 255;
    const b = b_srgb / 255;
    const l = 0.4122214708 * r + 0.5363325363 * g2 + 0.0514459929 * b;
    const m = 0.2119034982 * r + 0.6806995451 * g2 + 0.1073969566 * b;
    const s = 0.0883024619 * r + 0.2817188376 * g2 + 0.6299787005 * b;
    const l_ = Math.cbrt(l);
    const m_ = Math.cbrt(m);
    const s_ = Math.cbrt(s);
    return {
      L: 0.2104542553 * l_ + 0.793617785 * m_ - 0.0040720468 * s_,
      a: 1.9779984951 * l_ - 2.428592205 * m_ + 0.4505937099 * s_,
      b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.808675766 * s_
    };
  }
  function oklabToRgb(L, a, b_oklab) {
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b_oklab;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b_oklab;
    const s_ = L - 0.0894841775 * a - 1.291485548 * b_oklab;
    const l = l_ * l_ * l_;
    const m = m_ * m_ * m_;
    const s = s_ * s_ * s_;
    let r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
    let g2 = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
    let b = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s;
    r = Math.round(Math.max(0, Math.min(1, r)) * 255);
    g2 = Math.round(Math.max(0, Math.min(1, g2)) * 255);
    b = Math.round(Math.max(0, Math.min(1, b)) * 255);
    return { r, g: g2, b };
  }
  function processOklabColor(oklabColor, context = {}) {
    const { L, a, b } = oklabColor;
    const C = Math.sqrt(a * a + b * b);
    let h_rad = Math.atan2(b, a);
    if (h_rad < 0) {
      h_rad += 2 * Math.PI;
    }
    const h = h_rad * (180 / Math.PI);
    const {
      energy = 0.5,
      valence = 0.5,
      artisticMode = "artist-vision"
    } = context;
    const multipliers = YEAR3000_CONFIG.getCurrentMultipliers();
    let adjusted_L = L * (1 + (valence - 0.5) * 0.1);
    let adjusted_C = C * (1 + (energy - 0.5) * 0.2) * (multipliers?.saturation || 1);
    adjusted_L = Math.max(
      0,
      Math.min(1, adjusted_L * (multipliers?.brightness || 1))
    );
    return {
      L: adjusted_L,
      C: adjusted_C,
      h: C > 1e-3 ? h : null
      // Hue is meaningless if chroma is near zero
    };
  }
  function calculateOklabDerivedProperties(oklabColor) {
    const { L, C, h } = processOklabColor(oklabColor);
    const isWarm = h !== null ? h >= 0 && h < 90 || h >= 270 && h <= 360 : false;
    const isCool = h !== null ? h >= 90 && h < 270 : false;
    let mood = "neutral";
    if (L > 0.7 && C > 0.1) mood = "bright";
    else if (L < 0.4) mood = "dark";
    else if (isWarm && C > 0.1) mood = "warm";
    else if (isCool && C > 0.1) mood = "cool";
    return {
      lightness: L,
      chroma: C,
      hue: h,
      isWarm,
      isCool,
      mood
    };
  }
  function generateHarmonicOklabColors(baseOklabColor, rule = "analogous", angle = 30) {
    const baseLCH = processOklabColor(baseOklabColor);
    if (baseLCH.h === null) {
      return [baseOklabColor];
    }
    const getOklabFromLCH = /* @__PURE__ */ __name((l_val, c_val, h_deg_val) => {
      const h_rad = h_deg_val * (Math.PI / 180);
      const a_val = c_val * Math.cos(h_rad);
      const b_val = c_val * Math.sin(h_rad);
      return { L: l_val, a: a_val, b: b_val };
    }, "getOklabFromLCH");
    const colors = [baseOklabColor];
    const { L, C, h } = baseLCH;
    switch (rule) {
      case "complementary":
        colors.push(getOklabFromLCH(L, C, (h + 180) % 360));
        break;
      case "analogous":
        colors.push(getOklabFromLCH(L, C, (h + angle) % 360));
        colors.push(getOklabFromLCH(L, C, (h - angle + 360) % 360));
        break;
      case "triadic":
        colors.push(getOklabFromLCH(L, C, (h + 120) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 240) % 360));
        break;
      case "tetradic":
        colors.push(getOklabFromLCH(L, C, (h + 90) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 180) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 270) % 360));
        break;
      case "split-complementary":
        colors.push(getOklabFromLCH(L, C, (h + 180 - angle) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 180 + angle) % 360));
        break;
      case "monochromatic":
        colors.push({
          L: Math.max(0, L - 0.2),
          a: baseOklabColor.a,
          b: baseOklabColor.b
        });
        colors.push({
          L: Math.min(1, L + 0.2),
          a: baseOklabColor.a,
          b: baseOklabColor.b
        });
        break;
    }
    return colors;
  }
  function lerp(start, end, amt) {
    return (1 - amt) * start + amt * end;
  }
  function colorDifference(rgb1, rgb2) {
    const lab1 = rgbToOklab(rgb1.r, rgb1.g, rgb1.b);
    const lab2 = rgbToOklab(rgb2.r, rgb2.g, rgb2.b);
    const deltaL = lab1.L - lab2.L;
    const deltaA = lab1.a - lab2.a;
    const deltaB = lab1.b - lab2.b;
    return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
  }
  function getHealthMonitor() {
    return healthMonitorInstance;
  }
  function findRequiredLuminance(color1, color2, ratio) {
    const getLuminance = /* @__PURE__ */ __name((rgb) => {
      const [r_val = 0, g_val = 0, b_val = 0] = [rgb.r, rgb.g, rgb.b].map((c) => {
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * r_val + 0.7152 * g_val + 0.0722 * b_val;
    }, "getLuminance");
    const lum2 = getLuminance(color2);
    let targetLuminance;
    targetLuminance = ratio * (lum2 + 0.05) - 0.05;
    const hsl = rgbToHsl(color1.r, color1.g, color1.b);
    const currentLuminance = getLuminance(color1);
    const luminanceRatio = targetLuminance / currentLuminance;
    return hsl.l;
  }
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function adjustColor(rgb, {
    brightness = 1,
    saturation = 1,
    hue = 0
  }) {
    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
    hsl.h = (hsl.h + hue) % 360;
    hsl.s = Math.max(0, Math.min(100, hsl.s * saturation));
    hsl.l = Math.max(0, Math.min(100, hsl.l * brightness));
    return hslToRgb(hsl.h, hsl.s, hsl.l);
  }
  function getCanonicalAccent() {
    const root = getRootStyle();
    const styles = getComputedStyle(root);
    let hex = styles.getPropertyValue("--sn-accent-hex").trim();
    let rgb = styles.getPropertyValue("--sn-accent-rgb").trim();
    if (!hex && rgb) {
      const [rStr = "0", gStr = "0", bStr = "0"] = rgb.split(/\s*,\s*/);
      const r = parseInt(rStr, 10) || 0;
      const g2 = parseInt(gStr, 10) || 0;
      const b = parseInt(bStr, 10) || 0;
      hex = rgbToHex(r, g2, b);
    }
    if (!rgb && hex) {
      const rgbObj = hexToRgb(hex);
      if (rgbObj) {
        rgb = `${rgbObj.r},${rgbObj.g},${rgbObj.b}`;
      }
    }
    return { hex, rgb };
  }
  var _HealthMonitor, HealthMonitor, healthMonitorInstance;
  var init_Year3000Utilities = __esm({
    "src-js/utils/core/Year3000Utilities.ts"() {
      "use strict";
      init_globalConfig();
      __name(getRootStyle, "getRootStyle");
      __name(throttle, "throttle");
      __name(debounce, "debounce");
      __name(hexToRgb, "hexToRgb");
      __name(sanitizeColorMap, "sanitizeColorMap");
      __name(rgbToHsl, "rgbToHsl");
      __name(hslToRgb, "hslToRgb");
      __name(rgbToHex, "rgbToHex");
      __name(calculateContrastRatio, "calculateContrastRatio");
      __name(lerpSmooth, "lerpSmooth");
      __name(bpmToInterval, "bpmToInterval");
      __name(intervalToBpm, "intervalToBpm");
      __name(bpmToAnimationFrameRate, "bpmToAnimationFrameRate");
      __name(isOnBeat, "isOnBeat");
      __name(getBeatPhase, "getBeatPhase");
      __name(getNextBeatTime, "getNextBeatTime");
      __name(easeBeatAnimation, "easeBeatAnimation");
      __name(calculateRhythmPhase, "calculateRhythmPhase");
      __name(calculateBreathingScale, "calculateBreathingScale");
      __name(calculateNavigationScale, "calculateNavigationScale");
      __name(rgbToOklab, "rgbToOklab");
      __name(oklabToRgb, "oklabToRgb");
      __name(processOklabColor, "processOklabColor");
      __name(calculateOklabDerivedProperties, "calculateOklabDerivedProperties");
      __name(generateHarmonicOklabColors, "generateHarmonicOklabColors");
      __name(lerp, "lerp");
      __name(colorDifference, "colorDifference");
      _HealthMonitor = class _HealthMonitor {
        registerSystem(name, instance2) {
        }
        updateSystemMetrics(name, metrics) {
        }
      };
      __name(_HealthMonitor, "HealthMonitor");
      HealthMonitor = _HealthMonitor;
      healthMonitorInstance = new HealthMonitor();
      __name(getHealthMonitor, "getHealthMonitor");
      __name(findRequiredLuminance, "findRequiredLuminance");
      __name(sleep, "sleep");
      __name(adjustColor, "adjustColor");
      __name(getCanonicalAccent, "getCanonicalAccent");
    }
  });

  // src-js/utils/animation/visualPerformance.ts
  function selectPerformanceProfile(quality, performanceProfiles, opts = {}) {
    const { trace } = opts;
    if (!performanceProfiles || typeof performanceProfiles !== "object") {
      trace?.(
        "[visualPerformance] No performanceProfiles provided \u2013 skipping selection"
      );
      return null;
    }
    let selected = performanceProfiles[quality];
    if (!selected) {
      trace?.(
        `[visualPerformance] Profile '${quality}' not found, falling back to 'balanced'`
      );
      selected = performanceProfiles["balanced"];
    }
    if (!selected) {
      const firstKey = Object.keys(
        performanceProfiles
      )[0];
      selected = performanceProfiles[firstKey];
      trace?.(
        `[visualPerformance] Using first available profile '${firstKey}' as fallback`
      );
    }
    return selected;
  }
  var init_visualPerformance = __esm({
    "src-js/utils/animation/visualPerformance.ts"() {
      "use strict";
      __name(selectPerformanceProfile, "selectPerformanceProfile");
    }
  });

  // src-js/visual/base/BaseVisualSystem.ts
  var _BaseVisualSystem, BaseVisualSystem;
  var init_BaseVisualSystem = __esm({
    "src-js/visual/base/BaseVisualSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_VisualCanvasFactory();
      init_Year3000Utilities();
      init_visualPerformance();
      _BaseVisualSystem = class _BaseVisualSystem {
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, performanceMonitor, musicSyncService, settingsManager) {
          this._initializationStartTime = null;
          // GPU-accelerated canvas support
          this.canvasCapabilities = null;
          this.activeCanvasResults = /* @__PURE__ */ new Map();
          this.config = config;
          this.utils = utils;
          this.performanceMonitor = performanceMonitor;
          this.musicSyncService = musicSyncService;
          this.settingsManager = settingsManager;
          this.systemName = this.constructor.name;
          this.initialized = false;
          this.isActive = false;
          this.currentPerformanceProfile = {};
          this.metrics = {
            initializationTime: 0,
            updates: 0,
            errors: 0
          };
          this._resizeHandler = null;
          this.boundHandleSettingsChange = this.handleSettingsChange.bind(this);
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Constructor`);
          }
        }
        // Replace the current skeletal `initialize` method with this complete, multi-phase version.
        async initialize() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing...`);
            if (this.performanceMonitor) {
              this._initializationStartTime = this.performanceMonitor.startTiming(
                `initialize_${this.systemName}`
              );
            }
          }
          if (this.settingsManager) {
            document.addEventListener(
              "year3000SystemSettingsChanged",
              this.boundHandleSettingsChange
            );
            try {
              const detectorInstance = globalThis.year3000System?.deviceCapabilityDetector;
              let quality = "balanced";
              if (detectorInstance?.isInitialized) {
                quality = detectorInstance.recommendPerformanceQuality();
              }
              this.performanceMonitor?.emitTrace?.(
                `[${this.systemName}] Auto-selected performance quality '${quality}' based on device capability.`
              );
              this._applyPerformanceProfile(quality);
            } catch (e) {
              this.performanceMonitor?.emitTrace?.(
                `[${this.systemName}] Device capability detection failed; defaulting to 'balanced'.`,
                e
              );
              this._applyPerformanceProfile("balanced");
            }
          }
          await this._performSystemSpecificInitialization();
          this.initialized = true;
          this.isActive = true;
          if (this.musicSyncService) {
            if (this._validateDependenciesForSubscription()) {
              this.musicSyncService.subscribe(this, this.systemName);
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Subscribed to MusicSyncService.`);
              }
            } else {
              console.warn(
                `[${this.systemName}] Dependency validation failed; subscription skipped.`
              );
            }
          }
          if (this.config.enableDebug && this._initializationStartTime !== null && this.performanceMonitor) {
            this.performanceMonitor.endTiming(
              `initialize_${this.systemName}`,
              this._initializationStartTime
            );
            console.log(`[${this.systemName}] Initialization complete.`);
          }
        }
        // Add new virtual methods for subclass extension.
        // These provide safe hooks for custom initialization logic.
        async _performSystemSpecificInitialization() {
          this.canvasCapabilities = detectRenderingCapabilities();
          if (this.canvasCapabilities) {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Canvas capabilities detected: WebGL2=${this.canvasCapabilities.webgl2}, Recommended=${this.canvasCapabilities.recommendedType}`
            );
          }
        }
        _validateDependenciesForSubscription() {
          if (typeof this.updateFromMusicAnalysis !== "function") {
            console.error(
              `[${this.systemName}] Missing updateFromMusicAnalysis method.`
            );
            return false;
          }
          if (!this.initialized) {
            console.warn(`[${this.systemName}] System not initialized.`);
            return false;
          }
          return this._performAdditionalDependencyValidation();
        }
        _performAdditionalDependencyValidation() {
          return true;
        }
        // Replace the current skeletal `destroy` method with this complete version for proper cleanup.
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying...`);
          }
          try {
            this.initialized = false;
            this.isActive = false;
            if (this.musicSyncService) {
              this.musicSyncService.unsubscribe(this.systemName);
            }
            if (this.settingsManager && this.boundHandleSettingsChange) {
              document.removeEventListener(
                "year3000SystemSettingsChanged",
                this.boundHandleSettingsChange
              );
            }
            if (this._resizeHandler) {
              window.removeEventListener("resize", this._resizeHandler);
              this._resizeHandler = null;
            }
            this._performSystemSpecificCleanup();
          } catch (error) {
            console.error(`[${this.systemName}] Error during destruction:`, error);
            this.metrics.errors++;
          }
        }
        // Add the virtual cleanup hook for subclasses.
        _performSystemSpecificCleanup() {
          for (const [id, canvasResult] of this.activeCanvasResults) {
            const canvas = canvasResult.canvas;
            if (canvas.parentNode) {
              canvas.parentNode.removeChild(canvas);
            }
            if (this.config.enableDebug) {
              console.log(
                `[${this.systemName}] Cleaned up canvas: ${id} (type: ${canvasResult.type})`
              );
            }
          }
          this.activeCanvasResults.clear();
        }
        updateFromMusicAnalysis(processedMusicData, ...args) {
        }
        /**
         * Unified animation hook called by MasterAnimationCoordinator.
         * Subclasses can override this method or implement updateAnimation for legacy support.
         *
         * @param deltaMs - Time in milliseconds since the last frame for this system
         */
        onAnimate(deltaMs) {
          if (typeof this.updateAnimation === "function") {
            this.updateAnimation(performance.now(), deltaMs);
          }
        }
        updateModeConfiguration(modeConfig) {
        }
        /**
         * Base implementation of the settings-change hook. It is intentionally empty
         * now that the legacy `sn-performanceQuality` key has been removed. Subclasses
         * should override this method if they need to respond to other settings keys
         * and are still encouraged to call `super.handleSettingsChange(event)`.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        handleSettingsChange(event) {
        }
        _applyPerformanceProfile(quality) {
          if (!this.config?.performanceProfiles) {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Performance profiles not found in config.`
            );
            return;
          }
          const profile = selectPerformanceProfile(
            quality,
            this.config.performanceProfiles,
            {
              trace: /* @__PURE__ */ __name((msg) => this.performanceMonitor?.emitTrace(msg), "trace")
            }
          );
          if (profile) {
            this.currentPerformanceProfile = profile;
            this.performanceMonitor?.emitTrace?.(
              `[BaseVisualSystem (${this.systemName})] Applied performance profile '${quality}'`,
              profile
            );
          } else {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Performance profile '${quality}' not found.`
            );
          }
        }
        getCosmicState() {
          if (typeof document === "undefined") return {};
          const root = document.documentElement;
          const style = getComputedStyle(root);
          return {
            energy: parseFloat(style.getPropertyValue("--sn-kinetic-energy")) || 0.5,
            valence: parseFloat(style.getPropertyValue("--sn-kinetic-valence")) || 0.5,
            bpm: parseFloat(style.getPropertyValue("--sn-kinetic-bpm")) || 120,
            tempoMultiplier: parseFloat(style.getPropertyValue("--sn-kinetic-tempo-multiplier")) || 1,
            beatPhase: parseFloat(style.getPropertyValue("--sn-kinetic-beat-phase")) || 0,
            beatPulse: parseFloat(style.getPropertyValue("--sn-kinetic-beat-pulse")) || 0
          };
        }
        /**
         * Create GPU-accelerated optimized canvas with kinetic styling.
         * This method prioritizes WebGL2 > 2D Canvas based on device capabilities.
         */
        async _createOptimizedKineticCanvas(id, zIndex = 5, blendMode = "screen", kineticMode = "pulse") {
          const existing = document.getElementById(id);
          if (existing) {
            existing.remove();
          }
          let preferredType = "2d";
          if (this.canvasCapabilities && this.currentPerformanceProfile) {
            const quality = this.currentPerformanceProfile.quality || "balanced";
            if (quality !== "low" && this.canvasCapabilities.webgl2) {
              preferredType = "webgl2";
            }
          }
          const canvasResult = await createOptimizedCanvas({
            id,
            width: window.innerWidth,
            height: window.innerHeight,
            alpha: true,
            antialias: true,
            preferredType
          });
          const canvas = canvasResult.canvas;
          canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: ${zIndex};
      pointer-events: none;
      mix-blend-mode: ${blendMode};
    `;
          canvas.classList.add("year3000-kinetic-canvas");
          canvas.dataset.kineticMode = kineticMode;
          canvas.dataset.systemName = this.systemName;
          canvas.dataset.canvasType = canvasResult.type;
          const kineticStyles = this._getKineticStyles(kineticMode);
          Object.assign(canvas.style, kineticStyles);
          document.body.appendChild(canvas);
          this.activeCanvasResults.set(id, canvasResult);
          this._resizeHandler = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (typeof this.handleResize === "function") {
              this.handleResize();
            }
          };
          window.addEventListener("resize", this._resizeHandler);
          this._resizeHandler();
          if (this.config.enableDebug) {
            console.log(
              `[BaseVisualSystem (${this.systemName})] Created optimized kinetic canvas: ${canvasResult.type} (mode: ${kineticMode})`
            );
          }
          return canvasResult;
        }
        /**
         * Get current canvas rendering capabilities.
         */
        getCanvasCapabilities() {
          return this.canvasCapabilities;
        }
        /**
         * Check if GPU acceleration is available and active.
         */
        hasGPUAcceleration() {
          return this.canvasCapabilities?.webgl2 || false;
        }
        _createKineticCanvas(id, zIndex = 5, blendMode = "screen", kineticMode = "pulse") {
          const canvas = this._createCanvasElement(id, zIndex, blendMode);
          canvas.classList.add("year3000-kinetic-canvas");
          canvas.dataset.kineticMode = kineticMode;
          canvas.dataset.systemName = this.systemName;
          const kineticStyles = this._getKineticStyles(kineticMode);
          Object.assign(canvas.style, kineticStyles);
          if (this.config.enableDebug) {
            console.log(
              `[BaseVisualSystem (${this.systemName})] Created kinetic canvas with mode: ${kineticMode}`
            );
          }
          return canvas;
        }
        _getKineticStyles(kineticMode) {
          const baseStyles = {
            transition: "all 150ms cubic-bezier(0.25, 0.46, 0.45, 0.94)"
          };
          switch (kineticMode) {
            case "pulse":
              return {
                ...baseStyles,
                animation: "year3000-pulse calc(var(--sn-kinetic-tempo-multiplier, 1) * 1s) ease-in-out infinite"
              };
            case "breathe":
              return {
                ...baseStyles,
                animation: "year3000-breathe calc(var(--sn-kinetic-tempo-multiplier, 1) * 4s) ease-in-out infinite"
              };
            case "flow":
              return {
                ...baseStyles,
                animation: "year3000-flow calc(var(--sn-kinetic-tempo-multiplier, 1) * 8s) linear infinite"
              };
            default:
              return baseStyles;
          }
        }
        _createCanvasElement(id, zIndex, blendMode) {
          const existing = document.getElementById(id);
          if (existing) {
            existing.remove();
          }
          const canvas = document.createElement("canvas");
          canvas.id = id;
          canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: ${zIndex};
      pointer-events: none;
      mix-blend-mode: ${blendMode};
    `;
          document.body.appendChild(canvas);
          this._resizeHandler = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (typeof this.handleResize === "function") {
              this.handleResize();
            }
          };
          window.addEventListener("resize", this._resizeHandler);
          this._resizeHandler();
          return canvas;
        }
        /**
         * Apply a fully-resolved PerformanceProfile coming from Year3000System.
         * Sub-systems may override this to adjust internal parameters (particle
         * counts, throttle values, etc.). The base implementation simply stores the
         * profile so dependants can query `currentPerformanceProfile`.
         */
        applyPerformanceSettings(profile) {
          this.currentPerformanceProfile = profile;
          if (profile.quality && typeof this._applyPerformanceProfile === "function") {
            this._applyPerformanceProfile?.(profile.quality);
          }
          if (this.config.enableDebug) {
            this.performanceMonitor?.emitTrace?.(
              `[BaseVisualSystem (${this.systemName})] Performance settings applied`,
              profile
            );
          }
        }
        /**
         * Centralised settings responder invoked by Year3000System.  The base
         * implementation simply adapts the parameters into a synthetic CustomEvent
         * so that legacy subclasses overriding `handleSettingsChange` continue to
         * work without modification.  Newer systems can override this directly for
         * efficiency.
         */
        applyUpdatedSettings(key, value) {
          const evt = new CustomEvent("year3000SystemSettingsChanged", {
            detail: { key, value }
          });
          try {
            this.handleSettingsChange(evt);
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn(
                `[BaseVisualSystem] ${this.systemName} applyUpdatedSettings error`,
                err
              );
            }
          }
        }
        // ---------------------------------------------------------------------------
        // SETTINGS-AWARE REPAINT CONTRACT
        // ---------------------------------------------------------------------------
        /**
         * Default no-op implementation.  Subclasses that cache colours, shaders, or
         * other theme-dependent resources should override and perform a lightweight
         * refresh.
         */
        forceRepaint(_reason = "generic") {
        }
      };
      __name(_BaseVisualSystem, "BaseVisualSystem");
      BaseVisualSystem = _BaseVisualSystem;
    }
  });

  // src-js/visual/backgrounds/LightweightParticleSystem.ts
  var _LightweightParticleSystem, LightweightParticleSystem;
  var init_LightweightParticleSystem = __esm({
    "src-js/visual/backgrounds/LightweightParticleSystem.ts"() {
      "use strict";
      init_BaseVisualSystem();
      init_Year3000Utilities();
      _LightweightParticleSystem = class _LightweightParticleSystem extends BaseVisualSystem {
        constructor(config, utils, performanceMonitor, musicSyncService, settingsManager, year3000System2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager);
          this.canvas = null;
          this.ctx = null;
          this.particlePool = [];
          this.lastSpawnTime = 0;
          this.spawnCooldown = 80;
          this.year3000System = year3000System2;
          this.maxParticles = this.currentPerformanceProfile?.maxParticles || 75;
        }
        async initialize() {
          await super.initialize();
          this.createCanvas();
          this.initializeParticlePool();
          this._updateParticleSettingsFromProfile();
          this.startRenderLoop();
        }
        _updateParticleSettingsFromProfile() {
          this.maxParticles = this.currentPerformanceProfile?.maxParticles || 75;
        }
        createCanvas() {
          this.canvas = this._createCanvasElement("sn-particle-canvas", 3, "screen");
          this.ctx = this.canvas.getContext("2d");
        }
        initializeParticlePool() {
          this.particlePool = [];
          for (let i = 0; i < this.maxParticles * 2; i++) {
            this.particlePool.push({ active: false });
          }
        }
        startRenderLoop() {
          if (this.config.enableDebug) {
            console.log(
              `[${this.systemName}] Render loop setup complete - using unified onAnimate hook`
            );
          }
        }
        spawnParticle(energy, intensity, speedFactor, mood) {
          const particle = this.particlePool.find((p) => !p.active);
          if (!particle || !this.canvas) return;
          const rootStyle = window.getComputedStyle(getRootStyle());
          const accentRgbStr = rootStyle.getPropertyValue("--sn-accent-rgb").trim() || rootStyle.getPropertyValue("--sn-gradient-accent-rgb").trim() || "202,158,230";
          const primaryRgbStr = rootStyle.getPropertyValue("--sn-gradient-primary-rgb").trim() || accentRgbStr;
          particle.active = true;
          particle.currentX = Math.random() * this.canvas.width;
          particle.currentY = this.canvas.height + Math.random() * 30 + 20;
          particle.vx = (Math.random() - 0.5) * 3 * (speedFactor || 1);
          particle.vy = -(1.5 + Math.random() * 2.5 + energy * 3) * (speedFactor || 1);
          particle.maxLife = 2500 + Math.random() * 3500 * intensity;
          particle.life = particle.maxLife;
          particle.baseSize = 1.5 + Math.random() * 2.5 + intensity * 2.5;
          particle.currentSize = 0;
          particle.targetSize = particle.baseSize;
          particle.baseOpacity = 0.4 + Math.random() * 0.5;
          particle.currentOpacity = 0;
          particle.targetOpacity = particle.baseOpacity;
          const baseColor = mood && mood.includes("happy") || Math.random() > 0.6 ? primaryRgbStr : accentRgbStr;
          particle.color = `rgba(${baseColor},1)`;
          particle.currentRotation = Math.random() * Math.PI * 2;
          particle.vr = (Math.random() - 0.5) * 0.08 * (speedFactor || 1);
        }
        /**
         * Per-frame callback from the MasterAnimationCoordinator. Delegates to the
         * established `updateAnimation` pathway so that particle rendering continues
         * to obey the existing logic – including potential fallback loops created
         * earlier in the system's lifecycle.
         *
         * @param deltaMs   Milliseconds elapsed since the previous frame.
         */
        onAnimate(deltaMs) {
          if (!this.initialized) return;
          this.updateAnimation(performance.now(), deltaMs);
        }
        updateAnimation(timestamp, deltaTime) {
          if (!this.ctx || !this.canvas) return;
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          for (const p of this.particlePool) {
            const particle = p;
            if (!particle.active) continue;
            particle.life -= deltaTime;
            if (particle.life <= 0) {
              particle.active = false;
              continue;
            }
            particle.currentX += particle.vx * (deltaTime / 16);
            particle.currentY += particle.vy * (deltaTime / 16);
            particle.currentRotation += particle.vr * (deltaTime / 16);
            const lifeRatio = particle.life / particle.maxLife;
            const fadeInDuration = 0.2;
            const fadeOutDuration = 0.5;
            let opacityFactor = 1;
            if (lifeRatio > 1 - fadeInDuration) {
              opacityFactor = (1 - lifeRatio) / fadeInDuration;
            } else if (lifeRatio < fadeOutDuration) {
              opacityFactor = lifeRatio / fadeOutDuration;
            }
            particle.currentOpacity = particle.targetOpacity * opacityFactor;
            particle.currentSize = particle.targetSize * opacityFactor;
            this.ctx.save();
            this.ctx.translate(particle.currentX, particle.currentY);
            this.ctx.rotate(particle.currentRotation);
            this.ctx.fillStyle = particle.color.replace(
              "1)",
              `${particle.currentOpacity})`
            );
            this.ctx.beginPath();
            this.ctx.arc(0, 0, particle.currentSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
          }
        }
        // --------------------------------------------------------------------
        // Central settings responder – adjust particle counts or reset pools
        // --------------------------------------------------------------------
        applyUpdatedSettings(key, value) {
          if (key === "sn-star-density") {
            const mapping = {
              disabled: 0,
              minimal: 40,
              balanced: 75,
              intense: 120
            };
            const desired = mapping[value] ?? this.maxParticles;
            if (desired !== this.maxParticles) {
              this.maxParticles = desired;
              this.initializeParticlePool();
            }
          }
        }
      };
      __name(_LightweightParticleSystem, "LightweightParticleSystem");
      LightweightParticleSystem = _LightweightParticleSystem;
    }
  });

  // src-js/core/performance/PerformanceAnalyzer.ts
  var _FPSCounter, FPSCounter, _PerformanceAnalyzer, PerformanceAnalyzer;
  var init_PerformanceAnalyzer = __esm({
    "src-js/core/performance/PerformanceAnalyzer.ts"() {
      "use strict";
      _FPSCounter = class _FPSCounter {
        constructor() {
          this.frames = 0;
          this.lastTime = performance.now();
          this.rafHandle = null;
          this.currentFPS = 0;
          this.averageFPS = 0;
          this.minFPS = Infinity;
          this.maxFPS = 0;
          this.history = [];
          this.loop = /* @__PURE__ */ __name(() => {
            this.frames++;
            const time = performance.now();
            if (time >= this.lastTime + 1e3) {
              this.currentFPS = this.frames;
              this.history.push(this.currentFPS);
              if (this.history.length > 30) {
                this.history.shift();
              }
              this.averageFPS = Math.round(
                this.history.reduce((a, b) => a + b, 0) / this.history.length
              );
              this.minFPS = Math.min(this.minFPS, this.currentFPS);
              this.maxFPS = Math.max(this.maxFPS, this.currentFPS);
              this.frames = 0;
              this.lastTime = time;
            }
            this.rafHandle = requestAnimationFrame(this.loop);
          }, "loop");
          this.stop = /* @__PURE__ */ __name(() => {
            if (this.rafHandle) {
              cancelAnimationFrame(this.rafHandle);
            }
          }, "stop");
          this.loop();
        }
        /** Returns copy of the last recorded FPS samples (1-sec granularity). */
        getHistory() {
          return [...this.history];
        }
      };
      __name(_FPSCounter, "FPSCounter");
      FPSCounter = _FPSCounter;
      _PerformanceAnalyzer = class _PerformanceAnalyzer {
        constructor(config = {}) {
          this.initialized = false;
          this.performanceHistory = [];
          this.metricsBuffer = /* @__PURE__ */ new Map();
          this.isMonitoring = false;
          this.monitoringTimer = null;
          this._fpsCounter = null;
          this.timedOperations = /* @__PURE__ */ new Map();
          this._buckets = /* @__PURE__ */ new Map();
          // -------------------------------------------------------------------
          // Performance budgets and monitoring -------------------------------
          // -------------------------------------------------------------------
          // Performance budgets (in milliseconds)
          this.performanceBudgets = {
            animationFrame: 16.67,
            // 60 FPS target
            cssVariableUpdate: 2,
            // CSS variable batching
            domObservation: 5,
            // DOM mutation handling
            audioAnalysis: 10,
            // Audio processing
            visualEffects: 8,
            // Visual system updates
            userInteraction: 100
            // User interaction response
          };
          // Budget tracking
          this.budgetViolations = /* @__PURE__ */ new Map();
          this.budgetHistory = /* @__PURE__ */ new Map();
          // -------------------------------------------------------------------
          // Simple metric recorder for external systems -----------------------
          // -------------------------------------------------------------------
          /**
           * Lightweight metric recording helper used by visual systems.
           * Currently stores last value per metric name; can be expanded later.
           */
          this._externalMetrics = /* @__PURE__ */ new Map();
          this.config = {
            enableDebug: config.enableDebug || false,
            monitoringInterval: config.monitoringInterval || 5e3,
            retentionPeriod: config.retentionPeriod || 3e5,
            ...config
          };
          try {
            this._fpsCounter = new FPSCounter();
            this.initialized = true;
            if (this.config.enableDebug) {
              console.log("\u{1F4CA} [PerformanceAnalyzer] Initialized successfully.");
            }
          } catch (error) {
            this.initialized = false;
            console.error(
              "CRITICAL: PerformanceAnalyzer failed to initialize.",
              error
            );
          }
          this._buckets = /* @__PURE__ */ new Map();
        }
        recordMetric(name, value) {
          this._externalMetrics.set(name, value);
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] metric '${name}' = ${value}`);
          }
        }
        startMonitoring() {
          if (this.isMonitoring) return;
          this.isMonitoring = true;
          this.monitoringTimer = setInterval(() => {
            this._collectPerformanceMetrics();
          }, this.config.monitoringInterval);
          if (this.config.enableDebug) {
            console.log("\u{1F4CA} [PerformanceAnalyzer] Monitoring started");
          }
        }
        stopMonitoring() {
          if (!this.isMonitoring) return;
          this.isMonitoring = false;
          if (this.monitoringTimer) {
            clearInterval(this.monitoringTimer);
            this.monitoringTimer = null;
          }
          if (this.config.enableDebug) {
            console.log("\u{1F4CA} [PerformanceAnalyzer] Monitoring stopped");
          }
        }
        _collectPerformanceMetrics() {
          const timestamp = performance.now();
          const metrics = {
            timestamp,
            memory: this._getMemoryMetrics(),
            timing: this._getTimingMetrics(),
            fps: this._getFPSMetrics(),
            dom: this._getDOMMetrics(),
            network: this._getNetworkMetrics()
          };
          this.performanceHistory.push(metrics);
          const cutoff = timestamp - this.config.retentionPeriod;
          this.performanceHistory = this.performanceHistory.filter(
            (m) => m.timestamp > cutoff
          );
          this.metricsBuffer.set(timestamp, metrics);
          for (const key of this.metricsBuffer.keys()) {
            if (key < cutoff) {
              this.metricsBuffer.delete(key);
            }
          }
        }
        _getMemoryMetrics() {
          const memoryInfo = performance.memory || {};
          return {
            used: memoryInfo.usedJSHeapSize || 0,
            total: memoryInfo.totalJSHeapSize || 0,
            limit: memoryInfo.jsHeapSizeLimit || 0,
            utilization: memoryInfo.totalJSHeapSize ? memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize * 100 : 0,
            available: memoryInfo.jsHeapSizeLimit ? memoryInfo.jsHeapSizeLimit - memoryInfo.usedJSHeapSize : 0
          };
        }
        _getTimingMetrics() {
          const navigation = performance.getEntriesByType(
            "navigation"
          )[0];
          return {
            domContentLoaded: navigation?.domContentLoadedEventEnd || 0,
            loadComplete: navigation?.loadEventEnd || 0,
            firstPaint: this._getFirstPaint(),
            firstContentfulPaint: this._getFirstContentfulPaint(),
            largestContentfulPaint: this._getLargestContentfulPaint()
          };
        }
        _getFPSMetrics() {
          if (this._fpsCounter) {
            return {
              current: this._fpsCounter.currentFPS,
              average: this._fpsCounter.averageFPS,
              min: this._fpsCounter.minFPS,
              max: this._fpsCounter.maxFPS,
              isEstimate: false
            };
          }
          return { current: 60, average: 60, min: 60, max: 60, isEstimate: true };
        }
        _getDOMMetrics() {
          return {
            elements: document.querySelectorAll("*").length,
            styleSheets: document.styleSheets.length,
            images: document.images.length,
            scripts: document.scripts.length,
            links: document.links.length
          };
        }
        _getNetworkMetrics() {
          const connection = navigator.connection || {};
          return {
            effectiveType: connection.effectiveType || "unknown",
            downlink: connection.downlink || 0,
            rtt: connection.rtt || 0,
            saveData: connection.saveData || false
          };
        }
        _getFirstPaint() {
          const firstPaint = performance.getEntriesByType("paint").find((entry) => entry.name === "first-paint");
          return firstPaint ? firstPaint.startTime : 0;
        }
        _getFirstContentfulPaint() {
          const fcp = performance.getEntriesByType("paint").find((entry) => entry.name === "first-contentful-paint");
          return fcp ? fcp.startTime : 0;
        }
        _getLargestContentfulPaint() {
          const lcpEntries = performance.getEntriesByType("largest-contentful-paint");
          const lastEntry = lcpEntries[lcpEntries.length - 1];
          return lastEntry ? lastEntry.startTime : 0;
        }
        calculateHealthScore() {
          const latestMetrics = this.performanceHistory[this.performanceHistory.length - 1];
          if (!latestMetrics) return 100;
          let score = 100;
          if (latestMetrics.memory.utilization > 80) score -= 20;
          if (latestMetrics.fps.average < 30) score -= 25;
          if (latestMetrics.timing.largestContentfulPaint > 2500) score -= 15;
          return Math.max(0, score);
        }
        getHealthLevel(score) {
          if (score > 80) return "stable";
          if (score > 50) return "warning";
          return "critical";
        }
        // --- Start of methods migrated from PerformanceMonitor ---
        startTiming(operation) {
          return performance.now();
        }
        endTiming(operation, startTime) {
          const duration = performance.now() - startTime;
          if (!this.timedOperations.has(operation)) {
            this.timedOperations.set(operation, []);
          }
          const timings = this.timedOperations.get(operation);
          timings.push(duration);
          if (timings.length > 50) {
            timings.shift();
          }
        }
        getAverageTime(operation) {
          const timings = this.timedOperations.get(operation);
          if (!timings || timings.length === 0) {
            return 0;
          }
          return timings.reduce((a, b) => a + b, 0) / timings.length;
        }
        detectMemoryPressure() {
          const memory = performance.memory;
          if (memory) {
            const used = memory.usedJSHeapSize;
            const total = memory.totalJSHeapSize;
            return used / total > 0.8 ? "high" : "normal";
          }
          return "unknown";
        }
        shouldReduceQuality() {
          const score = this.calculateHealthScore();
          return score < 60;
        }
        /**
         * Emit a trace message when debug mode is enabled.  This method provides a
         * single, centralized entry-point so callers can avoid sprinkling
         * `console.log` statements around.  In the future we might widen this to
         * support different channels (performance panel, remote telemetry, etc.).
         */
        emitTrace(message, data) {
          if (!this.config.enableDebug) return;
          if (data !== void 0) {
            console.log(`\u{1F4CA} [PerformanceAnalyzer] ${message}`, data);
          } else {
            console.log(`\u{1F4CA} [PerformanceAnalyzer] ${message}`);
          }
        }
        /**
         * Throttle helper – returns true when the caller is allowed to perform an update
         * for the supplied bucket. Subsequent calls within `minIntervalMs` will return
         * false until the interval has elapsed. Useful for cheaply rate-limiting CSS
         * variable flushes, expensive observers, etc.
         *
         * @param bucket        Arbitrary string identifying the operation family
         * @param minIntervalMs Minimum time between allowed updates (default 16 ms)
         */
        shouldUpdate(bucket, minIntervalMs = 16) {
          const now = performance.now();
          const nextAllowed = this._buckets.get(bucket) ?? 0;
          if (now >= nextAllowed) {
            this._buckets.set(bucket, now + minIntervalMs);
            return true;
          }
          return false;
        }
        // --- Performance Budget Methods ---
        /**
         * Check if an operation is within performance budget
         */
        isWithinBudget(operation, duration) {
          const budget = this.performanceBudgets[operation];
          if (!budget) return true;
          const withinBudget = duration <= budget;
          if (!withinBudget) {
            this.budgetViolations.set(operation, (this.budgetViolations.get(operation) || 0) + 1);
            if (this.config.enableDebug) {
              console.warn(`\u{1F4CA} [PerformanceAnalyzer] Budget violation: ${operation} took ${duration.toFixed(2)}ms (budget: ${budget}ms)`);
            }
          }
          const history = this.budgetHistory.get(operation) || [];
          history.push(duration);
          if (history.length > 100) history.shift();
          this.budgetHistory.set(operation, history);
          return withinBudget;
        }
        /**
         * Time an operation and check against budget
         */
        timeOperation(operation, fn) {
          const start = performance.now();
          const result = fn();
          const duration = performance.now() - start;
          this.isWithinBudget(operation, duration);
          return result;
        }
        /**
         * Time an async operation and check against budget
         */
        async timeOperationAsync(operation, fn) {
          const start = performance.now();
          const result = await fn();
          const duration = performance.now() - start;
          this.isWithinBudget(operation, duration);
          return result;
        }
        /**
         * Get performance budget violations
         */
        getBudgetViolations() {
          return new Map(this.budgetViolations);
        }
        /**
         * Get performance budget statistics
         */
        getBudgetStats() {
          const stats = {};
          for (const [operation, budget] of Object.entries(this.performanceBudgets)) {
            const violations = this.budgetViolations.get(operation) || 0;
            const history = this.budgetHistory.get(operation) || [];
            const averageTime = history.length > 0 ? history.reduce((a, b) => a + b, 0) / history.length : 0;
            const maxTime = history.length > 0 ? Math.max(...history) : 0;
            stats[operation] = {
              budget,
              violations,
              averageTime,
              maxTime
            };
          }
          return stats;
        }
        /**
         * Update performance budget for an operation
         */
        updateBudget(operation, budgetMs) {
          this.performanceBudgets[operation] = budgetMs;
          if (this.config.enableDebug) {
            console.log(`\u{1F4CA} [PerformanceAnalyzer] Updated budget for ${operation}: ${budgetMs}ms`);
          }
        }
        /**
         * Clear budget violation history
         */
        clearBudgetHistory() {
          this.budgetViolations.clear();
          this.budgetHistory.clear();
        }
        // --- End of migrated methods ---
        destroy() {
          this.stopMonitoring();
          if (this._fpsCounter) {
            this._fpsCounter.stop();
          }
          this.performanceHistory = [];
          this.metricsBuffer.clear();
          this.timedOperations.clear();
          if (this.config.enableDebug) {
            console.log("\u{1F4CA} [PerformanceAnalyzer] Destroyed and cleaned up.");
          }
        }
        /**
         * Lightweight, synchronous heuristic to decide whether the current device
         * should be treated as "low-end". This avoids the async overhead of
         * `DeviceCapabilityDetector` while still giving callers a fast gate for
         * performance-heavy logic.
         *
         * The heuristic intentionally stays conservative: we only mark devices as
         * low-end when *multiple* indicators point in that direction to minimise
         * false-positives on mid-tier hardware.
         */
        static isLowEndDevice() {
          if (this._isLowEndCache !== null) {
            return this._isLowEndCache;
          }
          try {
            const deviceMemory = navigator.deviceMemory ?? 4;
            const cpuCores = navigator.hardwareConcurrency ?? 4;
            const memoryFlag = deviceMemory < 4;
            const coreFlag = cpuCores <= 2;
            const connection = navigator.connection || {};
            const effectiveType = connection.effectiveType;
            const slowNetworkFlag = ["slow-2g", "2g"].includes(effectiveType ?? "");
            const isLowEnd = memoryFlag && coreFlag || memoryFlag && slowNetworkFlag;
            this._isLowEndCache = isLowEnd;
            return isLowEnd;
          } catch {
            this._isLowEndCache = false;
            return false;
          }
        }
        /**
         * Returns median FPS using the most recent N one-second samples (default 5).
         * Falls back to current FPS when insufficient samples.
         */
        getMedianFPS(sampleWindowSeconds = 5) {
          if (!this._fpsCounter) return 60;
          const hist = this._fpsCounter.getHistory?.() || [];
          const samples = hist.slice(-sampleWindowSeconds);
          if (!samples.length) return this._fpsCounter.currentFPS || 60;
          const sorted = [...samples].sort((a, b) => a - b);
          const mid = Math.floor(sorted.length / 2);
          return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        }
        /**
         * Capture a one-off 60 s (or custom) performance baseline and trigger a JSON
         * download so developers can commit the artefact under
         * `docs/perf-baselines/`.
         *
         * Example (DevTools):
         *   await year3000System.performanceAnalyzer.startBaselineCapture("Home");
         */
        async startBaselineCapture(viewName = "unknown", durationMs = 6e4) {
          if (!this.isMonitoring) {
            this.startMonitoring();
          }
          const start = Date.now();
          if (this.config.enableDebug) {
            console.log(
              `\u{1F4CA} [PerformanceAnalyzer] Baseline capture for "${viewName}" started`
            );
          }
          await new Promise((r) => setTimeout(r, durationMs));
          if (this.config.enableDebug) {
            console.log(
              `\u{1F4CA} [PerformanceAnalyzer] Baseline capture complete \u2013 ${this.performanceHistory.length} samples in ${(Date.now() - start) / 1e3}s`
            );
          }
          const artefact = {
            view: viewName,
            capturedAt: (/* @__PURE__ */ new Date()).toISOString(),
            durationMs,
            samples: this.performanceHistory
          };
          try {
            const blob = new Blob([JSON.stringify(artefact, null, 2)], {
              type: "application/json"
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${viewName}_${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}_baseline.json`;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 5e3);
          } catch (err) {
            console.warn(
              "[PerformanceAnalyzer] Unable to trigger baseline download",
              err
            );
          }
          return [...this.performanceHistory];
        }
        // --- End of static helpers ---
      };
      __name(_PerformanceAnalyzer, "PerformanceAnalyzer");
      _PerformanceAnalyzer._isLowEndCache = null;
      PerformanceAnalyzer = _PerformanceAnalyzer;
    }
  });

  // src-js/visual/backgrounds/ParticleFieldSystem.ts
  var _ParticleFieldSystem, ParticleFieldSystem;
  var init_ParticleFieldSystem = __esm({
    "src-js/visual/backgrounds/ParticleFieldSystem.ts"() {
      "use strict";
      init_PerformanceAnalyzer();
      _ParticleFieldSystem = class _ParticleFieldSystem {
        constructor(config, utils, performanceAnalyzer, musicSyncService, settingsManager, rootSystem) {
          this.config = config;
          this.utils = utils;
          this.performanceAnalyzer = performanceAnalyzer;
          this.musicSyncService = musicSyncService;
          this.settingsManager = settingsManager;
          this.rootSystem = rootSystem;
          this.initialized = false;
          this._canvas = null;
          this._ctx = null;
          this._particles = [];
          this._animationFrame = null;
          /** Whether we spawned our own requestAnimationFrame loop (fallback for standalone usage). */
          this._ownsRAF = false;
          /** Cached performance flag so we don\'t call shouldReduceQuality() every particle. */
          this._lowQualityMode = false;
          this._pulseStrength = 0;
          // Stores the resize handler reference for proper cleanup.
          this._boundResizeHandler = null;
          this.systemName = "ParticleFieldSystem";
        }
        forceRepaint(reason) {
          throw new Error("Method not implemented.");
        }
        // ───────────────────────────── IManagedSystem ──────────────────────────────
        async initialize() {
          if (this.config.artisticMode !== "cosmic-maximum") return;
          if (window.matchMedia("(prefers-reduced-motion: reduce)").matches && this.settingsManager.get("sn-3d-effects-level") === "disabled") {
            return;
          }
          this._setupCanvas();
          const particleCount = this._getParticleCount();
          this._createParticles(particleCount);
          const hasMAC = !!(this.rootSystem && this.rootSystem.masterAnimationCoordinator);
          if (!hasMAC) {
            this._startLoop();
            this._ownsRAF = true;
          }
          this.musicSyncService.subscribe(this, "ParticleFieldSystem");
          this.initialized = true;
          if (this.rootSystem?.registerVisualSystem) {
            this.rootSystem.registerVisualSystem(this, "background");
          }
        }
        updateAnimation(_delta) {
        }
        async healthCheck() {
          return {
            healthy: this.initialized,
            ok: this.initialized,
            details: "Particle field running",
            issues: this.initialized ? [] : ["System not initialized"],
            system: "ParticleFieldSystem"
          };
        }
        destroy() {
          if (this._animationFrame) cancelAnimationFrame(this._animationFrame);
          this._ownsRAF = false;
          this.musicSyncService.unsubscribe("ParticleFieldSystem");
          if (this._canvas && this._canvas.parentElement) {
            this._canvas.parentElement.removeChild(this._canvas);
          }
          if (this._boundResizeHandler) {
            window.removeEventListener("resize", this._boundResizeHandler);
            this._boundResizeHandler = null;
          }
          this._particles = [];
          this.initialized = false;
        }
        // ───────────────────────── MusicSyncSubscriber API ─────────────────────────
        updateFromMusicAnalysis(processedData) {
          if (processedData?.beatOccurred) {
            this._pulseStrength = Math.min(1, processedData.energy || 0.5) * 3;
          }
        }
        // ───────────────────────────────── helpers ─────────────────────────────────
        _setupCanvas() {
          const canvas = document.createElement("canvas");
          canvas.id = "sn-particle-field";
          canvas.style.position = "fixed";
          canvas.style.top = "0";
          canvas.style.left = "0";
          canvas.style.width = "100%";
          canvas.style.height = "100%";
          canvas.style.pointerEvents = "none";
          canvas.style.zIndex = "-1";
          document.body.appendChild(canvas);
          this._canvas = canvas;
          this._ctx = canvas.getContext("2d");
          this._resize();
          this._boundResizeHandler = this._resize.bind(this);
          window.addEventListener("resize", this._boundResizeHandler);
        }
        _resize() {
          if (!this._canvas) return;
          const dpr = window.devicePixelRatio || 1;
          this._canvas.width = window.innerWidth * dpr;
          this._canvas.height = window.innerHeight * dpr;
          this._ctx?.scale(dpr, dpr);
        }
        _createParticles(count) {
          const w = window.innerWidth;
          const h = window.innerHeight;
          for (let i = 0; i < count; i++) {
            this._particles.push({
              x: Math.random() * w,
              y: Math.random() * h,
              baseSize: Math.random() * 1.5 + 0.5,
              pulse: 0,
              speedX: (Math.random() - 0.5) * 0.1,
              speedY: (Math.random() - 0.5) * 0.1
            });
          }
        }
        _startLoop() {
          const tick = /* @__PURE__ */ __name(() => {
            this._step();
            this._animationFrame = requestAnimationFrame(tick);
          }, "tick");
          this._animationFrame = requestAnimationFrame(tick);
        }
        _step() {
          const ctx = this._ctx;
          if (!ctx || !this._canvas) return;
          ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
          this._pulseStrength *= 0.93;
          this._lowQualityMode = this.performanceAnalyzer.shouldReduceQuality() || PerformanceAnalyzer.isLowEndDevice();
          for (const p of this._particles) {
            p.x += p.speedX;
            p.y += p.speedY;
            if (p.x < 0) p.x += window.innerWidth;
            if (p.x > window.innerWidth) p.x -= window.innerWidth;
            if (p.y < 0) p.y += window.innerHeight;
            if (p.y > window.innerHeight) p.y -= window.innerHeight;
            const size = p.baseSize + p.pulse;
            if (this._lowQualityMode) {
              ctx.fillStyle = "rgba(255,255,255,0.75)";
            } else {
              const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
              gradient.addColorStop(0, "rgba(255,255,255,0.8)");
              gradient.addColorStop(1, "rgba(255,255,255,0)");
              ctx.fillStyle = gradient;
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
            ctx.fill();
            p.pulse *= 0.9;
            if (this._pulseStrength > 0.1) {
              p.pulse += this._pulseStrength * 0.1 * Math.random();
            }
          }
        }
        // -----------------------------------------------------------------------
        // VisualSystemRegistry hook – use registry cadence when available
        // -----------------------------------------------------------------------
        onAnimate(_delta, _context) {
          if (this._ownsRAF) return;
          this._step();
        }
        onPerformanceModeChange(mode) {
        }
        // Helper to compute particle count based on performance mode
        _getParticleCount() {
          if (this.performanceAnalyzer.shouldReduceQuality() || PerformanceAnalyzer.isLowEndDevice()) {
            return 180;
          }
          return 300;
        }
      };
      __name(_ParticleFieldSystem, "ParticleFieldSystem");
      ParticleFieldSystem = _ParticleFieldSystem;
    }
  });

  // src-js/core/performance/CSSVariableBatcher.ts
  var CRITICAL_NOW_PLAYING_VARS, _CSSVariableBatcher, CSSVariableBatcher;
  var init_CSSVariableBatcher = __esm({
    "src-js/core/performance/CSSVariableBatcher.ts"() {
      "use strict";
      CRITICAL_NOW_PLAYING_VARS = /* @__PURE__ */ new Set([
        // Legacy variables (Phase 1 migration)
        "--sn-beat-pulse-intensity",
        "--sn-breathing-scale",
        "--sn-accent-hex",
        "--sn-accent-rgb",
        // New namespaced variables (Phase 2+)
        "--sn.music.beat.pulse.intensity",
        "--sn.music.breathing.scale",
        "--sn.music.rhythm.phase",
        "--sn.music.spectrum.phase",
        "--sn.color.accent.hex",
        "--sn.color.accent.rgb",
        "--sn.bg.webgl.ready",
        "--sn.bg.active-backend"
      ]);
      _CSSVariableBatcher = class _CSSVariableBatcher {
        /**
         * Get the singleton instance of CSSVariableBatcher
         * Creates a new instance if none exists
         *
         * @param config - Configuration for new instance (ignored if instance already exists)
         * @returns The singleton CSSVariableBatcher instance
         */
        static getInstance(config = {}) {
          if (!_CSSVariableBatcher.instance) {
            _CSSVariableBatcher.instance = new _CSSVariableBatcher(config);
          }
          return _CSSVariableBatcher.instance;
        }
        /**
         * Ensure all systems use the same CSSVariableBatcher instance
         * Call this method to get the shared batcher
         */
        static getSharedInstance() {
          if (!_CSSVariableBatcher.instance) {
            console.warn(
              "[CSSVariableBatcher] No instance exists, creating default instance"
            );
            _CSSVariableBatcher.instance = new _CSSVariableBatcher();
          }
          return _CSSVariableBatcher.instance;
        }
        constructor(config = {}) {
          this.config = {
            batchIntervalMs: config.batchIntervalMs ?? 0,
            // 0 = coalesced; scheduling handled via rAF/microtask
            maxBatchSize: config.maxBatchSize ?? 50,
            enableDebug: config.enableDebug ?? false,
            useCssTextFastPath: config.useCssTextFastPath ?? false,
            autoHijack: config.autoHijack ?? true,
            ...config
          };
          this._cssVariableBatcher = {
            pendingUpdates: /* @__PURE__ */ new Map(),
            rafHandle: null,
            microtaskScheduled: false,
            batchIntervalMs: this.config.batchIntervalMs,
            maxBatchSize: this.config.maxBatchSize,
            totalUpdates: 0,
            batchCount: 0,
            enabled: true
          };
          this._performanceMetrics = {
            totalBatches: 0,
            totalUpdates: 0,
            totalBatchTime: 0,
            maxBatchTime: 0,
            averageBatchSize: 0,
            overBudgetBatches: 0
          };
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [CSSVariableBatcher] Initialized");
          }
          _CSSVariableBatcher.instance = this;
          if (this.config.autoHijack) {
            this._enableGlobalHijack();
          }
        }
        queueCSSVariableUpdate(property, value, element = null) {
          if (CRITICAL_NOW_PLAYING_VARS.has(property)) {
            const styleDecl = (element || document.documentElement).style;
            if (_CSSVariableBatcher.nativeSetProperty) {
              _CSSVariableBatcher.nativeSetProperty.call(styleDecl, property, value);
            } else {
              styleDecl.setProperty(property, value);
            }
            return;
          }
          const target = element || document.documentElement;
          if (!this._cssVariableBatcher.enabled) {
            if (_CSSVariableBatcher.nativeSetProperty) {
              _CSSVariableBatcher.nativeSetProperty.call(target.style, property, value);
            } else {
              target.style.setProperty(property, value);
            }
            return;
          }
          const elementKey = element ? `element_${element.id || element.className || "unnamed"}` : "root";
          const updateKey = `${elementKey}:${property}`;
          this._cssVariableBatcher.pendingUpdates.set(updateKey, {
            element: target,
            property,
            value,
            timestamp: performance.now()
          });
          this._cssVariableBatcher.totalUpdates++;
          this._performanceMetrics.totalUpdates++;
          this._scheduleFlush();
          if (this._cssVariableBatcher.pendingUpdates.size >= this._cssVariableBatcher.maxBatchSize) {
            this.flushCSSVariableBatch();
          }
        }
        _processCSSVariableBatch() {
          if (this._cssVariableBatcher.pendingUpdates.size === 0) {
            return;
          }
          const startTime = performance.now();
          const updates = Array.from(
            this._cssVariableBatcher.pendingUpdates.values()
          );
          this._cssVariableBatcher.pendingUpdates.clear();
          if (this._cssVariableBatcher.rafHandle !== null) {
            cancelAnimationFrame(this._cssVariableBatcher.rafHandle);
            this._cssVariableBatcher.rafHandle = null;
          }
          this._cssVariableBatcher.microtaskScheduled = false;
          try {
            const updatesByElement = /* @__PURE__ */ new Map();
            for (const update of updates) {
              if (!updatesByElement.has(update.element)) {
                updatesByElement.set(update.element, []);
              }
              updatesByElement.get(update.element).push(update);
            }
            for (const [element, elementUpdates] of updatesByElement.entries()) {
              if (elementUpdates.length > 3 && this.config.useCssTextFastPath) {
                let cssText = element.style.cssText;
                for (const update of elementUpdates) {
                  const propertyPattern = new RegExp(
                    `${update.property.replace(
                      /[.*+?^${}()|[\]\\]/g,
                      "\\$&"
                    )}:[^;]*;?`,
                    "g"
                  );
                  cssText = cssText.replace(propertyPattern, "");
                  cssText += `${update.property}:${update.value};`;
                }
                element.style.cssText = cssText;
              } else {
                for (const update of elementUpdates) {
                  if (_CSSVariableBatcher.nativeSetProperty) {
                    _CSSVariableBatcher.nativeSetProperty.call(element.style, update.property, update.value);
                  } else {
                    element.style.setProperty(update.property, update.value);
                  }
                }
              }
            }
            this._cssVariableBatcher.batchCount++;
            this._performanceMetrics.totalBatches++;
            const batchTime = performance.now() - startTime;
            this._updatePerformanceMetrics(batchTime, updates.length);
            if (this.config.enableDebug && Math.random() < 0.1) {
              console.log(
                `\u{1F3A8} [CSSVariableBatcher] Processed CSS batch: ${updates.length} updates in ${batchTime.toFixed(2)}ms`
              );
            }
          } catch (error) {
            console.error(
              "[CSSVariableBatcher] Error processing CSS variable batch:",
              error
            );
            for (const update of updates) {
              try {
                if (_CSSVariableBatcher.nativeSetProperty) {
                  _CSSVariableBatcher.nativeSetProperty.call(update.element.style, update.property, update.value);
                } else {
                  update.element.style.setProperty(update.property, update.value);
                }
              } catch (e) {
                console.warn(
                  `[CSSVariableBatcher] Failed to apply CSS property ${update.property}:`,
                  e
                );
              }
            }
          }
        }
        _updatePerformanceMetrics(batchTime, batchSize) {
          this._performanceMetrics.totalBatchTime += batchTime;
          this._performanceMetrics.maxBatchTime = Math.max(
            this._performanceMetrics.maxBatchTime,
            batchTime
          );
          this._performanceMetrics.averageBatchSize = (this._performanceMetrics.averageBatchSize * (this._performanceMetrics.totalBatches - 1) + batchSize) / this._performanceMetrics.totalBatches;
          if (batchTime > 8) {
            this._performanceMetrics.overBudgetBatches++;
            if (this.config.enableDebug) {
              console.warn(
                `[CSSVariableBatcher] CSS batch took ${batchTime.toFixed(
                  2
                )}ms for ${batchSize} updates`
              );
            }
            if (batchTime > 16) {
              this.setBatchingEnabled(false);
              setTimeout(() => this.setBatchingEnabled(true), 5e3);
            }
          }
        }
        flushCSSVariableBatch() {
          if (this._cssVariableBatcher.rafHandle !== null) {
            cancelAnimationFrame(this._cssVariableBatcher.rafHandle);
            this._cssVariableBatcher.rafHandle = null;
          }
          this._cssVariableBatcher.microtaskScheduled = false;
          this._processCSSVariableBatch();
        }
        /**
         * Alias for unit tests that need to synchronously flush the pending batch.
         */
        flushNow() {
          this.flushCSSVariableBatch();
        }
        setBatchingEnabled(enabled) {
          this._cssVariableBatcher.enabled = enabled;
          if (!enabled) {
            this.flushCSSVariableBatch();
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F3A8} [CSSVariableBatcher] Batching ${enabled ? "enabled" : "disabled"}`
            );
          }
        }
        updateConfig(newConfig) {
          this.config = { ...this.config, ...newConfig };
          if (newConfig.batchIntervalMs) {
            this._cssVariableBatcher.batchIntervalMs = newConfig.batchIntervalMs;
          }
          if (newConfig.maxBatchSize) {
            this._cssVariableBatcher.maxBatchSize = newConfig.maxBatchSize;
          }
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [CSSVariableBatcher] Configuration updated:", newConfig);
          }
        }
        getPerformanceReport() {
          const averageBatchTime = this._performanceMetrics.totalBatches > 0 ? this._performanceMetrics.totalBatchTime / this._performanceMetrics.totalBatches : 0;
          const estimatedSavings = this._performanceMetrics.totalUpdates > 0 ? Math.round(
            (this._performanceMetrics.totalUpdates - this._performanceMetrics.totalBatches) / this._performanceMetrics.totalUpdates * 100
          ) : 0;
          return {
            enabled: this._cssVariableBatcher.enabled,
            pendingUpdates: this._cssVariableBatcher.pendingUpdates.size,
            totalUpdates: this._performanceMetrics.totalUpdates,
            totalBatches: this._performanceMetrics.totalBatches,
            averageBatchSize: Math.round(this._performanceMetrics.averageBatchSize * 10) / 10,
            averageBatchTime: Math.round(averageBatchTime * 100) / 100,
            maxBatchTime: Math.round(this._performanceMetrics.maxBatchTime * 100) / 100,
            overBudgetBatches: this._performanceMetrics.overBudgetBatches,
            batchInterval: this._cssVariableBatcher.batchIntervalMs,
            maxBatchSize: this._cssVariableBatcher.maxBatchSize,
            performance: {
              estimatedDomManipulationReduction: `${estimatedSavings}%`,
              efficiency: this._calculateEfficiency()
            },
            recommendations: this._generateBatchingRecommendations()
          };
        }
        _calculateEfficiency() {
          if (this._performanceMetrics.totalBatches === 0) return "fair";
          const averageBatchSize = this._performanceMetrics.averageBatchSize;
          const overBudgetRate = this._performanceMetrics.overBudgetBatches / this._performanceMetrics.totalBatches;
          if (averageBatchSize > 10 && overBudgetRate < 0.1) return "excellent";
          if (averageBatchSize > 5 && overBudgetRate < 0.2) return "good";
          if (averageBatchSize > 2) return "fair";
          return "poor";
        }
        _generateBatchingRecommendations() {
          const recommendations = [];
          if (this._performanceMetrics.averageBatchSize < 2) {
            recommendations.push({
              type: "batch_size",
              priority: "low",
              message: "Average batch size is small - consider increasing batch interval",
              action: "Increase batchIntervalMs to collect more updates per batch"
            });
          }
          if (this._performanceMetrics.overBudgetBatches > this._performanceMetrics.totalBatches * 0.2) {
            recommendations.push({
              type: "performance",
              priority: "medium",
              message: "Frequent over-budget batches detected",
              action: "Reduce maxBatchSize or optimize CSS property updates"
            });
          }
          return recommendations;
        }
        resetMetrics() {
          this._performanceMetrics = {
            totalBatches: 0,
            totalUpdates: 0,
            totalBatchTime: 0,
            maxBatchTime: 0,
            averageBatchSize: 0,
            overBudgetBatches: 0
          };
          this._cssVariableBatcher.totalUpdates = 0;
          this._cssVariableBatcher.batchCount = 0;
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [CSSVariableBatcher] Performance metrics reset");
          }
        }
        destroy() {
          this.flushCSSVariableBatch();
          if (this._cssVariableBatcher.rafHandle !== null) {
            cancelAnimationFrame(this._cssVariableBatcher.rafHandle);
          }
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [CSSVariableBatcher] Destroyed");
          }
        }
        _scheduleFlush() {
          if (this._cssVariableBatcher.rafHandle !== null || this._cssVariableBatcher.microtaskScheduled) {
            return;
          }
          const flushCallback = /* @__PURE__ */ __name(() => {
            this._cssVariableBatcher.rafHandle = null;
            this._cssVariableBatcher.microtaskScheduled = false;
            this._processCSSVariableBatch();
          }, "flushCallback");
          if (typeof document !== "undefined" && document.visibilityState === "hidden") {
            this._cssVariableBatcher.microtaskScheduled = true;
            queueMicrotask(flushCallback);
          } else if (typeof requestAnimationFrame === "function") {
            this._cssVariableBatcher.rafHandle = requestAnimationFrame(
              () => flushCallback()
            );
          } else {
            setTimeout(flushCallback, 0);
          }
        }
        /** Patch CSSStyleDeclaration.setProperty so legacy code is batched */
        _enableGlobalHijack() {
          if (_CSSVariableBatcher.hijackEnabled) return;
          const original = CSSStyleDeclaration.prototype.setProperty;
          _CSSVariableBatcher.nativeSetProperty = original;
          const batchInstance = this;
          CSSStyleDeclaration.prototype.setProperty = function(prop, value, priority) {
            if (prop && (prop.startsWith("--sn-") || prop.startsWith("--sn.")) && batchInstance) {
              batchInstance.queueCSSVariableUpdate(prop, String(value ?? ""));
            } else {
              original.call(this, prop, value, priority);
            }
          };
          _CSSVariableBatcher.hijackEnabled = true;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3A8} [CSSVariableBatcher] Global setProperty hijack enabled (--sn- and --sn. namespaces)"
            );
          }
        }
        // ========================================================================
        // DESIGN TOKEN SYSTEM INTEGRATION
        // ========================================================================
        /**
         * Add a critical variable to the fast-path list
         * Critical variables bypass batching for real-time updates
         *
         * @param variable - CSS variable name to add to fast-path
         */
        addCriticalVariable(variable) {
          CRITICAL_NOW_PLAYING_VARS.add(variable);
          if (this.config.enableDebug) {
            console.log(
              `\u{1F3A8} [CSSVariableBatcher] Added critical variable: ${variable}`
            );
          }
        }
        /**
         * Remove a variable from the critical fast-path list
         *
         * @param variable - CSS variable name to remove from fast-path
         */
        removeCriticalVariable(variable) {
          CRITICAL_NOW_PLAYING_VARS.delete(variable);
          if (this.config.enableDebug) {
            console.log(
              `\u{1F3A8} [CSSVariableBatcher] Removed critical variable: ${variable}`
            );
          }
        }
        /**
         * Check if a variable is on the critical fast-path
         *
         * @param variable - CSS variable name to check
         * @returns True if variable is critical
         */
        isCriticalVariable(variable) {
          return CRITICAL_NOW_PLAYING_VARS.has(variable);
        }
        /**
         * Get list of all critical variables
         *
         * @returns Array of critical variable names
         */
        getCriticalVariables() {
          return Array.from(CRITICAL_NOW_PLAYING_VARS);
        }
        /**
         * Convenience method for setting music synchronization variables
         * Maps to the new design token namespace
         *
         * @param metrics - Music metrics object
         */
        setMusicMetrics(metrics) {
          if (metrics.beatIntensity !== void 0) {
            this.setProperty(
              "--sn.music.beat.pulse.intensity",
              metrics.beatIntensity.toString()
            );
          }
          if (metrics.rhythmPhase !== void 0) {
            this.setProperty("--sn.music.rhythm.phase", `${metrics.rhythmPhase}deg`);
          }
          if (metrics.breathingScale !== void 0) {
            this.setProperty(
              "--sn.music.breathing.scale",
              metrics.breathingScale.toString()
            );
          }
          if (metrics.spectrumPhase !== void 0) {
            this.setProperty(
              "--sn.music.spectrum.phase",
              `${metrics.spectrumPhase}deg`
            );
          }
          if (metrics.energy !== void 0) {
            this.setProperty("--sn.music.energy.level", metrics.energy.toString());
          }
          if (metrics.valence !== void 0) {
            this.setProperty("--sn.music.valence", metrics.valence.toString());
          }
          if (metrics.bpm !== void 0) {
            this.setProperty("--sn.music.tempo.bpm", metrics.bpm.toString());
          }
        }
        /**
         * Convenience method for setting color variables
         * Maps to the new design token namespace
         *
         * @param colors - Color values object
         */
        setColorTokens(colors) {
          if (colors.accentHex) {
            this.setProperty("--sn.color.accent.hex", colors.accentHex);
          }
          if (colors.accentRgb) {
            this.setProperty("--sn.color.accent.rgb", colors.accentRgb);
          }
          if (colors.primaryRgb) {
            this.setProperty("--sn.bg.gradient.primary.rgb", colors.primaryRgb);
          }
          if (colors.secondaryRgb) {
            this.setProperty("--sn.bg.gradient.secondary.rgb", colors.secondaryRgb);
          }
          if (colors.gradientOpacity !== void 0) {
            this.setProperty(
              "--sn.bg.gradient.opacity",
              colors.gradientOpacity.toString()
            );
          }
          if (colors.gradientBlur) {
            this.setProperty("--sn.bg.gradient.blur", colors.gradientBlur);
          }
        }
        /**
         * Convenience method for setting performance-related variables
         *
         * @param perf - Performance values object
         */
        setPerformanceTokens(perf) {
          if (perf.webglReady !== void 0) {
            this.setProperty("--sn.bg.webgl.ready", perf.webglReady ? "1" : "0");
          }
          if (perf.activeBackend) {
            this.setProperty("--sn.bg.active-backend", perf.activeBackend);
          }
          if (perf.qualityLevel) {
            this.setProperty("--sn.perf.quality.level", perf.qualityLevel);
          }
          if (perf.reducedMotion !== void 0) {
            this.setProperty(
              "--sn.anim.motion.reduced",
              perf.reducedMotion ? "1" : "0"
            );
          }
          if (perf.gpuAcceleration !== void 0) {
            this.setProperty(
              "--sn.perf.gpu.acceleration.enabled",
              perf.gpuAcceleration ? "1" : "0"
            );
          }
        }
        /**
         * Force immediate flush of all pending updates
         * Useful for ensuring critical updates are applied immediately
         */
        forceFlush() {
          if (this._cssVariableBatcher.pendingUpdates.size > 0) {
            this._processCSSVariableBatch();
          }
        }
        /**
         * Get statistics about batching efficiency
         *
         * @returns Performance statistics and recommendations
         */
        getBatchingStats() {
          const overBudgetPercentage = this._performanceMetrics.totalBatches > 0 ? this._performanceMetrics.overBudgetBatches / this._performanceMetrics.totalBatches * 100 : 0;
          const recommendations = [];
          if (this._performanceMetrics.averageBatchSize < 2) {
            recommendations.push(
              "Consider reducing update frequency to improve batching efficiency"
            );
          }
          if (overBudgetPercentage > 20) {
            recommendations.push(
              "High percentage of over-budget batches - consider reducing maxBatchSize"
            );
          }
          if (CRITICAL_NOW_PLAYING_VARS.size > 10) {
            recommendations.push(
              "Many critical variables may impact performance - review fast-path usage"
            );
          }
          return {
            efficiency: this._calculateEfficiency(),
            totalBatches: this._performanceMetrics.totalBatches,
            averageBatchSize: this._performanceMetrics.averageBatchSize,
            overBudgetPercentage: Math.round(overBudgetPercentage * 10) / 10,
            criticalVariableCount: CRITICAL_NOW_PLAYING_VARS.size,
            recommendations
          };
        }
        // =====================================================================
        // Convenience API ------------------------------------------------------
        // =====================================================================
        /**
         * Direct helper mirroring CSSStyleDeclaration.setProperty semantics.
         * Internally delegates to queueCSSVariableUpdate so external call sites
         * (e.g. GradientConductor) can use a familiar imperative API while still
         * benefiting from batching.
         *
         * @param property – CSS custom property name (e.g. "--sn.color.accent.rgb")
         * @param value    – The value to assign
         * @param element  – Optional target element, defaults to <html>
         */
        setProperty(property, value, element = null) {
          this.queueCSSVariableUpdate(property, value, element);
        }
      };
      __name(_CSSVariableBatcher, "CSSVariableBatcher");
      // Singleton reference so the hijack can reach the live instance
      _CSSVariableBatcher.instance = null;
      _CSSVariableBatcher.hijackEnabled = false;
      CSSVariableBatcher = _CSSVariableBatcher;
    }
  });

  // src-js/utils/graphics/ShaderLoader.ts
  function createGradientTexture(gl, stops, width = 256) {
    try {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = 1;
      const ctx = canvas.getContext("2d");
      if (!ctx) return null;
      const gradient = ctx.createLinearGradient(0, 0, width, 0);
      stops.forEach((stop) => {
        const color = `rgba(${Math.round(stop.r * 255)}, ${Math.round(
          stop.g * 255
        )}, ${Math.round(stop.b * 255)}, ${stop.a})`;
        gradient.addColorStop(stop.position, color);
      });
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, 1);
      const texture = gl.createTexture();
      if (!texture) return null;
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      return texture;
    } catch (error) {
      Y3K?.debug?.error(
        "ShaderLoader",
        `Gradient texture creation failed: ${error}`
      );
      return null;
    }
  }
  var _ShaderLoader, ShaderLoader, DEFAULT_VERTEX_SHADER;
  var init_ShaderLoader = __esm({
    "src-js/utils/graphics/ShaderLoader.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _ShaderLoader = class _ShaderLoader {
        /**
         * Load and compile a fragment shader from source
         * @param gl WebGL2 rendering context
         * @param source GLSL fragment shader source code
         * @param cacheKey Optional cache key (defaults to hash of source)
         * @returns Compiled WebGL shader or null on failure
         */
        static loadFragment(gl, source, cacheKey) {
          const key = cacheKey || this.hashSource(source);
          const contextCache = this.getContextCache(gl);
          if (contextCache[key]) {
            return contextCache[key];
          }
          try {
            const shader = this.compileShader(gl, gl.FRAGMENT_SHADER, source);
            if (shader) {
              contextCache[key] = shader;
              Y3K?.debug?.log(
                "ShaderLoader",
                `Fragment shader compiled: ${key.substring(0, 8)}...`
              );
            }
            return shader;
          } catch (error) {
            Y3K?.debug?.error(
              "ShaderLoader",
              `Fragment shader compilation failed: ${error}`
            );
            return null;
          }
        }
        /**
         * Load and compile a vertex shader from source
         * @param gl WebGL2 rendering context
         * @param source GLSL vertex shader source code
         * @param cacheKey Optional cache key
         * @returns Compiled WebGL shader or null on failure
         */
        static loadVertex(gl, source, cacheKey) {
          const key = cacheKey || this.hashSource(source);
          const contextCache = this.getContextCache(gl);
          if (contextCache[key]) {
            return contextCache[key];
          }
          try {
            const shader = this.compileShader(gl, gl.VERTEX_SHADER, source);
            if (shader) {
              contextCache[key] = shader;
              Y3K?.debug?.log(
                "ShaderLoader",
                `Vertex shader compiled: ${key.substring(0, 8)}...`
              );
            }
            return shader;
          } catch (error) {
            Y3K?.debug?.error(
              "ShaderLoader",
              `Vertex shader compilation failed: ${error}`
            );
            return null;
          }
        }
        /**
         * Create a shader program from vertex and fragment shaders
         * @param gl WebGL2 rendering context
         * @param vertexShader Compiled vertex shader
         * @param fragmentShader Compiled fragment shader
         * @returns WebGL program or null on failure
         */
        static createProgram(gl, vertexShader, fragmentShader) {
          try {
            const program = gl.createProgram();
            if (!program) return null;
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
              const info = gl.getProgramInfoLog(program);
              gl.deleteProgram(program);
              throw new Error(`Program linking failed: ${info}`);
            }
            return program;
          } catch (error) {
            Y3K?.debug?.error("ShaderLoader", `Program creation failed: ${error}`);
            return null;
          }
        }
        /**
         * Clear shader cache for a specific WebGL context
         * @param gl WebGL2 rendering context
         */
        static clearCache(gl) {
          const contextCache = this.cache.get(gl);
          if (contextCache) {
            Object.values(contextCache).forEach((shader) => {
              gl.deleteShader(shader);
            });
            this.cache.delete(gl);
          }
        }
        /**
         * Clear all shader caches (use on theme hot-reload)
         */
        static clearAllCaches() {
          this.cache.clear();
        }
        static compileShader(gl, type, source) {
          const shader = gl.createShader(type);
          if (!shader) return null;
          gl.shaderSource(shader, source);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            const info = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error(`Shader compilation failed: ${info}`);
          }
          return shader;
        }
        static getContextCache(gl) {
          if (!this.cache.has(gl)) {
            this.cache.set(gl, {});
          }
          return this.cache.get(gl);
        }
        static hashSource(source) {
          let hash = 0;
          for (let i = 0; i < source.length; i++) {
            const char = source.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
          }
          return hash.toString(16);
        }
      };
      __name(_ShaderLoader, "ShaderLoader");
      _ShaderLoader.cache = /* @__PURE__ */ new Map();
      ShaderLoader = _ShaderLoader;
      DEFAULT_VERTEX_SHADER = `#version 300 es
precision mediump float;

in vec2 a_position;
out vec2 v_uv;

void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;
      __name(createGradientTexture, "createGradientTexture");
    }
  });

  // src-js/visual/backgrounds/WebGLGradientBackgroundSystem.ts
  var flowGradientShader, _WebGLGradientBackgroundSystem, WebGLGradientBackgroundSystem;
  var init_WebGLGradientBackgroundSystem = __esm({
    "src-js/visual/backgrounds/WebGLGradientBackgroundSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_CSSVariableBatcher();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_ShaderLoader();
      init_BaseVisualSystem();
      flowGradientShader = `#version 300 es
precision mediump float;

uniform float u_time;
uniform sampler2D u_gradientTex;
uniform vec2 u_resolution;
uniform float u_flowStrength;
uniform float u_noiseScale;

// Wave stack uniforms
uniform float u_waveY[2];
uniform float u_waveHeight[2];
uniform float u_waveOffset[2];
uniform float u_blurExp;
uniform float u_blurMax;

out vec4 fragColor;

// Simplex noise implementation
vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

  i = mod289(i);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// Octave noise for richer detail
float octaveNoise(vec2 uv, float octaves, float persistence, float scale) {
  float value = 0.0;
  float amplitude = 1.0;
  float frequency = scale;
  float maxValue = 0.0;

  for(float i = 0.0; i < octaves; i++) {
    value += snoise(uv * frequency) * amplitude;
    maxValue += amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return value / maxValue;
}

// Wave alpha calculation with smooth transitions
float wave_alpha(vec2 uv, int waveIndex) {
  float y = uv.y;
  float waveCenter = u_waveY[waveIndex];
  float waveHeight = u_waveHeight[waveIndex];

  float distance = abs(y - waveCenter);
  float alpha = 1.0 - smoothstep(0.0, waveHeight * 0.5, distance);

  return alpha;
}

// Dynamic blur calculation using power function
float calc_blur(vec2 uv) {
  vec2 center = vec2(0.5, 0.5);
  float distance = length(uv - center);

  float blur = pow(distance, u_blurExp);
  blur = clamp(blur, 0.0, u_blurMax);

  return blur;
}

// Background noise generator with time offset
float background_noise(vec2 uv, float timeOffset) {
  vec2 flowUV = uv;
  float adjustedTime = u_time + timeOffset;

  flowUV.x += adjustedTime * 0.02 * u_flowStrength;
  flowUV.y += sin(adjustedTime * 0.03 + uv.x * 3.14159) * 0.01 * u_flowStrength;

  float noise1 = octaveNoise(flowUV * u_noiseScale, 4.0, 0.5, 1.0);
  float noise2 = octaveNoise(flowUV * u_noiseScale * 2.0 + vec2(100.0), 3.0, 0.4, 1.0);

  return (noise1 + noise2 * 0.3) * 0.5 + 0.5;
}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;

  // Generate three distinct background noise fields with time offsets
  float noise1 = background_noise(uv, u_waveOffset[0]);
  float noise2 = background_noise(uv, u_waveOffset[1]);
  float noise3 = background_noise(uv, 0.0); // Base noise without offset

  // Calculate wave alphas for blending
  float alpha1 = wave_alpha(uv, 0);
  float alpha2 = wave_alpha(uv, 1);
  float alpha3 = 1.0 - alpha1 - alpha2; // Remaining area
  alpha3 = max(alpha3, 0.0); // Ensure non-negative

  // Normalize alphas to ensure they sum to 1.0
  float totalAlpha = alpha1 + alpha2 + alpha3;
  if (totalAlpha > 0.0) {
    alpha1 /= totalAlpha;
    alpha2 /= totalAlpha;
    alpha3 /= totalAlpha;
  }

  // Blend the three noise fields based on wave alphas
  float t = noise1 * alpha1 + noise2 * alpha2 + noise3 * alpha3;
  t = clamp(t, 0.0, 1.0);

  // Sample gradient texture
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));

  // Apply dynamic blur based on position
  float blurAmount = calc_blur(uv);

  // Apply subtle vignette with blur modulation
  vec2 center = uv - 0.5;
  float vignette = 1.0 - dot(center, center) * (0.3 + blurAmount * 0.2);
  color.rgb *= vignette;

  // Apply blur effect to alpha channel for depth
  color.a *= (1.0 - blurAmount * 0.3);

  fragColor = color;
}`;
      _WebGLGradientBackgroundSystem = class _WebGLGradientBackgroundSystem extends BaseVisualSystem {
        constructor(config = YEAR3000_CONFIG, utils, performanceMonitor, musicSyncService = null, settingsManager = null, year3000System2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager);
          this.canvas = null;
          this.wrapper = null;
          this.gl = null;
          this.shaderProgram = null;
          this.uniforms = {
            u_time: null,
            u_gradientTex: null,
            u_resolution: null,
            u_flowStrength: null,
            u_noiseScale: null,
            u_waveY: null,
            u_waveHeight: null,
            u_waveOffset: null,
            u_blurExp: null,
            u_blurMax: null
          };
          this.gradientTexture = null;
          this.vertexBuffer = null;
          this.vao = null;
          this.settings = {
            enabled: true,
            intensity: "balanced",
            flowStrength: 0.7,
            noiseScale: 1.2,
            waveY: [0.25, 0.75],
            // Wave positions from theme metrics
            waveHeight: [0.4, 0.3],
            // Wave heights for smooth blending
            waveOffset: [2.5, -1.8],
            // Time offsets for wave independence
            blurExp: 1.2,
            // Blur power function exponent
            blurMax: 0.6
            // Maximum blur amount
          };
          this.isWebGLAvailable = false;
          this.animationId = null;
          this.startTime = 0;
          this.lastFrameTime = 0;
          this.frameThrottleInterval = 1e3 / 45;
          // 45 FPS target
          this.colorHarmonyEngine = null;
          this.cssVariableBatcher = null;
          this.boundColorHarmonyHandler = null;
          this.prefersReducedMotion = false;
          this.webglReady = false;
          this.animate = /* @__PURE__ */ __name(() => {
            if (!this.isActive || !this.gl || !this.canvas) return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.lastFrameTime;
            if (deltaTime < this.frameThrottleInterval) {
              this.animationId = requestAnimationFrame(this.animate);
              return;
            }
            this.lastFrameTime = currentTime;
            this.render(currentTime);
            this.animationId = requestAnimationFrame(this.animate);
          }, "animate");
          this.resize = /* @__PURE__ */ __name(() => {
            if (!this.canvas) return;
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            this.canvas.width = displayWidth * dpr;
            this.canvas.height = displayHeight * dpr;
            this.canvas.style.width = displayWidth + "px";
            this.canvas.style.height = displayHeight + "px";
          }, "resize");
          this.colorHarmonyEngine = year3000System2?.colorHarmonyEngine || null;
          this.cssVariableBatcher = new CSSVariableBatcher();
          this.prefersReducedMotion = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;
          this.boundColorHarmonyHandler = this.handleColorHarmonyChange.bind(this);
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          this.isWebGLAvailable = this.checkWebGL2Support();
          if (!this.isWebGLAvailable) {
            this.fallbackToCSSGradient();
            return;
          }
          const deviceDetector = new DeviceCapabilityDetector();
          if (deviceDetector.recommendPerformanceQuality() === "low") {
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Low performance device detected, falling back to CSS gradient"
            );
            this.fallbackToCSSGradient();
            return;
          }
          this.loadSettings();
          if (!this.settings.enabled) {
            this.fallbackToCSSGradient();
            return;
          }
          try {
            await this.initializeWebGL();
            this.subscribeToEvents();
            this.startAnimation();
            document.documentElement.style.setProperty("--sn-webgl-ready", "1");
            document.documentElement.style.setProperty("--sn-webgl-enabled", "1");
            document.documentElement.style.setProperty("--sn-current-backend", "hybrid");
            document.documentElement.style.setProperty("--sn-gradient-crossfade-opacity", "0.5");
            Y3K?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL gradient system initialized successfully"
            );
          } catch (error) {
            Y3K?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Failed to initialize WebGL gradient:",
              error
            );
            this.fallbackToCSSGradient();
          }
        }
        checkWebGL2Support() {
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2");
          return gl !== null;
        }
        findSpotifyContainer() {
          const containers = [
            ".Root__main-view",
            ".main-view-container",
            ".main-gridContainer-gridContainer",
            ".Root__top-container",
            "body"
          ];
          for (const selector of containers) {
            const element = document.querySelector(selector);
            if (element) {
              Y3K?.debug?.log(
                "WebGLGradientBackgroundSystem",
                `Found container: ${selector}`
              );
              return element;
            }
          }
          Y3K?.debug?.warn(
            "WebGLGradientBackgroundSystem",
            "No Spotify container found, falling back to body"
          );
          return document.body;
        }
        loadSettings() {
          if (!this.settingsManager) return;
          try {
            const intensitySetting = this.settingsManager.get(
              "sn-flow-gradient"
            );
            if (intensitySetting === "disabled") {
              this.settings.enabled = false;
              return;
            }
            this.settings.intensity = intensitySetting || "balanced";
            switch (this.settings.intensity) {
              case "minimal":
                this.settings.flowStrength = 0.4;
                this.settings.noiseScale = 0.8;
                this.settings.waveHeight = [0.3, 0.2];
                this.settings.waveOffset = [1.5, -1];
                this.settings.blurExp = 1;
                this.settings.blurMax = 0.4;
                break;
              case "balanced":
                this.settings.flowStrength = 0.7;
                this.settings.noiseScale = 1.2;
                this.settings.waveHeight = [0.4, 0.3];
                this.settings.waveOffset = [2.5, -1.8];
                this.settings.blurExp = 1.2;
                this.settings.blurMax = 0.6;
                break;
              case "intense":
                this.settings.flowStrength = 1;
                this.settings.noiseScale = 1.6;
                this.settings.waveHeight = [0.5, 0.4];
                this.settings.waveOffset = [3.5, -2.5];
                this.settings.blurExp = 1.4;
                this.settings.blurMax = 0.8;
                break;
            }
          } catch (error) {
            Y3K?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "Failed to load settings, using defaults:",
              error
            );
          }
        }
        async initializeWebGL() {
          this.wrapper = document.createElement("div");
          this.wrapper.className = "sn-flow-gradient-wrapper";
          this.wrapper.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -11;
      pointer-events: none;
      overflow: hidden;
    `;
          this.canvas = document.createElement("canvas");
          this.canvas.id = "sn-webgl-gradient";
          this.canvas.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    `;
          this.wrapper.appendChild(this.canvas);
          this.gl = this.canvas.getContext("webgl2", {
            alpha: true,
            antialias: false,
            depth: false,
            stencil: false,
            powerPreference: "default"
          });
          if (!this.gl) {
            throw new Error("Failed to get WebGL2 context");
          }
          await this.compileShaders();
          this.createGeometry();
          await this.updateGradientTexture();
          this.setupUniforms();
          this.resize();
          const targetContainer = this.findSpotifyContainer();
          targetContainer.appendChild(this.wrapper);
          window.addEventListener("resize", this.resize.bind(this));
        }
        async compileShaders() {
          if (!this.gl) throw new Error("WebGL context not available");
          const vertexShader = ShaderLoader.loadVertex(
            this.gl,
            DEFAULT_VERTEX_SHADER
          );
          const fragmentShader = ShaderLoader.loadFragment(
            this.gl,
            flowGradientShader
          );
          if (!vertexShader || !fragmentShader) {
            throw new Error("Failed to compile shaders");
          }
          this.shaderProgram = ShaderLoader.createProgram(
            this.gl,
            vertexShader,
            fragmentShader
          );
          if (!this.shaderProgram) {
            throw new Error("Failed to create shader program");
          }
        }
        createGeometry() {
          if (!this.gl || !this.shaderProgram) return;
          const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
          this.vertexBuffer = this.gl.createBuffer();
          this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
          this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
          this.vao = this.gl.createVertexArray();
          this.gl.bindVertexArray(this.vao);
          const positionLocation = this.gl.getAttribLocation(
            this.shaderProgram,
            "a_position"
          );
          this.gl.enableVertexAttribArray(positionLocation);
          this.gl.vertexAttribPointer(
            positionLocation,
            2,
            this.gl.FLOAT,
            false,
            0,
            0
          );
          this.gl.bindVertexArray(null);
        }
        setupUniforms() {
          if (!this.gl || !this.shaderProgram) return;
          this.uniforms.u_time = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_time"
          );
          this.uniforms.u_gradientTex = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_gradientTex"
          );
          this.uniforms.u_resolution = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_resolution"
          );
          this.uniforms.u_flowStrength = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_flowStrength"
          );
          this.uniforms.u_noiseScale = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_noiseScale"
          );
          this.uniforms.u_waveY = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveY"
          );
          this.uniforms.u_waveHeight = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveHeight"
          );
          this.uniforms.u_waveOffset = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveOffset"
          );
          this.uniforms.u_blurExp = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_blurExp"
          );
          this.uniforms.u_blurMax = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_blurMax"
          );
        }
        async updateGradientTexture() {
          if (!this.gl) return;
          let colorStops = this.getDefaultGradientStops();
          if (this.colorHarmonyEngine) {
            try {
              const currentGradient = this.colorHarmonyEngine.getCurrentGradient(5);
              if (currentGradient && currentGradient.length > 0) {
                colorStops = currentGradient.map((color, index) => ({
                  r: color.r / 255,
                  g: color.g / 255,
                  b: color.b / 255,
                  a: 1,
                  position: index / (currentGradient.length - 1)
                }));
                Y3K?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `Updated gradient texture with ${colorStops.length} stops from ColorHarmonyEngine`
                );
              }
            } catch (error) {
              Y3K?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "Failed to get gradient from ColorHarmonyEngine:",
                error
              );
            }
          }
          if (this.gradientTexture) {
            this.gl.deleteTexture(this.gradientTexture);
          }
          this.gradientTexture = createGradientTexture(this.gl, colorStops);
          if (!this.gradientTexture) {
            throw new Error("Failed to create gradient texture");
          }
          const root = document.documentElement;
          const maxStops = Math.min(8, colorStops.length);
          root.style.setProperty("--sn-grad-stop-count", String(maxStops));
          for (let i = 0; i < maxStops; i++) {
            const c = colorStops[i];
            root.style.setProperty(
              `--sn-grad-stop-${i}-rgb`,
              `${Math.round(c.r * 255)},${Math.round(c.g * 255)},${Math.round(
                c.b * 255
              )}`
            );
          }
        }
        getDefaultGradientStops() {
          return [
            { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 0 },
            // Base
            { r: 0.549, g: 0.408, b: 0.878, a: 1, position: 0.3 },
            // Mauve
            { r: 0.788, g: 0.557, b: 0.902, a: 1, position: 0.6 },
            // Pink
            { r: 0.957, g: 0.761, b: 0.494, a: 1, position: 1 }
            // Peach
          ];
        }
        subscribeToEvents() {
          if (this.colorHarmonyEngine && this.boundColorHarmonyHandler) {
            document.addEventListener(
              "color-harmony:gradient-changed",
              this.boundColorHarmonyHandler
            );
          }
        }
        handleColorHarmonyChange(event) {
          this.updateGradientTexture().catch((error) => {
            Y3K?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Failed to update gradient texture:",
              error
            );
          });
        }
        startAnimation() {
          this.startTime = performance.now();
          this.lastFrameTime = this.startTime;
          this.animate();
        }
        render(currentTime) {
          if (!this.gl || !this.shaderProgram || !this.vao || !this.gradientTexture)
            return;
          this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
          this.gl.clearColor(0, 0, 0, 0);
          this.gl.clear(this.gl.COLOR_BUFFER_BIT);
          this.gl.useProgram(this.shaderProgram);
          this.gl.bindVertexArray(this.vao);
          if (!this.webglReady) {
            this.webglReady = true;
            document.documentElement.style.setProperty("--sn-webgl-ready", "1");
            document.documentElement.style.setProperty("--sn-webgl-enabled", "1");
            document.documentElement.style.setProperty("--sn-current-backend", "hybrid");
            document.documentElement.style.setProperty("--sn-gradient-crossfade-opacity", "0.5");
          }
          const time = this.prefersReducedMotion ? 0 : (currentTime - this.startTime) / 1e3;
          if (this.uniforms.u_time) {
            this.gl.uniform1f(this.uniforms.u_time, time);
          }
          if (this.uniforms.u_resolution) {
            this.gl.uniform2f(
              this.uniforms.u_resolution,
              this.canvas.width,
              this.canvas.height
            );
          }
          if (this.uniforms.u_flowStrength) {
            const rootStyle = document.documentElement;
            const flowStrengthValue = rootStyle.style.getPropertyValue("--sn-flow-strength").trim();
            const flowStrength = flowStrengthValue ? parseFloat(flowStrengthValue) : this.settings.flowStrength;
            this.gl.uniform1f(this.uniforms.u_flowStrength, flowStrength);
          }
          if (this.uniforms.u_noiseScale) {
            this.gl.uniform1f(this.uniforms.u_noiseScale, this.settings.noiseScale);
          }
          if (this.uniforms.u_waveY) {
            this.gl.uniform1fv(this.uniforms.u_waveY, this.settings.waveY);
          }
          if (this.uniforms.u_waveHeight) {
            this.gl.uniform1fv(this.uniforms.u_waveHeight, this.settings.waveHeight);
          }
          if (this.uniforms.u_waveOffset) {
            this.gl.uniform1fv(this.uniforms.u_waveOffset, this.settings.waveOffset);
          }
          if (this.uniforms.u_blurExp) {
            this.gl.uniform1f(this.uniforms.u_blurExp, this.settings.blurExp);
          }
          if (this.uniforms.u_blurMax) {
            this.gl.uniform1f(this.uniforms.u_blurMax, this.settings.blurMax);
          }
          this.gl.activeTexture(this.gl.TEXTURE0);
          this.gl.bindTexture(this.gl.TEXTURE_2D, this.gradientTexture);
          if (this.uniforms.u_gradientTex) {
            this.gl.uniform1i(this.uniforms.u_gradientTex, 0);
          }
          this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
          this.gl.bindVertexArray(null);
        }
        fallbackToCSSGradient() {
          document.documentElement.style.setProperty("--sn-webgl-ready", "0");
          document.documentElement.style.setProperty("--sn-webgl-enabled", "0");
          document.documentElement.style.setProperty("--sn-current-backend", "css");
          document.documentElement.style.setProperty("--sn-gradient-crossfade-opacity", "0");
          if (this.cssVariableBatcher) {
            this.startCSSFallbackAnimation();
          }
          Y3K?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Using CSS gradient fallback"
          );
        }
        startCSSFallbackAnimation() {
          if (!this.cssVariableBatcher) return;
          const animateCSS = /* @__PURE__ */ __name(() => {
            if (!this.isActive) return;
            const time = performance.now() / 1e3;
            const flowX = Math.sin(time * 0.04) * 20 + Math.sin(time * 0.07) * 8;
            const flowY = Math.cos(time * 0.05) * 20 + Math.cos(time * 0.09) * 6;
            const scale = 1.15 + Math.sin(time * 0.03) * 0.2;
            const batcher = this.cssVariableBatcher;
            if (!batcher) return;
            batcher.queueCSSVariableUpdate("--sn-gradient-flow-x", `${flowX}%`);
            batcher.queueCSSVariableUpdate("--sn-gradient-flow-y", `${flowY}%`);
            batcher.queueCSSVariableUpdate(
              "--sn-gradient-flow-scale",
              scale.toString()
            );
            setTimeout(animateCSS, this.frameThrottleInterval);
          }, "animateCSS");
          animateCSS();
        }
        handleSettingsChange(event) {
          super.handleSettingsChange(event);
          const customEvent = event;
          const { key, value } = customEvent.detail;
          if (key === "sn-flow-gradient") {
            const wasEnabled = this.settings.enabled;
            this.settings.intensity = value;
            this.loadSettings();
            if (value === "disabled" && wasEnabled) {
              this.settings.enabled = false;
              this.destroy();
              this.fallbackToCSSGradient();
            } else if (this.settings.enabled && !wasEnabled && this.isWebGLAvailable) {
              this.initialize();
            }
          }
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
          if (this.gl) {
            if (this.gradientTexture) {
              this.gl.deleteTexture(this.gradientTexture);
              this.gradientTexture = null;
            }
            if (this.vertexBuffer) {
              this.gl.deleteBuffer(this.vertexBuffer);
              this.vertexBuffer = null;
            }
            if (this.vao) {
              this.gl.deleteVertexArray(this.vao);
              this.vao = null;
            }
            if (this.shaderProgram) {
              this.gl.deleteProgram(this.shaderProgram);
              this.shaderProgram = null;
            }
            ShaderLoader.clearCache(this.gl);
          }
          if (this.wrapper && this.wrapper.parentNode) {
            this.wrapper.parentNode.removeChild(this.wrapper);
            this.wrapper = null;
          }
          this.canvas = null;
          if (this.boundColorHarmonyHandler) {
            document.removeEventListener(
              "color-harmony:gradient-changed",
              this.boundColorHarmonyHandler
            );
            this.boundColorHarmonyHandler = null;
          }
          window.removeEventListener("resize", this.resize);
          this.gl = null;
          document.documentElement.style.setProperty("--sn-webgl-ready", "0");
          document.documentElement.style.setProperty("--sn-webgl-enabled", "0");
          document.documentElement.style.setProperty("--sn-current-backend", "css");
          document.documentElement.style.setProperty("--sn-gradient-crossfade-opacity", "0");
        }
        forceRepaint(reason = "settings-change") {
          if (this.isActive && this.gradientTexture) {
            this.updateGradientTexture().catch((error) => {
              Y3K?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Failed to repaint gradient:",
                error
              );
            });
          }
        }
        // Public setters for wave parameters
        setWaveY(waveY) {
          this.settings.waveY = waveY;
        }
        setWaveHeight(waveHeight) {
          this.settings.waveHeight = waveHeight;
        }
        setWaveOffset(waveOffset) {
          this.settings.waveOffset = waveOffset;
        }
        setBlurSettings(blurExp, blurMax) {
          this.settings.blurExp = blurExp;
          this.settings.blurMax = blurMax;
        }
        getMetrics() {
          return {
            fps: this.performanceMonitor?.getMedianFPS?.() || 0,
            compileErrors: 0,
            // TODO: Track compilation errors
            isActive: this.isActive,
            settings: { ...this.settings }
          };
        }
        /**
         * Gracefully stop the animation loop.  Exposed for backplane adapters.
         */
        stopAnimation() {
          if (this.animationId !== null) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
        }
        /**
         * Lightweight health check used by adapters; returns OK if WebGL is ready.
         */
        async healthCheck() {
          return {
            ok: this.webglReady,
            details: this.webglReady ? "WebGL system nominal" : "WebGL not initialized"
          };
        }
        /**
         * Alternative resize helper that allows explicit dimensions while leaving
         * the original `resize` listener (no-arg) intact.
         */
        resizeTo(width, height) {
          if (!this.canvas) return;
          this.canvas.width = width;
          this.canvas.height = height;
          this.resize?.();
        }
      };
      __name(_WebGLGradientBackgroundSystem, "WebGLGradientBackgroundSystem");
      WebGLGradientBackgroundSystem = _WebGLGradientBackgroundSystem;
    }
  });

  // src-js/core/events/EventBus.ts
  var _EventBus, EventBus, GlobalEventBus, g;
  var init_EventBus = __esm({
    "src-js/core/events/EventBus.ts"() {
      "use strict";
      _EventBus = class _EventBus {
        constructor() {
          this.subscribers = {};
        }
        subscribe(topic, callback) {
          if (!this.subscribers[topic]) {
            this.subscribers[topic] = /* @__PURE__ */ new Set();
          }
          this.subscribers[topic].add(callback);
          return () => {
            if (this.subscribers[topic]) {
              this.subscribers[topic].delete(callback);
              if (this.subscribers[topic].size === 0) {
                delete this.subscribers[topic];
              }
            }
          };
        }
        publish(topic, payload) {
          if (this.subscribers[topic]) {
            this.subscribers[topic].forEach((callback) => {
              try {
                callback(payload);
              } catch (error) {
                console.error(
                  `[EventBus] Error in subscriber for topic "${topic}":`,
                  error
                );
              }
            });
          }
        }
        unsubscribe(topic, callback) {
          if (this.subscribers[topic]) {
            this.subscribers[topic].delete(callback);
            if (this.subscribers[topic].size === 0) {
              delete this.subscribers[topic];
            }
          }
        }
        // -------------------------------------------------------------------
        // Compatibility aliases (v2 API) ------------------------------------
        // These provide ergonomic `on` / `emit` helpers used throughout newer
        // systems while retaining the underlying subscribe/publish semantics.
        // -------------------------------------------------------------------
        /**
         * Alias for `subscribe` to improve readability (`on('topic', cb)`).
         */
        on(topic, callback) {
          return this.subscribe(topic, callback);
        }
        /**
         * Alias for `publish` so call sites can use `emit('topic', data)`.
         */
        emit(topic, payload) {
          this.publish(topic, payload);
        }
        destroy() {
          this.subscribers = {};
        }
      };
      __name(_EventBus, "EventBus");
      EventBus = _EventBus;
      GlobalEventBus = new EventBus();
      g = globalThis;
      if (!g.GlobalEventBus) {
        g.GlobalEventBus = GlobalEventBus;
      }
    }
  });

  // src-js/types/signature.ts
  var createDefaultSignature;
  var init_signature = __esm({
    "src-js/types/signature.ts"() {
      "use strict";
      createDefaultSignature = /* @__PURE__ */ __name((userId) => ({
        version: "1.0.0",
        userId,
        createdAt: Date.now(),
        lastModified: Date.now(),
        colorMemories: /* @__PURE__ */ new Map(),
        rhythmicPreferences: /* @__PURE__ */ new Map(),
        emotionalResonanceProfile: {},
        evolutionaryTrajectory: {
          adaptability: 0.5,
          // Start balanced
          explorationFactor: 0.5,
          // Start balanced
          lastUpdate: Date.now()
        }
      }), "createDefaultSignature");
    }
  });

  // node_modules/idb/build/index.js
  function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
      IDBDatabase,
      IDBObjectStore,
      IDBIndex,
      IDBCursor,
      IDBTransaction
    ]);
  }
  function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey
    ]);
  }
  function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
      const unlisten = /* @__PURE__ */ __name(() => {
        request.removeEventListener("success", success);
        request.removeEventListener("error", error);
      }, "unlisten");
      const success = /* @__PURE__ */ __name(() => {
        resolve(wrap(request.result));
        unlisten();
      }, "success");
      const error = /* @__PURE__ */ __name(() => {
        reject(request.error);
        unlisten();
      }, "error");
      request.addEventListener("success", success);
      request.addEventListener("error", error);
    });
    reverseTransformCache.set(promise, request);
    return promise;
  }
  function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx))
      return;
    const done = new Promise((resolve, reject) => {
      const unlisten = /* @__PURE__ */ __name(() => {
        tx.removeEventListener("complete", complete);
        tx.removeEventListener("error", error);
        tx.removeEventListener("abort", error);
      }, "unlisten");
      const complete = /* @__PURE__ */ __name(() => {
        resolve();
        unlisten();
      }, "complete");
      const error = /* @__PURE__ */ __name(() => {
        reject(tx.error || new DOMException("AbortError", "AbortError"));
        unlisten();
      }, "error");
      tx.addEventListener("complete", complete);
      tx.addEventListener("error", error);
      tx.addEventListener("abort", error);
    });
    transactionDoneMap.set(tx, done);
  }
  function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
  }
  function wrapFunction(func) {
    if (getCursorAdvanceMethods().includes(func)) {
      return function(...args) {
        func.apply(unwrap(this), args);
        return wrap(this.request);
      };
    }
    return function(...args) {
      return wrap(func.apply(unwrap(this), args));
    };
  }
  function transformCachableValue(value) {
    if (typeof value === "function")
      return wrapFunction(value);
    if (value instanceof IDBTransaction)
      cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
      return new Proxy(value, idbProxyTraps);
    return value;
  }
  function wrap(value) {
    if (value instanceof IDBRequest)
      return promisifyRequest(value);
    if (transformCache.has(value))
      return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
      transformCache.set(value, newValue);
      reverseTransformCache.set(newValue, value);
    }
    return newValue;
  }
  function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap(request);
    if (upgrade) {
      request.addEventListener("upgradeneeded", (event) => {
        upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
      });
    }
    if (blocked) {
      request.addEventListener("blocked", (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion,
        event.newVersion,
        event
      ));
    }
    openPromise.then((db) => {
      if (terminated)
        db.addEventListener("close", () => terminated());
      if (blocking) {
        db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
      }
    }).catch(() => {
    });
    return openPromise;
  }
  function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
      return;
    }
    if (cachedMethods.get(prop))
      return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, "");
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
    ) {
      return;
    }
    const method = /* @__PURE__ */ __name(async function(storeName, ...args) {
      const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
      let target2 = tx.store;
      if (useIndex)
        target2 = target2.index(args.shift());
      return (await Promise.all([
        target2[targetFuncName](...args),
        isWrite && tx.done
      ]))[0];
    }, "method");
    cachedMethods.set(prop, method);
    return method;
  }
  async function* iterate(...args) {
    let cursor = this;
    if (!(cursor instanceof IDBCursor)) {
      cursor = await cursor.openCursor(...args);
    }
    if (!cursor)
      return;
    cursor = cursor;
    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
    reverseTransformCache.set(proxiedCursor, unwrap(cursor));
    while (cursor) {
      yield proxiedCursor;
      cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
      advanceResults.delete(proxiedCursor);
    }
  }
  function isIteratorProp(target, prop) {
    return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
  }
  var instanceOfAny, idbProxyableTypes, cursorAdvanceMethods, transactionDoneMap, transformCache, reverseTransformCache, idbProxyTraps, unwrap, readMethods, writeMethods, cachedMethods, advanceMethodProps, methodMap, advanceResults, ittrProxiedCursorToOriginalProxy, cursorIteratorTraps;
  var init_build = __esm({
    "node_modules/idb/build/index.js"() {
      instanceOfAny = /* @__PURE__ */ __name((object, constructors) => constructors.some((c) => object instanceof c), "instanceOfAny");
      __name(getIdbProxyableTypes, "getIdbProxyableTypes");
      __name(getCursorAdvanceMethods, "getCursorAdvanceMethods");
      transactionDoneMap = /* @__PURE__ */ new WeakMap();
      transformCache = /* @__PURE__ */ new WeakMap();
      reverseTransformCache = /* @__PURE__ */ new WeakMap();
      __name(promisifyRequest, "promisifyRequest");
      __name(cacheDonePromiseForTransaction, "cacheDonePromiseForTransaction");
      idbProxyTraps = {
        get(target, prop, receiver) {
          if (target instanceof IDBTransaction) {
            if (prop === "done")
              return transactionDoneMap.get(target);
            if (prop === "store") {
              return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
            }
          }
          return wrap(target[prop]);
        },
        set(target, prop, value) {
          target[prop] = value;
          return true;
        },
        has(target, prop) {
          if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
            return true;
          }
          return prop in target;
        }
      };
      __name(replaceTraps, "replaceTraps");
      __name(wrapFunction, "wrapFunction");
      __name(transformCachableValue, "transformCachableValue");
      __name(wrap, "wrap");
      unwrap = /* @__PURE__ */ __name((value) => reverseTransformCache.get(value), "unwrap");
      __name(openDB, "openDB");
      readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
      writeMethods = ["put", "add", "delete", "clear"];
      cachedMethods = /* @__PURE__ */ new Map();
      __name(getMethod, "getMethod");
      replaceTraps((oldTraps) => ({
        ...oldTraps,
        get: /* @__PURE__ */ __name((target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver), "get"),
        has: /* @__PURE__ */ __name((target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop), "has")
      }));
      advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
      methodMap = {};
      advanceResults = /* @__PURE__ */ new WeakMap();
      ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
      cursorIteratorTraps = {
        get(target, prop) {
          if (!advanceMethodProps.includes(prop))
            return target[prop];
          let cachedFunc = methodMap[prop];
          if (!cachedFunc) {
            cachedFunc = methodMap[prop] = function(...args) {
              advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
            };
          }
          return cachedFunc;
        }
      };
      __name(iterate, "iterate");
      __name(isIteratorProp, "isIteratorProp");
      replaceTraps((oldTraps) => ({
        ...oldTraps,
        get(target, prop, receiver) {
          if (isIteratorProp(target, prop))
            return iterate;
          return oldTraps.get(target, prop, receiver);
        },
        has(target, prop) {
          return isIteratorProp(target, prop) || oldTraps.has(target, prop);
        }
      }));
    }
  });

  // src-js/audio/TemporalMemoryService.ts
  var DB_NAME, DB_VERSION, SIGNATURE_STORE, SIGNATURE_KEY, _TemporalMemoryService, TemporalMemoryService, temporalMemoryService;
  var init_TemporalMemoryService = __esm({
    "src-js/audio/TemporalMemoryService.ts"() {
      "use strict";
      init_signature();
      init_build();
      DB_NAME = "Year3000-TemporalMemory";
      DB_VERSION = 1;
      SIGNATURE_STORE = "aestheticSignatures";
      SIGNATURE_KEY = "currentUser";
      _TemporalMemoryService = class _TemporalMemoryService {
        constructor() {
          this.dbPromise = openDB(DB_NAME, DB_VERSION, {
            upgrade(db) {
              if (!db.objectStoreNames.contains(SIGNATURE_STORE)) {
                db.createObjectStore(SIGNATURE_STORE);
              }
            }
          });
        }
        async getSignature(userId = "defaultUser") {
          try {
            const db = await this.dbPromise;
            const signature = await db.get(SIGNATURE_STORE, SIGNATURE_KEY);
            if (signature) {
              return signature;
            } else {
              const defaultSignature = createDefaultSignature(userId);
              await this.saveSignature(defaultSignature);
              return defaultSignature;
            }
          } catch (error) {
            console.error(
              "[TemporalMemoryService] Failed to get signature from IndexedDB. Returning default.",
              error
            );
            return createDefaultSignature(userId);
          }
        }
        async saveSignature(signature) {
          try {
            const db = await this.dbPromise;
            signature.lastModified = Date.now();
            await db.put(SIGNATURE_STORE, signature, SIGNATURE_KEY);
          } catch (error) {
            console.error(
              "[TemporalMemoryService] Failed to save signature to IndexedDB.",
              error
            );
          }
        }
        async resetSignature(userId = "defaultUser") {
          const defaultSignature = createDefaultSignature(userId);
          await this.saveSignature(defaultSignature);
          console.log("[TemporalMemoryService] Aesthetic signature has been reset.");
          return defaultSignature;
        }
        async getSignatureTrends(signature) {
          if (!signature) return null;
          const trends = {
            dominantColor: null,
            dominantRhythm: null,
            avgEnergy: 0,
            avgValence: 0
          };
          let dominantColor = null;
          signature.colorMemories.forEach((mem, hex) => {
            if (!dominantColor || mem.count > dominantColor.count) {
              dominantColor = { hex, count: mem.count };
            }
            trends.avgValence += mem.emotionalValence * mem.count;
          });
          let totalColorCount = 0;
          signature.colorMemories.forEach((mem) => totalColorCount += mem.count);
          if (totalColorCount > 0) {
            trends.avgValence /= totalColorCount;
          }
          trends.dominantColor = dominantColor;
          let dominantRhythm = null;
          signature.rhythmicPreferences.forEach((pattern, id) => {
            if (!dominantRhythm || pattern.count > dominantRhythm.count) {
              dominantRhythm = { id, count: pattern.count };
            }
            trends.avgEnergy += pattern.associatedEnergy * pattern.count;
          });
          let totalRhythmCount = 0;
          signature.rhythmicPreferences.forEach((p) => totalRhythmCount += p.count);
          if (totalRhythmCount > 0) {
            trends.avgEnergy /= totalRhythmCount;
          }
          trends.dominantRhythm = dominantRhythm;
          return trends;
        }
      };
      __name(_TemporalMemoryService, "TemporalMemoryService");
      TemporalMemoryService = _TemporalMemoryService;
      temporalMemoryService = new TemporalMemoryService();
    }
  });

  // src-js/core/animation/EnhancedMasterAnimationCoordinator.ts
  var _EnhancedMasterAnimationCoordinator, EnhancedMasterAnimationCoordinator;
  var init_EnhancedMasterAnimationCoordinator = __esm({
    "src-js/core/animation/EnhancedMasterAnimationCoordinator.ts"() {
      "use strict";
      init_EventBus();
      init_TemporalMemoryService();
      _EnhancedMasterAnimationCoordinator = class _EnhancedMasterAnimationCoordinator {
        constructor(config, performanceCoordinator) {
          this.performanceCoordinator = null;
          // Animation management
          this.animations = /* @__PURE__ */ new Map();
          this.frameCallbacks = /* @__PURE__ */ new Map();
          this.callbackCounter = 0;
          // Master animation loop
          this.animationFrameId = null;
          this.isRunning = false;
          this.isPaused = false;
          // Timing and performance
          this.lastTimestamp = 0;
          this.frameCount = 0;
          this.startTime = 0;
          this.frameTimeBudget = 16;
          // 60fps
          // Performance metrics
          this.metrics = {
            totalFrames: 0,
            droppedFrames: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            performanceMode: "quality",
            activeAnimations: 0,
            activeCallbacks: 0,
            frameRate: 60,
            lastOptimization: 0
          };
          // Frame context for visual systems
          this.frameContext = {
            timestamp: 0,
            deltaMs: 0,
            performanceMode: "quality",
            frameBudget: 16,
            beatIntensity: 0,
            scrollRatio: 0,
            tiltXY: { x: 0, y: 0 }
          };
          // Performance tracking
          this.performanceHistory = [];
          this.MAX_HISTORY_SIZE = 60;
          // 1 second at 60fps
          // ===================================================================
          // EMERGENT CHOREOGRAPHY ENGINE INTEGRATION (from consolidation)
          // ===================================================================
          // Emergent choreography state
          this.signature = null;
          this.saveInterval = null;
          this.currentBpm = 120;
          this.currentIntensity = 0.5;
          this.emergentEventSubscriptions = [];
          // =========================================================================
          // PRIVATE METHODS
          // =========================================================================
          /**
           * Main animation loop
           */
          this.animate = /* @__PURE__ */ __name(() => {
            if (!this.isRunning) return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.lastTimestamp;
            if (this.isPaused) {
              this.animationFrameId = requestAnimationFrame(this.animate);
              return;
            }
            this.frameContext.timestamp = currentTime;
            this.frameContext.deltaMs = deltaTime;
            const frameStartTime = performance.now();
            this.executeFrameCallbacks(deltaTime, currentTime);
            this.executeAnimationSystems(deltaTime, currentTime);
            this.processEmergentTick(deltaTime);
            const frameTime = performance.now() - frameStartTime;
            this.updatePerformanceMetrics(frameTime);
            if (this.performanceCoordinator) {
              this.performanceCoordinator.trackSubsystem("MasterAnimationCoordinator", {
                frameTime,
                fps: this.metrics.frameRate,
                memoryUsage: performance.memory?.usedJSHeapSize || 0,
                cpuUsage: frameTime > this.frameTimeBudget ? frameTime / this.frameTimeBudget * 10 : 0
              });
            }
            this.lastTimestamp = currentTime;
            this.frameCount++;
            this.animationFrameId = requestAnimationFrame(this.animate);
          }, "animate");
          this.config = config;
          this.eventBus = GlobalEventBus;
          this.performanceCoordinator = performanceCoordinator || null;
          this.startTime = performance.now();
          this.lastTimestamp = this.startTime;
          this.currentMultipliers = this.config.cosmicMultipliers;
          this.subscribeToEvents();
          this.initializeEmergentChoreography();
          this.updateFrameBudget();
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Initialized with unified animation coordination and emergent choreography");
          }
        }
        /**
         * Get or create singleton instance
         */
        static getInstance(config, performanceCoordinator) {
          if (!_EnhancedMasterAnimationCoordinator.instance) {
            if (!config) {
              throw new Error("EnhancedMasterAnimationCoordinator requires config for first initialization");
            }
            _EnhancedMasterAnimationCoordinator.instance = new _EnhancedMasterAnimationCoordinator(config, performanceCoordinator);
          }
          return _EnhancedMasterAnimationCoordinator.instance;
        }
        /**
         * Register an animation system (legacy AnimationConductor compatibility)
         */
        registerAnimationSystem(name, system, priority = "normal", targetFPS = 60) {
          if (this.animations.has(name)) {
            if (this.config.enableDebug) {
              console.warn(`[EnhancedMasterAnimationCoordinator] Animation system ${name} already registered`);
            }
            return false;
          }
          const registration = {
            name,
            system,
            priority,
            targetFPS,
            type: "animation",
            enabled: true,
            frameInterval: 1e3 / targetFPS,
            lastUpdate: 0,
            frameCount: 0,
            totalTime: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            skippedFrames: 0
          };
          this.animations.set(name, registration);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered animation system: ${name} (priority: ${priority}, fps: ${targetFPS})`);
          }
          return true;
        }
        /**
         * Register a visual system (legacy VisualFrameCoordinator compatibility)
         */
        registerVisualSystem(system, priority = "normal") {
          if (this.animations.has(system.systemName)) {
            if (this.config.enableDebug) {
              console.warn(`[EnhancedMasterAnimationCoordinator] Visual system ${system.systemName} already registered`);
            }
            return false;
          }
          const registration = {
            name: system.systemName,
            system,
            priority,
            targetFPS: 60,
            type: "visual",
            enabled: true,
            frameInterval: 16.67,
            // 60fps
            lastUpdate: 0,
            frameCount: 0,
            totalTime: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            skippedFrames: 0
          };
          this.animations.set(system.systemName, registration);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered visual system: ${system.systemName} (priority: ${priority})`);
          }
          return true;
        }
        /**
         * Register a frame callback for unified RAF management
         */
        registerFrameCallback(callback, priority = "normal", system) {
          const id = `callback_${++this.callbackCounter}`;
          const frameCallback = {
            id,
            callback,
            priority,
            system: system || void 0,
            enabled: true,
            frameCount: 0,
            totalTime: 0,
            lastExecution: 0
          };
          this.frameCallbacks.set(id, frameCallback);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered frame callback: ${id} (priority: ${priority})`);
          }
          return id;
        }
        /**
         * Unregister an animation system
         */
        unregisterAnimationSystem(name) {
          const removed = this.animations.delete(name);
          if (removed) {
            this.updateMetrics();
            if (this.animations.size === 0 && this.frameCallbacks.size === 0) {
              this.stopMasterAnimationLoop();
            }
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] Unregistered animation system: ${name}`);
            }
          }
          return removed;
        }
        /**
         * Unregister a frame callback
         */
        unregisterFrameCallback(id) {
          const removed = this.frameCallbacks.delete(id);
          if (removed) {
            this.updateMetrics();
            if (this.animations.size === 0 && this.frameCallbacks.size === 0) {
              this.stopMasterAnimationLoop();
            }
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] Unregistered frame callback: ${id}`);
            }
          }
          return removed;
        }
        /**
         * Start the master animation loop
         */
        startMasterAnimationLoop() {
          if (this.isRunning) return;
          this.isRunning = true;
          this.isPaused = false;
          this.lastTimestamp = performance.now();
          this.frameCount = 0;
          this.animate();
          this.eventBus.publish("animation:loop-started", {
            timestamp: Date.now(),
            systems: this.animations.size,
            callbacks: this.frameCallbacks.size
          });
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Master animation loop started");
          }
        }
        /**
         * Stop the master animation loop
         */
        stopMasterAnimationLoop() {
          if (!this.isRunning) return;
          this.isRunning = false;
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
          this.eventBus.publish("animation:loop-stopped", {
            timestamp: Date.now(),
            totalFrames: this.frameCount,
            duration: performance.now() - this.startTime
          });
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Master animation loop stopped");
          }
        }
        /**
         * Pause the animation loop
         */
        pauseAnimationLoop() {
          this.isPaused = true;
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Animation loop paused");
          }
        }
        /**
         * Resume the animation loop
         */
        resumeAnimationLoop() {
          if (!this.isPaused) return;
          this.isPaused = false;
          this.lastTimestamp = performance.now();
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Animation loop resumed");
          }
        }
        /**
         * Set performance mode for all registered systems
         */
        setPerformanceMode(mode) {
          this.metrics.performanceMode = mode;
          this.frameContext.performanceMode = mode;
          this.frameTimeBudget = mode === "performance" ? 8 : 16;
          this.frameContext.frameBudget = this.frameTimeBudget;
          for (const registration of this.animations.values()) {
            if (registration.system.onPerformanceModeChange) {
              registration.system.onPerformanceModeChange(mode);
            }
          }
          this.eventBus.publish("animation:performance-mode-changed", {
            mode,
            timestamp: Date.now()
          });
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Performance mode set to: ${mode}`);
          }
        }
        /**
         * Get current performance metrics
         */
        getPerformanceMetrics() {
          return { ...this.metrics };
        }
        /**
         * Get all registered systems
         */
        getRegisteredSystems() {
          return {
            animations: new Map(this.animations),
            callbacks: new Map(this.frameCallbacks)
          };
        }
        /**
         * Enable or disable a specific system
         */
        setSystemEnabled(name, enabled) {
          const animation = this.animations.get(name);
          if (animation) {
            animation.enabled = enabled;
            this.updateMetrics();
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] System ${name} ${enabled ? "enabled" : "disabled"}`);
            }
            return true;
          }
          return false;
        }
        /**
         * Get current multipliers for emergent choreography
         */
        getCurrentMultipliers() {
          return this.currentMultipliers;
        }
        /**
         * Force update evolutionary trajectory
         */
        async updateEvolutionaryTrajectory() {
          await this._updateEvolutionaryTrajectory();
        }
        /**
         * Destroy the coordinator and clean up resources
         */
        destroy() {
          this.stopMasterAnimationLoop();
          this.destroyEmergentChoreography();
          for (const registration of this.animations.values()) {
            if (registration.type === "visual" && "destroy" in registration.system) {
              try {
                registration.system.destroy();
              } catch (error) {
                console.error(`[EnhancedMasterAnimationCoordinator] Error destroying system ${registration.name}:`, error);
              }
            }
          }
          this.animations.clear();
          this.frameCallbacks.clear();
          if (_EnhancedMasterAnimationCoordinator.instance === this) {
            _EnhancedMasterAnimationCoordinator.instance = null;
          }
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Destroyed");
          }
        }
        /**
         * Execute frame callbacks with priority ordering
         */
        executeFrameCallbacks(deltaTime, timestamp) {
          const sortedCallbacks = Array.from(this.frameCallbacks.values()).filter((callback) => callback.enabled).sort((a, b) => {
            const priorityOrder = { critical: 0, normal: 1, background: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
          });
          for (const callback of sortedCallbacks) {
            const callbackStartTime = performance.now();
            try {
              callback.callback(deltaTime, timestamp);
              const callbackTime = performance.now() - callbackStartTime;
              callback.totalTime += callbackTime;
              callback.frameCount++;
              callback.lastExecution = timestamp;
              if (callbackTime > this.frameTimeBudget * 0.5) {
                if (this.config.enableDebug) {
                  console.warn(`[EnhancedMasterAnimationCoordinator] Callback ${callback.id} exceeded budget: ${callbackTime.toFixed(2)}ms`);
                }
              }
            } catch (error) {
              console.error(`[EnhancedMasterAnimationCoordinator] Error in callback ${callback.id}:`, error);
            }
          }
        }
        /**
         * Execute animation systems with priority ordering and FPS throttling
         */
        executeAnimationSystems(deltaTime, timestamp) {
          const sortedSystems = Array.from(this.animations.values()).filter((animation) => animation.enabled).sort((a, b) => {
            const priorityOrder = { critical: 0, normal: 1, background: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
          });
          for (const animation of sortedSystems) {
            if (timestamp - animation.lastUpdate < animation.frameInterval) {
              animation.skippedFrames++;
              continue;
            }
            const systemStartTime = performance.now();
            try {
              if (animation.type === "visual") {
                animation.system.onAnimate(deltaTime, this.frameContext);
              } else {
                const animationSystem = animation.system;
                if (animationSystem.onAnimate) {
                  animationSystem.onAnimate(deltaTime);
                }
                if (animationSystem.updateAnimation) {
                  animationSystem.updateAnimation(timestamp, deltaTime);
                }
              }
              const systemTime = performance.now() - systemStartTime;
              animation.totalTime += systemTime;
              animation.frameCount++;
              animation.lastUpdate = timestamp;
              animation.averageFrameTime = animation.totalTime / animation.frameCount;
              animation.maxFrameTime = Math.max(animation.maxFrameTime, systemTime);
              if (systemTime > this.frameTimeBudget * 0.8) {
                if (this.config.enableDebug) {
                  console.warn(`[EnhancedMasterAnimationCoordinator] System ${animation.name} exceeded budget: ${systemTime.toFixed(2)}ms`);
                }
              }
            } catch (error) {
              console.error(`[EnhancedMasterAnimationCoordinator] Error in system ${animation.name}:`, error);
            }
          }
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics(frameTime) {
          this.metrics.totalFrames++;
          this.metrics.maxFrameTime = Math.max(this.metrics.maxFrameTime, frameTime);
          this.performanceHistory.push(frameTime);
          if (this.performanceHistory.length > this.MAX_HISTORY_SIZE) {
            this.performanceHistory.shift();
          }
          this.metrics.averageFrameTime = this.performanceHistory.reduce((sum, time) => sum + time, 0) / this.performanceHistory.length;
          this.metrics.frameRate = this.performanceHistory.length > 0 ? 1e3 / this.metrics.averageFrameTime : 60;
          if (frameTime > this.frameTimeBudget * 1.5) {
            this.metrics.droppedFrames++;
          }
          if (this.metrics.averageFrameTime > this.frameTimeBudget * 1.2 && this.metrics.performanceMode === "quality") {
            this.setPerformanceMode("performance");
            this.metrics.lastOptimization = Date.now();
          } else if (this.metrics.averageFrameTime < this.frameTimeBudget * 0.8 && this.metrics.performanceMode === "performance") {
            if (Date.now() - this.metrics.lastOptimization > 5e3) {
              this.setPerformanceMode("quality");
            }
          }
        }
        /**
         * Update frame budget based on performance mode
         */
        updateFrameBudget() {
          this.frameTimeBudget = this.metrics.performanceMode === "performance" ? 8 : 16;
          this.frameContext.frameBudget = this.frameTimeBudget;
        }
        /**
         * Update metrics counts
         */
        updateMetrics() {
          this.metrics.activeAnimations = Array.from(this.animations.values()).filter((a) => a.enabled).length;
          this.metrics.activeCallbacks = Array.from(this.frameCallbacks.values()).filter((c) => c.enabled).length;
        }
        /**
         * Subscribe to performance events
         */
        subscribeToEvents() {
          this.eventBus.subscribe("music:beat", (payload) => {
            this.frameContext.beatIntensity = payload.intensity || 0;
          });
          this.eventBus.subscribe("performance:throttle-updates", (payload) => {
            for (const animation of this.animations.values()) {
              if (animation.name === payload.subsystem || payload.subsystem === "*") {
                animation.frameInterval = Math.min(animation.frameInterval * 1.5, 33.33);
              }
            }
          });
          this.eventBus.subscribe("performance:reduce-quality", (payload) => {
            this.setPerformanceMode("performance");
          });
        }
        // =========================================================================
        // EMERGENT CHOREOGRAPHY ENGINE METHODS (from consolidation)
        // =========================================================================
        /**
         * Initialize emergent choreography functionality
         */
        async initializeEmergentChoreography() {
          try {
            this.signature = await temporalMemoryService.getSignature();
            this.registerEmergentEventListeners();
            this.saveInterval = setInterval(() => {
              if (this.signature) {
                temporalMemoryService.saveSignature(this.signature);
              }
            }, 3e4);
            if (this.config.enableDebug) {
              console.log("[EnhancedMasterAnimationCoordinator] Emergent choreography initialized");
            }
          } catch (error) {
            console.error("[EnhancedMasterAnimationCoordinator] Failed to initialize emergent choreography:", error);
          }
        }
        /**
         * Register emergent choreography event listeners
         */
        registerEmergentEventListeners() {
          const beatFrameSub = this.eventBus.subscribe(
            "beat/frame",
            (payload) => this.handleBeatFrame(payload)
          );
          const harmonyFrameSub = this.eventBus.subscribe(
            "colorharmony/frame",
            (payload) => this.handleHarmonyFrame(payload)
          );
          const bpmSub = this.eventBus.subscribe(
            "beat/bpm",
            (payload) => {
              this.currentBpm = payload.bpm;
            }
          );
          const intensitySub = this.eventBus.subscribe(
            "beat/intensity",
            (payload) => {
              this.currentIntensity = payload.intensity;
            }
          );
          this.emergentEventSubscriptions.push(
            beatFrameSub,
            harmonyFrameSub,
            bpmSub,
            intensitySub
          );
        }
        /**
         * Handle beat frame events for emergent adaptation
         */
        handleBeatFrame(payload) {
          if (!this.signature) return;
          this.signature.lastModified = Date.now();
        }
        /**
         * Handle harmony frame events for emergent adaptation
         */
        handleHarmonyFrame(payload) {
          if (!this.signature) return;
          const { kineticState } = payload;
          this.signature.lastModified = Date.now();
        }
        /**
         * Update evolutionary trajectory based on signature trends
         */
        async _updateEvolutionaryTrajectory() {
          if (!this.signature) return;
          const trends = await temporalMemoryService.getSignatureTrends(
            this.signature
          );
          if (!trends) return;
          const { avgEnergy, avgValence } = trends;
          const explorationFactor = 0.5 + (avgEnergy - 0.5) * 0.2;
          this.signature.evolutionaryTrajectory.explorationFactor = Math.max(
            0.1,
            Math.min(0.9, explorationFactor)
          );
          const adaptability = 0.5 + (Math.abs(avgValence) - 0.2) * 0.3;
          this.signature.evolutionaryTrajectory.adaptability = Math.max(
            0.1,
            Math.min(0.9, adaptability)
          );
          this.signature.evolutionaryTrajectory.lastUpdate = Date.now();
        }
        /**
         * Calculate visual pulse based on current BPM and intensity
         */
        _calculateVisualPulse(deltaMs) {
          const beatInterval = 6e4 / this.currentBpm;
          const phase = performance.now() % beatInterval / beatInterval;
          const hueShift = Math.sin(phase * 2 * Math.PI + Math.PI / 2) * 15 * this.currentIntensity;
          return {
            timestamp: performance.now(),
            bpm: this.currentBpm,
            intensity: this.currentIntensity,
            phase,
            hueShift
          };
        }
        /**
         * Calculate adaptive coefficients based on signature
         */
        _calculateAdaptiveCoefficients() {
          if (!this.signature) return;
          const { adaptability, explorationFactor } = this.signature.evolutionaryTrajectory;
          const kineticIntensity = 0.5 + adaptability * 0.5;
          const visualIntensityBase = 0.8 + explorationFactor * 0.4;
          this.currentMultipliers = {
            ...this.config.cosmicMultipliers,
            kineticIntensity,
            visualIntensityBase
          };
          this.eventBus.publish(
            "emergent/multipliersUpdated",
            this.currentMultipliers
          );
        }
        /**
         * Process emergent choreography tick within animation loop
         */
        processEmergentTick(deltaMs) {
          if (!this.signature) return;
          this._calculateAdaptiveCoefficients();
          if (this.signature && Date.now() - this.signature.evolutionaryTrajectory.lastUpdate > 6e4) {
            this._updateEvolutionaryTrajectory();
          }
          const visualPulse = this._calculateVisualPulse(deltaMs);
          if (visualPulse) {
            this.eventBus.publish("visual/pulse", visualPulse);
          }
          const emergentPayload = {
            timestamp: performance.now(),
            deltaMs
            // ...other emergent data to be calculated in later phases
          };
          this.eventBus.publish("emergent/frame", emergentPayload);
        }
        /**
         * Clean up emergent choreography resources
         */
        destroyEmergentChoreography() {
          if (this.signature) {
            temporalMemoryService.saveSignature(this.signature);
          }
          if (this.saveInterval) {
            clearInterval(this.saveInterval);
            this.saveInterval = null;
          }
          this.emergentEventSubscriptions.forEach((unsubscribe) => unsubscribe());
          this.emergentEventSubscriptions = [];
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Emergent choreography destroyed");
          }
        }
      };
      __name(_EnhancedMasterAnimationCoordinator, "EnhancedMasterAnimationCoordinator");
      _EnhancedMasterAnimationCoordinator.instance = null;
      EnhancedMasterAnimationCoordinator = _EnhancedMasterAnimationCoordinator;
    }
  });

  // src-js/core/css/UnifiedVariableGroups.ts
  function getVariableDefinition(variableName) {
    for (const [groupName, group] of Object.entries(UNIFIED_VARIABLE_GROUPS)) {
      for (const [varKey, definition] of Object.entries(group.variables)) {
        if (definition.name === variableName) {
          return {
            group: groupName,
            definition
          };
        }
      }
    }
    return null;
  }
  function getVariablesForGroup(groupName) {
    return UNIFIED_VARIABLE_GROUPS[groupName]?.variables || {};
  }
  function getCriticalVariables() {
    const criticalVars = [];
    for (const group of Object.values(UNIFIED_VARIABLE_GROUPS)) {
      for (const variable of Object.values(group.variables)) {
        if (variable.critical) {
          criticalVars.push(variable.name);
        }
      }
    }
    return criticalVars;
  }
  function convertLegacyVariable(legacyName) {
    return LEGACY_VARIABLE_MAPPINGS[legacyName] || legacyName;
  }
  function getGroupPriority(groupName) {
    return UNIFIED_VARIABLE_GROUPS[groupName]?.priority || "normal";
  }
  function validateVariableValue(variableName, value) {
    const definition = getVariableDefinition(variableName);
    if (!definition) return true;
    const { type } = definition.definition;
    switch (type) {
      case "number":
        return !isNaN(Number(value));
      case "boolean":
        return value === "0" || value === "1";
      case "time":
        return /^\d+(\.\d+)?(s|ms)$/.test(value);
      case "length":
        return /^\d+(\.\d+)?(px|em|rem|vh|vw|%)$/.test(value);
      case "angle":
        return /^\d+(\.\d+)?(deg|rad|turn)$/.test(value);
      case "percentage":
        return /^\d+(\.\d+)?%$/.test(value);
      case "color":
        return /^(#[0-9A-F]{6}|#[0-9A-F]{3}|\d+,\s*\d+,\s*\d+)$/i.test(value);
      case "string":
        return true;
      default:
        return true;
    }
  }
  var UNIFIED_VARIABLE_GROUPS, LEGACY_VARIABLE_MAPPINGS;
  var init_UnifiedVariableGroups = __esm({
    "src-js/core/css/UnifiedVariableGroups.ts"() {
      "use strict";
      UNIFIED_VARIABLE_GROUPS = {
        music: {
          name: "music",
          priority: "critical",
          description: "Real-time audio synchronization and beat detection",
          variables: {
            "beat.pulse.intensity": {
              name: "--sn-music-beat-pulse-intensity",
              defaultValue: "0",
              type: "number",
              description: "Current beat intensity (0-1)",
              critical: true
            },
            "beat.frequency": {
              name: "--sn-music-beat-frequency",
              defaultValue: "120",
              type: "number",
              description: "BPM value"
            },
            "beat.phase": {
              name: "--sn-music-beat-phase",
              defaultValue: "0",
              type: "number",
              description: "Current beat phase (0-1)"
            },
            "beat.confidence": {
              name: "--sn-music-beat-confidence",
              defaultValue: "0",
              type: "number",
              description: "Beat detection confidence (0-1)"
            },
            "spectrum.phase": {
              name: "--sn-music-spectrum-phase",
              defaultValue: "0deg",
              type: "angle",
              description: "Hue shift based on spectrum",
              critical: true
            },
            "spectrum.energy": {
              name: "--sn-music-spectrum-energy",
              defaultValue: "0",
              type: "number",
              description: "Overall energy level (0-1)"
            },
            "spectrum.bass": {
              name: "--sn-music-spectrum-bass",
              defaultValue: "0",
              type: "number",
              description: "Bass frequency energy (0-1)"
            },
            "spectrum.mids": {
              name: "--sn-music-spectrum-mids",
              defaultValue: "0",
              type: "number",
              description: "Mid frequency energy (0-1)"
            },
            "spectrum.treble": {
              name: "--sn-music-spectrum-treble",
              defaultValue: "0",
              type: "number",
              description: "Treble frequency energy (0-1)"
            },
            "breathing.scale": {
              name: "--sn-music-breathing-scale",
              defaultValue: "1",
              type: "number",
              description: "Breathing scale factor (0.95-1.05)",
              critical: true
            },
            "breathing.rate": {
              name: "--sn-music-breathing-rate",
              defaultValue: "4s",
              type: "time",
              description: "Breathing animation duration"
            },
            "rhythm.phase": {
              name: "--sn-music-rhythm-phase",
              defaultValue: "0",
              type: "number",
              description: "Rhythm phase (radians)",
              critical: true
            },
            "rhythm.intensity": {
              name: "--sn-music-rhythm-intensity",
              defaultValue: "0",
              type: "number",
              description: "Rhythm intensity (0-1)"
            },
            "tempo.bpm": {
              name: "--sn-music-tempo-bpm",
              defaultValue: "120",
              type: "number",
              description: "Current song BPM"
            },
            "energy.level": {
              name: "--sn-music-energy-level",
              defaultValue: "0.5",
              type: "number",
              description: "Song energy level (0-1)"
            },
            "valence": {
              name: "--sn-music-valence",
              defaultValue: "0.5",
              type: "number",
              description: "Song valence/mood (0-1)"
            },
            "danceability": {
              name: "--sn-music-danceability",
              defaultValue: "0.5",
              type: "number",
              description: "Song danceability (0-1)"
            }
          }
        },
        color: {
          name: "color",
          priority: "high",
          description: "Dynamic color extraction and palette management",
          variables: {
            "accent.hex": {
              name: "--sn-color-accent-hex",
              defaultValue: "#cba6f7",
              type: "color",
              description: "Current accent color (hex)",
              critical: true
            },
            "accent.rgb": {
              name: "--sn-color-accent-rgb",
              defaultValue: "203, 166, 247",
              type: "color",
              description: "Current accent color (RGB)",
              critical: true
            },
            "accent.hsl": {
              name: "--sn-color-accent-hsl",
              defaultValue: "267, 84%, 81%",
              type: "color",
              description: "Current accent color (HSL)"
            },
            "accent.oklch": {
              name: "--sn-color-accent-oklch",
              defaultValue: "0.75, 0.15, 295",
              type: "color",
              description: "Current accent color (OKLCH)"
            },
            "extracted.primary.rgb": {
              name: "--sn-color-extracted-primary-rgb",
              defaultValue: "203, 166, 247",
              type: "color",
              description: "Primary extracted color from album art"
            },
            "extracted.secondary.rgb": {
              name: "--sn-color-extracted-secondary-rgb",
              defaultValue: "166, 227, 161",
              type: "color",
              description: "Secondary extracted color from album art"
            },
            "extracted.tertiary.rgb": {
              name: "--sn-color-extracted-tertiary-rgb",
              defaultValue: "250, 179, 135",
              type: "color",
              description: "Tertiary extracted color from album art"
            },
            "extracted.dominant.rgb": {
              name: "--sn-color-extracted-dominant-rgb",
              defaultValue: "203, 166, 247",
              type: "color",
              description: "Dominant extracted color from album art"
            },
            "extracted.vibrant.rgb": {
              name: "--sn-color-extracted-vibrant-rgb",
              defaultValue: "203, 166, 247",
              type: "color",
              description: "Vibrant extracted color from album art"
            },
            "harmony.complementary.rgb": {
              name: "--sn-color-harmony-complementary-rgb",
              defaultValue: "166, 227, 161",
              type: "color",
              description: "Complementary color harmony"
            },
            "harmony.analogous.rgb": {
              name: "--sn-color-harmony-analogous-rgb",
              defaultValue: "243, 166, 247",
              type: "color",
              description: "Analogous color harmony"
            },
            "harmony.triadic.rgb": {
              name: "--sn-color-harmony-triadic-rgb",
              defaultValue: "247, 203, 166",
              type: "color",
              description: "Triadic color harmony"
            },
            "harmony.blend.intensity": {
              name: "--sn-color-harmony-blend-intensity",
              defaultValue: "0.8",
              type: "number",
              description: "Color harmony blend intensity (0-1)"
            },
            "shift.hue": {
              name: "--sn-color-shift-hue",
              defaultValue: "0deg",
              type: "angle",
              description: "Global hue shift"
            },
            "shift.saturation": {
              name: "--sn-color-shift-saturation",
              defaultValue: "1",
              type: "number",
              description: "Global saturation multiplier"
            },
            "shift.lightness": {
              name: "--sn-color-shift-lightness",
              defaultValue: "1",
              type: "number",
              description: "Global lightness multiplier"
            },
            "shift.temperature": {
              name: "--sn-color-shift-temperature",
              defaultValue: "0",
              type: "number",
              description: "Color temperature (-1 to 1)"
            }
          }
        },
        background: {
          name: "background",
          priority: "normal",
          description: "Gradient, WebGL, and background effects",
          variables: {
            "gradient.primary.rgb": {
              name: "--sn-bg-gradient-primary-rgb",
              defaultValue: "203, 166, 247",
              type: "color",
              description: "Primary gradient color"
            },
            "gradient.secondary.rgb": {
              name: "--sn-bg-gradient-secondary-rgb",
              defaultValue: "166, 227, 161",
              type: "color",
              description: "Secondary gradient color"
            },
            "gradient.tertiary.rgb": {
              name: "--sn-bg-gradient-tertiary-rgb",
              defaultValue: "250, 179, 135",
              type: "color",
              description: "Tertiary gradient color"
            },
            "gradient.opacity": {
              name: "--sn-bg-gradient-opacity",
              defaultValue: "0.15",
              type: "number",
              description: "Gradient opacity (0-1)"
            },
            "gradient.blur": {
              name: "--sn-bg-gradient-blur",
              defaultValue: "40px",
              type: "length",
              description: "Gradient blur radius"
            },
            "gradient.angle": {
              name: "--sn-bg-gradient-angle",
              defaultValue: "135deg",
              type: "angle",
              description: "Gradient angle"
            },
            "gradient.flow.direction": {
              name: "--sn-bg-gradient-flow-direction",
              defaultValue: "0deg",
              type: "angle",
              description: "Gradient flow direction"
            },
            "gradient.flow.speed": {
              name: "--sn-bg-gradient-flow-speed",
              defaultValue: "1",
              type: "number",
              description: "Gradient flow speed multiplier"
            },
            "webgl.ready": {
              name: "--sn-bg-webgl-ready",
              defaultValue: "0",
              type: "boolean",
              description: "WebGL system ready state (0/1)",
              critical: true
            },
            "webgl.quality": {
              name: "--sn-bg-webgl-quality",
              defaultValue: "1",
              type: "number",
              description: "WebGL quality level (0-1)"
            },
            "webgl.noise.scale": {
              name: "--sn-bg-webgl-noise-scale",
              defaultValue: "1",
              type: "number",
              description: "WebGL noise scale factor"
            },
            "webgl.noise.intensity": {
              name: "--sn-bg-webgl-noise-intensity",
              defaultValue: "0.1",
              type: "number",
              description: "WebGL noise intensity"
            },
            "webgl.flow.speed": {
              name: "--sn-bg-webgl-flow-speed",
              defaultValue: "0.5",
              type: "number",
              description: "WebGL flow animation speed"
            },
            "webgl.flow.direction": {
              name: "--sn-bg-webgl-flow-direction",
              defaultValue: "0deg",
              type: "angle",
              description: "WebGL flow direction"
            },
            "active-backend": {
              name: "--sn-bg-active-backend",
              defaultValue: "css",
              type: "string",
              description: "Active background backend (css/webgl)",
              critical: true
            },
            "transition.duration": {
              name: "--sn-bg-transition-duration",
              defaultValue: "0.8s",
              type: "time",
              description: "Background transition duration"
            },
            "transition.easing": {
              name: "--sn-bg-transition-easing",
              defaultValue: "ease-in-out",
              type: "string",
              description: "Background transition easing"
            }
          }
        },
        animation: {
          name: "animation",
          priority: "normal",
          description: "Animation coordination and effects",
          variables: {
            "duration.fast": {
              name: "--sn-anim-duration-fast",
              defaultValue: "0.2s",
              type: "time",
              description: "Fast animation duration"
            },
            "duration.normal": {
              name: "--sn-anim-duration-normal",
              defaultValue: "0.4s",
              type: "time",
              description: "Normal animation duration"
            },
            "duration.slow": {
              name: "--sn-anim-duration-slow",
              defaultValue: "0.8s",
              type: "time",
              description: "Slow animation duration"
            },
            "duration.breathing": {
              name: "--sn-anim-duration-breathing",
              defaultValue: "4s",
              type: "time",
              description: "Breathing animation duration"
            },
            "easing.standard": {
              name: "--sn-anim-easing-standard",
              defaultValue: "cubic-bezier(0.4, 0, 0.2, 1)",
              type: "string",
              description: "Standard easing function"
            },
            "easing.decelerate": {
              name: "--sn-anim-easing-decelerate",
              defaultValue: "cubic-bezier(0, 0, 0.2, 1)",
              type: "string",
              description: "Decelerate easing function"
            },
            "easing.accelerate": {
              name: "--sn-anim-easing-accelerate",
              defaultValue: "cubic-bezier(0.4, 0, 1, 1)",
              type: "string",
              description: "Accelerate easing function"
            },
            "easing.bounce": {
              name: "--sn-anim-easing-bounce",
              defaultValue: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
              type: "string",
              description: "Bounce easing function"
            },
            "motion.reduced": {
              name: "--sn-anim-motion-reduced",
              defaultValue: "0",
              type: "boolean",
              description: "Reduced motion preference (0/1)"
            },
            "motion.scale": {
              name: "--sn-anim-motion-scale",
              defaultValue: "1",
              type: "number",
              description: "Global animation scale factor"
            },
            "motion.blur": {
              name: "--sn-anim-motion-blur",
              defaultValue: "0",
              type: "number",
              description: "Motion blur intensity"
            },
            "frame.budget": {
              name: "--sn-anim-frame-budget",
              defaultValue: "16.67ms",
              type: "time",
              description: "Target frame budget"
            },
            "frame.priority": {
              name: "--sn-anim-frame-priority",
              defaultValue: "normal",
              type: "string",
              description: "Animation priority level"
            },
            "frame.fps": {
              name: "--sn-anim-frame-fps",
              defaultValue: "60",
              type: "number",
              description: "Target frames per second"
            }
          }
        },
        layout: {
          name: "layout",
          priority: "normal",
          description: "Layout, spacing, and responsive design",
          variables: {
            "sidebar.width": {
              name: "--sn-layout-sidebar-width",
              defaultValue: "280px",
              type: "length",
              description: "Sidebar width"
            },
            "sidebar.collapsed.width": {
              name: "--sn-layout-sidebar-collapsed-width",
              defaultValue: "72px",
              type: "length",
              description: "Collapsed sidebar width"
            },
            "sidebar.transition": {
              name: "--sn-layout-sidebar-transition",
              defaultValue: "0.3s",
              type: "time",
              description: "Sidebar transition duration"
            },
            "content.padding": {
              name: "--sn-layout-content-padding",
              defaultValue: "24px",
              type: "length",
              description: "Content padding"
            },
            "content.max-width": {
              name: "--sn-layout-content-max-width",
              defaultValue: "1200px",
              type: "length",
              description: "Content max width"
            },
            "content.gap": {
              name: "--sn-layout-content-gap",
              defaultValue: "16px",
              type: "length",
              description: "Content gap"
            },
            "card.border-radius": {
              name: "--sn-layout-card-border-radius",
              defaultValue: "12px",
              type: "length",
              description: "Card border radius"
            },
            "card.padding": {
              name: "--sn-layout-card-padding",
              defaultValue: "16px",
              type: "length",
              description: "Card padding"
            },
            "card.gap": {
              name: "--sn-layout-card-gap",
              defaultValue: "12px",
              type: "length",
              description: "Card gap"
            },
            "card.hover.lift": {
              name: "--sn-layout-card-hover-lift",
              defaultValue: "8px",
              type: "length",
              description: "Card hover lift distance"
            },
            "breakpoint.mobile": {
              name: "--sn-layout-breakpoint-mobile",
              defaultValue: "768px",
              type: "length",
              description: "Mobile breakpoint"
            },
            "breakpoint.tablet": {
              name: "--sn-layout-breakpoint-tablet",
              defaultValue: "1024px",
              type: "length",
              description: "Tablet breakpoint"
            },
            "breakpoint.desktop": {
              name: "--sn-layout-breakpoint-desktop",
              defaultValue: "1200px",
              type: "length",
              description: "Desktop breakpoint"
            }
          }
        },
        performance: {
          name: "performance",
          priority: "high",
          description: "Performance monitoring and optimization",
          variables: {
            "mode": {
              name: "--sn-perf-mode",
              defaultValue: "quality",
              type: "string",
              description: "Performance mode (quality/performance)"
            },
            "quality.level": {
              name: "--sn-perf-quality-level",
              defaultValue: "1",
              type: "number",
              description: "Quality level (0-1)"
            },
            "fps.target": {
              name: "--sn-perf-fps-target",
              defaultValue: "60",
              type: "number",
              description: "Target frames per second"
            },
            "frame.budget": {
              name: "--sn-perf-frame-budget",
              defaultValue: "16.67",
              type: "number",
              description: "Frame budget in milliseconds"
            },
            "gpu.acceleration.enabled": {
              name: "--sn-perf-gpu-acceleration-enabled",
              defaultValue: "1",
              type: "boolean",
              description: "GPU acceleration enabled (0/1)"
            },
            "gpu.memory.budget": {
              name: "--sn-perf-gpu-memory-budget",
              defaultValue: "100",
              type: "number",
              description: "GPU memory budget in MB"
            },
            "gpu.shader.quality": {
              name: "--sn-perf-gpu-shader-quality",
              defaultValue: "1",
              type: "number",
              description: "Shader quality level (0-1)"
            },
            "thermal.throttle": {
              name: "--sn-perf-thermal-throttle",
              defaultValue: "0",
              type: "boolean",
              description: "Thermal throttling active (0/1)"
            },
            "thermal.temperature": {
              name: "--sn-perf-thermal-temperature",
              defaultValue: "0",
              type: "number",
              description: "Estimated temperature (0-1)"
            },
            "thermal.threshold": {
              name: "--sn-perf-thermal-threshold",
              defaultValue: "0.8",
              type: "number",
              description: "Thermal threshold (0-1)"
            },
            "battery.saver": {
              name: "--sn-perf-battery-saver",
              defaultValue: "0",
              type: "boolean",
              description: "Battery saver mode (0/1)"
            },
            "battery.level": {
              name: "--sn-perf-battery-level",
              defaultValue: "1",
              type: "number",
              description: "Battery level (0-1)"
            },
            "battery.charging": {
              name: "--sn-perf-battery-charging",
              defaultValue: "0",
              type: "boolean",
              description: "Battery charging state (0/1)"
            }
          }
        },
        consciousness: {
          name: "consciousness",
          priority: "normal",
          description: "Consciousness fields and magnetic depth",
          variables: {
            "depth.field": {
              name: "--sn-consciousness-depth-field",
              defaultValue: "800px",
              type: "length",
              description: "3D perspective depth field"
            },
            "depth.near": {
              name: "--sn-consciousness-depth-near",
              defaultValue: "12px",
              type: "length",
              description: "Near depth distance"
            },
            "depth.far": {
              name: "--sn-consciousness-depth-far",
              defaultValue: "-10px",
              type: "length",
              description: "Far depth distance"
            },
            "depth.neutral": {
              name: "--sn-consciousness-depth-neutral",
              defaultValue: "0px",
              type: "length",
              description: "Neutral depth position"
            },
            "field.intensity": {
              name: "--sn-consciousness-field-intensity",
              defaultValue: "0.4",
              type: "number",
              description: "Consciousness field intensity (0-1)"
            },
            "field.breathing.rate": {
              name: "--sn-consciousness-field-breathing-rate",
              defaultValue: "12s",
              type: "time",
              description: "Consciousness field breathing rate"
            },
            "field.sensitivity": {
              name: "--sn-consciousness-field-sensitivity",
              defaultValue: "0.8",
              type: "number",
              description: "Field response sensitivity (0-1)"
            },
            "bilateral.left.lead": {
              name: "--sn-consciousness-bilateral-left-lead",
              defaultValue: "-150ms",
              type: "time",
              description: "Left sidebar lead time"
            },
            "bilateral.right.delay": {
              name: "--sn-consciousness-bilateral-right-delay",
              defaultValue: "150ms",
              type: "time",
              description: "Right sidebar delay"
            },
            "bilateral.sync": {
              name: "--sn-consciousness-bilateral-sync",
              defaultValue: "1",
              type: "boolean",
              description: "Bilateral sync enabled (0/1)"
            },
            "hover.pull": {
              name: "--sn-consciousness-hover-pull",
              defaultValue: "12px",
              type: "length",
              description: "Hover pull distance"
            },
            "focus.pull": {
              name: "--sn-consciousness-focus-pull",
              defaultValue: "18px",
              type: "length",
              description: "Focus pull distance"
            },
            "transition.speed": {
              name: "--sn-consciousness-transition-speed",
              defaultValue: "0.6s",
              type: "time",
              description: "Consciousness transition speed"
            }
          }
        },
        utility: {
          name: "utility",
          priority: "low",
          description: "Utility classes and helper variables",
          variables: {
            "debug.enabled": {
              name: "--sn-debug-enabled",
              defaultValue: "0",
              type: "boolean",
              description: "Debug mode enabled (0/1)"
            },
            "debug.verbose": {
              name: "--sn-debug-verbose",
              defaultValue: "0",
              type: "boolean",
              description: "Verbose debug mode (0/1)"
            },
            "debug.performance": {
              name: "--sn-debug-performance",
              defaultValue: "0",
              type: "boolean",
              description: "Performance debug mode (0/1)"
            },
            "debug.grid.visible": {
              name: "--sn-debug-grid-visible",
              defaultValue: "0",
              type: "boolean",
              description: "Debug grid visible (0/1)"
            },
            "a11y.contrast.enhanced": {
              name: "--sn-a11y-contrast-enhanced",
              defaultValue: "0",
              type: "boolean",
              description: "Enhanced contrast mode (0/1)"
            },
            "a11y.focus.visible": {
              name: "--sn-a11y-focus-visible",
              defaultValue: "1",
              type: "boolean",
              description: "Focus visible (0/1)"
            },
            "a11y.motion.reduced": {
              name: "--sn-a11y-motion-reduced",
              defaultValue: "0",
              type: "boolean",
              description: "Reduced motion preference (0/1)"
            },
            "a11y.text.size.scale": {
              name: "--sn-a11y-text-size-scale",
              defaultValue: "1",
              type: "number",
              description: "Text size scale factor"
            },
            "feature.webgl.enabled": {
              name: "--sn-feature-webgl-enabled",
              defaultValue: "1",
              type: "boolean",
              description: "WebGL features enabled (0/1)"
            },
            "feature.consciousness.enabled": {
              name: "--sn-feature-consciousness-enabled",
              defaultValue: "1",
              type: "boolean",
              description: "Consciousness features enabled (0/1)"
            },
            "feature.music.sync.enabled": {
              name: "--sn-feature-music-sync-enabled",
              defaultValue: "1",
              type: "boolean",
              description: "Music sync enabled (0/1)"
            },
            "feature.animations.enabled": {
              name: "--sn-feature-animations-enabled",
              defaultValue: "1",
              type: "boolean",
              description: "Animations enabled (0/1)"
            }
          }
        }
      };
      LEGACY_VARIABLE_MAPPINGS = {
        // Beat sync legacy mappings
        "--sn-beat-pulse-intensity": "--sn-music-beat-pulse-intensity",
        "--sn-rhythm-phase": "--sn-music-rhythm-phase",
        "--sn-spectrum-phase": "--sn-music-spectrum-phase",
        "--sn-breathing-scale": "--sn-music-breathing-scale",
        "--sn-feed-bloom-intensity": "--sn-music-beat-pulse-intensity",
        // Color legacy mappings
        "--sn-accent-hex": "--sn-color-accent-hex",
        "--sn-accent-rgb": "--sn-color-accent-rgb",
        "--sn-gradient-primary-rgb": "--sn-bg-gradient-primary-rgb",
        "--sn-gradient-secondary-rgb": "--sn-bg-gradient-secondary-rgb",
        "--sn-gradient-accent-rgb": "--sn-color-accent-rgb",
        // Background legacy mappings
        "--sn-gradient-opacity": "--sn-bg-gradient-opacity",
        "--sn-gradient-blur": "--sn-bg-gradient-blur",
        "--sn-gradient-transition": "--sn-bg-transition-duration",
        // Consciousness legacy mappings
        "--magnetic-depth-field": "--sn-consciousness-depth-field",
        "--magnetic-hover-pull": "--sn-consciousness-hover-pull",
        "--magnetic-focus-pull": "--sn-consciousness-focus-pull",
        "--magnetic-transition-speed": "--sn-consciousness-transition-speed",
        "--consciousness-field-intensity": "--sn-consciousness-field-intensity",
        "--consciousness-breathing-rate": "--sn-consciousness-field-breathing-rate",
        // Animation legacy mappings
        "--sn-transition-timing-default": "--sn-anim-easing-standard",
        "--sn-transition-duration-fast": "--sn-anim-duration-fast",
        "--sn-transition-duration-normal": "--sn-anim-duration-normal",
        "--sn-transition-duration-slow": "--sn-anim-duration-slow"
      };
      __name(getVariableDefinition, "getVariableDefinition");
      __name(getVariablesForGroup, "getVariablesForGroup");
      __name(getCriticalVariables, "getCriticalVariables");
      __name(convertLegacyVariable, "convertLegacyVariable");
      __name(getGroupPriority, "getGroupPriority");
      __name(validateVariableValue, "validateVariableValue");
    }
  });

  // src-js/core/css/UnifiedCSSVariableManager.ts
  var _UnifiedCSSVariableManager, UnifiedCSSVariableManager;
  var init_UnifiedCSSVariableManager = __esm({
    "src-js/core/css/UnifiedCSSVariableManager.ts"() {
      "use strict";
      init_EventBus();
      init_UnifiedVariableGroups();
      _UnifiedCSSVariableManager = class _UnifiedCSSVariableManager {
        constructor(config) {
          this.performanceAnalyzer = null;
          this.cssVariableBatcher = null;
          // Variable groups for organized management
          this.variableGroups = /* @__PURE__ */ new Map();
          // Transaction system for batch updates
          this.pendingTransactions = /* @__PURE__ */ new Map();
          this.transactionCounter = 0;
          // Update queue with priority handling
          this.updateQueue = /* @__PURE__ */ new Map();
          this.flushTimer = null;
          // Performance tracking
          this.performanceMetrics = {
            totalUpdates: 0,
            batchedUpdates: 0,
            conflictResolutions: 0,
            averageFlushTime: 0,
            transactionCount: 0,
            lastFlushTime: 0
          };
          // Configuration
          this.DEFAULT_BATCH_SIZE = 50;
          this.DEFAULT_FLUSH_INTERVAL = 16;
          // 60fps
          this.PRIORITY_WEIGHTS = {
            low: 1,
            normal: 2,
            high: 3,
            critical: 4
          };
          this.config = config;
          this.eventBus = GlobalEventBus;
          this.initializeDefaultGroups();
          this.subscribeToEvents();
          if (this.config.enableDebug) {
            console.log("[UnifiedCSSVariableManager] Created with centralized management");
          }
        }
        /**
         * Get or create singleton instance
         */
        static getInstance(config) {
          if (!_UnifiedCSSVariableManager.instance) {
            if (!config) {
              throw new Error("UnifiedCSSVariableManager requires config for first initialization");
            }
            _UnifiedCSSVariableManager.instance = new _UnifiedCSSVariableManager(config);
          }
          return _UnifiedCSSVariableManager.instance;
        }
        /**
         * Initialize with performance analyzer and CSS variable batcher
         */
        initialize(performanceAnalyzer, cssVariableBatcher) {
          this.performanceAnalyzer = performanceAnalyzer;
          this.cssVariableBatcher = cssVariableBatcher;
          if (this.config.enableDebug) {
            console.log("[UnifiedCSSVariableManager] Initialized with performance monitoring");
          }
        }
        /**
         * Queue a CSS variable update with priority
         */
        queueUpdate(property, value, priority = "normal", source = "unknown") {
          const unifiedProperty = convertLegacyVariable(property);
          let finalPriority = priority;
          if (priority === "normal") {
            const varDef = getVariableDefinition(unifiedProperty);
            if (varDef) {
              finalPriority = getGroupPriority(varDef.group);
            }
          }
          if (this.config.enableDebug && !validateVariableValue(unifiedProperty, value)) {
            console.warn(`[UnifiedCSSVariableManager] Invalid value for ${unifiedProperty}: ${value}`);
          }
          const update = {
            property: unifiedProperty,
            value,
            priority: finalPriority,
            timestamp: performance.now(),
            source
          };
          const existingUpdate = this.updateQueue.get(unifiedProperty);
          if (existingUpdate) {
            if (this.shouldReplaceUpdate(existingUpdate, update)) {
              this.updateQueue.set(unifiedProperty, update);
              this.performanceMetrics.conflictResolutions++;
            }
          } else {
            this.updateQueue.set(unifiedProperty, update);
          }
          this.performanceMetrics.totalUpdates++;
          this.scheduleFlush(finalPriority);
          if (this.config.enableDebug && finalPriority === "critical") {
            console.log(`[UnifiedCSSVariableManager] Critical update queued: ${unifiedProperty} = ${value}`);
          }
        }
        /**
         * Queue multiple CSS variable updates in a transaction
         */
        queueTransaction(variables, priority = "normal", source = "unknown") {
          const transactionId = `tx_${++this.transactionCounter}`;
          const variableMap = new Map(Object.entries(variables));
          const transaction = {
            id: transactionId,
            variables: variableMap,
            timestamp: performance.now(),
            priority,
            completed: false
          };
          this.pendingTransactions.set(transactionId, transaction);
          for (const [property, value] of variableMap) {
            this.queueUpdate(property, value, priority, `${source}:${transactionId}`);
          }
          this.performanceMetrics.transactionCount++;
          if (this.config.enableDebug) {
            console.log(`[UnifiedCSSVariableManager] Transaction ${transactionId} queued with ${variableMap.size} variables`);
          }
          return transactionId;
        }
        /**
         * Register a variable group for organized management
         */
        registerVariableGroup(name, priority = "normal", batchSize = this.DEFAULT_BATCH_SIZE, flushInterval = this.DEFAULT_FLUSH_INTERVAL) {
          const group = {
            name,
            variables: /* @__PURE__ */ new Map(),
            priority,
            batchSize,
            flushInterval
          };
          this.variableGroups.set(name, group);
          if (this.config.enableDebug) {
            console.log(`[UnifiedCSSVariableManager] Registered variable group: ${name}`);
          }
        }
        /**
         * Update variables in a specific group
         */
        updateVariableGroup(groupName, variables, source = "unknown") {
          const group = this.variableGroups.get(groupName);
          if (!group) {
            console.warn(`[UnifiedCSSVariableManager] Unknown variable group: ${groupName}`);
            return;
          }
          for (const [property, value] of Object.entries(variables)) {
            group.variables.set(property, value);
          }
          this.queueTransaction(variables, group.priority, `group:${groupName}:${source}`);
        }
        /**
         * Force immediate flush of all pending updates
         */
        forceFlush() {
          if (this.flushTimer) {
            clearTimeout(this.flushTimer);
            this.flushTimer = null;
          }
          this.flushUpdates();
        }
        /**
         * Get current performance metrics
         */
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Get current variable group status
         */
        getVariableGroups() {
          return new Map(this.variableGroups);
        }
        /**
         * Get pending transaction status
         */
        getPendingTransactions() {
          return new Map(this.pendingTransactions);
        }
        /**
         * Clear all pending updates (emergency reset)
         */
        clearPendingUpdates() {
          this.updateQueue.clear();
          this.pendingTransactions.clear();
          if (this.flushTimer) {
            clearTimeout(this.flushTimer);
            this.flushTimer = null;
          }
          if (this.config.enableDebug) {
            console.log("[UnifiedCSSVariableManager] Cleared all pending updates");
          }
        }
        // =========================================================================
        // UNIFIED VARIABLE GROUP CONVENIENCE METHODS
        // =========================================================================
        /**
         * Update music system variables
         */
        updateMusicVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-music-${key.replace(/\./g, "-")}`;
              updates[fullKey] = String(value);
            }
          }
          this.queueTransaction(updates, "critical", "music-system");
        }
        /**
         * Update color system variables
         */
        updateColorVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-color-${key.replace(/\./g, "-")}`;
              updates[fullKey] = String(value);
            }
          }
          this.queueTransaction(updates, "high", "color-system");
        }
        /**
         * Update background system variables
         */
        updateBackgroundVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-bg-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.queueTransaction(updates, "normal", "background-system");
        }
        /**
         * Update performance system variables
         */
        updatePerformanceVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-performance-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.queueTransaction(updates, "high", "performance-system");
        }
        /**
         * Update consciousness system variables
         */
        updateConsciousnessVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-consciousness-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.queueTransaction(updates, "normal", "consciousness-system");
        }
        /**
         * Update animation system variables
         */
        updateAnimationVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-anim-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.queueTransaction(updates, "normal", "animation-system");
        }
        /**
         * Update utility system variables
         */
        updateUtilityVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.queueTransaction(updates, "low", "utility-system");
        }
        /**
         * Get current value for a unified variable
         */
        getVariableValue(variableName) {
          const unifiedName = convertLegacyVariable(variableName);
          const computedStyle = getComputedStyle(document.documentElement);
          return computedStyle.getPropertyValue(unifiedName).trim() || null;
        }
        /**
         * Check if a variable is currently being updated
         */
        isVariablePending(variableName) {
          const unifiedName = convertLegacyVariable(variableName);
          return this.updateQueue.has(unifiedName);
        }
        /**
         * Get all variables in a specific group
         */
        getGroupVariables(groupName) {
          const variables = getVariablesForGroup(groupName);
          const result = {};
          for (const [key, variable] of Object.entries(variables)) {
            const value = this.getVariableValue(variable.name);
            if (value !== null) {
              result[key] = value;
            }
          }
          return result;
        }
        /**
         * Destroy the manager and clean up resources
         */
        destroy() {
          this.clearPendingUpdates();
          this.variableGroups.clear();
          if (_UnifiedCSSVariableManager.instance === this) {
            _UnifiedCSSVariableManager.instance = null;
          }
          if (this.config.enableDebug) {
            console.log("[UnifiedCSSVariableManager] Destroyed");
          }
        }
        // =========================================================================
        // PRIVATE METHODS
        // =========================================================================
        /**
         * Initialize default variable groups based on unified system architecture
         */
        initializeDefaultGroups() {
          this.variableGroups.clear();
          for (const [groupName, groupDef] of Object.entries(UNIFIED_VARIABLE_GROUPS)) {
            const batchSize = this.getBatchSizeForPriority(groupDef.priority);
            const flushInterval = this.getFlushIntervalForPriority(groupDef.priority);
            this.registerVariableGroup(groupName, groupDef.priority, batchSize, flushInterval);
            if (this.config.enableDebug) {
              console.log(`[UnifiedCSSVariableManager] Registered group: ${groupName} (${groupDef.priority})`);
            }
          }
          if (this.cssVariableBatcher) {
            const criticalVars = getCriticalVariables();
            for (const varName of criticalVars) {
              this.cssVariableBatcher.addCriticalVariable(varName);
            }
            if (this.config.enableDebug) {
              console.log(`[UnifiedCSSVariableManager] Registered ${criticalVars.length} critical variables`);
            }
          }
          if (this.config.enableDebug) {
            console.log("[UnifiedCSSVariableManager] Unified variable groups initialized");
          }
        }
        /**
         * Get batch size based on priority
         */
        getBatchSizeForPriority(priority) {
          switch (priority) {
            case "critical":
              return 10;
            case "high":
              return 25;
            case "normal":
              return 50;
            case "low":
              return 100;
            default:
              return 50;
          }
        }
        /**
         * Get flush interval based on priority
         */
        getFlushIntervalForPriority(priority) {
          switch (priority) {
            case "critical":
              return 4;
            case "high":
              return 8;
            case "normal":
              return 16;
            case "low":
              return 32;
            default:
              return 16;
          }
        }
        /**
         * Subscribe to relevant events
         */
        subscribeToEvents() {
          this.eventBus.subscribe("settings:css-variable-optimization", (payload) => {
            if (payload.enabled !== void 0) {
              if (this.config.enableDebug) {
                console.log(`[UnifiedCSSVariableManager] CSS variable optimization ${payload.enabled ? "enabled" : "disabled"}`);
              }
            }
          });
          this.eventBus.subscribe("performance:warning", (payload) => {
            if (payload.type === "css-variables") {
              this.adjustPerformanceProfile("low");
            }
          });
        }
        /**
         * Determine if an update should replace an existing one
         */
        shouldReplaceUpdate(existing, incoming) {
          const existingWeight = this.PRIORITY_WEIGHTS[existing.priority];
          const incomingWeight = this.PRIORITY_WEIGHTS[incoming.priority];
          if (incomingWeight > existingWeight) {
            return true;
          }
          if (incomingWeight === existingWeight) {
            return incoming.timestamp > existing.timestamp;
          }
          return false;
        }
        /**
         * Schedule flush based on priority
         */
        scheduleFlush(priority) {
          if (this.flushTimer) {
            if (priority === "critical") {
              this.forceFlush();
              return;
            }
            if (priority === "high") {
              clearTimeout(this.flushTimer);
              this.flushTimer = setTimeout(() => this.flushUpdates(), 8);
              return;
            }
            return;
          }
          const delay = this.getFlushDelay(priority);
          this.flushTimer = setTimeout(() => this.flushUpdates(), delay);
        }
        /**
         * Get flush delay based on priority
         */
        getFlushDelay(priority) {
          switch (priority) {
            case "critical":
              return 0;
            case "high":
              return 8;
            case "normal":
              return 16;
            case "low":
              return 32;
            default:
              return 16;
          }
        }
        /**
         * Flush all pending updates
         */
        flushUpdates() {
          if (this.updateQueue.size === 0) {
            this.flushTimer = null;
            return;
          }
          const startTime = performance.now();
          const updates = Array.from(this.updateQueue.values());
          updates.sort((a, b) => {
            const priorityDiff = this.PRIORITY_WEIGHTS[b.priority] - this.PRIORITY_WEIGHTS[a.priority];
            if (priorityDiff !== 0) return priorityDiff;
            return a.timestamp - b.timestamp;
          });
          const variables = {};
          for (const update of updates) {
            variables[update.property] = update.value;
          }
          if (this.cssVariableBatcher) {
            for (const [property, value] of Object.entries(variables)) {
              this.cssVariableBatcher.queueCSSVariableUpdate(property, value);
            }
            this.cssVariableBatcher.flushCSSVariableBatch();
          } else {
            for (const [property, value] of Object.entries(variables)) {
              document.documentElement.style.setProperty(property, value);
            }
          }
          for (const transaction of this.pendingTransactions.values()) {
            let allVariablesProcessed = true;
            for (const [property] of transaction.variables) {
              if (this.updateQueue.has(property)) {
                allVariablesProcessed = false;
                break;
              }
            }
            if (allVariablesProcessed) {
              transaction.completed = true;
            }
          }
          for (const [id, transaction] of this.pendingTransactions) {
            if (transaction.completed) {
              this.pendingTransactions.delete(id);
            }
          }
          this.updateQueue.clear();
          this.flushTimer = null;
          const flushTime = performance.now() - startTime;
          this.performanceMetrics.averageFlushTime = this.performanceMetrics.averageFlushTime * 0.9 + flushTime * 0.1;
          this.performanceMetrics.batchedUpdates += updates.length;
          this.performanceMetrics.lastFlushTime = Date.now();
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.recordMetric("css-variable-flush-time", flushTime);
            this.performanceAnalyzer.recordMetric("css-variable-batch-size", updates.length);
          }
          this.eventBus.publish("css-variables:flushed", {
            updateCount: updates.length,
            flushTime,
            timestamp: Date.now()
          });
          if (this.config.enableDebug && updates.length > 50) {
            console.log(`[UnifiedCSSVariableManager] Flushed ${updates.length} updates in ${flushTime.toFixed(2)}ms`);
          }
        }
        /**
         * Adjust performance profile based on system load
         */
        adjustPerformanceProfile(profile) {
          switch (profile) {
            case "low":
              for (const group of this.variableGroups.values()) {
                group.flushInterval = Math.max(group.flushInterval * 2, 64);
                group.batchSize = Math.min(group.batchSize * 2, 200);
              }
              break;
            case "normal":
              this.initializeDefaultGroups();
              break;
            case "high":
              for (const group of this.variableGroups.values()) {
                group.flushInterval = Math.max(group.flushInterval * 0.5, 4);
                group.batchSize = Math.max(group.batchSize * 0.5, 10);
              }
              break;
          }
          if (this.config.enableDebug) {
            console.log(`[UnifiedCSSVariableManager] Performance profile adjusted to ${profile}`);
          }
        }
      };
      __name(_UnifiedCSSVariableManager, "UnifiedCSSVariableManager");
      _UnifiedCSSVariableManager.instance = null;
      UnifiedCSSVariableManager = _UnifiedCSSVariableManager;
    }
  });

  // src-js/core/performance/UnifiedPerformanceCoordinator.ts
  var _UnifiedPerformanceCoordinator, UnifiedPerformanceCoordinator;
  var init_UnifiedPerformanceCoordinator = __esm({
    "src-js/core/performance/UnifiedPerformanceCoordinator.ts"() {
      "use strict";
      init_EventBus();
      _UnifiedPerformanceCoordinator = class _UnifiedPerformanceCoordinator {
        constructor(config, performanceAnalyzer) {
          // Subsystem tracking
          this.subsystemMetrics = /* @__PURE__ */ new Map();
          // Optimization management
          this.optimizationStrategies = /* @__PURE__ */ new Map();
          this.adaptiveOptimizationEnabled = false;
          this.optimizationInterval = null;
          // Issue tracking
          this.activeIssues = /* @__PURE__ */ new Map();
          this.issueHistory = [];
          // Health monitoring
          this.lastHealthCheck = 0;
          this.healthCheckInterval = null;
          this.HEALTH_CHECK_INTERVAL = 5e3;
          // Initialized in initializeThermalMonitoring
          this.batteryState = null;
          // Initialized in constructor
          this.frameTimeHistory = [];
          this.memoryUsageHistory = [];
          this.lastOptimizationTime = 0;
          this.optimizationCooldown = 5e3;
          // 5 seconds
          // Performance thresholds
          this.PERFORMANCE_THRESHOLDS = {
            frameTime: {
              warning: 16.67,
              // 60fps
              critical: 33.33
              // 30fps
            },
            memoryUsage: {
              warning: 50 * 1024 * 1024,
              // 50MB
              critical: 100 * 1024 * 1024
              // 100MB
            },
            cpuUsage: {
              warning: 15,
              // 15%
              critical: 30
              // 30%
            },
            fps: {
              warning: 50,
              critical: 30
            }
          };
          // Performance modes configuration (from PerformanceOptimizationManager)
          this.PERFORMANCE_MODES = {
            battery: {
              name: "battery",
              qualityLevel: 0.4,
              animationQuality: 0.3,
              effectQuality: 0.2,
              blurQuality: 0.3,
              shadowQuality: 0.2,
              frameRate: 30,
              optimizationLevel: 3
            },
            balanced: {
              name: "balanced",
              qualityLevel: 0.8,
              animationQuality: 0.8,
              effectQuality: 0.7,
              blurQuality: 0.8,
              shadowQuality: 0.7,
              frameRate: 60,
              optimizationLevel: 1
            },
            performance: {
              name: "performance",
              qualityLevel: 1,
              animationQuality: 1,
              effectQuality: 1,
              blurQuality: 1,
              shadowQuality: 1,
              frameRate: 60,
              optimizationLevel: 0
            },
            auto: {
              name: "auto",
              qualityLevel: 0.8,
              // Will be dynamically adjusted
              animationQuality: 0.8,
              effectQuality: 0.8,
              blurQuality: 0.8,
              shadowQuality: 0.8,
              frameRate: 60,
              optimizationLevel: 1
            }
          };
          this.config = config;
          this.performanceAnalyzer = performanceAnalyzer;
          this.eventBus = GlobalEventBus;
          this.initializeDeviceCapabilities();
          this.initializeThermalMonitoring();
          this.initializeBatteryMonitoring();
          this.currentPerformanceMode = this.PERFORMANCE_MODES.auto;
          this.initializeDefaultStrategies();
          this.startHealthMonitoring();
          this.subscribeToEvents();
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Initialized with enhanced device capabilities, thermal monitoring, and battery optimization");
          }
        }
        /**
         * Get or create singleton instance
         */
        static getInstance(config, performanceAnalyzer) {
          if (!_UnifiedPerformanceCoordinator.instance) {
            if (!config || !performanceAnalyzer) {
              throw new Error("UnifiedPerformanceCoordinator requires config and performanceAnalyzer for first initialization");
            }
            _UnifiedPerformanceCoordinator.instance = new _UnifiedPerformanceCoordinator(config, performanceAnalyzer);
          }
          return _UnifiedPerformanceCoordinator.instance;
        }
        /**
         * Track performance metrics for a subsystem
         */
        trackSubsystem(name, metrics) {
          const currentTime = performance.now();
          const existingMetrics = this.subsystemMetrics.get(name) || {
            name,
            frameTime: 0,
            memoryUsage: 0,
            cpuUsage: 0,
            fps: 60,
            lastUpdate: currentTime,
            status: "healthy",
            issues: []
          };
          const updatedMetrics = {
            ...existingMetrics,
            ...metrics,
            lastUpdate: currentTime
          };
          updatedMetrics.status = this.calculateHealthStatus(updatedMetrics);
          this.updateSubsystemIssues(updatedMetrics);
          this.subsystemMetrics.set(name, updatedMetrics);
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.recordMetric(`subsystem_${name}_frame_time`, updatedMetrics.frameTime);
            this.performanceAnalyzer.recordMetric(`subsystem_${name}_memory`, updatedMetrics.memoryUsage);
            this.performanceAnalyzer.recordMetric(`subsystem_${name}_fps`, updatedMetrics.fps);
          }
          if (this.adaptiveOptimizationEnabled && updatedMetrics.status !== "healthy") {
            this.checkAndTriggerOptimization(updatedMetrics);
          }
          if (this.config.enableDebug && updatedMetrics.status !== "healthy") {
            console.warn(`[UnifiedPerformanceCoordinator] Subsystem ${name} status: ${updatedMetrics.status}`, updatedMetrics);
          }
        }
        /**
         * Get comprehensive system health report
         */
        getSystemHealth() {
          const currentTime = performance.now();
          const subsystems = new Map(this.subsystemMetrics);
          let healthyCount = 0;
          let warningCount = 0;
          let criticalCount = 0;
          for (const metrics of subsystems.values()) {
            switch (metrics.status) {
              case "healthy":
                healthyCount++;
                break;
              case "warning":
                warningCount++;
                break;
              case "critical":
                criticalCount++;
                break;
            }
          }
          const totalSubsystems = subsystems.size;
          let overall = "healthy";
          if (criticalCount > 0) {
            overall = "critical";
          } else if (warningCount > 0) {
            overall = "warning";
          }
          const performanceScore = this.calculatePerformanceScore(subsystems);
          const recommendations = this.generateRecommendations(subsystems);
          const healthReport = {
            overall,
            totalSubsystems,
            healthySubsystems: healthyCount,
            warningSubsystems: warningCount,
            criticalSubsystems: criticalCount,
            subsystems,
            recommendations,
            performanceScore,
            lastUpdate: currentTime
          };
          this.lastHealthCheck = currentTime;
          this.eventBus.publish("performance:health-report", healthReport);
          return healthReport;
        }
        /**
         * Enable adaptive optimization
         */
        enableAdaptiveOptimization() {
          if (this.adaptiveOptimizationEnabled) return;
          this.adaptiveOptimizationEnabled = true;
          this.optimizationInterval = setInterval(() => {
            this.performOptimizationCheck();
          }, 2e3);
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Adaptive optimization enabled");
          }
          this.eventBus.publish("performance:optimization-enabled", {
            timestamp: Date.now(),
            strategies: Array.from(this.optimizationStrategies.keys())
          });
        }
        /**
         * Disable adaptive optimization
         */
        disableAdaptiveOptimization() {
          if (!this.adaptiveOptimizationEnabled) return;
          this.adaptiveOptimizationEnabled = false;
          if (this.optimizationInterval) {
            clearInterval(this.optimizationInterval);
            this.optimizationInterval = null;
          }
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Adaptive optimization disabled");
          }
          this.eventBus.publish("performance:optimization-disabled", {
            timestamp: Date.now()
          });
        }
        /**
         * Register an optimization strategy
         */
        registerOptimizationStrategy(strategy) {
          this.optimizationStrategies.set(strategy.name, strategy);
          if (this.config.enableDebug) {
            console.log(`[UnifiedPerformanceCoordinator] Registered optimization strategy: ${strategy.name}`);
          }
        }
        /**
         * Trigger optimization for a specific issue
         */
        triggerOptimization(issue) {
          this.activeIssues.set(`${issue.subsystem}:${issue.type}`, issue);
          this.issueHistory.push(issue);
          if (this.issueHistory.length > 100) {
            this.issueHistory.shift();
          }
          const applicableStrategies = Array.from(this.optimizationStrategies.values()).filter((strategy) => strategy.subsystem === issue.subsystem || strategy.subsystem === "*").sort((a, b) => b.priority - a.priority);
          for (const strategy of applicableStrategies) {
            const subsystemMetrics = this.subsystemMetrics.get(issue.subsystem);
            if (subsystemMetrics && strategy.condition(subsystemMetrics)) {
              try {
                strategy.action(subsystemMetrics);
                if (this.config.enableDebug) {
                  console.log(`[UnifiedPerformanceCoordinator] Applied optimization strategy: ${strategy.name} for ${issue.subsystem}`);
                }
                this.eventBus.publish("performance:optimization-applied", {
                  issue,
                  strategy: strategy.name,
                  timestamp: Date.now()
                });
                break;
              } catch (error) {
                console.error(`[UnifiedPerformanceCoordinator] Error applying optimization strategy ${strategy.name}:`, error);
              }
            }
          }
        }
        /**
         * Get current performance metrics for debugging
         */
        getMetrics() {
          return {
            subsystems: new Map(this.subsystemMetrics),
            issues: new Map(this.activeIssues),
            strategies: new Map(this.optimizationStrategies),
            adaptiveOptimizationEnabled: this.adaptiveOptimizationEnabled
          };
        }
        /**
         * Destroy the coordinator and clean up resources
         */
        destroy() {
          this.disableAdaptiveOptimization();
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          this.subsystemMetrics.clear();
          this.optimizationStrategies.clear();
          this.activeIssues.clear();
          this.issueHistory = [];
          if (_UnifiedPerformanceCoordinator.instance === this) {
            _UnifiedPerformanceCoordinator.instance = null;
          }
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Destroyed");
          }
        }
        // =========================================================================
        // PRIVATE METHODS
        // =========================================================================
        /**
         * Initialize default optimization strategies
         */
        initializeDefaultStrategies() {
          this.registerOptimizationStrategy({
            name: "memory-cleanup",
            type: "memory_cleanup",
            priority: 100,
            subsystem: "*",
            description: "Trigger garbage collection and memory cleanup",
            condition: /* @__PURE__ */ __name((metrics) => metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
              this.eventBus.publish("performance:memory-cleanup", {
                subsystem: metrics.name,
                memoryUsage: metrics.memoryUsage,
                timestamp: Date.now()
              });
            }, "action")
          });
          this.registerOptimizationStrategy({
            name: "fps-optimization",
            type: "reduce_quality",
            priority: 80,
            subsystem: "*",
            description: "Reduce quality settings to improve FPS",
            condition: /* @__PURE__ */ __name((metrics) => metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
              this.eventBus.publish("performance:reduce-quality", {
                subsystem: metrics.name,
                fps: metrics.fps,
                timestamp: Date.now()
              });
            }, "action")
          });
          this.registerOptimizationStrategy({
            name: "cpu-throttling",
            type: "throttle_updates",
            priority: 70,
            subsystem: "*",
            description: "Throttle update frequency to reduce CPU usage",
            condition: /* @__PURE__ */ __name((metrics) => metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
              this.eventBus.publish("performance:throttle-updates", {
                subsystem: metrics.name,
                cpuUsage: metrics.cpuUsage,
                timestamp: Date.now()
              });
            }, "action")
          });
        }
        /**
         * Calculate health status for subsystem
         */
        calculateHealthStatus(metrics) {
          const issues = [];
          if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.critical) {
            issues.push("critical-frame-time");
          } else if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.warning) {
            issues.push("warning-frame-time");
          }
          if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.critical) {
            issues.push("critical-memory");
          } else if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning) {
            issues.push("warning-memory");
          }
          if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.critical) {
            issues.push("critical-cpu");
          } else if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning) {
            issues.push("warning-cpu");
          }
          if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.critical) {
            issues.push("critical-fps");
          } else if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning) {
            issues.push("warning-fps");
          }
          metrics.issues = issues;
          if (issues.some((issue) => issue.startsWith("critical"))) {
            return "critical";
          } else if (issues.some((issue) => issue.startsWith("warning"))) {
            return "warning";
          } else {
            return "healthy";
          }
        }
        /**
         * Update subsystem issues based on thresholds
         */
        updateSubsystemIssues(metrics) {
          const issueKey = `${metrics.name}:performance`;
          if (metrics.status === "healthy") {
            if (this.activeIssues.has(issueKey)) {
              const issue = this.activeIssues.get(issueKey);
              issue.resolved = true;
              this.activeIssues.delete(issueKey);
            }
          } else {
            const issue = {
              type: "render",
              severity: metrics.status === "critical" ? "critical" : "medium",
              subsystem: metrics.name,
              message: `Performance degradation detected: ${metrics.issues.join(", ")}`,
              timestamp: Date.now(),
              resolved: false
            };
            this.activeIssues.set(issueKey, issue);
          }
        }
        /**
         * Check and trigger optimization if needed
         */
        checkAndTriggerOptimization(metrics) {
          const issueKey = `${metrics.name}:performance`;
          const issue = this.activeIssues.get(issueKey);
          if (issue && !issue.resolved) {
            this.triggerOptimization(issue);
          }
        }
        /**
         * Perform periodic optimization check
         */
        performOptimizationCheck() {
          const currentTime = performance.now();
          for (const [name, metrics] of this.subsystemMetrics) {
            if (currentTime - metrics.lastUpdate > 1e4) {
              continue;
            }
            if (metrics.status !== "healthy") {
              this.checkAndTriggerOptimization(metrics);
            }
          }
        }
        /**
         * Calculate overall performance score
         */
        calculatePerformanceScore(subsystems) {
          if (subsystems.size === 0) return 100;
          let totalScore = 0;
          for (const metrics of subsystems.values()) {
            let subsystemScore = 100;
            if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.warning) {
              subsystemScore -= 20;
            }
            if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.critical) {
              subsystemScore -= 30;
            }
            if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning) {
              subsystemScore -= 15;
            }
            if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.critical) {
              subsystemScore -= 25;
            }
            if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning) {
              subsystemScore -= 10;
            }
            if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.critical) {
              subsystemScore -= 20;
            }
            if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning) {
              subsystemScore -= 15;
            }
            if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.critical) {
              subsystemScore -= 25;
            }
            totalScore += Math.max(0, subsystemScore);
          }
          return Math.round(totalScore / subsystems.size);
        }
        /**
         * Generate recommendations based on system health
         */
        generateRecommendations(subsystems) {
          const recommendations = [];
          const allIssues = Array.from(subsystems.values()).flatMap((metrics) => metrics.issues);
          const issueCounts = /* @__PURE__ */ new Map();
          for (const issue of allIssues) {
            issueCounts.set(issue, (issueCounts.get(issue) || 0) + 1);
          }
          for (const [issue, count] of issueCounts) {
            if (count >= 2) {
              switch (issue) {
                case "critical-frame-time":
                case "warning-frame-time":
                  recommendations.push("Consider reducing animation quality or frequency");
                  break;
                case "critical-memory":
                case "warning-memory":
                  recommendations.push("Memory cleanup needed - consider reducing cache sizes");
                  break;
                case "critical-cpu":
                case "warning-cpu":
                  recommendations.push("High CPU usage detected - consider throttling updates");
                  break;
                case "critical-fps":
                case "warning-fps":
                  recommendations.push("Low FPS detected - consider disabling non-essential effects");
                  break;
              }
            }
          }
          if (recommendations.length === 0) {
            recommendations.push("System performance is optimal");
          }
          return recommendations;
        }
        /**
         * Start health monitoring
         */
        startHealthMonitoring() {
          this.healthCheckInterval = setInterval(() => {
            this.getSystemHealth();
          }, this.HEALTH_CHECK_INTERVAL);
        }
        /**
         * Subscribe to performance events
         */
        subscribeToEvents() {
          this.eventBus.subscribe("performance:memory-warning", (payload) => {
            if (payload.subsystem) {
              this.triggerOptimization({
                type: "memory",
                severity: "high",
                subsystem: payload.subsystem,
                message: `Memory usage warning: ${payload.usage}MB`,
                timestamp: Date.now(),
                resolved: false
              });
            }
          });
          this.eventBus.subscribe("performance:fps-drop", (payload) => {
            if (payload.subsystem) {
              this.triggerOptimization({
                type: "fps",
                severity: "medium",
                subsystem: payload.subsystem,
                message: `FPS drop detected: ${payload.fps}`,
                timestamp: Date.now(),
                resolved: false
              });
            }
          });
        }
        // ===============================================================================
        // ENHANCED CAPABILITIES FROM PERFORMANCEOPTIMIZATIONMANAGER CONSOLIDATION
        // ===============================================================================
        /**
         * Initialize device capabilities detection
         */
        initializeDeviceCapabilities() {
          const nav = navigator;
          const memory = performance.memory;
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
          let maxTextureSize = 2048;
          if (gl) {
            maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE) || 2048;
          }
          const estimatedMemory = memory ? Math.round(memory.jsHeapSizeLimit / (1024 * 1024 * 1024)) : 4;
          let performanceTier = "medium";
          if (estimatedMemory >= 8 && nav.hardwareConcurrency >= 8 && maxTextureSize >= 4096) {
            performanceTier = "premium";
          } else if (estimatedMemory >= 4 && nav.hardwareConcurrency >= 4) {
            performanceTier = "high";
          } else if (estimatedMemory >= 2 && nav.hardwareConcurrency >= 2) {
            performanceTier = "medium";
          } else {
            performanceTier = "low";
          }
          this.deviceCapabilities = {
            performanceTier,
            memoryGB: estimatedMemory,
            cpuCores: nav.hardwareConcurrency || 4,
            gpuAcceleration: !!gl,
            isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(nav.userAgent),
            supportsWebGL: !!gl,
            supportsBackdropFilter: CSS.supports("backdrop-filter", "blur(10px)"),
            maxTextureSize,
            devicePixelRatio: window.devicePixelRatio || 1
          };
          if (this.config.enableDebug) {
            console.log("[UnifiedPerformanceCoordinator] Device capabilities detected:", this.deviceCapabilities);
          }
        }
        /**
         * Initialize thermal state monitoring
         */
        initializeThermalMonitoring() {
          this.thermalState = {
            temperature: "normal",
            throttleLevel: 0,
            cpuUsage: 0,
            gpuUsage: 0,
            memoryUsage: 0
          };
          setInterval(() => {
            this.updateThermalState();
          }, 1e4);
        }
        /**
         * Initialize battery monitoring if available
         */
        async initializeBatteryMonitoring() {
          try {
            const nav = navigator;
            if ("getBattery" in nav) {
              const battery = await nav.getBattery();
              this.batteryState = {
                level: battery.level,
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
              };
              battery.addEventListener("levelchange", () => {
                if (this.batteryState) {
                  this.batteryState.level = battery.level;
                  this.adjustPerformanceModeForBattery();
                }
              });
              battery.addEventListener("chargingchange", () => {
                if (this.batteryState) {
                  this.batteryState.charging = battery.charging;
                  this.adjustPerformanceModeForBattery();
                }
              });
              if (this.config.enableDebug) {
                console.log("[UnifiedPerformanceCoordinator] Battery monitoring initialized");
              }
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.log("[UnifiedPerformanceCoordinator] Battery API not available");
            }
          }
        }
        /**
         * Update thermal state based on performance metrics
         */
        updateThermalState() {
          const currentFPS = this.performanceAnalyzer.getMedianFPS() || 60;
          const memory = performance.memory;
          const memoryUsage = memory ? memory.usedJSHeapSize / memory.jsHeapSizeLimit : 0;
          let temperature = "normal";
          let throttleLevel = 0;
          if (currentFPS < 30 || memoryUsage > 0.9) {
            temperature = "critical";
            throttleLevel = 0.8;
          } else if (currentFPS < 45 || memoryUsage > 0.7) {
            temperature = "hot";
            throttleLevel = 0.4;
          } else if (currentFPS < 55 || memoryUsage > 0.5) {
            temperature = "warm";
            throttleLevel = 0.2;
          }
          this.thermalState = {
            temperature,
            throttleLevel,
            cpuUsage: Math.min(1 - currentFPS / 60, 1),
            gpuUsage: 0,
            // TODO: Implement GPU usage detection
            memoryUsage
          };
          if (temperature === "critical" && this.currentPerformanceMode.name !== "battery") {
            this.setPerformanceMode("battery");
          } else if (temperature === "normal" && this.currentPerformanceMode.name === "battery") {
            this.setPerformanceMode("auto");
          }
        }
        /**
         * Adjust performance mode based on battery state
         */
        adjustPerformanceModeForBattery() {
          if (!this.batteryState) return;
          if (!this.batteryState.charging && this.batteryState.level < 0.2) {
            this.setPerformanceMode("battery");
          } else if (this.batteryState.charging && this.currentPerformanceMode.name === "battery") {
            this.setPerformanceMode("auto");
          }
        }
        /**
         * Set performance mode
         */
        setPerformanceMode(modeName) {
          const mode = this.PERFORMANCE_MODES[modeName];
          if (!mode) return;
          this.currentPerformanceMode = mode;
          this.eventBus.emit("performance:mode-changed", {
            mode: modeName,
            qualityLevel: mode.qualityLevel,
            frameRate: mode.frameRate
          });
          if (this.config.enableDebug) {
            console.log(`[UnifiedPerformanceCoordinator] Performance mode changed to: ${modeName}`);
          }
        }
        /**
         * Get current device capabilities
         */
        getDeviceCapabilities() {
          return { ...this.deviceCapabilities };
        }
        /**
         * Get current thermal state
         */
        getThermalState() {
          return { ...this.thermalState };
        }
        /**
         * Get current battery state
         */
        getBatteryState() {
          return this.batteryState ? { ...this.batteryState } : null;
        }
        /**
         * Get current performance mode
         */
        getCurrentPerformanceMode() {
          return { ...this.currentPerformanceMode };
        }
      };
      __name(_UnifiedPerformanceCoordinator, "UnifiedPerformanceCoordinator");
      _UnifiedPerformanceCoordinator.instance = null;
      UnifiedPerformanceCoordinator = _UnifiedPerformanceCoordinator;
    }
  });

  // src-js/core/base/UnifiedSystemBase.ts
  var _UnifiedSystemBase, UnifiedSystemBase;
  var init_UnifiedSystemBase = __esm({
    "src-js/core/base/UnifiedSystemBase.ts"() {
      "use strict";
      init_PerformanceAnalyzer();
      init_CSSVariableBatcher();
      init_EventBus();
      init_EnhancedMasterAnimationCoordinator();
      init_UnifiedCSSVariableManager();
      init_UnifiedPerformanceCoordinator();
      init_globalConfig();
      _UnifiedSystemBase = class _UnifiedSystemBase {
        constructor(config = YEAR3000_CONFIG) {
          // Core lifecycle state
          this.initialized = false;
          this.destroyed = false;
          // Event management
          this.eventUnsubscribers = [];
          // Performance tracking
          this.initializationStartTime = null;
          this.frameStartTime = 0;
          this.frameCount = 0;
          this.lastFPSCalculation = 0;
          this.currentFPS = 60;
          this.config = config;
          this.systemName = this.constructor.name;
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] UnifiedSystemBase constructor`);
          }
        }
        // =========================================================================
        // UNIFIED LIFECYCLE MANAGEMENT
        // =========================================================================
        /**
         * Base initialization - sets up shared utilities and calls system-specific init
         */
        async _baseInitialize() {
          if (this.initialized) {
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Already initialized`);
            }
            return;
          }
          try {
            this.initializationStartTime = performance.now();
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Starting unified initialization`);
            }
            const globalSystem = globalThis.year3000System;
            if (globalSystem) {
              this.performanceAnalyzer = globalSystem.performanceAnalyzer || new PerformanceAnalyzer();
              this.cssVariableBatcher = globalSystem.cssVariableBatcher || CSSVariableBatcher.getInstance();
              this.eventBus = GlobalEventBus;
              this.animationCoordinator = globalSystem.enhancedMasterAnimationCoordinator || EnhancedMasterAnimationCoordinator.getInstance();
              this.unifiedCSSManager = globalSystem.unifiedCSSManager || UnifiedCSSVariableManager.getInstance(this.config);
              this.performanceCoordinator = globalSystem.performanceCoordinator || UnifiedPerformanceCoordinator.getInstance(this.config, this.performanceAnalyzer);
            } else {
              this.performanceAnalyzer = new PerformanceAnalyzer();
              this.cssVariableBatcher = CSSVariableBatcher.getInstance();
              this.eventBus = GlobalEventBus;
              this.animationCoordinator = EnhancedMasterAnimationCoordinator.getInstance();
              this.unifiedCSSManager = UnifiedCSSVariableManager.getInstance(this.config);
              this.performanceCoordinator = UnifiedPerformanceCoordinator.getInstance(this.config, this.performanceAnalyzer);
            }
            if (this.unifiedCSSManager && this.performanceAnalyzer && this.cssVariableBatcher) {
              this.unifiedCSSManager.initialize(this.performanceAnalyzer, this.cssVariableBatcher);
            }
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.recordMetric === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_registered`, 1);
            }
            await this.trackPerformanceAsync("initialize", async () => {
              await this.initialize();
            });
            this.initialized = true;
            this.publishEvent("system:initialized", {
              systemName: this.systemName,
              timestamp: Date.now(),
              initializationTime: this.initializationStartTime ? performance.now() - this.initializationStartTime : 0
            });
            if (this.config.enableDebug) {
              const duration = this.initializationStartTime ? performance.now() - this.initializationStartTime : 0;
              console.log(`[${this.systemName}] Unified initialization complete (${duration.toFixed(2)}ms)`);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Initialization failed:`, error);
            this.publishEvent("system:initialization-failed", {
              systemName: this.systemName,
              error: error instanceof Error ? error.message : String(error),
              timestamp: Date.now()
            });
            throw error;
          }
        }
        /**
         * Base destruction - handles cleanup and calls system-specific destroy
         */
        _baseDestroy() {
          if (this.destroyed) {
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Already destroyed`);
            }
            return;
          }
          try {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Starting unified destruction`);
            }
            this.eventUnsubscribers.forEach((unsubscribe) => {
              try {
                unsubscribe();
              } catch (error) {
                console.warn(`[${this.systemName}] Error during event unsubscription:`, error);
              }
            });
            this.eventUnsubscribers = [];
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.recordMetric === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_unregistered`, 1);
            }
            this.destroy();
            this.destroyed = true;
            this.publishEvent("system:destroyed", {
              systemName: this.systemName,
              timestamp: Date.now()
            });
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Unified destruction complete`);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Destruction failed:`, error);
          }
        }
        // =========================================================================
        // SHARED UTILITY METHODS
        // =========================================================================
        /**
         * Update a single CSS variable with priority support
         */
        updateCSSVariable(property, value, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueUpdate(property, value, priority, this.systemName);
          } else if (this.cssVariableBatcher) {
            this.cssVariableBatcher.queueCSSVariableUpdate(property, value);
          } else {
            console.warn(`[${this.systemName}] CSS variable management not initialized`);
          }
        }
        /**
         * Update multiple CSS variables efficiently with priority support
         */
        updateCSSVariables(updates, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueTransaction(updates, priority, this.systemName);
          } else if (this.cssVariableBatcher) {
            Object.entries(updates).forEach(([property, value]) => {
              this.cssVariableBatcher.queueCSSVariableUpdate(property, value);
            });
          } else {
            console.warn(`[${this.systemName}] CSS variable management not initialized`);
          }
        }
        /**
         * Subscribe to events with automatic cleanup
         */
        subscribeToEvent(event, callback) {
          if (!this.eventBus) {
            console.warn(`[${this.systemName}] Event bus not initialized`);
            return () => {
            };
          }
          const unsubscribe = this.eventBus.subscribe(event, callback);
          this.eventUnsubscribers.push(unsubscribe);
          return unsubscribe;
        }
        /**
         * Publish events to the global event bus
         */
        publishEvent(event, payload) {
          if (!this.eventBus) {
            console.warn(`[${this.systemName}] Event bus not initialized`);
            return;
          }
          this.eventBus.publish(event, payload);
        }
        /**
         * Track performance of synchronous operations
         */
        trackPerformance(operation, fn) {
          const startTime = performance.now();
          try {
            fn();
          } finally {
            const endTime = performance.now();
            const frameTime = endTime - startTime;
            this.trackSystemPerformance(frameTime);
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.timeOperation === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_${operation}`, frameTime);
            }
          }
        }
        /**
         * Track performance of asynchronous operations
         */
        async trackPerformanceAsync(operation, fn) {
          if (!this.performanceAnalyzer || typeof this.performanceAnalyzer.timeOperationAsync !== "function") {
            await fn();
            return;
          }
          await this.performanceAnalyzer.timeOperationAsync(`${this.systemName}_${operation}`, fn);
        }
        /**
         * Track system performance metrics
         */
        trackSystemPerformance(frameTime) {
          if (!this.performanceCoordinator) return;
          this.frameCount++;
          const currentTime = performance.now();
          if (currentTime - this.lastFPSCalculation >= 1e3) {
            this.currentFPS = this.frameCount;
            this.frameCount = 0;
            this.lastFPSCalculation = currentTime;
          }
          const memoryUsage = performance.memory?.usedJSHeapSize || 0;
          this.performanceCoordinator.trackSubsystem(this.systemName, {
            frameTime,
            memoryUsage,
            fps: this.currentFPS,
            cpuUsage: frameTime > 16.67 ? Math.min(100, frameTime / 16.67 * 5) : 0
            // Rough estimate
          });
        }
        /**
         * Register with animation coordinator
         */
        registerAnimation(priority = 60) {
          if (!this.animationCoordinator) {
            console.warn(`[${this.systemName}] Animation coordinator not initialized`);
            return;
          }
          this.animationCoordinator.registerAnimationSystem(
            this.systemName,
            this,
            "normal",
            priority
          );
        }
        /**
         * Force a repaint - useful for settings changes
         */
        forceRepaint(reason) {
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.emitTrace(`[${this.systemName}] Force repaint: ${reason || "unknown"}`);
          }
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.forceFlush();
          }
          document.documentElement.style.transform = "translateZ(0)";
          requestAnimationFrame(() => {
            document.documentElement.style.transform = "";
          });
        }
        // =========================================================================
        // UTILITY GETTERS AND STATUS
        // =========================================================================
        /**
         * Check if system is initialized
         */
        get isInitialized() {
          return this.initialized;
        }
        /**
         * Check if system is destroyed
         */
        get isDestroyed() {
          return this.destroyed;
        }
        /**
         * Get system name
         */
        get name() {
          return this.systemName;
        }
        /**
         * Get system configuration
         */
        get systemConfig() {
          return this.config;
        }
        /**
         * Register a CSS variable group for this system
         */
        registerCSSVariableGroup(groupName, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.registerVariableGroup(`${this.systemName}-${groupName}`, priority);
          }
        }
        /**
         * Update variables in a CSS variable group
         */
        updateCSSVariableGroup(groupName, variables) {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.updateVariableGroup(`${this.systemName}-${groupName}`, variables, this.systemName);
          } else {
            this.updateCSSVariables(variables);
          }
        }
        // =========================================================================
        // COMPATIBILITY METHODS
        // =========================================================================
        /**
         * Legacy compatibility method for IManagedSystem
         * @deprecated Use onAnimate instead
         */
        updateAnimation(deltaTime) {
          this.onAnimate(deltaTime);
        }
        /**
         * Legacy compatibility method for BaseVisualSystem
         * @deprecated Override initialize() directly
         */
        async _performSystemSpecificInitialization() {
          await this.initialize();
        }
        /**
         * Legacy compatibility method for BaseVisualSystem
         * @deprecated Override destroy() directly
         */
        _performSystemSpecificCleanup() {
          this.destroy();
        }
      };
      __name(_UnifiedSystemBase, "UnifiedSystemBase");
      UnifiedSystemBase = _UnifiedSystemBase;
    }
  });

  // src-js/visual/organic-consciousness/OrganicBeatSyncConsciousness.ts
  var _OrganicBeatSyncConsciousness, OrganicBeatSyncConsciousness;
  var init_OrganicBeatSyncConsciousness = __esm({
    "src-js/visual/organic-consciousness/OrganicBeatSyncConsciousness.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_Year3000Utilities();
      _OrganicBeatSyncConsciousness = class _OrganicBeatSyncConsciousness extends UnifiedSystemBase {
        constructor(config) {
          super(config);
          // =========================================================================
          // ORGANIC CONSCIOUSNESS STATE
          // =========================================================================
          // Core organic properties (current values)
          this.organicIntensity = 0;
          this.cellularGrowth = 1;
          this.breathingPhase = 0;
          this.emotionalTemperature = 4e3;
          // 1000K-20000K range
          this.membraneFluidityLevel = 0.5;
          // Target values for smooth LERP interpolation
          this.targetOrganicIntensity = 0;
          this.targetCellularGrowth = 1;
          this.targetEmotionalTemperature = 4e3;
          this.targetMembraneFluidityLevel = 0.5;
          // LERP smoothing half-life values (in seconds)
          this.lerpHalfLifeValues = {
            intensityAttack: 0.05,
            // Fast attack for beat response
            intensityDecay: 0.15,
            // Smooth decay
            cellularGrowth: 0.08,
            // Organic cellular response  
            emotionalTemperature: 0.3,
            // Gradual temperature shifts
            membraneFluidty: 0.12
            // Fluid membrane transitions
          };
          // Timing and rhythm
          this.lastBeatTime = 0;
          this.currentBPM = 120;
          this.breathingCycleDuration = 2e3;
          // 2 seconds default
          // Cinematic consciousness elements
          this.atmosphericParticles = [];
          this.cellularMembranes = [];
          this.breathingOrganisms = [];
          // Performance metrics
          this.performanceMetrics = {
            organicUpdates: 0,
            cellularGrowthEvents: 0,
            breathingCycles: 0,
            emotionalShifts: 0,
            averageFrameTime: 0,
            memoryUsage: 0
          };
          // Organic consciousness configuration
          this.organicConfig = {
            cellularResponseSensitivity: 0.7,
            breathingRhythmIntensity: 0.8,
            emotionalTemperatureRange: { min: 1e3, max: 2e4 },
            membraneFluidityEnabled: true,
            atmosphericParticlesEnabled: true,
            cinematicEffectsEnabled: true
          };
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F30A} Organic consciousness awakening...");
          }
        }
        // =========================================================================
        // UNIFIED SYSTEM LIFECYCLE
        // =========================================================================
        /**
         * Initialize organic consciousness system
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F9EC} Initializing organic consciousness...");
          }
          this.registerCSSVariableGroup("organic-core", "critical");
          this.registerCSSVariableGroup("cellular-growth", "high");
          this.registerCSSVariableGroup("breathing-rhythm", "high");
          this.registerCSSVariableGroup("emotional-temperature", "normal");
          this.registerCSSVariableGroup("membrane-fluidity", "normal");
          this.growCellularMembranes();
          this.cultivateBreathingOrganisms();
          this.manifestAtmosphericParticles();
          this.subscribeToEvent("music:beat", (payload) => this.onBeatConsciousness(payload));
          this.subscribeToEvent("music:energy", (payload) => this.onEnergyConsciousness(payload));
          this.subscribeToEvent("music:emotion", (payload) => this.onEmotionalConsciousness(payload));
          this.subscribeToEvent("music:bpm-change", (payload) => this.onTempoConsciousness(payload));
          this.registerAnimation(60);
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F31F} Organic consciousness fully awakened");
          }
        }
        /**
         * Clean up organic consciousness
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F343} Dissolving organic consciousness...");
          }
          this.dissolveCellularMembranes();
          this.releaseBreathingOrganisms();
          this.disperseAtmosphericParticles();
          this.organicIntensity = 0;
          this.cellularGrowth = 1;
          this.breathingPhase = 0;
          this.emotionalTemperature = 4e3;
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F30C} Organic consciousness peacefully dissolved");
          }
        }
        /**
         * Organic consciousness animation frame
         */
        onAnimate(deltaTime) {
          const startTime = performance.now();
          this.updateOrganicConsciousness(deltaTime);
          this.processCellularGrowth(deltaTime);
          this.animateBreathingRhythms(deltaTime);
          this.updateEmotionalTemperature(deltaTime);
          this.animateMembraneFluidty(deltaTime);
          this.applyOrganicCSSVariables();
          const frameTime = performance.now() - startTime;
          this.performanceMetrics.averageFrameTime = this.performanceMetrics.averageFrameTime * 0.9 + frameTime * 0.1;
          this.performanceMetrics.organicUpdates++;
          if (frameTime > 2 && this.config.enableDebug) {
            console.warn(`[OrganicBeatSyncConsciousness] \u{1F40C} Organic consciousness frame took ${frameTime.toFixed(2)}ms (target: <2ms)`);
          }
        }
        /**
         * Health check for organic consciousness
         */
        async healthCheck() {
          const issues = [];
          if (this.cellularMembranes.length === 0) {
            issues.push("Cellular membranes not cultivated");
          }
          if (this.breathingOrganisms.length === 0) {
            issues.push("Breathing organisms not cultivated");
          }
          if (this.performanceMetrics.averageFrameTime > 2) {
            issues.push(`Average frame time ${this.performanceMetrics.averageFrameTime.toFixed(2)}ms exceeds 2ms target`);
          }
          if (this.organicIntensity === 0 && Date.now() - this.lastBeatTime > 1e4) {
            issues.push("No organic consciousness activity detected in last 10 seconds");
          }
          if (this.emotionalTemperature < 1e3 || this.emotionalTemperature > 2e4) {
            issues.push(`Emotional temperature ${this.emotionalTemperature}K outside 1000K-20000K range`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Organic consciousness health: ${issues.length === 0 ? "thriving" : "needs attention"}`,
            issues,
            system: "OrganicBeatSyncConsciousness"
          };
        }
        // =========================================================================
        // ORGANIC CONSCIOUSNESS BEHAVIORS
        // =========================================================================
        /**
         * Handle beat consciousness - organic response to music beats
         */
        onBeatConsciousness(payload) {
          const { intensity, bpm, energy, timestamp } = payload;
          this.lastBeatTime = timestamp || Date.now();
          this.currentBPM = bpm || this.currentBPM;
          this.targetOrganicIntensity = Math.min(1, intensity * this.organicConfig.cellularResponseSensitivity);
          this.targetCellularGrowth = 1 + (energy || 0.5) * 0.3;
          this.triggerCellularGrowthBurst(energy || 0.5);
          this.synchronizeBreathingRhythm(bpm || 120);
          this.performanceMetrics.cellularGrowthEvents++;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F3B5} Beat consciousness: intensity=${intensity}, energy=${energy}, bpm=${bpm}`);
          }
        }
        /**
         * Handle energy consciousness - organic response to music energy
         */
        onEnergyConsciousness(payload) {
          const { energy, valence, timestamp } = payload;
          this.targetCellularGrowth = 1 + energy * 0.3;
          this.targetMembraneFluidityLevel = 0.3 + valence * 0.4;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u26A1 Energy consciousness: energy=${energy}, valence=${valence}`);
          }
        }
        /**
         * Handle emotional consciousness - organic response to music emotion
         */
        onEmotionalConsciousness(payload) {
          const { emotion, valence, energy, arousal } = payload;
          const baseTemp = 4e3;
          const energyModulation = (energy - 0.5) * 8e3;
          const valenceModulation = (valence - 0.5) * 6e3;
          this.targetEmotionalTemperature = Math.max(1e3, Math.min(
            2e4,
            baseTemp + energyModulation + valenceModulation
          ));
          this.performanceMetrics.emotionalShifts++;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F308} Emotional consciousness: ${this.emotionalTemperature}K temperature`);
          }
        }
        /**
         * Handle tempo consciousness - organic response to BPM changes
         */
        onTempoConsciousness(payload) {
          const { bpm, tempo, enhancedBPM } = payload;
          this.currentBPM = enhancedBPM || bpm || tempo || 120;
          const bpmFactor = Math.max(0.3, Math.min(3, this.currentBPM / 120));
          this.breathingCycleDuration = 2e3 / bpmFactor;
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F3B6} Tempo consciousness: ${this.currentBPM} BPM, ${this.breathingCycleDuration.toFixed(0)}ms breathing cycle`);
          }
        }
        // =========================================================================
        // CELLULAR CONSCIOUSNESS METHODS
        // =========================================================================
        /**
         * Grow cellular membranes
         */
        growCellularMembranes() {
          for (let i = 0; i < 3; i++) {
            const membrane = document.createElement("div");
            membrane.className = "organic-cellular-membrane";
            membrane.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: ${990 + i};
        background: radial-gradient(circle at ${50 + i * 20}% ${50 + i * 15}%, 
          rgba(var(--spice-rgb-accent, 168, 173, 200), 0.08) 0%, 
          transparent 70%);
        opacity: 0;
        transform: scale(0.8);
        transition: opacity 0.3s ease-out, transform 0.3s ease-out;
      `;
            document.body.appendChild(membrane);
            this.cellularMembranes.push(membrane);
          }
        }
        /**
         * Cultivate breathing organisms
         */
        cultivateBreathingOrganisms() {
          for (let i = 0; i < 5; i++) {
            const organism = document.createElement("div");
            organism.className = "organic-breathing-organism";
            organism.style.cssText = `
        position: fixed;
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background: linear-gradient(45deg, 
          rgba(var(--spice-rgb-accent, 168, 173, 200), 0.1) 0%, 
          rgba(var(--spice-rgb-accent, 168, 173, 200), 0.05) 100%);
        pointer-events: none;
        z-index: 985;
        opacity: 0;
        transform: scale(0.5);
        transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        top: ${Math.random() * 80 + 10}%;
        left: ${Math.random() * 80 + 10}%;
      `;
            document.body.appendChild(organism);
            this.breathingOrganisms.push(organism);
          }
        }
        /**
         * Manifest atmospheric particles
         */
        manifestAtmosphericParticles() {
          for (let i = 0; i < 8; i++) {
            const particle = document.createElement("div");
            particle.className = "organic-atmospheric-particle";
            particle.style.cssText = `
        position: fixed;
        width: 4px;
        height: 4px;
        border-radius: 50%;
        background: rgba(var(--spice-rgb-accent, 168, 173, 200), 0.6);
        pointer-events: none;
        z-index: 980;
        opacity: 0;
        transform: scale(0);
        transition: opacity 0.8s ease-out, transform 0.8s ease-out;
        top: ${Math.random() * 100}%;
        left: ${Math.random() * 100}%;
      `;
            document.body.appendChild(particle);
            this.atmosphericParticles.push(particle);
          }
        }
        /**
         * Trigger cellular growth burst
         */
        triggerCellularGrowthBurst(energy) {
          const growthIntensity = energy * this.organicConfig.cellularResponseSensitivity;
          this.cellularMembranes.forEach((membrane, index) => {
            const scale = 0.8 + growthIntensity * 0.4;
            const opacity = Math.min(0.15, growthIntensity * 0.2);
            membrane.style.opacity = opacity.toString();
            membrane.style.transform = `scale(${scale})`;
            setTimeout(() => {
              membrane.style.opacity = "0";
              membrane.style.transform = "scale(0.8)";
            }, 200 + index * 50);
          });
        }
        /**
         * Synchronize breathing rhythm
         */
        synchronizeBreathingRhythm(bpm) {
          const cycleSpeed = Math.max(0.5, Math.min(4, bpm / 120));
          this.breathingOrganisms.forEach((organism, index) => {
            const delay = index * 100;
            setTimeout(() => {
              organism.style.opacity = "0.8";
              organism.style.transform = "scale(1.2)";
              setTimeout(() => {
                organism.style.opacity = "0.3";
                organism.style.transform = "scale(0.8)";
              }, this.breathingCycleDuration * 0.5);
            }, delay);
          });
          this.performanceMetrics.breathingCycles++;
        }
        // =========================================================================
        // ANIMATION UPDATE METHODS
        // =========================================================================
        /**
         * Update organic consciousness state using framerate-independent LERP smoothing
         */
        updateOrganicConsciousness(deltaTime) {
          this.breathingPhase += deltaTime / this.breathingCycleDuration * 2 * Math.PI;
          if (this.breathingPhase > 2 * Math.PI) {
            this.breathingPhase -= 2 * Math.PI;
          }
          const deltaTimeSeconds = deltaTime / 1e3;
          const halfLife = this.targetOrganicIntensity > this.organicIntensity ? this.lerpHalfLifeValues.intensityAttack : this.lerpHalfLifeValues.intensityDecay;
          this.organicIntensity = lerpSmooth(
            this.organicIntensity,
            this.targetOrganicIntensity,
            deltaTimeSeconds,
            halfLife
          );
          const timeSinceLastBeat = Date.now() - this.lastBeatTime;
          if (timeSinceLastBeat > 2e3) {
            this.targetOrganicIntensity = lerpSmooth(
              this.targetOrganicIntensity,
              0,
              // Decay to zero
              deltaTimeSeconds,
              this.lerpHalfLifeValues.intensityDecay
            );
          }
        }
        /**
         * Process cellular growth using framerate-independent LERP smoothing
         */
        processCellularGrowth(deltaTime) {
          const deltaTimeSeconds = deltaTime / 1e3;
          this.cellularGrowth = lerpSmooth(
            this.cellularGrowth,
            this.targetCellularGrowth,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.cellularGrowth
          );
          this.targetCellularGrowth = lerpSmooth(
            this.targetCellularGrowth,
            1,
            // Baseline growth
            deltaTimeSeconds,
            this.lerpHalfLifeValues.cellularGrowth * 2
            // Slower decay
          );
        }
        /**
         * Animate breathing rhythms
         */
        animateBreathingRhythms(deltaTime) {
          const breathingIntensity = (Math.sin(this.breathingPhase) + 1) / 2;
          this.breathingOrganisms.forEach((organism, index) => {
            const phaseOffset = index * Math.PI / 4;
            const localIntensity = (Math.sin(this.breathingPhase + phaseOffset) + 1) / 2;
            const scale = 0.8 + localIntensity * 0.4;
            const opacity = 0.2 + localIntensity * 0.3;
            organism.style.transform = `scale(${scale})`;
            organism.style.opacity = opacity.toString();
          });
        }
        /**
         * Update emotional temperature using framerate-independent LERP smoothing
         */
        updateEmotionalTemperature(deltaTime) {
          const deltaTimeSeconds = deltaTime / 1e3;
          this.emotionalTemperature = lerpSmooth(
            this.emotionalTemperature,
            this.targetEmotionalTemperature,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.emotionalTemperature
          );
          const neutral = 4e3;
          this.targetEmotionalTemperature = lerpSmooth(
            this.targetEmotionalTemperature,
            neutral,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.emotionalTemperature * 3
            // Slower neutral decay
          );
        }
        /**
         * Animate membrane fluidity using framerate-independent LERP smoothing
         */
        animateMembraneFluidty(deltaTime) {
          if (!this.organicConfig.membraneFluidityEnabled) return;
          const deltaTimeSeconds = deltaTime / 1e3;
          this.membraneFluidityLevel = lerpSmooth(
            this.membraneFluidityLevel,
            this.targetMembraneFluidityLevel,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.membraneFluidty
          );
          const fluidityWave = Math.sin(this.breathingPhase * 0.5) * 0.1;
          const currentFluidity = this.membraneFluidityLevel + fluidityWave;
          this.atmosphericParticles.forEach((particle, index) => {
            const phaseOffset = index * Math.PI / 4;
            const intensity = (Math.sin(this.breathingPhase + phaseOffset) + 1) / 2;
            const scale = 0.5 + intensity * currentFluidity;
            const opacity = 0.3 + intensity * 0.4;
            particle.style.transform = `scale(${scale})`;
            particle.style.opacity = opacity.toString();
          });
        }
        /**
         * Apply organic CSS variables
         */
        applyOrganicCSSVariables() {
          this.updateCSSVariableGroup("organic-core", {
            "--organic-intensity": this.organicIntensity.toFixed(3),
            "--organic-bpm": this.currentBPM.toString(),
            "--organic-breathing-phase": this.breathingPhase.toFixed(4)
          });
          this.updateCSSVariableGroup("cellular-growth", {
            "--cellular-growth-scale": this.cellularGrowth.toFixed(3),
            "--cellular-response-sensitivity": this.organicConfig.cellularResponseSensitivity.toFixed(2)
          });
          this.updateCSSVariableGroup("breathing-rhythm", {
            "--breathing-cycle-duration": `${this.breathingCycleDuration.toFixed(0)}ms`,
            "--breathing-rhythm-intensity": this.organicConfig.breathingRhythmIntensity.toFixed(2)
          });
          this.updateCSSVariableGroup("emotional-temperature", {
            "--emotional-temperature": `${this.emotionalTemperature.toFixed(0)}K`,
            "--emotional-temperature-normalized": ((this.emotionalTemperature - 1e3) / 19e3).toFixed(3)
          });
          this.updateCSSVariableGroup("membrane-fluidity", {
            "--membrane-fluidity-level": this.membraneFluidityLevel.toFixed(3),
            "--membrane-fluidity-enabled": this.organicConfig.membraneFluidityEnabled ? "1" : "0"
          });
        }
        // =========================================================================
        // CLEANUP METHODS
        // =========================================================================
        /**
         * Dissolve cellular membranes
         */
        dissolveCellularMembranes() {
          this.cellularMembranes.forEach((membrane) => {
            if (membrane.parentNode) {
              membrane.parentNode.removeChild(membrane);
            }
          });
          this.cellularMembranes = [];
        }
        /**
         * Release breathing organisms
         */
        releaseBreathingOrganisms() {
          this.breathingOrganisms.forEach((organism) => {
            if (organism.parentNode) {
              organism.parentNode.removeChild(organism);
            }
          });
          this.breathingOrganisms = [];
        }
        /**
         * Disperse atmospheric particles
         */
        disperseAtmosphericParticles() {
          this.atmosphericParticles.forEach((particle) => {
            if (particle.parentNode) {
              particle.parentNode.removeChild(particle);
            }
          });
          this.atmosphericParticles = [];
        }
        // =========================================================================
        // PUBLIC API METHODS
        // =========================================================================
        /**
         * Get organic consciousness metrics
         */
        getOrganicMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Update organic consciousness configuration
         */
        updateOrganicConfig(config) {
          this.organicConfig = { ...this.organicConfig, ...config };
          if (this.config.enableDebug) {
            console.log("[OrganicBeatSyncConsciousness] \u{1F527} Organic configuration updated:", this.organicConfig);
          }
        }
        /**
         * Get current organic consciousness state
         */
        getOrganicState() {
          return {
            organicIntensity: this.organicIntensity,
            cellularGrowth: this.cellularGrowth,
            breathingPhase: this.breathingPhase,
            emotionalTemperature: this.emotionalTemperature,
            membraneFluidityLevel: this.membraneFluidityLevel,
            lastBeatTime: this.lastBeatTime,
            currentBPM: this.currentBPM
          };
        }
        /**
         * Force organic consciousness repaint
         */
        forceRepaint(reason) {
          super.forceRepaint(reason);
          this.organicIntensity = 0;
          this.cellularGrowth = 1;
          this.breathingPhase = 0;
          this.applyOrganicCSSVariables();
          if (this.config.enableDebug) {
            console.log(`[OrganicBeatSyncConsciousness] \u{1F504} Organic consciousness repaint: ${reason}`);
          }
        }
      };
      __name(_OrganicBeatSyncConsciousness, "OrganicBeatSyncConsciousness");
      OrganicBeatSyncConsciousness = _OrganicBeatSyncConsciousness;
    }
  });

  // src-js/visual/ui-effects/InteractionTrackingSystem.ts
  var _InteractionTrackingSystem, InteractionTrackingSystem;
  var init_InteractionTrackingSystem = __esm({
    "src-js/visual/ui-effects/InteractionTrackingSystem.ts"() {
      "use strict";
      init_EventBus();
      init_BaseVisualSystem();
      _InteractionTrackingSystem = class _InteractionTrackingSystem extends BaseVisualSystem {
        constructor(config, utils, performanceMonitor, musicSyncService, settingsManager, year3000System2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager);
          this._scrollContainerElements = [];
          // Stored throttled interaction handler for proper cleanup.
          this._interactionHandler = null;
          this.year3000System = year3000System2;
          this.nexusState = {
            complexity: 0.1,
            coherence: 0.8,
            volatility: 0.05,
            timeDistortionFactor: 1,
            currentNavigationScale: 1,
            targetComplexity: 0.1,
            targetCoherence: 0.8,
            targetVolatility: 0.05,
            targetTimeDistortionFactor: 1,
            targetNavigationScale: 1,
            userInfluence: 0,
            lastEnergy: 0.5,
            lastValence: 0.5,
            lastVisualIntensity: 0.5,
            lastMoodIdentifier: "neutral",
            responsiveness: 1,
            temporalSensitivity: 1
          };
          this.biometricState = {
            isMeditating: false,
            lastUserInteractionTime: Date.now(),
            meditationGracePeriod: 5e3,
            interactionCooldown: 1e3,
            lastMeditationUpdateTime: null,
            desaturation: 0,
            slowdown: 1,
            targetDesaturation: 0,
            targetSlowdown: 1
          };
          this.lastHeavyUpdateTime = 0;
          this.heavyUpdateInterval = 1e3 / 10;
          this.lastBiometricCheckTime = 0;
          this.biometricCheckInterval = 1e3;
          this.lastInteractionRecordTime = 0;
          this.interactionRecordInterval = 200;
          this._animationRegistered = false;
          this._performanceMode = "auto";
          this._frameSkipCounter = 0;
          this._maxFrameSkip = 2;
          this.systemIntegrationMetrics = {
            lastSystemsCheck: Date.now(),
            integrationHealth: "healthy",
            crossSystemErrors: 0,
            meditationTransitions: 0,
            navigationScaleUpdates: 0
          };
          const healthMonitor = this.utils.getHealthMonitor();
          if (healthMonitor) {
            healthMonitor.registerSystem("InteractionTrackingSystem", this);
          }
          this.rootElement = this.utils.getRootStyle();
          this.modalObserver = null;
          this._lastScrollTime = null;
          this._lastScrollTop = null;
        }
        /**
         * Frame callback invoked by the MasterAnimationCoordinator.
         * Delegates to the existing `updateAnimation` implementation which
         * contains the system's main per-frame logic (including internal
         * frame-skipping and heavy-update cadence).
         *
         * @param deltaMs  Milliseconds elapsed since the previous animation frame.
         */
        onAnimate(deltaMs) {
          if (!this.initialized) return;
          this.updateAnimation(performance.now(), deltaMs);
        }
        async initialize() {
          await super.initialize();
          this.initializeOptimizedQuantumSpace();
          this.setupModalObserver();
          this.setupOptimizedInteractionListener();
          this._registerWithAnimationCoordinator();
        }
        _registerWithAnimationCoordinator() {
          if (this.year3000System && this.year3000System.registerAnimationSystem) {
            this.year3000System.registerAnimationSystem(
              "InteractionTrackingSystem",
              this,
              "normal",
              30
            );
            this._animationRegistered = true;
          } else {
            this._startFallbackAnimationLoops();
          }
        }
        initializeOptimizedQuantumSpace() {
          const root = this.utils.getRootStyle();
          if (!root) return;
          const safeSetProperty = /* @__PURE__ */ __name((name, value) => {
            try {
              root.style.setProperty(name, value);
            } catch (e) {
            }
          }, "safeSetProperty");
          safeSetProperty("--sn-nexus-complexity", this.nexusState.complexity);
          safeSetProperty("--sn-nexus-coherence", this.nexusState.coherence);
          safeSetProperty("--sn-nexus-volatility", this.nexusState.volatility);
          safeSetProperty(
            "--sn-nexus-time-distortion",
            this.nexusState.timeDistortionFactor
          );
          safeSetProperty("--sn-nav-item-transform-scale", "1.0");
          safeSetProperty("--sn-sidebar-meditation-desaturation", "0");
          safeSetProperty("--sn-sidebar-meditation-slowdown", "1");
          safeSetProperty("--sn-nexus-pattern-complexity", "0.5");
          safeSetProperty("--sn-nexus-pattern-rotation", "0deg");
        }
        recordUserInteraction(event) {
          const eventType = event.type;
          if (eventType === "scroll") {
            const target = event.target;
            if (target) {
              const newTop = target.scrollTop;
              const now2 = performance.now();
              const velocity = this._lastScrollTime ? (newTop - (this._lastScrollTop ?? 0)) / (now2 - this._lastScrollTime) : 0;
              const direction = velocity < 0 ? "up" : "down";
              GlobalEventBus.publish("user:scroll", {
                velocity: velocity * 1e3,
                // pixels per second
                direction
              });
              this._lastScrollTop = newTop;
              this._lastScrollTime = now2;
            }
          }
          const now = performance.now();
          if (now - this.lastInteractionRecordTime < this.interactionRecordInterval) {
            return;
          }
          this.lastInteractionRecordTime = now;
          this.nexusState.userInfluence += 5e-3;
          this.nexusState.volatility = Math.min(1, this.nexusState.volatility + 0.01);
          this.nexusState.userInfluence = Math.min(
            0.5,
            this.nexusState.userInfluence
          );
          this.biometricState.lastUserInteractionTime = Date.now();
          this.biometricState.isMeditating = false;
        }
        setupModalObserver() {
          const modalRoot = document.querySelector(".main-modal-container");
          if (!modalRoot) return;
          const observerCallback = /* @__PURE__ */ __name((mutationsList, observer) => {
            for (const mutation of mutationsList) {
              if (mutation.type === "childList") {
                const hasModal = modalRoot.children.length > 0;
                this.nexusState.timeDistortionFactor = hasModal ? 0.2 : 1;
                this.nexusState.coherence = hasModal ? 0.2 : 0.8;
              }
            }
          }, "observerCallback");
          this.modalObserver = new MutationObserver(observerCallback);
          this.modalObserver.observe(modalRoot, { childList: true });
        }
        setupOptimizedInteractionListener() {
          this._interactionHandler = this.utils.throttle(
            (event) => this.recordUserInteraction(event),
            100
          );
          const genericEvents = ["click", "mousemove", "keydown"];
          genericEvents.forEach((eventType) => {
            document.addEventListener(
              eventType,
              this._interactionHandler,
              { passive: true }
            );
          });
          const scrollSelectors = [
            ".main-view-container__scroll-node",
            ".main-view-container__scroll-node-child",
            "section[data-testid='playlist-page']"
          ];
          const foundContainers = [];
          scrollSelectors.forEach((sel) => {
            document.querySelectorAll(sel).forEach((el) => {
              foundContainers.push(el);
            });
          });
          const targets = foundContainers.length ? foundContainers : [document];
          targets.forEach((el) => {
            el.addEventListener("scroll", this._interactionHandler, {
              passive: true
            });
          });
          this._scrollContainerElements = foundContainers;
        }
        updateFromMusicAnalysis(processedMusicData, rawFeatures, trackUri) {
          if (!this.initialized || !this.validateMusicData(processedMusicData)) {
            this.applySafeDefaults();
            return;
          }
          this.updateNexusTargets(processedMusicData);
        }
        updateNexusTargets(processedMusicData) {
          const {
            energy,
            valence,
            visualIntensity,
            animationSpeedFactor,
            moodIdentifier
          } = processedMusicData;
          this.nexusState.targetComplexity = (energy * 0.6 + visualIntensity * 0.4) * 0.9 + 0.1;
          this.nexusState.targetCoherence = 1 - (energy * 0.5 + visualIntensity * 0.5) * 0.6;
          this.nexusState.targetVolatility = (1 - valence) * 0.1 + (energy - 0.5) * 0.05;
          this.nexusState.targetTimeDistortionFactor = animationSpeedFactor;
          this.nexusState.targetNavigationScale = this.calculateOptimizedNavigationScale(visualIntensity, moodIdentifier);
        }
        updateDigitalMeditationState(processedMusicData) {
          const now = Date.now();
          if (now - this.lastBiometricCheckTime < this.biometricCheckInterval) {
            return;
          }
          this.lastBiometricCheckTime = now;
          const timeSinceLastInteraction = now - this.biometricState.lastUserInteractionTime;
          if (timeSinceLastInteraction > this.biometricState.meditationGracePeriod && processedMusicData.energy < 0.3 && processedMusicData.valence > 0.6) {
            this.biometricState.isMeditating = true;
            this.biometricState.targetDesaturation = 0.6;
            this.biometricState.targetSlowdown = 0.5;
          } else {
            this.biometricState.isMeditating = false;
            this.biometricState.targetDesaturation = 0;
            this.biometricState.targetSlowdown = 1;
          }
        }
        updateAnimation(timestamp, deltaTime) {
          if (!this.initialized) return;
          this._frameSkipCounter++;
          if (this._frameSkipCounter < this._maxFrameSkip) {
            return;
          }
          this._frameSkipCounter = 0;
          this.animateOptimizedNexusFrame(deltaTime);
          if (timestamp - this.lastHeavyUpdateTime > this.heavyUpdateInterval) {
            const latestMusicData = this.musicSyncService?.getLatestProcessedData();
            if (latestMusicData) this.updateDigitalMeditationState(latestMusicData);
            this.updateIntegrationMetrics();
            this.lastHeavyUpdateTime = timestamp;
          }
        }
        onPerformanceModeChange(mode) {
          this._performanceMode = mode;
          if (mode === "performance") {
            this.heavyUpdateInterval = 1e3 / 5;
            this._maxFrameSkip = 3;
            this.interactionRecordInterval = 500;
          } else {
            this.heavyUpdateInterval = 1e3 / 10;
            this._maxFrameSkip = 2;
            this.interactionRecordInterval = 200;
          }
        }
        _startFallbackAnimationLoops() {
          const loop = /* @__PURE__ */ __name(() => {
            this.updateAnimation(performance.now(), 16.67);
            requestAnimationFrame(loop);
          }, "loop");
          requestAnimationFrame(loop);
        }
        animateOptimizedNexusFrame(deltaTimeMs) {
          const lerpFactor = Math.min((deltaTimeMs ?? 16.67) / 1e3 * 5, 1);
          this.nexusState.complexity = this.utils.lerp(
            this.nexusState.complexity,
            this.nexusState.targetComplexity,
            lerpFactor
          );
          this.nexusState.coherence = this.utils.lerp(
            this.nexusState.coherence,
            this.nexusState.targetCoherence,
            lerpFactor
          );
          this.nexusState.volatility = this.utils.lerp(
            this.nexusState.volatility,
            this.nexusState.targetVolatility,
            lerpFactor
          );
          this.nexusState.currentNavigationScale = this.utils.lerp(
            this.nexusState.currentNavigationScale,
            this.nexusState.targetNavigationScale,
            lerpFactor
          );
          this.biometricState.desaturation = this.utils.lerp(
            this.biometricState.desaturation,
            this.biometricState.targetDesaturation,
            lerpFactor
          );
          this.biometricState.slowdown = this.utils.lerp(
            this.biometricState.slowdown,
            this.biometricState.targetSlowdown,
            lerpFactor
          );
          this.applyOptimizedStateToCSS();
        }
        applyOptimizedStateToCSS() {
          const queueCSSUpdate = /* @__PURE__ */ __name((property, value) => {
            if (this.year3000System?.queueCSSVariableUpdate) {
              this.year3000System.queueCSSVariableUpdate(
                property,
                value.toString()
              );
            } else {
              this.rootElement.style.setProperty(property, value.toString());
            }
          }, "queueCSSUpdate");
          queueCSSUpdate(
            "--sn-nexus-complexity",
            this.nexusState.complexity.toFixed(3)
          );
          queueCSSUpdate(
            "--sn-nexus-coherence",
            this.nexusState.coherence.toFixed(3)
          );
          queueCSSUpdate(
            "--sn-nexus-volatility",
            this.nexusState.volatility.toFixed(3)
          );
          queueCSSUpdate(
            "--sn-nav-item-transform-scale",
            this.nexusState.currentNavigationScale.toFixed(3)
          );
          queueCSSUpdate(
            "--sn-sidebar-meditation-desaturation",
            this.biometricState.desaturation.toFixed(3)
          );
          queueCSSUpdate(
            "--sn-sidebar-meditation-slowdown",
            this.biometricState.slowdown.toFixed(3)
          );
        }
        validateMusicData(data) {
          return data && typeof data.energy === "number" && typeof data.valence === "number" && typeof data.visualIntensity === "number";
        }
        applySafeDefaults() {
          const safeSetProperty = /* @__PURE__ */ __name((name, value) => {
            if (this.rootElement) this.rootElement.style.setProperty(name, value);
          }, "safeSetProperty");
          safeSetProperty("--sn-nexus-complexity", "0.1");
          safeSetProperty("--sn-nexus-coherence", "0.8");
        }
        updateIntegrationMetrics() {
        }
        calculateIntegrationComplexity() {
          let complexity = 0;
          complexity += this.nexusState.complexity * 10;
          if (this.biometricState.isMeditating) complexity += 5;
          return complexity;
        }
        performCleanup() {
          if (this.nexusState.userInfluence > 0) {
            this.nexusState.userInfluence = Math.max(
              0,
              this.nexusState.userInfluence - 0.01
            );
          }
        }
        calculateOptimizedNavigationScale(visualIntensity = 0.5, moodIdentifier = "neutral") {
          let scale = 1;
          if (visualIntensity > 0.7) scale = 1.02;
          if (moodIdentifier === "energetic") scale *= 1.01;
          return scale;
        }
        getNavigationScalingReport() {
          return {
            target: this.nexusState.targetNavigationScale,
            current: this.nexusState.currentNavigationScale,
            intensity: this.nexusState.lastVisualIntensity,
            mood: this.nexusState.lastMoodIdentifier
          };
        }
        getMeditationReport() {
          return {
            isMeditating: this.biometricState.isMeditating,
            timeSinceInteraction: (Date.now() - this.biometricState.lastUserInteractionTime) / 1e3,
            desaturation: this.biometricState.desaturation,
            slowdown: this.biometricState.slowdown
          };
        }
        destroy() {
          if (this._interactionHandler) {
            ["click", "mousemove", "keydown"].forEach((evt) => {
              document.removeEventListener(
                evt,
                this._interactionHandler
              );
            });
            this._scrollContainerElements.forEach((el) => {
              el.removeEventListener(
                "scroll",
                this._interactionHandler
              );
            });
            this._interactionHandler = null;
          }
          super.destroy();
        }
      };
      __name(_InteractionTrackingSystem, "InteractionTrackingSystem");
      InteractionTrackingSystem = _InteractionTrackingSystem;
    }
  });

  // src-js/visual/ui-effects/SpotifyUIApplicationSystem.ts
  var _SpotifyUIApplicationSystem, SpotifyUIApplicationSystem;
  var init_SpotifyUIApplicationSystem = __esm({
    "src-js/visual/ui-effects/SpotifyUIApplicationSystem.ts"() {
      "use strict";
      init_EventBus();
      _SpotifyUIApplicationSystem = class _SpotifyUIApplicationSystem {
        constructor(year3000System2) {
          this.year3000System = year3000System2;
          this.systemName = "SpotifyUIApplicationSystem";
          this.initialized = false;
          this.effectLayers = [];
          this.observerRegistry = /* @__PURE__ */ new Map();
          this.debounceRefresh = this.debounce(() => {
            this.refreshUITargets();
          }, 500);
          this.targets = this.initializeEmptyTargets();
        }
        /**
         * Required by IManagedSystem - periodic animation updates
         */
        updateAnimation(deltaTime) {
        }
        /**
         * Required by IManagedSystem - health check
         */
        async healthCheck() {
          try {
            const targetStats = this.getTargetStats();
            const totalElements = Object.values(targetStats).reduce(
              (sum, count) => sum + count,
              0
            );
            const isHealthy = this.initialized && totalElements > 0;
            const issues = [];
            if (totalElements === 0) {
              issues.push("No UI elements discovered");
            }
            return {
              healthy: isHealthy,
              ok: isHealthy,
              details: `UI Application System ${this.initialized ? "active" : "inactive"}, ${totalElements} elements enhanced`,
              issues,
              system: "SpotifyUIApplicationSystem"
            };
          } catch (error) {
            return {
              healthy: false,
              ok: false,
              details: "Health check failed",
              issues: [error instanceof Error ? error.message : "Unknown error"],
              system: "SpotifyUIApplicationSystem"
            };
          }
        }
        /**
         * Force repaint - implements optional IManagedSystem method
         * Cascade Coordination - Ensures proper layering of effects
         */
        forceRepaint(reason) {
          console.log(`\u{1F3A8} Force repaint requested: ${reason || "manual trigger"}`);
          this.forceEffectCascade();
        }
        initializeEmptyTargets() {
          return {
            nowPlaying: [],
            sidebar: [],
            mainContent: [],
            buttons: [],
            cards: [],
            headers: [],
            textElements: [],
            iconElements: [],
            playbackControls: [],
            trackRows: []
          };
        }
        async initialize() {
          if (this.initialized) return;
          try {
            await this.discoverUITargets();
            this.setupEffectLayers();
            this.applyUnifiedState();
            this.setupDOMObservers();
            this.registerSystemCallbacks();
            this.initialized = true;
            console.log("\u2728 SpotifyUIApplicationSystem initialized successfully");
          } catch (error) {
            console.error("Failed to initialize SpotifyUIApplicationSystem", error);
            throw error;
          }
        }
        /**
         * DOM Intelligence Layer - Discovers current Spotify UI elements
         */
        async discoverUITargets() {
          const selectors = {
            nowPlaying: [
              '[data-testid="now-playing-widget"]',
              ".main-nowPlayingWidget-nowPlaying",
              ".Root__now-playing-bar"
            ],
            sidebar: [
              '[data-testid="nav-bar"]',
              ".main-navBar-navBar",
              ".Root__nav-bar"
            ],
            mainContent: [
              '[data-testid="main"]',
              ".main-view-container",
              ".Root__main-view"
            ],
            buttons: [
              'button[class*="Button"]',
              '[role="button"]',
              ".main-playButton-PlayButton"
            ],
            cards: [
              '[data-testid*="card"]',
              ".main-card-card",
              ".main-entityCard-container"
            ],
            headers: [
              "h1, h2, h3, h4, h5, h6",
              '[data-testid*="header"]',
              ".main-entityHeader-titleText"
            ],
            textElements: [
              '[data-testid="track-name"]',
              '[data-testid="artist-name"]',
              ".main-trackList-trackName",
              ".main-trackList-artistName"
            ],
            iconElements: [
              'svg[class*="Icon"]',
              '[data-testid*="icon"]',
              ".Svg-sc-ytk21e-0"
            ],
            playbackControls: [
              '[data-testid="control-button"]',
              ".main-playPauseButton-button",
              ".player-controls__buttons"
            ],
            trackRows: [
              '[data-testid="tracklist-row"]',
              ".main-trackList-trackListRow",
              ".main-rootlist-rootlistItem"
            ]
          };
          for (const [category, selectorArray] of Object.entries(selectors)) {
            const elements = [];
            for (const selector of selectorArray) {
              try {
                const found = document.querySelectorAll(selector);
                elements.push(...Array.from(found));
              } catch (error) {
                continue;
              }
            }
            const uniqueElements = Array.from(new Set(elements));
            this.targets[category] = uniqueElements;
          }
          console.log("\u{1F3AF} UI targets discovered", {
            nowPlaying: this.targets.nowPlaying.length,
            sidebar: this.targets.sidebar.length,
            mainContent: this.targets.mainContent.length,
            buttons: this.targets.buttons.length,
            cards: this.targets.cards.length,
            headers: this.targets.headers.length,
            textElements: this.targets.textElements.length,
            iconElements: this.targets.iconElements.length,
            playbackControls: this.targets.playbackControls.length,
            trackRows: this.targets.trackRows.length
          });
        }
        /**
         * Effect Application Pipeline - Sets up cascade layers from background to foreground
         */
        setupEffectLayers() {
          this.effectLayers = [
            // Layer 1: Background & Container Effects
            {
              name: "background-containers",
              elements: [...this.targets.mainContent, ...this.targets.sidebar],
              priority: 10,
              cssVariables: {
                "--sn-bg-primary": "var(--sn-accent-primary)",
                "--sn-bg-secondary": "var(--sn-accent-secondary)",
                "--sn-gradient-start": "var(--sn-gradient-primary-rgb)",
                "--sn-gradient-end": "var(--sn-gradient-secondary-rgb)"
              }
            },
            // Layer 2: Card & Content Effects
            {
              name: "ui-cards",
              elements: this.targets.cards,
              priority: 20,
              cssVariables: {
                "--sn-card-bg": "var(--sn-accent-primary)",
                "--sn-card-border": "var(--sn-accent-secondary)",
                "--sn-card-glow": "var(--sn-accent-tertiary)",
                "--sn-glassmorphism-intensity": "var(--sn-effect-intensity)"
              },
              interactionEffects: true
            },
            // Layer 3: Interactive Elements
            {
              name: "interactive-elements",
              elements: [...this.targets.buttons, ...this.targets.playbackControls],
              priority: 30,
              cssVariables: {
                "--sn-button-bg": "var(--sn-accent-primary)",
                "--sn-button-hover": "var(--sn-accent-secondary)",
                "--sn-button-active": "var(--sn-accent-tertiary)",
                "--sn-beat-sync-intensity": "var(--sn-music-intensity)"
              },
              interactionEffects: true
            },
            // Layer 4: Text & Icon Enhancement
            {
              name: "text-icon-effects",
              elements: [
                ...this.targets.textElements,
                ...this.targets.iconElements,
                ...this.targets.headers
              ],
              priority: 40,
              cssVariables: {
                "--sn-text-primary": "var(--sn-accent-primary)",
                "--sn-text-secondary": "var(--sn-accent-secondary)",
                "--sn-text-glow": "var(--sn-accent-tertiary)",
                "--sn-icon-color": "var(--sn-accent-primary)",
                "--sn-icon-glow": "var(--sn-accent-secondary)"
              }
            },
            // Layer 5: Now Playing Special Effects
            {
              name: "now-playing-effects",
              elements: this.targets.nowPlaying,
              priority: 50,
              cssVariables: {
                "--sn-now-playing-bg": "var(--sn-accent-primary)",
                "--sn-now-playing-glow": "var(--sn-accent-secondary)",
                "--sn-beat-pulse": "var(--sn-music-intensity)",
                "--sn-track-progress": "var(--sn-accent-tertiary)"
              },
              interactionEffects: true
            }
          ];
        }
        /**
         * Applies unified state from existing systems to discovered UI elements
         */
        applyUnifiedState() {
          this.effectLayers.forEach((layer) => {
            layer.elements.forEach((element) => {
              this.applyEffectToElement(element, layer);
            });
          });
        }
        /**
         * Helper method to safely call Year3000System's queueCSSVariableUpdate
         */
        safeQueueCSSVariableUpdate(property, value, element) {
          if (this.year3000System?.queueCSSVariableUpdate) {
            this.year3000System.queueCSSVariableUpdate(property, value, element || null);
          } else {
            const target = element || document.documentElement;
            target.style.setProperty(property, value);
          }
        }
        applyEffectToElement(element, layer) {
          if (!(element instanceof HTMLElement)) return;
          Object.entries(layer.cssVariables).forEach(([property, value]) => {
            this.safeQueueCSSVariableUpdate(property, value, element);
          });
          element.classList.add(`sn-${layer.name}`);
          element.classList.add("sn-ui-enhanced");
          if (layer.interactionEffects) {
            this.addInteractionEffects(element, layer);
          }
          element.setAttribute("data-sn-layer", layer.name);
          element.setAttribute("data-sn-priority", layer.priority.toString());
        }
        addInteractionEffects(element, layer) {
          if (layer.name === "interactive-elements" || layer.name === "now-playing-effects") {
            this.safeQueueCSSVariableUpdate(
              "--sn-beat-response",
              "var(--sn-music-intensity)",
              element
            );
            element.classList.add("sn-beat-responsive");
          }
          element.addEventListener("mouseenter", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-hover-intensity",
              "1",
              element
            );
            element.classList.add("sn-hover-active");
          });
          element.addEventListener("mouseleave", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-hover-intensity",
              "0",
              element
            );
            element.classList.remove("sn-hover-active");
          });
          element.addEventListener("click", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-click-intensity",
              "1",
              element
            );
            element.classList.add("sn-click-active");
            setTimeout(() => {
              this.safeQueueCSSVariableUpdate(
                "--sn-click-intensity",
                "0",
                element
              );
              element.classList.remove("sn-click-active");
            }, 300);
          });
        }
        /**
         * Sets up DOM mutation observers for dynamic Spotify UI updates
         */
        setupDOMObservers() {
          const observerConfig = {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ["class", "data-testid"]
          };
          const mainObserver = new MutationObserver((mutations) => {
            let needsRefresh = false;
            mutations.forEach((mutation) => {
              if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
                needsRefresh = true;
              }
            });
            if (needsRefresh) {
              this.debounceRefresh();
            }
          });
          const mainElement = document.querySelector('[data-testid="main"]') || document.body;
          mainObserver.observe(mainElement, observerConfig);
          this.observerRegistry.set("main", mainObserver);
        }
        debounce(func, wait) {
          let timeout;
          return /* @__PURE__ */ __name(function executedFunction(...args) {
            const later = /* @__PURE__ */ __name(() => {
              clearTimeout(timeout);
              func(...args);
            }, "later");
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          }, "executedFunction");
        }
        async refreshUITargets() {
          try {
            await this.discoverUITargets();
            this.applyUnifiedState();
            console.log("\u{1F504} UI targets refreshed");
          } catch (error) {
            console.error("Failed to refresh UI targets", error);
          }
        }
        /**
         * Registers for updates from unified systems - connects to event-driven architecture
         */
        registerSystemCallbacks() {
          try {
            GlobalEventBus.subscribe("colors/harmonized", (event) => {
              this.handleColorHarmonizedEvent(event);
            });
            console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Subscribed to colors/harmonized events");
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to subscribe to colors/harmonized events:", error);
            if (this.year3000System.colorHarmonyEngine) {
              const originalApplyColors = this.year3000System.applyColorsToTheme.bind(
                this.year3000System
              );
              this.year3000System.applyColorsToTheme = (extractedColors = {}) => {
                originalApplyColors(extractedColors);
                this.updateColorVariables(extractedColors);
              };
              console.warn("[SpotifyUIApplicationSystem] Using legacy color application hook as fallback");
            }
          }
          if (this.year3000System.musicSyncService) {
            const originalUpdateFromAnalysis = this.year3000System.updateFromMusicAnalysis.bind(this.year3000System);
            this.year3000System.updateFromMusicAnalysis = (processedData, rawFeatures, trackUri) => {
              originalUpdateFromAnalysis(processedData, rawFeatures, trackUri);
              this.updateMusicIntensity(processedData);
            };
          }
          if (this.year3000System.beatSyncVisualSystem) {
            if (this.year3000System.timerConsolidationSystem) {
              this.year3000System.timerConsolidationSystem.registerConsolidatedTimer(
                "SpotifyUIApplicationSystem-beatEffects",
                () => {
                  const intensity = this.getCurrentMusicIntensity();
                  if (intensity > 0.5) {
                    this.triggerBeatEffects({ intensity });
                  }
                },
                200,
                "normal"
              );
            } else {
              setInterval(() => {
                const intensity = this.getCurrentMusicIntensity();
                if (intensity > 0.5) {
                  this.triggerBeatEffects({ intensity });
                }
              }, 200);
            }
          }
        }
        getCurrentMusicIntensity() {
          const root = document.documentElement;
          const intensity = getComputedStyle(root).getPropertyValue("--sn-kinetic-energy").trim();
          return parseFloat(intensity) || 0;
        }
        /**
         * Handle colors/harmonized event from ColorOrchestrator (Event-driven architecture)
         */
        handleColorHarmonizedEvent(event) {
          if (event.type !== "colors/harmonized") return;
          const { processedColors, cssVariables, metadata } = event.payload;
          console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Received harmonized colors via event-driven pattern", {
            strategy: metadata.strategy,
            colorsCount: Object.keys(processedColors).length,
            cssVariablesCount: Object.keys(cssVariables).length
          });
          try {
            this.updateColorVariables(processedColors);
            if (cssVariables && Object.keys(cssVariables).length > 0) {
              this.applyCSSVariablesToSpotifyUI(cssVariables);
            }
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to apply harmonized colors from event:", error);
            this.updateColorVariables(processedColors);
          }
        }
        /**
         * Apply CSS variables directly to Spotify UI elements (optimization for event-driven pattern)
         */
        applyCSSVariablesToSpotifyUI(cssVariables) {
          try {
            const root = document.documentElement;
            const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
            for (const [variable, value] of Object.entries(cssVariables)) {
              if (variable && value) {
                root.style.setProperty(variable, value);
              }
            }
            enhancedElements.forEach((element) => {
              if (element instanceof HTMLElement) {
                for (const [variable, value] of Object.entries(cssVariables)) {
                  if (variable && value) {
                    element.style.setProperty(variable, value);
                  }
                }
              }
            });
            console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Applied CSS variables to Spotify UI", {
              variablesCount: Object.keys(cssVariables).length,
              enhancedElementsCount: enhancedElements.length
            });
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to apply CSS variables to Spotify UI:", error);
          }
        }
        updateColorVariables(colorData) {
          const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
          enhancedElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-primary",
                colorData.primary || "var(--spice-accent)",
                element
              );
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-secondary",
                colorData.secondary || "var(--spice-accent)",
                element
              );
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-tertiary",
                colorData.tertiary || "var(--spice-accent)",
                element
              );
            }
          });
        }
        updateMusicIntensity(processedData) {
          const intensity = processedData?.processedEnergy || 0;
          const intensityElements = document.querySelectorAll(".sn-beat-responsive");
          intensityElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-music-intensity",
                intensity.toString(),
                element
              );
            }
          });
        }
        triggerBeatEffects(beatData) {
          const beatElements = document.querySelectorAll(".sn-beat-responsive");
          beatElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-beat-pulse",
                "1",
                element
              );
              element.classList.add("sn-beat-active");
              setTimeout(() => {
                this.safeQueueCSSVariableUpdate(
                  "--sn-beat-pulse",
                  "0",
                  element
                );
                element.classList.remove("sn-beat-active");
              }, 200);
            }
          });
        }
        /**
         * Cascade Coordination - Ensures proper layering of effects
         */
        forceEffectCascade() {
          this.effectLayers.sort((a, b) => a.priority - b.priority).forEach((layer) => {
            layer.elements.forEach((element) => {
              this.applyEffectToElement(element, layer);
            });
          });
        }
        async destroy() {
          if (this.year3000System?.timerConsolidationSystem) {
            this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer("SpotifyUIApplicationSystem-beatEffects");
          }
          this.observerRegistry.forEach((observer) => {
            observer.disconnect();
          });
          this.observerRegistry.clear();
          const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
          enhancedElements.forEach((element) => {
            element.classList.remove("sn-ui-enhanced");
            element.removeAttribute("data-sn-layer");
            element.removeAttribute("data-sn-priority");
          });
          this.initialized = false;
        }
        // Debug utility
        getTargetStats() {
          return Object.fromEntries(
            Object.entries(this.targets).map(([key, elements]) => [
              key,
              elements.length
            ])
          );
        }
      };
      __name(_SpotifyUIApplicationSystem, "SpotifyUIApplicationSystem");
      SpotifyUIApplicationSystem = _SpotifyUIApplicationSystem;
    }
  });

  // src-js/core/performance/AdaptivePerformanceSystem.ts
  var _AdaptivePerformanceSystem, AdaptivePerformanceSystem;
  var init_AdaptivePerformanceSystem = __esm({
    "src-js/core/performance/AdaptivePerformanceSystem.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_DeviceCapabilityDetector();
      init_PerformanceAnalyzer();
      _AdaptivePerformanceSystem = class _AdaptivePerformanceSystem {
        constructor(deviceDetector, performanceAnalyzer) {
          // Performance monitoring
          this.performanceHistory = [];
          this.monitoringInterval = null;
          this.adaptationTimer = null;
          this.lastAdaptation = 0;
          this.adaptationCooldown = 5e3;
          // 5 seconds between adaptations
          // Thermal and power management
          this.thermalHistory = [];
          this.powerObserver = null;
          this.batteryAPI = null;
          // Event handling
          this.eventListeners = [];
          this.boundPerformanceCheck = null;
          this.boundThermalCheck = null;
          // Quality scaling algorithms
          this.qualityScales = {
            ultra: { complexity: 1, particles: 1, fps: 60, precision: "highp" },
            high: { complexity: 0.8, particles: 0.8, fps: 60, precision: "highp" },
            medium: { complexity: 0.6, particles: 0.6, fps: 45, precision: "mediump" },
            low: { complexity: 0.4, particles: 0.4, fps: 30, precision: "mediump" },
            minimal: { complexity: 0.2, particles: 0.2, fps: 24, precision: "lowp" }
          };
          this.deviceDetector = deviceDetector || new DeviceCapabilityDetector();
          this.performanceAnalyzer = performanceAnalyzer || new PerformanceAnalyzer();
          this.hardwareMetrics = this.detectHardware();
          this.currentProfile = this.determineOptimalProfile();
          this.currentBudget = this.calculatePerformanceBudget();
          this.currentQuality = this.deriveQualitySettings();
          this.boundPerformanceCheck = this.performanceCheck.bind(this);
          this.boundThermalCheck = this.thermalCheck.bind(this);
          Y3K?.debug?.log("AdaptivePerformanceSystem", "Initialized with profile:", this.currentProfile.tier);
        }
        async initialize() {
          await this.initializeHardwareMonitoring();
          this.startPerformanceMonitoring();
          await this.initializePowerManagement();
          this.initializeThermalMonitoring();
          Y3K?.debug?.log("AdaptivePerformanceSystem", "Performance monitoring started");
        }
        detectHardware() {
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
          const cpuCores = navigator.hardwareConcurrency || 4;
          const cpuArchitecture = this.detectCPUArchitecture();
          const memoryInfo = performance.memory;
          const totalMemoryGB = memoryInfo ? memoryInfo.jsHeapSizeLimit / (1024 * 1024 * 1024) : 4;
          const availableMemoryMB = memoryInfo ? (memoryInfo.jsHeapSizeLimit - memoryInfo.usedJSHeapSize) / (1024 * 1024) : 1024;
          let gpuVendor = "unknown";
          let gpuRenderer = "unknown";
          let maxTextureSize = 2048;
          let webglVersion = "none";
          if (gl) {
            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            if (debugInfo) {
              gpuVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || "unknown";
              gpuRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || "unknown";
            }
            maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            webglVersion = gl instanceof WebGL2RenderingContext ? "2.0" : "1.0";
          }
          const devicePixelRatio = window.devicePixelRatio || 1;
          const screenResolution = {
            width: screen.width * devicePixelRatio,
            height: screen.height * devicePixelRatio
          };
          return {
            cpuCores,
            cpuFrequency: 0,
            // Not directly detectable
            cpuArchitecture,
            totalMemoryGB,
            availableMemoryMB,
            memoryPressure: availableMemoryMB < 512 ? "high" : availableMemoryMB < 1024 ? "medium" : "low",
            gpuVendor,
            gpuRenderer,
            maxTextureSize,
            webglVersion,
            devicePixelRatio,
            screenResolution,
            powerLevel: "balanced",
            // Will be updated by power management
            thermalState: "nominal"
          };
        }
        detectCPUArchitecture() {
          const userAgent = navigator.userAgent.toLowerCase();
          if (userAgent.includes("arm64") || userAgent.includes("aarch64")) {
            return "arm64";
          } else if (userAgent.includes("arm")) {
            return "arm32";
          } else if (userAgent.includes("x86_64") || userAgent.includes("amd64")) {
            return "x64";
          } else if (userAgent.includes("x86")) {
            return "x86";
          }
          return "unknown";
        }
        determineOptimalProfile() {
          const deviceTier = this.deviceDetector.recommendPerformanceQuality();
          const isMobile = /Mobi|Android/i.test(navigator.userAgent);
          const isLowMemory = this.hardwareMetrics.memoryPressure === "high";
          const hasWebGL2 = this.hardwareMetrics.webglVersion === "2.0";
          let tier;
          if (isLowMemory || !hasWebGL2) {
            tier = "minimal";
          } else if (isMobile) {
            tier = deviceTier === "high" ? "medium" : "low";
          } else {
            switch (deviceTier) {
              case "high":
                tier = this.hardwareMetrics.cpuCores >= 8 ? "ultra" : "high";
                break;
              case "balanced":
                tier = "medium";
                break;
              default:
                tier = "low";
            }
          }
          const profiles = {
            ultra: {
              tier: "ultra",
              targetFPS: 60,
              memoryBudgetMB: 100,
              cpuBudgetPercent: 20,
              gpuBudgetPercent: 40,
              thermalLimit: 75,
              adaptiveScaling: true
            },
            high: {
              tier: "high",
              targetFPS: 60,
              memoryBudgetMB: 75,
              cpuBudgetPercent: 15,
              gpuBudgetPercent: 30,
              thermalLimit: 70,
              adaptiveScaling: true
            },
            medium: {
              tier: "medium",
              targetFPS: 45,
              memoryBudgetMB: 50,
              cpuBudgetPercent: 10,
              gpuBudgetPercent: 20,
              thermalLimit: 65,
              adaptiveScaling: true
            },
            low: {
              tier: "low",
              targetFPS: 30,
              memoryBudgetMB: 32,
              cpuBudgetPercent: 8,
              gpuBudgetPercent: 15,
              thermalLimit: 60,
              adaptiveScaling: false
            },
            minimal: {
              tier: "minimal",
              targetFPS: 24,
              memoryBudgetMB: 20,
              cpuBudgetPercent: 5,
              gpuBudgetPercent: 10,
              thermalLimit: 55,
              adaptiveScaling: false
            }
          };
          return profiles[tier];
        }
        calculatePerformanceBudget() {
          const frameTimeMs = 1e3 / this.currentProfile.targetFPS;
          return {
            frameTimeMs,
            memoryLimitMB: this.currentProfile.memoryBudgetMB,
            cpuTimeSliceMs: frameTimeMs * 0.8,
            // 80% of frame time for CPU
            gpuUtilizationPercent: this.currentProfile.gpuBudgetPercent,
            networkBandwidthKBps: 100
            // Conservative network budget
          };
        }
        deriveQualitySettings() {
          const scale = this.qualityScales[this.currentProfile.tier];
          return {
            gradientComplexity: scale.complexity,
            particleDensity: scale.particles,
            shaderPrecision: scale.precision,
            textureResolution: scale.complexity,
            animationFPS: scale.fps,
            transitionQuality: this.currentProfile.tier === "ultra" ? "cinematic" : this.currentProfile.tier === "high" ? "smooth" : this.currentProfile.tier === "medium" ? "basic" : "instant",
            motionBlur: this.currentProfile.tier === "ultra",
            bloomEnabled: scale.complexity > 0.6,
            shadowQuality: this.currentProfile.tier === "ultra" ? "high" : this.currentProfile.tier === "high" ? "medium" : this.currentProfile.tier === "medium" ? "low" : "off",
            antiAliasing: this.currentProfile.tier === "ultra" ? "msaa4x" : this.currentProfile.tier === "high" ? "msaa2x" : this.currentProfile.tier === "medium" ? "fxaa" : "none",
            postProcessing: scale.complexity > 0.5
          };
        }
        async initializeHardwareMonitoring() {
          if ("memory" in performance) {
          }
          if ("connection" in navigator) {
            const connection = navigator.connection;
            if (connection) {
              connection.addEventListener("change", () => {
                this.adaptToConnectionSpeed(connection.effectiveType);
              });
            }
          }
        }
        startPerformanceMonitoring() {
          if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
          }
          this.monitoringInterval = window.setInterval(this.boundPerformanceCheck, 1e3);
        }
        performanceCheck() {
          const fps = this.performanceAnalyzer.getMedianFPS() || 0;
          const frameTime = fps > 0 ? 1e3 / fps : 1e3;
          const memoryInfo = performance.memory;
          const memoryUsage = memoryInfo ? memoryInfo.usedJSHeapSize / (1024 * 1024) : 0;
          const cpuUsage = this.estimateCPUUsage(fps, frameTime);
          const gpuUsage = this.estimateGPUUsage(fps, frameTime);
          this.performanceHistory.push({
            timestamp: performance.now(),
            fps,
            frameTime,
            memoryUsage,
            cpuUsage,
            gpuUsage,
            thermalState: this.hardwareMetrics.thermalState
          });
          const cutoff = performance.now() - 3e4;
          this.performanceHistory = this.performanceHistory.filter((entry) => entry.timestamp > cutoff);
          this.checkAdaptationNeeded();
        }
        estimateCPUUsage(fps, frameTime) {
          const targetFrameTime = this.currentBudget.frameTimeMs;
          const usage = Math.min(frameTime / targetFrameTime * 100, 100);
          return Math.max(usage, 5);
        }
        estimateGPUUsage(fps, frameTime) {
          const complexity = this.currentQuality.gradientComplexity;
          const baseUsage = complexity * 20;
          const frameTimeImpact = frameTime > this.currentBudget.frameTimeMs ? 10 : 0;
          return Math.min(baseUsage + frameTimeImpact, 100);
        }
        checkAdaptationNeeded() {
          if (!this.currentProfile.adaptiveScaling) return;
          if (performance.now() - this.lastAdaptation < this.adaptationCooldown) return;
          if (this.performanceHistory.length < 5) return;
          const recent = this.performanceHistory.slice(-5);
          const avgFPS = recent.reduce((sum, entry) => sum + entry.fps, 0) / recent.length;
          const avgMemory = recent.reduce((sum, entry) => sum + entry.memoryUsage, 0) / recent.length;
          const avgFrameTime = recent.reduce((sum, entry) => sum + entry.frameTime, 0) / recent.length;
          const fpsIssue = avgFPS < this.currentProfile.targetFPS * 0.8;
          const memoryIssue = avgMemory > this.currentBudget.memoryLimitMB;
          const frameTimeIssue = avgFrameTime > this.currentBudget.frameTimeMs * 1.2;
          const thermalIssue = this.hardwareMetrics.thermalState !== "nominal";
          if (fpsIssue || memoryIssue || frameTimeIssue || thermalIssue) {
            this.adaptPerformanceDown();
          } else if (this.canScaleUp(avgFPS, avgMemory, avgFrameTime)) {
            this.adaptPerformanceUp();
          }
        }
        canScaleUp(fps, memory, frameTime) {
          const fpsHeadroom = fps > this.currentProfile.targetFPS * 1.1;
          const memoryHeadroom = memory < this.currentBudget.memoryLimitMB * 0.7;
          const frameTimeHeadroom = frameTime < this.currentBudget.frameTimeMs * 0.8;
          const noThermalIssues = this.hardwareMetrics.thermalState === "nominal";
          return fpsHeadroom && memoryHeadroom && frameTimeHeadroom && noThermalIssues;
        }
        adaptPerformanceDown() {
          const oldQuality = { ...this.currentQuality };
          this.currentQuality.gradientComplexity = Math.max(0.1, this.currentQuality.gradientComplexity * 0.8);
          this.currentQuality.particleDensity = Math.max(0.1, this.currentQuality.particleDensity * 0.8);
          if (this.currentQuality.animationFPS > 24) {
            this.currentQuality.animationFPS = Math.max(24, this.currentQuality.animationFPS - 15);
          }
          if (this.currentQuality.postProcessing) {
            this.currentQuality.postProcessing = false;
          } else if (this.currentQuality.bloomEnabled) {
            this.currentQuality.bloomEnabled = false;
          } else if (this.currentQuality.antiAliasing !== "none") {
            this.currentQuality.antiAliasing = this.currentQuality.antiAliasing === "msaa4x" ? "msaa2x" : this.currentQuality.antiAliasing === "msaa2x" ? "fxaa" : "none";
          }
          this.lastAdaptation = performance.now();
          this.emitAdaptationEvent({
            type: "quality-change",
            reason: "Performance optimization",
            oldSettings: oldQuality,
            newSettings: { ...this.currentQuality },
            timestamp: performance.now()
          });
          Y3K?.debug?.log("AdaptivePerformanceSystem", "Adapted performance down", {
            complexity: this.currentQuality.gradientComplexity,
            fps: this.currentQuality.animationFPS
          });
        }
        adaptPerformanceUp() {
          const oldQuality = { ...this.currentQuality };
          this.currentQuality.gradientComplexity = Math.min(1, this.currentQuality.gradientComplexity * 1.1);
          this.currentQuality.particleDensity = Math.min(1, this.currentQuality.particleDensity * 1.1);
          if (this.currentQuality.animationFPS < this.currentProfile.targetFPS) {
            this.currentQuality.animationFPS = Math.min(this.currentProfile.targetFPS, this.currentQuality.animationFPS + 15);
          }
          if (!this.currentQuality.bloomEnabled && this.currentQuality.gradientComplexity > 0.6) {
            this.currentQuality.bloomEnabled = true;
          } else if (!this.currentQuality.postProcessing && this.currentQuality.gradientComplexity > 0.7) {
            this.currentQuality.postProcessing = true;
          }
          this.lastAdaptation = performance.now();
          this.emitAdaptationEvent({
            type: "quality-change",
            reason: "Performance headroom available",
            oldSettings: oldQuality,
            newSettings: { ...this.currentQuality },
            timestamp: performance.now()
          });
          Y3K?.debug?.log("AdaptivePerformanceSystem", "Adapted performance up", {
            complexity: this.currentQuality.gradientComplexity,
            fps: this.currentQuality.animationFPS
          });
        }
        async initializePowerManagement() {
          if ("getBattery" in navigator) {
            try {
              this.batteryAPI = await navigator.getBattery();
              this.batteryAPI.addEventListener("chargingchange", () => this.updatePowerLevel());
              this.batteryAPI.addEventListener("levelchange", () => this.updatePowerLevel());
              this.updatePowerLevel();
            } catch (error) {
              Y3K?.debug?.warn("AdaptivePerformanceSystem", "Battery API not available:", error);
            }
          }
        }
        updatePowerLevel() {
          if (!this.batteryAPI) return;
          const charging = this.batteryAPI.charging;
          const level = this.batteryAPI.level;
          if (charging) {
            this.hardwareMetrics.powerLevel = "high";
          } else if (level > 0.5) {
            this.hardwareMetrics.powerLevel = "balanced";
          } else {
            this.hardwareMetrics.powerLevel = "battery-saver";
            if (level < 0.2) {
              this.adaptToBatterySaver();
            }
          }
        }
        adaptToBatterySaver() {
          const oldQuality = { ...this.currentQuality };
          this.currentQuality.gradientComplexity = 0.2;
          this.currentQuality.particleDensity = 0.1;
          this.currentQuality.animationFPS = 24;
          this.currentQuality.postProcessing = false;
          this.currentQuality.bloomEnabled = false;
          this.currentQuality.antiAliasing = "none";
          this.currentQuality.shadowQuality = "off";
          this.emitAdaptationEvent({
            type: "quality-change",
            reason: "Battery conservation mode",
            oldSettings: oldQuality,
            newSettings: { ...this.currentQuality },
            timestamp: performance.now()
          });
        }
        initializeThermalMonitoring() {
          setInterval(this.boundThermalCheck, 1e4);
        }
        thermalCheck() {
          if (this.performanceHistory.length < 10) return;
          const recent = this.performanceHistory.slice(-10);
          const avgFPS = recent.reduce((sum, entry) => sum + entry.fps, 0) / recent.length;
          const fpsDecline = this.performanceHistory.length > 20 ? this.performanceHistory.slice(-20, -10).reduce((sum, entry) => sum + entry.fps, 0) / 10 - avgFPS : 0;
          let newThermalState = "nominal";
          if (fpsDecline > 10) {
            newThermalState = "critical";
          } else if (fpsDecline > 5) {
            newThermalState = "hot";
          } else if (fpsDecline > 2) {
            newThermalState = "warm";
          }
          if (newThermalState !== this.hardwareMetrics.thermalState) {
            this.hardwareMetrics.thermalState = newThermalState;
            if (newThermalState !== "nominal") {
              this.handleThermalThrottling(newThermalState);
            }
          }
          this.thermalHistory.push(avgFPS);
          if (this.thermalHistory.length > 20) {
            this.thermalHistory.shift();
          }
        }
        handleThermalThrottling(thermalState) {
          const oldQuality = { ...this.currentQuality };
          switch (thermalState) {
            case "warm":
              this.currentQuality.animationFPS = Math.max(30, this.currentQuality.animationFPS);
              this.currentQuality.postProcessing = false;
              break;
            case "hot":
              this.currentQuality.animationFPS = 24;
              this.currentQuality.gradientComplexity *= 0.7;
              this.currentQuality.particleDensity *= 0.5;
              break;
            case "critical":
              this.currentQuality.animationFPS = 15;
              this.currentQuality.gradientComplexity = 0.2;
              this.currentQuality.particleDensity = 0.1;
              this.currentQuality.postProcessing = false;
              this.currentQuality.bloomEnabled = false;
              break;
          }
          this.emitAdaptationEvent({
            type: "thermal-throttle",
            reason: `Thermal throttling: ${thermalState}`,
            oldSettings: oldQuality,
            newSettings: { ...this.currentQuality },
            timestamp: performance.now()
          });
          Y3K?.debug?.warn("AdaptivePerformanceSystem", `Thermal throttling activated: ${thermalState}`);
        }
        adaptToConnectionSpeed(effectiveType) {
          const isSlowConnection = effectiveType === "slow-2g" || effectiveType === "2g";
          if (isSlowConnection) {
            this.currentBudget.networkBandwidthKBps = 20;
          } else if (effectiveType === "3g") {
            this.currentBudget.networkBandwidthKBps = 50;
          } else {
            this.currentBudget.networkBandwidthKBps = 100;
          }
        }
        emitAdaptationEvent(event) {
          this.eventListeners.forEach((listener) => {
            try {
              listener(event);
            } catch (error) {
              Y3K?.debug?.error("AdaptivePerformanceSystem", "Event listener error:", error);
            }
          });
        }
        // Public API
        getHardwareMetrics() {
          return { ...this.hardwareMetrics };
        }
        getCurrentProfile() {
          return { ...this.currentProfile };
        }
        getCurrentBudget() {
          return { ...this.currentBudget };
        }
        getCurrentQuality() {
          return { ...this.currentQuality };
        }
        getPerformanceHistory() {
          return [...this.performanceHistory];
        }
        addEventListener(listener) {
          this.eventListeners.push(listener);
        }
        removeEventListener(listener) {
          const index = this.eventListeners.indexOf(listener);
          if (index > -1) {
            this.eventListeners.splice(index, 1);
          }
        }
        setProfile(profile) {
          this.currentProfile = { ...this.currentProfile, ...profile };
          this.currentBudget = this.calculatePerformanceBudget();
          this.currentQuality = this.deriveQualitySettings();
        }
        setQuality(quality) {
          const oldQuality = { ...this.currentQuality };
          this.currentQuality = { ...this.currentQuality, ...quality };
          this.emitAdaptationEvent({
            type: "quality-change",
            reason: "Manual quality adjustment",
            oldSettings: oldQuality,
            newSettings: { ...this.currentQuality },
            timestamp: performance.now()
          });
        }
        forceAdaptation() {
          this.lastAdaptation = 0;
          this.checkAdaptationNeeded();
        }
        destroy() {
          if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
          }
          if (this.adaptationTimer) {
            clearTimeout(this.adaptationTimer);
            this.adaptationTimer = null;
          }
          if (this.batteryAPI) {
            this.batteryAPI.removeEventListener("chargingchange", this.updatePowerLevel);
            this.batteryAPI.removeEventListener("levelchange", this.updatePowerLevel);
          }
          this.eventListeners = [];
          this.performanceHistory = [];
          this.thermalHistory = [];
          Y3K?.debug?.log("AdaptivePerformanceSystem", "Destroyed");
        }
      };
      __name(_AdaptivePerformanceSystem, "AdaptivePerformanceSystem");
      AdaptivePerformanceSystem = _AdaptivePerformanceSystem;
    }
  });

  // src-js/visual/integration/VisualSystemFacade.ts
  var _VisualSystemFacade, VisualSystemFacade;
  var init_VisualSystemFacade = __esm({
    "src-js/visual/integration/VisualSystemFacade.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_DeviceCapabilityDetector();
      init_LightweightParticleSystem();
      init_ParticleFieldSystem();
      init_WebGLGradientBackgroundSystem();
      init_OrganicBeatSyncConsciousness();
      init_InteractionTrackingSystem();
      init_SpotifyUIApplicationSystem();
      init_AdaptivePerformanceSystem();
      _VisualSystemFacade = class _VisualSystemFacade {
        constructor(config, utils, year3000System2, cssVariableBatcher, performanceAnalyzer, musicSyncService, settingsManager, colorHarmonyEngine, eventBus) {
          this.colorHarmonyEngine = null;
          this.eventBus = null;
          this.adaptivePerformanceSystem = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Event handlers
          this.boundAdaptationHandler = null;
          this.boundSettingsHandler = null;
          // Monitoring intervals
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Event callbacks
          this.onSystemAdaptation = null;
          this.onHealthChange = null;
          this.onSystemCreated = null;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System2;
          this.cssVariableBatcher = cssVariableBatcher;
          this.performanceAnalyzer = performanceAnalyzer;
          this.musicSyncService = musicSyncService;
          this.settingsManager = settingsManager;
          this.colorHarmonyEngine = colorHarmonyEngine || null;
          this.eventBus = eventBus || null;
          this.deviceDetector = new DeviceCapabilityDetector();
          this.systemRegistry = /* @__PURE__ */ new Map();
          this.systemCache = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.bridgeConfig = {
            mode: "progressive",
            enablePerformanceMonitoring: true,
            enableAdaptiveQuality: true,
            enableEventCoordination: true,
            performanceThresholds: {
              minFPS: 45,
              maxMemoryMB: 50,
              thermalLimit: 70
            },
            qualityPreferences: {
              preferHighQuality: true,
              allowDynamicScaling: true,
              batteryConservation: false
            }
          };
          this.currentMetrics = this.createInitialMetrics();
          this.boundAdaptationHandler = this.handleAdaptationEvent.bind(this);
          this.boundSettingsHandler = this.handleSettingsChange.bind(this);
          this.registerVisualSystems();
          Y3K?.debug?.log("VisualSystemFacade", "Factory facade initialized with visual systems");
        }
        registerVisualSystems() {
          this.systemRegistry.set("Particle", LightweightParticleSystem);
          this.systemDependencies.set("Particle", ["performanceAnalyzer", "cssVariableBatcher"]);
          this.systemRegistry.set("ParticleField", ParticleFieldSystem);
          this.systemDependencies.set("ParticleField", ["performanceAnalyzer", "cssVariableBatcher"]);
          this.systemRegistry.set("WebGLBackground", WebGLGradientBackgroundSystem);
          this.systemDependencies.set("WebGLBackground", ["performanceAnalyzer", "eventBus"]);
          this.systemRegistry.set("OrganicBeatSync", OrganicBeatSyncConsciousness);
          this.systemDependencies.set("OrganicBeatSync", ["performanceAnalyzer", "cssVariableBatcher", "eventBus", "musicSyncService", "colorHarmonyEngine"]);
          this.systemRegistry.set("InteractionTracking", InteractionTrackingSystem);
          this.systemDependencies.set("InteractionTracking", ["performanceAnalyzer", "cssVariableBatcher"]);
          this.systemRegistry.set("SpotifyUIApplication", SpotifyUIApplicationSystem);
          this.systemDependencies.set("SpotifyUIApplication", ["year3000System"]);
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3K?.debug?.warn("VisualSystemFacade", "Already initialized");
            return;
          }
          try {
            this.bridgeConfig = { ...this.bridgeConfig, ...config };
            await this.deviceDetector.initialize();
            if (this.bridgeConfig.enablePerformanceMonitoring) {
              this.adaptivePerformanceSystem = new AdaptivePerformanceSystem(
                this.deviceDetector,
                this.performanceAnalyzer
              );
              await this.adaptivePerformanceSystem.initialize();
              this.adaptivePerformanceSystem.addEventListener(this.boundAdaptationHandler);
            }
            await this.applyConfiguration();
            this.subscribeToEvents();
            this.startMonitoring();
            await this.performVisualHealthCheck();
            this.isInitialized = true;
            this.cssVariableBatcher.queueCSSVariableUpdate("--sn-visual-bridge-active", "1");
            this.cssVariableBatcher.queueCSSVariableUpdate("--sn-visual-bridge-mode", this.bridgeConfig.mode);
            Y3K?.debug?.log("VisualSystemFacade", "Facade fully initialized", {
              mode: this.bridgeConfig.mode,
              systemsRegistered: this.systemRegistry.size,
              performanceMonitoring: this.bridgeConfig.enablePerformanceMonitoring
            });
          } catch (error) {
            Y3K?.debug?.error("VisualSystemFacade", "Initialization failed:", error);
            await this.cleanup();
            throw error;
          }
        }
        /**
         * Factory method to create and return visual systems
         * This is the main interface for the facade pattern
         */
        getVisualSystem(key) {
          if (this.systemCache.has(key)) {
            return this.systemCache.get(key);
          }
          const system = this.createVisualSystem(key);
          this.systemCache.set(key, system);
          this.currentMetrics.activeVisualSystems.push(key);
          if (this.onSystemCreated) {
            this.onSystemCreated(key, system);
          }
          return system;
        }
        /**
         * Create a new visual system instance with proper dependency injection
         */
        createVisualSystem(key) {
          const SystemClass = this.systemRegistry.get(key);
          if (!SystemClass) {
            throw new Error(`Visual system '${key}' not found in registry`);
          }
          const testInstance = new SystemClass(this.config);
          if (typeof testInstance._baseInitialize === "function") {
            const system2 = testInstance;
            this.injectUnifiedSystemDependencies(system2, key);
            return system2;
          }
          if (key === "SpotifyUIApplication") {
            const system2 = new SystemClass(this.year3000System);
            this.injectDependencies(system2, key);
            return system2;
          }
          const system = new SystemClass(
            this.config,
            this.utils,
            this.performanceAnalyzer,
            this.musicSyncService,
            this.settingsManager,
            this.year3000System
          );
          this.injectDependencies(system, key);
          return system;
        }
        /**
         * Inject dependencies into visual systems
         */
        injectDependencies(system, key) {
          const dependencies = this.systemDependencies.get(key) || [];
          if (dependencies.includes("performanceAnalyzer") && system.setPerformanceAnalyzer) {
            system.setPerformanceAnalyzer(this.performanceAnalyzer);
          }
          if (dependencies.includes("cssVariableBatcher") && system.setCSSVariableBatcher) {
            system.setCSSVariableBatcher(this.cssVariableBatcher);
          }
          if (dependencies.includes("eventBus") && this.eventBus && system.setEventBus) {
            system.setEventBus(this.eventBus);
          }
          if (this.colorHarmonyEngine && system.setColorHarmonyEngine) {
            system.setColorHarmonyEngine(this.colorHarmonyEngine);
          }
          if (dependencies.includes("musicSyncService") && system.setMusicSyncService) {
            system.setMusicSyncService(this.musicSyncService);
          }
          this.integratePerformanceMonitoring(system, key);
        }
        /**
         * Inject dependencies into UnifiedSystemBase-derived systems
         */
        injectUnifiedSystemDependencies(system, key) {
          if (this.cssVariableBatcher) {
            system.cssVariableBatcher = this.cssVariableBatcher;
          }
          if (this.performanceAnalyzer) {
            system.performanceAnalyzer = this.performanceAnalyzer;
          }
          if (this.year3000System) {
            globalThis.year3000System = this.year3000System;
          }
          this.integratePerformanceMonitoring(system, key);
        }
        /**
         * Integrate performance monitoring for visual systems
         */
        integratePerformanceMonitoring(system, key) {
          if (!this.bridgeConfig.enablePerformanceMonitoring) return;
          const originalUpdateAnimation = system.updateAnimation;
          if (typeof originalUpdateAnimation === "function") {
            system.updateAnimation = (deltaTime) => {
              const startTime = performance.now();
              originalUpdateAnimation.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer.recordMetric(
                `Visual_${key}`,
                endTime - startTime
              );
            };
          }
          const originalOnAnimate = system.onAnimate;
          if (typeof originalOnAnimate === "function") {
            system.onAnimate = (deltaTime) => {
              const startTime = performance.now();
              originalOnAnimate.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer.recordMetric(
                `Visual_${key}_Animate`,
                endTime - startTime
              );
            };
          }
          if (this.adaptivePerformanceSystem) {
            this.adaptiveQualityControl(system, key);
          }
        }
        /**
         * Apply adaptive quality control to visual systems
         */
        adaptiveQualityControl(system, key) {
          if (!this.eventBus) return;
          this.eventBus.subscribe("performance:degradation", (event) => {
            if (system.reduceQuality) {
              system.reduceQuality(event.reductionLevel);
            }
          });
          this.eventBus.subscribe("performance:improvement", (event) => {
            if (system.increaseQuality) {
              system.increaseQuality(event.improvementLevel);
            }
          });
        }
        /**
         * Handle adaptation events from the performance system
         */
        handleAdaptationEvent(event) {
          Y3K?.debug?.log("VisualSystemFacade", `Adaptation event: ${event.type}`, event.reason);
          this.currentMetrics.currentQuality = event.newSettings;
          this.systemCache.forEach((system, key) => {
            if (system.handleAdaptationEvent) {
              system.handleAdaptationEvent(event);
            }
          });
          if (this.onSystemAdaptation) {
            this.onSystemAdaptation(this.currentMetrics);
          }
          this.cssVariableBatcher.queueCSSVariableUpdate("--sn-adaptive-quality", event.newSettings.gradientComplexity.toString());
          this.cssVariableBatcher.queueCSSVariableUpdate("--sn-adaptive-fps", event.newSettings.animationFPS.toString());
        }
        /**
         * Propagate visual events to all systems
         */
        propagateVisualEvent(event) {
          if (!this.bridgeConfig.enableEventCoordination) return;
          this.systemCache.forEach((system, key) => {
            if (system.handleVisualEvent) {
              try {
                system.handleVisualEvent(event);
              } catch (error) {
                Y3K?.debug?.warn("VisualSystemFacade", `Error propagating event to ${key}:`, error);
              }
            }
          });
          this.currentMetrics.eventCount++;
          this.currentMetrics.lastEventTime = performance.now();
        }
        /**
         * Initialize all visual systems at once
         */
        async initializeVisualSystems() {
          const initPromises = Array.from(this.systemCache.entries()).map(async ([key, system]) => {
            try {
              if (typeof system._baseInitialize === "function") {
                await system._baseInitialize();
              } else {
                await system.initialize();
              }
              Y3K?.debug?.log("VisualSystemFacade", `Initialized visual system: ${key}`);
              return { key, success: true };
            } catch (error) {
              Y3K?.debug?.error("VisualSystemFacade", `Failed to initialize ${key}:`, error);
              return { key, success: false, error };
            }
          });
          const results = await Promise.allSettled(initPromises);
          const successCount = results.filter((r) => r.status === "fulfilled" && r.value.success).length;
          Y3K?.debug?.log("VisualSystemFacade", `Visual systems initialized: ${successCount}/${results.length}`);
        }
        /**
         * Perform health check on all visual systems
         */
        async performVisualHealthCheck() {
          const healthCheck = {
            overall: "good",
            systems: /* @__PURE__ */ new Map(),
            recommendations: [],
            timestamp: performance.now()
          };
          let healthyCount = 0;
          let totalCount = 0;
          for (const [key, system] of this.systemCache) {
            totalCount++;
            try {
              const systemHealth = system.healthCheck ? await system.healthCheck() : { status: "unknown", message: "No health check available" };
              const isHealthy = systemHealth.status === "healthy" || systemHealth.status === "good";
              if (isHealthy) healthyCount++;
              healthCheck.systems.set(key, {
                ok: isHealthy,
                details: systemHealth.message || systemHealth.details || "System operational"
              });
            } catch (error) {
              healthCheck.systems.set(key, {
                ok: false,
                details: `Health check failed: ${error}`
              });
            }
          }
          const healthPercentage = totalCount > 0 ? healthyCount / totalCount : 1;
          if (healthPercentage >= 0.9) {
            healthCheck.overall = "excellent";
          } else if (healthPercentage >= 0.7) {
            healthCheck.overall = "good";
          } else if (healthPercentage >= 0.5) {
            healthCheck.overall = "degraded";
            healthCheck.recommendations.push("Some visual systems are experiencing issues");
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push("Multiple visual system failures detected");
          }
          if (this.currentMetrics.currentFPS < 30) {
            healthCheck.recommendations.push("Low FPS detected - consider reducing visual quality");
          }
          if (this.currentMetrics.memoryUsageMB > 40) {
            healthCheck.recommendations.push("High memory usage - consider optimizing visual systems");
          }
          this.lastHealthCheck = healthCheck;
          this.cssVariableBatcher.queueCSSVariableUpdate("--sn-visual-health", healthCheck.overall);
          return healthCheck;
        }
        // Utility methods
        createInitialMetrics() {
          return {
            currentFPS: 0,
            averageFPS: 0,
            frameTime: 0,
            memoryUsageMB: 0,
            systemHealth: "good",
            activeVisualSystems: [],
            currentQuality: {
              gradientComplexity: 0.6,
              particleDensity: 0.6,
              shaderPrecision: "mediump",
              textureResolution: 1,
              animationFPS: 60,
              transitionQuality: "smooth",
              motionBlur: false,
              bloomEnabled: true,
              shadowQuality: "medium",
              antiAliasing: "fxaa",
              postProcessing: true
            },
            adaptiveScaling: true,
            performanceMonitoring: true,
            eventCoordination: true,
            lastEventTime: 0,
            eventCount: 0
          };
        }
        async applyConfiguration() {
          if (this.adaptivePerformanceSystem) {
            const profile = this.adaptivePerformanceSystem.getCurrentProfile();
            profile.targetFPS = this.bridgeConfig.performanceThresholds.minFPS;
            profile.memoryBudgetMB = this.bridgeConfig.performanceThresholds.maxMemoryMB;
            profile.adaptiveScaling = this.bridgeConfig.enableAdaptiveQuality;
            this.adaptivePerformanceSystem.setProfile(profile);
          }
        }
        subscribeToEvents() {
          if (this.settingsManager && this.boundSettingsHandler) {
            document.addEventListener("year3000SystemSettingsChanged", this.boundSettingsHandler);
          }
        }
        startMonitoring() {
          if (this.bridgeConfig.enablePerformanceMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performVisualHealthCheck();
            }, 1e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 1e3);
          }
        }
        updateMetrics() {
          this.currentMetrics.currentFPS = this.performanceAnalyzer.getMedianFPS() || 0;
          this.currentMetrics.frameTime = this.currentMetrics.currentFPS > 0 ? 1e3 / this.currentMetrics.currentFPS : 1e3;
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.memoryUsageMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          if (this.currentMetrics.currentFPS < 20) {
            this.currentMetrics.systemHealth = "critical";
          } else if (this.currentMetrics.currentFPS < 30) {
            this.currentMetrics.systemHealth = "degraded";
          } else if (this.currentMetrics.currentFPS > 55) {
            this.currentMetrics.systemHealth = "excellent";
          } else {
            this.currentMetrics.systemHealth = "good";
          }
        }
        handleSettingsChange(event) {
          const customEvent = event;
          const { key, value } = customEvent.detail;
          if (key.startsWith("sn-visual-")) {
            this.updateConfigurationFromSettings(key, value);
          }
        }
        updateConfigurationFromSettings(key, value) {
          switch (key) {
            case "sn-visual-quality":
              this.bridgeConfig.qualityPreferences.preferHighQuality = value === "high";
              break;
            case "sn-visual-performance":
              this.bridgeConfig.enableAdaptiveQuality = value === "adaptive";
              break;
          }
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          if (this.boundSettingsHandler) {
            document.removeEventListener("year3000SystemSettingsChanged", this.boundSettingsHandler);
          }
          if (this.adaptivePerformanceSystem) {
            this.adaptivePerformanceSystem.removeEventListener(this.boundAdaptationHandler);
            this.adaptivePerformanceSystem.destroy();
            this.adaptivePerformanceSystem = null;
          }
          this.cssVariableBatcher.queueCSSVariableUpdate("--sn-visual-bridge-active", "0");
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.bridgeConfig };
        }
        async setConfiguration(config) {
          this.bridgeConfig = { ...this.bridgeConfig, ...config };
          await this.applyConfiguration();
        }
        setOnSystemAdaptation(callback) {
          this.onSystemAdaptation = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            systemsActive: this.systemCache.size,
            healthy: this.currentMetrics.systemHealth === "excellent" || this.currentMetrics.systemHealth === "good"
          };
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          this.systemCache.clear();
          Y3K?.debug?.log("VisualSystemFacade", "Facade destroyed");
        }
      };
      __name(_VisualSystemFacade, "VisualSystemFacade");
      VisualSystemFacade = _VisualSystemFacade;
    }
  });

  // src-js/core/performance/TimerConsolidationSystem.ts
  var _TimerConsolidationSystem, TimerConsolidationSystem;
  var init_TimerConsolidationSystem = __esm({
    "src-js/core/performance/TimerConsolidationSystem.ts"() {
      "use strict";
      _TimerConsolidationSystem = class _TimerConsolidationSystem {
        constructor(config = {}) {
          this._timerRegistry = /* @__PURE__ */ new Map();
          this._timerMasterInterval = null;
          this.config = {
            timerIntervalMs: config.timerIntervalMs || 50,
            maxTimerBudget: config.maxTimerBudget || 10,
            enableDebug: config.enableDebug || false,
            ...config
          };
          this._timerPerformanceMetrics = {
            totalExecutions: 0,
            totalTime: 0,
            maxExecutionTime: 0,
            averageExecutionTime: 0,
            skippedTimers: 0,
            timerCallbacks: /* @__PURE__ */ new Map()
          };
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Initialized");
          }
        }
        initialize() {
          if (this.config.enableDebug) {
            console.log(
              "\u23F1\uFE0F [TimerConsolidationSystem] Timer consolidation initialized"
            );
          }
        }
        registerConsolidatedTimer(timerId, callback, intervalMs, priority = "normal") {
          if (this._timerRegistry.has(timerId)) {
            console.warn(
              `[TimerConsolidationSystem] Timer ${timerId} already registered`
            );
            return;
          }
          const timerConfig = {
            callback,
            intervalMs,
            priority,
            lastExecution: 0,
            enabled: true,
            executionCount: 0,
            totalExecutionTime: 0,
            maxExecutionTime: 0,
            skippedExecutions: 0
          };
          this._timerRegistry.set(timerId, timerConfig);
          this._timerPerformanceMetrics.timerCallbacks.set(timerId, {
            calls: 0,
            totalTime: 0,
            maxTime: 0
          });
          if (this.config.enableDebug) {
            console.log(
              `\u23F1\uFE0F [TimerConsolidationSystem] Registered timer: ${timerId} (${intervalMs}ms, ${priority} priority)`
            );
          }
          if (this._timerRegistry.size === 1 && !this._timerMasterInterval) {
            this._startMasterTimer();
          }
        }
        unregisterConsolidatedTimer(timerId) {
          if (this._timerRegistry.has(timerId)) {
            this._timerRegistry.delete(timerId);
            this._timerPerformanceMetrics.timerCallbacks.delete(timerId);
            if (this.config.enableDebug) {
              console.log(
                `\u23F1\uFE0F [TimerConsolidationSystem] Unregistered timer: ${timerId}`
              );
            }
            if (this._timerRegistry.size === 0) {
              this._stopMasterTimer();
            }
          }
        }
        _startMasterTimer() {
          if (this._timerMasterInterval) return;
          this._timerMasterInterval = setInterval(() => {
            this._executeMasterTimerFrame();
          }, this.config.timerIntervalMs);
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Master timer started");
          }
        }
        _stopMasterTimer() {
          if (this._timerMasterInterval) {
            clearInterval(this._timerMasterInterval);
            this._timerMasterInterval = null;
          }
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Master timer stopped");
          }
        }
        _executeMasterTimerFrame() {
          const frameStartTime = performance.now();
          let remainingBudget = this.config.maxTimerBudget;
          const timersByPriority = Array.from(this._timerRegistry.entries()).sort(
            ([, a], [, b]) => {
              const priorityOrder = { critical: 0, normal: 1, background: 2 };
              return priorityOrder[a.priority] - priorityOrder[b.priority];
            }
          );
          for (const [timerId, config] of timersByPriority) {
            if (!config.enabled || remainingBudget <= 0 && config.priority === "background") {
              if (remainingBudget <= 0) config.skippedExecutions++;
              continue;
            }
            const timeSinceLastExecution = frameStartTime - config.lastExecution;
            if (timeSinceLastExecution < config.intervalMs) {
              continue;
            }
            const timerStartTime = performance.now();
            try {
              config.callback();
              const timerExecutionTime = performance.now() - timerStartTime;
              config.executionCount++;
              config.totalExecutionTime += timerExecutionTime;
              config.maxExecutionTime = Math.max(
                config.maxExecutionTime,
                timerExecutionTime
              );
              config.lastExecution = frameStartTime;
              const stats = this._timerPerformanceMetrics.timerCallbacks.get(timerId);
              if (stats) {
                stats.calls++;
                stats.totalTime += timerExecutionTime;
                stats.maxTime = Math.max(stats.maxTime, timerExecutionTime);
              }
              remainingBudget -= timerExecutionTime;
            } catch (error) {
              console.error(
                `[TimerConsolidationSystem] Error in timer ${timerId}:`,
                error
              );
              config.enabled = false;
            }
          }
          const totalFrameTime = performance.now() - frameStartTime;
          this._updateTimerPerformanceMetrics(totalFrameTime);
        }
        _updateTimerPerformanceMetrics(frameTime) {
          const metrics = this._timerPerformanceMetrics;
          metrics.totalExecutions++;
          metrics.totalTime += frameTime;
          metrics.maxExecutionTime = Math.max(metrics.maxExecutionTime, frameTime);
          metrics.averageExecutionTime = metrics.totalTime / metrics.totalExecutions;
          if (frameTime > this.config.maxTimerBudget) {
            metrics.skippedTimers++;
          }
        }
        destroy() {
          this._stopMasterTimer();
          this._timerRegistry.clear();
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Destroyed");
          }
        }
      };
      __name(_TimerConsolidationSystem, "TimerConsolidationSystem");
      TimerConsolidationSystem = _TimerConsolidationSystem;
    }
  });

  // src-js/core/css/PerformanceCSSIntegration.ts
  var _PerformanceCSSIntegration, PerformanceCSSIntegration;
  var init_PerformanceCSSIntegration = __esm({
    "src-js/core/css/PerformanceCSSIntegration.ts"() {
      "use strict";
      init_EventBus();
      _PerformanceCSSIntegration = class _PerformanceCSSIntegration {
        constructor(config, cssVariableManager, performanceCoordinator) {
          // Performance state tracking
          this.currentDeviceCapabilities = null;
          this.currentPerformanceMode = null;
          this.lastCSSUpdate = 0;
          this.cssUpdateThrottle = 100;
          // Update CSS at most every 100ms
          // CSS class management
          this.appliedClasses = /* @__PURE__ */ new Set();
          this.config = config;
          this.cssVariableManager = cssVariableManager;
          this.performanceCoordinator = performanceCoordinator;
          this.eventBus = GlobalEventBus;
          this.cssConfig = {
            enableAdaptiveOptimization: true,
            enableThermalThrottling: true,
            enableBatteryOptimization: true,
            enableDeviceTierOptimization: true,
            debugPerformanceClasses: this.config.enableDebug
          };
          this.currentDeviceCapabilities = this.performanceCoordinator.getDeviceCapabilities();
          this.currentPerformanceMode = this.performanceCoordinator.getCurrentPerformanceMode();
          this.subscribeToEvents();
          this.applyInitialOptimizations();
          if (this.config.enableDebug) {
            console.log("[PerformanceCSSIntegration] Initialized with device tier:", this.currentDeviceCapabilities.performanceTier);
          }
        }
        /**
         * Get or create singleton instance
         */
        static getInstance(config, cssVariableManager, performanceCoordinator) {
          if (!_PerformanceCSSIntegration.instance) {
            if (!config || !cssVariableManager || !performanceCoordinator) {
              throw new Error("PerformanceCSSIntegration requires all dependencies for first initialization");
            }
            _PerformanceCSSIntegration.instance = new _PerformanceCSSIntegration(
              config,
              cssVariableManager,
              performanceCoordinator
            );
          }
          return _PerformanceCSSIntegration.instance;
        }
        /**
         * Update CSS optimization configuration
         */
        updateConfig(newConfig) {
          this.cssConfig = { ...this.cssConfig, ...newConfig };
          this.applyCurrentOptimizations();
          if (this.config.enableDebug) {
            console.log("[PerformanceCSSIntegration] Configuration updated:", this.cssConfig);
          }
        }
        /**
         * Force CSS performance update
         */
        forceUpdate() {
          this.lastCSSUpdate = 0;
          this.updateCSSPerformanceVariables();
          this.applyCurrentOptimizations();
        }
        /**
         * Get current CSS configuration
         */
        getConfig() {
          return { ...this.cssConfig };
        }
        /**
         * Apply device-specific CSS classes
         */
        applyDeviceOptimizations() {
          if (!this.cssConfig.enableDeviceTierOptimization || !this.currentDeviceCapabilities) return;
          this.removeClassesByPrefix("device-tier-");
          this.removeClassesByPrefix("device-mobile-");
          this.removeClassesByPrefix("device-gpu-");
          const tierClass = `device-tier-${this.currentDeviceCapabilities.performanceTier}`;
          this.addCSSClass(tierClass);
          if (this.currentDeviceCapabilities.isMobile) {
            this.addCSSClass("device-mobile-optimized");
          }
          if (this.currentDeviceCapabilities.gpuAcceleration) {
            this.addCSSClass("device-gpu-accelerated");
          } else {
            this.addCSSClass("device-gpu-fallback");
          }
          const memoryTier = this.getMemoryTier(this.currentDeviceCapabilities.memoryGB);
          this.addCSSClass(`device-memory-${memoryTier}`);
        }
        /**
         * Apply performance mode CSS classes
         */
        applyPerformanceModeOptimizations() {
          if (!this.currentPerformanceMode) return;
          this.removeClassesByPrefix("performance-mode-");
          const modeClass = `performance-mode-${this.currentPerformanceMode.name}`;
          this.addCSSClass(modeClass);
          const optimizationClass = `optimization-level-${this.currentPerformanceMode.optimizationLevel}`;
          this.addCSSClass(optimizationClass);
        }
        /**
         * Apply thermal state CSS classes
         */
        applyThermalOptimizations(thermalState) {
          if (!this.cssConfig.enableThermalThrottling) return;
          this.removeClassesByPrefix("thermal-");
          const thermalClass = `thermal-${thermalState}`;
          this.addCSSClass(thermalClass);
        }
        /**
         * Apply battery state CSS classes
         */
        applyBatteryOptimizations(batteryLevel, charging) {
          if (!this.cssConfig.enableBatteryOptimization) return;
          this.removeClassesByPrefix("battery-");
          if (batteryLevel < 0.2) {
            this.addCSSClass("battery-low");
          } else if (batteryLevel < 0.5) {
            this.addCSSClass("battery-medium");
          } else {
            this.addCSSClass("battery-high");
          }
          if (charging) {
            this.addCSSClass("battery-charging");
          }
        }
        /**
         * Enable/disable debug performance classes
         */
        setDebugMode(enabled) {
          this.cssConfig.debugPerformanceClasses = enabled;
          if (enabled) {
            this.addCSSClass("debug-performance");
          } else {
            this.removeCSSClass("debug-performance");
          }
        }
        /**
         * Get applied CSS classes
         */
        getAppliedClasses() {
          return Array.from(this.appliedClasses);
        }
        /**
         * Destroy the integration
         */
        destroy() {
          for (const className of this.appliedClasses) {
            document.body.classList.remove(className);
          }
          this.appliedClasses.clear();
          if (_PerformanceCSSIntegration.instance === this) {
            _PerformanceCSSIntegration.instance = null;
          }
          if (this.config.enableDebug) {
            console.log("[PerformanceCSSIntegration] Destroyed");
          }
        }
        // =========================================================================
        // PRIVATE METHODS
        // =========================================================================
        /**
         * Subscribe to performance events
         */
        subscribeToEvents() {
          this.eventBus.subscribe("performance:mode-changed", (payload) => {
            this.currentPerformanceMode = this.performanceCoordinator.getCurrentPerformanceMode();
            this.applyPerformanceModeOptimizations();
            this.updateCSSPerformanceVariables();
          });
          this.eventBus.subscribe("performance:thermal-warning", (payload) => {
            this.applyThermalOptimizations(payload.temperature);
          });
          this.eventBus.subscribe("performance:auto-optimized", (payload) => {
            this.currentPerformanceMode = this.performanceCoordinator.getCurrentPerformanceMode();
            this.applyCurrentOptimizations();
            this.updateCSSPerformanceVariables();
          });
          this.eventBus.subscribe("performance:memory-pressure", (payload) => {
            this.updateMemoryPressureClasses(payload.level);
          });
        }
        /**
         * Apply initial CSS optimizations
         */
        applyInitialOptimizations() {
          this.applyDeviceOptimizations();
          this.applyPerformanceModeOptimizations();
          this.updateCSSPerformanceVariables();
          if (this.cssConfig.debugPerformanceClasses) {
            this.setDebugMode(true);
          }
        }
        /**
         * Apply current optimizations
         */
        applyCurrentOptimizations() {
          this.applyDeviceOptimizations();
          this.applyPerformanceModeOptimizations();
          const batteryState = this.performanceCoordinator.getBatteryState();
          const thermalState = this.performanceCoordinator.getThermalState();
          if (batteryState) {
            this.applyBatteryOptimizations(batteryState.level, batteryState.charging);
          }
          const thermalTemp = thermalState.temperature || "normal";
          this.applyThermalOptimizations(thermalTemp);
        }
        /**
         * Update CSS performance variables
         */
        updateCSSPerformanceVariables() {
          const now = Date.now();
          if (now - this.lastCSSUpdate < this.cssUpdateThrottle) return;
          this.lastCSSUpdate = now;
          if (!this.currentPerformanceMode || !this.currentDeviceCapabilities) return;
          this.cssVariableManager.updatePerformanceVariables({
            "mode": this.currentPerformanceMode.name,
            "quality.level": this.currentPerformanceMode.qualityLevel,
            "fps.target": this.currentPerformanceMode.frameRate,
            "frame.budget": 1e3 / this.currentPerformanceMode.frameRate,
            "optimization.level": this.currentPerformanceMode.optimizationLevel
          });
          this.cssVariableManager.updatePerformanceVariables({
            "device.tier": this.currentDeviceCapabilities.performanceTier,
            "device.memory": this.currentDeviceCapabilities.memoryGB,
            "device.gpu": this.currentDeviceCapabilities.gpuAcceleration ? 1 : 0,
            "device.mobile": this.currentDeviceCapabilities.isMobile ? 1 : 0
          });
          this.cssVariableManager.updatePerformanceVariables({
            "blur.quality": this.currentPerformanceMode.blurQuality,
            "shadow.quality": this.currentPerformanceMode.shadowQuality,
            "animation.quality": this.currentPerformanceMode.animationQuality,
            "effect.quality": this.currentPerformanceMode.effectQuality
          });
        }
        /**
         * Add CSS class to document body
         */
        addCSSClass(className) {
          if (!this.appliedClasses.has(className)) {
            document.body.classList.add(className);
            this.appliedClasses.add(className);
          }
        }
        /**
         * Remove CSS class from document body
         */
        removeCSSClass(className) {
          if (this.appliedClasses.has(className)) {
            document.body.classList.remove(className);
            this.appliedClasses.delete(className);
          }
        }
        /**
         * Remove all classes with a specific prefix
         */
        removeClassesByPrefix(prefix) {
          const classesToRemove = Array.from(this.appliedClasses).filter(
            (className) => className.startsWith(prefix)
          );
          for (const className of classesToRemove) {
            this.removeCSSClass(className);
          }
        }
        /**
         * Get memory tier based on available memory
         */
        getMemoryTier(memoryGB) {
          if (memoryGB >= 16) return "high";
          if (memoryGB >= 8) return "medium";
          if (memoryGB >= 4) return "low";
          return "minimal";
        }
        /**
         * Update memory pressure CSS classes
         */
        updateMemoryPressureClasses(level) {
          this.removeClassesByPrefix("memory-pressure-");
          this.addCSSClass(`memory-pressure-${level}`);
        }
      };
      __name(_PerformanceCSSIntegration, "PerformanceCSSIntegration");
      _PerformanceCSSIntegration.instance = null;
      PerformanceCSSIntegration = _PerformanceCSSIntegration;
    }
  });

  // src-js/ui/managers/SettingsManager.ts
  var _SettingsManager, SettingsManager;
  var init_SettingsManager = __esm({
    "src-js/ui/managers/SettingsManager.ts"() {
      "use strict";
      init_globalConfig();
      init_Year3000Utilities();
      _SettingsManager = class _SettingsManager {
        constructor(config = YEAR3000_CONFIG, harmonicModes = HARMONIC_MODES, utils = Year3000Utilities_exports) {
          this.initialized = false;
          this.config = config;
          this.harmonicModes = harmonicModes;
          this.utils = utils;
          this.defaults = {
            "catppuccin-flavor": "mocha",
            "catppuccin-accentColor": "mauve",
            "sn-star-density": "balanced",
            "sn-gradient-intensity": "balanced",
            "sn-glassmorphism-level": "moderate",
            "sn-3d-effects-level": "full",
            "sn-nebula-intensity": "balanced",
            "sn-artistic-mode": "artist-vision",
            "sn-current-harmonic-mode": "analogous-flow",
            "sn-harmonic-intensity": "0.7",
            "sn-harmonic-evolution": "true",
            "sn-harmonic-manual-base-color": "",
            "sn-enable-aberration": "true",
            "sn-nebula-aberration-strength": "0.4",
            "sn-echo-intensity": "2",
            "sn-visual-intensity": (() => {
              try {
                const detector = globalThis.year3000System?.deviceCapabilityDetector;
                const overall = detector?.deviceCapabilities?.overall;
                switch (overall) {
                  case "high":
                    return "1";
                  case "medium":
                    return "0.7";
                  case "low":
                    return "0.4";
                  default:
                    return "0.8";
                }
              } catch (e) {
                return "0.8";
              }
            })(),
            "sn-animation-quality": "auto",
            "sn-glass-beat-pulse": "true",
            "sn-glass-base-intensity": "0.5",
            "sn-flow-gradient": "balanced"
          };
          this.validationSchemas = {
            "catppuccin-flavor": {
              default: "mocha",
              allowedValues: ["latte", "frappe", "macchiato", "mocha"]
            },
            "catppuccin-accentColor": {
              default: "mauve",
              allowedValues: [
                "rosewater",
                "flamingo",
                "pink",
                "mauve",
                "red",
                "maroon",
                "peach",
                "yellow",
                "green",
                "teal",
                "sky",
                "sapphire",
                "blue",
                "lavender",
                "text",
                "none"
              ]
            },
            "sn-star-density": {
              default: "balanced",
              allowedValues: ["disabled", "minimal", "balanced", "intense"]
            },
            "sn-gradient-intensity": {
              default: "balanced",
              allowedValues: ["disabled", "minimal", "balanced", "intense"]
            },
            "sn-glassmorphism-level": {
              default: "moderate",
              allowedValues: ["disabled", "minimal", "moderate", "intense"]
            },
            "sn-3d-effects-level": {
              default: "full",
              allowedValues: ["full", "minimal", "disabled"]
            },
            "sn-nebula-intensity": {
              default: "balanced",
              allowedValues: ["disabled", "minimal", "balanced", "intense"]
            },
            "sn-artistic-mode": {
              default: "artist-vision",
              allowedValues: Object.keys(ARTISTIC_MODE_PROFILES)
            },
            "sn-current-harmonic-mode": {
              default: "analogous-flow",
              allowedValues: Object.keys(
                this.harmonicModes
              )
            },
            "sn-harmonic-intensity": { default: "0.7" },
            "sn-harmonic-evolution": {
              default: "true",
              allowedValues: ["true", "false"]
            },
            "sn-harmonic-manual-base-color": { default: "" },
            "sn-enable-aberration": {
              default: "true",
              allowedValues: ["true", "false"]
            },
            "sn-nebula-aberration-strength": { default: "0.4" },
            "sn-echo-intensity": {
              default: "2",
              allowedValues: ["0", "1", "2", "3"]
            },
            "sn-visual-intensity": { default: "0.8" },
            "sn-animation-quality": {
              default: "auto",
              allowedValues: ["auto", "low", "high"]
            },
            "sn-glass-beat-pulse": {
              default: "true",
              allowedValues: ["true", "false"]
            },
            "sn-glass-base-intensity": { default: "0.5" },
            "sn-flow-gradient": {
              default: "balanced",
              allowedValues: ["disabled", "minimal", "balanced", "intense"]
            }
          };
          this.validateAndRepair();
          this.initialized = true;
        }
        forceRepaint(reason) {
          throw new Error("Method not implemented.");
        }
        async initialize() {
          this.initialized = true;
        }
        async healthCheck() {
          try {
            Spicetify.LocalStorage.get("spicetify-exp-features");
            return {
              healthy: true,
              ok: true,
              details: "LocalStorage is accessible.",
              issues: [],
              system: "SettingsManager"
            };
          } catch (e) {
            return {
              healthy: false,
              ok: false,
              details: "Failed to access Spicetify.LocalStorage.",
              issues: [e.message],
              system: "SettingsManager"
            };
          }
        }
        get(key) {
          try {
            const value = Spicetify.LocalStorage.get(key);
            const schema = this.validationSchemas[key];
            if (!schema) {
              console.warn(`StarryNight: No validation schema for key: ${key}.`);
              return value;
            }
            if (value === null || schema.allowedValues && !schema.allowedValues.includes(value)) {
              return schema.default;
            }
            return value;
          } catch (error) {
            console.error(`StarryNight: Error reading key ${key}:`, error);
            return this.validationSchemas[key]?.default;
          }
        }
        getAllowedValues(key) {
          return this.validationSchemas[key]?.allowedValues;
        }
        set(key, value) {
          try {
            const schema = this.validationSchemas[key];
            if (!schema) {
              Spicetify.LocalStorage.set(key, value);
              return true;
            }
            if (key === "sn-harmonic-manual-base-color") {
              if (value !== "" && !/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)) {
                return false;
              }
            } else if (schema.allowedValues && !schema.allowedValues.includes(value)) {
              return false;
            }
            Spicetify.LocalStorage.set(key, value);
            document.dispatchEvent(
              new CustomEvent("year3000SystemSettingsChanged", {
                detail: { key, value }
              })
            );
            return true;
          } catch (error) {
            console.error(`StarryNight: Error setting key ${key}:`, error);
            return false;
          }
        }
        getAllSettings() {
          const settings = {};
          for (const key in this.validationSchemas) {
            settings[key] = this.get(key);
          }
          return settings;
        }
        validateAndRepair() {
          let repairedCount = 0;
          for (const key in this.validationSchemas) {
            const aKey = key;
            const currentValue = Spicetify.LocalStorage.get(aKey);
            const validatedValue = this.get(aKey);
            if (currentValue !== validatedValue) {
              this.set(aKey, validatedValue);
              repairedCount++;
            }
          }
          if (repairedCount > 0) {
            console.log(`StarryNight: Repaired ${repairedCount} invalid settings.`);
          }
        }
        resetAllToDefaults() {
          for (const key of Object.keys(this.defaults)) {
            this.set(
              key,
              this.defaults[key]
            );
          }
          console.log("StarryNight: All settings reset to defaults.");
        }
        // To satisfy the SystemHealthMonitor, which expects all registered systems
        // to have these lifecycle methods.
        updateAnimation() {
        }
        destroy() {
          console.log("StarryNight: SettingsManager destroyed (no-op).");
        }
        // === NEW: Harmonic mode helpers ===========================================
        /**
         * Return the full HarmonicMode object for the currently selected mode.
         * Falls back to the default entry ("analogous-flow") if the key is missing.
         */
        getCurrentHarmonicMode() {
          const key = this.get("sn-current-harmonic-mode");
          return this.harmonicModes[key] || this.harmonicModes["analogous-flow"];
        }
        /**
         * Retrieve a HarmonicMode definition by key, or undefined if not found.
         */
        getHarmonicMode(key) {
          return this.harmonicModes[key];
        }
      };
      __name(_SettingsManager, "SettingsManager");
      SettingsManager = _SettingsManager;
    }
  });

  // src-js/config/settingKeys.ts
  var GLASS_LEVEL_KEY, GLASS_LEVEL_OLD_KEY, CARD_3D_LEVEL_KEY, HARMONIC_INTENSITY_KEY, HARMONIC_EVOLUTION_KEY, NEBULA_INTENSITY_KEY;
  var init_settingKeys = __esm({
    "src-js/config/settingKeys.ts"() {
      "use strict";
      GLASS_LEVEL_KEY = "sn-glassmorphism-level";
      GLASS_LEVEL_OLD_KEY = "sn-glassmorphismIntensity";
      CARD_3D_LEVEL_KEY = "sn-3d-effects-level";
      HARMONIC_INTENSITY_KEY = "sn-harmonic-intensity";
      HARMONIC_EVOLUTION_KEY = "sn-harmonic-evolution";
      NEBULA_INTENSITY_KEY = "sn-nebula-intensity";
    }
  });

  // src-js/visual/integration/ColorOrchestrator.ts
  var _ColorStrategyRegistry, ColorStrategyRegistry, _ColorOrchestrator, ColorOrchestrator, globalColorOrchestrator;
  var init_ColorOrchestrator = __esm({
    "src-js/visual/integration/ColorOrchestrator.ts"() {
      "use strict";
      init_EventBus();
      init_UnifiedDebugManager();
      _ColorStrategyRegistry = class _ColorStrategyRegistry {
        constructor() {
          this.strategies = /* @__PURE__ */ new Map();
          this.defaultStrategy = null;
        }
        /**
         * Register a color processing strategy
         */
        register(strategy) {
          const name = strategy.getStrategyName();
          this.strategies.set(name, strategy);
          if (!this.defaultStrategy) {
            this.defaultStrategy = strategy;
          }
          Y3K?.debug?.log("ColorStrategyRegistry", `Registered strategy: ${name}`);
        }
        /**
         * Select best strategy for given criteria
         */
        selectStrategy(criteria) {
          if (criteria.performance === "high" && criteria.quality === "basic") {
            for (const strategy of this.strategies.values()) {
              const strategyName = strategy.getStrategyName().toLowerCase();
              if (strategyName.includes("lightweight") || strategyName.includes("fast")) {
                return strategy;
              }
            }
          }
          if (criteria.quality === "premium" && criteria.performance === "low") {
            for (const strategy of this.strategies.values()) {
              const strategyName = strategy.getStrategyName().toLowerCase();
              if (strategyName.includes("harmony") || strategyName.includes("advanced")) {
                return strategy;
              }
            }
          }
          if (criteria.deviceCapabilities?.isMobile) {
            for (const strategy of this.strategies.values()) {
              const strategyName = strategy.getStrategyName().toLowerCase();
              if (strategyName.includes("mobile") || strategyName.includes("optimized")) {
                return strategy;
              }
            }
          }
          return this.defaultStrategy;
        }
        /**
         * Get all registered strategies
         */
        getStrategies() {
          return Array.from(this.strategies.values());
        }
        /**
         * Get strategy by name
         */
        getStrategy(name) {
          return this.strategies.get(name) || null;
        }
        /**
         * Set default strategy
         */
        setDefaultStrategy(strategy) {
          this.defaultStrategy = strategy;
        }
        /**
         * Get registry status
         */
        getStatus() {
          return {
            strategyCount: this.strategies.size,
            strategies: Array.from(this.strategies.keys()),
            defaultStrategy: this.defaultStrategy?.getStrategyName() || null
          };
        }
      };
      __name(_ColorStrategyRegistry, "ColorStrategyRegistry");
      ColorStrategyRegistry = _ColorStrategyRegistry;
      _ColorOrchestrator = class _ColorOrchestrator {
        constructor() {
          this.isInitialized = false;
          this.processingQueue = [];
          this.isProcessing = false;
          this.currentStrategy = null;
          // Performance tracking
          this.processedCount = 0;
          this.totalProcessingTime = 0;
          this.lastProcessingTime = 0;
          this.registry = new ColorStrategyRegistry();
          this.selectionCriteria = {
            performance: "medium",
            quality: "enhanced",
            deviceCapabilities: {
              hasWebGL: Boolean(window.WebGLRenderingContext),
              memoryMB: this.estimateMemoryMB(),
              isMobile: this.detectMobile()
            },
            userPreferences: {
              harmonicMode: "catppuccin",
              intensity: 0.8,
              enableAdvancedBlending: true
            }
          };
          Y3K?.debug?.log("ColorOrchestrator", "Color orchestrator created");
        }
        /**
         * Initialize orchestrator with event bus and strategy registry
         */
        async initialize() {
          if (this.isInitialized) {
            Y3K?.debug?.warn("ColorOrchestrator", "Already initialized");
            return;
          }
          try {
            GlobalEventBus.subscribe("colors/extracted", this.handleColorExtractionEvent.bind(this));
            await this.registerDefaultStrategies();
            this.isInitialized = true;
            Y3K?.debug?.log("ColorOrchestrator", "Color orchestrator initialized", {
              strategies: this.registry.getStatus().strategyCount,
              criteria: this.selectionCriteria
            });
          } catch (error) {
            Y3K?.debug?.error("ColorOrchestrator", "Initialization failed:", error);
            throw error;
          }
        }
        /**
         * Handle color extraction event from GlobalEventBus
         */
        async handleColorExtractionEvent(event) {
          if (event.type !== "colors/extracted") return;
          const context = event.payload;
          await this.handleColorExtraction(context);
        }
        /**
         * Process color extraction event using Strategy pattern
         */
        async handleColorExtraction(context) {
          this.processingQueue.push(context);
          if (!this.isProcessing) {
            await this.processQueue();
          }
        }
        /**
         * Process the color processing queue
         */
        async processQueue() {
          if (this.isProcessing || this.processingQueue.length === 0) return;
          this.isProcessing = true;
          try {
            while (this.processingQueue.length > 0) {
              const context = this.processingQueue.shift();
              await this.processColorContext(context);
            }
          } catch (error) {
            Y3K?.debug?.error("ColorOrchestrator", "Queue processing failed:", error);
          } finally {
            this.isProcessing = false;
            this.currentStrategy = null;
          }
        }
        /**
         * Process a single color context using selected strategy
         */
        async processColorContext(context) {
          const startTime = performance.now();
          try {
            const strategy = this.selectStrategy(context);
            if (!strategy) {
              Y3K?.debug?.warn("ColorOrchestrator", "No strategy available for context", context);
              return;
            }
            this.currentStrategy = strategy.getStrategyName();
            if (!strategy.canProcess(context)) {
              Y3K?.debug?.warn("ColorOrchestrator", `Strategy ${this.currentStrategy} cannot process context`);
              return;
            }
            const result = await strategy.processColors(context);
            const endTime = performance.now();
            this.lastProcessingTime = endTime - startTime;
            this.totalProcessingTime += this.lastProcessingTime;
            this.processedCount++;
            Y3K?.debug?.log("ColorOrchestrator", "Color processing completed", {
              strategy: this.currentStrategy,
              processingTime: this.lastProcessingTime,
              trackUri: context.trackUri
            });
          } catch (error) {
            const endTime = performance.now();
            this.lastProcessingTime = endTime - startTime;
            Y3K?.debug?.error("ColorOrchestrator", "Color processing failed:", {
              error,
              strategy: this.currentStrategy,
              trackUri: context.trackUri
            });
          }
        }
        /**
         * Select best strategy for given context
         */
        selectStrategy(context) {
          const contextualCriteria = { ...this.selectionCriteria };
          if (context.performanceHints) {
            if (context.performanceHints.preferLightweight) {
              contextualCriteria.performance = "high";
              contextualCriteria.quality = "basic";
            }
            if (context.performanceHints.enableAdvancedBlending) {
              contextualCriteria.quality = "premium";
            }
          }
          if (context.musicData) {
            if (context.musicData.energy && context.musicData.energy > 0.8) {
              contextualCriteria.quality = "premium";
            }
          }
          return this.registry.selectStrategy(contextualCriteria);
        }
        /**
         * Register default strategies (ColorHarmonyEngine will self-register)
         */
        async registerDefaultStrategies() {
          Y3K?.debug?.log("ColorOrchestrator", "Default strategies registration completed");
        }
        /**
         * Get current processing status
         */
        getStatus() {
          return {
            isProcessing: this.isProcessing,
            ...this.currentStrategy ? { currentStrategy: this.currentStrategy } : {},
            queueSize: this.processingQueue.length
          };
        }
        /**
         * Set strategy selection criteria
         */
        setSelectionCriteria(criteria) {
          this.selectionCriteria = { ...this.selectionCriteria, ...criteria };
          Y3K?.debug?.log("ColorOrchestrator", "Selection criteria updated", criteria);
        }
        /**
         * Get processing performance metrics
         */
        getPerformanceMetrics() {
          return {
            processedCount: this.processedCount,
            averageProcessingTime: this.processedCount > 0 ? this.totalProcessingTime / this.processedCount : 0,
            lastProcessingTime: this.lastProcessingTime,
            totalProcessingTime: this.totalProcessingTime
          };
        }
        /**
         * Register a new color processing strategy
         */
        registerStrategy(strategy) {
          this.registry.register(strategy);
        }
        /**
         * Get strategy registry for advanced operations
         */
        getRegistry() {
          return this.registry;
        }
        // ============================================================================
        // Utility Methods
        // ============================================================================
        /**
         * Estimate available memory in MB
         */
        estimateMemoryMB() {
          const memoryInfo = performance.memory;
          if (memoryInfo && memoryInfo.usedJSHeapSize && memoryInfo.jsHeapSizeLimit) {
            return (memoryInfo.jsHeapSizeLimit - memoryInfo.usedJSHeapSize) / (1024 * 1024);
          }
          return this.detectMobile() ? 256 : 1024;
        }
        /**
         * Detect if running on mobile device
         */
        detectMobile() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        /**
         * Cleanup resources
         */
        async destroy() {
          GlobalEventBus.unsubscribe("colors/extracted", this.handleColorExtractionEvent.bind(this));
          this.processingQueue = [];
          this.isProcessing = false;
          this.isInitialized = false;
          Y3K?.debug?.log("ColorOrchestrator", "Color orchestrator destroyed");
        }
      };
      __name(_ColorOrchestrator, "ColorOrchestrator");
      ColorOrchestrator = _ColorOrchestrator;
      globalColorOrchestrator = new ColorOrchestrator();
    }
  });

  // src-js/utils/core/PaletteExtensionManager.ts
  var GENRE_PALETTE_HINTS, _PaletteExtensionManager, PaletteExtensionManager;
  var init_PaletteExtensionManager = __esm({
    "src-js/utils/core/PaletteExtensionManager.ts"() {
      "use strict";
      GENRE_PALETTE_HINTS = {
        jazz: { temperatureShift: 15, saturationBoost: 1.1, warmth: 0.8 },
        electronic: { temperatureShift: -10, saturationBoost: 1.2, warmth: 0.2 },
        classical: { temperatureShift: 5, saturationBoost: 0.9, warmth: 0.6 },
        rock: { temperatureShift: 0, saturationBoost: 1.15, warmth: 0.5 },
        ambient: { temperatureShift: -5, saturationBoost: 0.8, warmth: 0.3 },
        hiphop: { temperatureShift: 8, saturationBoost: 1.25, warmth: 0.7 },
        pop: { temperatureShift: 0, saturationBoost: 1, warmth: 0.5 },
        metal: { temperatureShift: -15, saturationBoost: 1.3, warmth: 0.1 },
        indie: { temperatureShift: 10, saturationBoost: 0.95, warmth: 0.6 },
        default: { temperatureShift: 0, saturationBoost: 1, warmth: 0.5 }
      };
      _PaletteExtensionManager = class _PaletteExtensionManager {
        constructor(config, utils) {
          this.paletteCache = {};
          this.cacheTTL = 3e5;
          // 5 minutes
          this.maxCacheSize = 50;
          this.config = config;
          this.utils = utils;
        }
        // TODO: Phase 3 - Load custom palette from JSON with validation
        async loadCustomPalette(paletteId, source) {
          const cached = this.paletteCache[paletteId];
          if (cached && Date.now() - cached.timestamp < this.cacheTTL && cached.isValid) {
            if (this.config.enableDebug) {
              console.log(
                `[PaletteExtensionManager] Cache hit for palette: ${paletteId}`
              );
            }
            return cached.palette;
          }
          try {
            const fallbackPalette = this.generateFallbackPalette(paletteId);
            if (this.validatePalette(fallbackPalette)) {
              this.cachePalette(paletteId, fallbackPalette, true);
              return fallbackPalette;
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[PaletteExtensionManager] Failed to load palette ${paletteId}:`,
                error
              );
            }
          }
          return null;
        }
        // TODO: Phase 3 - Generate fallback palette for unknown themes
        generateFallbackPalette(themeName) {
          const root = this.utils.getRootStyle();
          const computedStyle = getComputedStyle(root);
          const baseColor = computedStyle.getPropertyValue("--spice-main").trim() || computedStyle.getPropertyValue("--spice-base").trim() || "#1e1e2e";
          const accentColor = (
            // Prefer Year 3000 dynamic accent if it's already available, else fall back to spice button, then to dynamic accent fallback.
            computedStyle.getPropertyValue("--sn-gradient-accent").trim() || computedStyle.getPropertyValue("--spice-button").trim() || computedStyle.getPropertyValue("--sn-dynamic-accent").trim() || computedStyle.getPropertyValue("--spice-accent").trim() || "#8caaee"
          );
          const baseRgb = this.utils.hexToRgb(
            baseColor.startsWith("#") ? baseColor : `#${baseColor}`
          );
          const accentRgb = this.utils.hexToRgb(
            accentColor.startsWith("#") ? accentColor : `#${accentColor}`
          );
          if (!baseRgb || !accentRgb) {
            const dynamicAccent = computedStyle.getPropertyValue("--sn-dynamic-accent").trim();
            const dynamicBase = computedStyle.getPropertyValue("--spice-base").trim();
            return {
              name: themeName,
              version: "1.0.0",
              accents: {
                mauve: dynamicAccent || "#ca9ee6",
                pink: "#f4b8e4",
                blue: dynamicAccent || "#8caaee",
                sapphire: "#85c1dc",
                sky: "#99d1db",
                teal: "#81c8be",
                green: "#a6d189",
                yellow: "#e5c890",
                peach: "#ef9f76",
                red: "#e78284",
                lavender: "#babbf1"
              },
              neutrals: {
                base: dynamicBase || "#1e1e2e",
                surface0: "#313244",
                surface1: "#45475a",
                surface2: "#585b70",
                overlay0: "#6c7086",
                overlay1: "#7f849c",
                overlay2: "#9399b2",
                text: "#cdd6f4"
              },
              metadata: {
                author: "PaletteExtensionManager",
                description: `Generated fallback for ${themeName}`,
                temperature: "neutral"
              }
            };
          }
          const baseHsl = this.utils.rgbToHsl(baseRgb.r, baseRgb.g, baseRgb.b);
          const accentHsl = this.utils.rgbToHsl(
            accentRgb.r,
            accentRgb.g,
            accentRgb.b
          );
          return {
            name: themeName,
            version: "1.0.0",
            accents: this.generateAccentVariations(accentHsl),
            neutrals: this.generateNeutralVariations(baseHsl),
            metadata: {
              author: "PaletteExtensionManager",
              description: `Generated palette for ${themeName}`,
              temperature: this.detectTemperature(baseHsl, accentHsl)
            }
          };
        }
        // TODO: Phase 3 - Apply genre-aware modifications to palette
        applyGenreAwareModifications(palette, genre) {
          const genreHints = GENRE_PALETTE_HINTS[genre] || GENRE_PALETTE_HINTS.default;
          if (this.config.enableDebug) {
            console.log(
              `[PaletteExtensionManager] Applying ${genre} hints to palette:`,
              genreHints
            );
          }
          const modifiedPalette = {
            ...palette,
            accents: {},
            neutrals: {},
            metadata: {
              ...palette.metadata,
              genre: [...palette.metadata?.genre || [], genre]
            }
          };
          for (const [key, color] of Object.entries(palette.accents)) {
            modifiedPalette.accents[key] = this.applyGenreColorModification(
              color,
              genreHints.temperatureShift,
              genreHints.saturationBoost
            );
          }
          for (const [key, color] of Object.entries(palette.neutrals)) {
            modifiedPalette.neutrals[key] = this.applyGenreColorModification(
              color,
              genreHints.temperatureShift * 0.3,
              // Less intense for neutrals
              genreHints.saturationBoost * 0.7
            );
          }
          return modifiedPalette;
        }
        // TODO: Phase 3 - Validate palette structure and required properties
        validatePalette(palette) {
          if (!palette || typeof palette !== "object") return false;
          if (!palette.name || typeof palette.name !== "string") return false;
          if (!palette.version || typeof palette.version !== "string") return false;
          if (!palette.accents || typeof palette.accents !== "object") return false;
          if (!palette.neutrals || typeof palette.neutrals !== "object") return false;
          const allColors = [
            ...Object.values(palette.accents),
            ...Object.values(palette.neutrals)
          ];
          for (const color of allColors) {
            if (typeof color !== "string" || !this.isValidHexColor(color)) {
              return false;
            }
          }
          return true;
        }
        // TODO: Phase 3 - Cache management
        cachePalette(paletteId, palette, isValid) {
          if (Object.keys(this.paletteCache).length >= this.maxCacheSize) {
            const oldestEntry = Object.entries(this.paletteCache).sort(
              ([, aVal], [, bVal]) => aVal.timestamp - bVal.timestamp
            )[0];
            const oldestKey = oldestEntry?.[0];
            if (oldestKey && this.paletteCache[oldestKey]) {
              delete this.paletteCache[oldestKey];
            }
          }
          this.paletteCache[paletteId] = {
            palette,
            timestamp: Date.now(),
            isValid
          };
        }
        // TODO: Phase 3 - Generate accent color variations
        generateAccentVariations(baseHsl) {
          const variations = {};
          const hueShifts = [0, 30, 60, 120, 180, 210, 240, 300, 330, 45, 90];
          const names = [
            "primary",
            "secondary",
            "tertiary",
            "complement",
            "opposite",
            "warm1",
            "cool1",
            "accent1",
            "accent2",
            "highlight",
            "emphasis"
          ];
          hueShifts.forEach((shift, index) => {
            const name = names[index] || `variant${index}`;
            const adjustedHue = (baseHsl.h + shift) % 360;
            const rgb = this.utils.hslToRgb(adjustedHue, baseHsl.s, baseHsl.l);
            if (rgb) {
              variations[name] = this.utils.rgbToHex(rgb.r, rgb.g, rgb.b);
            }
          });
          return variations;
        }
        // TODO: Phase 3 - Generate neutral color variations
        generateNeutralVariations(baseHsl) {
          const neutrals = {};
          const lightnessLevels = [
            { name: "base", l: baseHsl.l },
            { name: "surface0", l: Math.min(95, baseHsl.l + 10) },
            { name: "surface1", l: Math.min(90, baseHsl.l + 20) },
            { name: "surface2", l: Math.min(85, baseHsl.l + 30) },
            { name: "overlay0", l: Math.min(80, baseHsl.l + 40) },
            { name: "overlay1", l: Math.min(75, baseHsl.l + 50) },
            { name: "text", l: Math.min(95, baseHsl.l + 60) }
          ];
          lightnessLevels.forEach((level) => {
            const rgb = this.utils.hslToRgb(
              baseHsl.h,
              Math.max(0, baseHsl.s - 20),
              level.l
            );
            if (rgb) {
              neutrals[level.name] = this.utils.rgbToHex(rgb.r, rgb.g, rgb.b);
            }
          });
          return neutrals;
        }
        // TODO: Phase 3 - Detect color temperature
        detectTemperature(baseHsl, accentHsl) {
          const avgHue = (baseHsl.h + accentHsl.h) / 2;
          if (avgHue >= 0 && avgHue <= 60 || avgHue >= 300 && avgHue <= 360) {
            return "warm";
          } else if (avgHue >= 120 && avgHue <= 240) {
            return "cool";
          } else {
            return "neutral";
          }
        }
        // TODO: Phase 3 - Apply genre-specific color modifications
        applyGenreColorModification(hexColor, temperatureShift, saturationBoost) {
          const rgb = this.utils.hexToRgb(hexColor);
          if (!rgb) return hexColor;
          const hsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
          const adjustedHue = (hsl.h + temperatureShift + 360) % 360;
          const adjustedSaturation = Math.max(
            0,
            Math.min(100, hsl.s * saturationBoost)
          );
          const modifiedRgb = this.utils.hslToRgb(
            adjustedHue,
            adjustedSaturation,
            hsl.l
          );
          if (modifiedRgb) {
            return this.utils.rgbToHex(modifiedRgb.r, modifiedRgb.g, modifiedRgb.b);
          }
          return hexColor;
        }
        // TODO: Phase 3 - Validate hex color format
        isValidHexColor(color) {
          return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);
        }
        // TODO: Phase 3 - Public API for getting genre hints
        getGenreHints(genre) {
          return GENRE_PALETTE_HINTS[genre] || GENRE_PALETTE_HINTS.default;
        }
        // TODO: Phase 3 - Clear cache
        clearCache() {
          this.paletteCache = {};
          if (this.config.enableDebug) {
            console.log("[PaletteExtensionManager] Palette cache cleared");
          }
        }
      };
      __name(_PaletteExtensionManager, "PaletteExtensionManager");
      PaletteExtensionManager = _PaletteExtensionManager;
    }
  });

  // src-js/utils/spicetify/SemanticColorManager.ts
  var _SemanticColorManager, SemanticColorManager;
  var init_SemanticColorManager = __esm({
    "src-js/utils/spicetify/SemanticColorManager.ts"() {
      "use strict";
      init_Year3000Utilities();
      _SemanticColorManager = class _SemanticColorManager {
        constructor(config = {}) {
          this.cssVariableBatcher = null;
          this.colorCache = /* @__PURE__ */ new Map();
          this.lastCacheUpdate = 0;
          this.initialized = false;
          this.config = {
            enableDebug: false,
            fallbackToSpiceColors: true,
            cacheDuration: 5e3,
            // 5 seconds
            ...config
          };
        }
        initialize(cssVariableBatcher) {
          this.cssVariableBatcher = cssVariableBatcher || null;
          this.initialized = true;
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [SemanticColorManager] Initialized with", {
              mappings: _SemanticColorManager.SEMANTIC_MAPPINGS.length,
              batcherAvailable: !!this.cssVariableBatcher,
              spicetifyAvailable: this.isSpicetifyAvailable()
            });
          }
        }
        async updateSemanticColors() {
          if (!this.initialized) {
            console.warn("[SemanticColorManager] Not initialized, cannot update colors");
            return;
          }
          const now = Date.now();
          if (now - this.lastCacheUpdate < (this.config.cacheDuration || 5e3)) {
            return;
          }
          try {
            for (const mapping of _SemanticColorManager.SEMANTIC_MAPPINGS) {
              const color = await this.getSemanticColor(mapping.semanticColor);
              this.applyColorToCSS(mapping.cssVariable, color);
              const rgbColor = hexToRgb(color);
              if (rgbColor) {
                const rgbVariable = mapping.cssVariable.replace("--spice-", "--spice-rgb-");
                this.applyColorToCSS(rgbVariable, `${rgbColor.r},${rgbColor.g},${rgbColor.b}`);
              }
            }
            this.lastCacheUpdate = now;
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] Updated all semantic colors");
            }
          } catch (error) {
            console.error("[SemanticColorManager] Failed to update semantic colors:", error);
          }
        }
        async getSemanticColor(semanticColor) {
          const cached = this.colorCache.get(semanticColor);
          if (cached && Date.now() - this.lastCacheUpdate < (this.config.cacheDuration || 5e3)) {
            return cached;
          }
          let color;
          try {
            if (this.isSpicetifyAvailable() && Spicetify.Platform?.getSemanticColors) {
              const semanticColors = await Spicetify.Platform.getSemanticColors();
              color = semanticColors[semanticColor];
            } else {
              color = this.getFallbackColor(semanticColor);
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(`[SemanticColorManager] Failed to get semantic color ${semanticColor}:`, error);
            }
            color = this.getFallbackColor(semanticColor);
          }
          this.colorCache.set(semanticColor, color);
          return color;
        }
        getFallbackColor(semanticColor) {
          const mapping = _SemanticColorManager.SEMANTIC_MAPPINGS.find((m) => m.semanticColor === semanticColor);
          if (mapping) {
            return mapping.fallbackColor;
          }
          if (semanticColor.startsWith("text")) {
            return "#cdd6f4";
          } else if (semanticColor.startsWith("background")) {
            return "#1e1e2e";
          } else if (semanticColor.startsWith("essential")) {
            return "#cba6f7";
          } else if (semanticColor.startsWith("decorative")) {
            return "#9399b2";
          }
          return "#cdd6f4";
        }
        applyColorToCSS(cssVariable, color) {
          if (this.cssVariableBatcher) {
            this.cssVariableBatcher.queueCSSVariableUpdate(cssVariable, color);
          } else {
            document.documentElement.style.setProperty(cssVariable, color);
          }
        }
        isSpicetifyAvailable() {
          return typeof Spicetify !== "undefined" && Spicetify.Platform && typeof Spicetify.Platform.getSemanticColors === "function";
        }
        flushUpdates() {
          if (this.cssVariableBatcher) {
            this.cssVariableBatcher.flushCSSVariableBatch();
          }
        }
        clearCache() {
          this.colorCache.clear();
          this.lastCacheUpdate = 0;
        }
        getColorMappings() {
          return _SemanticColorManager.SEMANTIC_MAPPINGS;
        }
        destroy() {
          this.clearCache();
          this.cssVariableBatcher = null;
          this.initialized = false;
        }
      };
      __name(_SemanticColorManager, "SemanticColorManager");
      // Semantic color mappings to our CSS variables
      _SemanticColorManager.SEMANTIC_MAPPINGS = [
        // Text colors
        { semanticColor: "textBase", cssVariable: "--spice-text", fallbackColor: "#cdd6f4", description: "Primary text color" },
        { semanticColor: "textSubdued", cssVariable: "--spice-subtext", fallbackColor: "#a6adc8", description: "Secondary text color" },
        { semanticColor: "textBrightAccent", cssVariable: "--spice-accent", fallbackColor: "#cba6f7", description: "Accent text color" },
        { semanticColor: "textNegative", cssVariable: "--spice-red", fallbackColor: "#f38ba8", description: "Error text color" },
        { semanticColor: "textWarning", cssVariable: "--spice-yellow", fallbackColor: "#f9e2af", description: "Warning text color" },
        { semanticColor: "textPositive", cssVariable: "--spice-green", fallbackColor: "#a6e3a1", description: "Success text color" },
        { semanticColor: "textAnnouncement", cssVariable: "--spice-blue", fallbackColor: "#89b4fa", description: "Info text color" },
        // Essential colors (for icons, controls)
        { semanticColor: "essentialBase", cssVariable: "--spice-button", fallbackColor: "#cdd6f4", description: "Primary button color" },
        { semanticColor: "essentialSubdued", cssVariable: "--spice-button-disabled", fallbackColor: "#6c7086", description: "Disabled button color" },
        { semanticColor: "essentialBrightAccent", cssVariable: "--spice-button-active", fallbackColor: "#cba6f7", description: "Active button color" },
        { semanticColor: "essentialNegative", cssVariable: "--spice-notification-error", fallbackColor: "#f38ba8", description: "Error button color" },
        { semanticColor: "essentialWarning", cssVariable: "--spice-notification-warning", fallbackColor: "#f9e2af", description: "Warning button color" },
        { semanticColor: "essentialPositive", cssVariable: "--spice-notification-success", fallbackColor: "#a6e3a1", description: "Success button color" },
        // Background colors
        { semanticColor: "backgroundBase", cssVariable: "--spice-main", fallbackColor: "#1e1e2e", description: "Main background color" },
        { semanticColor: "backgroundHighlight", cssVariable: "--spice-highlight", fallbackColor: "#313244", description: "Highlight background color" },
        { semanticColor: "backgroundPress", cssVariable: "--spice-press", fallbackColor: "#45475a", description: "Press state background color" },
        { semanticColor: "backgroundElevatedBase", cssVariable: "--spice-card", fallbackColor: "#181825", description: "Card background color" },
        { semanticColor: "backgroundElevatedHighlight", cssVariable: "--spice-card-highlight", fallbackColor: "#313244", description: "Card highlight background" },
        { semanticColor: "backgroundTintedBase", cssVariable: "--spice-sidebar", fallbackColor: "#313244", description: "Sidebar background color" },
        { semanticColor: "backgroundTintedHighlight", cssVariable: "--spice-sidebar-highlight", fallbackColor: "#45475a", description: "Sidebar highlight background" },
        // Decorative colors
        { semanticColor: "decorativeBase", cssVariable: "--spice-decorative", fallbackColor: "#cdd6f4", description: "Decorative element color" },
        { semanticColor: "decorativeSubdued", cssVariable: "--spice-decorative-subdued", fallbackColor: "#9399b2", description: "Subdued decorative color" }
      ];
      SemanticColorManager = _SemanticColorManager;
    }
  });

  // src-js/audio/ColorHarmonyEngine.ts
  var _ColorHarmonyEngine, ColorHarmonyEngine;
  var init_ColorHarmonyEngine = __esm({
    "src-js/audio/ColorHarmonyEngine.ts"() {
      "use strict";
      init_settingKeys();
      init_EventBus();
      init_ColorOrchestrator();
      init_PaletteExtensionManager();
      init_Year3000Utilities();
      init_SemanticColorManager();
      init_BaseVisualSystem();
      _ColorHarmonyEngine = class _ColorHarmonyEngine extends BaseVisualSystem {
        constructor(config, utils, performanceMonitor, settingsManager) {
          super(
            config,
            utils || Year3000Utilities_exports,
            performanceMonitor,
            null,
            // No direct music service dependency
            settingsManager || null
          );
          this.emergentEngine = null;
          // User-specified harmonic intensity (0-1). Multiplies defaultBlendRatio.
          this.userIntensity = 0.7;
          this.evolutionEnabled = true;
          this._evolutionTimer = null;
          // Timer ref for debounce
          this._pendingPaletteRefresh = null;
          // Track last applied genre to avoid redundant palette refreshes
          this._lastGenre = null;
          this.systemName = "ColorHarmonyEngine";
          this.paletteExtensionManager = new PaletteExtensionManager(
            this.config,
            this.utils
          );
          this.semanticColorManager = new SemanticColorManager({
            enableDebug: this.config.enableDebug,
            fallbackToSpiceColors: true,
            cacheDuration: 5e3
          });
          this.currentTheme = this.detectCurrentTheme();
          if (config && typeof config.harmonicIntensity === "number" && Number.isFinite(config.harmonicIntensity)) {
            const clamped = Math.max(
              0,
              Math.min(1, config.harmonicIntensity)
            );
            this.userIntensity = clamped;
          }
          this.harmonyMetrics = {
            totalHarmonyCalculations: 0,
            musicInfluencedAdjustments: 0,
            temporalMemoryEvents: 0,
            performance: []
          };
          this.musicalMemory = {
            recentTracks: [],
            userColorPreferences: /* @__PURE__ */ new Map(),
            energyHistory: [],
            maxMemorySize: 50
          };
          this.kineticState = {
            currentPulse: 0,
            breathingPhase: 0,
            lastBeatTime: 0,
            visualMomentum: 0
          };
          this.catppuccinPalettes = {
            frappe: {
              accents: {
                rosewater: "#f2d5cf",
                flamingo: "#eebebe",
                pink: "#f4b8e4",
                mauve: "#ca9ee6",
                red: "#e78284",
                maroon: "#ea999c",
                peach: "#ef9f76",
                yellow: "#e5c890",
                green: "#a6d189",
                teal: "#81c8be",
                sky: "#99d1db",
                sapphire: "#85c1dc",
                blue: "#8caaee",
                lavender: "#babbf1"
              },
              neutrals: {
                base: "#303446",
                surface0: "#414559",
                surface1: "#51576d",
                surface2: "#626880"
              }
            },
            latte: {
              accents: {
                rosewater: "#dc8a78",
                flamingo: "#dd7878",
                pink: "#ea76cb",
                mauve: "#8839ef",
                red: "#d20f39",
                maroon: "#e64553",
                peach: "#fe640b",
                yellow: "#df8e1d",
                green: "#40a02b",
                teal: "#179299",
                sky: "#04a5e5",
                sapphire: "#209fb5",
                blue: "#1e66f5",
                lavender: "#7287fd"
              },
              neutrals: {
                base: "#eff1f5",
                surface0: "#e6e9ef",
                surface1: "#dce0e8",
                surface2: "#c5c9d1"
              }
            },
            macchiato: {
              accents: {
                rosewater: "#f4dbd6",
                flamingo: "#f0c6c6",
                pink: "#f5bde6",
                mauve: "#c6a0f6",
                red: "#ed8796",
                maroon: "#ee99a0",
                peach: "#f5a97f",
                yellow: "#eed49f",
                green: "#a6da95",
                teal: "#8bd5ca",
                sky: "#91d7e3",
                sapphire: "#7dc4e4",
                blue: "#8aadf4",
                lavender: "#b7bdf8"
              },
              neutrals: {
                base: "#24273a",
                surface0: "#363a4f",
                surface1: "#494d64",
                surface2: "#5b6078"
              }
            },
            mocha: {
              accents: {
                rosewater: "#f5e0dc",
                flamingo: "#f2cdcd",
                pink: "#f5c2e7",
                mauve: "#cba6f7",
                red: "#f38ba8",
                maroon: "#eba0ac",
                peach: "#fab387",
                yellow: "#f9e2af",
                green: "#a6e3a1",
                teal: "#94e2d5",
                sky: "#89dceb",
                sapphire: "#74c7ec",
                blue: "#89b4fa",
                lavender: "#b4befe"
              },
              neutrals: {
                base: "#1e1e2e",
                surface0: "#313244",
                surface1: "#45475a",
                surface2: "#585b70"
              }
            }
          };
          this.vibrancyConfig = {
            defaultBlendRatio: 0.95,
            // BOLD! 95% extracted color dominance (was 0.85)
            minimumSaturation: 0.6,
            // DEMAND VIBRANCY! Up from pathetic 0.4
            maximumDesaturation: 0.05,
            // PREVENT COLOR DEATH! Down from 0.15
            contrastBoostIntensity: 2.2,
            // STRONGER CONTRAST! Up from 1.8
            harmonyTolerance: 0.35,
            // ARTISTIC FREEDOM! Down from restrictive 0.55
            // 🎨 NEW: Artistic Enhancement Factors
            artisticSaturationBoost: 1.2,
            // 20% saturation enhancement for extracted colors
            cosmicLuminanceBoost: 1.15,
            // 15% luminance boost for cosmic presence
            energyResponsiveness: 0.8,
            // How much music energy affects color intensity
            // 🌟 Dynamic Blending Based on Artistic Mode
            getBlendRatio(artisticMode = "artist-vision") {
              const ratios = {
                "corporate-safe": 0.75,
                // Conservative: 75% extracted
                "artist-vision": 0.95,
                // Bold: 95% extracted
                "cosmic-maximum": 0.98
                // Maximum: 98% extracted!
              };
              return ratios[artisticMode] || this.defaultBlendRatio;
            }
          };
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Initialized with Year 3000 Quantum Empathy"
            );
          }
          if (config && typeof config.harmonicEvolution === "boolean") {
            this.evolutionEnabled = config.harmonicEvolution;
          }
          this._boundSettingsChangeHandler = this._handleSettingsChange.bind(this);
          this._boundArtisticModeHandler = this._handleArtisticModeChanged.bind(this);
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this._boundSettingsChangeHandler
          );
          document.addEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          if (this.evolutionEnabled) {
            this._startEvolutionLoop();
          }
        }
        // Unified implementation
        updateAnimation(timestampOrDelta, maybeDelta) {
          const delta = maybeDelta ?? timestampOrDelta;
          this.onAnimate(delta);
        }
        // TODO: Implement proper onAnimate method for Year 3000 per-frame updates
        onAnimate(deltaMs) {
          this._updateCSSVariables(deltaMs);
          this._calculateBeatPulse(deltaMs);
          GlobalEventBus.publish("colorharmony/frame", {
            timestamp: performance.now(),
            kineticState: this.kineticState
          });
        }
        // TODO: Private method for updating CSS variables with kinetic state
        _updateCSSVariables(deltaMs) {
          const root = this.utils.getRootStyle();
          if (!root) return;
          root.style.setProperty(
            "--sn-harmony-energy",
            this.kineticState.visualMomentum.toFixed(3)
          );
          root.style.setProperty(
            "--sn-harmony-pulse",
            this.kineticState.currentPulse.toFixed(3)
          );
          root.style.setProperty(
            "--sn-harmony-breathing-phase",
            (Math.sin(this.kineticState.breathingPhase) * 0.5 + 0.5).toFixed(3)
          );
          if (this.kineticState.musicIntensityMultiplier !== void 0) {
            root.style.setProperty(
              "--sn-harmony-intensity",
              this.kineticState.musicIntensityMultiplier.toFixed(3)
            );
          }
          if (this.kineticState.valenceGravity !== void 0) {
            root.style.setProperty(
              "--sn-harmony-valence",
              this.kineticState.valenceGravity.toFixed(3)
            );
          }
          if (this.kineticState.beatPhase !== void 0) {
            root.style.setProperty(
              "--sn-harmony-beat-phase",
              this.kineticState.beatPhase.toFixed(3)
            );
          }
          if (this.kineticState.hueShift !== void 0) {
            root.style.setProperty(
              "--sn-harmony-hue-shift",
              `${this.kineticState.hueShift.toFixed(1)}deg`
            );
          }
          const glow = Math.max(0, Math.min(1, this.kineticState.currentPulse * 1.2));
          root.style.setProperty("--sn-text-glow-intensity", glow.toFixed(3));
        }
        // TODO: Private method for calculating beat pulse effects
        _calculateBeatPulse(deltaMs) {
          this.kineticState.currentPulse *= Math.pow(0.95, deltaMs / 16.67);
          this.kineticState.breathingPhase += deltaMs / 1e3 * 0.5;
          if (this.kineticState.breathingPhase > 2 * Math.PI) {
            this.kineticState.breathingPhase -= 2 * Math.PI;
          }
        }
        async initialize() {
          await super.initialize();
          const cssVariableBatcher = this.performanceMonitor ? this.performanceMonitor.cssVariableBatcher : void 0;
          this.semanticColorManager.initialize(cssVariableBatcher);
          await this.semanticColorManager.updateSemanticColors();
          GlobalEventBus.subscribe("colors/extracted", this.handleColorExtraction.bind(this));
          try {
            globalColorOrchestrator.registerStrategy(this);
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [ColorHarmonyEngine] Registered with ColorOrchestrator as strategy processor.");
            }
          } catch (error) {
            console.warn("\u{1F3A8} [ColorHarmonyEngine] Failed to register with ColorOrchestrator:", error);
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Initialized with Year 3000 Quantum Empathy via BaseVisualSystem and SemanticColorManager."
            );
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Subscribed to 'colors/extracted' events for strategy pattern processing."
            );
          }
          this.initialized = true;
        }
        async healthCheck() {
          if (!this.catppuccinPalettes[this.currentTheme]) {
            return {
              healthy: false,
              ok: false,
              details: `Current theme '${this.currentTheme}' not found in palettes.`,
              issues: [`Current theme '${this.currentTheme}' not found in palettes.`],
              system: "ColorHarmonyEngine"
            };
          }
          return {
            healthy: true,
            ok: true,
            details: "Palettes are loaded correctly.",
            issues: [],
            system: "ColorHarmonyEngine"
          };
        }
        // ============================================================================
        // IColorProcessor Strategy Pattern Implementation
        // ============================================================================
        /**
         * Process colors according to Catppuccin harmony strategy
         * Implements the Strategy pattern for color processing
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const { rawColors, trackUri, musicData } = context;
            const processedColors = this.blendWithCatppuccin(rawColors, musicData);
            const accentHex = processedColors["VIBRANT"] || processedColors["PROMINENT"] || Object.values(processedColors)[0] || "#a6adc8";
            const rgb = this.utils.hexToRgb(accentHex);
            const accentRgb = rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "166,173,200";
            const processingTime = performance.now() - startTime;
            this.harmonyMetrics.totalHarmonyCalculations++;
            this.harmonyMetrics.performance.push(processingTime);
            const result = {
              processedColors,
              accentHex,
              accentRgb,
              metadata: {
                strategy: "CatppuccinHarmony",
                processingTime,
                cacheKey: `catppuccin-${trackUri}-${this.currentTheme}`,
                harmonicIntensity: this.userIntensity
              },
              context
            };
            GlobalEventBus.publish("colors/harmonized", {
              type: "colors/harmonized",
              payload: {
                ...result,
                cssVariables: this.generateCSSVariables(result)
              }
            });
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3A8} [ColorHarmonyEngine] Processed colors via strategy pattern in ${processingTime.toFixed(2)}ms`,
                { accentHex, strategy: "CatppuccinHarmony" }
              );
            }
            return result;
          } catch (error) {
            console.error("[ColorHarmonyEngine] Strategy processing failed:", error);
            return {
              processedColors: { VIBRANT: "#a6adc8" },
              accentHex: "#a6adc8",
              accentRgb: "166,173,200",
              metadata: {
                strategy: "CatppuccinHarmony",
                processingTime: performance.now() - startTime,
                error: String(error)
              },
              context
            };
          }
        }
        /**
         * Get strategy name for identification
         */
        getStrategyName() {
          return "CatppuccinHarmony";
        }
        /**
         * Check if this strategy can process the given context
         */
        canProcess(context) {
          return context && context.rawColors && Object.keys(context.rawColors).length > 0;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          const baseTime = 5;
          const colorCount = Object.keys(context.rawColors || {}).length;
          const complexityFactor = Math.max(1, colorCount / 5);
          return baseTime * complexityFactor;
        }
        /**
         * Handle color extraction events from GlobalEventBus
         * Event-driven entry point for strategy pattern
         */
        async handleColorExtraction(event) {
          try {
            if (!this.initialized) {
              if (this.config.enableDebug) {
                console.warn("[ColorHarmonyEngine] Received color extraction event but not initialized");
              }
              return;
            }
            const context = event.payload || event;
            if (this.canProcess(context)) {
              await this.processColors(context);
            } else {
              if (this.config.enableDebug) {
                console.warn("[ColorHarmonyEngine] Cannot process color context:", context);
              }
            }
          } catch (error) {
            console.error("[ColorHarmonyEngine] Error handling color extraction event:", error);
          }
        }
        /**
         * Generate CSS variables from color result
         */
        generateCSSVariables(result) {
          const cssVars = {};
          cssVars["--sn-accent-hex"] = result.accentHex;
          cssVars["--sn-accent-rgb"] = result.accentRgb;
          cssVars[_ColorHarmonyEngine.CANONICAL_HEX_VAR] = result.accentHex;
          cssVars[_ColorHarmonyEngine.CANONICAL_RGB_VAR] = result.accentRgb;
          cssVars["--spice-accent"] = result.accentHex;
          cssVars["--spice-button"] = result.accentHex;
          cssVars["--spice-button-active"] = result.accentHex;
          cssVars["--spice-rgb-accent"] = result.accentRgb;
          cssVars["--spice-rgb-button"] = result.accentRgb;
          return cssVars;
        }
        detectCurrentTheme() {
          const rootElement = this.utils.getRootStyle();
          if (!rootElement) {
            console.warn(
              "[ColorHarmonyEngine detectCurrentTheme] Root element not found. Defaulting to mocha."
            );
            return "mocha";
          }
          const computedRootStyle = getComputedStyle(rootElement);
          const baseColorHex = computedRootStyle.getPropertyValue("--spice-main").trim();
          const normalizedBaseColor = baseColorHex.startsWith("#") ? baseColorHex.substring(1).toUpperCase() : baseColorHex.toUpperCase();
          const themeMap = {
            "303446": "frappe",
            EFF1F5: "latte",
            "24273A": "macchiato",
            "1E1E2E": "mocha"
          };
          const knownTheme = themeMap[normalizedBaseColor];
          if (knownTheme) {
            if (this.config.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Detected Catppuccin theme: ${knownTheme}`
              );
            }
            return knownTheme;
          }
          if (this.config.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] Unknown theme detected (${normalizedBaseColor}), attempting to generate fallback`
            );
          }
          const fallbackThemeName = `custom-${normalizedBaseColor.toLowerCase()}`;
          try {
            const fallbackPalette = this.paletteExtensionManager.generateFallbackPalette(fallbackThemeName);
            if (this.config.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Generated fallback palette for theme: ${fallbackThemeName}`,
                fallbackPalette
              );
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[ColorHarmonyEngine] Failed to generate fallback palette:`,
                error
              );
            }
          }
          if (this.config.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] Falling back to mocha theme for unknown base color: ${normalizedBaseColor}`
            );
          }
          return "mocha";
        }
        // TODO: Phase 3 - New method to get genre-aware palette
        async _getGenreAwarePalette(genre) {
          const basePalette = this.catppuccinPalettes[this.currentTheme];
          if (!genre || !basePalette) {
            return basePalette;
          }
          try {
            const customPalette = {
              name: this.currentTheme,
              version: "1.0.0",
              accents: basePalette.accents,
              neutrals: basePalette.neutrals,
              metadata: {
                author: "Catppuccin",
                description: `${this.currentTheme} flavor`,
                temperature: "neutral"
              }
            };
            const modifiedPalette = this.paletteExtensionManager.applyGenreAwareModifications(
              customPalette,
              genre
            );
            return {
              accents: modifiedPalette.accents,
              neutrals: modifiedPalette.neutrals
            };
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[ColorHarmonyEngine] Failed to apply genre modifications for ${genre}:`,
                error
              );
            }
            return basePalette;
          }
        }
        getMusicIntensityMultiplier(energy = 0.5, valence = 0.5) {
          const baseMultiplier = this.config.getCurrentMultipliers().musicEnergyBoost;
          const energyBoost = energy > 0.7 ? 1.3 : energy > 0.4 ? 1 : 0.8;
          const valenceBoost = valence > 0.6 ? 1.2 : valence < 0.4 ? 0.9 : 1;
          return baseMultiplier * energyBoost * valenceBoost;
        }
        validateColorHarmony(color, context = "general") {
          const startTime = performance.now();
          this.harmonyMetrics.totalHarmonyCalculations++;
          const contextRequirements = {
            general: {
              minContrast: 1.8,
              minHarmony: this.vibrancyConfig.harmonyTolerance
            },
            search: { minContrast: 2.8, minHarmony: 0.4 },
            navigation: { minContrast: 2.5, minHarmony: 0.45 },
            text: { minContrast: 4.5, minHarmony: 0.6 },
            accent: { minContrast: 1.5, minHarmony: 0.3 }
          };
          const requirements = contextRequirements[context] || contextRequirements["general"];
          const currentPalette = this.catppuccinPalettes[this.currentTheme];
          if (!currentPalette?.neutrals?.base) {
            const errorMsg = `[StarryNight] Catppuccin palette or base neutral not found for theme: ${this.currentTheme}`;
            console.error(errorMsg);
            return {
              isValid: false,
              error: "Palette configuration error.",
              contrastRatio: 0,
              harmonyScore: 0,
              meetsContrast: false,
              isHarmonious: false,
              artisticMode: this.config.artisticMode,
              adjustedRequirements: requirements,
              recommendations: []
            };
          }
          const backgroundColor = currentPalette.neutrals.base;
          const colorHex = this.utils.rgbToHex(color.r, color.g, color.b);
          const contrastRatio = this.utils.calculateContrastRatio(
            colorHex,
            backgroundColor
          );
          const harmonyScore = this.calculateHarmonyScore(color, currentPalette);
          const currentMode = this.config.artisticMode;
          let adjustedRequirements = { ...requirements };
          if (currentMode === "cosmic-maximum") {
            adjustedRequirements.minContrast *= 0.7;
            adjustedRequirements.minHarmony *= 0.6;
          } else if (currentMode === "artist-vision") {
            adjustedRequirements.minContrast *= 0.85;
            adjustedRequirements.minHarmony *= 0.8;
          }
          const meetsContrast = contrastRatio >= adjustedRequirements.minContrast;
          const isHarmonious = harmonyScore >= adjustedRequirements.minHarmony;
          const endTime = performance.now();
          this.harmonyMetrics.performance.push(endTime - startTime);
          return {
            isValid: meetsContrast && isHarmonious,
            contrastRatio,
            harmonyScore,
            meetsContrast,
            isHarmonious,
            artisticMode: currentMode,
            adjustedRequirements,
            recommendations: this.generateRecommendations(
              color,
              contrastRatio,
              harmonyScore,
              adjustedRequirements
            )
          };
        }
        calculateHarmonyScore(color, palette) {
          const colorHsl = this.utils.rgbToHsl(color.r, color.g, color.b);
          let maxHarmony = 0;
          const accentColors = Object.values(palette.accents);
          for (const accentColor of accentColors) {
            const accentRgb = this.utils.hexToRgb(accentColor);
            if (!accentRgb) continue;
            const accentHsl = this.utils.rgbToHsl(
              accentRgb.r,
              accentRgb.g,
              accentRgb.b
            );
            const hueDiff = Math.abs(colorHsl.h - accentHsl.h);
            const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);
            const harmoniousAngles = [
              0,
              30,
              60,
              90,
              120,
              150,
              180,
              210,
              240,
              270,
              300,
              330
            ];
            const isHarmonious = harmoniousAngles.some(
              (angle) => Math.abs(normalizedHueDiff - angle) < 20
            );
            if (isHarmonious) {
              const harmonyStrength = 1 - Math.min(
                ...harmoniousAngles.map(
                  (angle) => Math.abs(normalizedHueDiff - angle)
                )
              ) / 20;
              maxHarmony = Math.max(maxHarmony, harmonyStrength);
            }
          }
          return maxHarmony;
        }
        findBestHarmoniousAccent(rgb, palette) {
          let bestAccent = {
            name: "mauve",
            hex: this.utils.getRootStyle()?.style.getPropertyValue("--sn-dynamic-accent")?.trim() || this.utils.getRootStyle()?.style.getPropertyValue("--spice-accent")?.trim() || "#cba6f7",
            // Fallback to default mauve hex
            rgb: { r: 203, g: 166, b: 247 }
          };
          const accentPriority = [
            "mauve",
            "lavender",
            "blue",
            "sapphire",
            "sky",
            "pink",
            "peach",
            "teal"
          ];
          let bestScore = -1;
          const inputHsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
          for (const accentName of accentPriority) {
            const accentHex = palette.accents[accentName];
            if (accentHex) {
              const accentRgb = this.utils.hexToRgb(accentHex);
              if (!accentRgb) continue;
              const accentHsl = this.utils.rgbToHsl(
                accentRgb.r,
                accentRgb.g,
                accentRgb.b
              );
              const hueDiff = Math.abs(inputHsl.h - accentHsl.h);
              const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);
              const harmonyScore = 1 - normalizedHueDiff / 180;
              const saturationBonus = accentHsl.s * 0.3;
              const totalScore = harmonyScore + saturationBonus;
              if (totalScore > bestScore) {
                bestScore = totalScore;
                bestAccent = {
                  name: accentName,
                  hex: accentHex,
                  rgb: accentRgb
                };
              }
            }
          }
          return bestAccent;
        }
        blendColors(rgb1, rgb2, ratio = this.vibrancyConfig.defaultBlendRatio) {
          const r = Math.max(0, Math.min(1, ratio));
          const oklab1 = this.utils.rgbToOklab(rgb1.r, rgb1.g, rgb1.b);
          const oklab2 = this.utils.rgbToOklab(rgb2.r, rgb2.g, rgb2.b);
          const lerp2 = /* @__PURE__ */ __name((a, b) => a * r + b * (1 - r), "lerp");
          const blendedOklab = {
            L: lerp2(oklab1.L, oklab2.L),
            a: lerp2(oklab1.a, oklab2.a),
            b: lerp2(oklab1.b, oklab2.b)
          };
          const blendedRgb = this.utils.oklabToRgb(
            blendedOklab.L,
            blendedOklab.a,
            blendedOklab.b
          );
          const blendedHsl = this.utils.rgbToHsl(
            blendedRgb.r,
            blendedRgb.g,
            blendedRgb.b
          );
          const artisticMode = this.config?.artisticMode ?? "artist-vision";
          const emergentMultipliers = this.emergentEngine?.getCurrentMultipliers?.() || void 0;
          const shouldUseEmergent = artisticMode === "cosmic-maximum" && !!emergentMultipliers;
          const validMultipliers = emergentMultipliers || {};
          const saturationBoostFactor = shouldUseEmergent ? (validMultipliers.visualIntensityBase || 1) * 1.25 : this.vibrancyConfig.artisticSaturationBoost;
          const luminanceBoostFactor = shouldUseEmergent ? (validMultipliers.aestheticGravityStrength || 1) * 1.15 : this.vibrancyConfig.cosmicLuminanceBoost;
          blendedHsl.s = Math.max(
            blendedHsl.s,
            this.vibrancyConfig.minimumSaturation * 100
          );
          blendedHsl.s = Math.min(100, blendedHsl.s * saturationBoostFactor);
          if (artisticMode !== "corporate-safe") {
            blendedHsl.l = Math.min(95, blendedHsl.l * luminanceBoostFactor);
          }
          const finalRgb = this.utils.hslToRgb(
            blendedHsl.h,
            blendedHsl.s,
            blendedHsl.l
          );
          return { r: finalRgb.r, g: finalRgb.g, b: finalRgb.b };
        }
        blendWithCatppuccin(extractedColors, musicContext = null) {
          this.performanceMonitor?.emitTrace?.(
            "[ColorHarmonyEngine] Starting blendWithCatppuccin"
          );
          const currentPalette = this.catppuccinPalettes[this.currentTheme];
          if (!currentPalette) {
            console.error(
              `[StarryNight] Catppuccin palette not found for theme: ${this.currentTheme}`
            );
            return extractedColors;
          }
          const harmonizedColors = {};
          for (const [role, color] of Object.entries(extractedColors)) {
            if (!color) continue;
            const extractedRgb = this.utils.hexToRgb(color);
            if (!extractedRgb) {
              harmonizedColors[role] = color;
              continue;
            }
            const bestAccent = this.findBestHarmoniousAccent(
              extractedRgb,
              currentPalette
            );
            if (!bestAccent?.rgb) {
              console.warn(
                `[StarryNight] Could not find a valid harmonious accent for role: ${role}. Using original color.`
              );
              harmonizedColors[role] = color;
              continue;
            }
            let blendRatio = this.vibrancyConfig.getBlendRatio(
              this.config.artisticMode
            );
            if (musicContext) {
              const musicIntensity = this.getMusicIntensityMultiplier(
                musicContext.energy,
                musicContext.valence
              );
              blendRatio *= musicIntensity * this.userIntensity;
              blendRatio = Math.max(0, Math.min(1, blendRatio));
            }
            const finalRgb = this.blendColors(
              extractedRgb,
              bestAccent.rgb,
              blendRatio
            );
            harmonizedColors[role] = this.utils.rgbToHex(
              finalRgb.r,
              finalRgb.g,
              finalRgb.b
            );
          }
          this.harmonyMetrics.musicInfluencedAdjustments++;
          this.performanceMonitor?.emitTrace?.(
            "[ColorHarmonyEngine] Completed blendWithCatppuccin"
          );
          this.updateSemanticColorsWithHarmonizedPalette(harmonizedColors);
          return harmonizedColors;
        }
        /**
         * Updates semantic colors using the harmonized palette
         * Integrates with Spicetify's semantic color system for consistent theming
         */
        updateSemanticColorsWithHarmonizedPalette(harmonizedColors) {
          if (!this.semanticColorManager) {
            return;
          }
          try {
            this.semanticColorManager.updateSemanticColors();
            const primaryColor = harmonizedColors["VIBRANT"] || harmonizedColors["PRIMARY"];
            const secondaryColor = harmonizedColors["DARK_VIBRANT"] || harmonizedColors["SECONDARY"];
            const accentColor = harmonizedColors["VIBRANT_NON_ALARMING"] || harmonizedColors["LIGHT_VIBRANT"];
            if (primaryColor) {
              this.semanticColorManager.getSemanticColor("essentialBrightAccent").then((color) => {
                const blendedColor = this.blendWithSemanticColor(primaryColor, color, 0.7);
                this.applyCSSVariable("--spice-accent", blendedColor);
                this.applyCSSVariable("--spice-button-active", blendedColor);
              });
            }
            if (secondaryColor) {
              this.semanticColorManager.getSemanticColor("backgroundElevatedHighlight").then((color) => {
                const blendedColor = this.blendWithSemanticColor(secondaryColor, color, 0.5);
                this.applyCSSVariable("--spice-highlight", blendedColor);
              });
            }
            if (accentColor) {
              this.semanticColorManager.getSemanticColor("textBrightAccent").then((color) => {
                const blendedColor = this.blendWithSemanticColor(accentColor, color, 0.6);
                this.applyCSSVariable("--spice-text-accent", blendedColor);
              });
            }
            this.semanticColorManager.flushUpdates();
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn("[ColorHarmonyEngine] Failed to update semantic colors:", error);
            }
          }
        }
        /**
         * Blends a harmonized color with a semantic color for consistency
         */
        blendWithSemanticColor(harmonizedHex, semanticHex, blendRatio) {
          const harmonizedRgb = this.utils.hexToRgb(harmonizedHex);
          const semanticRgb = this.utils.hexToRgb(semanticHex);
          if (!harmonizedRgb || !semanticRgb) {
            return harmonizedHex;
          }
          const blendedRgb = this.blendColors(harmonizedRgb, semanticRgb, blendRatio);
          return this.utils.rgbToHex(blendedRgb.r, blendedRgb.g, blendedRgb.b);
        }
        /**
         * Applies CSS variable with fallback to direct style application
         */
        applyCSSVariable(property, value) {
          const cssVariableBatcher = this.performanceMonitor?.cssVariableBatcher;
          if (cssVariableBatcher) {
            cssVariableBatcher.queueCSSVariableUpdate(property, value);
          } else {
            document.documentElement.style.setProperty(property, value);
          }
        }
        generateRecommendations(color, contrastRatio, harmonyScore, requirements) {
          const recommendations = [];
          const currentPalette = this.catppuccinPalettes[this.currentTheme];
          const baseRgb = this.utils.hexToRgb(currentPalette.neutrals.base);
          if (!baseRgb) {
            return [];
          }
          if (contrastRatio < requirements.minContrast) {
            const targetL = this.utils.findRequiredLuminance(
              color,
              baseRgb,
              requirements.minContrast
            );
            const currentHsl = this.utils.rgbToHsl(color.r, color.g, color.b);
            const adjustedRgbArr = this.utils.hslToRgb(
              currentHsl.h,
              currentHsl.s,
              targetL
            );
            const adjustedRgb = {
              r: adjustedRgbArr.r,
              g: adjustedRgbArr.g,
              b: adjustedRgbArr.b
            };
            recommendations.push({
              type: "contrast",
              suggestion: `Adjust luminance to meet contrast of ${requirements.minContrast}`,
              recommendedColor: this.utils.rgbToHex(
                adjustedRgb.r,
                adjustedRgb.g,
                adjustedRgb.b
              )
            });
          }
          if (harmonyScore < requirements.minHarmony) {
            const harmoniousAccent = this.findBestHarmoniousAccent(
              color,
              currentPalette
            );
            const blendedColor = this.blendColors(color, harmoniousAccent.rgb, 0.5);
            recommendations.push({
              type: "harmony",
              suggestion: `Blend with harmonious accent color to improve score to at least ${requirements.minHarmony}`,
              recommendedColor: this.utils.rgbToHex(
                blendedColor.r,
                blendedColor.g,
                blendedColor.b
              )
            });
          }
          return recommendations;
        }
        getPerformanceReport() {
          return {
            system: this.systemName,
            metrics: this.harmonyMetrics,
            kineticState: this.kineticState,
            musicalMemorySize: this.musicalMemory.recentTracks.length,
            currentTheme: this.currentTheme
          };
        }
        updateFromMusicAnalysis(processedMusicData, rawFeatures, trackUri) {
          if (!processedMusicData) return;
          const g2 = processedMusicData.genre;
          if (g2 && g2 !== this._lastGenre) {
            this._applyGenrePalette(g2).then(() => {
              this._lastGenre = g2;
              this._forcePaletteRepaint();
            });
          }
          this._updateMusicalMemory(processedMusicData, trackUri);
          this._updateKineticState(processedMusicData);
          this._applyAestheticGravity(processedMusicData);
          this._calculateMusicAwareDynamics(processedMusicData);
        }
        // TODO: Phase 2 - New method for music-aware dynamic calculations
        _calculateMusicAwareDynamics(musicData) {
          const {
            energy = 0.5,
            valence = 0.5,
            enhancedBPM = 120,
            beatOccurred = false
          } = musicData;
          const musicIntensityMultiplier = this._calculateMusicIntensityMultiplier(
            energy,
            valence
          );
          const beatPhase = this._calculateBeatPhase(enhancedBPM);
          const valenceGravity = (valence - 0.5) * 2;
          const hueShift = this._calculateHueShift(beatOccurred, energy, beatPhase);
          this.kineticState = {
            ...this.kineticState,
            musicIntensityMultiplier,
            beatPhase,
            valenceGravity,
            hueShift
          };
        }
        // TODO: Phase 2 - Calculate music intensity based on energy and valence
        _calculateMusicIntensityMultiplier(energy, valence) {
          const baseIntensity = energy * 0.7 + valence * 0.3;
          const contrastBoost = Math.abs(valence - 0.5) * 0.4;
          return Math.max(0.1, Math.min(2, baseIntensity + contrastBoost));
        }
        // TODO: Phase 2 - Calculate beat phase for cyclic effects
        _calculateBeatPhase(enhancedBPM) {
          const now = performance.now();
          const beatInterval = 6e4 / enhancedBPM;
          const timeSinceStart = now % beatInterval;
          return timeSinceStart / beatInterval;
        }
        // TODO: Phase 2 - Calculate dynamic hue shift for beat effects
        _calculateHueShift(beatOccurred, energy, beatPhase) {
          if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
            return 0;
          }
          const artisticMode = this.config.artisticMode;
          const baseAmplitude = artisticMode === "cosmic-maximum" ? 8 : 5;
          let hueShift = Math.sin(beatPhase * 2 * Math.PI) * baseAmplitude;
          if (beatOccurred) {
            const beatBoost = artisticMode === "cosmic-maximum" ? 12 : 10;
            hueShift += energy * beatBoost;
          }
          const clampRange = artisticMode === "cosmic-maximum" ? 25 : 15;
          return Math.max(-clampRange, Math.min(clampRange, hueShift));
        }
        _updateMusicalMemory(musicData, trackUri) {
          this.musicalMemory.recentTracks.unshift({
            trackUri,
            ...musicData,
            timestamp: Date.now()
          });
          if (this.musicalMemory.recentTracks.length > this.musicalMemory.maxMemorySize) {
            this.musicalMemory.recentTracks.pop();
          }
          this.musicalMemory.energyHistory.unshift(musicData.energy);
          if (this.musicalMemory.energyHistory.length > 20) {
            this.musicalMemory.energyHistory.pop();
          }
          this.harmonyMetrics.temporalMemoryEvents++;
        }
        _updateKineticState(musicData) {
          const { energy, enhancedBPM, beatOccurred } = musicData;
          const now = performance.now();
          if (beatOccurred) {
            this.kineticState.lastBeatTime = now;
            this.kineticState.currentPulse = 1;
          } else {
            this.kineticState.currentPulse *= 0.95;
          }
          const timeSinceLastBeat = now - this.kineticState.lastBeatTime;
          const beatInterval = 6e4 / (enhancedBPM || 120);
          this.kineticState.breathingPhase = timeSinceLastBeat % beatInterval / beatInterval * 2 * Math.PI;
          this.kineticState.visualMomentum = this.utils.lerp(
            this.kineticState.visualMomentum,
            energy,
            0.1
          );
        }
        _applyAestheticGravity(musicData) {
          const { visualIntensity, valence, energy } = musicData;
          const gravityX = (valence - 0.5) * 2;
          const gravityY = (energy - 0.5) * 2;
          const gravityStrength = visualIntensity;
          const root = this.utils.getRootStyle();
          if (root) {
            root.style.setProperty("--sn-gravity-x", gravityX.toFixed(3));
            root.style.setProperty("--sn-gravity-y", gravityY.toFixed(3));
            root.style.setProperty(
              "--sn-gravity-strength",
              gravityStrength.toFixed(3)
            );
          }
        }
        getQuantumEmpathyMetrics() {
          const avgEnergy = this.musicalMemory.energyHistory.reduce((a, b) => a + b, 0) / this.musicalMemory.energyHistory.length || 0;
          return {
            averageRecentEnergy: avgEnergy,
            systemMomentum: this.kineticState.visualMomentum,
            preferenceProfileSize: this.musicalMemory.userColorPreferences.size
          };
        }
        generateHarmonicVariations(baseRgb) {
          const oklab = this.utils.rgbToOklab(baseRgb.r, baseRgb.g, baseRgb.b);
          const darkOklabL = Math.max(0, Math.min(1, oklab.L * 0.75));
          const darkRgb = this.utils.oklabToRgb(darkOklabL, oklab.a, oklab.b);
          const lightOklabL = Math.max(0, Math.min(1, oklab.L * 1.25));
          const lightRgb = this.utils.oklabToRgb(lightOklabL, oklab.a, oklab.b);
          return {
            darkVibrantHex: this.utils.rgbToHex(darkRgb.r, darkRgb.g, darkRgb.b),
            lightVibrantHex: this.utils.rgbToHex(lightRgb.r, lightRgb.g, lightRgb.b)
          };
        }
        /**
         * Get current gradient colors optimized for WebGL texture creation
         * @param stopCount Number of gradient stops to generate (default: 5)
         * @returns Array of RGB color objects or null if unavailable
         */
        getCurrentGradient(stopCount = 5) {
          try {
            const currentPalette = this.catppuccinPalettes[this.currentTheme];
            if (!currentPalette) {
              return null;
            }
            const rootEl = this.utils.getRootStyle();
            const accentHex = rootEl ? getComputedStyle(rootEl).getPropertyValue(_ColorHarmonyEngine.CANONICAL_HEX_VAR).trim() : "";
            let primaryColor;
            if (accentHex) {
              const rgb = this.utils.hexToRgb(accentHex);
              if (rgb) {
                primaryColor = rgb;
              } else {
                const defaultAccent = currentPalette.accents.mauve || "#cba6f7";
                primaryColor = this.utils.hexToRgb(defaultAccent);
              }
            } else {
              const defaultAccent = currentPalette.accents.mauve || "#cba6f7";
              primaryColor = this.utils.hexToRgb(defaultAccent);
            }
            const gradientColors = [];
            const musicInfluence = this.kineticState.musicIntensityMultiplier || 1;
            const hueShift = this.kineticState.hueShift || 0;
            const valenceGravity = this.kineticState.valenceGravity || 0.5;
            for (let i = 0; i < stopCount; i++) {
              const position = i / (stopCount - 1);
              let variantColor;
              if (position === 0) {
                variantColor = this._createVariant(
                  primaryColor,
                  -0.3,
                  valenceGravity,
                  hueShift
                );
              } else if (position === 1) {
                variantColor = this._createVariant(
                  primaryColor,
                  0.2,
                  valenceGravity,
                  hueShift
                );
              } else {
                const lightnessFactor = (position - 0.5) * 0.4;
                variantColor = this._createVariant(
                  primaryColor,
                  lightnessFactor,
                  valenceGravity,
                  hueShift
                );
              }
              variantColor = this._applyMusicInfluence(
                variantColor,
                musicInfluence,
                position
              );
              gradientColors.push({
                r: Math.round(Math.max(0, Math.min(255, variantColor.r))),
                g: Math.round(Math.max(0, Math.min(255, variantColor.g))),
                b: Math.round(Math.max(0, Math.min(255, variantColor.b)))
              });
            }
            if (this.config?.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Generated gradient with ${stopCount} stops:`,
                gradientColors
              );
            }
            return gradientColors;
          } catch (error) {
            if (this.config?.enableDebug) {
              console.error(
                "[ColorHarmonyEngine] Failed to generate gradient:",
                error
              );
            }
            return null;
          }
        }
        /**
         * Create a color variant with lightness, saturation, and hue adjustments
         */
        _createVariant(baseColor, lightnessFactor, valenceGravity, hueShift) {
          const oklab = this.utils.rgbToOklab(baseColor.r, baseColor.g, baseColor.b);
          const newL = Math.max(0, Math.min(1, oklab.L + lightnessFactor * 0.2));
          const chromaScale = 0.8 + valenceGravity * 0.4;
          const newA = oklab.a * chromaScale;
          const newB = oklab.b * chromaScale;
          const hueAdjustment = hueShift * 0.1;
          const adjustedA = newA * Math.cos(hueAdjustment) - newB * Math.sin(hueAdjustment);
          const adjustedB = newA * Math.sin(hueAdjustment) + newB * Math.cos(hueAdjustment);
          return this.utils.oklabToRgb(newL, adjustedA, adjustedB);
        }
        /**
         * Apply music intensity influence to color
         */
        _applyMusicInfluence(color, intensity, position) {
          const positionEffect = 1 + Math.sin(position * Math.PI) * 0.2;
          const effectiveIntensity = Math.max(
            0.7,
            Math.min(1.3, intensity * positionEffect)
          );
          return {
            r: color.r * effectiveIntensity,
            g: color.g * effectiveIntensity,
            b: color.b * effectiveIntensity
          };
        }
        // =========================
        // PUBLIC API – User Control
        // =========================
        /**
         * Update user-defined harmonic intensity (0–1). Values outside range are clamped.
         */
        setIntensity(value) {
          const clamped = Math.max(0, Math.min(1, value));
          this.userIntensity = clamped;
          if (this.config?.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] User harmonic intensity set to ${clamped}`
            );
          }
        }
        /**
         * External systems can push a pre-computed RGB palette to the engine.
         * Currently this simply triggers a palette refresh so all CSS variables
         * are recalculated.  Future phases may blend these colours directly.
         *
         * @param colors – Array of RGB objects ({ r,g,b }) representing the new palette
         */
        updatePalette(colors) {
          if (!colors?.length) return;
          if (this.config?.enableDebug) {
            console.log("[ColorHarmonyEngine] updatePalette invoked", {
              count: colors.length
            });
          }
          this.forceRepaint("external-palette");
        }
        // ============================
        // Settings / Event Integration
        // ============================
        _handleSettingsChange(event) {
          const { key, value } = event.detail || {};
          switch (key) {
            case HARMONIC_INTENSITY_KEY: {
              const num = parseFloat(value);
              if (!Number.isNaN(num)) {
                this.setIntensity(num);
              }
              break;
            }
            case HARMONIC_EVOLUTION_KEY: {
              const enabled = value === "true" || value === true;
              this._setEvolutionEnabled(enabled);
              break;
            }
          }
        }
        _handleArtisticModeChanged() {
          this.currentTheme = this.detectCurrentTheme();
          if (!this._pendingPaletteRefresh) {
            this._pendingPaletteRefresh = setTimeout(() => {
              this._pendingPaletteRefresh = null;
              this.refreshPalette();
            }, 80);
          }
        }
        _forcePaletteRepaint() {
          this.kineticState.hueShift = (this.kineticState.hueShift || 0) + 0.01;
        }
        // Evolution helpers
        _startEvolutionLoop() {
          if (this._evolutionTimer) return;
          const basePeriod = 3e4;
          const period = basePeriod / Math.max(0.1, this.userIntensity);
          this._evolutionTimer = setInterval(() => {
            const step = 2 * this.userIntensity;
            const current = this.kineticState.hueShift ?? 0;
            this.kineticState.hueShift = (current + step + 360) % 360 - 180;
          }, period);
        }
        _stopEvolutionLoop() {
          if (this._evolutionTimer) {
            clearInterval(this._evolutionTimer);
            this._evolutionTimer = null;
          }
        }
        _setEvolutionEnabled(enabled) {
          if (this.evolutionEnabled === enabled) return;
          this.evolutionEnabled = enabled;
          if (enabled) this._startEvolutionLoop();
          else this._stopEvolutionLoop();
        }
        // Clean up listeners when destroyed
        destroy() {
          this._stopEvolutionLoop();
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this._boundSettingsChangeHandler
          );
          document.removeEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          if (this.semanticColorManager) {
            this.semanticColorManager.destroy();
          }
          super.destroy?.();
        }
        /**
         * Public helper that triggers a colour rebake based on the current track.
         * Prefer calling the global Year3000System where available so the full
         * pipeline (extraction → harmonisation → CSS variable batch) is reused.
         */
        async refreshPalette() {
          try {
            const y3kSystem = globalThis.year3000System;
            if (y3kSystem?.updateColorsFromCurrentTrack) {
              await y3kSystem.updateColorsFromCurrentTrack();
              return;
            }
            const root = this.utils.getRootStyle();
            if (!root) return;
            const styles = getComputedStyle(root);
            const primary = styles.getPropertyValue("--sn-gradient-primary").trim();
            if (primary) {
              root.style.setProperty("--sn-gradient-primary", primary);
              const rgb = this.utils.hexToRgb(primary);
              if (rgb) {
                root.style.setProperty(
                  "--sn-gradient-primary-rgb",
                  `${rgb.r},${rgb.g},${rgb.b}`
                );
              }
            }
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn("[ColorHarmonyEngine] refreshPalette failed", err);
            }
          }
        }
        /**
         * Swap Catppuccin palette accents & neutrals based on detected genre.
         * Executes asynchronously to avoid blocking audio thread.
         */
        async _applyGenrePalette(genre) {
          try {
            const palette = await this._getGenreAwarePalette(genre);
            if (!palette) return;
            this.catppuccinPalettes[this.currentTheme] = palette;
            await this.refreshPalette();
            try {
              GlobalEventBus.publish("music:genre-change", {
                genre,
                palette
              });
            } catch (_e) {
            }
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn("[ColorHarmonyEngine] _applyGenrePalette failed", err);
            }
          }
        }
        setEmergentEngine(engine) {
          this.emergentEngine = engine;
        }
        // ---------------------------------------------------------------------------
        // 🔄 SETTINGS-AWARE REPAINT IMPLEMENTATION
        // ---------------------------------------------------------------------------
        /**
         * Re-apply the current palette immediately.  This is extremely lightweight
         * (just re-blends colours + sets CSS vars) so it can be called synchronously
         * from Year3000System after a relevant settings change.
         */
        forceRepaint(_reason = "settings-change") {
          this.refreshPalette?.();
        }
      };
      __name(_ColorHarmonyEngine, "ColorHarmonyEngine");
      /**
       * Canonical accent CSS custom property names.
       *  – `--sn-accent-hex`  : Hex string (e.g. "#cba6f7")
       *  – `--sn-accent-rgb`  : Comma-separated R,G,B channels (e.g. "203,166,247")
       *
       * These are written by the Year3000System colour pipeline and are considered
       * the single source-of-truth accent accessed by SCSS and visual systems.
       */
      _ColorHarmonyEngine.CANONICAL_HEX_VAR = "--sn-accent-hex";
      _ColorHarmonyEngine.CANONICAL_RGB_VAR = "--sn-accent-rgb";
      ColorHarmonyEngine = _ColorHarmonyEngine;
    }
  });

  // src-js/utils/platform/SpicetifyCompat.ts
  var _SpicetifyCompat, SpicetifyCompat;
  var init_SpicetifyCompat = __esm({
    "src-js/utils/platform/SpicetifyCompat.ts"() {
      "use strict";
      _SpicetifyCompat = class _SpicetifyCompat {
        /**
         * Get audio data with fallback handling
         * Uses correct Spicetify.getAudioData() API with fallback to legacy patterns
         */
        static async getAudioData() {
          try {
            if (typeof Spicetify !== "undefined" && Spicetify.getAudioData) {
              return await Spicetify.getAudioData();
            } else {
              console.warn("[SpicetifyCompat] Spicetify.getAudioData not available");
              return null;
            }
          } catch (error) {
            console.error("[SpicetifyCompat] Error fetching audio data:", error);
            return null;
          }
        }
        /**
         * Check if Spicetify APIs are available
         */
        static isAvailable() {
          return typeof Spicetify !== "undefined" && !!Spicetify.getAudioData;
        }
        /**
         * Retry wrapper for audio data fetching
         */
        static async getAudioDataWithRetry(retryDelay = 200, maxRetries = 10) {
          for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
              const audioData = await this.getAudioData();
              if (audioData) {
                return audioData;
              }
            } catch (error) {
              if (attempt < maxRetries - 1) {
                console.log(
                  `[SpicetifyCompat] Retrying audio data fetch (${attempt + 1}/${maxRetries})...`
                );
                await new Promise((resolve) => setTimeout(resolve, retryDelay));
              } else {
                console.warn(
                  `[SpicetifyCompat] Audio data fetch failed after ${maxRetries} attempts:`,
                  error
                );
              }
            }
          }
          return null;
        }
      };
      __name(_SpicetifyCompat, "SpicetifyCompat");
      SpicetifyCompat = _SpicetifyCompat;
    }
  });

  // src-js/audio/GenreProfileManager.ts
  var GENRE_PROFILES, _GenreProfileManager, GenreProfileManager;
  var init_GenreProfileManager = __esm({
    "src-js/audio/GenreProfileManager.ts"() {
      "use strict";
      init_globalConfig();
      GENRE_PROFILES = {
        electronic: { energyBoost: 1.1, beatEmphasis: 1.2, precision: 0.9 },
        dance: { energyBoost: 1.2, beatEmphasis: 1.25, precision: 0.95 },
        house: { energyBoost: 1.2, beatEmphasis: 1.25, precision: 0.95 },
        techno: { energyBoost: 1.15, beatEmphasis: 1.3, precision: 1 },
        trance: { energyBoost: 1.15, beatEmphasis: 1.1, precision: 0.85 },
        rock: { energyBoost: 1.05, intensityMultiplier: 1.1, dynamicRange: 1.1 },
        metal: { energyBoost: 1.15, intensityMultiplier: 1.2, dynamicRange: 1.2 },
        punk: { energyBoost: 1.2, intensityMultiplier: 1.1, precision: 0.8 },
        hiphop: { beatEmphasis: 1.3, grooveFactor: 1.2, tempoMultiplier: 0.95 },
        rap: { beatEmphasis: 1.3, grooveFactor: 1.2, tempoMultiplier: 0.95 },
        jazz: { adaptiveVariation: true, complexity: 1.2, smoothingFactor: 1.3 },
        classical: {
          gentleMode: true,
          dynamicRange: 1.4,
          tempoVariationHandling: "adaptive"
        },
        ambient: { subtleMode: true, intensityReduction: 0.7, smoothingFactor: 1.5 },
        pop: { energyBoost: 1.05, beatEmphasis: 1.1, precision: 0.85 },
        rnb: { grooveFactor: 1.25, smoothingFactor: 1.1 },
        soul: { grooveFactor: 1.3, smoothingFactor: 1.15 },
        default: {
          balanced: true,
          energyBoost: 1,
          beatEmphasis: 1,
          precision: 1
        }
      };
      _GenreProfileManager = class _GenreProfileManager {
        constructor(dependencies = {}) {
          this.config = dependencies.YEAR3000_CONFIG || YEAR3000_CONFIG;
          if (this.config.enableDebug) {
            console.log("\u{1F9EC} [GenreProfileManager] Initialized");
          }
        }
        _getGenreFromAudioFeatures(features) {
          if (!features) return "default";
          const { danceability, energy, acousticness, instrumentalness, tempo } = features;
          if (instrumentalness > 0.6 && acousticness < 0.2 && energy > 0.6) {
            if (tempo > 120) return "techno";
            return "electronic";
          }
          if (danceability > 0.7 && energy > 0.7) return "dance";
          if (acousticness > 0.7 && energy < 0.4) return "classical";
          if (acousticness > 0.5 && instrumentalness < 0.1) return "jazz";
          if (energy > 0.7 && instrumentalness < 0.1 && danceability > 0.5)
            return "rock";
          if (danceability > 0.7 && instrumentalness < 0.2 && energy > 0.5 && tempo < 110)
            return "hiphop";
          return "default";
        }
        getProfileForTrack(audioFeatures) {
          const genre = this._getGenreFromAudioFeatures(audioFeatures);
          const profile = GENRE_PROFILES[genre];
          if (this.config.enableDebug) {
            console.log(
              `[GenreProfileManager] Detected genre: '${genre}'. Applying profile.`
            );
          }
          if (profile) {
            return profile;
          }
          const defaultProfile = GENRE_PROFILES.default;
          if (defaultProfile) {
            return defaultProfile;
          }
          throw new Error(
            "[GenreProfileManager] Critical: Default genre profile is missing."
          );
        }
        /**
         * Public helper that returns the genre string detected for the given audio-features without
         * allocating a full profile. Useful for colour/palette routing.
         */
        detectGenre(features) {
          return this._getGenreFromAudioFeatures(features);
        }
      };
      __name(_GenreProfileManager, "GenreProfileManager");
      GenreProfileManager = _GenreProfileManager;
    }
  });

  // src-js/audio/MusicSyncService.ts
  var MUSIC_SYNC_CONFIG, _MusicSyncService, MusicSyncService;
  var init_MusicSyncService = __esm({
    "src-js/audio/MusicSyncService.ts"() {
      "use strict";
      init_globalConfig();
      init_EventBus();
      init_Year3000Utilities();
      init_SpicetifyCompat();
      init_StorageManager();
      init_GenreProfileManager();
      MUSIC_SYNC_CONFIG = {
        enableDebug: true,
        enableBeatSynchronization: true,
        enableGenreAnalysis: true,
        enableMoodAdaptation: true,
        bpmCalculation: {
          useEnhancedAlgorithm: true,
          danceabilityWeight: 0.9,
          energyWeight: 0.6,
          bpmWeight: 0.6,
          energyThreshold: 0.5,
          danceabilityThreshold: 0.5,
          bpmThreshold: 0.8,
          maxBPM: 180,
          minBPM: 60
        },
        performance: {
          cacheSize: 100,
          cacheTTL: 3e5,
          maxRetries: 10,
          retryDelay: 200,
          enableMetrics: true,
          processingTimeTarget: 50
        },
        synchronization: {
          beatAccuracyTarget: 50,
          maxSyncDelay: 1e3,
          adaptiveQuality: true,
          predictiveCaching: true,
          debounceRapidChanges: 200
        },
        genreProfiles: {
          electronic: { intensityMultiplier: 1.2, precisionBoost: 1.1 },
          jazz: { smoothingFactor: 1.3, adaptiveVariation: true },
          classical: { gentleMode: true, tempoVariationHandling: "adaptive" },
          rock: { energyBoost: 1.15, consistentTiming: true },
          ambient: { subtleMode: true, intensityReduction: 0.7 },
          hiphop: { beatEmphasis: 1.25, rhythmPrecision: "high" },
          default: { balanced: true }
        },
        musicVisualSync: {
          enhancedBPM: {
            fallbacks: {
              tempo: 120,
              loudness: -5,
              key: 0,
              timeSignature: 4
            },
            danceabilityEstimation: {
              highDance: { min: 125, max: 145, value: 0.8 },
              mediumDance: { min: 100, max: 124, value: 0.7 },
              lowMediumDance: { min: 80, max: 99, value: 0.6 },
              lowDance: { value: 0.5 }
            },
            energyEstimation: {
              tempoRange: { min: 80, max: 160 },
              loudnessRange: { min: -15, max: 0 },
              tempoWeight: 0.6,
              loudnessWeight: 0.4
            }
          }
        }
      };
      _MusicSyncService = class _MusicSyncService {
        constructor(dependencies = {}) {
          this.isInitialized = false;
          this.currentTrack = null;
          this.audioData = null;
          this.currentTrackUri = null;
          this.latestProcessedData = null;
          // High-precision beat scheduling
          this.beatSchedulerTimer = null;
          // Phase 1: Song Change Debouncing
          this.songChangeDebounceTimer = null;
          this.nextBeatIndex = 0;
          this.currentSongBeats = [];
          this.songStartTimestamp = 0;
          this.metrics = {
            bpmCalculations: 0,
            beatSyncs: 0,
            cacheHits: 0,
            cacheMisses: 0,
            avgProcessingTime: 0,
            performance: [],
            errors: 0,
            updates: 0
          };
          this.unifiedCache = /* @__PURE__ */ new Map();
          this.subscribers = /* @__PURE__ */ new Map();
          this.beatSync = {
            lastBeatTime: 0,
            nextBeatTime: 0,
            beatInterval: 0,
            confidence: 0,
            isActive: false
          };
          this.performanceInterval = null;
          this.cacheCleanupInterval = null;
          // Increment this prefix whenever cache schema changes to avoid stale data
          this.CACHE_KEY_VERSION_PREFIX = "v3";
          /** Current unit beat direction vector (updated each beat). */
          this.currentBeatVector = { x: 0, y: 0 };
          this.config = dependencies.YEAR3000_CONFIG || YEAR3000_CONFIG;
          this.utils = dependencies.Year3000Utilities || Year3000Utilities_exports;
          this.settingsManager = dependencies.settingsManager;
          this.year3000System = dependencies.year3000System;
          this.genreProfileManager = dependencies.genreProfileManager || new GenreProfileManager({ YEAR3000_CONFIG: this.config });
          this.cacheTTL = MUSIC_SYNC_CONFIG.performance.cacheTTL;
          this.userPreferences = this.loadUserPreferences();
          if (this.config.enableDebug) {
            console.log("\u{1F3B5} MusicSyncService constructor called");
            console.log(
              "\u{1F3B5} [MusicSyncService] Initialized with GenreProfileManager support"
            );
          }
        }
        async initialize() {
          try {
            if (this.config.enableDebug) {
              console.log("\u{1F3B5} Initializing unified MusicSyncService...");
            }
            if (!SpicetifyCompat.isAvailable()) {
              console.warn(
                "[MusicSyncService] Spicetify audio data API not available at initialization. Some features may be limited."
              );
            }
            this.setupCacheManagement();
            if (MUSIC_SYNC_CONFIG.performance.enableMetrics) {
              this.setupPerformanceMonitoring();
            }
            this.isInitialized = true;
            if (this.config.enableDebug) {
              console.log("\u{1F31F} MusicSyncService initialized successfully!");
            }
          } catch (error) {
            console.error("\u274C MusicSyncService initialization failed:", error);
            this.metrics.errors++;
          }
        }
        // === SUBSCRIBER MANAGEMENT ===
        subscribe(systemInstance, systemName) {
          if (!systemInstance || typeof systemInstance.updateFromMusicAnalysis !== "function") {
            console.warn(
              `[MusicSyncService] Invalid system or missing updateFromMusicAnalysis method: ${systemName}`
            );
            return;
          }
          if (this.subscribers.has(systemName)) {
            if (this.config.enableDebug) {
              console.warn(
                `[MusicSyncService] System ${systemName} already subscribed.`
              );
            }
            return;
          }
          this.subscribers.set(systemName, systemInstance);
          if (this.config.enableDebug) {
            console.log(`[MusicSyncService] System subscribed: ${systemName}`);
          }
          if (this.latestProcessedData && systemInstance.initialized) {
            try {
              systemInstance.updateFromMusicAnalysis(
                this.latestProcessedData,
                null,
                this.currentTrackUri
              );
            } catch (error) {
              console.error(
                `[MusicSyncService] Error notifying new subscriber ${systemName}:`,
                error
              );
            }
          }
        }
        unsubscribe(systemName) {
          if (this.subscribers.has(systemName)) {
            this.subscribers.delete(systemName);
            if (this.config.enableDebug) {
              console.log(`[MusicSyncService] System unsubscribed: ${systemName}`);
            }
          }
        }
        notifySubscribers(processedData, rawFeatures, trackUri) {
          if (!this.isInitialized) {
            console.warn(
              "[MusicSyncService] Not initialized, cannot notify subscribers."
            );
            return;
          }
          this.latestProcessedData = processedData;
          for (const [name, system] of this.subscribers) {
            try {
              if (system.initialized && typeof system.updateFromMusicAnalysis === "function") {
                system.updateFromMusicAnalysis(processedData, rawFeatures, trackUri);
              }
            } catch (error) {
              console.error(
                `[MusicSyncService] Error notifying subscriber ${name}:`,
                error
              );
              this.metrics.errors++;
            }
          }
        }
        // === DATA FETCHING & CACHING ===
        async fetchAudioData(options = {}) {
          const {
            retryDelay = MUSIC_SYNC_CONFIG.performance.retryDelay,
            maxRetries = MUSIC_SYNC_CONFIG.performance.maxRetries
          } = options;
          const currentTrackUri = Spicetify.Player.data?.item?.uri;
          if (!currentTrackUri) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] No current track URI to fetch audio data."
              );
            }
            return null;
          }
          const cacheKey = this.generateCacheKey(currentTrackUri, "audioData");
          const cached = this.getFromCache(cacheKey);
          if (cached?.audioData) {
            if (this.isValidAudioData(cached.audioData)) {
              this.metrics.cacheHits++;
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Cache hit for audioData: ${cacheKey}`
                );
              }
              return cached.audioData;
            }
            this.unifiedCache.delete(cacheKey);
          }
          this.metrics.cacheMisses++;
          for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
              const audioData = await SpicetifyCompat.getAudioData();
              if (this.isValidAudioData(audioData)) {
                this.setInCache(cacheKey, { audioData });
                return audioData;
              }
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Audio analysis unavailable (attempt ${attempt + 1}/${maxRetries}). Retrying\u2026`
                );
              }
            } catch (error) {
              if (attempt === maxRetries - 1) {
                if (this.config.enableDebug) {
                  console.warn(
                    `[MusicSyncService] Audio data fetch error on final attempt:`,
                    error
                  );
                }
                this.metrics.errors++;
                const fallback = {
                  tempo: 120,
                  energy: 0.5,
                  valence: 0.5,
                  loudness: -10,
                  key: 0,
                  time_signature: 4,
                  danceability: 0.5,
                  acousticness: 0.5,
                  instrumentalness: 0,
                  speechiness: 0.05,
                  liveness: 0.2,
                  mode: 1
                };
                if (this.config.enableDebug) {
                  console.warn(
                    `[MusicSyncService] All audio-data attempts failed \u2013 using fallback defaults`
                  );
                }
                return fallback;
              }
            }
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
          }
          return null;
        }
        async getAudioFeatures() {
          try {
            const currentTrack = Spicetify.Player.data?.item;
            if (!currentTrack?.uri) return null;
            const trackId = currentTrack.uri.split(":")[2] || "fallback";
            const cacheKey = this.generateCacheKey(trackId, "features");
            const cached = this.getFromCache(
              cacheKey
            );
            if (cached?.audioFeatures) {
              this.metrics.cacheHits++;
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Cache hit for audioFeatures: ${cacheKey}`
                );
              }
              return cached.audioFeatures;
            }
            this.metrics.cacheMisses++;
            const response = await Spicetify.CosmosAsync.get(
              `https://api.spotify.com/v1/audio-features/${trackId}`
            );
            const features = {
              danceability: response.danceability,
              energy: response.energy,
              valence: response.valence,
              acousticness: response.acousticness,
              instrumentalness: response.instrumentalness,
              tempo: response.tempo
            };
            this.setInCache(cacheKey, { audioFeatures: features });
            return features;
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] Could not fetch audio features:",
                error
              );
            }
            return null;
          }
        }
        generateCacheKey(identifier, type = "default") {
          return `${this.CACHE_KEY_VERSION_PREFIX}-${identifier}-${type}`;
        }
        getFromCache(key) {
          const cached = this.unifiedCache.get(key);
          if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
            return cached.data;
          }
          if (cached) {
            this.unifiedCache.delete(key);
          }
          return null;
        }
        setInCache(key, data) {
          this.unifiedCache.set(key, {
            data,
            timestamp: Date.now()
          });
        }
        // === ENHANCED BPM CALCULATION ===
        async calculateEnhancedBPM(audioData, options = {}) {
          const startTime = performance.now();
          try {
            if (!audioData?.tempo) {
              if (this.config.enableDebug) {
                console.warn("[MusicSyncService] No BPM data available for track");
              }
              return this.getFallbackBPM();
            }
            const trackBPM = audioData.tempo;
            const config = {
              ...MUSIC_SYNC_CONFIG.bpmCalculation,
              ...options
            };
            const audioFeatures = await this.getAudioFeatures();
            if (!audioFeatures) {
              if (this.config.enableDebug) {
                console.log("[MusicSyncService] Using basic BPM calculation");
              }
              return this.validateBPM(trackBPM);
            }
            const { danceability, energy, valence = 0.5 } = audioFeatures;
            if (this.config.enableDebug) {
              console.log(
                `[MusicSyncService] Audio features - Danceability: ${danceability}, Energy: ${energy}, Valence: ${valence}`
              );
            }
            const profile = this.genreProfileManager.getProfileForTrack(
              audioFeatures || void 0
            );
            const detectedGenre = this.genreProfileManager.detectGenre(
              audioFeatures || void 0
            );
            const enhancedBPM = this.computeAdvancedBPM({
              trackBPM,
              danceability,
              energy,
              valence,
              config,
              profile
            });
            const currentTrack = Spicetify.Player.data?.item || Spicetify.Player.data;
            const uriParts = currentTrack?.uri?.split(":") ?? [];
            const trackId = uriParts.length > 2 && uriParts[2] ? uriParts[2] : "fallback";
            const cacheKey = this.generateCacheKey(trackId, "bpm");
            this.setInCache(cacheKey, {
              bpm: enhancedBPM,
              audioFeatures
            });
            this.metrics.bpmCalculations++;
            if (this.config.enableDebug) {
              console.log(
                `[MusicSyncService] Enhanced BPM: ${enhancedBPM} (original: ${trackBPM})`
              );
            }
            return enhancedBPM;
          } catch (error) {
            console.error("[MusicSyncService] BPM calculation failed:", error);
            this.metrics.errors++;
            return this.getFallbackBPM();
          }
        }
        computeAdvancedBPM(params) {
          const { trackBPM, danceability, energy, valence, config, profile } = params;
          const {
            danceabilityWeight,
            energyWeight,
            bpmWeight,
            energyThreshold,
            danceabilityThreshold,
            bpmThreshold,
            maxBPM,
            minBPM
          } = config;
          const normalizedBPM = Math.min(trackBPM / 120, 2);
          let adjustedDanceabilityWeight = danceabilityWeight;
          let adjustedEnergyWeight = energyWeight;
          let adjustedBpmWeight = bpmWeight;
          if (danceability < danceabilityThreshold) {
            adjustedDanceabilityWeight *= danceability;
          }
          if (energy < energyThreshold) {
            adjustedEnergyWeight *= energy;
          }
          if (normalizedBPM < bpmThreshold) {
            adjustedBpmWeight = 0.9;
          }
          let valenceInfluence = 1;
          if (valence > 0.6) {
            valenceInfluence = 1.05;
          } else if (valence < 0.4 && energy < 0.5) {
            valenceInfluence = 0.95;
          }
          const weightSum = adjustedDanceabilityWeight + adjustedEnergyWeight + adjustedBpmWeight;
          const weightedAverage = (danceability * adjustedDanceabilityWeight + energy * adjustedEnergyWeight + normalizedBPM * adjustedBpmWeight) / weightSum;
          let enhancedBPM = weightedAverage * 120 * valenceInfluence;
          if (profile.beatEmphasis) {
            enhancedBPM *= profile.beatEmphasis;
          }
          enhancedBPM = Math.max(minBPM, Math.min(maxBPM, enhancedBPM));
          return Math.round(enhancedBPM * 100) / 100;
        }
        validateBPM(bpm) {
          const { minBPM, maxBPM } = MUSIC_SYNC_CONFIG.bpmCalculation;
          return Math.max(minBPM, Math.min(maxBPM * 2, Math.round(bpm * 100) / 100));
        }
        getFallbackBPM() {
          return 75;
        }
        // === FEATURE ESTIMATION & FALLBACKS ===
        estimateDanceabilityFromTempo(tempo) {
          const config = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.danceabilityEstimation;
          if (tempo >= config.highDance.min && tempo <= config.highDance.max) {
            return config.highDance.value;
          }
          if (tempo >= config.mediumDance.min && tempo <= config.mediumDance.max) {
            return config.mediumDance.value;
          }
          if (tempo >= config.lowMediumDance.min && tempo <= config.lowMediumDance.max) {
            return config.lowMediumDance.value;
          }
          return config.lowDance.value;
        }
        estimateEnergyFromTempoLoudness(tempo, loudness) {
          const config = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.energyEstimation;
          const tempoFactor = Math.max(
            0,
            Math.min(
              1,
              (tempo - config.tempoRange.min) / (config.tempoRange.max - config.tempoRange.min)
            )
          );
          const loudnessFactor = Math.max(
            0,
            Math.min(
              1,
              (loudness - config.loudnessRange.min) / (config.loudnessRange.max - config.loudnessRange.min)
            )
          );
          return tempoFactor * config.tempoWeight + loudnessFactor * config.loudnessWeight;
        }
        estimateValenceFromKey(key) {
          const majorKeys = [0, 2, 4, 5, 7, 9, 11];
          return majorKeys.includes(key) ? 0.6 : 0.4;
        }
        getFallbackProcessedData(trackUri) {
          const fallbacks = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks;
          const fallbackBeatInterval = 6e4 / fallbacks.tempo;
          return {
            trackUri,
            timestamp: Date.now(),
            tempo: fallbacks.tempo,
            loudness: fallbacks.loudness,
            key: fallbacks.key,
            timeSignature: fallbacks.timeSignature,
            estimatedDanceability: this.estimateDanceabilityFromTempo(
              fallbacks.tempo
            ),
            estimatedEnergy: this.estimateEnergyFromTempoLoudness(
              fallbacks.tempo,
              fallbacks.loudness
            ),
            estimatedValence: 0.5,
            energy: 0.5,
            valence: 0.5,
            processedEnergy: 0.5,
            visualIntensity: 0.5,
            moodIdentifier: "neutral",
            baseBPM: fallbacks.tempo,
            enhancedBPM: fallbacks.tempo,
            beatInterval: fallbackBeatInterval,
            bmpCalculationMethod: "fallback",
            dataSource: "fallback"
          };
        }
        // === MAIN PROCESSING PIPELINE ===
        async processAudioFeatures(rawSpicetifyAudioFeatures, trackUri, trackDurationMs) {
          if (!this.isInitialized) {
            console.warn("[MusicSyncService] Not initialized, skipping processing.");
            return;
          }
          this.stopBeatScheduler();
          this.currentTrackUri = trackUri;
          const cacheKey = this.generateCacheKey(trackUri, "processed");
          const cached = this.getFromCache(cacheKey);
          if (cached?.processedData) {
            this.notifySubscribers(cached.processedData, null, trackUri);
            return;
          }
          try {
            let audioAnalysisData = rawSpicetifyAudioFeatures;
            if (!audioAnalysisData) {
              audioAnalysisData = await this.fetchAudioData();
            }
            if (!audioAnalysisData) {
              throw new Error("Failed to fetch or receive audio data.");
            }
            if (audioAnalysisData.beats && audioAnalysisData.beats.length > 0) {
              this.currentSongBeats = audioAnalysisData.beats;
              this.songStartTimestamp = Date.now();
              this.nextBeatIndex = 0;
              this.scheduleNextBeatEvent();
            }
            const enhancedBPM = await this.calculateEnhancedBPM(audioAnalysisData);
            const beatInterval = enhancedBPM > 0 ? 6e4 / enhancedBPM : 0;
            const trackData = audioAnalysisData;
            const {
              tempo = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.tempo,
              loudness = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.loudness,
              key = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.key,
              time_signature: timeSignature = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.timeSignature
            } = trackData;
            const audioFeatures = await this.getAudioFeatures();
            const estimatedDanceability = audioFeatures?.danceability ?? this.estimateDanceabilityFromTempo(tempo);
            const estimatedEnergy = audioFeatures?.energy ?? this.estimateEnergyFromTempoLoudness(tempo, loudness);
            const estimatedValence = audioFeatures?.valence ?? this.estimateValenceFromKey(key);
            const artisticMultipliers = this.config.getCurrentMultipliers?.() || {
              musicEnergyBoost: 1,
              visualIntensityBase: 1
            };
            const processedEnergy = Math.max(
              0.1,
              Math.min(
                1,
                estimatedEnergy * (artisticMultipliers.musicEnergyBoost || 1)
              )
            );
            const baseIntensity = estimatedEnergy * 0.6 + estimatedDanceability * 0.4;
            const visualIntensity = baseIntensity * (artisticMultipliers.visualIntensityBase || 1);
            let moodIdentifier = "neutral";
            if (estimatedValence > 0.6 && estimatedEnergy > 0.6) {
              moodIdentifier = "energetic-happy";
            } else if (estimatedValence > 0.6 && estimatedEnergy <= 0.6) {
              moodIdentifier = "calm-happy";
            } else if (estimatedValence <= 0.4 && estimatedEnergy > 0.6) {
              moodIdentifier = "intense-moody";
            } else if (estimatedValence <= 0.4 && estimatedEnergy <= 0.4) {
              moodIdentifier = "calm-melancholy";
            }
            const animationSpeedFactor = Math.max(0.5, 0.8 + visualIntensity * 0.4);
            const genreTag = this.genreProfileManager.detectGenre(
              audioFeatures || void 0
            );
            const processedData = {
              trackUri,
              timestamp: Date.now(),
              tempo,
              loudness,
              key,
              timeSignature,
              duration: trackDurationMs,
              estimatedDanceability,
              estimatedEnergy,
              estimatedValence,
              energy: estimatedEnergy,
              valence: estimatedValence,
              processedEnergy,
              visualIntensity,
              moodIdentifier,
              baseBPM: tempo,
              enhancedBPM,
              beatInterval,
              bmpCalculationMethod: "unified-service",
              dataSource: "unified-music-sync-service",
              beatOccurred: false,
              animationSpeedFactor,
              genre: genreTag
            };
            this.setInCache(cacheKey, { processedData });
            this.latestProcessedData = processedData;
            if (this.config.enableDebug) {
              console.log("\u{1F3B5} [MusicSyncService] Processed music data:", {
                baseTempo: tempo,
                enhancedBPM,
                mood: moodIdentifier,
                energy: estimatedEnergy.toFixed(2),
                visualIntensity: visualIntensity.toFixed(2)
              });
            }
            this.notifySubscribers(
              processedData,
              rawSpicetifyAudioFeatures,
              trackUri
            );
            GlobalEventBus.publish("beat/frame", {
              timestamp: performance.now(),
              trackUri,
              processedData,
              rawData: rawSpicetifyAudioFeatures
            });
            GlobalEventBus.publish("beat/bpm", { bpm: processedData.enhancedBPM });
            GlobalEventBus.publish("beat/intensity", {
              intensity: processedData.visualIntensity
            });
            if (this.config.enableDebug) {
              console.log(
                "[MusicSyncService] Successfully processed audio features.",
                {
                  baseTempo: tempo,
                  enhancedBPM,
                  mood: moodIdentifier,
                  energy: estimatedEnergy.toFixed(2),
                  visualIntensity: visualIntensity.toFixed(2)
                }
              );
            }
          } catch (error) {
            console.error("[MusicSyncService] Processing failed:", error);
            this.metrics.errors++;
            const fallbackData = this.getFallbackProcessedData(trackUri);
            this.latestProcessedData = fallbackData;
            this.notifySubscribers(fallbackData, null, trackUri);
          }
        }
        /**
         * Re-extract colours & (optionally) recompute beat analysis for the current
         * track.  When `force === true` the method runs even if the track URI hasn't
         * changed (used after live settings updates so gradients repaint instantly).
         */
        async processSongUpdate(force = false) {
          const trackUri = Spicetify.Player?.data?.item?.uri;
          if (!trackUri) return;
          if (!force && trackUri === this.currentTrackUri) {
            return;
          }
          if (this.songChangeDebounceTimer) {
            clearTimeout(this.songChangeDebounceTimer);
          }
          if (force) {
            await this._processSongUpdateInternal(trackUri);
            return;
          }
          this.songChangeDebounceTimer = setTimeout(async () => {
            this.songChangeDebounceTimer = null;
            await this._processSongUpdateInternal(trackUri);
          }, MUSIC_SYNC_CONFIG.synchronization.debounceRapidChanges);
        }
        /**
         * Internal implementation of song processing, extracted for debouncing.
         */
        async _processSongUpdateInternal(trackUri) {
          this.invalidateTrackCaches(trackUri);
          try {
            const trackDuration = Spicetify.Player.data?.item?.duration?.milliseconds || 0;
            const [audioFeatures, rawColors] = await Promise.all([
              this.getAudioFeatures(),
              Spicetify.colorExtractor(trackUri)
            ]);
            const colors = this.utils.sanitizeColorMap(
              rawColors || {}
            );
            if (Object.keys(colors).length > 0) {
              const colorContext = {
                rawColors: colors,
                trackUri,
                timestamp: Date.now(),
                harmonicMode: this.config.currentHarmonicMode || "catppuccin",
                musicData: audioFeatures ? {
                  energy: audioFeatures.energy,
                  valence: audioFeatures.valence,
                  tempo: audioFeatures.tempo,
                  genre: this.genreProfileManager.detectGenre(audioFeatures)
                } : void 0,
                performanceHints: {
                  preferLightweight: false,
                  enableAdvancedBlending: true,
                  maxProcessingTime: 100
                  // 100ms max for color processing
                }
              };
              GlobalEventBus.publish("colors/extracted", {
                type: "colors/extracted",
                payload: colorContext
              });
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F3B5} [MusicSyncService] Published colors/extracted event for strategy processing",
                  { trackUri, colorCount: Object.keys(colors).length }
                );
              }
            }
            if (audioFeatures) {
              const provisionalAudioData = this.convertFeaturesToAudioData(audioFeatures);
              await this.processAudioFeatures(
                provisionalAudioData,
                trackUri,
                trackDuration
              );
            }
            (async () => {
              const fullAnalysis = await this.fetchAudioData();
              if (this.isValidAudioData(fullAnalysis)) {
                await this.processAudioFeatures(
                  fullAnalysis,
                  trackUri,
                  trackDuration
                );
              }
            })();
          } catch (error) {
            console.error(
              `[MusicSyncService] Error processing song update for ${trackUri}:`,
              error
            );
            this.metrics.errors++;
          }
        }
        // === LIFECYCLE & HELPERS ===
        setupCacheManagement() {
          this.cacheCleanupInterval = setInterval(() => {
            const now = Date.now();
            for (const [key, cacheEntry] of this.unifiedCache.entries()) {
              if (now - cacheEntry.timestamp > this.cacheTTL) {
                this.unifiedCache.delete(key);
              }
            }
          }, this.cacheTTL);
        }
        setupPerformanceMonitoring() {
          this.performanceInterval = setInterval(() => {
            if (this.metrics.performance.length > 0) {
              const avg = this.metrics.performance.reduce((a, b) => a + b, 0) / this.metrics.performance.length;
              this.metrics.avgProcessingTime = avg;
              this.metrics.performance = [];
            }
          }, 6e4);
        }
        loadUserPreferences() {
          try {
            const prefs = StorageManager.get("sn-music-sync-prefs");
            return prefs ? JSON.parse(prefs) : {};
          } catch (e) {
            return {};
          }
        }
        saveUserPreferences() {
          try {
            StorageManager.set(
              "sn-music-sync-prefs",
              JSON.stringify(this.userPreferences)
            );
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] Could not save user preferences:",
                error
              );
            }
          }
        }
        updateConfiguration(newConfig) {
          const previousConfig = { ...MUSIC_SYNC_CONFIG };
          Object.assign(MUSIC_SYNC_CONFIG, newConfig);
          if (this.config.enableDebug) {
            console.log("\u{1F3B5} [MusicSyncService] Configuration updated", {
              from: previousConfig,
              to: MUSIC_SYNC_CONFIG
            });
          }
          this.cacheTTL = MUSIC_SYNC_CONFIG.performance.cacheTTL;
          if (previousConfig.performance.enableMetrics !== MUSIC_SYNC_CONFIG.performance.enableMetrics) {
            if (MUSIC_SYNC_CONFIG.performance.enableMetrics) {
              this.setupPerformanceMonitoring();
            } else if (this.performanceInterval) {
              clearInterval(this.performanceInterval);
              this.performanceInterval = null;
            }
          }
        }
        destroy() {
          if (this.songChangeDebounceTimer) {
            clearTimeout(this.songChangeDebounceTimer);
            this.songChangeDebounceTimer = null;
          }
          this.stopBeatScheduler();
          if (this.performanceInterval) clearInterval(this.performanceInterval);
          if (this.cacheCleanupInterval) clearInterval(this.cacheCleanupInterval);
          this.subscribers.clear();
          this.unifiedCache.clear();
          this.isInitialized = false;
          this.latestProcessedData = null;
          this.metrics = {
            bpmCalculations: 0,
            beatSyncs: 0,
            cacheHits: 0,
            cacheMisses: 0,
            avgProcessingTime: 0,
            performance: [],
            errors: 0,
            updates: 0
          };
          this.cacheCleanupInterval = null;
        }
        // Legacy method for backward compatibility - now uses event-driven pattern
        setColorHarmonyEngine(engine) {
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3B5} [MusicSyncService] setColorHarmonyEngine called - now using event-driven pattern instead of direct dependency."
            );
          }
        }
        getLatestProcessedData() {
          return this.latestProcessedData;
        }
        /**
         * Get the latest beat vector (unit direction) for visual systems that need
         * directional rhythm cues. Falls back to {0,0} when unavailable.
         */
        getCurrentBeatVector() {
          return { ...this.currentBeatVector };
        }
        stopBeatScheduler() {
          if (this.beatSchedulerTimer) {
            clearTimeout(this.beatSchedulerTimer);
            this.beatSchedulerTimer = null;
          }
        }
        triggerBeatEvent() {
          const GOLDEN_RATIO = 0.61803398875;
          const angle = this.nextBeatIndex * GOLDEN_RATIO % 1 * Math.PI * 2;
          this.currentBeatVector = { x: Math.cos(angle), y: Math.sin(angle) };
          if (this.latestProcessedData) {
            const beatUpdate = {
              ...this.latestProcessedData,
              beatOccurred: true,
              beatVector: this.currentBeatVector
            };
            this.notifySubscribers(beatUpdate, null, this.currentTrackUri);
          }
          this.nextBeatIndex++;
          this.scheduleNextBeatEvent();
        }
        scheduleNextBeatEvent() {
          if (this.nextBeatIndex >= this.currentSongBeats.length) {
            return;
          }
          const nextBeat = this.currentSongBeats[this.nextBeatIndex];
          const timeSinceSongStart = Date.now() - this.songStartTimestamp;
          const delay = nextBeat.start * 1e3 - timeSinceSongStart;
          if (delay >= 0) {
            this.beatSchedulerTimer = setTimeout(
              () => this.triggerBeatEvent(),
              delay
            );
          } else {
            this.nextBeatIndex++;
            this.scheduleNextBeatEvent();
          }
        }
        /**
         * Validate that the returned audio analysis object actually contains usable
         * information (primarily tempo). Spotify may return an empty object when the
         * analysis is not ready yet – treating that as valid poisons the cache.
         */
        isValidAudioData(data) {
          return !!data && typeof data.tempo === "number" && data.tempo > 0;
        }
        /**
         * Remove any cached entries (audioData, features, bpm, processed) belonging
         * to the provided track URI. Useful when switching tracks to ensure we do
         * not reuse stale or invalid data cached under the previous song.
         */
        invalidateTrackCaches(trackUri) {
          if (!trackUri) return;
          for (const key of this.unifiedCache.keys()) {
            if (key.includes(trackUri)) {
              this.unifiedCache.delete(key);
            }
          }
        }
        /**
         * Convert the lightweight `audio-features` payload into a pseudo `AudioData`
         * object so the rest of the pipeline (which expects full analysis) can work
         * immediately. Missing properties are filled with sensible defaults.
         */
        convertFeaturesToAudioData(features) {
          const fb = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks;
          return {
            tempo: features.tempo,
            energy: features.energy,
            valence: features.valence,
            loudness: fb.loudness,
            key: fb.key,
            time_signature: fb.timeSignature,
            danceability: features.danceability,
            acousticness: features.acousticness,
            instrumentalness: features.instrumentalness,
            speechiness: 0,
            liveness: 0,
            mode: 0
            // Optional arrays left undefined – beat grid will arrive later
          };
        }
        // -------------------------------------------------------------------
        // External adapter integration helpers ------------------------------
        // -------------------------------------------------------------------
        /**
         * Adapter-facing helper to push music metrics without relying on the
         * full processing pipeline.  Currently a no-op placeholder that may be
         * expanded in future phases.
         */
        updateMetrics(metrics) {
          this.latestProcessedData = metrics;
        }
        /**
         * Get current music state for consciousness systems
         */
        getCurrentMusicState() {
          if (!this.latestProcessedData || !this.audioData) {
            return null;
          }
          return {
            emotion: this.latestProcessedData.emotion || null,
            beat: {
              tempo: this.latestProcessedData.bpm || this.audioData.tempo || 120,
              energy: this.latestProcessedData.energy || this.audioData.energy || 0.5,
              timestamp: Date.now()
            },
            intensity: this.latestProcessedData.intensity || this.audioData.energy || 0.5
          };
        }
      };
      __name(_MusicSyncService, "MusicSyncService");
      MusicSyncService = _MusicSyncService;
    }
  });

  // src-js/ui/managers/GlassmorphismManager.ts
  var _GlassmorphismManager, GlassmorphismManager;
  var init_GlassmorphismManager = __esm({
    "src-js/ui/managers/GlassmorphismManager.ts"() {
      "use strict";
      init_globalConfig();
      init_settingKeys();
      init_Year3000Utilities();
      _GlassmorphismManager = class _GlassmorphismManager {
        constructor(config = YEAR3000_CONFIG, utils = Year3000Utilities_exports, cssBatcher = null, performanceAnalyzer = null, settingsManager) {
          this.initialized = false;
          this.cssBatcher = null;
          this.performanceAnalyzer = null;
          this.observers = [];
          this.config = config;
          this.utils = utils;
          this.cssBatcher = cssBatcher;
          this.performanceAnalyzer = performanceAnalyzer;
          this.settingsManager = settingsManager;
          this.isSupported = this.detectBackdropFilterSupport();
          this.currentIntensity = "balanced";
          this.boundHandleSettingsChange = this.handleSettingsChange.bind(this);
          this.initialize();
        }
        static getInstance() {
          if (!_GlassmorphismManager.instance) {
            throw new Error("GlassmorphismManager instance not initialized");
          }
          return _GlassmorphismManager.instance;
        }
        async initialize() {
          const initialIntensity = this.settingsManager.get("sn-glassmorphism-level");
          this.applyGlassmorphismSettings(initialIntensity);
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this.boundHandleSettingsChange
          );
          this.initialized = true;
        }
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "GlassmorphismManager is operational.",
            issues: [],
            system: "GlassmorphismManager"
          };
        }
        updateAnimation(deltaTime) {
        }
        destroy() {
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this.boundHandleSettingsChange
          );
          this.observers.forEach((observer) => observer.disconnect());
          this.observers = [];
          this.initialized = false;
        }
        handleSettingsChange(event) {
          const customEvent = event;
          const { key, value } = customEvent.detail || {};
          if (key === GLASS_LEVEL_KEY || key === GLASS_LEVEL_OLD_KEY) {
            this.applyGlassmorphismSettings(value);
          }
        }
        detectBackdropFilterSupport() {
          try {
            return CSS.supports("backdrop-filter", "blur(1px)") || CSS.supports("-webkit-backdrop-filter", "blur(1px)");
          } catch (error) {
            console.warn(
              "StarryNight: CSS.supports not available, assuming no backdrop-filter support",
              error
            );
            return false;
          }
        }
        applyGlassmorphismSettings(intensity) {
          const body = document.body;
          body.classList.remove(
            "sn-glass-disabled",
            "sn-glass-minimal",
            "sn-glass-balanced",
            "sn-glass-intense"
          );
          body.classList.add(`sn-glass-${intensity}`);
          this.currentIntensity = intensity;
          this.updateGlassVariables(intensity);
        }
        updateGlassVariables(intensity) {
          const root = document.documentElement;
          const shouldReduceQuality = this.performanceAnalyzer?.shouldReduceQuality() || false;
          let blurValue, opacityValue, saturationValue;
          switch (intensity) {
            case "disabled":
              root.style.removeProperty("--glass-blur");
              root.style.removeProperty("--glass-opacity");
              root.style.removeProperty("--glass-saturation");
              return;
            case "minimal":
              blurValue = shouldReduceQuality ? "2px" : "3px";
              opacityValue = "0.05";
              saturationValue = "1.05";
              break;
            case "intense":
              blurValue = shouldReduceQuality ? "6px" : "8px";
              opacityValue = "0.15";
              saturationValue = "1.4";
              break;
            case "balanced":
            default:
              blurValue = shouldReduceQuality ? "4px" : "6px";
              opacityValue = "0.1";
              saturationValue = "1.2";
              break;
          }
          root.style.setProperty("--glass-blur", blurValue);
          root.style.setProperty("--glass-opacity", opacityValue);
          root.style.setProperty("--glass-saturation", saturationValue);
        }
        updateGlassColors(primaryColor, secondaryColor) {
          if (this.currentIntensity === "disabled") return;
          const root = document.documentElement;
          const glassPrimary = this.convertToGlassColor(primaryColor, 0.1);
          const glassSecondary = this.convertToGlassColor(secondaryColor, 0.08);
          root.style.setProperty("--glass-background", glassPrimary);
          root.style.setProperty("--glass-border", glassSecondary);
        }
        convertToGlassColor(color, opacity) {
          try {
            if (typeof color !== "string") return `rgba(255, 255, 255, ${opacity})`;
            if (color.startsWith("rgb")) {
              const values = color.match(/\d+/g);
              if (values && values.length >= 3) {
                return `rgba(${values[0]}, ${values[1]}, ${values[2]}, ${opacity})`;
              }
            }
            if (color.startsWith("#")) {
              const hex = color.slice(1);
              const r = parseInt(hex.substring(0, 2), 16);
              const g2 = parseInt(hex.substring(2, 4), 16);
              const b = parseInt(hex.substring(4, 6), 16);
              if (!isNaN(r) && !isNaN(g2) && !isNaN(b)) {
                return `rgba(${r}, ${g2}, ${b}, ${opacity})`;
              }
            }
            return `rgba(255, 255, 255, ${opacity})`;
          } catch (error) {
            return `rgba(255, 255, 255, ${opacity})`;
          }
        }
        checkPerformanceAndAdjust() {
          if (this.performanceAnalyzer?.shouldReduceQuality() || false) {
            if (this.currentIntensity === "intense") {
              this.applyGlassmorphismSettings("balanced");
            } else if (this.currentIntensity === "balanced" || this.currentIntensity === "moderate") {
              this.applyGlassmorphismSettings("minimal");
            }
          }
        }
        applyGlassmorphism(level) {
          const glassConfig = this.config.glassmorphism[level];
          if (!this.cssBatcher) return;
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-display",
            level === "disabled" ? "none" : "block"
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-blur",
            `${glassConfig.blur}px`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-saturation",
            `${glassConfig.saturation}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-brightness",
            `${glassConfig.brightness}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-noise-opacity",
            `${glassConfig.noiseOpacity}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-border-opacity",
            `${glassConfig.borderOpacity}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-shadow-opacity",
            `${glassConfig.shadowOpacity}`
          );
          this.cssBatcher.flushCSSVariableBatch();
          if (this.config.enableDebug) {
            console.log(`\u{1F48E} [GlassmorphismManager] Applied level: ${level}`);
          }
        }
        // --------------------------------------------------------------------
        // Year3000System central settings broadcast hook
        // --------------------------------------------------------------------
        applyUpdatedSettings(key, value) {
          if (key === "sn-glassmorphism-level") {
            this.applyGlassmorphismSettings(value);
          }
        }
      };
      __name(_GlassmorphismManager, "GlassmorphismManager");
      GlassmorphismManager = _GlassmorphismManager;
    }
  });

  // src-js/ui/managers/Card3DManager.ts
  var _Card3DManager, Card3DManager;
  var init_Card3DManager = __esm({
    "src-js/ui/managers/Card3DManager.ts"() {
      "use strict";
      init_settingKeys();
      _Card3DManager = class _Card3DManager {
        constructor(performanceMonitor, settingsManager, utils) {
          this.initialized = false;
          this.cardQuerySelector = ".main-card-card, .main-gridContainer-gridContainer.main-gridContainer-fixedWidth";
          this.cardEventHandlers = /* @__PURE__ */ new WeakMap();
          this.config = {
            perspective: 1e3,
            maxRotation: 5,
            scale: 1.02,
            transitionSpeed: "200ms",
            glowOpacity: 0.8,
            selector: ".main-card-card, .main-grid-grid > *, .main-shelf-shelf > * > *"
          };
          this.performanceMonitor = performanceMonitor;
          this.settingsManager = settingsManager;
          this.utils = utils;
          this.cards = document.querySelectorAll(this.config.selector);
          this.boundHandleSettingsChange = this.handleSettingsChange.bind(this);
        }
        static getInstance(performanceMonitor, settingsManager, utils) {
          if (!_Card3DManager.instance) {
            _Card3DManager.instance = new _Card3DManager(
              performanceMonitor,
              settingsManager,
              utils
            );
          }
          return _Card3DManager.instance;
        }
        async initialize() {
          if (this.initialized) return;
          const quality = this.performanceMonitor.shouldReduceQuality();
          if (quality) {
            if (this.settingsManager.get("sn-3d-effects-level") !== "disabled") {
              console.log(
                `[Card3DManager] Performance is low. 3D effects disabled. Current quality: ${quality}`
              );
              return;
            }
          }
          this.cards = document.querySelectorAll(this.config.selector);
          await this.applyEventListeners();
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this.boundHandleSettingsChange
          );
          this.initialized = true;
        }
        async healthCheck() {
          const elements = document.querySelectorAll(this.cardQuerySelector);
          if (elements.length > 0) {
            return {
              healthy: true,
              ok: true,
              details: `Found ${elements.length} cards to manage.`,
              issues: [],
              system: "Card3DManager"
            };
          }
          return {
            healthy: false,
            ok: false,
            details: "No card elements found with the configured selector.",
            issues: ["No card elements found with the configured selector."],
            system: "Card3DManager"
          };
        }
        updateAnimation(deltaTime) {
        }
        apply3DMode(mode) {
          console.log(`[Card3DManager] Applying 3D mode: ${mode}`);
          if (mode === "disabled") {
            this.destroy();
          } else {
            this.initialize();
          }
        }
        get shouldEnable3DEffects() {
          const quality = this.performanceMonitor.shouldReduceQuality();
          const setting = this.settingsManager.get("sn-enable3dCards");
          return !quality && setting !== "disabled";
        }
        async applyEventListeners() {
          this.cards.forEach((card) => {
            if (this.cardEventHandlers.has(card)) return;
            const moveHandler = /* @__PURE__ */ __name((e) => this.handleMouseMove(card, e), "moveHandler");
            const leaveHandler = /* @__PURE__ */ __name(() => this.handleMouseLeave(card), "leaveHandler");
            this.cardEventHandlers.set(card, {
              move: moveHandler,
              leave: leaveHandler
            });
            card.addEventListener("mousemove", moveHandler);
            card.addEventListener("mouseleave", leaveHandler);
          });
        }
        handleMouseMove(card, e) {
          if (!this.shouldEnable3DEffects) return;
          const { clientX, clientY } = e;
          const { top, left, width, height } = card.getBoundingClientRect();
          const x = clientX - left;
          const y = clientY - top;
          const rotateX = this.config.maxRotation * (y - height / 2) / (height / 2);
          const rotateY = -this.config.maxRotation * (x - width / 2) / (width / 2);
          card.style.transform = `perspective(${this.config.perspective}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale3d(${this.config.scale}, ${this.config.scale}, ${this.config.scale})`;
          card.style.transition = `transform ${this.config.transitionSpeed} ease-out`;
          this.applyGlow(card, x, y, width, height);
        }
        handleMouseLeave(card) {
          card.style.transform = "perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)";
          card.style.transition = "transform 600ms ease-in-out";
          this.removeGlow(card);
        }
        applyGlow(card, x, y, width, height) {
          let glowElement = card.querySelector(".card-glow");
          if (!glowElement) {
            glowElement = document.createElement("div");
            glowElement.className = "card-glow";
            card.appendChild(glowElement);
          }
          glowElement.style.background = `radial-gradient(circle at ${x}px ${y}px, rgba(var(--spice-rgb-button), ${this.config.glowOpacity}) 0%, transparent 40%)`;
        }
        removeGlow(card) {
          const glowElement = card.querySelector(".card-glow");
          if (glowElement) {
            glowElement.style.background = "transparent";
          }
        }
        destroy() {
          this.cards.forEach((card) => {
            const handlers = this.cardEventHandlers.get(card);
            if (handlers) {
              card.removeEventListener("mousemove", handlers.move);
              card.removeEventListener("mouseleave", handlers.leave);
              this.cardEventHandlers.delete(card);
            }
            this.removeGlow(card);
            card.style.transform = "";
            card.style.transition = "";
          });
          this.initialized = false;
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this.boundHandleSettingsChange
          );
        }
        handleSettingsChange(event) {
          const { key, value } = event.detail || {};
          if (key === CARD_3D_LEVEL_KEY) {
            this.apply3DMode(value);
          }
        }
      };
      __name(_Card3DManager, "Card3DManager");
      Card3DManager = _Card3DManager;
    }
  });

  // src-js/visual/ui-effects/SidebarDimensionalNexusSystem.ts
  var _SidebarDimensionalNexusSystem, SidebarDimensionalNexusSystem;
  var init_SidebarDimensionalNexusSystem = __esm({
    "src-js/visual/ui-effects/SidebarDimensionalNexusSystem.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_globalConfig();
      _SidebarDimensionalNexusSystem = class _SidebarDimensionalNexusSystem extends UnifiedSystemBase {
        constructor(config = YEAR3000_CONFIG) {
          super(config);
          this.spatialLayers = /* @__PURE__ */ new Map();
          this.navigationElements = /* @__PURE__ */ new Map();
          // 3D Transform management
          this.currentTransform = {
            translateX: 0,
            translateY: 0,
            translateZ: 0,
            rotateX: 0,
            rotateY: 0,
            rotateZ: 0,
            scaleX: 1,
            scaleY: 1,
            scaleZ: 1
          };
          this.targetTransform = { ...this.currentTransform };
          // Spatial navigation parameters
          this.DEPTH_LAYERS = 5;
          this.LAYER_SPACING = 50;
          // pixels
          this.PARALLAX_FACTOR = 0.3;
          this.GESTURE_SENSITIVITY = 1.2;
          this.PREDICTION_THRESHOLD = 0.7;
          // Animation and interpolation
          this.SPATIAL_LERP = 0.08;
          // Smooth spatial transitions
          this.FOCUS_LERP = 0.15;
          // Focus transitions
          this.DEPTH_LERP = 0.12;
          // Depth transitions
          // Performance optimization
          this.intersectionObserver = null;
          this.spatialAnimationFrame = null;
          this.lastSpatialUpdate = 0;
          // Gesture handling
          this.gestureState = {
            active: false,
            startTime: 0,
            currentGesture: null,
            momentum: { x: 0, y: 0, z: 0 }
          };
          // Music integration
          this.musicIntensity = 0;
          this.musicEnergy = 0;
          this.spatialState = {
            currentDepth: 0,
            focusedLayer: null,
            spatialMode: "layered",
            navigationVelocity: { x: 0, y: 0, z: 0 },
            userGazeDirection: { x: 0, y: 0 },
            predictiveElements: []
          };
          if (config.enableDebug) {
            console.log(`[${this.systemName}] Initialized dimensional nexus system`);
          }
        }
        /**
         * Initialize the dimensional nexus system
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing dimensional nexus`);
          }
          await this.initializeSpatialLayers();
          await this.initializeNavigationElements();
          this.setupGestureHandling();
          this.setupViewportOptimization();
          this.subscribeToEvent("music:beat", (payload) => {
            this.musicIntensity = payload.intensity;
            this.updateMusicSpatialEffects();
          });
          this.subscribeToEvent("music:energy", (payload) => {
            this.musicEnergy = payload.energy;
            this.updateMusicSpatialEffects();
          });
          this.subscribeToEvent("sidebar:bilateral-beat", (payload) => {
            this.handleBilateralSpatialSync(payload);
          });
          this.registerAnimation(55);
          this.initializeCSSTransforms();
          this.publishEvent("sidebar:dimensional-nexus-ready", {
            systemName: this.systemName,
            depthLayers: this.DEPTH_LAYERS,
            spatialMode: this.spatialState.spatialMode,
            timestamp: Date.now()
          });
        }
        /**
         * Initialize spatial layers for 3D navigation
         */
        async initializeSpatialLayers() {
          for (let i = 0; i < this.DEPTH_LAYERS; i++) {
            const layerId = `layer-${i}`;
            const depth = i * this.LAYER_SPACING;
            const layer = {
              id: layerId,
              depth,
              elements: [],
              transform: this.calculateLayerTransform(depth),
              visibility: this.calculateLayerVisibility(depth)
            };
            this.spatialLayers.set(layerId, layer);
            this.updateCSSVariables({
              [`--sn-spatial-layer-${i}-depth`]: `${depth}px`,
              [`--sn-spatial-layer-${i}-visibility`]: layer.visibility.toFixed(2),
              [`--sn-spatial-layer-${i}-transform`]: this.transformToCSS(layer.transform)
            });
          }
        }
        /**
         * Initialize navigation elements with spatial positioning
         */
        async initializeNavigationElements() {
          const mockElements = [
            { id: "home", type: "folder", weight: 0.9 },
            { id: "search", type: "folder", weight: 0.8 },
            { id: "library", type: "folder", weight: 0.95 },
            { id: "playlists", type: "playlist", weight: 0.85 },
            { id: "artists", type: "artist", weight: 0.7 },
            { id: "albums", type: "album", weight: 0.6 },
            { id: "podcasts", type: "folder", weight: 0.4 }
          ];
          mockElements.forEach((element, index) => {
            const spatialPosition = this.calculateSpatialPosition(index, element.weight);
            const layerIndex = Math.floor(index / 2);
            const navElement = {
              id: element.id,
              type: element.type,
              spatialPosition,
              contextualWeight: element.weight,
              interactionHistory: [],
              predictedRelevance: element.weight
            };
            this.navigationElements.set(element.id, navElement);
            const layerId = `layer-${layerIndex}`;
            const layer = this.spatialLayers.get(layerId);
            if (layer) {
              layer.elements.push(navElement);
            }
          });
        }
        /**
         * Calculate spatial position for an element
         */
        calculateSpatialPosition(index, weight) {
          const angle = index * 60 * (Math.PI / 180);
          const radius = 20 + (1 - weight) * 30;
          return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: index * 10,
            // Depth based on index
            rotation: angle * (180 / Math.PI),
            // Convert back to degrees
            scale: 0.8 + weight * 0.4
            // Scale based on weight
          };
        }
        /**
         * Set up gesture handling for dimensional navigation
         */
        setupGestureHandling() {
          this.subscribeToEvent("sidebar:gesture", (payload) => {
            this.handleGesture(payload);
          });
          if (this.config.enableDebug) {
            setInterval(() => {
              this.simulateGesture();
            }, 5e3);
          }
        }
        /**
         * Handle gesture events for spatial navigation
         */
        handleGesture(gesture) {
          this.gestureState.active = true;
          this.gestureState.currentGesture = gesture;
          switch (gesture.type) {
            case "swipe":
              this.handleSwipeGesture(gesture);
              break;
            case "pinch":
              this.handlePinchGesture(gesture);
              break;
            case "rotate":
              this.handleRotateGesture(gesture);
              break;
            case "pan":
              this.handlePanGesture(gesture);
              break;
          }
          this.updateSpatialNavigationState();
        }
        /**
         * Handle swipe gestures for layer navigation
         */
        handleSwipeGesture(gesture) {
          const direction = gesture.direction;
          const intensity = gesture.intensity * this.GESTURE_SENSITIVITY;
          switch (direction) {
            case "up":
              this.navigateToDepth(this.spatialState.currentDepth - 1);
              break;
            case "down":
              this.navigateToDepth(this.spatialState.currentDepth + 1);
              break;
            case "left":
              this.rotateSpatialView(-30 * intensity);
              break;
            case "right":
              this.rotateSpatialView(30 * intensity);
              break;
          }
        }
        /**
         * Handle pinch gestures for spatial zoom
         */
        handlePinchGesture(gesture) {
          const scaleChange = 1 + (gesture.intensity - 0.5) * 0.5;
          this.targetTransform.scaleX *= scaleChange;
          this.targetTransform.scaleY *= scaleChange;
          this.targetTransform.scaleZ *= scaleChange;
          this.targetTransform.scaleX = Math.max(0.5, Math.min(2, this.targetTransform.scaleX));
          this.targetTransform.scaleY = Math.max(0.5, Math.min(2, this.targetTransform.scaleY));
          this.targetTransform.scaleZ = Math.max(0.5, Math.min(2, this.targetTransform.scaleZ));
        }
        /**
         * Handle rotation gestures for 3D spatial rotation
         */
        handleRotateGesture(gesture) {
          const rotationAmount = gesture.intensity * 45;
          this.targetTransform.rotateY += rotationAmount;
          this.targetTransform.rotateX += rotationAmount * 0.5;
          this.targetTransform.rotateY = this.targetTransform.rotateY % 360;
          this.targetTransform.rotateX = this.targetTransform.rotateX % 360;
        }
        /**
         * Handle pan gestures for spatial translation
         */
        handlePanGesture(gesture) {
          const deltaX = gesture.currentPosition.x - gesture.startPosition.x;
          const deltaY = gesture.currentPosition.y - gesture.startPosition.y;
          this.targetTransform.translateX += deltaX * 0.5;
          this.targetTransform.translateY += deltaY * 0.5;
          this.targetTransform.translateX = Math.max(-200, Math.min(200, this.targetTransform.translateX));
          this.targetTransform.translateY = Math.max(-200, Math.min(200, this.targetTransform.translateY));
        }
        /**
         * Navigate to specific depth layer
         */
        navigateToDepth(targetDepth) {
          const clampedDepth = Math.max(0, Math.min(this.DEPTH_LAYERS - 1, targetDepth));
          if (clampedDepth !== this.spatialState.currentDepth) {
            this.spatialState.currentDepth = clampedDepth;
            this.spatialState.focusedLayer = `layer-${clampedDepth}`;
            this.targetTransform.translateZ = -clampedDepth * this.LAYER_SPACING;
            this.updateLayerVisibility();
            this.publishEvent("sidebar:spatial-depth-changed", {
              previousDepth: this.spatialState.currentDepth,
              newDepth: clampedDepth,
              focusedLayer: this.spatialState.focusedLayer,
              timestamp: Date.now()
            });
          }
        }
        /**
         * Rotate spatial view
         */
        rotateSpatialView(angle) {
          this.targetTransform.rotateY += angle;
          this.targetTransform.rotateY = this.targetTransform.rotateY % 360;
        }
        /**
         * Update spatial navigation state
         */
        updateSpatialNavigationState() {
          const currentGesture = this.gestureState.currentGesture;
          if (currentGesture) {
            this.spatialState.navigationVelocity = {
              x: currentGesture.velocity * 0.1,
              y: currentGesture.velocity * 0.1,
              z: 0
            };
          }
          this.spatialState.userGazeDirection = {
            x: this.targetTransform.rotateY / 360,
            y: this.targetTransform.rotateX / 360
          };
          this.updatePredictiveElements();
        }
        /**
         * Update predictive elements based on user behavior
         */
        updatePredictiveElements() {
          const predictiveElements = [];
          for (const [, element] of this.navigationElements) {
            const relevanceScore = this.calculateRelevanceScore(element);
            if (relevanceScore > this.PREDICTION_THRESHOLD) {
              element.predictedRelevance = relevanceScore;
              predictiveElements.push(element);
            }
          }
          this.spatialState.predictiveElements = predictiveElements.sort((a, b) => b.predictedRelevance - a.predictedRelevance).slice(0, 5);
        }
        /**
         * Calculate relevance score for predictive positioning
         */
        calculateRelevanceScore(element) {
          let score = element.contextualWeight;
          const distanceFromView = Math.sqrt(
            Math.pow(element.spatialPosition.x - this.spatialState.userGazeDirection.x * 100, 2) + Math.pow(element.spatialPosition.y - this.spatialState.userGazeDirection.y * 100, 2)
          );
          const proximityBoost = Math.max(0, 1 - distanceFromView / 100);
          score += proximityBoost * 0.3;
          const recentInteractions = element.interactionHistory.filter(
            (interaction) => Date.now() - interaction.timestamp < 3e5
            // 5 minutes
          );
          const interactionBoost = Math.min(recentInteractions.length * 0.1, 0.4);
          score += interactionBoost;
          return Math.min(score, 1);
        }
        /**
         * Set up viewport optimization using Intersection Observer
         */
        setupViewportOptimization() {
          if (typeof IntersectionObserver !== "undefined") {
            this.intersectionObserver = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  const layerId = entry.target.getAttribute("data-layer-id");
                  if (layerId) {
                    const layer = this.spatialLayers.get(layerId);
                    if (layer) {
                      layer.visibility = entry.isIntersecting ? 1 : 0;
                    }
                  }
                });
              },
              {
                threshold: [0, 0.1, 0.5, 0.9, 1]
              }
            );
          }
        }
        /**
         * Update layer visibility based on current depth
         */
        updateLayerVisibility() {
          for (const [layerId, layer] of this.spatialLayers) {
            const layerIndex = parseInt(layerId.split("-")[1] || "0", 10);
            const distance2 = Math.abs(layerIndex - this.spatialState.currentDepth);
            layer.visibility = Math.max(0, 1 - distance2 * 0.3);
            this.updateCSSVariable(
              `--sn-spatial-layer-${layerIndex}-visibility`,
              layer.visibility.toFixed(2)
            );
          }
        }
        /**
         * Update music-responsive spatial effects
         */
        updateMusicSpatialEffects() {
          const breathingScale = 1 + this.musicIntensity * 0.05;
          const energyRotation = this.musicEnergy * 2;
          for (let i = 0; i < this.DEPTH_LAYERS; i++) {
            this.updateCSSVariables({
              [`--sn-spatial-layer-${i}-breathing`]: breathingScale.toFixed(3),
              [`--sn-spatial-layer-${i}-energy-rotation`]: `${energyRotation.toFixed(1)}deg`
            });
          }
        }
        /**
         * Handle bilateral spatial synchronization
         */
        handleBilateralSpatialSync(payload) {
          if (payload.source === "left") {
            const consciousnessBoost = payload.intensity * 0.1;
            this.targetTransform.translateZ += consciousnessBoost * 10;
            this.targetTransform.rotateY += consciousnessBoost * 5;
          }
        }
        /**
         * Initialize CSS 3D transforms
         */
        initializeCSSTransforms() {
          this.updateCSSVariables({
            "--sn-spatial-perspective": "1000px",
            "--sn-spatial-transform-style": "preserve-3d",
            "--sn-spatial-backface-visibility": "hidden"
          });
          this.updateSpatialTransforms();
        }
        /**
         * Update spatial transforms
         */
        updateSpatialTransforms() {
          this.currentTransform.translateX = this.lerp(
            this.currentTransform.translateX,
            this.targetTransform.translateX,
            this.SPATIAL_LERP
          );
          this.currentTransform.translateY = this.lerp(
            this.currentTransform.translateY,
            this.targetTransform.translateY,
            this.SPATIAL_LERP
          );
          this.currentTransform.translateZ = this.lerp(
            this.currentTransform.translateZ,
            this.targetTransform.translateZ,
            this.DEPTH_LERP
          );
          this.currentTransform.rotateX = this.lerp(
            this.currentTransform.rotateX,
            this.targetTransform.rotateX,
            this.SPATIAL_LERP
          );
          this.currentTransform.rotateY = this.lerp(
            this.currentTransform.rotateY,
            this.targetTransform.rotateY,
            this.SPATIAL_LERP
          );
          this.currentTransform.rotateZ = this.lerp(
            this.currentTransform.rotateZ,
            this.targetTransform.rotateZ,
            this.SPATIAL_LERP
          );
          this.currentTransform.scaleX = this.lerp(
            this.currentTransform.scaleX,
            this.targetTransform.scaleX,
            this.FOCUS_LERP
          );
          this.currentTransform.scaleY = this.lerp(
            this.currentTransform.scaleY,
            this.targetTransform.scaleY,
            this.FOCUS_LERP
          );
          this.currentTransform.scaleZ = this.lerp(
            this.currentTransform.scaleZ,
            this.targetTransform.scaleZ,
            this.FOCUS_LERP
          );
          this.updateCSSVariable("--sn-spatial-transform", this.transformToCSS(this.currentTransform));
        }
        /**
         * Calculate layer transform
         */
        calculateLayerTransform(depth) {
          return {
            translateX: 0,
            translateY: 0,
            translateZ: -depth,
            rotateX: 0,
            rotateY: 0,
            rotateZ: 0,
            scaleX: 1,
            scaleY: 1,
            scaleZ: 1
          };
        }
        /**
         * Calculate layer visibility
         */
        calculateLayerVisibility(depth) {
          return Math.max(0, 1 - depth / (this.DEPTH_LAYERS * this.LAYER_SPACING));
        }
        /**
         * Convert transform object to CSS string
         */
        transformToCSS(transform) {
          return `
      translate3d(${transform.translateX}px, ${transform.translateY}px, ${transform.translateZ}px)
      rotateX(${transform.rotateX}deg)
      rotateY(${transform.rotateY}deg)
      rotateZ(${transform.rotateZ}deg)
      scale3d(${transform.scaleX}, ${transform.scaleY}, ${transform.scaleZ})
    `.replace(/\s+/g, " ").trim();
        }
        /**
         * Linear interpolation helper
         */
        lerp(from, to, alpha) {
          return from + (to - from) * alpha;
        }
        /**
         * Simulate gesture for testing
         */
        simulateGesture() {
          if (!this.config.enableDebug) return;
          const gestures = [
            {
              type: "swipe",
              direction: "up",
              intensity: 0.6,
              velocity: 50,
              startPosition: { x: 0, y: 0 },
              currentPosition: { x: 0, y: -50 },
              deltaTime: 200
            },
            {
              type: "pinch",
              intensity: 0.8,
              velocity: 30,
              startPosition: { x: 0, y: 0 },
              currentPosition: { x: 0, y: 0 },
              deltaTime: 300
            }
          ];
          const randomGesture = gestures[Math.floor(Math.random() * gestures.length)];
          if (randomGesture) {
            this.handleGesture(randomGesture);
          }
        }
        /**
         * Animation frame callback
         */
        onAnimate(deltaTime) {
          this.lastSpatialUpdate = performance.now();
          this.updateSpatialTransforms();
          this.updateLayerVisibility();
          this.updateMusicSpatialEffects();
          this.spatialState.navigationVelocity.x *= 0.95;
          this.spatialState.navigationVelocity.y *= 0.95;
          this.spatialState.navigationVelocity.z *= 0.95;
          this.updatePredictiveElements();
        }
        /**
         * Get current spatial state
         */
        getSpatialState() {
          return { ...this.spatialState };
        }
        /**
         * Get current spatial layers
         */
        getSpatialLayers() {
          return new Map(this.spatialLayers);
        }
        /**
         * Get navigation elements
         */
        getNavigationElements() {
          return new Map(this.navigationElements);
        }
        /**
         * System health check
         */
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: `Dimensional nexus system healthy - ${this.spatialLayers.size} layers, ${this.navigationElements.size} elements, depth ${this.spatialState.currentDepth}`,
            issues: [],
            system: "SidebarDimensionalNexusSystem"
          };
        }
        /**
         * Clean up resources
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying dimensional nexus`);
          }
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            this.intersectionObserver = null;
          }
          if (this.spatialAnimationFrame) {
            cancelAnimationFrame(this.spatialAnimationFrame);
            this.spatialAnimationFrame = null;
          }
          this.spatialLayers.clear();
          this.navigationElements.clear();
          this.spatialState = {
            currentDepth: 0,
            focusedLayer: null,
            spatialMode: "flat",
            navigationVelocity: { x: 0, y: 0, z: 0 },
            userGazeDirection: { x: 0, y: 0 },
            predictiveElements: []
          };
          this.publishEvent("sidebar:dimensional-nexus-destroyed", {
            timestamp: Date.now()
          });
        }
      };
      __name(_SidebarDimensionalNexusSystem, "SidebarDimensionalNexusSystem");
      SidebarDimensionalNexusSystem = _SidebarDimensionalNexusSystem;
    }
  });

  // src-js/visual/ui-effects/SidebarInteractiveFlowSystem.ts
  var _SidebarInteractiveFlowSystem, SidebarInteractiveFlowSystem;
  var init_SidebarInteractiveFlowSystem = __esm({
    "src-js/visual/ui-effects/SidebarInteractiveFlowSystem.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_globalConfig();
      _SidebarInteractiveFlowSystem = class _SidebarInteractiveFlowSystem extends UnifiedSystemBase {
        constructor(config = YEAR3000_CONFIG) {
          super(config);
          this.interactionPatterns = /* @__PURE__ */ new Map();
          // Performance optimization
          this.proximityObserver = null;
          this.interactionElements = /* @__PURE__ */ new Map();
          this.activeDisturbances = [];
          // Animation state
          this.animationPhase = 0;
          this.lastUpdateTime = 0;
          // Note: frameCount is inherited from UnifiedSystemBase, using localFrameCount instead
          this.localFrameCount = 0;
          // Music integration
          this.musicBeatIntensity = 0;
          this.musicEnergyLevel = 0;
          // Proximity tracking
          this.cursorPosition = { x: 0, y: 0 };
          this.cursorVelocity = { x: 0, y: 0 };
          this.lastCursorUpdate = 0;
          // Performance parameters
          this.MAX_FLOW_VECTORS = 50;
          this.DISTURBANCE_DECAY_RATE = 0.05;
          this.PROXIMITY_THRESHOLD = 100;
          // pixels
          this.INTERACTION_COOLDOWN = 16;
          // ms (~60fps)
          // Flow dynamics
          this.FLOW_LERP = 0.08;
          this.VISCOSITY_LERP = 0.12;
          this.INTENSITY_LERP = 0.15;
          this.flowState = {
            direction: "radial",
            intensity: 0.3,
            velocity: 50,
            viscosity: 0.7,
            flowField: []
          };
          this.liquidConsciousnessState = {
            globalFlowIntensity: 0,
            dominantFlowDirection: 0,
            interactionCount: 0,
            lastInteractionTime: 0,
            proximityElements: []
          };
          this.initializeFlowField();
          if (config.enableDebug) {
            console.log(`[${this.systemName}] Initialized liquid consciousness flow system`);
          }
        }
        /**
         * Initialize the interactive flow system
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing liquid consciousness interactions`);
          }
          this.initializeInteractionPatterns();
          this.setupProximityDetection();
          this.setupCursorTracking();
          this.subscribeToEvent("music:beat", (payload) => {
            this.musicBeatIntensity = payload.intensity;
            this.updateMusicFlowEffects();
          });
          this.subscribeToEvent("music:energy", (payload) => {
            this.musicEnergyLevel = payload.energy;
            this.updateMusicFlowEffects();
          });
          this.subscribeToEvent("sidebar:bilateral-beat", (payload) => {
            this.handleBilateralFlowSync(payload);
          });
          this.subscribeToEvent("sidebar:consciousness-level-changed", (payload) => {
            this.handleConsciousnessFlowChange(payload);
          });
          this.subscribeToEvent("sidebar:interaction", (payload) => {
            this.handleInteractionTrigger(payload);
          });
          this.registerAnimation(50);
          this.initializeFlowCSSVariables();
          this.publishEvent("sidebar:interactive-flow-ready", {
            systemName: this.systemName,
            flowPatterns: this.interactionPatterns.size,
            proximityThreshold: this.PROXIMITY_THRESHOLD,
            timestamp: Date.now()
          });
        }
        /**
         * Initialize flow field with vectors
         */
        initializeFlowField() {
          this.flowState.flowField = [];
          const gridSize = 8;
          const spacing = 20;
          for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
              const vector = {
                x: x * spacing,
                y: y * spacing,
                magnitude: 0.5 + Math.random() * 0.5,
                direction: Math.random() * Math.PI * 2,
                influence: 0.3 + Math.random() * 0.4
              };
              this.flowState.flowField.push(vector);
            }
          }
        }
        /**
         * Initialize interaction patterns
         */
        initializeInteractionPatterns() {
          this.interactionPatterns.set("hover", {
            id: "hover",
            type: "hover",
            response: {
              intensityChange: 0.2,
              velocityChange: 0.1,
              viscosityChange: -0.1,
              // Less viscous on hover
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                // Will be updated on interaction
                radius: 30,
                strength: 0.3,
                decay: 0.05,
                type: "wave"
              }],
              rippleEffect: false,
              // Performance-optimized
              glowEffect: true
            },
            duration: 300,
            easing: "liquid",
            priority: 3
          });
          this.interactionPatterns.set("click", {
            id: "click",
            type: "click",
            response: {
              intensityChange: 0.5,
              velocityChange: 0.3,
              viscosityChange: -0.2,
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 50,
                strength: 0.7,
                decay: 0.08,
                type: "pulse"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 500,
            easing: "liquid",
            priority: 8
          });
          this.interactionPatterns.set("focus", {
            id: "focus",
            type: "focus",
            response: {
              intensityChange: 0.3,
              velocityChange: 0.05,
              viscosityChange: 0.1,
              // More viscous for focus
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 40,
                strength: 0.4,
                decay: 0.02,
                // Slower decay for sustained effect
                type: "spiral"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 1e3,
            easing: "liquid",
            priority: 6
          });
          this.interactionPatterns.set("proximity", {
            id: "proximity",
            type: "proximity",
            response: {
              intensityChange: 0.1,
              velocityChange: 0.05,
              viscosityChange: -0.05,
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 20,
                strength: 0.2,
                decay: 0.03,
                type: "wave"
              }],
              rippleEffect: false,
              glowEffect: false
            },
            duration: 200,
            easing: "liquid",
            priority: 2
          });
          this.interactionPatterns.set("gesture", {
            id: "gesture",
            type: "gesture",
            response: {
              intensityChange: 0.4,
              velocityChange: 0.2,
              viscosityChange: -0.15,
              flowFieldDisturbance: [{
                center: { x: 0, y: 0 },
                radius: 60,
                strength: 0.6,
                decay: 0.06,
                type: "vortex"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 400,
            easing: "liquid",
            priority: 7
          });
        }
        /**
         * Set up proximity detection using Intersection Observer
         */
        setupProximityDetection() {
          if (typeof IntersectionObserver !== "undefined") {
            this.proximityObserver = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  const element = entry.target;
                  const elementId = element.id || element.className;
                  if (entry.isIntersecting) {
                    this.interactionElements.set(elementId, element);
                    this.handleProximityEnter(element);
                  } else {
                    this.interactionElements.delete(elementId);
                    this.handleProximityExit(element);
                  }
                });
              },
              {
                threshold: [0, 0.1, 0.5, 1],
                rootMargin: `${this.PROXIMITY_THRESHOLD}px`
              }
            );
            this.observeSidebarElements();
          }
        }
        /**
         * Set up cursor tracking for proximity awareness
         */
        setupCursorTracking() {
          if (this.config.enableDebug) {
            setInterval(() => {
              this.simulateCursorMovement();
            }, 50);
          }
        }
        /**
         * Observe sidebar elements for proximity detection
         */
        observeSidebarElements() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Observing sidebar elements for proximity`);
          }
        }
        /**
         * Handle interaction trigger
         */
        handleInteractionTrigger(trigger) {
          const pattern = this.interactionPatterns.get(trigger.type);
          if (!pattern) return;
          const currentTime = Date.now();
          if (currentTime - this.liquidConsciousnessState.lastInteractionTime < this.INTERACTION_COOLDOWN) {
            return;
          }
          this.liquidConsciousnessState.lastInteractionTime = currentTime;
          this.liquidConsciousnessState.interactionCount++;
          this.applyFlowResponse(pattern.response, trigger.position);
          this.updateGlobalFlowState(pattern);
          this.publishEvent("sidebar:flow-interaction", {
            type: trigger.type,
            position: trigger.position,
            pattern: pattern.id,
            timestamp: currentTime
          });
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Flow interaction: ${trigger.type} at (${trigger.position.x}, ${trigger.position.y})`);
          }
        }
        /**
         * Apply flow response to the system
         */
        applyFlowResponse(response, position) {
          this.flowState.intensity = Math.max(0, Math.min(
            1,
            this.flowState.intensity + response.intensityChange
          ));
          this.flowState.velocity = Math.max(0, Math.min(
            200,
            this.flowState.velocity + response.velocityChange * 50
          ));
          this.flowState.viscosity = Math.max(0, Math.min(
            1,
            this.flowState.viscosity + response.viscosityChange
          ));
          response.flowFieldDisturbance.forEach((disturbance) => {
            const positionedDisturbance = {
              ...disturbance,
              center: position
            };
            this.activeDisturbances.push(positionedDisturbance);
          });
          if (this.activeDisturbances.length > 10) {
            this.activeDisturbances = this.activeDisturbances.slice(-10);
          }
        }
        /**
         * Update global flow state based on interaction pattern
         */
        updateGlobalFlowState(pattern) {
          const priorityWeight = pattern.priority / 10;
          this.liquidConsciousnessState.dominantFlowDirection = (this.liquidConsciousnessState.dominantFlowDirection + Math.random() * Math.PI * 2) * priorityWeight;
          this.liquidConsciousnessState.globalFlowIntensity = Math.max(0, Math.min(
            1,
            this.liquidConsciousnessState.globalFlowIntensity + pattern.response.intensityChange * 0.5
          ));
        }
        /**
         * Handle proximity enter
         */
        handleProximityEnter(element) {
          const rect = element.getBoundingClientRect();
          const center = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          };
          const distance2 = Math.sqrt(
            Math.pow(center.x - this.cursorPosition.x, 2) + Math.pow(center.y - this.cursorPosition.y, 2)
          );
          this.liquidConsciousnessState.proximityElements.push({
            element,
            distance: distance2,
            influence: Math.max(0, 1 - distance2 / this.PROXIMITY_THRESHOLD)
          });
          this.handleInteractionTrigger({
            type: "proximity",
            position: center,
            element,
            timestamp: Date.now(),
            proximityData: {
              distance: distance2,
              angle: Math.atan2(center.y - this.cursorPosition.y, center.x - this.cursorPosition.x),
              velocity: this.cursorVelocity,
              pressure: 0.5
            }
          });
        }
        /**
         * Handle proximity exit
         */
        handleProximityExit(element) {
          this.liquidConsciousnessState.proximityElements = this.liquidConsciousnessState.proximityElements.filter((item) => item.element !== element);
        }
        /**
         * Update music flow effects
         */
        updateMusicFlowEffects() {
          const musicFlowIntensity = this.musicBeatIntensity * 0.3;
          this.flowState.intensity = Math.max(this.flowState.intensity, musicFlowIntensity);
          const musicVelocityBoost = this.musicEnergyLevel * 30;
          this.flowState.velocity = Math.min(200, this.flowState.velocity + musicVelocityBoost);
          const musicViscosityAdjustment = (1 - this.musicEnergyLevel) * 0.2;
          this.flowState.viscosity = Math.max(0.1, this.flowState.viscosity - musicViscosityAdjustment);
          this.updateFlowFieldWithMusic();
        }
        /**
         * Update flow field with music influence
         */
        updateFlowFieldWithMusic() {
          const musicInfluence = this.musicBeatIntensity * 0.5;
          this.flowState.flowField.forEach((vector) => {
            vector.direction += (Math.random() - 0.5) * musicInfluence * 0.1;
            vector.magnitude = Math.max(0.1, Math.min(
              1,
              vector.magnitude + (this.musicEnergyLevel - 0.5) * 0.2
            ));
          });
        }
        /**
         * Handle bilateral flow synchronization
         */
        handleBilateralFlowSync(payload) {
          if (payload.source === "left") {
            const consciousnessFlow = payload.intensity * 0.2;
            this.flowState.intensity = Math.max(this.flowState.intensity, consciousnessFlow);
            const flowDirectionAdjustment = payload.intensity * 0.3;
            this.liquidConsciousnessState.dominantFlowDirection += flowDirectionAdjustment;
          }
        }
        /**
         * Handle consciousness flow changes
         */
        handleConsciousnessFlowChange(payload) {
          const consciousnessLevels = {
            dormant: 0.1,
            aware: 0.3,
            focused: 0.6,
            transcendent: 1
          };
          const targetIntensity = consciousnessLevels[payload.newLevel] || 0.3;
          this.flowState.intensity = this.lerp(this.flowState.intensity, targetIntensity, 0.1);
          const viscosityTarget = 0.8 - targetIntensity * 0.3;
          this.flowState.viscosity = this.lerp(this.flowState.viscosity, viscosityTarget, 0.05);
        }
        /**
         * Simulate cursor movement for testing
         */
        simulateCursorMovement() {
          if (!this.config.enableDebug) return;
          const currentTime = Date.now();
          const deltaTime = currentTime - this.lastCursorUpdate;
          const time = currentTime * 1e-3;
          const newX = 200 + Math.sin(time * 0.5) * 100;
          const newY = 300 + Math.cos(time * 0.3) * 80;
          if (this.lastCursorUpdate > 0) {
            this.cursorVelocity.x = (newX - this.cursorPosition.x) / deltaTime * 1e3;
            this.cursorVelocity.y = (newY - this.cursorPosition.y) / deltaTime * 1e3;
          }
          this.cursorPosition.x = newX;
          this.cursorPosition.y = newY;
          this.lastCursorUpdate = currentTime;
        }
        /**
         * Update flow field disturbances
         */
        updateFlowDisturbances() {
          this.activeDisturbances = this.activeDisturbances.filter((disturbance) => {
            disturbance.strength *= 1 - disturbance.decay;
            return disturbance.strength > 0.01;
          });
          this.activeDisturbances.forEach((disturbance) => {
            this.flowState.flowField.forEach((vector) => {
              const distance2 = Math.sqrt(
                Math.pow(vector.x - disturbance.center.x, 2) + Math.pow(vector.y - disturbance.center.y, 2)
              );
              if (distance2 < disturbance.radius) {
                const influence = disturbance.strength * (1 - distance2 / disturbance.radius);
                switch (disturbance.type) {
                  case "wave":
                    vector.magnitude += influence * 0.3;
                    break;
                  case "spiral":
                    vector.direction += influence * 0.5;
                    break;
                  case "pulse":
                    vector.magnitude += influence * 0.5;
                    vector.direction += influence * 0.2;
                    break;
                  case "vortex":
                    const angle = Math.atan2(
                      vector.y - disturbance.center.y,
                      vector.x - disturbance.center.x
                    );
                    vector.direction = angle + influence * Math.PI * 0.5;
                    break;
                }
              }
            });
          });
        }
        /**
         * Initialize flow CSS variables
         */
        initializeFlowCSSVariables() {
          this.updateCSSVariables({
            "--sn-flow-intensity": this.flowState.intensity.toFixed(3),
            "--sn-flow-velocity": `${this.flowState.velocity}px`,
            "--sn-flow-viscosity": this.flowState.viscosity.toFixed(3),
            "--sn-flow-direction": `${this.liquidConsciousnessState.dominantFlowDirection}rad`,
            "--sn-flow-global-intensity": this.liquidConsciousnessState.globalFlowIntensity.toFixed(3),
            "--sn-flow-interaction-count": this.liquidConsciousnessState.interactionCount.toString(),
            "--sn-flow-proximity-elements": this.liquidConsciousnessState.proximityElements.length.toString(),
            "--sn-flow-disturbances": this.activeDisturbances.length.toString(),
            "--sn-flow-music-beat": this.musicBeatIntensity.toFixed(3),
            "--sn-flow-music-energy": this.musicEnergyLevel.toFixed(3)
          });
        }
        /**
         * Update flow CSS variables
         */
        updateFlowCSSVariables() {
          this.updateCSSVariables({
            "--sn-flow-intensity": this.flowState.intensity.toFixed(3),
            "--sn-flow-velocity": `${this.flowState.velocity}px`,
            "--sn-flow-viscosity": this.flowState.viscosity.toFixed(3),
            "--sn-flow-direction": `${this.liquidConsciousnessState.dominantFlowDirection}rad`,
            "--sn-flow-global-intensity": this.liquidConsciousnessState.globalFlowIntensity.toFixed(3)
          });
        }
        /**
         * Linear interpolation helper
         */
        lerp(from, to, alpha) {
          return from + (to - from) * alpha;
        }
        /**
         * Animation frame callback
         */
        onAnimate(deltaTime) {
          this.lastUpdateTime = performance.now();
          this.animationPhase += deltaTime * 1e-3;
          this.localFrameCount++;
          this.updateFlowDisturbances();
          this.flowState.intensity = this.lerp(
            this.flowState.intensity,
            this.liquidConsciousnessState.globalFlowIntensity,
            this.INTENSITY_LERP
          );
          this.flowState.intensity *= 0.995;
          this.flowState.velocity *= 0.98;
          if (this.localFrameCount % 10 === 0) {
            this.updateFlowFieldNaturalTurbulence();
          }
          this.updateProximityElements();
          this.updateFlowCSSVariables();
          this.updateMusicFlowEffects();
        }
        /**
         * Update flow field with natural turbulence
         */
        updateFlowFieldNaturalTurbulence() {
          this.flowState.flowField.forEach((vector) => {
            vector.direction += (Math.random() - 0.5) * 0.02;
            vector.magnitude += (Math.random() - 0.5) * 0.01;
            vector.magnitude = Math.max(0.1, Math.min(1, vector.magnitude));
          });
        }
        /**
         * Update proximity elements
         */
        updateProximityElements() {
          this.liquidConsciousnessState.proximityElements.forEach((item) => {
            const rect = item.element.getBoundingClientRect();
            const center = {
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2
            };
            item.distance = Math.sqrt(
              Math.pow(center.x - this.cursorPosition.x, 2) + Math.pow(center.y - this.cursorPosition.y, 2)
            );
            item.influence = Math.max(0, 1 - item.distance / this.PROXIMITY_THRESHOLD);
          });
        }
        /**
         * Get current flow state
         */
        getFlowState() {
          return { ...this.flowState };
        }
        /**
         * Get liquid consciousness state
         */
        getLiquidConsciousnessState() {
          return { ...this.liquidConsciousnessState };
        }
        /**
         * Get active disturbances
         */
        getActiveDisturbances() {
          return [...this.activeDisturbances];
        }
        /**
         * System health check
         */
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: `Interactive flow system healthy - ${this.interactionPatterns.size} patterns, ${this.activeDisturbances.length} disturbances, ${this.liquidConsciousnessState.interactionCount} interactions`,
            issues: [],
            system: "SidebarInteractiveFlowSystem"
          };
        }
        /**
         * Clean up resources
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying liquid consciousness flow system`);
          }
          if (this.proximityObserver) {
            this.proximityObserver.disconnect();
            this.proximityObserver = null;
          }
          this.interactionPatterns.clear();
          this.interactionElements.clear();
          this.activeDisturbances = [];
          this.flowState = {
            direction: "radial",
            intensity: 0,
            velocity: 0,
            viscosity: 0.5,
            flowField: []
          };
          this.liquidConsciousnessState = {
            globalFlowIntensity: 0,
            dominantFlowDirection: 0,
            interactionCount: 0,
            lastInteractionTime: 0,
            proximityElements: []
          };
          this.publishEvent("sidebar:interactive-flow-destroyed", {
            timestamp: Date.now()
          });
        }
      };
      __name(_SidebarInteractiveFlowSystem, "SidebarInteractiveFlowSystem");
      SidebarInteractiveFlowSystem = _SidebarInteractiveFlowSystem;
    }
  });

  // src-js/core/performance/PerformanceBudgetManager.ts
  var _PerformanceBudgetManager, PerformanceBudgetManager;
  var init_PerformanceBudgetManager = __esm({
    "src-js/core/performance/PerformanceBudgetManager.ts"() {
      "use strict";
      _PerformanceBudgetManager = class _PerformanceBudgetManager {
        constructor(config = {}, performanceAnalyzer) {
          this.cssVariableBatcher = null;
          // Optimization state
          this.optimizationLevel = "none";
          this.disabledFeatures = /* @__PURE__ */ new Set();
          this.config = {
            budgets: {
              animationFrame: 16.67,
              // 60 FPS
              cssVariableUpdate: 2,
              domObservation: 5,
              audioAnalysis: 10,
              visualEffects: 8,
              userInteraction: 100
            },
            autoOptimize: {
              enabled: true,
              violationThreshold: 5,
              recoveryThreshold: 80
            },
            enableDebug: false,
            ...config
          };
          this.performanceAnalyzer = performanceAnalyzer;
          this.setupBudgetMonitoring();
        }
        static getInstance(config, performanceAnalyzer) {
          if (!_PerformanceBudgetManager.instance && performanceAnalyzer) {
            _PerformanceBudgetManager.instance = new _PerformanceBudgetManager(
              config,
              performanceAnalyzer
            );
          }
          return _PerformanceBudgetManager.instance;
        }
        /**
         * Register CSS Variable Batcher for optimization
         */
        registerCSSVariableBatcher(batcher) {
          this.cssVariableBatcher = batcher;
        }
        /**
         * Set up automatic budget monitoring and optimization
         */
        setupBudgetMonitoring() {
          if (!this.config.autoOptimize.enabled) return;
          setInterval(() => {
            this.checkBudgets();
          }, 5e3);
        }
        /**
         * Check budget violations and trigger optimizations
         */
        checkBudgets() {
          const violations = this.performanceAnalyzer.getBudgetViolations();
          const healthScore = this.performanceAnalyzer.calculateHealthScore();
          let totalViolations = 0;
          for (const [operation, count] of violations) {
            totalViolations += count;
            if (count >= this.config.autoOptimize.violationThreshold) {
              this.optimizeOperation(operation);
            }
          }
          if (totalViolations >= this.config.autoOptimize.violationThreshold * 2) {
            this.escalateOptimization();
          }
          if (healthScore >= this.config.autoOptimize.recoveryThreshold) {
            this.recoverOptimizations();
          }
        }
        /**
         * Optimize a specific operation that's violating budget
         */
        optimizeOperation(operation) {
          if (this.disabledFeatures.has(operation)) return;
          switch (operation) {
            case "cssVariableUpdate":
              this.optimizeCSSVariableUpdates();
              break;
            case "domObservation":
              this.optimizeDOMObservation();
              break;
            case "visualEffects":
              this.optimizeVisualEffects();
              break;
            case "audioAnalysis":
              this.optimizeAudioAnalysis();
              break;
          }
          this.disabledFeatures.add(operation);
          if (this.config.enableDebug) {
            console.log(`\u{1F3AF} [PerformanceBudgetManager] Optimized ${operation} due to budget violations`);
          }
        }
        /**
         * Optimize CSS variable updates
         */
        optimizeCSSVariableUpdates() {
          if (!this.cssVariableBatcher) return;
          this.cssVariableBatcher.updateConfig({
            batchIntervalMs: 32,
            // Reduce to 30 FPS
            maxBatchSize: 25
            // Smaller batches
          });
        }
        /**
         * Optimize DOM observation
         */
        optimizeDOMObservation() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-dom-observation", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Optimize visual effects
         */
        optimizeVisualEffects() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-visual-effects", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Optimize audio analysis
         */
        optimizeAudioAnalysis() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-audio-analysis", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Escalate optimization level
         */
        escalateOptimization() {
          if (this.optimizationLevel === "none") {
            this.optimizationLevel = "conservative";
          } else if (this.optimizationLevel === "conservative") {
            this.optimizationLevel = "aggressive";
          }
          if (this.config.enableDebug) {
            console.log(`\u{1F3AF} [PerformanceBudgetManager] Escalated to ${this.optimizationLevel} optimization`);
          }
        }
        /**
         * Recover from optimizations when performance improves
         */
        recoverOptimizations() {
          if (this.optimizationLevel === "none") return;
          this.disabledFeatures.clear();
          if (this.cssVariableBatcher) {
            this.cssVariableBatcher.updateConfig({
              batchIntervalMs: 16,
              maxBatchSize: 50
            });
          }
          document.dispatchEvent(new CustomEvent("year3000:recover-optimizations", {
            detail: { previousLevel: this.optimizationLevel }
          }));
          this.optimizationLevel = "none";
          if (this.config.enableDebug) {
            console.log("\u{1F3AF} [PerformanceBudgetManager] Recovered from optimizations");
          }
        }
        /**
         * Get current optimization status
         */
        getOptimizationStatus() {
          return {
            level: this.optimizationLevel,
            disabledFeatures: Array.from(this.disabledFeatures),
            budgetViolations: this.performanceAnalyzer.getBudgetViolations(),
            healthScore: this.performanceAnalyzer.calculateHealthScore()
          };
        }
        /**
         * Manually trigger optimization for testing
         */
        manualOptimize(operation) {
          this.optimizeOperation(operation);
        }
        /**
         * Manually recover from optimizations
         */
        manualRecover() {
          this.recoverOptimizations();
        }
        /**
         * Update performance budgets
         */
        updateBudgets(budgets) {
          this.config.budgets = { ...this.config.budgets, ...budgets };
          for (const [operation, budget] of Object.entries(budgets)) {
            this.performanceAnalyzer.updateBudget(operation, budget);
          }
        }
        /**
         * Destroy and cleanup
         */
        destroy() {
          this.disabledFeatures.clear();
          this.cssVariableBatcher = null;
          _PerformanceBudgetManager.instance = null;
        }
      };
      __name(_PerformanceBudgetManager, "PerformanceBudgetManager");
      _PerformanceBudgetManager.instance = null;
      PerformanceBudgetManager = _PerformanceBudgetManager;
    }
  });

  // src-js/utils/dom/domCache.ts
  function $$(selector, options = {}) {
    if (!SUPPORTS_WEAKREF) {
      return Array.from(document.querySelectorAll(selector));
    }
    let entry = CACHE.get(selector);
    let elements = entry?.ref?.deref();
    if (options.force || !elements) {
      elements = Array.from(document.querySelectorAll(selector));
      const ref = new WeakRef(elements);
      entry = { ref, lastUpdate: Date.now() };
      CACHE.set(selector, entry);
      registry?.register(elements, selector);
    }
    return elements;
  }
  var CACHE, SUPPORTS_WEAKREF, SUPPORTS_REGISTRY, registry;
  var init_domCache = __esm({
    "src-js/utils/dom/domCache.ts"() {
      "use strict";
      CACHE = /* @__PURE__ */ new Map();
      SUPPORTS_WEAKREF = typeof WeakRef !== "undefined";
      SUPPORTS_REGISTRY = typeof FinalizationRegistry !== "undefined";
      registry = SUPPORTS_REGISTRY ? (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore – lib dom may not include FinalizationRegistry in older TS bundlers
        new FinalizationRegistry((selector) => {
          CACHE.delete(selector);
        })
      ) : null;
      __name($$, "$$");
    }
  });

  // src-js/debug/SpotifyDOMSelectors.ts
  function elementExists(selector) {
    return $$(selector).length > 0;
  }
  function findElementsWithFallback(modernSelector, legacySelector, options) {
    let elements = $$(modernSelector, options);
    if (elements.length === 0 && legacySelector) {
      elements = $$(legacySelector, options);
      if (elements.length > 0) {
        console.warn(
          `\u{1F30C} [SpotifyDOMSelectors] Using legacy selector: ${legacySelector}. Consider updating to: ${modernSelector}`
        );
      }
    }
    return elements;
  }
  function validateSpotifyDOM() {
    console.group("\u{1F30C} [SpotifyDOMSelectors] DOM Validation");
    const results = {
      found: 0,
      missing: 0,
      details: {}
    };
    Object.entries(MODERN_SELECTORS).forEach(([key, selector]) => {
      const exists = elementExists(selector);
      results.details[key] = {
        selector,
        exists,
        element: exists ? $$(selector)[0] || null : null
      };
      if (exists) {
        results.found++;
        console.log(`\u2705 ${key}: ${selector}`);
      } else {
        results.missing++;
        console.warn(`\u274C ${key}: ${selector}`);
      }
    });
    console.log(`\u{1F4CA} Summary: ${results.found} found, ${results.missing} missing`);
    console.groupEnd();
    return results;
  }
  function testGravitySystemSelectors() {
    console.group("\u{1F30C} [Phase 1] Testing Gravity System Selectors");
    console.log("\u{1F3AF} Primary gravity well targets:");
    if (GRAVITY_WELL_TARGETS["primary"]) {
      GRAVITY_WELL_TARGETS["primary"].forEach((selector) => {
        const element = $$(selector)[0] || null;
        console.log(`${element ? "\u2705" : "\u274C"} ${selector}`, element);
      });
    }
    console.log("\u{1F3AF} Secondary gravity well targets:");
    if (GRAVITY_WELL_TARGETS["secondary"]) {
      GRAVITY_WELL_TARGETS["secondary"].forEach((selector) => {
        const element = $$(selector)[0] || null;
        console.log(`${element ? "\u2705" : "\u274C"} ${selector}`, element);
      });
    }
    console.log("\u{1F6F8} Orbital elements:");
    Object.entries(ORBITAL_ELEMENTS).forEach(([key, selector]) => {
      const elements = $$(selector);
      console.log(
        `${elements.length > 0 ? "\u2705" : "\u274C"} ${key} (${selector}): ${elements.length} found`
      );
    });
    console.groupEnd();
  }
  function validatePredictionTargets() {
    console.group(
      "\u{1F52E} [SpotifyDOMSelectors] Phase 2 - Prediction Target Validation"
    );
    const testSelectors = [
      { name: "Track Rows", selector: ORBITAL_ELEMENTS["trackRows"] },
      { name: "Progress Bar", selector: MODERN_SELECTORS["progressBar"] },
      { name: "Play Button", selector: MODERN_SELECTORS["playButton"] },
      { name: "Heart Button", selector: MODERN_SELECTORS["heartButton"] },
      { name: "Album Cover", selector: MODERN_SELECTORS["albumCover"] },
      {
        name: "Now Playing Widget",
        selector: MODERN_SELECTORS["nowPlayingWidget"]
      },
      { name: "Now Playing Left", selector: MODERN_SELECTORS["nowPlayingLeft"] },
      { name: "Left Sidebar", selector: MODERN_SELECTORS["leftSidebar"] },
      { name: "Library Items", selector: ORBITAL_ELEMENTS["libraryItems"] }
    ];
    const results = {
      found: 0,
      missing: 0,
      details: {}
    };
    testSelectors.forEach(({ name, selector }) => {
      if (!selector) return;
      const elements = findElementsWithFallback(selector);
      const count = elements.length;
      results.details[name] = {
        selector,
        count,
        exists: count > 0
      };
      if (count > 0) {
        results.found++;
        console.log(`\u2705 ${name}: ${count} elements found (${selector})`);
      } else {
        results.missing++;
        console.warn(`\u274C ${name}: No elements found (${selector})`);
      }
    });
    console.log(
      `\u{1F4CA} Prediction Targets Summary: ${results.found} types found, ${results.missing} missing`
    );
    console.groupEnd();
    return results;
  }
  function testPhase2Systems() {
    console.group("\u{1F30C} [SpotifyDOMSelectors] Phase 2 - System Integration Test");
    const systemTests = {
      behavioralPrediction: validatePredictionTargets(),
      dimensionalNexus: {
        sidebarElement: MODERN_SELECTORS["leftSidebar"] ? elementExists(MODERN_SELECTORS["leftSidebar"]) : false
      },
      dataGlyph: {
        navLinks: MODERN_SELECTORS["navBarLink"] ? elementExists(MODERN_SELECTORS["navBarLink"]) : false,
        trackRows: ORBITAL_ELEMENTS["trackRows"] ? elementExists(ORBITAL_ELEMENTS["trackRows"]) : false,
        cards: ORBITAL_ELEMENTS["cards"] ? elementExists(ORBITAL_ELEMENTS["cards"]) : false
      }
    };
    let totalIssues = 0;
    Object.values(systemTests).forEach((tests) => {
      if (typeof tests === "object" && tests.missing) {
        totalIssues += tests.missing;
      }
    });
    console.log(
      `\u{1F3AF} Phase 2 Integration Health: ${totalIssues === 0 ? "\u2705 All systems operational" : `\u26A0\uFE0F ${totalIssues} issues detected`}`
    );
    console.groupEnd();
    return systemTests;
  }
  var MODERN_SELECTORS, SELECTOR_MAPPINGS, ORBITAL_ELEMENTS, GRAVITY_WELL_TARGETS, ANTI_GRAVITY_ZONES;
  var init_SpotifyDOMSelectors = __esm({
    "src-js/debug/SpotifyDOMSelectors.ts"() {
      "use strict";
      init_domCache();
      MODERN_SELECTORS = {
        // Main Layout Structure
        nowPlayingBar: ".Root__now-playing-bar",
        leftSidebar: ".Root__nav-bar",
        mainView: ".Root__main-view",
        rightSidebar: ".Root__right-sidebar",
        // Now Playing Components
        nowPlayingWidget: "[data-testid='now-playing-widget']",
        nowPlayingLeft: ".main-nowPlayingBar-left",
        nowPlayingCenter: ".main-nowPlayingBar-center",
        nowPlayingRight: ".main-nowPlayingBar-right",
        coverArt: ".main-coverSlotCollapsed-container",
        trackInfo: ".main-trackInfo-container",
        // Navigation & Library
        navMain: "nav[aria-label='Main']",
        yourLibrary: ".main-yourLibraryX-libraryContainer",
        libraryItems: ".main-yourLibraryX-listItem",
        libraryHeader: ".main-yourLibraryX-header",
        playlistList: ".main-rootlist-wrapper",
        // Track Lists & Content
        trackListContainer: "[role='grid'][aria-label*='tracks']",
        trackRow: ".main-trackList-trackListRow",
        trackListHeader: ".main-trackList-trackListHeaderRow",
        trackNumber: ".main-trackList-rowSectionIndex",
        trackTitle: ".main-trackList-rowTitle",
        trackArtist: ".main-trackList-rowSubTitle",
        // Entity Headers (Playlist/Album/Artist Pages)
        entityHeader: ".main-entityHeader-container",
        entityTitle: ".main-entityHeader-title",
        entityMetadata: ".main-entityHeader-metaData",
        entityImage: ".main-entityHeader-imageContainer",
        // Action Bar & Controls
        actionBar: ".main-actionBar-ActionBarRow",
        actionBarInner: ".main-actionBar-ActionBar",
        playButton: "[data-testid='play-button']",
        pauseButton: "[data-testid='pause-button']",
        shuffleButton: "[data-testid='shuffle-button']",
        likeButton: ".control-button-heart",
        // Queue & Right Sidebar
        queue: ".main-queue-trackList",
        queueContainer: "[aria-label='Next in queue']",
        aboutArtist: "[aria-label='About the artist']",
        credits: "[aria-label='Credits']",
        // Search & Filtering
        searchInput: "[data-testid='search-input']",
        searchPage: "[data-testid='search-container']",
        filterPills: ".main-genre-chip",
        sortButton: "[data-testid='sort-button']",
        // Cards & Media
        card: ".main-card-card",
        cardImage: ".main-cardImage-image",
        albumArt: ".main-trackList-albumArt",
        // Modal & Overlay
        modal: ".main-modal-container",
        overlay: ".main-overlay-container"
      };
      SELECTOR_MAPPINGS = Object.entries({
        // Migration mapping: legacy → modern
        ".main-nowPlayingWidget-nowPlaying": MODERN_SELECTORS["nowPlayingBar"],
        ".main-navBar-navBar": MODERN_SELECTORS["leftSidebar"],
        ".main-search-searchBar": MODERN_SELECTORS["searchInput"],
        ".main-topBar-topBar": MODERN_SELECTORS["actionBar"],
        ".main-queue-queue": MODERN_SELECTORS["queue"],
        ".main-trackList-trackList": MODERN_SELECTORS["trackListContainer"]
      }).reduce((acc, [key, value]) => {
        if (typeof value === "string") {
          acc[key] = value;
        }
        return acc;
      }, {});
      ORBITAL_ELEMENTS = {
        // Elements that can have orbital gravity effects
        trackRows: MODERN_SELECTORS["trackRow"] ?? "",
        libraryItems: MODERN_SELECTORS["libraryItems"] ?? "",
        cards: MODERN_SELECTORS["card"] ?? "",
        navLinks: ".main-navBar-navBarLink"
        // This one still works
      };
      GRAVITY_WELL_TARGETS = {
        // Major UI elements that should have gravity wells
        primary: [
          MODERN_SELECTORS["nowPlayingBar"],
          MODERN_SELECTORS["leftSidebar"],
          MODERN_SELECTORS["entityHeader"]
        ].filter((s) => !!s),
        secondary: [
          MODERN_SELECTORS["actionBar"],
          MODERN_SELECTORS["queue"],
          MODERN_SELECTORS["searchInput"]
        ].filter((s) => !!s),
        tertiary: [
          MODERN_SELECTORS["playButton"],
          MODERN_SELECTORS["trackListHeader"]
        ].filter((s) => !!s)
      };
      ANTI_GRAVITY_ZONES = {
        // Areas where anti-gravity effects should be applied
        searchAreas: [
          MODERN_SELECTORS["searchInput"],
          MODERN_SELECTORS["searchPage"]
        ].filter((s) => !!s),
        notifications: [
          "[data-testid='notification-bar']",
          ".main-topBar-notifications"
        ],
        dropdowns: [".main-dropdown-menu", "[role='menu']", "[role='listbox']"]
      };
      __name(elementExists, "elementExists");
      __name(findElementsWithFallback, "findElementsWithFallback");
      __name(validateSpotifyDOM, "validateSpotifyDOM");
      __name(testGravitySystemSelectors, "testGravitySystemSelectors");
      __name(validatePredictionTargets, "validatePredictionTargets");
      __name(testPhase2Systems, "testPhase2Systems");
      if (typeof window !== "undefined") {
        window.SpotifyDOMSelectors = {
          validate: validateSpotifyDOM,
          testGravity: testGravitySystemSelectors,
          validatePredictionTargets,
          testPhase2Systems,
          selectors: MODERN_SELECTORS,
          targets: GRAVITY_WELL_TARGETS,
          orbital: ORBITAL_ELEMENTS,
          antiGravity: ANTI_GRAVITY_ZONES
        };
        console.log("\u{1F3AF} [SpotifyDOMSelectors] Debug functions available:");
        console.log("  window.SpotifyDOMSelectors.validate() - Test all selectors");
        console.log(
          "  window.SpotifyDOMSelectors.testGravity() - Test gravity selectors"
        );
      }
    }
  });

  // src-js/visual/ui-effects/SidebarPerformanceCoordinator.ts
  var SidebarPerformanceCoordinator_exports = {};
  __export(SidebarPerformanceCoordinator_exports, {
    RightSidebarCoordinator: () => RightSidebarCoordinator,
    SidebarPerformanceCoordinator: () => SidebarPerformanceCoordinator,
    getRightSidebarCoordinator: () => getRightSidebarCoordinator,
    getSidebarPerformanceCoordinator: () => getSidebarPerformanceCoordinator
  });
  function getRightSidebarCoordinator(config) {
    return SidebarPerformanceCoordinator.getInstance(config);
  }
  function getSidebarPerformanceCoordinator(config) {
    return SidebarPerformanceCoordinator.getInstance(config);
  }
  var _SidebarPerformanceCoordinator, SidebarPerformanceCoordinator, RightSidebarCoordinator;
  var init_SidebarPerformanceCoordinator = __esm({
    "src-js/visual/ui-effects/SidebarPerformanceCoordinator.ts"() {
      "use strict";
      init_CSSVariableBatcher();
      init_PerformanceBudgetManager();
      init_SpotifyDOMSelectors();
      _SidebarPerformanceCoordinator = class _SidebarPerformanceCoordinator {
        constructor(config = {}) {
          this.pendingUpdates = /* @__PURE__ */ new Map();
          this.isFlushScheduled = false;
          this.rafId = null;
          this.performanceAnalyzer = null;
          // Harmonic variable mapping for Year 3000 convergence
          this.harmonicVariableMap = /* @__PURE__ */ new Map([
            ["--sn-rs-beat-intensity", "--sn-beat-pulse-intensity"],
            ["--sn-rs-glow-alpha", "--sn-rhythm-phase"],
            ["--sn-rs-hue-shift", "--sn-spectrum-phase"]
          ]);
          // Performance tracking
          this.flushCount = 0;
          this.totalFlushTime = 0;
          this.lastFlushTimestamp = 0;
          this.budgetManager = null;
          // DOM observation for reactive refresh and temporal play
          this.domObserver = null;
          this.sidebarElement = null;
          this.visibilityObserver = null;
          this.observationThrottleTimer = null;
          this.lastObservationTime = 0;
          this.OBSERVATION_THROTTLE_MS = 100;
          // Throttle observations to 10 Hz
          this.isFirstOpen = true;
          this.lastScrollUpdate = 0;
          // Timeout tracking for proper cleanup
          this.activeTimeouts = /* @__PURE__ */ new Set();
          this.domObservationRetryTimeout = null;
          this.config = {
            enableDebug: config.enableDebug ?? false,
            maxBatchSize: config.maxBatchSize ?? 50,
            ...config
          };
          this.performanceAnalyzer = config.performanceAnalyzer || null;
          if (this.performanceAnalyzer) {
            this.budgetManager = PerformanceBudgetManager.getInstance(void 0, this.performanceAnalyzer);
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceCoordinator] Initialized with RAF-based batching"
            );
          }
        }
        /**
         * Singleton accessor for global coordination
         */
        static getInstance(config) {
          if (!_SidebarPerformanceCoordinator.instance) {
            _SidebarPerformanceCoordinator.instance = new _SidebarPerformanceCoordinator(config);
          }
          return _SidebarPerformanceCoordinator.instance;
        }
        /**
         * Queue a CSS variable update for atomic application at next animation frame
         */
        queueUpdate(property, value) {
          const criticalVars = [
            "--sn-rs-glow-alpha",
            "--sn-rs-beat-intensity",
            "--sn-rs-hue-shift"
          ];
          if (criticalVars.includes(property)) {
            this.applyCriticalUpdate(property, value);
            return;
          }
          if (CSSVariableBatcher.instance) {
            CSSVariableBatcher.instance.queueCSSVariableUpdate(
              property,
              value,
              this.getSidebarElement()
            );
          } else {
            this.pendingUpdates.set(property, {
              property,
              value,
              timestamp: performance.now()
            });
            if (this.config.enableDebug && this.pendingUpdates.size === 1) {
              console.log(
                `\u{1F30C} [SidebarPerformanceCoordinator] Queuing first update (fallback): ${property}`
              );
            }
            this.scheduleFlush();
          }
        }
        /**
         * Apply critical updates immediately to the sidebar element
         */
        applyCriticalUpdate(property, value) {
          const sidebarElement = this.getSidebarElement();
          if (sidebarElement) {
            try {
              sidebarElement.style.setProperty(property, value);
            } catch (error) {
              console.error(
                `\u{1F30C} [SidebarPerformanceCoordinator] Failed to apply critical ${property}:`,
                error
              );
            }
          }
        }
        /**
         * Get the sidebar element with fallback to document root
         * Extensible to support multiple sidebar locations in the future
         */
        getSidebarElement() {
          if (!this.sidebarElement) {
            this.sidebarElement = document.querySelector(
              MODERN_SELECTORS.rightSidebar
            );
          }
          return this.sidebarElement || document.documentElement;
        }
        /**
         * Schedule atomic flush at next animation frame
         */
        scheduleFlush() {
          if (this.isFlushScheduled) {
            return;
          }
          this.isFlushScheduled = true;
          this.rafId = requestAnimationFrame(() => {
            this.flushUpdates();
          });
        }
        /**
         * Atomically apply all pending updates
         */
        flushUpdates() {
          if (this.pendingUpdates.size === 0) {
            this.isFlushScheduled = false;
            return;
          }
          const startTime = performance.now();
          const targetElement = this.getSidebarElement();
          const updateCount = this.pendingUpdates.size;
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [SidebarPerformanceCoordinator] Flushing ${updateCount} updates atomically`
            );
          }
          if (updateCount > (this.config.maxBatchSize || 50)) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceCoordinator] Large batch detected (${updateCount} updates), may impact performance`
            );
          }
          for (const update of this.pendingUpdates.values()) {
            try {
              targetElement.style.setProperty(
                update.property,
                update.value
              );
              const harmonicVar = this.harmonicVariableMap.get(update.property);
              if (harmonicVar) {
                document.documentElement.style.setProperty(harmonicVar, update.value);
                if (this.config.enableDebug) {
                  console.log(
                    `\u{1F30C} [SidebarPerformanceCoordinator] Mapped ${update.property} \u2192 ${harmonicVar} = ${update.value}`
                  );
                }
              }
            } catch (error) {
              console.error(
                `\u{1F30C} [SidebarPerformanceCoordinator] Failed to apply ${update.property}:`,
                error
              );
            }
          }
          this.pendingUpdates.clear();
          this.isFlushScheduled = false;
          this.rafId = null;
          if (this.config.onFlushComplete) {
            try {
              this.config.onFlushComplete();
            } catch (error) {
              console.error(
                "\u{1F30C} [SidebarPerformanceCoordinator] Error in flush completion callback:",
                error
              );
            }
          }
          const endTime = performance.now();
          const flushTime = endTime - startTime;
          this.flushCount++;
          this.totalFlushTime += flushTime;
          this.lastFlushTimestamp = endTime;
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.emitTrace?.(
              `[SidebarPerformanceCoordinator] Flushed ${updateCount} updates in ${flushTime.toFixed(
                2
              )}ms`
            );
          }
          const avgFlushTime = this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0;
          if (avgFlushTime > 3) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceCoordinator] Performance threshold exceeded: average ${avgFlushTime.toFixed(
                2
              )}ms per flush (target: <3ms)`
            );
          }
          if (this.config.enableDebug && flushTime > 4) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceCoordinator] Slow flush detected: ${flushTime.toFixed(
                2
              )}ms for ${updateCount} updates`
            );
          }
        }
        /**
         * Setup DOM observation for reactive refresh and temporal play
         */
        setupDOMObservation() {
          if (this.domObserver) {
            return;
          }
          this.sidebarElement = document.querySelector(
            MODERN_SELECTORS.rightSidebar
          );
          if (!this.sidebarElement) {
            if (this.config.enableDebug) {
              console.warn(
                "\u{1F30C} [SidebarPerformanceCoordinator] Sidebar not found, deferring DOM observation"
              );
            }
            if (this.domObservationRetryTimeout) {
              clearTimeout(this.domObservationRetryTimeout);
              this.activeTimeouts.delete(this.domObservationRetryTimeout);
            }
            this.domObservationRetryTimeout = setTimeout(() => {
              this.setupDOMObservation();
              this.domObservationRetryTimeout = null;
            }, 1e3);
            this.activeTimeouts.add(this.domObservationRetryTimeout);
            return;
          }
          this.domObserver = new MutationObserver((mutations) => {
            this.throttleObservationUpdate(() => {
              this.queueUpdate("--sn-rs-force-refresh", Date.now().toString());
              for (const mutation of mutations) {
                if (mutation.type === "attributes" && (mutation.attributeName === "aria-hidden" || mutation.attributeName === "style")) {
                  this.handleVisibilityChange();
                }
              }
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F30C} [SidebarPerformanceCoordinator] DOM change detected, forcing refresh"
                );
              }
            });
          });
          this.domObserver.observe(this.sidebarElement, {
            childList: true,
            subtree: false,
            // Optimize: Only observe direct children
            attributes: true,
            // Watch for aria-hidden and style changes
            attributeFilter: ["aria-hidden", "style", "class"],
            // Optimize: Don't observe attribute old values
            attributeOldValue: false,
            characterData: false
            // Don't observe text changes
          });
          this.setupVisibilityObserver();
          this.setupScrollObservation();
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceCoordinator] DOM observation active on sidebar"
            );
          }
        }
        /**
         * Setup visibility observer for temporal echo effects
         */
        setupVisibilityObserver() {
          if (!this.sidebarElement || this.visibilityObserver) return;
          this.visibilityObserver = new IntersectionObserver(
            (entries) => {
              const entry = entries[0];
              if (entry && entry.isIntersecting && this.isFirstOpen) {
                if (window.requestIdleCallback) {
                  window.requestIdleCallback(() => {
                    this.triggerTemporalEcho();
                    this.isFirstOpen = false;
                  });
                } else {
                  setTimeout(() => {
                    this.triggerTemporalEcho();
                    this.isFirstOpen = false;
                  }, 0);
                }
              }
            },
            { threshold: 0.1 }
          );
          this.visibilityObserver.observe(this.sidebarElement);
        }
        /**
         * Setup scroll observation with throttling for performance
         */
        setupScrollObservation() {
          if (!this.sidebarElement) return;
          const queueElement = this.sidebarElement.querySelector(
            ".main-nowPlayingView-queue"
          );
          if (!queueElement) return;
          queueElement.addEventListener(
            "scroll",
            this.throttledScrollHandler.bind(this),
            {
              passive: true
            }
          );
        }
        /**
         * Throttled scroll handler (≤30 Hz as specified)
         */
        throttledScrollHandler() {
          const now = performance.now();
          if (now - this.lastScrollUpdate < 33) return;
          this.lastScrollUpdate = now;
          if (window.requestIdleCallback) {
            window.requestIdleCallback(() => {
              this.queueUpdate("--sn-rs-scroll-ratio", Math.random().toString());
            }, { timeout: 100 });
          } else {
            this.queueUpdate("--sn-rs-scroll-ratio", Math.random().toString());
          }
        }
        /**
         * Throttle DOM observation updates to reduce CPU overhead
         */
        throttleObservationUpdate(callback) {
          const now = performance.now();
          if (now - this.lastObservationTime < this.OBSERVATION_THROTTLE_MS) {
            if (this.observationThrottleTimer) {
              clearTimeout(this.observationThrottleTimer);
            }
            this.observationThrottleTimer = window.setTimeout(() => {
              callback();
              this.lastObservationTime = performance.now();
              this.observationThrottleTimer = null;
            }, this.OBSERVATION_THROTTLE_MS);
          } else {
            callback();
            this.lastObservationTime = now;
          }
        }
        /**
         * Handle visibility changes for temporal effects
         */
        handleVisibilityChange() {
          if (!this.sidebarElement) return;
          const isVisible = !this.sidebarElement.hasAttribute("aria-hidden") && !this.sidebarElement.style.display?.includes(
            "none"
          );
          if (isVisible && this.isFirstOpen) {
            this.triggerTemporalEcho();
            this.isFirstOpen = false;
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [SidebarPerformanceCoordinator] Visibility changed: ${isVisible ? "visible" : "hidden"}`
            );
          }
        }
        /**
         * Trigger one-time temporal echo effect
         */
        triggerTemporalEcho() {
          if (!this.sidebarElement) return;
          this.sidebarElement.classList.add("sn-future-preview");
          this.queueUpdate("--sn-kinetic-intensity", "1");
          this.queueUpdate("--sn-echo-hue-shift", "15deg");
          this.queueUpdate("--sn-echo-radius-multiplier", "1.2");
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceCoordinator] Triggering temporal echo effect"
            );
          }
          const cleanupTimeout = setTimeout(() => {
            this.sidebarElement?.classList.remove("sn-future-preview");
            this.queueUpdate("--sn-kinetic-intensity", "0");
            this.activeTimeouts.delete(cleanupTimeout);
          }, 2e3);
          this.activeTimeouts.add(cleanupTimeout);
        }
        /**
         * Get performance metrics for monitoring
         */
        getPerformanceMetrics() {
          return {
            flushCount: this.flushCount,
            averageFlushTime: this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0,
            lastFlushTimestamp: this.lastFlushTimestamp,
            pendingUpdates: this.pendingUpdates.size
          };
        }
        /**
         * Force immediate flush for critical scenarios
         */
        forceFlush() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
          this.flushUpdates();
        }
        /**
         * Cleanup and destroy coordinator
         */
        destroy() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
          this.activeTimeouts.forEach((timeout) => {
            clearTimeout(timeout);
          });
          this.activeTimeouts.clear();
          if (this.domObservationRetryTimeout) {
            clearTimeout(this.domObservationRetryTimeout);
            this.domObservationRetryTimeout = null;
          }
          if (this.observationThrottleTimer) {
            clearTimeout(this.observationThrottleTimer);
            this.observationThrottleTimer = null;
          }
          if (this.domObserver) {
            this.domObserver.disconnect();
            this.domObserver = null;
          }
          if (this.visibilityObserver) {
            this.visibilityObserver.disconnect();
            this.visibilityObserver = null;
          }
          this.pendingUpdates.clear();
          this.isFlushScheduled = false;
          this.sidebarElement = null;
          if (_SidebarPerformanceCoordinator.instance === this) {
            _SidebarPerformanceCoordinator.instance = null;
          }
          if (this.config.enableDebug) {
            const avgFlushTime = this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0;
            console.log(
              `\u{1F30C} [SidebarPerformanceCoordinator] Destroyed. Performance: ${this.flushCount} flushes, ${avgFlushTime.toFixed(2)}ms avg`
            );
          }
        }
      };
      __name(_SidebarPerformanceCoordinator, "SidebarPerformanceCoordinator");
      _SidebarPerformanceCoordinator.instance = null;
      SidebarPerformanceCoordinator = _SidebarPerformanceCoordinator;
      RightSidebarCoordinator = SidebarPerformanceCoordinator;
      __name(getRightSidebarCoordinator, "getRightSidebarCoordinator");
      __name(getSidebarPerformanceCoordinator, "getSidebarPerformanceCoordinator");
    }
  });

  // src-js/visual/ui-effects/RightSidebarConsciousnessEnhanced.ts
  var _RightSidebarConsciousnessEnhanced, RightSidebarConsciousnessEnhanced;
  var init_RightSidebarConsciousnessEnhanced = __esm({
    "src-js/visual/ui-effects/RightSidebarConsciousnessEnhanced.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_SidebarPerformanceCoordinator();
      init_globalConfig();
      _RightSidebarConsciousnessEnhanced = class _RightSidebarConsciousnessEnhanced extends UnifiedSystemBase {
        constructor(config = YEAR3000_CONFIG, coordinator) {
          super(config);
          // Consciousness state (bilateral awareness)
          this.consciousnessState = {
            level: "dormant",
            beatIntensity: 0,
            energyLevel: 0,
            glowAlpha: 0.15,
            hueShift: 0,
            bilateralSync: false
          };
          // Animation state for smooth transitions
          this.currentBeatIntensity = 0;
          this.targetBeatIntensity = 0;
          this.currentHueShift = 0;
          this.targetHueShift = 0;
          // Performance parameters (maintaining original specifications)
          this.INTENSITY_LERP = 0.25;
          this.HUE_LERP = 0.05;
          this.BILATERAL_OFFSET = 150;
          // 150ms behind left sidebar
          // Animation timing
          this.lastUpdateTime = 0;
          this.animationPhase = 0;
          this.coordinator = coordinator || SidebarPerformanceCoordinator.getInstance({
            enableDebug: config.enableDebug,
            performanceAnalyzer: this.performanceAnalyzer,
            onFlushComplete: /* @__PURE__ */ __name(() => {
              this.performanceAnalyzer?.emitTrace?.(
                "[RightSidebarConsciousnessEnhanced] Coordinator flush completed"
              );
            }, "onFlushComplete")
          });
          if (config.enableDebug) {
            console.log(`[${this.systemName}] Initialized enhanced right sidebar consciousness`);
          }
        }
        /**
         * Initialize the enhanced right sidebar consciousness system
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing enhanced right sidebar consciousness`);
          }
          this.subscribeToEvent("music:beat", (payload) => {
            this.handleBeat(payload);
          });
          this.subscribeToEvent("music:energy", (payload) => {
            this.handleEnergy(payload);
          });
          this.subscribeToEvent("sidebar:bilateral-beat", (payload) => {
            if (payload.source === "left") {
              this.handleLeftSidebarBeat(payload);
            }
          });
          this.subscribeToEvent("sidebar:bilateral-sync", (payload) => {
            this.handleBilateralSync(payload);
          });
          this.subscribeToEvent("sidebar:bilateral-sync-enabled", (payload) => {
            this.consciousnessState.bilateralSync = true;
            this.publishEvent("sidebar:right-consciousness-sync-enabled", {
              timestamp: Date.now()
            });
          });
          this.registerAnimation(60);
          this.consciousnessState.level = "aware";
          this.consciousnessState.bilateralSync = true;
          this.updateInitialCSSVariables();
          this.publishEvent("sidebar:right-consciousness-enhanced-ready", {
            systemName: this.systemName,
            bilateralSync: this.consciousnessState.bilateralSync,
            timestamp: Date.now()
          });
        }
        /**
         * Handle music beat events
         */
        handleBeat(payload) {
          this.targetBeatIntensity = Math.min(Math.max(payload.intensity, 0), 1);
          this.updateConsciousnessLevel(payload.intensity);
          if (this.consciousnessState.bilateralSync) {
            this.publishEvent("sidebar:bilateral-beat", {
              source: "right",
              intensity: payload.intensity,
              timestamp: Date.now() - this.BILATERAL_OFFSET,
              // 150ms behind left
              consciousnessLevel: this.consciousnessState.level
            });
          }
        }
        /**
         * Handle energy events
         */
        handleEnergy(payload) {
          const deg = Math.round(payload.energy * 120);
          this.targetHueShift = deg;
          this.consciousnessState.energyLevel = payload.energy;
          if (this.consciousnessState.bilateralSync) {
            this.publishEvent("sidebar:bilateral-energy", {
              source: "right",
              energy: payload.energy,
              hueShift: deg,
              timestamp: Date.now() - this.BILATERAL_OFFSET
            });
          }
        }
        /**
         * Handle left sidebar beat for bilateral coordination
         */
        handleLeftSidebarBeat(payload) {
          const complementaryIntensity = payload.intensity * 0.8;
          this.targetBeatIntensity = Math.max(this.targetBeatIntensity, complementaryIntensity);
          this.updateConsciousnessLevel(complementaryIntensity);
        }
        /**
         * Handle bilateral synchronization
         */
        handleBilateralSync(payload) {
          if (payload.source === "orchestrator") {
            if (payload.type === "beat") {
              this.targetBeatIntensity = payload.intensity;
            } else if (payload.type === "energy") {
              const deg = Math.round(payload.energy * 120);
              this.targetHueShift = deg;
            }
          }
        }
        /**
         * Update consciousness level based on music intensity
         */
        updateConsciousnessLevel(intensity) {
          let newLevel;
          if (intensity < 0.2) {
            newLevel = "dormant";
          } else if (intensity < 0.5) {
            newLevel = "aware";
          } else if (intensity < 0.8) {
            newLevel = "focused";
          } else {
            newLevel = "transcendent";
          }
          if (newLevel !== this.consciousnessState.level) {
            const previousLevel = this.consciousnessState.level;
            this.consciousnessState.level = newLevel;
            this.publishEvent("sidebar:consciousness-level-changed", {
              sidebar: "right",
              previousLevel,
              newLevel,
              intensity,
              timestamp: Date.now()
            });
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Consciousness level: ${previousLevel} \u2192 ${newLevel}`);
            }
          }
        }
        /**
         * Animation frame callback - maintains original <1ms frame budget
         */
        onAnimate(deltaTime) {
          this.lastUpdateTime = performance.now();
          this.animationPhase += deltaTime * 1e-3;
          this.currentBeatIntensity = this.lerp(
            this.currentBeatIntensity,
            this.targetBeatIntensity,
            this.INTENSITY_LERP
          );
          this.currentHueShift = this.lerp(
            this.currentHueShift,
            this.targetHueShift,
            this.HUE_LERP
          );
          this.consciousnessState.beatIntensity = this.currentBeatIntensity;
          this.consciousnessState.hueShift = this.currentHueShift;
          const glowAlpha = 0.15 + this.currentBeatIntensity * 0.45;
          this.consciousnessState.glowAlpha = glowAlpha;
          this.updateCSSVariables({
            "--sn-rs-beat-intensity": this.currentBeatIntensity.toFixed(3),
            "--sn-rs-glow-alpha": glowAlpha.toFixed(3),
            "--sn-rs-hue-shift": `${this.currentHueShift}deg`,
            "--sn-rs-consciousness-level": this.getConsciousnessLevelValue(),
            "--sn-rs-bilateral-sync": this.consciousnessState.bilateralSync ? "1" : "0",
            "--sn-rs-energy-level": this.consciousnessState.energyLevel.toFixed(3)
          });
          this.coordinator.queueUpdate("--sn-rs-beat-intensity", this.currentBeatIntensity.toString());
          this.coordinator.queueUpdate("--sn-rs-glow-alpha", glowAlpha.toFixed(3));
          this.coordinator.queueUpdate("--sn-rs-hue-shift", `${this.currentHueShift}deg`);
        }
        /**
         * Get numeric value for consciousness level
         */
        getConsciousnessLevelValue() {
          const levels = {
            dormant: 0.25,
            aware: 0.5,
            focused: 0.75,
            transcendent: 1
          };
          return levels[this.consciousnessState.level].toFixed(2);
        }
        /**
         * Set up initial CSS variables
         */
        updateInitialCSSVariables() {
          this.updateCSSVariables({
            "--sn-rs-beat-intensity": "0",
            "--sn-rs-glow-alpha": "0.15",
            "--sn-rs-hue-shift": "0deg",
            "--sn-rs-consciousness-level": "0.5",
            "--sn-rs-bilateral-sync": "1",
            "--sn-rs-energy-level": "0"
          });
        }
        /**
         * Linear interpolation helper (maintaining original behavior)
         */
        lerp(from, to, alpha) {
          return from + (to - from) * alpha;
        }
        /**
         * Enhanced health check with bilateral consciousness metrics
         */
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: `Enhanced right sidebar consciousness healthy - Level: ${this.consciousnessState.level}, Beat: ${this.consciousnessState.beatIntensity.toFixed(2)}, Bilateral sync: ${this.consciousnessState.bilateralSync}`,
            issues: [],
            system: "RightSidebarConsciousnessEnhanced"
          };
        }
        /**
         * Clean up resources
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying enhanced right sidebar consciousness`);
          }
          this.publishEvent("sidebar:bilateral-consciousness-destroyed", {
            sidebar: "right",
            timestamp: Date.now()
          });
          this.consciousnessState = {
            level: "dormant",
            beatIntensity: 0,
            energyLevel: 0,
            glowAlpha: 0.15,
            hueShift: 0,
            bilateralSync: false
          };
        }
        /**
         * Get current consciousness state for debugging
         */
        getConsciousnessState() {
          return { ...this.consciousnessState };
        }
        /**
         * Get current animation metrics for performance monitoring
         */
        getAnimationMetrics() {
          return {
            currentBeatIntensity: this.currentBeatIntensity,
            targetBeatIntensity: this.targetBeatIntensity,
            currentHueShift: this.currentHueShift,
            targetHueShift: this.targetHueShift,
            lastUpdateTime: this.lastUpdateTime,
            animationPhase: this.animationPhase,
            consciousnessLevel: this.consciousnessState.level,
            bilateralSync: this.consciousnessState.bilateralSync
          };
        }
        /**
         * Enable/disable bilateral synchronization
         */
        setBilateralSync(enabled) {
          this.consciousnessState.bilateralSync = enabled;
          this.publishEvent("sidebar:right-consciousness-sync-changed", {
            enabled,
            timestamp: Date.now()
          });
        }
        /**
         * Set shared coordinator (for orchestrator integration)
         */
        setCoordinator(coordinator) {
          this.coordinator = coordinator;
        }
      };
      __name(_RightSidebarConsciousnessEnhanced, "RightSidebarConsciousnessEnhanced");
      RightSidebarConsciousnessEnhanced = _RightSidebarConsciousnessEnhanced;
    }
  });

  // src-js/core/integration/SidebarSystemsIntegration.ts
  var _MockLeftSidebarConsciousnessSystem, MockLeftSidebarConsciousnessSystem, _MockSidebarSystemsOrchestrator, MockSidebarSystemsOrchestrator, _SidebarSystemsIntegration, SidebarSystemsIntegration;
  var init_SidebarSystemsIntegration = __esm({
    "src-js/core/integration/SidebarSystemsIntegration.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_SidebarDimensionalNexusSystem();
      init_SidebarInteractiveFlowSystem();
      init_RightSidebarConsciousnessEnhanced();
      init_SidebarPerformanceCoordinator();
      init_globalConfig();
      _MockLeftSidebarConsciousnessSystem = class _MockLeftSidebarConsciousnessSystem extends UnifiedSystemBase {
        async initialize() {
          console.log("[MockLeftSidebarConsciousnessSystem] Initialized");
        }
        destroy() {
          console.log("[MockLeftSidebarConsciousnessSystem] Destroyed");
        }
        onAnimate(deltaTime) {
        }
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "Mock left sidebar consciousness healthy",
            issues: [],
            system: "MockLeftSidebarConsciousnessSystem"
          };
        }
        getConsciousnessState() {
          return { level: "aware", intensity: 0.5 };
        }
        getAnimationMetrics() {
          return { beatIntensity: 0.5, explorationLevel: 0.3 };
        }
      };
      __name(_MockLeftSidebarConsciousnessSystem, "MockLeftSidebarConsciousnessSystem");
      MockLeftSidebarConsciousnessSystem = _MockLeftSidebarConsciousnessSystem;
      _MockSidebarSystemsOrchestrator = class _MockSidebarSystemsOrchestrator extends UnifiedSystemBase {
        constructor() {
          super(...arguments);
          this.synchronizationEnabled = true;
          this.rightSidebarSystem = null;
        }
        async initialize() {
          console.log("[MockSidebarSystemsOrchestrator] Initialized");
        }
        destroy() {
          console.log("[MockSidebarSystemsOrchestrator] Destroyed");
        }
        onAnimate(deltaTime) {
        }
        async healthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "Mock sidebar orchestrator healthy",
            issues: [],
            system: "MockBilateralSidebarOrchestrator"
          };
        }
        getBilateralState() {
          return {
            leftSidebar: { active: true, level: "aware" },
            rightSidebar: { active: !!this.rightSidebarSystem, level: "aware" },
            synchronization: { enabled: this.synchronizationEnabled }
          };
        }
        getPerformanceMetrics() {
          return {
            bilateralSyncMetrics: { syncEvents: 100, avgSyncLatency: 5 },
            performanceMetrics: { totalCSSUpdates: 200, avgUpdateTime: 2 }
          };
        }
        setSynchronizationEnabled(enabled) {
          this.synchronizationEnabled = enabled;
        }
        setRightSidebarSystem(system) {
          this.rightSidebarSystem = system;
        }
      };
      __name(_MockSidebarSystemsOrchestrator, "MockSidebarSystemsOrchestrator");
      MockSidebarSystemsOrchestrator = _MockSidebarSystemsOrchestrator;
      _SidebarSystemsIntegration = class _SidebarSystemsIntegration extends UnifiedSystemBase {
        constructor(config = YEAR3000_CONFIG) {
          super(config);
          // System registry
          this.sidebarSystems = /* @__PURE__ */ new Map();
          // Integration state
          this.integrationEnabled = false;
          // Animation frame tracking
          this.lastFrameTime = 0;
          this.sharedCoordinator = SidebarPerformanceCoordinator.getInstance({
            enableDebug: config.enableDebug,
            performanceAnalyzer: this.performanceAnalyzer,
            onFlushComplete: /* @__PURE__ */ __name(() => this.handlePerformanceFlush(), "onFlushComplete")
          });
          this.leftSidebarConsciousness = new MockLeftSidebarConsciousnessSystem(config);
          this.rightSidebarConsciousness = new RightSidebarConsciousnessEnhanced(config);
          this.sidebarOrchestrator = new MockSidebarSystemsOrchestrator(config);
          this.dimensionalNexus = new SidebarDimensionalNexusSystem(config);
          this.interactiveFlow = new SidebarInteractiveFlowSystem(config);
          this.performanceMetrics = {
            totalSystems: 5,
            activeSystems: 0,
            bilateralSyncEnabled: false,
            averageFrameTime: 0,
            totalMemoryUsage: 0,
            healthStatus: "healthy"
          };
          if (config.enableDebug) {
            console.log(`[${this.systemName}] Initialized sidebar systems integration`);
          }
        }
        /**
         * Initialize all sidebar systems in proper order
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing sidebar systems integration`);
          }
          try {
            this.registerSidebarSystems();
            await this.registerWithUnifiedRegistry();
            await this.initializeSystemsInOrder();
            this.setupBilateralCoordination();
            this.connectToEventBus();
            this.integrateWithPerformanceSystems();
            this.registerAnimation(70);
            this.integrationEnabled = true;
            this.updatePerformanceMetrics();
            this.publishEvent("sidebar:integration-ready", {
              systemName: this.systemName,
              totalSystems: this.sidebarSystems.size,
              activeSystems: this.performanceMetrics.activeSystems,
              bilateralSync: this.performanceMetrics.bilateralSyncEnabled,
              timestamp: Date.now()
            });
          } catch (error) {
            console.error(`[${this.systemName}] Integration initialization failed:`, error);
            throw error;
          }
        }
        /**
         * Register all sidebar system definitions
         */
        registerSidebarSystems() {
          this.sidebarSystems.set("leftSidebarConsciousness", {
            name: "leftSidebarConsciousness",
            system: this.leftSidebarConsciousness,
            priority: "normal",
            enabled: true,
            dependencies: []
          });
          this.sidebarSystems.set("rightSidebarConsciousness", {
            name: "rightSidebarConsciousness",
            system: this.rightSidebarConsciousness,
            priority: "normal",
            enabled: true,
            dependencies: []
          });
          this.sidebarSystems.set("sidebarOrchestrator", {
            name: "sidebarOrchestrator",
            system: this.sidebarOrchestrator,
            priority: "critical",
            enabled: true,
            dependencies: ["leftSidebarConsciousness", "rightSidebarConsciousness"]
          });
          this.sidebarSystems.set("dimensionalNexus", {
            name: "dimensionalNexus",
            system: this.dimensionalNexus,
            priority: "normal",
            enabled: true,
            dependencies: ["sidebarOrchestrator"]
          });
          this.sidebarSystems.set("interactiveFlow", {
            name: "interactiveFlow",
            system: this.interactiveFlow,
            priority: "background",
            enabled: true,
            dependencies: ["sidebarOrchestrator"]
          });
        }
        /**
         * Initialize systems in dependency order
         */
        async initializeSystemsInOrder() {
          const initializationOrder = this.calculateInitializationOrder();
          for (const systemName of initializationOrder) {
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.enabled) {
              try {
                await systemDef.system._baseInitialize();
                this.performanceMetrics.activeSystems++;
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Initialized ${systemName}`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to initialize ${systemName}:`, error);
              }
            }
          }
        }
        /**
         * Calculate system initialization order based on dependencies
         */
        calculateInitializationOrder() {
          const visited = /* @__PURE__ */ new Set();
          const visiting = /* @__PURE__ */ new Set();
          const order = [];
          const visit = /* @__PURE__ */ __name((systemName) => {
            if (visiting.has(systemName)) {
              throw new Error(`Circular dependency detected: ${systemName}`);
            }
            if (visited.has(systemName)) return;
            visiting.add(systemName);
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.dependencies) {
              for (const dep of systemDef.dependencies) {
                visit(dep);
              }
            }
            visiting.delete(systemName);
            visited.add(systemName);
            order.push(systemName);
          }, "visit");
          for (const systemName of this.sidebarSystems.keys()) {
            visit(systemName);
          }
          return order;
        }
        /**
         * Set up bilateral consciousness coordination
         */
        setupBilateralCoordination() {
          this.sidebarOrchestrator.setRightSidebarSystem(this.rightSidebarConsciousness);
          this.sidebarOrchestrator.setSynchronizationEnabled(true);
          this.performanceMetrics.bilateralSyncEnabled = true;
          this.subscribeToEvent("sidebar:bilateral-sync", (payload) => {
            this.handleBilateralSync(payload);
          });
          this.subscribeToEvent("sidebar:consciousness-level-changed", (payload) => {
            this.handleConsciousnessChange(payload);
          });
        }
        /**
         * Handle bilateral synchronization events
         */
        handleBilateralSync(payload) {
          if (payload.source === "orchestrator") {
            this.updatePerformanceMetrics();
          }
        }
        /**
         * Handle consciousness level changes
         */
        handleConsciousnessChange(payload) {
          const consciousnessLevels = {
            dormant: 0.5,
            aware: 0.7,
            focused: 0.9,
            transcendent: 1
          };
          const performanceLevel = consciousnessLevels[payload.newLevel] || 0.7;
          this.adjustPerformanceBudgets(performanceLevel);
        }
        /**
         * Adjust performance budgets based on consciousness level
         */
        adjustPerformanceBudgets(level) {
          const baseBudget = 16;
          const adjustedBudget = Math.floor(baseBudget * level);
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Adjusted performance budget to ${adjustedBudget} based on consciousness level`);
          }
        }
        /**
         * Handle performance flush completion
         */
        handlePerformanceFlush() {
          const currentTime = performance.now();
          if (this.lastFrameTime > 0) {
            const frameTime = currentTime - this.lastFrameTime;
            this.performanceMetrics.averageFrameTime = (this.performanceMetrics.averageFrameTime + frameTime) / 2;
          }
          this.lastFrameTime = currentTime;
          this.updateHealthStatus();
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics() {
          this.performanceMetrics.totalSystems = this.sidebarSystems.size;
          let activeSystems = 0;
          for (const [, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              activeSystems++;
            }
          }
          this.performanceMetrics.activeSystems = activeSystems;
          this.performanceMetrics.bilateralSyncEnabled = this.sidebarOrchestrator.getBilateralState().synchronization.enabled;
        }
        /**
         * Update health status based on performance metrics
         */
        updateHealthStatus() {
          if (this.performanceMetrics.averageFrameTime > 20) {
            this.performanceMetrics.healthStatus = "critical";
          } else if (this.performanceMetrics.averageFrameTime > 16.67) {
            this.performanceMetrics.healthStatus = "degraded";
          } else {
            this.performanceMetrics.healthStatus = "healthy";
          }
        }
        /**
         * Animation frame callback
         */
        onAnimate(deltaTime) {
          if (!this.integrationEnabled) return;
          this.updatePerformanceMetrics();
          this.updateHealthStatus();
          const currentTime = performance.now();
          if (currentTime - this.lastFrameTime > 1e3) {
            this.publishEvent("sidebar:integration-metrics", {
              metrics: this.performanceMetrics,
              timestamp: Date.now()
            });
          }
        }
        /**
         * Register all sidebar systems with Year3000System animation coordinator
         */
        registerWithAnimationCoordinator(animationCoordinator) {
          if (!animationCoordinator) {
            console.warn(`[${this.systemName}] Animation coordinator not available`);
            return;
          }
          for (const [systemName, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              try {
                animationCoordinator.registerAnimationSystem(
                  systemName,
                  systemDef.system,
                  systemDef.priority,
                  60
                  // Default FPS
                );
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Registered ${systemName} with animation coordinator`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to register ${systemName}:`, error);
              }
            }
          }
        }
        /**
         * Get all sidebar systems for external access
         */
        getSidebarSystems() {
          return new Map(this.sidebarSystems);
        }
        /**
         * Get performance metrics
         */
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Enable/disable specific sidebar system
         */
        setSidebarSystemEnabled(systemName, enabled) {
          const systemDef = this.sidebarSystems.get(systemName);
          if (systemDef) {
            systemDef.enabled = enabled;
            if (!enabled && systemDef.system.isInitialized) {
              systemDef.system._baseDestroy();
              this.performanceMetrics.activeSystems--;
            } else if (enabled && !systemDef.system.isInitialized) {
              systemDef.system._baseInitialize().catch((error) => {
                console.error(`[${this.systemName}] Failed to re-enable ${systemName}:`, error);
              });
            }
            this.publishEvent("sidebar:system-toggled", {
              systemName,
              enabled,
              timestamp: Date.now()
            });
          }
        }
        /**
         * System health check
         */
        async healthCheck() {
          const systemHealthChecks = {};
          for (const [systemName, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              try {
                systemHealthChecks[systemName] = await systemDef.system.healthCheck();
              } catch (error) {
                systemHealthChecks[systemName] = {
                  healthy: false,
                  ok: false,
                  details: `Health check failed: ${error.message}`,
                  issues: [`Health check failed: ${error.message}`],
                  system: systemName
                };
              }
            }
          }
          const unhealthySystems = Object.values(systemHealthChecks).filter((check) => !check.ok);
          const isHealthy = unhealthySystems.length === 0;
          return {
            healthy: isHealthy,
            ok: isHealthy,
            details: `Sidebar integration ${isHealthy ? "healthy" : "degraded"} - ${this.performanceMetrics.activeSystems}/${this.performanceMetrics.totalSystems} systems active, bilateral sync: ${this.performanceMetrics.bilateralSyncEnabled}`,
            issues: unhealthySystems.map((check) => check.details || "Unknown issue"),
            system: "SidebarSystemsIntegration"
          };
        }
        /**
         * Phase 3: Register sidebar systems with UnifiedSystemRegistry
         */
        async registerWithUnifiedRegistry() {
          const year3000System2 = globalThis.year3000System;
          if (!year3000System2?.unifiedSystemIntegration) {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] UnifiedSystemRegistry not available, skipping registration`);
            }
            return;
          }
          try {
            const registry2 = year3000System2.getUnifiedSystemRegistry();
            if (registry2) {
              for (const [systemName, systemDef] of this.sidebarSystems) {
                registry2.register(
                  `sidebar:${systemName}`,
                  systemDef.system,
                  systemDef.dependencies?.map((dep) => `sidebar:${dep}`) || []
                );
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Registered ${systemName} with UnifiedSystemRegistry`);
                }
              }
              registry2.register("sidebar:integration", this, []);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Failed to register with UnifiedSystemRegistry:`, error);
          }
        }
        /**
         * Phase 3: Connect to EventBus for system-wide communication
         */
        connectToEventBus() {
          this.subscribeToEvent("music:beat", (payload) => {
            this.handleMusicBeat(payload);
          });
          this.subscribeToEvent("music:energy", (payload) => {
            this.handleMusicEnergy(payload);
          });
          this.subscribeToEvent("performance:threshold-exceeded", (payload) => {
            this.handlePerformanceThreshold(payload);
          });
          this.subscribeToEvent("user:navigation", (payload) => {
            this.handleUserNavigation(payload);
          });
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Connected to EventBus for system-wide communication`);
          }
        }
        /**
         * Phase 3: Integrate with TimerConsolidationSystem and MasterAnimationCoordinator
         */
        integrateWithPerformanceSystems() {
          const year3000System2 = globalThis.year3000System;
          if (!year3000System2) {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Year3000System not available, skipping performance integration`);
            }
            return;
          }
          try {
            const timerSystem = year3000System2.timerConsolidationSystem;
            if (timerSystem) {
              timerSystem.registerTimer("sidebar-performance-monitor", 1e3, () => {
                this.updatePerformanceMetrics();
              });
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Integrated with TimerConsolidationSystem`);
              }
            }
            const animationCoordinator = year3000System2.enhancedMasterAnimationCoordinator;
            if (animationCoordinator) {
              animationCoordinator.registerFrameCallback(
                (deltaTime, timestamp) => {
                  this.bilateralConsciousnessFrameUpdate(deltaTime, timestamp);
                },
                "critical",
                "sidebar-bilateral-consciousness"
              );
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Integrated with EnhancedMasterAnimationCoordinator`);
              }
            }
          } catch (error) {
            console.error(`[${this.systemName}] Failed to integrate with performance systems:`, error);
          }
        }
        /**
         * Handle music beat events for consciousness synchronization
         */
        handleMusicBeat(payload) {
          if (!this.integrationEnabled) return;
          const beatData = {
            intensity: payload.intensity || 0.5,
            timestamp: payload.timestamp || Date.now(),
            bpm: payload.bpm || 120
          };
          this.sidebarOrchestrator.getBilateralState();
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Processed music beat:`, beatData);
          }
        }
        /**
         * Handle music energy changes for adaptive consciousness
         */
        handleMusicEnergy(payload) {
          if (!this.integrationEnabled) return;
          const energyLevel = payload.energy || 0.5;
          this.adjustPerformanceBudgets(0.5 + energyLevel * 0.5);
          if (this.interactiveFlow.isInitialized) {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Adapted consciousness to energy level: ${energyLevel}`);
            }
          }
        }
        /**
         * Handle performance threshold events
         */
        handlePerformanceThreshold(payload) {
          if (!this.integrationEnabled) return;
          if (payload.severity === "critical") {
            this.setSidebarSystemEnabled("interactiveFlow", false);
            this.setSidebarSystemEnabled("dimensionalNexus", false);
            this.performanceMetrics.healthStatus = "critical";
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Activated emergency performance mode`);
            }
          } else if (payload.severity === "warning" && this.performanceMetrics.healthStatus === "critical") {
            this.setSidebarSystemEnabled("dimensionalNexus", true);
            setTimeout(() => {
              this.setSidebarSystemEnabled("interactiveFlow", true);
            }, 2e3);
            this.performanceMetrics.healthStatus = "degraded";
          }
        }
        /**
         * Handle user navigation events for predictive consciousness
         */
        handleUserNavigation(payload) {
          if (!this.integrationEnabled) return;
          const navigationContext = {
            action: payload.action || "navigate",
            target: payload.target || "unknown",
            timestamp: payload.timestamp || Date.now()
          };
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Processing navigation context:`, navigationContext);
          }
        }
        /**
         * Bilateral consciousness frame update callback
         */
        bilateralConsciousnessFrameUpdate(deltaTime, timestamp) {
          if (!this.integrationEnabled) return;
          const leftState = this.leftSidebarConsciousness.getConsciousnessState();
          const rightState = this.rightSidebarConsciousness.getConsciousnessState();
          const leftTimestamp = timestamp;
          const rightTimestamp = timestamp;
          const syncMetrics = {
            leftLevel: leftState.level,
            rightLevel: rightState.level,
            timingDelta: Math.abs(leftTimestamp - rightTimestamp),
            frameTime: deltaTime
          };
          if (syncMetrics.timingDelta > 16.67) {
            this.publishEvent("sidebar:bilateral-desync-warning", {
              delta: syncMetrics.timingDelta,
              frameTime: deltaTime,
              timestamp
            });
          }
        }
        /**
         * Clean up all sidebar systems
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying sidebar systems integration`);
          }
          this.integrationEnabled = false;
          const year3000System2 = globalThis.year3000System;
          if (year3000System2?.timerConsolidationSystem) {
            year3000System2.timerConsolidationSystem.unregisterTimer("sidebar-performance-monitor");
          }
          const destructionOrder = this.calculateInitializationOrder().reverse();
          for (const systemName of destructionOrder) {
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.system.isInitialized) {
              try {
                systemDef.system._baseDestroy();
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Destroyed ${systemName}`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to destroy ${systemName}:`, error);
              }
            }
          }
          this.sidebarSystems.clear();
          this.performanceMetrics = {
            totalSystems: 0,
            activeSystems: 0,
            bilateralSyncEnabled: false,
            averageFrameTime: 0,
            totalMemoryUsage: 0,
            healthStatus: "healthy"
          };
          this.publishEvent("sidebar:integration-destroyed", {
            timestamp: Date.now()
          });
        }
      };
      __name(_SidebarSystemsIntegration, "SidebarSystemsIntegration");
      SidebarSystemsIntegration = _SidebarSystemsIntegration;
    }
  });

  // src-js/core/migration/SystemMigrationHelper.ts
  var _SystemMigrationHelper, SystemMigrationHelper;
  var init_SystemMigrationHelper = __esm({
    "src-js/core/migration/SystemMigrationHelper.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      _SystemMigrationHelper = class _SystemMigrationHelper {
        /**
         * Wrap an existing IManagedSystem implementation to work with UnifiedSystemBase
         * 
         * @param systemClass - The IManagedSystem class to wrap
         * @param args - Constructor arguments for the system
         * @returns A UnifiedSystemBase wrapper
         */
        static wrapIManagedSystem(systemClass, ...args) {
          return new class extends UnifiedSystemBase {
            constructor() {
              super();
              this.originalSystem = new systemClass(...args);
              this.systemName = this.originalSystem.constructor.name;
            }
            async initialize() {
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Migrating IManagedSystem initialization`);
              }
              await this.originalSystem.initialize();
            }
            destroy() {
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Migrating IManagedSystem destruction`);
              }
              this.originalSystem.destroy();
            }
            onAnimate(deltaTime) {
              this.originalSystem.updateAnimation(deltaTime);
            }
            async healthCheck() {
              return await this.originalSystem.healthCheck();
            }
            // Expose the original system for any needed access
            getOriginalSystem() {
              return this.originalSystem;
            }
            // Forward forceRepaint if it exists
            forceRepaint(reason) {
              if (this.originalSystem.forceRepaint) {
                this.originalSystem.forceRepaint(reason);
              } else {
                super.forceRepaint(reason);
              }
            }
          }();
        }
        /**
         * Wrap an existing BaseVisualSystem extension to work with UnifiedSystemBase
         * 
         * @param systemClass - The BaseVisualSystem class to wrap
         * @param args - Constructor arguments for the system
         * @returns A UnifiedSystemBase wrapper
         */
        static wrapBaseVisualSystem(systemClass, ...args) {
          return new class extends UnifiedSystemBase {
            constructor() {
              super();
              this.originalSystem = new systemClass(...args);
              this.systemName = this.originalSystem.constructor.name;
            }
            async initialize() {
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Migrating BaseVisualSystem initialization`);
              }
              await this.originalSystem.initialize();
            }
            destroy() {
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Migrating BaseVisualSystem destruction`);
              }
              this.originalSystem.destroy();
            }
            onAnimate(deltaTime) {
              this.originalSystem.onAnimate(deltaTime);
            }
            async healthCheck() {
              const isDestroyed = "isDestroyed" in this.originalSystem ? this.originalSystem.isDestroyed : false;
              const isHealthy = this.originalSystem.initialized && !isDestroyed;
              const issues = [];
              if (!this.originalSystem.initialized) {
                issues.push("System not initialized");
              }
              if (isDestroyed) {
                issues.push("System is destroyed");
              }
              const result = {
                healthy: isHealthy,
                ok: isHealthy,
                details: `${this.systemName} health check`,
                issues,
                system: this.systemName
              };
              return result;
            }
            // Expose the original system for any needed access
            getOriginalSystem() {
              return this.originalSystem;
            }
            // Forward forceRepaint if it exists
            forceRepaint(reason) {
              if (this.originalSystem.forceRepaint) {
                this.originalSystem.forceRepaint(reason);
              } else {
                super.forceRepaint(reason);
              }
            }
          }();
        }
        /**
         * Migrate a map of systems to UnifiedSystemBase
         * 
         * @param systems - Map of system name to system instance
         * @returns Map of system name to UnifiedSystemBase wrapper
         */
        static migrateSystemsMap(systems) {
          const migratedSystems = /* @__PURE__ */ new Map();
          for (const [name, system] of systems) {
            let migratedSystem;
            if (this.implementsIManagedSystem(system)) {
              migratedSystem = this.wrapIManagedSystem(system.constructor);
            } else if (this.extendsBaseVisualSystem(system)) {
              migratedSystem = this.wrapBaseVisualSystem(system.constructor);
            } else {
              console.warn(`[SystemMigrationHelper] Unknown system type for ${name}, skipping migration`);
              continue;
            }
            migratedSystems.set(name, migratedSystem);
          }
          return migratedSystems;
        }
        /**
         * Create a compatibility layer for systems that need gradual migration
         * 
         * @param originalSystem - The original system to wrap
         * @returns A UnifiedSystemBase wrapper with compatibility methods
         */
        static createCompatibilityLayer(originalSystem) {
          if (this.implementsIManagedSystem(originalSystem)) {
            return this.wrapIManagedSystem(originalSystem.constructor);
          } else if (this.extendsBaseVisualSystem(originalSystem)) {
            return this.wrapBaseVisualSystem(originalSystem.constructor);
          } else {
            throw new Error(`[SystemMigrationHelper] Unable to create compatibility layer for ${originalSystem.constructor.name}`);
          }
        }
        /**
         * Validate that a system migration was successful
         * 
         * @param originalSystem - The original system
         * @param migratedSystem - The migrated UnifiedSystemBase
         * @returns Validation result
         */
        static validateMigration(originalSystem, migratedSystem) {
          const issues = [];
          if (typeof migratedSystem.initialize !== "function") {
            issues.push("Missing initialize method");
          }
          if (typeof migratedSystem.destroy !== "function") {
            issues.push("Missing destroy method");
          }
          if (typeof migratedSystem.onAnimate !== "function") {
            issues.push("Missing onAnimate method");
          }
          if (typeof migratedSystem.healthCheck !== "function") {
            issues.push("Missing healthCheck method");
          }
          if (migratedSystem.name !== originalSystem.constructor.name) {
            issues.push(`System name mismatch: expected ${originalSystem.constructor.name}, got ${migratedSystem.name}`);
          }
          return {
            success: issues.length === 0,
            issues
          };
        }
        // =========================================================================
        // PRIVATE UTILITY METHODS
        // =========================================================================
        /**
         * Check if an object implements the IManagedSystem interface
         */
        static implementsIManagedSystem(obj) {
          return obj && typeof obj.initialize === "function" && typeof obj.destroy === "function" && typeof obj.updateAnimation === "function" && typeof obj.healthCheck === "function" && typeof obj.initialized === "boolean";
        }
        /**
         * Check if an object extends the BaseVisualSystem class
         */
        static extendsBaseVisualSystem(obj) {
          return obj && typeof obj.initialize === "function" && typeof obj.destroy === "function" && typeof obj.onAnimate === "function" && typeof obj.initialized === "boolean";
        }
        /**
         * Generate a migration report for a collection of systems
         */
        static generateMigrationReport(systems) {
          const report = {
            totalSystems: systems.size,
            migratable: 0,
            imanagedSystems: 0,
            baseVisualSystems: 0,
            unknownSystems: 0,
            systemDetails: []
          };
          for (const [name, system] of systems) {
            let type = "Unknown";
            let migratable = false;
            if (this.implementsIManagedSystem(system)) {
              type = "IManagedSystem";
              migratable = true;
              report.imanagedSystems++;
            } else if (this.extendsBaseVisualSystem(system)) {
              type = "BaseVisualSystem";
              migratable = true;
              report.baseVisualSystems++;
            } else {
              type = "Unknown";
              report.unknownSystems++;
            }
            if (migratable) {
              report.migratable++;
            }
            report.systemDetails.push({
              name,
              type,
              migratable
            });
          }
          return report;
        }
      };
      __name(_SystemMigrationHelper, "SystemMigrationHelper");
      SystemMigrationHelper = _SystemMigrationHelper;
    }
  });

  // src-js/core/registry/UnifiedSystemRegistry.ts
  var _UnifiedSystemRegistry, UnifiedSystemRegistry;
  var init_UnifiedSystemRegistry = __esm({
    "src-js/core/registry/UnifiedSystemRegistry.ts"() {
      "use strict";
      init_SystemMigrationHelper();
      _UnifiedSystemRegistry = class _UnifiedSystemRegistry {
        constructor(config = {}) {
          this.systems = /* @__PURE__ */ new Map();
          this.dependencies = /* @__PURE__ */ new Map();
          this.initializationOrder = [];
          this.initialized = false;
          this.healthCheckTimer = null;
          this.config = {
            enableDebug: config.enableDebug || false,
            healthCheckInterval: config.healthCheckInterval || 3e4,
            // 30 seconds
            maxInitializationTime: config.maxInitializationTime || 1e4
            // 10 seconds
          };
          if (this.config.enableDebug) {
            console.log("[UnifiedSystemRegistry] Created with config:", this.config);
          }
        }
        /**
         * Register a system with optional dependencies
         * 
         * @param name - Unique name for the system
         * @param system - UnifiedSystemBase instance
         * @param dependencies - Array of system names this system depends on
         */
        register(name, system, dependencies = []) {
          if (this.systems.has(name)) {
            console.warn(`[UnifiedSystemRegistry] System ${name} already registered, replacing`);
          }
          this.systems.set(name, system);
          this.dependencies.set(name, dependencies);
          this.calculateInitializationOrder();
          if (this.config.enableDebug) {
            console.log(`[UnifiedSystemRegistry] Registered system: ${name}`, {
              dependencies,
              totalSystems: this.systems.size
            });
          }
        }
        /**
         * Register a legacy system using migration helper
         * 
         * @param name - Unique name for the system
         * @param legacySystem - Legacy system (IManagedSystem or BaseVisualSystem)
         * @param dependencies - Array of system names this system depends on
         */
        registerLegacySystem(name, legacySystem, dependencies = []) {
          try {
            const migratedSystem = SystemMigrationHelper.createCompatibilityLayer(legacySystem);
            this.register(name, migratedSystem, dependencies);
            if (this.config.enableDebug) {
              console.log(`[UnifiedSystemRegistry] Migrated and registered legacy system: ${name}`);
            }
          } catch (error) {
            console.error(`[UnifiedSystemRegistry] Failed to migrate legacy system ${name}:`, error);
          }
        }
        /**
         * Unregister a system
         * 
         * @param name - System name to unregister
         */
        unregister(name) {
          if (!this.systems.has(name)) {
            console.warn(`[UnifiedSystemRegistry] System ${name} not found for unregistration`);
            return;
          }
          const system = this.systems.get(name);
          if (system.isInitialized && !system.isDestroyed) {
            system._baseDestroy();
          }
          this.systems.delete(name);
          this.dependencies.delete(name);
          this.calculateInitializationOrder();
          if (this.config.enableDebug) {
            console.log(`[UnifiedSystemRegistry] Unregistered system: ${name}`);
          }
        }
        /**
         * Initialize all registered systems in dependency order
         */
        async initializeAll() {
          if (this.initialized) {
            console.warn("[UnifiedSystemRegistry] Already initialized");
            return { success: [], failed: [], skipped: [] };
          }
          const startTime = performance.now();
          const results = {
            success: [],
            failed: [],
            skipped: []
          };
          if (this.config.enableDebug) {
            console.log("[UnifiedSystemRegistry] Starting initialization of all systems");
            console.log("Initialization order:", this.initializationOrder);
          }
          for (const systemName of this.initializationOrder) {
            const system = this.systems.get(systemName);
            if (!system) {
              results.skipped.push(systemName);
              continue;
            }
            try {
              const initStartTime = performance.now();
              await system._baseInitialize();
              const initTime = performance.now() - initStartTime;
              results.success.push(systemName);
              if (this.config.enableDebug) {
                console.log(`[UnifiedSystemRegistry] \u2713 ${systemName} initialized (${initTime.toFixed(2)}ms)`);
              }
              if (initTime > this.config.maxInitializationTime) {
                console.warn(`[UnifiedSystemRegistry] System ${systemName} took ${initTime.toFixed(2)}ms to initialize (threshold: ${this.config.maxInitializationTime}ms)`);
              }
            } catch (error) {
              console.error(`[UnifiedSystemRegistry] \u2717 Failed to initialize ${systemName}:`, error);
              results.failed.push(systemName);
            }
          }
          this.initialized = true;
          this.startHealthMonitoring();
          const totalTime = performance.now() - startTime;
          if (this.config.enableDebug) {
            console.log(`[UnifiedSystemRegistry] Initialization complete (${totalTime.toFixed(2)}ms)`, results);
          }
          return results;
        }
        /**
         * Destroy all systems in reverse initialization order
         */
        destroyAll() {
          if (!this.initialized) {
            console.warn("[UnifiedSystemRegistry] Not initialized, nothing to destroy");
            return;
          }
          this.stopHealthMonitoring();
          const reverseOrder = [...this.initializationOrder].reverse();
          if (this.config.enableDebug) {
            console.log("[UnifiedSystemRegistry] Destroying all systems in reverse order");
          }
          for (const systemName of reverseOrder) {
            const system = this.systems.get(systemName);
            if (system && system.isInitialized && !system.isDestroyed) {
              try {
                system._baseDestroy();
                if (this.config.enableDebug) {
                  console.log(`[UnifiedSystemRegistry] \u2713 ${systemName} destroyed`);
                }
              } catch (error) {
                console.error(`[UnifiedSystemRegistry] \u2717 Failed to destroy ${systemName}:`, error);
              }
            }
          }
          this.initialized = false;
          if (this.config.enableDebug) {
            console.log("[UnifiedSystemRegistry] All systems destroyed");
          }
        }
        /**
         * Get a system by name
         * 
         * @param name - System name
         * @returns System instance or undefined
         */
        getSystem(name) {
          return this.systems.get(name);
        }
        /**
         * Get all system names
         */
        getSystemNames() {
          return Array.from(this.systems.keys());
        }
        /**
         * Get initialization order
         */
        getInitializationOrder() {
          return [...this.initializationOrder];
        }
        /**
         * Check if a system is registered
         */
        hasSystem(name) {
          return this.systems.has(name);
        }
        /**
         * Get system count
         */
        getSystemCount() {
          return this.systems.size;
        }
        /**
         * Perform health check on all systems
         */
        async performHealthCheck() {
          const results = /* @__PURE__ */ new Map();
          const healthy = [];
          const unhealthy = [];
          for (const [name, system] of this.systems) {
            if (!system.isInitialized || system.isDestroyed) {
              const result = {
                healthy: false,
                ok: false,
                details: `System ${name} not initialized or destroyed`,
                issues: ["System not ready"],
                system: name
              };
              results.set(name, result);
              unhealthy.push(name);
              continue;
            }
            try {
              const healthResult = await system.healthCheck();
              results.set(name, healthResult);
              if (healthResult.ok) {
                healthy.push(name);
              } else {
                unhealthy.push(name);
              }
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : String(error);
              const result = {
                healthy: false,
                ok: false,
                details: `Health check failed: ${errorMessage}`,
                issues: [errorMessage],
                system: name
              };
              results.set(name, result);
              unhealthy.push(name);
            }
          }
          return { healthy, unhealthy, results };
        }
        // =========================================================================
        // PRIVATE METHODS
        // =========================================================================
        /**
         * Calculate initialization order using topological sort
         */
        calculateInitializationOrder() {
          const visited = /* @__PURE__ */ new Set();
          const visiting = /* @__PURE__ */ new Set();
          const order = [];
          const visit = /* @__PURE__ */ __name((systemName) => {
            if (visiting.has(systemName)) {
              throw new Error(`Circular dependency detected involving: ${systemName}`);
            }
            if (visited.has(systemName)) {
              return;
            }
            visiting.add(systemName);
            const deps = this.dependencies.get(systemName) || [];
            for (const dep of deps) {
              if (!this.systems.has(dep)) {
                console.warn(`[UnifiedSystemRegistry] Dependency ${dep} not found for system ${systemName}`);
                continue;
              }
              visit(dep);
            }
            visiting.delete(systemName);
            visited.add(systemName);
            order.push(systemName);
          }, "visit");
          try {
            for (const systemName of this.systems.keys()) {
              visit(systemName);
            }
            this.initializationOrder = order;
            if (this.config.enableDebug) {
              console.log("[UnifiedSystemRegistry] Calculated initialization order:", order);
            }
          } catch (error) {
            console.error("[UnifiedSystemRegistry] Failed to calculate initialization order:", error);
            this.initializationOrder = Array.from(this.systems.keys());
          }
        }
        /**
         * Start periodic health monitoring
         */
        startHealthMonitoring() {
          if (this.healthCheckTimer) {
            clearInterval(this.healthCheckTimer);
          }
          this.healthCheckTimer = setInterval(async () => {
            const healthResult = await this.performHealthCheck();
            if (healthResult.unhealthy.length > 0) {
              console.warn("[UnifiedSystemRegistry] Unhealthy systems detected:", healthResult.unhealthy);
              if (this.config.enableDebug) {
                for (const unhealthySystem of healthResult.unhealthy) {
                  const result = healthResult.results.get(unhealthySystem);
                  console.warn(`[UnifiedSystemRegistry] ${unhealthySystem} health issues:`, result?.issues);
                }
              }
            }
          }, this.config.healthCheckInterval);
        }
        /**
         * Stop health monitoring
         */
        stopHealthMonitoring() {
          if (this.healthCheckTimer) {
            clearInterval(this.healthCheckTimer);
            this.healthCheckTimer = null;
          }
        }
      };
      __name(_UnifiedSystemRegistry, "UnifiedSystemRegistry");
      UnifiedSystemRegistry = _UnifiedSystemRegistry;
    }
  });

  // src-js/visual/ui-effects/RightSidebarConsciousnessSystemUnified.ts
  var _RightSidebarConsciousnessSystemUnified, RightSidebarConsciousnessSystemUnified;
  var init_RightSidebarConsciousnessSystemUnified = __esm({
    "src-js/visual/ui-effects/RightSidebarConsciousnessSystemUnified.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_SidebarPerformanceCoordinator();
      _RightSidebarConsciousnessSystemUnified = class _RightSidebarConsciousnessSystemUnified extends UnifiedSystemBase {
        constructor(config, coordinator) {
          super(config);
          // Current → target state for smooth lerp
          this.currentBeatIntensity = 0;
          this.targetBeatIntensity = 0;
          this.currentHueShift = 0;
          // degrees
          this.targetHueShift = 0;
          // Lerp smoothing factors
          this.INTENSITY_LERP = 0.25;
          this.HUE_LERP = 0.05;
          // Performance tracking
          this.lastTimestamp = performance.now();
          this.animationFrameCount = 0;
          this.totalAnimationTime = 0;
          this.coordinator = coordinator || SidebarPerformanceCoordinator.getInstance({
            enableDebug: this.config.enableDebug,
            onFlushComplete: /* @__PURE__ */ __name(() => {
              this.performanceAnalyzer?.emitTrace?.(
                "[RightSidebarConsciousnessSystemUnified] Coordinator flush completed"
              );
            }, "onFlushComplete")
          });
        }
        /**
         * Initialize the system and subscribe to music events
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log("[RightSidebarConsciousnessSystemUnified] Initializing...");
          }
          this.registerCSSVariableGroup("ui-state", "high");
          this.registerCSSVariableGroup("visual-effects", "normal");
          this.subscribeToEvent("music:beat", (payload) => this._handleBeat(payload));
          this.subscribeToEvent("music:energy", (payload) => this._handleEnergy(payload));
          this.registerAnimation(60);
          if (this.config.enableDebug) {
            console.log("[RightSidebarConsciousnessSystemUnified] Initialized successfully");
          }
        }
        /**
         * Clean up resources
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log("[RightSidebarConsciousnessSystemUnified] Destroying...");
          }
          if (this.config.enableDebug) {
            console.log("[RightSidebarConsciousnessSystemUnified] Destroyed successfully");
          }
        }
        /**
         * Animation frame callback
         */
        onAnimate(deltaTime) {
          this.trackPerformance("animate", () => {
            const startTime = performance.now();
            this._updateAnimationState(deltaTime);
            this._applyCSSVariables();
            const frameTime = performance.now() - startTime;
            this.totalAnimationTime += frameTime;
            this.animationFrameCount++;
            if (frameTime > 1 && this.config.enableDebug) {
              console.warn(`[RightSidebarConsciousnessSystemUnified] Frame took ${frameTime.toFixed(2)}ms (budget: 1ms)`);
            }
          });
        }
        /**
         * Health check implementation
         */
        async healthCheck() {
          const issues = [];
          if (!this.coordinator) {
            issues.push("SidebarPerformanceCoordinator not available");
          }
          const avgFrameTime = this.animationFrameCount > 0 ? this.totalAnimationTime / this.animationFrameCount : 0;
          if (avgFrameTime > 1) {
            issues.push(`Average frame time ${avgFrameTime.toFixed(2)}ms exceeds 1ms budget`);
          }
          if (!this.cssVariableBatcher) {
            issues.push("CSS variable batcher not available");
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `System health: ${issues.length === 0 ? "healthy" : "issues detected"}`,
            issues,
            system: "RightSidebarConsciousnessSystemUnified"
          };
        }
        // =========================================================================
        // PRIVATE METHODS
        // =========================================================================
        /**
         * Handle beat events from music system
         */
        _handleBeat(payload) {
          this.targetBeatIntensity = payload.intensity;
          if (this.config.enableDebug) {
            console.log(`[RightSidebarConsciousnessSystemUnified] Beat intensity: ${payload.intensity}`);
          }
        }
        /**
         * Handle energy events from music system
         */
        _handleEnergy(payload) {
          this.targetHueShift = payload.energy * 360;
          if (this.config.enableDebug) {
            console.log(`[RightSidebarConsciousnessSystemUnified] Energy hue shift: ${this.targetHueShift.toFixed(1)}\xB0`);
          }
        }
        /**
         * Update animation state with smooth lerping
         */
        _updateAnimationState(deltaTime) {
          this.currentBeatIntensity += (this.targetBeatIntensity - this.currentBeatIntensity) * this.INTENSITY_LERP;
          this.currentHueShift += (this.targetHueShift - this.currentHueShift) * this.HUE_LERP;
          this.currentBeatIntensity = Math.max(0, Math.min(1, this.currentBeatIntensity));
          this.currentHueShift = this.currentHueShift % 360;
          this.lastTimestamp = performance.now();
        }
        /**
         * Apply CSS variables using the unified system with priority-based groups
         */
        _applyCSSVariables() {
          this.updateCSSVariableGroup("ui-state", {
            "--sn-sidebar-beat-intensity": this.currentBeatIntensity.toFixed(3),
            "--sn-sidebar-consciousness-level": (this.currentBeatIntensity * 0.8 + 0.2).toFixed(3)
          });
          this.updateCSSVariableGroup("visual-effects", {
            "--sn-sidebar-hue-shift": `${this.currentHueShift.toFixed(1)}deg`,
            "--sn-sidebar-energy-pulse": Math.sin(this.currentBeatIntensity * Math.PI * 2).toFixed(3)
          });
          this.coordinator.queueUpdate("--sn-sidebar-beat-intensity", this.currentBeatIntensity.toFixed(3));
          this.coordinator.queueUpdate("--sn-sidebar-hue-shift", `${this.currentHueShift.toFixed(1)}deg`);
        }
        /**
         * Get current system metrics for debugging
         */
        getMetrics() {
          return {
            beatIntensity: this.currentBeatIntensity,
            hueShift: this.currentHueShift,
            averageFrameTime: this.animationFrameCount > 0 ? this.totalAnimationTime / this.animationFrameCount : 0,
            frameCount: this.animationFrameCount
          };
        }
        /**
         * Force repaint for settings changes
         */
        forceRepaint(reason) {
          super.forceRepaint(reason);
          this.currentBeatIntensity = 0;
          this.targetBeatIntensity = 0;
          this.currentHueShift = 0;
          this.targetHueShift = 0;
          this._applyCSSVariables();
          if (this.config.enableDebug) {
            console.log(`[RightSidebarConsciousnessSystemUnified] Force repaint: ${reason}`);
          }
        }
      };
      __name(_RightSidebarConsciousnessSystemUnified, "RightSidebarConsciousnessSystemUnified");
      RightSidebarConsciousnessSystemUnified = _RightSidebarConsciousnessSystemUnified;
    }
  });

  // src-js/core/integration/UnifiedSystemIntegration.ts
  var _UnifiedSystemIntegration, UnifiedSystemIntegration;
  var init_UnifiedSystemIntegration = __esm({
    "src-js/core/integration/UnifiedSystemIntegration.ts"() {
      "use strict";
      init_UnifiedSystemRegistry();
      init_RightSidebarConsciousnessSystemUnified();
      init_OrganicBeatSyncConsciousness();
      _UnifiedSystemIntegration = class _UnifiedSystemIntegration {
        constructor(year3000System2) {
          this.migrationQueue = /* @__PURE__ */ new Map();
          this.initialized = false;
          this.year3000System = year3000System2;
          this.unifiedRegistry = new UnifiedSystemRegistry({
            enableDebug: year3000System2.YEAR3000_CONFIG.enableDebug,
            healthCheckInterval: 6e4,
            // 1 minute
            maxInitializationTime: 5e3
            // 5 seconds
          });
          if (year3000System2.YEAR3000_CONFIG.enableDebug) {
            console.log("[UnifiedSystemIntegration] Created integration layer");
          }
        }
        /**
         * Initialize the integration layer and begin migration
         */
        async initialize() {
          if (this.initialized) {
            console.warn("[UnifiedSystemIntegration] Already initialized");
            return;
          }
          if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
            console.log("[UnifiedSystemIntegration] Starting integration initialization");
          }
          await this.migrateExistingSystems();
          const results = await this.unifiedRegistry.initializeAll();
          await this.replaceSystemsInYear3000();
          this.setupHealthMonitoring();
          this.initialized = true;
          if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
            console.log("[UnifiedSystemIntegration] Integration complete:", {
              success: results.success.length,
              failed: results.failed.length,
              skipped: results.skipped.length
            });
          }
        }
        /**
         * Migrate existing systems to unified architecture
         */
        async migrateExistingSystems() {
          if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
            console.log("[UnifiedSystemIntegration] Starting system migration");
          }
          if (this.year3000System.sidebarSystemsIntegration) {
            try {
              const unifiedSidebarSystem = new RightSidebarConsciousnessSystemUnified(
                this.year3000System.YEAR3000_CONFIG
              );
              this.unifiedRegistry.register(
                "RightSidebarConsciousnessSystem",
                unifiedSidebarSystem,
                []
                // No dependencies for now
              );
              this.migrationQueue.set("sidebarSystemsIntegration", unifiedSidebarSystem);
              if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
                console.log("[UnifiedSystemIntegration] \u2713 Migrated SidebarConsciousnessSystem");
              }
            } catch (error) {
              console.error("[UnifiedSystemIntegration] Failed to migrate SidebarConsciousnessSystem:", error);
            }
          }
          if (this.year3000System.beatSyncVisualSystem) {
            try {
              const organicBeatSyncSystem = new OrganicBeatSyncConsciousness(
                this.year3000System.YEAR3000_CONFIG
              );
              this.unifiedRegistry.register(
                "OrganicBeatSyncConsciousness",
                organicBeatSyncSystem,
                []
                // No dependencies for now
              );
              this.migrationQueue.set("beatSyncVisualSystem", organicBeatSyncSystem);
              if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
                console.log("[UnifiedSystemIntegration] \u2713 Migrated BeatSyncVisualSystem to OrganicBeatSyncConsciousness");
              }
            } catch (error) {
              console.error("[UnifiedSystemIntegration] Failed to migrate BeatSyncVisualSystem:", error);
            }
          }
          const systemsToMigrate = [
            {
              name: "LightweightParticleSystem",
              system: this.year3000System.lightweightParticleSystem,
              property: "lightweightParticleSystem",
              dependencies: ["BeatSyncVisualSystem"]
            },
            {
              name: "InteractionTrackingSystem",
              system: this.year3000System.interactionTrackingSystem,
              property: "interactionTrackingSystem",
              dependencies: ["RightSidebarConsciousnessSystem"]
            }
          ];
          for (const { name, system, property, dependencies } of systemsToMigrate) {
            if (system) {
              try {
                this.unifiedRegistry.registerLegacySystem(name, system, dependencies);
                this.migrationQueue.set(property, this.unifiedRegistry.getSystem(name));
                if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
                  console.log(`[UnifiedSystemIntegration] \u2713 Migrated ${name}`);
                }
              } catch (error) {
                console.error(`[UnifiedSystemIntegration] Failed to migrate ${name}:`, error);
              }
            }
          }
        }
        /**
         * Replace systems in Year3000System with unified versions
         */
        async replaceSystemsInYear3000() {
          if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
            console.log("[UnifiedSystemIntegration] Replacing systems in Year3000System");
          }
          for (const [property, unifiedSystem] of this.migrationQueue) {
            try {
              const oldSystem = this.year3000System[property];
              if (oldSystem && typeof oldSystem.destroy === "function") {
                await oldSystem.destroy();
              }
              this.year3000System[property] = unifiedSystem;
              if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
                console.log(`[UnifiedSystemIntegration] \u2713 Replaced ${property}`);
              }
            } catch (error) {
              console.error(`[UnifiedSystemIntegration] Failed to replace ${property}:`, error);
            }
          }
          if (this.year3000System.enhancedMasterAnimationCoordinator) {
            await this.updateAnimationRegistrations();
          }
        }
        /**
         * Update animation system registrations for unified systems
         */
        async updateAnimationRegistrations() {
          if (!this.year3000System.enhancedMasterAnimationCoordinator) return;
          const animationSystems = [
            {
              name: "BeatSyncVisualSystem",
              system: this.year3000System.beatSyncVisualSystem,
              priority: "critical",
              targetFPS: 60
            },
            {
              name: "RightSidebarConsciousnessSystem",
              system: this.year3000System.sidebarSystemsIntegration,
              priority: "normal",
              targetFPS: 60
            },
            {
              name: "LightweightParticleSystem",
              system: this.year3000System.lightweightParticleSystem,
              priority: "background",
              targetFPS: 30
            }
          ];
          for (const { name, system, priority, targetFPS } of animationSystems) {
            if (system && typeof system.onAnimate === "function") {
              try {
                try {
                  this.year3000System.enhancedMasterAnimationCoordinator.unregisterAnimationSystem(name);
                } catch (e) {
                }
                this.year3000System.enhancedMasterAnimationCoordinator.registerAnimationSystem(
                  name,
                  system,
                  priority,
                  targetFPS
                );
                if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
                  console.log(`[UnifiedSystemIntegration] \u2713 Re-registered ${name} with animation conductor`);
                }
              } catch (error) {
                console.error(`[UnifiedSystemIntegration] Failed to re-register ${name}:`, error);
              }
            }
          }
        }
        /**
         * Set up health monitoring integration
         */
        setupHealthMonitoring() {
          if (!this.year3000System.systemHealthMonitor) {
            return;
          }
          const unifiedHealthCheck = /* @__PURE__ */ __name(async () => {
            const healthResult = await this.unifiedRegistry.performHealthCheck();
            const result = {
              healthy: healthResult.unhealthy.length === 0,
              ok: healthResult.unhealthy.length === 0,
              details: `Unified systems: ${healthResult.healthy.length} healthy, ${healthResult.unhealthy.length} unhealthy`,
              issues: healthResult.unhealthy.length > 0 ? healthResult.unhealthy : [],
              system: "UnifiedSystemIntegration"
            };
            return result;
          }, "unifiedHealthCheck");
          const healthCheckObject = {
            healthCheck: unifiedHealthCheck,
            initialized: true,
            systemName: "UnifiedSystemRegistry",
            initialize: /* @__PURE__ */ __name(async () => {
            }, "initialize"),
            updateAnimation: /* @__PURE__ */ __name(() => {
            }, "updateAnimation"),
            destroy: /* @__PURE__ */ __name(() => {
            }, "destroy")
          };
          try {
            this.year3000System.systemHealthMonitor.registerSystem(
              "UnifiedSystemRegistry",
              healthCheckObject
            );
            if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
              console.log("[UnifiedSystemIntegration] \u2713 Health monitoring integration set up");
            }
          } catch (error) {
            console.error("[UnifiedSystemIntegration] Failed to set up health monitoring:", error);
          }
        }
        /**
         * Get the unified system registry
         */
        getRegistry() {
          return this.unifiedRegistry;
        }
        /**
         * Get system by name from unified registry
         */
        getSystem(name) {
          return this.unifiedRegistry.getSystem(name);
        }
        /**
         * Get health status of all unified systems
         */
        async getHealthStatus() {
          return await this.unifiedRegistry.performHealthCheck();
        }
        /**
         * Destroy the integration layer
         */
        async destroy() {
          if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
            console.log("[UnifiedSystemIntegration] Destroying integration layer");
          }
          this.unifiedRegistry.destroyAll();
          this.migrationQueue.clear();
          this.initialized = false;
          if (this.year3000System.YEAR3000_CONFIG.enableDebug) {
            console.log("[UnifiedSystemIntegration] Integration layer destroyed");
          }
        }
      };
      __name(_UnifiedSystemIntegration, "UnifiedSystemIntegration");
      UnifiedSystemIntegration = _UnifiedSystemIntegration;
    }
  });

  // src-js/types/systemCreationStrategy.ts
  var _SystemCreationError, SystemCreationError, _DependencyValidationError, DependencyValidationError, _StrategySelectionError, StrategySelectionError;
  var init_systemCreationStrategy = __esm({
    "src-js/types/systemCreationStrategy.ts"() {
      "use strict";
      _SystemCreationError = class _SystemCreationError extends Error {
        constructor(message, systemKey, strategy, context, cause) {
          super(message);
          this.systemKey = systemKey;
          this.strategy = strategy;
          this.context = context;
          this.cause = cause;
          this.name = "SystemCreationError";
        }
      };
      __name(_SystemCreationError, "SystemCreationError");
      SystemCreationError = _SystemCreationError;
      _DependencyValidationError = class _DependencyValidationError extends SystemCreationError {
        constructor(systemKey, strategy, missingDependencies, context) {
          super(
            `Missing required dependencies for ${systemKey}: ${missingDependencies.join(", ")}`,
            systemKey,
            strategy,
            context
          );
          this.missingDependencies = missingDependencies;
          this.name = "DependencyValidationError";
        }
      };
      __name(_DependencyValidationError, "DependencyValidationError");
      DependencyValidationError = _DependencyValidationError;
      _StrategySelectionError = class _StrategySelectionError extends Error {
        constructor(systemKey, criteria, message = `No suitable creation strategy found for system: ${systemKey}`) {
          super(message);
          this.systemKey = systemKey;
          this.criteria = criteria;
          this.name = "StrategySelectionError";
        }
      };
      __name(_StrategySelectionError, "StrategySelectionError");
      StrategySelectionError = _StrategySelectionError;
    }
  });

  // src-js/core/creation/SystemCreationStrategies.ts
  var _BaseCreationStrategy, BaseCreationStrategy, _StandardConstructorStrategy, StandardConstructorStrategy, _EventDrivenCreationStrategy, EventDrivenCreationStrategy, _ObjectDependenciesStrategy, ObjectDependenciesStrategy, _SystemCreationStrategyRegistry, SystemCreationStrategyRegistry, globalSystemCreationRegistry;
  var init_SystemCreationStrategies = __esm({
    "src-js/core/creation/SystemCreationStrategies.ts"() {
      "use strict";
      init_EventBus();
      init_UnifiedDebugManager();
      init_systemCreationStrategy();
      _BaseCreationStrategy = class _BaseCreationStrategy {
        constructor() {
          this.systemConfigs = /* @__PURE__ */ new Map();
        }
        /**
         * Validate dependencies before creation
         */
        validateDependencies(context) {
          const required = this.getRequiredDependencies(context.systemKey);
          const optional = this.getOptionalDependencies(context.systemKey);
          const missing = [];
          const warnings = [];
          for (const dep of required) {
            if (!(dep in context.dependencies) || !context.dependencies[dep]) {
              missing.push(dep);
            }
          }
          for (const dep of optional) {
            if (!(dep in context.dependencies) || !context.dependencies[dep]) {
              warnings.push(`Optional dependency missing: ${dep}`);
            }
          }
          return {
            valid: missing.length === 0,
            missing,
            warnings
          };
        }
        /**
         * Get required dependencies for system
         */
        getRequiredDependencies(systemKey) {
          const config = this.systemConfigs.get(systemKey);
          return config?.requiredDependencies || [];
        }
        /**
         * Get optional dependencies for system
         */
        getOptionalDependencies(systemKey) {
          const config = this.systemConfigs.get(systemKey);
          return config?.optionalDependencies || [];
        }
        /**
         * Register system configuration
         */
        registerSystemConfig(config) {
          this.systemConfigs.set(config.systemKey, config);
        }
        /**
         * Create base result structure
         */
        createBaseResult(system, context, startTime, error) {
          const endTime = performance.now();
          const creationTime = endTime - startTime;
          return {
            system,
            success: !error && system !== null,
            creationTime,
            strategy: this.getStrategyName(),
            injectedDependencies: Object.keys(context.dependencies),
            warnings: [],
            error: error || void 0,
            metadata: {
              requiresInitialization: true,
              pendingDependencies: [],
              context
            }
          };
        }
      };
      __name(_BaseCreationStrategy, "BaseCreationStrategy");
      BaseCreationStrategy = _BaseCreationStrategy;
      _StandardConstructorStrategy = class _StandardConstructorStrategy extends BaseCreationStrategy {
        constructor() {
          super();
          this.registerKnownSystems();
        }
        getStrategyName() {
          return "StandardConstructor";
        }
        canCreate(context) {
          const config = this.systemConfigs.get(context.systemKey);
          return config !== void 0 && !config.creationPreferences.eventDriven;
        }
        getEstimatedCreationTime(context) {
          return 10;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const validation = this.validateDependencies(context);
            if (!validation.valid && context.preferences.validateDependencies !== false) {
              throw new DependencyValidationError(
                context.systemKey,
                this.getStrategyName(),
                validation.missing,
                context
              );
            }
            const params = this.getConstructorParameters(context);
            const system = new SystemClass(...params);
            const result = this.createBaseResult(system, context, startTime);
            result.warnings = validation.warnings;
            Y3K?.debug?.log("StandardConstructorStrategy", `Created ${context.systemKey}`, {
              creationTime: result.creationTime,
              parametersUsed: params.length
            });
            return result;
          } catch (error) {
            const result = this.createBaseResult(null, context, startTime, error);
            Y3K?.debug?.error("StandardConstructorStrategy", `Failed to create ${context.systemKey}:`, error);
            return result;
          }
        }
        /**
         * Get constructor parameters based on system configuration
         */
        getConstructorParameters(context) {
          const config = this.systemConfigs.get(context.systemKey);
          if (!config?.constructorMapping) {
            return this.getStandardParameters(context);
          }
          const params = [];
          const { parameterNames, dependencyMapping } = config.constructorMapping;
          for (const paramName of parameterNames) {
            const depKey = dependencyMapping[paramName] || paramName;
            switch (depKey) {
              case "config":
                params.push(context.config);
                break;
              case "utils":
                params.push(context.utils);
                break;
              case "performanceAnalyzer":
                params.push(context.dependencies.performanceAnalyzer);
                break;
              case "settingsManager":
                params.push(context.dependencies.settingsManager);
                break;
              case "musicSyncService":
                params.push(context.dependencies.musicSyncService);
                break;
              case "year3000System":
                params.push(context.dependencies.year3000System);
                break;
              case "cssVariableBatcher":
                params.push(context.dependencies.cssVariableBatcher);
                break;
              case "performanceCoordinator":
                params.push(context.dependencies.performanceCoordinator);
                break;
              default:
                params.push(void 0);
            }
          }
          return params;
        }
        /**
         * Get standard parameters for systems without explicit configuration
         */
        getStandardParameters(context) {
          return [
            context.config,
            context.utils,
            context.dependencies.performanceAnalyzer,
            context.dependencies.musicSyncService,
            context.dependencies.settingsManager,
            context.dependencies.year3000System
          ];
        }
        /**
         * Register known system configurations
         */
        registerKnownSystems() {
          this.registerSystemConfig({
            systemKey: "ColorHarmonyEngine",
            requiredDependencies: ["config", "utils", "performanceAnalyzer", "settingsManager"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "utils", "performanceAnalyzer", "settingsManager"],
              dependencyMapping: {
                "config": "config",
                "utils": "utils",
                "performanceAnalyzer": "performanceAnalyzer",
                "settingsManager": "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "EnhancedMasterAnimationCoordinator",
            requiredDependencies: ["config", "performanceCoordinator"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "performanceCoordinator"],
              dependencyMapping: {
                "config": "config",
                "performanceCoordinator": "performanceCoordinator"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedPerformanceCoordinator",
            requiredDependencies: ["config"],
            optionalDependencies: ["performanceAnalyzer"],
            constructorMapping: {
              parameterNames: ["config", "performanceAnalyzer"],
              dependencyMapping: {
                "config": "config",
                "performanceAnalyzer": "performanceAnalyzer"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          const simpleSystemKeys = [
            "DeviceCapabilityDetector",
            "PerformanceAnalyzer",
            "CSSVariableBatcher",
            "SettingsManager"
          ];
          for (const systemKey of simpleSystemKeys) {
            this.registerSystemConfig({
              systemKey,
              requiredDependencies: [],
              optionalDependencies: [],
              constructorMapping: {
                parameterNames: [],
                dependencyMapping: {}
              },
              creationPreferences: {
                useSingleton: false,
                lazyInit: false,
                eventDriven: false,
                builderPattern: false
              }
            });
          }
          this.registerSystemConfig({
            systemKey: "TimerConsolidationSystem",
            requiredDependencies: [],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [],
              dependencyMapping: {}
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "GlassmorphismManager",
            requiredDependencies: ["config", "utils", "cssVariableBatcher", "performanceAnalyzer", "settingsManager"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "utils", "cssVariableBatcher", "performanceAnalyzer", "settingsManager"],
              dependencyMapping: {
                "config": "config",
                "utils": "utils",
                "cssVariableBatcher": "cssVariableBatcher",
                "performanceAnalyzer": "performanceAnalyzer",
                "settingsManager": "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "Card3DManager",
            requiredDependencies: ["performanceAnalyzer", "settingsManager", "utils"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["performanceAnalyzer", "settingsManager", "utils"],
              dependencyMapping: {
                "performanceAnalyzer": "performanceAnalyzer",
                "settingsManager": "settingsManager",
                "utils": "utils"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedCSSVariableManager",
            requiredDependencies: ["cssVariableBatcher"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["cssVariableBatcher"],
              dependencyMapping: {
                "cssVariableBatcher": "cssVariableBatcher"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "PerformanceCSSIntegration",
            requiredDependencies: ["config", "cssVariableBatcher", "performanceCoordinator"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "cssVariableManager", "performanceCoordinator"],
              dependencyMapping: {
                "config": "config",
                "cssVariableManager": "cssVariableBatcher",
                // Map cssVariableBatcher to cssVariableManager parameter
                "performanceCoordinator": "performanceCoordinator"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "SidebarSystemsIntegration",
            requiredDependencies: ["cssVariableBatcher"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["cssVariableBatcher"],
              dependencyMapping: {
                "cssVariableBatcher": "cssVariableBatcher"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedSystemIntegration",
            requiredDependencies: ["year3000System"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["year3000System"],
              dependencyMapping: {
                "year3000System": "year3000System"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
        }
      };
      __name(_StandardConstructorStrategy, "StandardConstructorStrategy");
      StandardConstructorStrategy = _StandardConstructorStrategy;
      _EventDrivenCreationStrategy = class _EventDrivenCreationStrategy extends BaseCreationStrategy {
        getStrategyName() {
          return "EventDriven";
        }
        canCreate(context) {
          const config = this.systemConfigs.get(context.systemKey);
          return config?.creationPreferences.eventDriven === true;
        }
        getEstimatedCreationTime(context) {
          return 50;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const standardStrategy = new StandardConstructorStrategy();
            const standardResult = await standardStrategy.createSystem(SystemClass, context);
            if (!standardResult.success) {
              return standardResult;
            }
            this.setupEventSubscriptions(standardResult.system, context);
            const result = this.createBaseResult(standardResult.system, context, startTime);
            result.warnings = standardResult.warnings;
            Y3K?.debug?.log("EventDrivenCreationStrategy", `Created ${context.systemKey} with event subscriptions`);
            return result;
          } catch (error) {
            const result = this.createBaseResult(null, context, startTime, error);
            Y3K?.debug?.error("EventDrivenCreationStrategy", `Failed to create ${context.systemKey}:`, error);
            return result;
          }
        }
        /**
         * Setup event subscriptions during creation
         */
        setupEventSubscriptions(system, context) {
          const eventSubscriptions = this.getEventSubscriptions(context.systemKey);
          for (const eventType of eventSubscriptions) {
            if (typeof system.handleEvent === "function") {
              GlobalEventBus.subscribe(eventType, (event) => {
                system.handleEvent(event);
              });
            } else if (typeof system.handleColorExtraction === "function" && eventType === "colors/extracted") {
              GlobalEventBus.subscribe(eventType, system.handleColorExtraction.bind(system));
            }
          }
          Y3K?.debug?.log(
            "EventDrivenCreationStrategy",
            `Setup event subscriptions for ${context.systemKey}:`,
            eventSubscriptions
          );
        }
        /**
         * Get events that system will subscribe to
         */
        getEventSubscriptions(systemKey) {
          const config = this.systemConfigs.get(systemKey);
          return config?.eventSubscriptions || [];
        }
      };
      __name(_EventDrivenCreationStrategy, "EventDrivenCreationStrategy");
      EventDrivenCreationStrategy = _EventDrivenCreationStrategy;
      _ObjectDependenciesStrategy = class _ObjectDependenciesStrategy extends BaseCreationStrategy {
        constructor() {
          super();
          this.registerObjectDependencySystems();
        }
        getStrategyName() {
          return "ObjectDependencies";
        }
        canCreate(context) {
          return context.systemKey === "MusicSyncService";
        }
        getEstimatedCreationTime(context) {
          return 30;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const validation = this.validateDependencies(context);
            if (!validation.valid && context.preferences.validateDependencies !== false) {
              throw new DependencyValidationError(
                context.systemKey,
                this.getStrategyName(),
                validation.missing,
                context
              );
            }
            const dependencies = {
              YEAR3000_CONFIG: context.config,
              Year3000Utilities: context.utils,
              settingsManager: context.dependencies.settingsManager,
              year3000System: context.dependencies.year3000System
              // NOTE: colorHarmonyEngine deliberately omitted - using event-driven pattern instead
            };
            const system = new SystemClass(dependencies);
            const result = this.createBaseResult(system, context, startTime);
            result.warnings = validation.warnings;
            result.metadata.pendingDependencies = [];
            Y3K?.debug?.log("ObjectDependenciesStrategy", `Created ${context.systemKey} with event-driven dependencies`);
            return result;
          } catch (error) {
            const result = this.createBaseResult(null, context, startTime, error);
            Y3K?.debug?.error("ObjectDependenciesStrategy", `Failed to create ${context.systemKey}:`, error);
            return result;
          }
        }
        /**
         * Register systems that use object dependencies
         */
        registerObjectDependencySystems() {
          this.registerSystemConfig({
            systemKey: "MusicSyncService",
            requiredDependencies: ["config", "utils"],
            optionalDependencies: ["settingsManager", "year3000System"],
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
        }
      };
      __name(_ObjectDependenciesStrategy, "ObjectDependenciesStrategy");
      ObjectDependenciesStrategy = _ObjectDependenciesStrategy;
      _SystemCreationStrategyRegistry = class _SystemCreationStrategyRegistry {
        constructor() {
          this.strategies = /* @__PURE__ */ new Map();
          this.registerDefaultStrategies();
        }
        /**
         * Register a creation strategy
         */
        register(strategy) {
          this.strategies.set(strategy.getStrategyName(), strategy);
          Y3K?.debug?.log("SystemCreationStrategyRegistry", `Registered strategy: ${strategy.getStrategyName()}`);
        }
        /**
         * Select best strategy for given criteria
         */
        selectStrategy(systemKey, criteria) {
          const candidateStrategies = this.getStrategiesForSystem(systemKey);
          if (candidateStrategies.length === 0) {
            return null;
          }
          let bestStrategy = candidateStrategies[0];
          if (!bestStrategy) {
            return null;
          }
          let bestScore = this.scoreStrategy(bestStrategy, systemKey, criteria);
          for (let i = 1; i < candidateStrategies.length; i++) {
            const strategy = candidateStrategies[i];
            if (!strategy) continue;
            const score = this.scoreStrategy(strategy, systemKey, criteria);
            if (score > bestScore) {
              bestStrategy = strategy;
              bestScore = score;
            }
          }
          return bestStrategy;
        }
        /**
         * Get all registered strategies
         */
        getStrategies() {
          return Array.from(this.strategies.values());
        }
        /**
         * Get strategy by name
         */
        getStrategy(name) {
          return this.strategies.get(name) || null;
        }
        /**
         * Get strategies that can create a specific system
         */
        getStrategiesForSystem(systemKey) {
          const context = {
            systemKey,
            config: {},
            utils: {},
            dependencies: {},
            preferences: {},
            metadata: {
              timestamp: Date.now(),
              reason: "startup",
              priority: "medium"
            }
          };
          return this.getStrategies().filter((strategy) => strategy.canCreate(context));
        }
        /**
         * Score strategy based on selection criteria
         */
        scoreStrategy(strategy, systemKey, criteria) {
          let score = 0;
          score += 10;
          if (criteria.dependencyRequirements === "event-driven") {
            if (strategy.getStrategyName() === "EventDriven") score += 20;
            if (strategy.getStrategyName() === "ObjectDependencies") score += 15;
          } else if (criteria.dependencyRequirements === "basic") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 20;
          }
          if (criteria.performance === "lightweight") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 15;
          } else if (criteria.performance === "optimized") {
            if (strategy.getStrategyName() === "EventDriven") score += 10;
          }
          if (criteria.creationContext === "startup") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 5;
          }
          return score;
        }
        /**
         * Register default strategies
         */
        registerDefaultStrategies() {
          this.register(new StandardConstructorStrategy());
          this.register(new EventDrivenCreationStrategy());
          this.register(new ObjectDependenciesStrategy());
        }
        /**
         * Get registry status
         */
        getStatus() {
          return {
            strategyCount: this.strategies.size,
            strategies: Array.from(this.strategies.keys())
          };
        }
      };
      __name(_SystemCreationStrategyRegistry, "SystemCreationStrategyRegistry");
      SystemCreationStrategyRegistry = _SystemCreationStrategyRegistry;
      globalSystemCreationRegistry = new SystemCreationStrategyRegistry();
    }
  });

  // src-js/core/creation/StrategyBasedFactory.ts
  var _StrategyBasedFactory, StrategyBasedFactory, globalStrategyBasedFactory;
  var init_StrategyBasedFactory = __esm({
    "src-js/core/creation/StrategyBasedFactory.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_SystemCreationStrategies();
      init_systemCreationStrategy();
      _StrategyBasedFactory = class _StrategyBasedFactory {
        constructor(strategyRegistry) {
          this.systemConfigs = /* @__PURE__ */ new Map();
          this.creationMetrics = {
            totalCreations: 0,
            successfulCreations: 0,
            averageCreationTime: 0,
            strategyUsage: {}
          };
          this.strategyRegistry = strategyRegistry || globalSystemCreationRegistry;
          Y3K?.debug?.log("StrategyBasedFactory", "Factory initialized with strategy registry");
        }
        /**
         * Create system using best available strategy
         */
        async createSystem(systemKey, SystemClass, context) {
          const startTime = performance.now();
          try {
            this.creationMetrics.totalCreations++;
            const systemConfig = this.getSystemConfig(systemKey);
            const criteria = this.buildSelectionCriteria(systemKey, systemConfig, context);
            const strategy = this.strategyRegistry.selectStrategy(systemKey, criteria);
            if (!strategy) {
              throw new StrategySelectionError(systemKey, criteria);
            }
            const strategyName = strategy.getStrategyName();
            this.creationMetrics.strategyUsage[strategyName] = (this.creationMetrics.strategyUsage[strategyName] || 0) + 1;
            const result = await strategy.createSystem(SystemClass, context);
            if (result.success) {
              this.creationMetrics.successfulCreations++;
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            this.updateAverageCreationTime(totalTime);
            Y3K?.debug?.log("StrategyBasedFactory", `Created ${systemKey} using ${strategyName}`, {
              success: result.success,
              creationTime: result.creationTime,
              totalTime
            });
            return result;
          } catch (error) {
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            Y3K?.debug?.error("StrategyBasedFactory", `Failed to create ${systemKey}:`, error);
            return {
              system: null,
              success: false,
              creationTime: totalTime,
              strategy: "unknown",
              injectedDependencies: [],
              warnings: [],
              error,
              metadata: {
                requiresInitialization: false,
                pendingDependencies: [],
                context
              }
            };
          }
        }
        /**
         * Register system creation configuration
         */
        registerSystemConfig(config) {
          this.systemConfigs.set(config.systemKey, config);
          Y3K?.debug?.log("StrategyBasedFactory", `Registered config for ${config.systemKey}`);
        }
        /**
         * Get system creation configuration
         */
        getSystemConfig(systemKey) {
          return this.systemConfigs.get(systemKey) || null;
        }
        /**
         * Update creation strategy registry
         */
        setStrategyRegistry(registry2) {
          this.strategyRegistry = registry2;
          Y3K?.debug?.log("StrategyBasedFactory", "Strategy registry updated");
        }
        /**
         * Get factory performance metrics
         */
        getMetrics() {
          return { ...this.creationMetrics };
        }
        /**
         * Reset performance metrics
         */
        resetMetrics() {
          this.creationMetrics = {
            totalCreations: 0,
            successfulCreations: 0,
            averageCreationTime: 0,
            strategyUsage: {}
          };
        }
        // ============================================================================
        // Private Helper Methods
        // ============================================================================
        /**
         * Build selection criteria based on system key and context
         * No longer relies on factory's own systemConfig - strategies manage their own configurations
         */
        buildSelectionCriteria(systemKey, systemConfig, context) {
          let complexity = "medium";
          const simpleSystems = [
            "DeviceCapabilityDetector",
            "PerformanceAnalyzer",
            "CSSVariableBatcher",
            "SettingsManager",
            "TimerConsolidationSystem"
          ];
          const complexSystems = [
            "GlassmorphismManager",
            "Card3DManager",
            "PerformanceCSSIntegration",
            "EnhancedMasterAnimationCoordinator"
          ];
          if (simpleSystems.includes(systemKey)) {
            complexity = "simple";
          } else if (complexSystems.includes(systemKey)) {
            complexity = "complex";
          }
          let dependencyRequirements = "basic";
          if (systemKey === "MusicSyncService" || systemKey === "ColorHarmonyEngine") {
            dependencyRequirements = "event-driven";
          } else if (simpleSystems.includes(systemKey)) {
            dependencyRequirements = "none";
          }
          let performance2 = "standard";
          if (context.metadata.priority === "critical") {
            performance2 = "optimized";
          } else if (context.preferences.monitorCreation) {
            performance2 = "optimized";
          } else if (complexity === "simple") {
            performance2 = "lightweight";
          }
          return {
            complexity,
            dependencyRequirements,
            performance: performance2,
            resourceConstraints: {
              memoryLimited: context.metadata.resourceConstraints?.maxMemoryMB !== void 0,
              timeLimited: context.metadata.resourceConstraints?.maxInitTimeMs !== void 0,
              cpuLimited: context.metadata.priority === "low"
            },
            creationContext: context.metadata.reason
          };
        }
        /**
         * Update running average creation time
         */
        updateAverageCreationTime(newTime) {
          const totalCreations = this.creationMetrics.totalCreations;
          const currentAverage = this.creationMetrics.averageCreationTime;
          this.creationMetrics.averageCreationTime = (currentAverage * (totalCreations - 1) + newTime) / totalCreations;
        }
        /**
         * Register default system configurations for known systems
         * DEPRECATED: System configurations are now managed by individual strategies
         */
        registerDefaultSystemConfigs() {
        }
      };
      __name(_StrategyBasedFactory, "StrategyBasedFactory");
      StrategyBasedFactory = _StrategyBasedFactory;
      globalStrategyBasedFactory = new StrategyBasedFactory();
    }
  });

  // src-js/core/integration/FacadeAdapter.ts
  var _NonVisualSystemFacadeAdapter, NonVisualSystemFacadeAdapter, globalFacadeAdapter;
  var init_FacadeAdapter = __esm({
    "src-js/core/integration/FacadeAdapter.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_StrategyBasedFactory();
      _NonVisualSystemFacadeAdapter = class _NonVisualSystemFacadeAdapter {
        constructor(strategyBasedFactory) {
          this.adapted = false;
          this.originalFacade = null;
          this.migrationProgress = 0;
          this.systemsUsingStrategy = /* @__PURE__ */ new Set();
          this.systemsUsingLegacy = /* @__PURE__ */ new Set();
          this.strategyBasedFactory = strategyBasedFactory || globalStrategyBasedFactory;
          Y3K?.debug?.log("NonVisualSystemFacadeAdapter", "Facade adapter initialized");
        }
        /**
         * Adapt facade to use strategy-based creation
         */
        adaptToStrategyPattern(factory) {
          this.strategyBasedFactory = factory;
          this.adapted = true;
          this.migrationProgress = 1;
          Y3K?.debug?.log("NonVisualSystemFacadeAdapter", "Facade adapted to strategy pattern");
        }
        /**
         * Get migration status
         */
        getMigrationStatus() {
          return {
            adapted: this.adapted,
            systemsUsingStrategyPattern: Array.from(this.systemsUsingStrategy),
            systemsUsingLegacyPattern: Array.from(this.systemsUsingLegacy),
            migrationProgress: this.migrationProgress
          };
        }
        /**
         * Complete migration to strategy pattern
         */
        async completeMigration() {
          if (!this.adapted) {
            this.adaptToStrategyPattern(this.strategyBasedFactory);
          }
          this.migrationProgress = 1;
          this.systemsUsingLegacy.clear();
          Y3K?.debug?.log("NonVisualSystemFacadeAdapter", "Migration to strategy pattern completed");
        }
        /**
         * Create system using strategy-based factory (replaces hardcoded constructor logic)
         */
        async createSystemWithStrategy(systemKey, SystemClass, context) {
          const creationContext = {
            systemKey,
            config: context.config,
            utils: context.utils,
            dependencies: context.dependencies,
            preferences: {
              lazyInit: false,
              validateDependencies: true,
              creationTimeout: 5e3,
              monitorCreation: true
            },
            metadata: {
              timestamp: Date.now(),
              reason: "startup",
              priority: "medium",
              resourceConstraints: {
                maxMemoryMB: 50,
                maxInitTimeMs: 1e3
              }
            }
          };
          try {
            const result = await this.strategyBasedFactory.createSystem(
              systemKey,
              SystemClass,
              creationContext
            );
            if (result.success) {
              this.systemsUsingStrategy.add(systemKey);
              this.systemsUsingLegacy.delete(systemKey);
            } else {
              this.systemsUsingLegacy.add(systemKey);
            }
            this.updateMigrationProgress();
            Y3K?.debug?.log(
              "NonVisualSystemFacadeAdapter",
              `Created ${systemKey} via strategy pattern`,
              {
                strategy: result.strategy,
                success: result.success,
                creationTime: result.creationTime
              }
            );
            return result;
          } catch (error) {
            this.systemsUsingLegacy.add(systemKey);
            this.updateMigrationProgress();
            Y3K?.debug?.error(
              "NonVisualSystemFacadeAdapter",
              `Failed to create ${systemKey} via strategy pattern:`,
              error
            );
            return {
              system: null,
              success: false,
              creationTime: 0,
              strategy: "adapter-fallback",
              injectedDependencies: [],
              warnings: [`Strategy creation failed: ${error}`],
              error,
              metadata: {
                requiresInitialization: false,
                pendingDependencies: [],
                context: creationContext
              }
            };
          }
        }
        /**
         * Legacy compatibility method - creates system using old hardcoded logic
         * This should be gradually phased out as systems migrate to strategy pattern
         */
        createSystemLegacy(systemKey, SystemClass, context) {
          this.systemsUsingLegacy.add(systemKey);
          this.updateMigrationProgress();
          Y3K?.debug?.warn(
            "NonVisualSystemFacadeAdapter",
            `Using legacy creation for ${systemKey} - should migrate to strategy pattern`
          );
          switch (systemKey) {
            case "DeviceCapabilityDetector":
            case "PerformanceAnalyzer":
            case "CSSVariableBatcher":
            case "SettingsManager":
            case "TimerConsolidationSystem":
              return new SystemClass();
            case "UnifiedSystemIntegration":
              return new SystemClass(context.year3000System);
            case "UnifiedCSSVariableManager":
            case "SidebarSystemsIntegration":
              return new SystemClass(context.dependencies.cssVariableBatcher);
            case "PerformanceCSSIntegration":
              return new SystemClass(
                context.config,
                context.dependencies.cssVariableBatcher,
                context.dependencies.performanceCoordinator
              );
            case "ColorHarmonyEngine":
              return new SystemClass(
                context.config,
                context.utils,
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager
              );
            case "EnhancedMasterAnimationCoordinator":
              return new SystemClass(
                context.config,
                context.dependencies.performanceCoordinator
              );
            case "UnifiedPerformanceCoordinator":
              return new SystemClass(
                context.config,
                context.dependencies.performanceAnalyzer
              );
            case "GlassmorphismManager":
              return new SystemClass(
                context.config,
                context.utils,
                context.dependencies.cssVariableBatcher,
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager
              );
            case "Card3DManager":
              return new SystemClass(
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager,
                context.utils
              );
            case "MusicSyncService":
              return new SystemClass({
                YEAR3000_CONFIG: context.config,
                Year3000Utilities: context.utils,
                settingsManager: context.dependencies.settingsManager,
                year3000System: context.year3000System
                // NOTE: colorHarmonyEngine deliberately omitted - using event-driven pattern
              });
            default:
              try {
                return new SystemClass();
              } catch (error) {
                return new SystemClass(
                  context.config,
                  context.utils,
                  context.dependencies.performanceAnalyzer,
                  context.dependencies.settingsManager
                );
              }
          }
        }
        /**
         * Update migration progress based on strategy vs legacy usage
         */
        updateMigrationProgress() {
          const totalSystems = this.systemsUsingStrategy.size + this.systemsUsingLegacy.size;
          if (totalSystems === 0) {
            this.migrationProgress = 0;
          } else {
            this.migrationProgress = this.systemsUsingStrategy.size / totalSystems;
          }
        }
        /**
         * Get adapter performance metrics
         */
        getAdapterMetrics() {
          const totalSystems = this.systemsUsingStrategy.size + this.systemsUsingLegacy.size;
          return {
            totalSystemsAdapted: this.systemsUsingStrategy.size,
            strategySuccessRate: totalSystems > 0 ? this.systemsUsingStrategy.size / totalSystems : 0,
            migrationProgress: this.migrationProgress,
            systemBreakdown: {
              strategy: Array.from(this.systemsUsingStrategy),
              legacy: Array.from(this.systemsUsingLegacy)
            }
          };
        }
        /**
         * Force migration of specific system to strategy pattern
         */
        async migrateSystemToStrategy(systemKey) {
          try {
            this.systemsUsingLegacy.delete(systemKey);
            Y3K?.debug?.log(
              "NonVisualSystemFacadeAdapter",
              `Migrated ${systemKey} to strategy pattern`
            );
            return true;
          } catch (error) {
            Y3K?.debug?.error(
              "NonVisualSystemFacadeAdapter",
              `Failed to migrate ${systemKey} to strategy pattern:`,
              error
            );
            return false;
          }
        }
        /**
         * Get recommended migration order for systems
         */
        getRecommendedMigrationOrder() {
          const migrationOrder = [
            // Simple systems (no dependencies)
            "PerformanceAnalyzer",
            "CSSVariableBatcher",
            "DeviceCapabilityDetector",
            "SettingsManager",
            // Event-driven systems
            "ColorHarmonyEngine",
            "MusicSyncService",
            // Complex systems
            "UnifiedPerformanceCoordinator",
            "EnhancedMasterAnimationCoordinator",
            // Integration systems
            "UnifiedSystemIntegration",
            // UI systems
            "GlassmorphismManager",
            "Card3DManager"
          ];
          return migrationOrder.filter((system) => this.systemsUsingLegacy.has(system));
        }
      };
      __name(_NonVisualSystemFacadeAdapter, "NonVisualSystemFacadeAdapter");
      NonVisualSystemFacadeAdapter = _NonVisualSystemFacadeAdapter;
      globalFacadeAdapter = new NonVisualSystemFacadeAdapter();
    }
  });

  // src-js/core/integration/NonVisualSystemFacade.ts
  var _NonVisualSystemFacade, NonVisualSystemFacade;
  var init_NonVisualSystemFacade = __esm({
    "src-js/core/integration/NonVisualSystemFacade.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_EnhancedMasterAnimationCoordinator();
      init_TimerConsolidationSystem();
      init_CSSVariableBatcher();
      init_UnifiedCSSVariableManager();
      init_UnifiedPerformanceCoordinator();
      init_DeviceCapabilityDetector();
      init_PerformanceAnalyzer();
      init_PerformanceCSSIntegration();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_ColorHarmonyEngine();
      init_MusicSyncService();
      init_GlassmorphismManager();
      init_Card3DManager();
      init_SidebarSystemsIntegration();
      init_UnifiedSystemIntegration();
      init_FacadeAdapter();
      _NonVisualSystemFacade = class _NonVisualSystemFacade {
        constructor(config, utils, year3000System2) {
          // Reference to main system
          // Core shared dependencies (will be injected from main system)
          this.cssVariableBatcher = null;
          this.performanceAnalyzer = null;
          this.performanceCoordinator = null;
          this.musicSyncService = null;
          this.settingsManager = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Monitoring intervals
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Event callbacks
          this.onSystemCreated = null;
          this.onSystemFailed = null;
          this.onHealthChange = null;
          // Strategy-based creation adapter
          this.facadeAdapter = globalFacadeAdapter;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System2;
          this.systemRegistry = /* @__PURE__ */ new Map();
          this.systemCache = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.facadeConfig = {
            mode: "progressive",
            enablePerformanceMonitoring: true,
            enableDependencyInjection: true,
            enableSystemHealthMonitoring: true,
            performanceThresholds: {
              maxInitTime: 5e3,
              // 5 seconds
              maxMemoryMB: 100,
              maxCPUPercent: 15
            },
            systemPreferences: {
              lazyInitialization: true,
              aggressiveCaching: true,
              performanceOptimization: true
            }
          };
          this.currentMetrics = this.createInitialMetrics();
          this.registerNonVisualSystems();
          Y3K?.debug?.log("NonVisualSystemFacade", "Non-visual systems facade initialized");
        }
        registerNonVisualSystems() {
          this.systemRegistry.set("EnhancedMasterAnimationCoordinator", EnhancedMasterAnimationCoordinator);
          this.systemDependencies.set("EnhancedMasterAnimationCoordinator", ["performanceAnalyzer", "cssVariableBatcher"]);
          this.systemRegistry.set("TimerConsolidationSystem", TimerConsolidationSystem);
          this.systemDependencies.set("TimerConsolidationSystem", ["performanceAnalyzer"]);
          this.systemRegistry.set("CSSVariableBatcher", CSSVariableBatcher);
          this.systemDependencies.set("CSSVariableBatcher", []);
          this.systemRegistry.set("UnifiedCSSVariableManager", UnifiedCSSVariableManager);
          this.systemDependencies.set("UnifiedCSSVariableManager", ["cssVariableBatcher"]);
          this.systemRegistry.set("UnifiedPerformanceCoordinator", UnifiedPerformanceCoordinator);
          this.systemDependencies.set("UnifiedPerformanceCoordinator", []);
          this.systemRegistry.set("DeviceCapabilityDetector", DeviceCapabilityDetector);
          this.systemDependencies.set("DeviceCapabilityDetector", []);
          this.systemRegistry.set("PerformanceAnalyzer", PerformanceAnalyzer);
          this.systemDependencies.set("PerformanceAnalyzer", []);
          this.systemRegistry.set("PerformanceCSSIntegration", PerformanceCSSIntegration);
          this.systemDependencies.set("PerformanceCSSIntegration", ["cssVariableBatcher", "performanceAnalyzer"]);
          this.systemDependencies.set("UnifiedDebugManager", []);
          this.systemRegistry.set("SettingsManager", SettingsManager);
          this.systemDependencies.set("SettingsManager", []);
          this.systemRegistry.set("ColorHarmonyEngine", ColorHarmonyEngine);
          this.systemDependencies.set("ColorHarmonyEngine", ["musicSyncService"]);
          this.systemRegistry.set("MusicSyncService", MusicSyncService);
          this.systemDependencies.set("MusicSyncService", []);
          this.systemRegistry.set("GlassmorphismManager", GlassmorphismManager);
          this.systemDependencies.set("GlassmorphismManager", ["cssVariableBatcher", "performanceAnalyzer", "settingsManager"]);
          this.systemRegistry.set("Card3DManager", Card3DManager);
          this.systemDependencies.set("Card3DManager", ["performanceAnalyzer", "settingsManager"]);
          this.systemRegistry.set("SidebarSystemsIntegration", SidebarSystemsIntegration);
          this.systemDependencies.set("SidebarSystemsIntegration", ["cssVariableBatcher"]);
          this.systemRegistry.set("UnifiedSystemIntegration", UnifiedSystemIntegration);
          this.systemDependencies.set("UnifiedSystemIntegration", ["year3000System"]);
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3K?.debug?.warn("NonVisualSystemFacade", "Already initialized");
            return;
          }
          try {
            const startTime = performance.now();
            this.facadeConfig = { ...this.facadeConfig, ...config };
            await this.initializeSharedDependencies();
            await this.applyConfiguration();
            this.startMonitoring();
            await this.performHealthCheck();
            const endTime = performance.now();
            this.currentMetrics.systemInitializationTime = endTime - startTime;
            this.isInitialized = true;
            Y3K?.debug?.log("NonVisualSystemFacade", "Non-visual systems facade fully initialized", {
              mode: this.facadeConfig.mode,
              systemsRegistered: this.systemRegistry.size,
              initTime: this.currentMetrics.systemInitializationTime
            });
          } catch (error) {
            Y3K?.debug?.error("NonVisualSystemFacade", "Initialization failed:", error);
            await this.cleanup();
            throw error;
          }
        }
        async initializeSharedDependencies() {
          const coreSystemsOrder = [
            "PerformanceAnalyzer",
            "CSSVariableBatcher",
            "SettingsManager",
            "UnifiedDebugManager",
            "MusicSyncService",
            "UnifiedPerformanceCoordinator"
          ];
          for (const systemKey of coreSystemsOrder) {
            try {
              const system = await this.getSystem(systemKey);
              if (system && typeof system.initialize === "function") {
                await system.initialize();
              }
              switch (systemKey) {
                case "PerformanceAnalyzer":
                  this.performanceAnalyzer = system;
                  break;
                case "CSSVariableBatcher":
                  this.cssVariableBatcher = system;
                  break;
                case "SettingsManager":
                  this.settingsManager = system;
                  break;
                case "UnifiedDebugManager":
                  break;
                case "MusicSyncService":
                  this.musicSyncService = system;
                  break;
                case "UnifiedPerformanceCoordinator":
                  this.performanceCoordinator = system;
                  break;
              }
            } catch (error) {
              Y3K?.debug?.error("NonVisualSystemFacade", `Failed to initialize ${systemKey}:`, error);
            }
          }
        }
        /**
         * Get system from cache (synchronous) - returns null if not cached
         * Use this for scenarios where the system should already be initialized
         */
        getCachedSystem(key) {
          return this.systemCache.get(key) || null;
        }
        /**
         * Factory method to create and return non-visual systems
         * This is the main interface for the facade pattern
         */
        async getSystem(key) {
          if (this.systemCache.has(key)) {
            return this.systemCache.get(key);
          }
          const system = await this.createSystem(key);
          this.systemCache.set(key, system);
          this.currentMetrics.activeSystems.push(key);
          this.currentMetrics.initializedSystems++;
          if (this.onSystemCreated) {
            this.onSystemCreated(key, system);
          }
          return system;
        }
        /**
         * Create a new non-visual system instance with strategy-based dependency injection
         */
        async createSystem(key) {
          const startTime = performance.now();
          try {
            if (key === "UnifiedDebugManager") {
              const system2 = UnifiedDebugManager_default.getInstance();
              this.injectDependencies(system2, key);
              this.integratePerformanceMonitoring(system2, key);
              const endTime2 = performance.now();
              this.currentMetrics.dependencyResolutionTime += endTime2 - startTime;
              return system2;
            }
            const SystemClass = this.systemRegistry.get(key);
            if (!SystemClass) {
              throw new Error(`Non-visual system '${key}' not found in registry`);
            }
            const context = {
              systemKey: key,
              config: this.config,
              utils: this.utils,
              dependencies: {
                config: this.config,
                utils: this.utils,
                performanceAnalyzer: this.performanceAnalyzer,
                settingsManager: this.settingsManager,
                musicSyncService: this.musicSyncService,
                year3000System: this.year3000System,
                cssVariableBatcher: this.cssVariableBatcher,
                performanceCoordinator: this.performanceCoordinator
              },
              preferences: {
                lazyInit: false,
                validateDependencies: true,
                creationTimeout: 5e3,
                monitorCreation: true
              },
              metadata: {
                timestamp: Date.now(),
                reason: "startup",
                priority: "medium",
                resourceConstraints: {
                  maxMemoryMB: 50,
                  maxInitTimeMs: 1e3
                }
              },
              year3000System: this.year3000System
            };
            const result = await this.facadeAdapter.createSystemWithStrategy(key, SystemClass, context);
            if (!result.success) {
              Y3K?.debug?.warn(
                "NonVisualSystemFacade",
                `Strategy creation failed for ${key}, falling back to legacy pattern`
              );
              const system2 = this.facadeAdapter.createSystemLegacy(key, SystemClass, context);
              this.injectDependencies(system2, key);
              this.integratePerformanceMonitoring(system2, key);
              const endTime2 = performance.now();
              this.currentMetrics.dependencyResolutionTime += endTime2 - startTime;
              return system2;
            }
            const system = result.system;
            this.injectDependencies(system, key);
            this.integratePerformanceMonitoring(system, key);
            const endTime = performance.now();
            this.currentMetrics.dependencyResolutionTime += endTime - startTime;
            Y3K?.debug?.log("NonVisualSystemFacade", `Created ${key} using strategy: ${result.strategy}`, {
              creationTime: result.creationTime,
              totalTime: endTime - startTime,
              injectedDependencies: result.injectedDependencies
            });
            return system;
          } catch (error) {
            this.currentMetrics.failedSystems++;
            this.currentMetrics.failedSystemsList.push(key);
            this.currentMetrics.systemErrors++;
            if (this.onSystemFailed) {
              this.onSystemFailed(key, error);
            }
            Y3K?.debug?.error("NonVisualSystemFacade", `Failed to create system ${key}:`, error);
            throw error;
          }
        }
        /**
         * Inject dependencies into non-visual systems
         */
        injectDependencies(system, key) {
          if (!this.facadeConfig.enableDependencyInjection) return;
          const dependencies = this.systemDependencies.get(key) || [];
          if (dependencies.includes("performanceAnalyzer") && this.performanceAnalyzer && system.setPerformanceAnalyzer) {
            system.setPerformanceAnalyzer(this.performanceAnalyzer);
          }
          if (dependencies.includes("cssVariableBatcher") && this.cssVariableBatcher && system.setCSSVariableBatcher) {
            system.setCSSVariableBatcher(this.cssVariableBatcher);
          }
          if (dependencies.includes("musicSyncService") && this.musicSyncService && system.setMusicSyncService) {
            system.setMusicSyncService(this.musicSyncService);
          }
          if (dependencies.includes("settingsManager") && this.settingsManager && system.setSettingsManager) {
            system.setSettingsManager(this.settingsManager);
          }
          if (dependencies.includes("year3000System") && system.setYear3000System) {
            system.setYear3000System(this.year3000System);
          }
        }
        /**
         * Integrate performance monitoring for non-visual systems
         */
        integratePerformanceMonitoring(system, key) {
          if (!this.facadeConfig.enablePerformanceMonitoring || !this.performanceAnalyzer) return;
          const originalInitialize = system.initialize;
          if (typeof originalInitialize === "function") {
            system.initialize = async (...args) => {
              const startTime = performance.now();
              const result = await originalInitialize.call(system, ...args);
              const endTime = performance.now();
              this.performanceAnalyzer?.recordMetric(
                `NonVisual_${key}_Initialize`,
                endTime - startTime
              );
              return result;
            };
          }
          const originalUpdateAnimation = system.updateAnimation;
          if (typeof originalUpdateAnimation === "function") {
            system.updateAnimation = (deltaTime) => {
              const startTime = performance.now();
              originalUpdateAnimation.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer?.recordMetric(
                `NonVisual_${key}_Animation`,
                endTime - startTime
              );
            };
          }
        }
        /**
         * Initialize all cached non-visual systems
         */
        async initializeAllSystems() {
          const initPromises = Array.from(this.systemCache.entries()).map(async ([key, system]) => {
            try {
              if (system && typeof system.initialize === "function") {
                await system.initialize();
              }
              Y3K?.debug?.log("NonVisualSystemFacade", `Initialized system: ${key}`);
              return { key, success: true };
            } catch (error) {
              Y3K?.debug?.error("NonVisualSystemFacade", `Failed to initialize ${key}:`, error);
              return { key, success: false, error };
            }
          });
          const results = await Promise.allSettled(initPromises);
          const successCount = results.filter((r) => r.status === "fulfilled" && r.value.success).length;
          Y3K?.debug?.log("NonVisualSystemFacade", `Non-visual systems initialized: ${successCount}/${results.length}`);
        }
        /**
         * Perform health check on all non-visual systems
         */
        async performHealthCheck() {
          const healthCheck = {
            overall: "good",
            systems: /* @__PURE__ */ new Map(),
            recommendations: [],
            timestamp: performance.now(),
            metrics: { ...this.currentMetrics }
          };
          let healthyCount = 0;
          let totalCount = 0;
          for (const [key, system] of this.systemCache) {
            totalCount++;
            try {
              const systemHealth = system.healthCheck ? await system.healthCheck() : { status: "unknown", message: "No health check available" };
              const isHealthy = systemHealth.status === "healthy" || systemHealth.status === "good";
              if (isHealthy) healthyCount++;
              healthCheck.systems.set(key, {
                ok: isHealthy,
                details: systemHealth.message || systemHealth.details || "System operational"
              });
            } catch (error) {
              healthCheck.systems.set(key, {
                ok: false,
                details: `Health check failed: ${error}`
              });
            }
          }
          const healthPercentage = totalCount > 0 ? healthyCount / totalCount : 1;
          if (healthPercentage >= 0.9) {
            healthCheck.overall = "excellent";
          } else if (healthPercentage >= 0.7) {
            healthCheck.overall = "good";
          } else if (healthPercentage >= 0.5) {
            healthCheck.overall = "degraded";
            healthCheck.recommendations.push("Some non-visual systems are experiencing issues");
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push("Multiple non-visual system failures detected");
          }
          if (this.currentMetrics.systemInitializationTime > 3e3) {
            healthCheck.recommendations.push("High initialization time - consider optimizing system startup");
          }
          if (this.currentMetrics.memoryUsageMB > 80) {
            healthCheck.recommendations.push("High memory usage - consider optimizing system memory usage");
          }
          this.lastHealthCheck = healthCheck;
          this.currentMetrics.lastHealthCheckTime = performance.now();
          if (this.onHealthChange) {
            this.onHealthChange(healthCheck);
          }
          return healthCheck;
        }
        // Utility methods
        createInitialMetrics() {
          return {
            systemCount: this.systemRegistry.size,
            initializedSystems: 0,
            failedSystems: 0,
            totalInitTime: 0,
            averageInitTime: 0,
            memoryUsageMB: 0,
            systemHealth: "good",
            activeSystems: [],
            failedSystemsList: [],
            dependencyInjection: this.facadeConfig.enableDependencyInjection,
            performanceMonitoring: this.facadeConfig.enablePerformanceMonitoring,
            healthMonitoring: this.facadeConfig.enableSystemHealthMonitoring,
            systemInitializationTime: 0,
            dependencyResolutionTime: 0,
            lastHealthCheckTime: 0,
            systemErrors: 0
          };
        }
        async applyConfiguration() {
          switch (this.facadeConfig.mode) {
            case "performance-first":
              this.facadeConfig.systemPreferences.lazyInitialization = true;
              this.facadeConfig.systemPreferences.aggressiveCaching = true;
              break;
            case "quality-first":
              this.facadeConfig.systemPreferences.lazyInitialization = false;
              this.facadeConfig.systemPreferences.performanceOptimization = true;
              break;
            case "battery-optimized":
              this.facadeConfig.performanceThresholds.maxCPUPercent = 5;
              this.facadeConfig.systemPreferences.lazyInitialization = true;
              break;
          }
        }
        startMonitoring() {
          if (this.facadeConfig.enableSystemHealthMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performHealthCheck();
            }, 3e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 5e3);
          }
        }
        updateMetrics() {
          this.currentMetrics.systemCount = this.systemRegistry.size;
          this.currentMetrics.initializedSystems = this.systemCache.size;
          this.currentMetrics.averageInitTime = this.currentMetrics.totalInitTime / Math.max(1, this.currentMetrics.initializedSystems);
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.memoryUsageMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          const failureRate = this.currentMetrics.failedSystems / Math.max(1, this.currentMetrics.systemCount);
          if (failureRate === 0) {
            this.currentMetrics.systemHealth = "excellent";
          } else if (failureRate < 0.1) {
            this.currentMetrics.systemHealth = "good";
          } else if (failureRate < 0.3) {
            this.currentMetrics.systemHealth = "degraded";
          } else {
            this.currentMetrics.systemHealth = "critical";
          }
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          this.cssVariableBatcher = null;
          this.performanceAnalyzer = null;
          this.musicSyncService = null;
          this.settingsManager = null;
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.facadeConfig };
        }
        async setConfiguration(config) {
          this.facadeConfig = { ...this.facadeConfig, ...config };
          await this.applyConfiguration();
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        setOnSystemFailed(callback) {
          this.onSystemFailed = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            systemsActive: this.systemCache.size,
            healthy: this.currentMetrics.systemHealth === "excellent" || this.currentMetrics.systemHealth === "good"
          };
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          this.systemCache.clear();
          Y3K?.debug?.log("NonVisualSystemFacade", "Non-visual systems facade destroyed");
        }
      };
      __name(_NonVisualSystemFacade, "NonVisualSystemFacade");
      NonVisualSystemFacade = _NonVisualSystemFacade;
    }
  });

  // src-js/core/integration/SystemCoordinator.ts
  var _SystemCoordinator, SystemCoordinator;
  var init_SystemCoordinator = __esm({
    "src-js/core/integration/SystemCoordinator.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_VisualSystemFacade();
      init_NonVisualSystemFacade();
      init_CSSVariableBatcher();
      init_PerformanceAnalyzer();
      init_MusicSyncService();
      init_SettingsManager();
      init_ColorHarmonyEngine();
      _SystemCoordinator = class _SystemCoordinator {
        constructor(config, utils, year3000System2) {
          // Facade instances
          this.visualBridge = null;
          this.nonVisualFacade = null;
          // Shared dependencies (centrally managed)
          this.sharedCSSVariableBatcher = null;
          this.sharedPerformanceAnalyzer = null;
          this.sharedMusicSyncService = null;
          this.sharedSettingsManager = null;
          this.sharedColorHarmonyEngine = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Event coordination
          this.eventBus = null;
          this.crossFacadeEventListeners = /* @__PURE__ */ new Map();
          // Monitoring
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Event callbacks
          this.onSystemCreated = null;
          this.onHealthChange = null;
          this.onPerformanceChange = null;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System2;
          this.coordinationConfig = {
            mode: "unified",
            enableSharedDependencies: true,
            enableCrossFacadeCommunication: true,
            enableUnifiedPerformanceMonitoring: true,
            enableResourceOptimization: true,
            performanceThresholds: {
              maxTotalMemoryMB: 150,
              maxTotalInitTime: 8e3,
              maxCrossCommLatency: 10
            },
            coordinationPreferences: {
              preferSharedResources: true,
              enableEventPropagation: true,
              enableHealthCoordination: true
            }
          };
          this.currentMetrics = this.createInitialMetrics();
          Y3K?.debug?.log("SystemCoordinator", "System coordinator initialized");
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3K?.debug?.warn("SystemCoordinator", "Already initialized");
            return;
          }
          try {
            const startTime = performance.now();
            this.coordinationConfig = { ...this.coordinationConfig, ...config };
            await this.initializeSharedDependencies();
            await this.initializeFacades();
            this.setupCrossFacadeCommunication();
            this.startMonitoring();
            await this.performHealthCheck();
            const endTime = performance.now();
            this.currentMetrics.totalInitTime = endTime - startTime;
            this.isInitialized = true;
            Y3K?.debug?.log("SystemCoordinator", "System coordination fully initialized", {
              mode: this.coordinationConfig.mode,
              visualSystems: this.currentMetrics.visualSystems,
              nonVisualSystems: this.currentMetrics.nonVisualSystems,
              initTime: this.currentMetrics.totalInitTime
            });
          } catch (error) {
            Y3K?.debug?.error("SystemCoordinator", "Initialization failed:", error);
            await this.cleanup();
            throw error;
          }
        }
        async initializeSharedDependencies() {
          if (!this.coordinationConfig.enableSharedDependencies) return;
          Y3K?.debug?.log("SystemCoordinator", "Initializing shared dependencies");
          try {
            this.sharedPerformanceAnalyzer = new PerformanceAnalyzer();
            this.sharedCSSVariableBatcher = new CSSVariableBatcher();
            this.sharedSettingsManager = new SettingsManager();
            await this.sharedSettingsManager.initialize();
            this.sharedMusicSyncService = new MusicSyncService();
            await this.sharedMusicSyncService.initialize();
            this.sharedColorHarmonyEngine = new ColorHarmonyEngine();
            await this.sharedColorHarmonyEngine.initialize();
            Y3K?.debug?.log("SystemCoordinator", "Shared dependencies initialized successfully");
          } catch (error) {
            Y3K?.debug?.error("SystemCoordinator", "Failed to initialize shared dependencies:", error);
            throw error;
          }
        }
        async initializeFacades() {
          Y3K?.debug?.log("SystemCoordinator", "Initializing facades");
          try {
            this.visualBridge = new VisualSystemFacade(
              this.config,
              this.utils,
              this.year3000System,
              this.sharedCSSVariableBatcher,
              this.sharedPerformanceAnalyzer,
              this.sharedMusicSyncService,
              this.sharedSettingsManager,
              this.sharedColorHarmonyEngine,
              this.eventBus
            );
            await this.visualBridge.initialize({
              mode: this.coordinationConfig.mode === "performance-optimized" ? "performance-first" : "progressive",
              enablePerformanceMonitoring: this.coordinationConfig.enableUnifiedPerformanceMonitoring,
              enableEventCoordination: this.coordinationConfig.enableCrossFacadeCommunication
            });
            this.visualBridge.setOnSystemCreated((key, system) => {
              this.handleSystemCreated("visual", key, system);
            });
            this.nonVisualFacade = new NonVisualSystemFacade(
              this.config,
              this.utils,
              this.year3000System
            );
            await this.nonVisualFacade.initialize({
              mode: this.coordinationConfig.mode === "performance-optimized" ? "performance-first" : "progressive",
              enablePerformanceMonitoring: this.coordinationConfig.enableUnifiedPerformanceMonitoring,
              enableDependencyInjection: this.coordinationConfig.enableSharedDependencies
            });
            this.nonVisualFacade.setOnSystemCreated((key, system) => {
              this.handleSystemCreated("non-visual", key, system);
            });
            this.injectSharedDependencies();
            Y3K?.debug?.log("SystemCoordinator", "Facades initialized successfully");
          } catch (error) {
            Y3K?.debug?.error("SystemCoordinator", "Failed to initialize facades:", error);
            throw error;
          }
        }
        injectSharedDependencies() {
          if (!this.coordinationConfig.enableSharedDependencies || !this.nonVisualFacade) return;
          if (this.sharedPerformanceAnalyzer) {
            this.nonVisualFacade.performanceAnalyzer = this.sharedPerformanceAnalyzer;
          }
          if (this.sharedCSSVariableBatcher) {
            this.nonVisualFacade.cssVariableBatcher = this.sharedCSSVariableBatcher;
          }
          if (this.sharedMusicSyncService) {
            this.nonVisualFacade.musicSyncService = this.sharedMusicSyncService;
          }
          if (this.sharedSettingsManager) {
            this.nonVisualFacade.settingsManager = this.sharedSettingsManager;
          }
          if (this.sharedColorHarmonyEngine) {
            this.nonVisualFacade.colorHarmonyEngine = this.sharedColorHarmonyEngine;
          }
        }
        setupCrossFacadeCommunication() {
          if (!this.coordinationConfig.enableCrossFacadeCommunication) return;
          Y3K?.debug?.log("SystemCoordinator", "Setting up cross-facade communication");
          this.addEventListener("visual-event", (event) => {
            if (this.visualBridge) {
              this.visualBridge.propagateVisualEvent(event);
            }
          });
          this.addEventListener("performance-event", (event) => {
            if (this.visualBridge) {
              this.visualBridge.handleAdaptationEvent(event);
            }
          });
          if (this.coordinationConfig.coordinationPreferences.enableHealthCoordination) {
            this.addEventListener("health-degradation", (event) => {
              this.handleHealthDegradation(event);
            });
          }
        }
        handleSystemCreated(type, key, system) {
          if (type === "visual") {
            this.currentMetrics.visualSystems++;
          } else {
            this.currentMetrics.nonVisualSystems++;
          }
          this.currentMetrics.activeSystems++;
          if (this.onSystemCreated) {
            this.onSystemCreated(type, key, system);
          }
          Y3K?.debug?.log("SystemCoordinator", `System created: ${type}/${key}`);
        }
        handleHealthDegradation(event) {
          Y3K?.debug?.warn("SystemCoordinator", "Health degradation detected:", event);
          if (this.coordinationConfig.mode === "performance-optimized") {
            this.optimizeForPerformance();
          }
        }
        optimizeForPerformance() {
          if (this.visualBridge) {
            this.visualBridge.setConfiguration({
              mode: "performance-first",
              enableAdaptiveQuality: true,
              qualityPreferences: {
                preferHighQuality: false,
                allowDynamicScaling: true,
                batteryConservation: true
              }
            });
          }
          if (this.nonVisualFacade) {
            this.nonVisualFacade.setConfiguration({
              mode: "performance-first",
              systemPreferences: {
                lazyInitialization: true,
                aggressiveCaching: true,
                performanceOptimization: true
              }
            });
          }
        }
        // Public API for facade access
        getVisualSystem(key) {
          if (!this.visualBridge) return null;
          return this.visualBridge.getVisualSystem(key);
        }
        getCachedNonVisualSystem(key) {
          if (!this.nonVisualFacade) return null;
          return this.nonVisualFacade.getCachedSystem(key);
        }
        async getNonVisualSystem(key) {
          if (!this.nonVisualFacade) return null;
          return await this.nonVisualFacade.getSystem(key);
        }
        async getSystem(key) {
          if (this.visualBridge) {
            try {
              return this.visualBridge.getVisualSystem(key);
            } catch (error) {
            }
          }
          if (this.nonVisualFacade) {
            try {
              return await this.nonVisualFacade.getSystem(key);
            } catch (error) {
            }
          }
          return null;
        }
        // Cross-facade event system
        addEventListener(eventType, listener) {
          if (!this.crossFacadeEventListeners.has(eventType)) {
            this.crossFacadeEventListeners.set(eventType, []);
          }
          this.crossFacadeEventListeners.get(eventType).push(listener);
        }
        removeEventListener(eventType, listener) {
          const listeners = this.crossFacadeEventListeners.get(eventType);
          if (listeners) {
            const index = listeners.indexOf(listener);
            if (index !== -1) {
              listeners.splice(index, 1);
            }
          }
        }
        emitEvent(eventType, event) {
          const listeners = this.crossFacadeEventListeners.get(eventType);
          if (listeners) {
            listeners.forEach((listener) => {
              try {
                listener(event);
              } catch (error) {
                Y3K?.debug?.error("SystemCoordinator", `Error in event listener for ${eventType}:`, error);
              }
            });
          }
          this.currentMetrics.crossFacadeEvents++;
        }
        // Health monitoring
        async performHealthCheck() {
          const healthCheck = {
            overall: "good",
            facades: {
              visual: { ok: true, details: "Visual systems operational", systemCount: 0 },
              nonVisual: { ok: true, details: "Non-visual systems operational", systemCount: 0 }
            },
            sharedResources: {
              performanceAnalyzer: { ok: true, details: "Performance analyzer operational" },
              cssVariableBatcher: { ok: true, details: "CSS variable batcher operational" },
              musicSyncService: { ok: true, details: "Music sync service operational" }
            },
            recommendations: [],
            timestamp: performance.now()
          };
          if (this.visualBridge) {
            try {
              const visualHealth = await this.visualBridge.performVisualHealthCheck();
              healthCheck.facades.visual.ok = visualHealth.overall === "excellent" || visualHealth.overall === "good";
              healthCheck.facades.visual.details = `Visual systems: ${visualHealth.overall}`;
              healthCheck.facades.visual.systemCount = visualHealth.systems.size;
            } catch (error) {
              healthCheck.facades.visual.ok = false;
              healthCheck.facades.visual.details = `Visual facade error: ${error}`;
            }
          }
          if (this.nonVisualFacade) {
            try {
              const nonVisualHealth = await this.nonVisualFacade.performHealthCheck();
              healthCheck.facades.nonVisual.ok = nonVisualHealth.overall === "excellent" || nonVisualHealth.overall === "good";
              healthCheck.facades.nonVisual.details = `Non-visual systems: ${nonVisualHealth.overall}`;
              healthCheck.facades.nonVisual.systemCount = nonVisualHealth.systems.size;
            } catch (error) {
              healthCheck.facades.nonVisual.ok = false;
              healthCheck.facades.nonVisual.details = `Non-visual facade error: ${error}`;
            }
          }
          if (this.sharedPerformanceAnalyzer) {
            try {
              healthCheck.sharedResources.performanceAnalyzer.ok = true;
              healthCheck.sharedResources.performanceAnalyzer.details = "Performance analyzer operational";
            } catch (error) {
              healthCheck.sharedResources.performanceAnalyzer.ok = false;
              healthCheck.sharedResources.performanceAnalyzer.details = `Performance analyzer error: ${error}`;
            }
          }
          const facadeHealthy = healthCheck.facades.visual.ok && healthCheck.facades.nonVisual.ok;
          const resourcesHealthy = healthCheck.sharedResources.performanceAnalyzer.ok && healthCheck.sharedResources.cssVariableBatcher.ok && healthCheck.sharedResources.musicSyncService.ok;
          if (facadeHealthy && resourcesHealthy) {
            healthCheck.overall = "excellent";
          } else if (facadeHealthy || resourcesHealthy) {
            healthCheck.overall = "good";
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push("Multiple system failures detected - consider system restart");
          }
          if (this.currentMetrics.totalMemoryMB > 120) {
            healthCheck.recommendations.push("High memory usage - consider optimizing system memory");
          }
          if (this.currentMetrics.totalInitTime > 6e3) {
            healthCheck.recommendations.push("High initialization time - consider optimizing system startup");
          }
          this.lastHealthCheck = healthCheck;
          if (this.onHealthChange) {
            this.onHealthChange(healthCheck);
          }
          return healthCheck;
        }
        // Utility methods
        createInitialMetrics() {
          return {
            totalSystems: 0,
            visualSystems: 0,
            nonVisualSystems: 0,
            activeSystems: 0,
            failedSystems: 0,
            totalMemoryMB: 0,
            totalInitTime: 0,
            averageSystemInitTime: 0,
            crossFacadeLatency: 0,
            overallHealth: "good",
            visualHealth: "good",
            nonVisualHealth: "good",
            sharedDependencies: 5,
            // Number of shared dependencies
            crossFacadeEvents: 0,
            resourceOptimization: 0
          };
        }
        startMonitoring() {
          if (this.coordinationConfig.enableUnifiedPerformanceMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performHealthCheck();
            }, 2e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 2e3);
          }
        }
        updateMetrics() {
          if (this.visualBridge) {
            const visualMetrics = this.visualBridge.getMetrics();
            this.currentMetrics.visualHealth = visualMetrics.systemHealth;
          }
          if (this.nonVisualFacade) {
            const nonVisualMetrics = this.nonVisualFacade.getMetrics();
            this.currentMetrics.nonVisualHealth = nonVisualMetrics.systemHealth;
          }
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.totalMemoryMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          if (this.currentMetrics.visualHealth === "excellent" && this.currentMetrics.nonVisualHealth === "excellent") {
            this.currentMetrics.overallHealth = "excellent";
          } else if (this.currentMetrics.visualHealth === "critical" || this.currentMetrics.nonVisualHealth === "critical") {
            this.currentMetrics.overallHealth = "critical";
          } else if (this.currentMetrics.visualHealth === "degraded" || this.currentMetrics.nonVisualHealth === "degraded") {
            this.currentMetrics.overallHealth = "degraded";
          } else {
            this.currentMetrics.overallHealth = "good";
          }
          if (this.onPerformanceChange) {
            this.onPerformanceChange(this.currentMetrics);
          }
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          if (this.visualBridge) {
            await this.visualBridge.destroy();
            this.visualBridge = null;
          }
          if (this.nonVisualFacade) {
            await this.nonVisualFacade.destroy();
            this.nonVisualFacade = null;
          }
          if (this.sharedPerformanceAnalyzer) {
            this.sharedPerformanceAnalyzer.destroy();
            this.sharedPerformanceAnalyzer = null;
          }
          if (this.sharedCSSVariableBatcher) {
            this.sharedCSSVariableBatcher = null;
          }
          this.crossFacadeEventListeners.clear();
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.coordinationConfig };
        }
        async setConfiguration(config) {
          this.coordinationConfig = { ...this.coordinationConfig, ...config };
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        setOnPerformanceChange(callback) {
          this.onPerformanceChange = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            visualSystems: this.visualBridge?.getSystemStatus().systemsActive || 0,
            nonVisualSystems: this.nonVisualFacade?.getSystemStatus().systemsActive || 0,
            healthy: this.currentMetrics.overallHealth === "excellent" || this.currentMetrics.overallHealth === "good"
          };
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          Y3K?.debug?.log("SystemCoordinator", "System coordinator destroyed");
        }
      };
      __name(_SystemCoordinator, "SystemCoordinator");
      SystemCoordinator = _SystemCoordinator;
    }
  });

  // src-js/utils/dom/NowPlayingDomWatcher.ts
  function startNowPlayingWatcher(onChange, enableDebug = false) {
    const bar = document.querySelector(
      MODERN_SELECTORS["nowPlayingBar"]
    );
    if (!bar) {
      if (enableDebug) {
        console.warn(
          "\u{1F3B5} [NowPlayingDomWatcher] nowPlayingBar element not found \u2013 watcher inactive"
        );
      }
      return () => {
      };
    }
    const mObserver = new MutationObserver(() => {
      onChange();
      if (enableDebug)
        console.log(
          "\u{1F3B5} [NowPlayingDomWatcher] DOM mutation detected \u2192 onChange dispatched"
        );
    });
    mObserver.observe(bar, { childList: true, subtree: true });
    if (enableDebug) console.log("\u{1F3B5} [NowPlayingDomWatcher] watcher active");
    return () => {
      mObserver.disconnect();
      if (enableDebug) console.log("\u{1F3B5} [NowPlayingDomWatcher] watcher disposed");
    };
  }
  var init_NowPlayingDomWatcher = __esm({
    "src-js/utils/dom/NowPlayingDomWatcher.ts"() {
      "use strict";
      init_SpotifyDOMSelectors();
      __name(startNowPlayingWatcher, "startNowPlayingWatcher");
    }
  });

  // src-js/visual/base/starryNightEffects.ts
  function injectStarContainer() {
    const existingContainer = document.querySelector(
      ".sn-stars-container"
    );
    if (existingContainer) {
      return existingContainer;
    }
    const starContainer = document.createElement("div");
    starContainer.className = "sn-stars-container";
    for (let i = 1; i <= 5; i++) {
      const star = document.createElement("div");
      star.className = "star";
      if (Math.random() > 0.7) star.classList.add("twinkle");
      starContainer.appendChild(star);
    }
    document.body.appendChild(starContainer);
    return starContainer;
  }
  function applyStarryNightSettings(gradientIntensity, starDensity) {
    if (YEAR3000_CONFIG.enableDebug) {
      console.log("[StarryNightEffects] Applying settings:", {
        gradientIntensity,
        starDensity
      });
    }
    const body = document.body;
    const gradientClasses = [
      "sn-gradient-disabled",
      "sn-gradient-minimal",
      "sn-gradient-balanced",
      "sn-gradient-intense"
    ];
    const starClasses = [
      "sn-stars-disabled",
      "sn-stars-minimal",
      "sn-stars-balanced",
      "sn-stars-intense"
    ];
    body.classList.remove(...gradientClasses, ...starClasses);
    if (gradientIntensity !== "balanced") {
      body.classList.add(`sn-gradient-${gradientIntensity}`);
    }
    if (starDensity !== "balanced") {
      body.classList.add(`sn-stars-${starDensity}`);
    }
    const existingContainer = document.querySelector(".sn-stars-container");
    if (starDensity === "disabled") {
      existingContainer?.remove();
    } else {
      if (!existingContainer) {
        injectStarContainer();
      }
    }
  }
  var init_starryNightEffects = __esm({
    "src-js/visual/base/starryNightEffects.ts"() {
      "use strict";
      init_SettingsManager();
      init_globalConfig();
      __name(injectStarContainer, "injectStarContainer");
      __name(applyStarryNightSettings, "applyStarryNightSettings");
    }
  });

  // src-js/core/lifecycle/year3000System.ts
  var _Year3000System, Year3000System, year3000System, year3000System_default;
  var init_year3000System = __esm({
    "src-js/core/lifecycle/year3000System.ts"() {
      "use strict";
      init_SystemCoordinator();
      init_ColorOrchestrator();
      init_EventBus();
      init_globalConfig();
      init_Year3000Utilities();
      init_NowPlayingDomWatcher();
      init_starryNightEffects();
      _Year3000System = class _Year3000System {
        constructor(config = YEAR3000_CONFIG) {
          // Phase 4: Facade Coordination System (replaces direct system properties)
          this.facadeCoordinator = null;
          // Private initialization results storage
          this._initializationResults = null;
          // API availability tracking
          this.availableAPIs = null;
          this._songChangeHandler = null;
          // Stats
          this._lastInitializationTime = null;
          this._initializationRetryHistory = [];
          this._systemStartTime = null;
          this._disposeNowPlayingWatcher = null;
          /**
           * Indicates whether automatic harmonic evolution is permitted. This mirrors the
           * `sn-harmonic-evolution` setting and `YEAR3000_CONFIG.harmonicEvolution`.
           * Sub-systems can read this flag instead of accessing the config directly so
           * that future scheduling logic (e.g. TimerConsolidationSystem) can rely on a
           * guaranteed field.
           */
          this.allowHarmonicEvolution = true;
          /** Global switch other systems can read to know guardrails are active */
          this.performanceGuardActive = false;
          this.YEAR3000_CONFIG = this._deepCloneConfig(config);
          if (typeof this.YEAR3000_CONFIG.init === "function") {
            this.YEAR3000_CONFIG.init();
          }
          this.utils = Year3000Utilities_exports;
          this.initialized = false;
          this._systemStartTime = Date.now();
          this._initializationResults = null;
          if (this.YEAR3000_CONFIG?.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Constructor: Instance created with Enhanced Master Animation Coordinator"
            );
          }
          this._boundExternalSettingsHandler = this._handleExternalSettingsChange.bind(this);
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this._boundExternalSettingsHandler
          );
          this._boundArtisticModeHandler = this._onArtisticModeChanged.bind(this);
          document.addEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          this._boundVisibilityChangeHandler = this._handleVisibilityChange.bind(this);
          document.addEventListener(
            "visibilitychange",
            this._boundVisibilityChangeHandler
          );
          this._disposeNowPlayingWatcher = startNowPlayingWatcher(() => {
            this.queueCSSVariableUpdate("--sn-force-refresh", Date.now().toString());
          }, this.YEAR3000_CONFIG.enableDebug);
          this.allowHarmonicEvolution = this.YEAR3000_CONFIG.harmonicEvolution ?? true;
          setTimeout(() => {
            this._applyPerformanceProfile();
          }, 0);
        }
        // Phase 4: Pure Facade Access Property Getters
        // Performance Systems
        get enhancedMasterAnimationCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("EnhancedMasterAnimationCoordinator") || null;
        }
        get timerConsolidationSystem() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("TimerConsolidationSystem") || null;
        }
        get cssVariableBatcher() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("CSSVariableBatcher") || null;
        }
        get unifiedCSSManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedCSSVariableManager") || null;
        }
        get performanceCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedPerformanceCoordinator") || null;
        }
        get deviceCapabilityDetector() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("DeviceCapabilityDetector") || null;
        }
        get performanceAnalyzer() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("PerformanceAnalyzer") || null;
        }
        get unifiedPerformanceCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedPerformanceCoordinator") || null;
        }
        get performanceCSSIntegration() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("PerformanceCSSIntegration") || null;
        }
        // Managers and Services
        get systemHealthMonitor() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedDebugManager") || null;
        }
        get settingsManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("SettingsManager") || null;
        }
        get colorHarmonyEngine() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("ColorHarmonyEngine") || null;
        }
        get musicSyncService() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("MusicSyncService") || null;
        }
        get glassmorphismManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("GlassmorphismManager") || null;
        }
        get card3DManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("Card3DManager") || null;
        }
        // Visual Systems
        get lightweightParticleSystem() {
          return this.facadeCoordinator?.getVisualSystem("Particle") || null;
        }
        get interactionTrackingSystem() {
          return this.facadeCoordinator?.getVisualSystem("InteractionTracking") || null;
        }
        get beatSyncVisualSystem() {
          return this.facadeCoordinator?.getVisualSystem("OrganicBeatSync") || null;
        }
        get webGLGradientBackgroundSystem() {
          return this.facadeCoordinator?.getVisualSystem("WebGLBackground") || null;
        }
        get particleFieldSystem() {
          return this.facadeCoordinator?.getVisualSystem("ParticleField") || null;
        }
        get emergentChoreographyEngine() {
          return this.enhancedMasterAnimationCoordinator || null;
        }
        get spotifyUIApplicationSystem() {
          return this.facadeCoordinator?.getVisualSystem("SpotifyUIApplication") || null;
        }
        // Organic Consciousness System (Year 3000 Philosophy)
        get organicBeatSyncConsciousness() {
          return this.facadeCoordinator?.getVisualSystem("OrganicBeatSync") || this.beatSyncVisualSystem;
        }
        // Integration Systems Getters
        get sidebarSystemsIntegration() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("SidebarSystemsIntegration") || null;
        }
        get unifiedSystemIntegration() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedSystemIntegration") || null;
        }
        _deepCloneConfig(config) {
          return config;
        }
        updateConfiguration(key, value) {
          if (!this.YEAR3000_CONFIG) {
            console.warn(
              "[Year3000System] Cannot update configuration - config not initialized"
            );
            return;
          }
          const keyPath = key.split(".").filter(Boolean);
          if (!keyPath.length) {
            return;
          }
          let current = this.YEAR3000_CONFIG;
          const finalKey = keyPath.pop();
          if (!finalKey) {
            return;
          }
          for (const pathKey of keyPath) {
            if (typeof current[pathKey] !== "object" || current[pathKey] === null) {
              current[pathKey] = {};
            }
            current = current[pathKey];
          }
          const oldValue = current[finalKey];
          current[finalKey] = value;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `[Year3000System] Configuration updated: ${key} = ${value} (was: ${oldValue})`
            );
          }
          this._notifyConfigurationChange(key, value, oldValue);
        }
        _notifyConfigurationChange(key, newValue, oldValue) {
        }
        async initializeAllSystems() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F30C} [Year3000System] initializeAllSystems(): Starting full system initialization..."
            );
          }
          this._systemStartTime = Date.now();
          const startTime = performance.now();
          const initializationResults = {
            success: [],
            failed: [],
            skipped: []
          };
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F30C} [Year3000System] Initializing Facade Coordination System...");
          }
          try {
            this.facadeCoordinator = new SystemCoordinator(
              this.YEAR3000_CONFIG,
              this.utils,
              this
            );
            await this.facadeCoordinator.initialize({
              mode: "unified",
              enableSharedDependencies: true,
              enableCrossFacadeCommunication: true,
              enableUnifiedPerformanceMonitoring: true,
              enableResourceOptimization: true,
              performanceThresholds: {
                maxTotalMemoryMB: 100,
                maxTotalInitTime: 5e3,
                maxCrossCommLatency: 50
              },
              coordinationPreferences: {
                preferSharedResources: true,
                enableEventPropagation: true,
                enableHealthCoordination: true
              }
            });
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Facade Coordination System initialized successfully");
            }
            await this._initializeFacadeSystems();
          } catch (error) {
            console.error("\u{1F30C} [Year3000System] Failed to initialize Facade Coordination System:", error);
            throw error;
          }
          initializationResults.success.push("FacadeCoordinationSystem");
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.startMonitoring();
            this.performanceGuardActive = true;
          }
          if (this.enhancedMasterAnimationCoordinator) {
            await this._registerEnhancedAnimationSystems();
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F3AC} [Year3000System] Enhanced animation system registration phase complete"
              );
            }
          } else {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for enhanced registration phase"
            );
          }
          this._initializationResults = initializationResults;
          this.initialized = true;
          const endTime = performance.now();
          this._lastInitializationTime = endTime - startTime;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `[Year3000System] System initialization complete in ${this._lastInitializationTime.toFixed(
                2
              )}ms.`
            );
            console.log(
              `[Year3000System] Results: ${initializationResults.success.length} success, ${initializationResults.failed.length} failed.`
            );
            if (initializationResults.failed.length > 0) {
              console.warn(
                `[Year3000System] Failed systems: ${initializationResults.failed.join(
                  ", "
                )}`
              );
            }
            if (initializationResults.skipped && initializationResults.skipped.length > 0) {
              console.info(
                `[Year3000System] Skipped systems: ${initializationResults.skipped.join(
                  ", "
                )}`
              );
            }
            if (initializationResults.success.length > 0) {
              console.info(
                `[Year3000System] Successful systems: ${initializationResults.success.join(
                  ", "
                )}`
              );
            }
            if (this.systemHealthMonitor) {
              this.systemHealthMonitor.logHealthReport();
            }
          }
        }
        /**
         * Initialize essential systems for degraded mode (no Spicetify APIs)
         * Phase 4: Essential system initialization for degraded mode
         */
        async _initializeEssentialFacadeSystems() {
          if (!this.facadeCoordinator) {
            throw new Error("Facade coordinator not available for essential system initialization");
          }
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F30C} [Year3000System] Initializing essential systems for degraded mode...");
          }
          try {
            const essentialSystems = [
              "PerformanceAnalyzer",
              "CSSVariableBatcher",
              "UnifiedDebugManager",
              "DeviceCapabilityDetector",
              "TimerConsolidationSystem"
            ];
            for (const systemKey of essentialSystems) {
              try {
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] Essential: Initialized ${systemKey} via facade`);
                  }
                }
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] Failed to initialize essential ${systemKey}:`, error);
              }
            }
            if (this.performanceAnalyzer) {
              this.performanceAnalyzer.startMonitoring();
              this.performanceGuardActive = true;
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] Essential: Performance monitoring started");
              }
            }
          } catch (error) {
            console.error("\u{1F30C} [Year3000System] Essential facade system initialization failed:", error);
            throw error;
          }
        }
        /**
         * Initialize essential systems through facade pattern
         * Phase 4: Core system initialization via facades
         */
        async _initializeFacadeSystems() {
          if (!this.facadeCoordinator) {
            throw new Error("Facade coordinator not available for system initialization");
          }
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F30C} [Year3000System] Initializing essential systems through facades...");
          }
          try {
            const essentialNonVisualSystems = [
              "PerformanceAnalyzer",
              "CSSVariableBatcher",
              "UnifiedDebugManager",
              "SettingsManager",
              "DeviceCapabilityDetector",
              "TimerConsolidationSystem",
              "UnifiedPerformanceCoordinator",
              "MusicSyncService",
              "ColorHarmonyEngine",
              "GlassmorphismManager",
              // 🌊 Essential glassmorphism effects
              "Card3DManager"
              // 🎴 Essential 3D card transformations
            ];
            for (const systemKey of essentialNonVisualSystems) {
              try {
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] Initialized ${systemKey} via facade`);
                  }
                }
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] Failed to initialize ${systemKey}:`, error);
              }
            }
            try {
              await globalColorOrchestrator.initialize();
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F3A8} [Year3000System] ColorOrchestrator initialized for strategy pattern coordination");
              }
            } catch (error) {
              console.error("\u{1F3A8} [Year3000System] Failed to initialize ColorOrchestrator:", error);
            }
            if (this.performanceAnalyzer) {
              this.performanceAnalyzer.startMonitoring();
              this.performanceGuardActive = true;
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] Performance monitoring started");
              }
            }
            const essentialVisualSystems = [
              "Particle",
              "ParticleField",
              "WebGLBackground",
              // 🌌 Enable WebGL gradient backgrounds
              "SpotifyUIApplication",
              // 🎨 Core UI color application
              "OrganicBeatSync",
              "InteractionTracking"
              // EmergentChoreography integrated into EnhancedMasterAnimationCoordinator
            ];
            for (const systemKey of essentialVisualSystems) {
              try {
                const system = this.facadeCoordinator.getVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.YEAR3000_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] Initialized visual ${systemKey} via facade`);
                  }
                }
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] Failed to initialize visual ${systemKey}:`, error);
              }
            }
            await this._linkSystemDependencies();
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Facade system initialization complete");
            }
          } catch (error) {
            console.error("\u{1F30C} [Year3000System] Facade system initialization failed:", error);
            throw error;
          }
        }
        /**
         * Link system dependencies after facade initialization
         * Phase 4: Connect systems that need cross-references
         */
        async _linkSystemDependencies() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F30C} [Year3000System] Linking system dependencies...");
          }
          try {
            if (this.musicSyncService && this.colorHarmonyEngine) {
              this.musicSyncService.setColorHarmonyEngine(this.colorHarmonyEngine);
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] ColorHarmonyEngine linked to MusicSyncService");
              }
            }
            if (this.colorHarmonyEngine && this.enhancedMasterAnimationCoordinator) {
              this.colorHarmonyEngine.setEmergentEngine(this.enhancedMasterAnimationCoordinator);
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] EnhancedMasterAnimationCoordinator (with emergent functionality) linked to ColorHarmonyEngine");
              }
            }
            if (this.systemHealthMonitor) {
              const systemsToRegister = [
                { name: "MusicSyncService", system: this.musicSyncService },
                { name: "ColorHarmonyEngine", system: this.colorHarmonyEngine },
                { name: "SettingsManager", system: this.settingsManager }
              ];
              for (const { name, system } of systemsToRegister) {
                if (system) {
                  this.systemHealthMonitor.registerSystem(name, system);
                }
              }
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] Systems registered with health monitor");
              }
            }
          } catch (error) {
            console.error("\u{1F30C} [Year3000System] Failed to link system dependencies:", error);
          }
        }
        /**
         * Legacy function - removed prediction systems entirely for performance optimization
         */
        _shouldSkipPredictionSystem(systemName) {
          return false;
          if (!this.deviceCapabilityDetector) {
            return false;
          }
          const performanceLevel = this.deviceCapabilityDetector.recommendPerformanceQuality();
          if (performanceLevel === "low") {
            return true;
          }
          if (this.deviceCapabilityDetector.deviceCapabilities?.display?.reducedMotion) {
            return true;
          }
          return false;
        }
        async _initializeVisualSystems(results) {
          if (!this.performanceAnalyzer || !this.musicSyncService || !this.settingsManager) {
            console.error(
              "[Year3000System] Cannot initialize visual systems due to missing core dependencies (PerformanceAnalyzer, MusicSyncService, or SettingsManager)."
            );
            const visualSystems = [
              "LightweightParticleSystem",
              "InteractionTrackingSystem",
              "BeatSyncVisualSystem",
              "SidebarSystemsIntegration"
              // "EmergentChoreographyEngine", // Consolidated into EnhancedMasterAnimationCoordinator
            ];
            visualSystems.forEach((s) => results.skipped.push(s));
            return;
          }
          if (this.colorHarmonyEngine && this.enhancedMasterAnimationCoordinator) {
            this.colorHarmonyEngine.setEmergentEngine(
              this.enhancedMasterAnimationCoordinator
            );
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F517} [Year3000System] EnhancedMasterAnimationCoordinator (emergent functionality) linked to ColorHarmonyEngine."
              );
            }
          }
        }
        async destroyAllSystems() {
          if (this.facadeCoordinator) {
            await this.facadeCoordinator.destroy();
            this.facadeCoordinator = null;
          }
          this._initializationResults = null;
          if (Spicetify.Player && this._songChangeHandler) {
            Spicetify.Player.removeEventListener(
              "songchange",
              this._songChangeHandler
            );
          }
          this.initialized = false;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F525} [Year3000System] All systems have been destroyed.");
          }
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this._boundExternalSettingsHandler
          );
          document.removeEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          document.removeEventListener(
            "visibilitychange",
            this._boundVisibilityChangeHandler
          );
          if (this._disposeNowPlayingWatcher) {
            this._disposeNowPlayingWatcher();
            this._disposeNowPlayingWatcher = null;
          }
        }
        async applyInitialSettings() {
          if (!this.settingsManager) {
            console.warn(
              "[Year3000System] SettingsManager not ready, cannot apply initial settings."
            );
            return;
          }
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F3A8} [Year3000System] Inside applyInitialSettings. SettingsManager valid:",
              !!this.settingsManager
            );
          }
          try {
            console.log(
              "\u{1F3A8} [Year3000System] applyInitialSettings: Getting initial settings..."
            );
            const accent = this.settingsManager.get("catppuccin-accentColor");
            const gradient = this.settingsManager.get("sn-gradient-intensity");
            const stars = this.settingsManager.get("sn-star-density");
            const intensityRaw = this.settingsManager.get("sn-harmonic-intensity");
            const evolutionRaw = this.settingsManager.get("sn-harmonic-evolution");
            const harmonicModeKey = this.settingsManager.get(
              "sn-current-harmonic-mode"
            );
            if (harmonicModeKey) {
              this.YEAR3000_CONFIG.currentHarmonicMode = String(harmonicModeKey);
            }
            console.log(
              `\u{1F3A8} [Year3000System] applyInitialSettings: Accent=${accent}, Gradient=${gradient}, Stars=${stars}`
            );
            if (accent !== "dynamic") {
              await this._applyCatppuccinAccent(accent);
            } else if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F3A8} [Year3000System] Skipping static accent application because 'dynamic' accent is selected."
              );
            }
            await this._applyStarryNightSettings(
              gradient,
              stars
            );
            const intensity = parseFloat(intensityRaw);
            if (!Number.isNaN(intensity)) {
              if (this.colorHarmonyEngine) {
                this.colorHarmonyEngine.setIntensity?.(intensity);
              }
              this.YEAR3000_CONFIG.harmonicIntensity = intensity;
            }
            const evolutionEnabled = evolutionRaw === "true";
            this.allowHarmonicEvolution = evolutionEnabled;
            this.YEAR3000_CONFIG.harmonicEvolution = evolutionEnabled;
            console.log(
              "\u{1F3A8} [Year3000System] applyInitialSettings: Successfully applied initial settings."
            );
          } catch (error) {
            console.error("[Year3000System] Error applying initial settings:", error);
          }
        }
        async _applyCatppuccinAccent(selectedAccent) {
          if (selectedAccent === "dynamic") {
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "\u{1F3A8} [Year3000System] _applyCatppuccinAccent: 'dynamic' accent selected \u2013 skipping static accent overrides."
              );
            }
            return;
          }
          console.log(
            `\u{1F3A8} [Year3000System] _applyCatppuccinAccent: Applying accent color '${selectedAccent}'`
          );
          const accent = selectedAccent === "none" ? "text" : selectedAccent;
          const colorScheme = Spicetify.Config.color_scheme || "mocha";
          const equalizerUrl = document.querySelector(
            "body > script.marketplaceScript"
          ) ? `url('https://github.com/catppuccin/spicetify/blob/main/catppuccin/assets/${colorScheme}/equalizer-animated-${accent}.gif?raw=true')` : `url('${colorScheme}/equalizer-animated-${accent}.gif')`;
          this.cssVariableBatcher?.queueCSSVariableUpdate(
            "--spice-text",
            `var(--spice-${accent})`
          );
          this.cssVariableBatcher?.queueCSSVariableUpdate(
            "--spice-button-active",
            `var(--spice-${accent})`
          );
          this.cssVariableBatcher?.queueCSSVariableUpdate(
            "--spice-equalizer",
            equalizerUrl
          );
          this.cssVariableBatcher?.flushCSSVariableBatch();
          console.log(
            `\u{1F3A8} [Year3000System] _applyCatppuccinAccent: Flushed CSS variables for accent color.`
          );
        }
        async _applyStarryNightSettings(gradientIntensity, starDensity) {
          try {
            applyStarryNightSettings(gradientIntensity, starDensity);
          } catch (error) {
            console.error("[Year3000System] Failed to apply starry night settings");
          }
        }
        applyColorsToTheme(extractedColors = {}) {
          let harmonizedColors = extractedColors;
          if (this.colorHarmonyEngine) {
            try {
              harmonizedColors = this.colorHarmonyEngine.blendWithCatppuccin(extractedColors);
            } catch (error) {
              console.error(
                "[Year3000System] ColorHarmonyEngine blend failed:",
                error
              );
            }
          }
          this._applyHarmonizedColorsToCss(harmonizedColors);
        }
        /**
         * Handle colors/harmonized event from ColorOrchestrator (Event-driven architecture)
         */
        handleColorHarmonizedEvent(event) {
          if (event.type !== "colors/harmonized") return;
          const { processedColors, cssVariables, metadata } = event.payload;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F3A8} [Year3000System] Received harmonized colors via event-driven pattern", {
              strategy: metadata.strategy,
              processingTime: metadata.processingTime,
              colorsCount: Object.keys(processedColors).length,
              cssVariablesCount: Object.keys(cssVariables).length
            });
          }
          try {
            this._applyHarmonizedColorsToCss(processedColors);
            if (cssVariables && Object.keys(cssVariables).length > 0) {
              this._applyCSSVariables(cssVariables);
            }
          } catch (error) {
            console.error("[Year3000System] Failed to apply harmonized colors from event:", error);
            this._applyHarmonizedColorsToCss(processedColors);
          }
        }
        /**
         * Apply CSS variables directly (optimization for event-driven pattern)
         */
        _applyCSSVariables(cssVariables) {
          try {
            const root = document.documentElement;
            for (const [variable, value] of Object.entries(cssVariables)) {
              if (variable && value) {
                root.style.setProperty(variable, value);
              }
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Applied CSS variables directly", {
                variablesCount: Object.keys(cssVariables).length,
                variables: Object.keys(cssVariables)
              });
            }
          } catch (error) {
            console.error("[Year3000System] Failed to apply CSS variables:", error);
          }
        }
        // =============================================
        // 🎨 INTERNAL – APPLY COLOR MAP TO CSS VARIABLES
        // =============================================
        _applyHarmonizedColorsToCss(colors = {}) {
          if (!colors || Object.keys(colors).length === 0) {
            colors = { VIBRANT: "#a6adc8" };
          }
          const primaryHex = colors["VIBRANT"] || colors["PROMINENT"] || colors["PRIMARY"] || Object.values(colors)[0];
          const secondaryHex = colors["DARK_VIBRANT"] || colors["DESATURATED"] || colors["SECONDARY"] || primaryHex;
          const accentHex = colors["VIBRANT_NON_ALARMING"] || colors["LIGHT_VIBRANT"] || primaryHex;
          const queueUpdate = /* @__PURE__ */ __name((prop, value) => {
            if (this.cssVariableBatcher) {
              this.cssVariableBatcher.queueCSSVariableUpdate(prop, value);
            } else {
              document.documentElement.style.setProperty(prop, value);
            }
          }, "queueUpdate");
          if (accentHex) {
            queueUpdate("--spice-accent", accentHex);
            queueUpdate("--spice-button", accentHex);
            queueUpdate("--spice-button-active", accentHex);
            if (primaryHex) queueUpdate("--spice-player", primaryHex);
          }
          const addRgb = /* @__PURE__ */ __name((prop, hex) => {
            if (!hex) return;
            const rgb = this.utils.hexToRgb(hex);
            if (rgb) {
              queueUpdate(prop, `${rgb.r},${rgb.g},${rgb.b}`);
            }
          }, "addRgb");
          if (accentHex) {
            queueUpdate("--sn-canonical-accent-hex", accentHex);
          }
          addRgb("--sn-canonical-accent-rgb", accentHex);
          addRgb("--spice-rgb-accent", accentHex);
          addRgb("--spice-rgb-button", accentHex);
          addRgb("--spice-rgb-player", primaryHex);
          const root = this.utils.getRootStyle();
          if (root) {
            const computedStyle = getComputedStyle(root);
            const addSpiceRgb = /* @__PURE__ */ __name((rgbProp, hexProp, fallbackHex) => {
              const hexValue = computedStyle.getPropertyValue(hexProp).trim() || fallbackHex;
              addRgb(rgbProp, hexValue);
            }, "addSpiceRgb");
            addSpiceRgb("--spice-rgb-main", "--spice-main", "#cdd6f4");
            addSpiceRgb("--spice-rgb-base", "--spice-base", "#1e1e2e");
            addSpiceRgb("--spice-rgb-player", "--spice-player", "#181825");
            addSpiceRgb("--spice-rgb-sidebar", "--spice-sidebar", "#313244");
            addSpiceRgb("--spice-rgb-surface0", "--spice-surface0", "#313244");
            addSpiceRgb("--spice-rgb-surface1", "--spice-surface1", "#45475a");
            addSpiceRgb("--spice-rgb-text", "--spice-text", "#cdd6f4");
          }
          if (this.cssVariableBatcher) {
            this.cssVariableBatcher.flushCSSVariableBatch();
          }
          try {
            if (this.glassmorphismManager && primaryHex && secondaryHex) {
              this.glassmorphismManager.updateGlassColors(primaryHex, secondaryHex);
            }
          } catch (e) {
            console.warn(
              "[Year3000System] GlassmorphismManager colour update failed:",
              e
            );
          }
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log("\u{1F3A8} [Year3000System] Applied harmonized colours", {
              primaryHex,
              secondaryHex,
              accentHex
            });
          }
        }
        // =============================================
        // 🆕 PUBLIC WRAPPER – UNIFIED CSS VARIABLE BATCH API
        // =============================================
        /**
         * Queue a CSS variable update through the shared CSSVariableBatcher. Falls
         * back to an immediate style mutation when the batcher is unavailable
         * (degraded mode or very early boot).
         *
         * @param property  The CSS custom property name (e.g. "--sn-nav-intensity")
         * @param value     The value to assign (raw string, keep units if needed)
         * @param element   Optional specific HTMLElement target. When omitted the
         *                  root <html> element is used so variables cascade.
         */
        queueCSSVariableUpdate(property, value, element = null) {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueUpdate(
              property,
              value,
              "normal",
              "Year3000System"
            );
          } else if (this.cssVariableBatcher) {
            this.cssVariableBatcher.queueCSSVariableUpdate(
              property,
              value,
              element || void 0
            );
          } else {
            const target = element || document.documentElement;
            target.style.setProperty(property, value);
          }
        }
        setGradientParameters() {
          if (this.colorHarmonyEngine) {
          }
        }
        async updateColorsFromCurrentTrack() {
          if (this.musicSyncService) {
            await this.musicSyncService.processSongUpdate();
          }
        }
        evolveHarmonicSignature(selectedModeKey, baseSourceHex) {
          if (this.colorHarmonyEngine) {
            const rgb = this.utils.hexToRgb(baseSourceHex);
            if (rgb) {
              const variations = this.colorHarmonyEngine.generateHarmonicVariations(rgb);
              return {
                derivedDarkVibrantHex: variations.darkVibrantHex,
                derivedLightVibrantHex: variations.lightVibrantHex
              };
            }
          }
          return null;
        }
        async waitForTrackData(maxRetries = 10, delayMs = 100) {
          for (let i = 0; i < maxRetries; i++) {
            if (Spicetify.Player.data?.track?.uri) {
              return Spicetify.Player.data;
            }
            await this.utils.sleep(delayMs);
          }
          return null;
        }
        updateHarmonicBaseColor(hexColor) {
          if (this.colorHarmonyEngine && this.cssVariableBatcher) {
            const rgb = this.utils.hexToRgb(hexColor);
            if (rgb) {
              const variations = this.colorHarmonyEngine.generateHarmonicVariations(rgb);
              this.cssVariableBatcher.queueCSSVariableUpdate(
                "--sn-harmonic-base-dark-vibrant",
                variations.darkVibrantHex
              );
              this.cssVariableBatcher.queueCSSVariableUpdate(
                "--sn-harmonic-base-light-vibrant",
                variations.lightVibrantHex
              );
              this.cssVariableBatcher.flushCSSVariableBatch();
            }
          }
        }
        setupMusicAnalysisAndColorExtraction() {
          if (!this.musicSyncService) {
            console.error(
              "[Year3000System] MusicSyncService is not available to set up song change handler."
            );
            return;
          }
          if (!window.Spicetify?.Player) {
            console.warn(
              "[Year3000System] Spicetify.Player not available - music analysis disabled"
            );
            return;
          }
          try {
            GlobalEventBus.subscribe("colors/harmonized", (event) => {
              this.handleColorHarmonizedEvent(event);
            });
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Subscribed to colors/harmonized events for event-driven color application");
            }
          } catch (error) {
            console.error("[Year3000System] Failed to subscribe to colors/harmonized events:", error);
          }
          const processSongUpdate = /* @__PURE__ */ __name(async () => {
            if (this.musicSyncService) {
              await this.musicSyncService.processSongUpdate();
            }
          }, "processSongUpdate");
          this._songChangeHandler = processSongUpdate;
          try {
            window.Spicetify.Player.addEventListener(
              "songchange",
              this._songChangeHandler
            );
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                "[Year3000System] Music analysis and color extraction set up successfully"
              );
            }
            setTimeout(processSongUpdate, 1e3);
          } catch (error) {
            console.error("[Year3000System] Failed to set up music analysis:", error);
            this._songChangeHandler = null;
          }
        }
        updateFromMusicAnalysis(processedData, rawFeatures, trackUri) {
          if (!processedData) return;
          this._updateGlobalKinetics(processedData);
        }
        _updateGlobalKinetics(data) {
          const root = this.utils.getRootStyle();
          if (!root) return;
          const safe = /* @__PURE__ */ __name((value, fallback = 0) => Number.isFinite(value) ? value : fallback, "safe");
          const processedEnergy = safe(data.processedEnergy);
          const valence = safe(data.valence);
          const enhancedBPM = safe(data.enhancedBPM);
          const beatInterval = safe(data.beatInterval);
          const animationSpeed = safe(data.animationSpeedFactor, 1);
          root.style.setProperty("--sn-kinetic-energy", processedEnergy.toFixed(3));
          root.style.setProperty("--sn-kinetic-valence", valence.toFixed(3));
          root.style.setProperty("--sn-kinetic-bpm", enhancedBPM.toFixed(2));
          root.style.setProperty(
            "--sn-kinetic-beat-interval",
            `${beatInterval.toFixed(0)}ms`
          );
          root.style.setProperty(
            "--sn-kinetic-animation-speed",
            animationSpeed.toFixed(3)
          );
        }
        // Animation System Registration Methods
        registerAnimationSystem(name, system, priority = "normal", targetFPS = 60) {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              `[Year3000System] Cannot register ${name} - EnhancedMasterAnimationCoordinator not ready`
            );
            return false;
          }
          this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
            name,
            system,
            priority,
            targetFPS
          );
          return true;
        }
        unregisterAnimationSystem(name) {
          if (!this.enhancedMasterAnimationCoordinator) {
            return false;
          }
          this.enhancedMasterAnimationCoordinator.unregisterAnimationSystem(name);
          return true;
        }
        /**
         * Public accessor that returns a subsystem instance by its constructor name or
         * by the conventional camel-cased property key. This is primarily used for
         * loose coupling between visual systems (e.g. BehaviouralPredictionEngine ⇆
         * PredictiveMaterializationSystem). Returns `null` when the requested system
         * is not available or not yet initialised.
         */
        getSystem(name) {
          if (!name) return null;
          if (this.unifiedSystemIntegration) {
            const unifiedSystem = this.unifiedSystemIntegration.getSystem(name);
            if (unifiedSystem) return unifiedSystem;
          }
          const camel = name.charAt(0).toLowerCase() + name.slice(1);
          if (this[camel]) return this[camel];
          for (const key of Object.keys(this)) {
            const maybeInstance = this[key];
            if (maybeInstance && maybeInstance.constructor?.name === name) {
              return maybeInstance;
            }
          }
          return null;
        }
        /**
         * Get the unified system registry for direct access
         */
        getUnifiedSystemRegistry() {
          return this.unifiedSystemIntegration?.getRegistry();
        }
        /**
         * Get health status of all unified systems
         */
        async getUnifiedSystemHealthStatus() {
          return this.unifiedSystemIntegration?.getHealthStatus();
        }
        async _registerAnimationSystems() {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for visual system registration"
            );
            return;
          }
          const visualSystems = [
            {
              name: "BeatSyncVisualSystem",
              system: this.beatSyncVisualSystem,
              priority: "critical"
            },
            // EmergentChoreographyEngine consolidated into EnhancedMasterAnimationCoordinator
            {
              name: "SidebarSystemsIntegration",
              system: this.sidebarSystemsIntegration,
              priority: "normal"
            },
            {
              name: "LightweightParticleSystem",
              system: this.lightweightParticleSystem,
              priority: "background"
            },
            {
              name: "InteractionTrackingSystem",
              system: this.interactionTrackingSystem,
              priority: "background"
            },
            {
              name: "SpotifyUIApplicationSystem",
              system: this.spotifyUIApplicationSystem,
              priority: "normal"
            }
          ];
          for (const { name, system, priority } of visualSystems) {
            if (system && (typeof system.onAnimate === "function" || typeof system.updateAnimation === "function")) {
              let optimizedPriority = priority;
              let targetFPS = 60;
              const currentProfile = system.currentPerformanceProfile;
              if (currentProfile?.frameRate) {
                targetFPS = currentProfile.frameRate;
              } else if (currentProfile?.quality) {
                const quality = currentProfile.quality;
                targetFPS = quality === "high" ? 60 : quality === "low" ? 30 : 45;
              }
              if (name.includes("BeatSync")) {
                optimizedPriority = "critical";
              } else if (name.includes("Particle") || name.includes("DataGlyph")) {
                optimizedPriority = "background";
                targetFPS = Math.min(targetFPS, 30);
              }
              this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
                name,
                system,
                optimizedPriority,
                targetFPS
              );
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  `\u{1F3AC} [Year3000System] Registered ${name} with Enhanced Master Animation Coordinator (${optimizedPriority} priority, ${targetFPS}fps) - using ${typeof system.onAnimate === "function" ? "onAnimate" : "updateAnimation"} hook`
                );
              }
            }
          }
        }
        /**
         * Register visual systems with the EnhancedMasterAnimationCoordinator
         * Phase 4: Animation System Consolidation
         */
        async _registerEnhancedAnimationSystems() {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for enhanced visual system registration"
            );
            return;
          }
          const enhancedVisualSystems = [
            {
              name: "BeatSyncVisualSystem",
              system: this.beatSyncVisualSystem,
              priority: "critical",
              type: "animation"
            },
            // EmergentChoreographyEngine consolidated into EnhancedMasterAnimationCoordinator
            {
              name: "SidebarSystemsIntegration",
              system: this.sidebarSystemsIntegration,
              priority: "normal",
              type: "animation"
            },
            {
              name: "LightweightParticleSystem",
              system: this.lightweightParticleSystem,
              priority: "background",
              type: "animation"
            },
            {
              name: "InteractionTrackingSystem",
              system: this.interactionTrackingSystem,
              priority: "background",
              type: "animation"
            },
            {
              name: "SpotifyUIApplicationSystem",
              system: this.spotifyUIApplicationSystem,
              priority: "normal",
              type: "animation"
            }
          ];
          for (const { name, system, priority, type } of enhancedVisualSystems) {
            if (system) {
              try {
                let registered = false;
                if (type === "animation" && (typeof system.onAnimate === "function" || typeof system.updateAnimation === "function")) {
                  registered = this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
                    name,
                    system,
                    priority,
                    60
                    // Default 60fps
                  );
                }
                if (registered && this.YEAR3000_CONFIG.enableDebug) {
                  console.log(
                    `\u{1F3AC} [Year3000System] Enhanced registration: ${name} (${priority} priority, ${type} type)`
                  );
                } else if (!registered) {
                  console.warn(
                    `[Year3000System] Failed to register ${name} with EnhancedMasterAnimationCoordinator`
                  );
                }
              } catch (error) {
                console.error(
                  `[Year3000System] Error registering ${name} with EnhancedMasterAnimationCoordinator:`,
                  error
                );
              }
            }
          }
        }
        // Progressive Loading Methods for Extension Support
        async initializeWithAvailableAPIs(availableAPIs) {
          this.availableAPIs = availableAPIs;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `\u{1F31F} [Year3000System] Progressive initialization mode: ${availableAPIs.degradedMode ? "DEGRADED" : "FULL"}`
            );
            console.log(`\u{1F31F} [Year3000System] Available APIs:`, {
              player: !!availableAPIs.player,
              platform: !!availableAPIs.platform,
              config: !!availableAPIs.config
            });
          }
          if (availableAPIs.degradedMode) {
            console.log(
              "\u{1F31F} [Year3000System] Initializing in degraded mode (visual-only systems)"
            );
            await this.initializeVisualOnlySystems();
          } else {
            console.log(
              "\u{1F31F} [Year3000System] Initializing in full mode (all systems)"
            );
            await this.initializeAllSystems();
          }
          if (availableAPIs.degradedMode) {
            this.setupProgressiveEnhancement();
          }
        }
        async initializeVisualOnlySystems() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Starting visual-only system initialization..."
            );
          }
          const startTime = performance.now();
          const initializationResults = {
            success: [],
            failed: [],
            skipped: []
          };
          try {
            this.facadeCoordinator = new SystemCoordinator(
              this.YEAR3000_CONFIG,
              this.utils,
              this
            );
            await this.facadeCoordinator.initialize({
              mode: "performance-optimized",
              enableSharedDependencies: true,
              enableCrossFacadeCommunication: false,
              enableUnifiedPerformanceMonitoring: true,
              enableResourceOptimization: true,
              performanceThresholds: {
                maxTotalMemoryMB: 50,
                maxTotalInitTime: 3e3,
                maxCrossCommLatency: 100
              },
              coordinationPreferences: {
                preferSharedResources: true,
                enableEventPropagation: false,
                enableHealthCoordination: true
              }
            });
            await this._initializeEssentialFacadeSystems();
            initializationResults.success.push("FacadeCoordinationSystem");
          } catch (error) {
            console.error("\u{1F30C} [Year3000System] Failed to initialize degraded facade system:", error);
            initializationResults.failed.push("FacadeCoordinationSystem");
          }
          const skippedSystems = [
            "SettingsManager",
            "MusicSyncService",
            "ColorHarmonyEngine",
            "GlassmorphismManager",
            "Card3DManager",
            "All Visual Systems"
          ];
          initializationResults.skipped.push(...skippedSystems);
          this._initializationResults = initializationResults;
          this.initialized = true;
          const endTime = performance.now();
          const initTime = endTime - startTime;
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              `\u{1F31F} [Year3000System] Visual-only initialization complete in ${initTime.toFixed(
                2
              )}ms`
            );
            console.log(
              `\u{1F31F} [Year3000System] Results: ${initializationResults.success.length} success, ${initializationResults.failed.length} failed, ${initializationResults.skipped.length} skipped`
            );
          }
        }
        setupProgressiveEnhancement() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Setting up progressive enhancement monitoring..."
            );
          }
          let enhancementAttempts = 0;
          const maxEnhancementAttempts = 30;
          const enhancementInterval = setInterval(() => {
            enhancementAttempts++;
            const playerAvailable = !!window.Spicetify?.Player;
            const platformAvailable = !!window.Spicetify?.Platform;
            if (playerAvailable && platformAvailable && this.availableAPIs?.degradedMode) {
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F31F} [Year3000System] APIs now available! Triggering upgrade to full mode..."
                );
              }
              clearInterval(enhancementInterval);
              this.upgradeToFullMode().catch((error) => {
                console.error("[Year3000System] Upgrade to full mode failed:", error);
              });
            }
            if (enhancementAttempts >= maxEnhancementAttempts) {
              if (this.YEAR3000_CONFIG.enableDebug) {
                console.log(
                  "\u{1F31F} [Year3000System] Progressive enhancement monitoring stopped (timeout)"
                );
              }
              clearInterval(enhancementInterval);
            }
          }, 2e3);
        }
        async upgradeToFullMode() {
          if (this.YEAR3000_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Upgrading from degraded mode to full mode..."
            );
          }
          this.availableAPIs = {
            player: window.Spicetify?.Player,
            platform: window.Spicetify?.Platform,
            config: window.Spicetify?.Config,
            degradedMode: false
          };
          try {
            const upgradeResults = {
              success: [],
              failed: [],
              skipped: []
            };
            try {
              if (this.systemHealthMonitor) {
                this.systemHealthMonitor.registerSystem(
                  "SettingsManager",
                  this.settingsManager
                );
              }
              upgradeResults.success.push("SettingsManager");
            } catch (error) {
              upgradeResults.failed.push("SettingsManager");
              console.error(
                `[Year3000System] Failed to upgrade SettingsManager:`,
                error
              );
            }
            if (this.settingsManager) {
              try {
              } catch (error) {
              }
            }
            if (this.performanceAnalyzer && this.settingsManager) {
              try {
              } catch (error) {
              }
              if (this.enhancedMasterAnimationCoordinator) {
                await this._registerAnimationSystems();
              }
            }
            if (this.musicSyncService && this.availableAPIs.player) {
              this.setupMusicAnalysisAndColorExtraction();
            }
            if (this.settingsManager) {
              await this.applyInitialSettings();
            }
            if (this.YEAR3000_CONFIG.enableDebug) {
              console.log(
                `\u{1F31F} [Year3000System] Upgrade complete: ${upgradeResults.success.length} success, ${upgradeResults.failed.length} failed`
              );
              if (upgradeResults.failed.length > 0) {
                console.warn(
                  `\u{1F31F} [Year3000System] Upgrade failed systems: ${upgradeResults.failed.join(
                    ", "
                  )}`
                );
              }
              if (upgradeResults.skipped && upgradeResults.skipped.length > 0) {
                console.info(
                  `\u{1F31F} [Year3000System] Upgrade skipped systems: ${upgradeResults.skipped.join(
                    ", "
                  )}`
                );
              }
              if (upgradeResults.success.length > 0) {
                console.info(
                  `\u{1F31F} [Year3000System] Upgrade successful systems: ${upgradeResults.success.join(
                    ", "
                  )}`
                );
              }
            }
          } catch (error) {
            console.error(
              "[Year3000System] Error during upgrade to full mode:",
              error
            );
          }
        }
        _handleExternalSettingsChange(event) {
          const { key, value } = event.detail || {};
          if (!key) return;
          switch (key) {
            case "artisticMode": {
              try {
                if (typeof this.YEAR3000_CONFIG.safeSetArtisticMode === "function") {
                  this.YEAR3000_CONFIG.safeSetArtisticMode(value);
                }
              } catch (e) {
                console.warn("[Year3000System] Failed to apply artistic mode", e);
              }
              break;
            }
            case "harmonicIntensity": {
              const num = parseFloat(value);
              if (!Number.isNaN(num)) {
                this.YEAR3000_CONFIG.harmonicIntensity = num;
                if (this.colorHarmonyEngine) {
                  this.colorHarmonyEngine.setIntensity?.(num);
                  this.updateColorsFromCurrentTrack?.();
                }
              }
              break;
            }
            case "harmonicEvolution": {
              const enabled = value === "true" || value === true;
              this.allowHarmonicEvolution = enabled;
              this.YEAR3000_CONFIG.harmonicEvolution = enabled;
              break;
            }
            case "manualBaseColor": {
              if (typeof value === "string" && value.startsWith("#")) {
                this.updateHarmonicBaseColor(value);
              }
              break;
            }
            case "harmonicMode": {
              if (value !== null && value !== void 0) {
                this.YEAR3000_CONFIG.currentHarmonicMode = String(value);
                this.updateColorsFromCurrentTrack?.();
              }
              break;
            }
            default:
              break;
          }
          this._broadcastSettingChange(key, value);
          this._refreshConditionalSystems();
        }
        /**
         * Notify all subsystems that implement applyUpdatedSettings so they can
         * adjust behaviour immediately after a SettingsManager change.
         */
        _broadcastSettingChange(key, value) {
          const systems = [
            this.colorHarmonyEngine,
            this.glassmorphismManager,
            this.card3DManager,
            this.lightweightParticleSystem,
            this.interactionTrackingSystem,
            this.beatSyncVisualSystem,
            this.sidebarSystemsIntegration,
            this.particleFieldSystem
            // contextMenuSystem removed
          ];
          systems.forEach((sys) => {
            if (sys && typeof sys.applyUpdatedSettings === "function") {
              try {
                sys.applyUpdatedSettings(key, value);
              } catch (err) {
                console.warn(
                  `[Year3000System] ${sys.systemName || sys.constructor?.name || "UnknownSystem"} failed to applyUpdatedSettings`,
                  err
                );
              }
            }
          });
        }
        // ---------------------------------------------------------------------------
        // 🔧  Placeholder implementations restored after merge conflict
        // ---------------------------------------------------------------------------
        /**
         * Apply the current performance profile to subsystems.
         * NOTE: Full implementation was lost in a previous edit; this stub preserves
         *        compile-time integrity until the original logic is reinstated.
         */
        _applyPerformanceProfile() {
        }
        /**
         * Refresh conditional visual systems (WebGL, ParticleField, etc.) depending
         * on capability and artistic mode settings.
         */
        _refreshConditionalSystems() {
        }
        /**
         * Handle artistic-mode changes by triggering a colour refresh.
         */
        _onArtisticModeChanged() {
          try {
            this.updateColorsFromCurrentTrack?.();
          } catch (e) {
            console.warn("[Year3000System] _onArtisticModeChanged stub error", e);
          }
        }
        _handleVisibilityChange() {
          if (document.visibilityState !== "hidden") return;
          try {
            this.cssVariableBatcher?.flushCSSVariableBatch?.();
            try {
            } catch {
            }
            if (this.YEAR3000_CONFIG?.enableDebug) {
              console.log(
                "\u{1F31F} [Year3000System] Visibility hidden \u2192 forced flush of pending style updates"
              );
            }
          } catch (e) {
            if (this.YEAR3000_CONFIG?.enableDebug) {
              console.warn("[Year3000System] VisibilityChange flush error", e);
            }
          }
        }
      };
      __name(_Year3000System, "Year3000System");
      Year3000System = _Year3000System;
      year3000System = new Year3000System();
      if (typeof window !== "undefined") {
        window.year3000System = year3000System;
      }
      year3000System_default = year3000System;
    }
  });

  // src-js/visual/ui-effects/prismaticScrollSheen.ts
  var prismaticScrollSheen_exports = {};
  __export(prismaticScrollSheen_exports, {
    PrismaticScrollSheenSystem: () => PrismaticScrollSheenSystem,
    initializePrismaticScrollSheen: () => initializePrismaticScrollSheen
  });
  function initializePrismaticScrollSheen() {
    try {
      const sys = new PrismaticScrollSheenSystem();
      year3000System_default?.registerVisualSystem?.(sys, "background");
    } catch (err) {
      console.error("[PrismaticScrollSheen] Failed to init:", err);
    }
  }
  var DEFAULT_CYCLE_PX, _PrismaticScrollSheenSystem, PrismaticScrollSheenSystem;
  var init_prismaticScrollSheen = __esm({
    "src-js/visual/ui-effects/prismaticScrollSheen.ts"() {
      "use strict";
      init_year3000System();
      DEFAULT_CYCLE_PX = 6e3;
      _PrismaticScrollSheenSystem = class _PrismaticScrollSheenSystem {
        constructor(cyclePx = DEFAULT_CYCLE_PX) {
          this.cyclePx = cyclePx;
          this.systemName = "PrismaticScrollSheen";
          this._lastRatio = -1;
          document.documentElement.style.setProperty(
            "--sn-scroll-cycle-px",
            String(cyclePx)
          );
        }
        /**
         * Called each animation frame by VisualSystemRegistry.
         */
        onAnimate(_delta, context) {
          const ratio = context.scrollRatio ?? 0;
          if (Math.abs(ratio - this._lastRatio) < 1e-3) return;
          this._lastRatio = ratio;
          const root = document.documentElement;
          root.style.setProperty("--sn-cdf-scroll-ratio", ratio.toFixed(4));
          root.style.setProperty("--sn-scroll-ratio", ratio.toFixed(4));
        }
        onPerformanceModeChange() {
        }
        destroy() {
        }
      };
      __name(_PrismaticScrollSheenSystem, "PrismaticScrollSheenSystem");
      PrismaticScrollSheenSystem = _PrismaticScrollSheenSystem;
      __name(initializePrismaticScrollSheen, "initializePrismaticScrollSheen");
      if (window.Y3K?.system?.registerVisualSystem) {
        initializePrismaticScrollSheen();
      }
    }
  });

  // src-js/debug/DragCartographer.ts
  var DragCartographer_exports = {};
  __export(DragCartographer_exports, {
    enableDragCartography: () => enableDragCartography,
    getDragMap: () => getDragMap
  });
  function enableDragCartography() {
    const g2 = globalThis;
    if (g2.__SN_dragCartographer) return;
    g2.__SN_dragCartographer = new DragCartographer();
    console.info("\u{1F6F0}\uFE0F  DragCartographer enabled \u2013 logging dragstart events");
  }
  function getDragMap() {
    return DragCartographer.getDragMap();
  }
  var _DragCartographer, DragCartographer;
  var init_DragCartographer = __esm({
    "src-js/debug/DragCartographer.ts"() {
      "use strict";
      _DragCartographer = class _DragCartographer {
        constructor() {
          this.seen = /* @__PURE__ */ new WeakSet();
          this.handleDragStart = /* @__PURE__ */ __name((event) => {
            const target = event.target;
            if (!target) return;
            if (this.seen.has(target)) return;
            this.seen.add(target);
            const selector = _DragCartographer.buildSelectorPath(target);
            const detail = {
              time: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
              selector
            };
            try {
              const dt = event.dataTransfer;
              if (dt) {
                const uris = dt.getData("text/spotify") || dt.getData("text/uri-list");
                if (uris) {
                  detail.uris = uris.split(/\n|,/).filter(Boolean);
                }
                const label = dt.getData("text/plain");
                if (label) detail.label = label;
              }
            } catch {
            }
            const agg = _DragCartographer.aggregate;
            const entry = agg.get(selector);
            if (entry) {
              entry.count += 1;
              if (entry.samples.length < 3) entry.samples.push(detail);
            } else {
              agg.set(selector, { selector, count: 1, samples: [detail] });
            }
            console.groupCollapsed(
              `%c[DragCartographer] dragstart \u2192 ${selector}`,
              "color:#7dd3fc;font-weight:600"
            );
            console.table(detail);
            console.log("Event:", event);
            console.log("Target element snapshot:", target);
            console.groupEnd();
          }, "handleDragStart");
          document.addEventListener("dragstart", this.handleDragStart, true);
        }
        static buildSelectorPath(el) {
          const path = [];
          let current = el;
          let depth = 0;
          while (current && depth < _DragCartographer.MAX_PATH_DEPTH) {
            const tag = current.tagName.toLowerCase();
            const id = current.id ? `#${current.id}` : "";
            const cls = current.className && typeof current.className === "string" ? "." + current.className.split(/\s+/).slice(0, 2).join(".") : "";
            path.push(`${tag}${id}${cls}`);
            current = current.parentElement;
            depth += 1;
          }
          return path.join(" > ");
        }
        // Public helper to fetch map
        static getDragMap() {
          return Array.from(_DragCartographer.aggregate.values()).sort(
            (a, b) => b.count - a.count
          );
        }
      };
      __name(_DragCartographer, "DragCartographer");
      _DragCartographer.MAX_PATH_DEPTH = 4;
      _DragCartographer.aggregate = /* @__PURE__ */ new Map();
      DragCartographer = _DragCartographer;
      __name(enableDragCartography, "enableDragCartography");
      __name(getDragMap, "getDragMap");
    }
  });

  // src-js/utils/graphics/CanvasGhostBuilder.ts
  function buildDragGhostCanvas(label, imgSrc, opts = {}) {
    const key = `${label}|${imgSrc}|${opts.size}|${opts.dpr}`;
    const cached = cache.get(key);
    if (cached) return cached;
    const size = opts.size ?? 72;
    const dpr = opts.dpr ?? (window.devicePixelRatio || 1);
    const borderRadius = opts.borderRadius ?? 8;
    const canvas = document.createElement("canvas");
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    const ctx = canvas.getContext("2d");
    ctx.scale(dpr, dpr);
    ctx.fillStyle = "rgba(32,32,35,0.9)";
    ctx.roundRect(0, 0, size, size, borderRadius);
    ctx.fill();
    if (opts.shadow !== false) {
      ctx.shadowColor = "rgba(0,0,0,0.4)";
      ctx.shadowBlur = 6;
    }
    const inner = size - 16;
    if (imgSrc) {
      const img = new Image();
      img.src = imgSrc;
      const drawImage = /* @__PURE__ */ __name(() => {
        ctx.save();
        ctx.beginPath();
        ctx.roundRect(8, 8, inner, inner, borderRadius - 2);
        ctx.clip();
        ctx.drawImage(img, 8, 8, inner, inner);
        ctx.restore();
        drawLabel();
      }, "drawImage");
      if (img.complete) {
        drawImage();
      } else {
        img.onload = drawImage;
        img.onerror = drawLabel;
      }
    } else {
      drawLabel();
    }
    function drawLabel() {
      ctx.fillStyle = "#fff";
      ctx.font = `500 12px Inter, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const maxWidth = size - 10;
      let text = label;
      while (ctx.measureText(text).width > maxWidth && text.length > 4) {
        text = text.slice(0, -2);
      }
      if (text !== label) text = text.slice(0, -1) + "\u2026";
      ctx.fillText(text, size / 2, size - 10);
    }
    __name(drawLabel, "drawLabel");
    cache.set(key, canvas);
    return canvas;
  }
  var cache;
  var init_CanvasGhostBuilder = __esm({
    "src-js/utils/graphics/CanvasGhostBuilder.ts"() {
      "use strict";
      cache = /* @__PURE__ */ new Map();
      __name(buildDragGhostCanvas, "buildDragGhostCanvas");
    }
  });

  // src-js/ui/interactions/EnhancedDragPreview.ts
  var EnhancedDragPreview_exports = {};
  __export(EnhancedDragPreview_exports, {
    enableEnhancedDragPreview: () => enableEnhancedDragPreview
  });
  function createGhost(label, imgSrc) {
    try {
      return buildDragGhostCanvas(label, imgSrc);
    } catch {
      const div = document.createElement("div");
      div.textContent = label;
      div.style.padding = "4px 6px";
      div.style.fontSize = "12px";
      div.style.background = "rgba(32,32,35,0.9)";
      div.style.color = "#fff";
      return div;
    }
  }
  function extractImageSrc(el) {
    const img = el.querySelector("img[src]");
    if (img?.src) return img.src;
    const bg = getComputedStyle(el).backgroundImage;
    const match = bg && /url\("?([^\"]+)"?\)/.exec(bg);
    return match ? match[1] : void 0;
  }
  function findFallbackLabel(el) {
    const attrLabel = el.getAttribute("aria-label") || el.getAttribute("title");
    if (attrLabel) return attrLabel;
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
      acceptNode(node) {
        const text = node.textContent?.trim();
        return text ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    const n = walker.nextNode();
    return (n?.textContent?.trim() || "").slice(0, 60);
  }
  function getPreviewData(target) {
    if (cache2.has(target)) return cache2.get(target);
    const label = findFallbackLabel(target);
    if (!label) return null;
    const img = extractImageSrc(target);
    const data = img ? { label, img } : { label };
    cache2.set(target, data);
    return data;
  }
  function onDragStart(event) {
    try {
      if (!event.dataTransfer || typeof event.dataTransfer.setDragImage !== "function")
        return;
      const target = event.target;
      if (!target) return;
      let label = event.dataTransfer.getData("text/plain");
      let imgSrc;
      if (!label) {
        const data = getPreviewData(target);
        if (!data) return;
        label = data.label;
        imgSrc = data.img;
      } else {
        imgSrc = extractImageSrc(target);
      }
      const ghostEl = createGhost(label, imgSrc);
      document.body.appendChild(ghostEl);
      const offset = ghostEl.offsetWidth / 2;
      event.dataTransfer.setDragImage(ghostEl, offset, offset);
      const cleanup = /* @__PURE__ */ __name(() => {
        ghostEl.remove();
        window.removeEventListener("dragend", cleanup, true);
      }, "cleanup");
      window.addEventListener("dragend", cleanup, true);
    } catch (err) {
      console.debug("[StarryNight] EnhancedDragPreview failed:", err);
    }
  }
  function enableEnhancedDragPreview(opts = {}) {
    const g2 = globalThis;
    if (g2.__SN_enhancedDragPreview) return;
    g2.__SN_enhancedDragPreview = true;
    Object.assign(DEFAULT_OPTS, opts);
    document.addEventListener("dragstart", onDragStart, true);
    console.info("\u{1F320} Enhanced drag preview enabled");
  }
  var DEFAULT_OPTS, cache2;
  var init_EnhancedDragPreview = __esm({
    "src-js/ui/interactions/EnhancedDragPreview.ts"() {
      "use strict";
      init_CanvasGhostBuilder();
      DEFAULT_OPTS = {
        size: 72,
        borderRadius: 8,
        fontSize: 12
      };
      cache2 = /* @__PURE__ */ new WeakMap();
      __name(createGhost, "createGhost");
      __name(extractImageSrc, "extractImageSrc");
      __name(findFallbackLabel, "findFallbackLabel");
      __name(getPreviewData, "getPreviewData");
      __name(onDragStart, "onDragStart");
      __name(enableEnhancedDragPreview, "enableEnhancedDragPreview");
    }
  });

  // src-js/utils/animation/flipSpring.ts
  function spring(config) {
    const k = config.stiffness ?? 260;
    const d = config.damping ?? 24;
    const m = config.mass ?? 1;
    let current = {};
    let velocity = {};
    let target = {};
    let animId = null;
    function step() {
      let done = true;
      const dt = 1 / 60;
      for (const key in target) {
        const x = current[key] ?? 0;
        const v = velocity[key] ?? 0;
        const goal = target[key] ?? 0;
        const Fspring = -k * (x - goal);
        const Fdamp = -d * v;
        const a = (Fspring + Fdamp) / m;
        const newV = v + a * dt;
        const newX = x + newV * dt;
        velocity[key] = newV;
        current[key] = newX;
        if (Math.abs(newV) > 0.1 || Math.abs(newX - goal) > 0.1) done = false;
      }
      config.onUpdate(current);
      if (!done) animId = requestAnimationFrame(step);
    }
    __name(step, "step");
    return {
      to(newTarget) {
        target = newTarget;
        if (!animId) animId = requestAnimationFrame(step);
      }
    };
  }
  var init_flipSpring = __esm({
    "src-js/utils/animation/flipSpring.ts"() {
      "use strict";
      __name(spring, "spring");
      window.snFlipSpringLoaded = true;
    }
  });

  // src-js/utils/dom/sidebarDetector.ts
  function querySidebar() {
    const node = document.querySelector(SIDEBAR_SELECTOR);
    if (!node) return null;
    const rect = node.getBoundingClientRect();
    return { node, rect };
  }
  function isSidebarCloneCapable() {
    const hasSidebar = !!querySidebar();
    const canClone = typeof Element.prototype.cloneNode === "function";
    const springReady = !!window.snFlipSpringLoaded;
    return hasSidebar && canClone && springReady;
  }
  var SIDEBAR_SELECTOR;
  var init_sidebarDetector = __esm({
    "src-js/utils/dom/sidebarDetector.ts"() {
      "use strict";
      SIDEBAR_SELECTOR = '[data-testid="rootlist-container"]';
      __name(querySidebar, "querySidebar");
      __name(isSidebarCloneCapable, "isSidebarCloneCapable");
    }
  });

  // src-js/ui/interactions/SidebarCloneOverlay.ts
  var SidebarCloneOverlay_exports = {};
  __export(SidebarCloneOverlay_exports, {
    destroySidebarClone: () => destroySidebarClone,
    launchSidebarClone: () => launchSidebarClone
  });
  function launchSidebarClone(context) {
    if (animationAbortController) {
      animationAbortController.abort();
      animationAbortController = null;
    }
    if (activeClone) {
      destroySidebarClone();
    }
    animationAbortController = new AbortController();
    const { signal } = animationAbortController;
    if (activeClone) return;
    const sidebar = querySidebar();
    if (!sidebar) return;
    const clone = sidebar.node.cloneNode(true);
    clone.id = "";
    clone.setAttribute("aria-hidden", "true");
    clone.classList.add("sn-clone-overlay");
    clone.style.position = "fixed";
    clone.style.top = `${sidebar.rect.top}px`;
    clone.style.left = `${sidebar.rect.left}px`;
    clone.style.width = `${sidebar.rect.width}px`;
    clone.style.height = `${sidebar.rect.height}px`;
    clone.style.zIndex = "9999";
    clone.style.willChange = "transform, opacity";
    clone.style.contain = "paint";
    (/* @__PURE__ */ __name(function stripCloneArtefacts(root) {
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
      while (walker.nextNode()) {
        const el = walker.currentNode;
        if (el.hasAttribute("aria-label")) el.removeAttribute("aria-label");
        if (el.tabIndex >= 0) el.tabIndex = -1;
      }
    }, "stripCloneArtefacts"))(clone);
    document.body.appendChild(clone);
    activeClone = clone;
    const firstX = 0;
    const firstY = 0;
    const firstS = 1;
    const lastX = context.cursorX - sidebar.rect.left - sidebar.rect.width * 0.2;
    const lastY = context.cursorY - sidebar.rect.top - sidebar.rect.height * 0.2;
    const lastS = 0.6;
    const prefersReduced = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    if (prefersReduced) {
      clone.style.transform = `translate(${lastX}px, ${lastY}px) scale(${lastS})`;
      pruneCloneItems(clone, context);
      return;
    }
    const anim = spring({
      stiffness: 220,
      damping: 20,
      onUpdate: /* @__PURE__ */ __name((v) => {
        if (signal.aborted) return;
        clone.style.transform = `translate(${v.x}px, ${v.y}px) scale(${v.s})`;
      }, "onUpdate")
    });
    clone.style.transformOrigin = "top left";
    clone.style.transform = `translate(${firstX}px, ${firstY}px) scale(${firstS})`;
    requestAnimationFrame(() => anim.to({ x: lastX, y: lastY, s: lastS }));
    const pruneTimeout = setTimeout(() => {
      if (!signal.aborted && activeClone) pruneCloneItems(activeClone, context);
    }, 400);
    signal.addEventListener("abort", () => clearTimeout(pruneTimeout));
    signal.addEventListener("abort", () => destroySidebarClone());
  }
  function destroySidebarClone() {
    cleanupFns.forEach((fn) => fn());
    cleanupFns.length = 0;
    if (activeClone) {
      activeClone.remove();
      activeClone = null;
    }
    if (animationAbortController) {
      animationAbortController.abort();
      animationAbortController = null;
    }
  }
  function addTracksToPlaylist(uri, trackUris) {
    try {
      const Cosmos = window.Spicetify?.CosmosAsync;
      if (!Cosmos) return;
      const endpoint = `/v1/playlists/${uri.split(":").pop()}/tracks`;
      Cosmos.post(endpoint, { uris: trackUris });
    } catch {
    }
  }
  function pruneCloneItems(root, context) {
    const all = Array.from(
      root.querySelectorAll('[data-uri^="spotify:playlist:"]')
    );
    if (!all.length) return;
    const keep = all.slice(0, 5);
    all.slice(5).forEach((el) => {
      el.classList.add("sn-prune-out");
      setTimeout(() => el.remove(), 180);
    });
    keep.forEach((el, idx) => {
      el.setAttribute("data-index", String(idx + 1));
      el.setAttribute("role", "button");
      el.tabIndex = 0;
      el.style.setProperty("--sn-glow-level", "0");
      el.style.backgroundImage = "paint(sn-aura)";
      el.addEventListener(
        "mouseenter",
        () => el.style.setProperty("--sn-glow-level", "1")
      );
      el.addEventListener(
        "mouseleave",
        () => el.style.setProperty("--sn-glow-level", "0")
      );
      const uriVal = el.getAttribute("data-uri");
      if (!uriVal) {
        return;
      }
      const trackUris = context.uris;
      const clickHandler = /* @__PURE__ */ __name((ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        const img = el.querySelector("img");
        pushRecentPlaylist(
          uriVal,
          img?.src || "",
          el.textContent?.trim() || "Playlist"
        );
        addTracksToPlaylist(uriVal, trackUris);
        announce("Track added to " + (el.textContent?.trim() || "playlist"));
        destroySidebarClone();
      }, "clickHandler");
      el.addEventListener("click", clickHandler);
      el.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          clickHandler(e);
        }
      });
    });
    const keyListener = /* @__PURE__ */ __name((e) => {
      const n = parseInt(e.key, 10);
      if (n >= 1 && n <= keep.length) {
        keep[n - 1]?.click();
      }
    }, "keyListener");
    window.addEventListener("keydown", keyListener, { capture: true });
    cleanupFns.push(
      () => window.removeEventListener("keydown", keyListener, { capture: true })
    );
  }
  function pushRecentPlaylist(uri, image, name) {
    try {
      const raw = localStorage.getItem(MRU_KEY);
      const list = raw ? JSON.parse(raw) : [];
      const existing = list.findIndex((p) => p.uri === uri);
      if (existing !== -1) list.splice(existing, 1);
      list.unshift({ uri, image, name });
      localStorage.setItem(MRU_KEY, JSON.stringify(list.slice(0, 10)));
    } catch {
    }
  }
  function announce(message) {
    const live = document.getElementById("sn-live");
    if (live) live.textContent = message;
  }
  var activeClone, cleanupFns, animationAbortController, MRU_KEY;
  var init_SidebarCloneOverlay = __esm({
    "src-js/ui/interactions/SidebarCloneOverlay.ts"() {
      "use strict";
      init_flipSpring();
      init_sidebarDetector();
      activeClone = null;
      cleanupFns = [];
      animationAbortController = null;
      MRU_KEY = "sn-recent-playlists";
      __name(launchSidebarClone, "launchSidebarClone");
      __name(destroySidebarClone, "destroySidebarClone");
      __name(addTracksToPlaylist, "addTracksToPlaylist");
      __name(pruneCloneItems, "pruneCloneItems");
      __name(pushRecentPlaylist, "pushRecentPlaylist");
      __name(announce, "announce");
    }
  });

  // src-js/ui/interactions/QuickAddRadialMenu.ts
  var QuickAddRadialMenu_exports = {};
  __export(QuickAddRadialMenu_exports, {
    enableQuickAddRadialMenu: () => enableQuickAddRadialMenu
  });
  function ensureLiveRegion() {
    let live = document.getElementById(LIVE_ID);
    if (!live) {
      live = document.createElement("div");
      live.id = LIVE_ID;
      live.setAttribute("aria-live", "polite");
      live.style.position = "absolute";
      live.style.width = "1px";
      live.style.height = "1px";
      live.style.overflow = "hidden";
      live.style.clipPath = "inset(100%)";
      live.style.clip = "rect(1px,1px,1px,1px)";
      live.style.whiteSpace = "nowrap";
      document.body.appendChild(live);
    }
    return live;
  }
  function distance(x1, y1, x2, y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function fetchRecentPlaylists() {
    try {
      const raw = localStorage.getItem("sn-recent-playlists");
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr.slice(0, MAX_PLAYLISTS_SHOWN) : [];
    } catch {
      return [];
    }
  }
  function addTracksToPlaylist2(playlistUri, trackUris) {
    try {
      const endpoint = `/v1/playlists/${playlistUri.split(":").pop()}/tracks`;
      window.Spicetify?.CosmosAsync.post(endpoint, {
        uris: trackUris
      });
    } catch (e) {
      console.warn("[StarryNight] QuickAddRadial failed to add tracks:", e);
    }
  }
  function pushRecentPlaylist2(pl) {
    try {
      const list = fetchRecentPlaylists();
      const existingIdx = list.findIndex((p) => p.uri === pl.uri);
      if (existingIdx !== -1) list.splice(existingIdx, 1);
      list.unshift(pl);
      const trimmed = list.slice(0, 10);
      localStorage.setItem("sn-recent-playlists", JSON.stringify(trimmed));
    } catch {
    }
  }
  function createOverlay(x, y, playlists) {
    if (!playlists.length) return;
    destroyOverlay();
    overlayEl = document.createElement("div");
    overlayEl.className = "sn-quick-add-overlay";
    overlayEl.style.position = "fixed";
    overlayEl.style.inset = "0";
    overlayEl.style.pointerEvents = "none";
    overlayEl.style.zIndex = "9999";
    const center = document.createElement("div");
    center.className = "sn-quick-add-center";
    center.style.position = "absolute";
    center.style.left = `${x}px`;
    center.style.top = `${y}px`;
    center.style.width = "0";
    center.style.height = "0";
    overlayEl.appendChild(center);
    document.body.appendChild(overlayEl);
    const radius = 90;
    const angleStep = Math.PI * 2 / playlists.length;
    playlists.forEach((pl, idx) => {
      const angle = angleStep * idx - Math.PI / 2;
      const btn = document.createElement("button");
      btn.className = "sn-quick-add-btn";
      btn.style.position = "absolute";
      btn.style.width = "64px";
      btn.style.height = "64px";
      btn.style.borderRadius = "50%";
      btn.style.border = "2px solid rgba(255,255,255,0.4)";
      btn.style.background = `url('${pl.image}') center/cover no-repeat`;
      btn.style.cursor = "pointer";
      btn.style.pointerEvents = "auto";
      const cx = radius * Math.cos(angle);
      const cy = radius * Math.sin(angle);
      btn.style.transform = `translate(${cx - 32}px, ${cy - 32}px)`;
      btn.style.transformOrigin = "center center";
      const firstX = 0;
      const firstY = 0;
      btn.style.transform = `translate(${firstX}px, ${firstY}px) scale(0.1)`;
      requestAnimationFrame(() => {
        const animator = spring({
          stiffness: 220,
          damping: 20,
          onUpdate: /* @__PURE__ */ __name((v) => {
            btn.style.transform = `translate(${v.x}px, ${v.y}px) scale(${v.s})`;
          }, "onUpdate")
        });
        animator.to({ x: cx - 32, y: cy - 32, s: 1 });
      });
      btn.title = `Add to ${pl.name}`;
      btn.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        if (currentDragDataUris) addTracksToPlaylist2(pl.uri, currentDragDataUris);
        pushRecentPlaylist2(pl);
        destroyOverlay();
      });
      center.appendChild(btn);
    });
    const live = ensureLiveRegion();
    live.textContent = "Quick-add menu open. Press number keys 1 to 5 to pick a playlist or continue dragging.";
  }
  function destroyOverlay() {
    overlayEl?.remove();
    overlayEl = null;
    const live = document.getElementById(LIVE_ID);
    if (live) live.textContent = "";
  }
  function clearHoldTimer() {
    if (holdTimer) {
      clearTimeout(holdTimer);
      holdTimer = null;
    }
  }
  function onDragStart2(e) {
    startX = e.clientX;
    startY = e.clientY;
    currentDragDataUris = (e.dataTransfer?.getData("text/spotify") || "").split(/[\n,]/).filter(Boolean);
    const cloneCapable = isSidebarCloneCapable();
    clearHoldTimer();
    holdTimer = window.setTimeout(async () => {
      if (cloneCapable) {
        const overlay = await Promise.resolve().then(() => (init_SidebarCloneOverlay(), SidebarCloneOverlay_exports));
        overlay.launchSidebarClone({
          cursorX: currentPointer.x,
          cursorY: currentPointer.y,
          uris: currentDragDataUris ?? []
        });
      } else {
        const playlists = await getRadialPlaylists();
        createOverlay(startX, startY, playlists);
      }
    }, HOLD_MS);
  }
  function onDragEnd() {
    clearHoldTimer();
    destroyOverlay();
    currentDragDataUris = null;
  }
  function onPointerMove(e) {
    currentPointer = { x: e.clientX, y: e.clientY };
    if (!holdTimer) return;
    if (distance(startX, startY, e.clientX, e.clientY) > MOVE_THRESHOLD) {
      clearHoldTimer();
    }
  }
  async function fetchPlaylistsFromAPI() {
    try {
      const Cosmos = window.Spicetify?.CosmosAsync;
      if (!Cosmos) return [];
      const resp = await Cosmos.get(
        "https://api.spotify.com/v1/me/playlists?limit=10"
      );
      if (!resp?.items) return [];
      return resp.items.slice(0, MAX_PLAYLISTS_SHOWN).map((pl) => ({
        uri: pl.uri,
        name: pl.name,
        image: pl.images?.[0]?.url || ""
      }));
    } catch {
      return [];
    }
  }
  function scrapeSidebarPlaylists() {
    try {
      const items = Array.from(
        document.querySelectorAll('[data-testid="rootlist-card"]')
      );
      const res = [];
      for (const el of items) {
        const uri = el.getAttribute("data-uri") || el.querySelector("a")?.getAttribute("href")?.replace("/playlist/", "spotify:playlist:");
        if (!uri) continue;
        const img = el.querySelector("img");
        const image = img?.src || "";
        const name = img?.alt || el.textContent?.trim() || "Playlist";
        res.push({ uri, image, name });
        if (res.length >= MAX_PLAYLISTS_SHOWN) break;
      }
      return res;
    } catch {
      return [];
    }
  }
  async function getRadialPlaylists() {
    const local = fetchRecentPlaylists();
    if (local.length) return local;
    const sidebar = scrapeSidebarPlaylists();
    if (sidebar.length) return sidebar;
    const api = await fetchPlaylistsFromAPI();
    return api;
  }
  function enableQuickAddRadialMenu() {
    const g2 = globalThis;
    if (g2.__SN_quickAddRadial) return;
    g2.__SN_quickAddRadial = true;
    window.addEventListener("dragstart", onDragStart2, true);
    window.addEventListener("dragend", onDragEnd, true);
    window.addEventListener("pointermove", onPointerMove, true);
    console.info("\u{1F30C} Quick-Add radial menu enabled");
    console.info(
      `[StarryNight] Sidebar clone capability: ${isSidebarCloneCapable()}`
    );
  }
  var HOLD_MS, MOVE_THRESHOLD, MAX_PLAYLISTS_SHOWN, holdTimer, startX, startY, overlayEl, currentDragDataUris, currentPointer, LIVE_ID;
  var init_QuickAddRadialMenu = __esm({
    "src-js/ui/interactions/QuickAddRadialMenu.ts"() {
      "use strict";
      init_flipSpring();
      init_sidebarDetector();
      HOLD_MS = 250;
      MOVE_THRESHOLD = 8;
      MAX_PLAYLISTS_SHOWN = 5;
      holdTimer = null;
      startX = 0;
      startY = 0;
      overlayEl = null;
      currentDragDataUris = null;
      currentPointer = { x: 0, y: 0 };
      LIVE_ID = "sn-live";
      __name(ensureLiveRegion, "ensureLiveRegion");
      __name(distance, "distance");
      __name(fetchRecentPlaylists, "fetchRecentPlaylists");
      __name(addTracksToPlaylist2, "addTracksToPlaylist");
      __name(pushRecentPlaylist2, "pushRecentPlaylist");
      __name(createOverlay, "createOverlay");
      __name(destroyOverlay, "destroyOverlay");
      __name(clearHoldTimer, "clearHoldTimer");
      __name(onDragStart2, "onDragStart");
      __name(onDragEnd, "onDragEnd");
      __name(onPointerMove, "onPointerMove");
      document.addEventListener("keydown", (e) => {
        if (!overlayEl) return;
        const num = parseInt(e.key, 10);
        if (num >= 1 && num <= MAX_PLAYLISTS_SHOWN) {
          const btn = overlayEl.querySelectorAll(".sn-quick-add-btn")[num - 1];
          btn?.click();
        }
      });
      __name(fetchPlaylistsFromAPI, "fetchPlaylistsFromAPI");
      __name(scrapeSidebarPlaylists, "scrapeSidebarPlaylists");
      __name(getRadialPlaylists, "getRadialPlaylists");
      __name(enableQuickAddRadialMenu, "enableQuickAddRadialMenu");
    }
  });

  // src-js/ui/components/SettingsSection.tsx
  var import_react, import_react_dom, _SettingsSection, SettingsSection;
  var init_SettingsSection = __esm({
    "src-js/ui/components/SettingsSection.tsx"() {
      "use strict";
      import_react = __toESM(__require("react"));
      import_react_dom = __toESM(__require("react-dom"));
      _SettingsSection = class _SettingsSection {
        constructor(name, settingsId, initialSettingsFields = {}) {
          this.name = name;
          this.settingsId = settingsId;
          this.initialSettingsFields = initialSettingsFields;
          this.settingsFields = this.initialSettingsFields;
          this.setRerender = null;
          /** Mounts the section when the user visits the Spotify settings route */
          this.pushSettings = /* @__PURE__ */ __name(async () => {
            Object.entries(this.settingsFields).forEach(([nameId, field]) => {
              if (field.type !== "button" && this.getFieldValue(nameId) === void 0) {
                this.setFieldValue(nameId, field.defaultValue);
              }
            });
            while (!window.Spicetify?.Platform?.History?.listen) {
              await new Promise((r) => setTimeout(r, 100));
            }
            if (this.stopHistoryListener) this.stopHistoryListener();
            this.stopHistoryListener = window.Spicetify.Platform.History.listen((e) => {
              if (e.pathname === "/preferences") this.render();
            });
            if (window.Spicetify.Platform.History.location.pathname === "/preferences") {
              await this.render();
            }
          }, "pushSettings");
          this.rerender = /* @__PURE__ */ __name(() => {
            this.setRerender?.(Math.random());
          }, "rerender");
          /* ----------------------- field creators ---------------------------- */
          this.addDropDown = /* @__PURE__ */ __name((nameId, description, options, defaultIndex, _onSelect, events) => {
            this.settingsFields[nameId] = {
              type: "dropdown",
              description,
              defaultValue: options[defaultIndex],
              options,
              events
            };
          }, "addDropDown");
          /** Toggle (checkbox) */
          this.addToggle = /* @__PURE__ */ __name((nameId, description, defaultValue, events) => {
            this.settingsFields[nameId] = {
              type: "toggle",
              description,
              defaultValue,
              events
            };
          }, "addToggle");
          /** Text / number / color input */
          this.addInput = /* @__PURE__ */ __name((nameId, description, defaultValue, inputType = "text", events) => {
            this.settingsFields[nameId] = {
              type: "input",
              description,
              defaultValue,
              inputType,
              events
            };
          }, "addInput");
          this.getFieldValue = /* @__PURE__ */ __name((nameId) => {
            return JSON.parse(
              window.Spicetify?.LocalStorage.get(this.storageKey(nameId)) || "null"
            )?.value;
          }, "getFieldValue");
          /* ---------------------- React wrappers ----------------------------- */
          this.FieldsContainer = /* @__PURE__ */ __name(() => {
            const [nonce, setNonce] = (0, import_react.useState)(0);
            this.setRerender = setNonce;
            return /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-section", key: nonce }, /* @__PURE__ */ import_react.default.createElement("h2", { className: "TypeElement-cello-textBase-type" }, this.name), Object.entries(this.settingsFields).map(([nameId, field]) => /* @__PURE__ */ import_react.default.createElement(this.Field, { key: nameId, nameId, field })));
          }, "FieldsContainer");
          this.Field = /* @__PURE__ */ __name(({
            nameId,
            field
          }) => {
            const id = `${this.settingsId}.${nameId}`;
            const initial = field.type === "button" ? field.value : this.getFieldValue(nameId) ?? field.defaultValue;
            const [value, setVal] = (0, import_react.useState)(initial);
            const setValue = /* @__PURE__ */ __name((v) => {
              setVal(v);
              this.setFieldValue(nameId, v);
            }, "setValue");
            if (field.type === "hidden") return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null);
            const Label = /* @__PURE__ */ import_react.default.createElement("label", { className: "TypeElement-viola-textSubdued-type", htmlFor: id }, field.description || "");
            let Control = null;
            switch (field.type) {
              case "dropdown":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "select",
                  {
                    className: "main-dropDown-dropDown",
                    id,
                    ...field.events,
                    onChange: (e) => {
                      const idx = e.currentTarget.selectedIndex;
                      const newVal = field.options[idx];
                      setValue(newVal);
                      field.events?.onChange?.(e);
                    }
                  },
                  field.options.map((opt, i) => /* @__PURE__ */ import_react.default.createElement("option", { key: opt, value: opt, selected: opt === value }, opt))
                );
                break;
              case "toggle":
                Control = /* @__PURE__ */ import_react.default.createElement("label", { className: "x-settings-secondColumn x-toggle-wrapper" }, /* @__PURE__ */ import_react.default.createElement(
                  "input",
                  {
                    id,
                    className: "x-toggle-input",
                    type: "checkbox",
                    checked: !!value,
                    ...field.events,
                    onClick: (e) => {
                      const checked = e.currentTarget.checked;
                      setValue(checked);
                      field.events?.onClick?.(e);
                    }
                  }
                ), /* @__PURE__ */ import_react.default.createElement("span", { className: "x-toggle-indicatorWrapper" }, /* @__PURE__ */ import_react.default.createElement("span", { className: "x-toggle-indicator" })));
                break;
              case "input":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "input",
                  {
                    className: "x-settings-input",
                    id,
                    dir: "ltr",
                    value,
                    type: field.inputType || "text",
                    ...field.events,
                    onChange: (e) => {
                      setValue(e.currentTarget.value);
                      field.events?.onChange?.(e);
                    }
                  }
                );
                break;
              case "button":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "button",
                  {
                    id,
                    className: "Button-sc-y0gtbx-0 Button-small-buttonSecondary-useBrowserDefaultFocusStyle x-settings-button",
                    ...field.events,
                    onClick: (e) => {
                      field.events?.onClick?.(e);
                    },
                    type: "button"
                  },
                  value
                );
                break;
              default:
                Control = null;
            }
            return /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-row" }, /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-firstColumn" }, Label), /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-secondColumn" }, Control));
          }, "Field");
        }
        /* --------------------- internal render helpers --------------------- */
        async render() {
          while (!document.getElementById("desktop.settings.selectLanguage")) {
            if (window.Spicetify.Platform.History.location.pathname !== "/preferences")
              return;
            await new Promise((r) => setTimeout(r, 100));
          }
          const container = document.querySelector(
            ".main-view-container__scroll-node-child main div"
          );
          if (!container)
            return console.error("[StarryNight] settings container not found");
          let host = Array.from(container.children).find(
            (c) => c.id === this.settingsId
          );
          if (!host) {
            host = document.createElement("div");
            host.id = this.settingsId;
            container.appendChild(host);
          }
          import_react_dom.default.render(/* @__PURE__ */ import_react.default.createElement(this.FieldsContainer, null), host);
        }
        /* ----- generic storage helpers (use Spicetify.LocalStorage) -------- */
        storageKey(nameId) {
          return `${this.settingsId}.${nameId}`;
        }
        setFieldValue(nameId, newValue) {
          window.Spicetify?.LocalStorage.set(
            this.storageKey(nameId),
            JSON.stringify({ value: newValue })
          );
        }
      };
      __name(_SettingsSection, "SettingsSection");
      SettingsSection = _SettingsSection;
    }
  });

  // src-js/ui/components/StarryNightSettings.ts
  var StarryNightSettings_exports = {};
  __export(StarryNightSettings_exports, {
    initializeStarryNightSettings: () => initializeStarryNightSettings
  });
  async function initializeStarryNightSettings() {
    const section = new SettingsSection(
      "StarryNight Theme",
      "starrynight-settings"
    );
    const accentOptions = [
      "dynamic",
      // 🎨 Album-based accent (Year 3000)
      "rosewater",
      "flamingo",
      "pink",
      "mauve",
      "red",
      "maroon",
      "peach",
      "yellow",
      "green",
      "teal",
      "sky",
      "sapphire",
      "blue",
      "lavender"
    ];
    function getSettingsManager() {
      const existing = window.Y3K?.system?.settingsManager;
      if (existing) return existing;
      const cached = globalThis.__SN_settingsManager;
      if (cached) return cached;
      const manager = new SettingsManager();
      globalThis.__SN_settingsManager = manager;
      return manager;
    }
    __name(getSettingsManager, "getSettingsManager");
    const settingsManager = getSettingsManager();
    const currentAccent = settingsManager.get("catppuccin-accentColor");
    section.addDropDown(
      "catppuccin-accentColor",
      // settings key (nameId)
      "Accent colour",
      // user-visible label
      accentOptions,
      // option list
      Math.max(0, accentOptions.indexOf(currentAccent)),
      // default index
      void 0,
      // onSelect (unused – we use onChange)
      {
        onChange: /* @__PURE__ */ __name((e) => {
          try {
            const idx = e?.currentTarget?.selectedIndex ?? 0;
            const newAccent = accentOptions[idx] ?? "mauve";
            settingsManager.set("catppuccin-accentColor", newAccent);
            const grad = settingsManager.get("sn-gradient-intensity");
            const stars = settingsManager.get("sn-star-density");
            applyStarryNightSettings(grad, stars);
            try {
              globalThis.Y3K?.system?.applyInitialSettings?.();
            } catch (applyErr) {
              console.warn(
                "[StarryNight] Unable to trigger Year3000System colour refresh",
                applyErr
              );
            }
          } catch (err) {
            console.error("[StarryNight] Failed to update accent colour", err);
          }
        }, "onChange")
      }
    );
    const intensityOptions = [
      "disabled",
      "minimal",
      "balanced",
      "intense"
    ];
    const currentGradient = settingsManager.get("sn-gradient-intensity");
    section.addDropDown(
      "sn-gradient-intensity",
      "Gradient intensity",
      intensityOptions,
      Math.max(0, intensityOptions.indexOf(currentGradient)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const newGrad = intensityOptions[idx] ?? "balanced";
          settingsManager.set("sn-gradient-intensity", newGrad);
          const stars = settingsManager.get("sn-star-density");
          applyStarryNightSettings(newGrad, stars);
        }, "onChange")
      }
    );
    const currentFlowGradient = settingsManager.get("sn-flow-gradient");
    section.addDropDown(
      "sn-flow-gradient",
      "Flow gradient intensity (WebGL)",
      intensityOptions,
      Math.max(0, intensityOptions.indexOf(currentFlowGradient)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const newFlow = intensityOptions[idx] ?? "balanced";
          settingsManager.set("sn-flow-gradient", newFlow);
        }, "onChange")
      }
    );
    const currentStars = settingsManager.get("sn-star-density");
    section.addDropDown(
      "sn-star-density",
      "Star density",
      intensityOptions,
      Math.max(0, intensityOptions.indexOf(currentStars)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const newStars = intensityOptions[idx] ?? "balanced";
          settingsManager.set("sn-star-density", newStars);
          const grad = settingsManager.get("sn-gradient-intensity");
          applyStarryNightSettings(grad, newStars);
        }, "onChange")
      }
    );
    const flavourOptions = ["latte", "frappe", "macchiato", "mocha"];
    const currentFlavor = settingsManager.get("catppuccin-flavor");
    section.addDropDown(
      "catppuccin-flavor",
      "Catppuccin flavour",
      flavourOptions,
      Math.max(0, flavourOptions.indexOf(currentFlavor)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager.set("catppuccin-flavor", flavourOptions[idx]);
          globalThis.Y3K?.system?.applyInitialSettings?.();
        }, "onChange")
      }
    );
    const glassOptions = ["disabled", "minimal", "moderate", "intense"];
    const currentGlass = settingsManager.get("sn-glassmorphism-level");
    section.addDropDown(
      "sn-glassmorphism-level",
      "Glassmorphism",
      glassOptions,
      Math.max(0, glassOptions.indexOf(currentGlass)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager.set("sn-glassmorphism-level", glassOptions[idx]);
        }, "onChange")
      }
    );
    const fx3dOptions = ["full", "minimal", "disabled"];
    const current3d = settingsManager.get("sn-3d-effects-level");
    section.addDropDown(
      "sn-3d-effects-level",
      "3D card effects",
      fx3dOptions,
      Math.max(0, fx3dOptions.indexOf(current3d)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager.set("sn-3d-effects-level", fx3dOptions[idx]);
        }, "onChange")
      }
    );
    const artisticOptions = [
      "corporate-safe",
      "artist-vision",
      "cosmic-maximum"
    ];
    const currentArtistic = settingsManager.get("sn-artistic-mode");
    section.addDropDown(
      "sn-artistic-mode",
      "Artistic mode",
      artisticOptions,
      Math.max(0, artisticOptions.indexOf(currentArtistic)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const mode = artisticOptions[idx];
          settingsManager.set("sn-artistic-mode", mode);
          globalThis.year3000System?.YEAR3000_CONFIG?.safeSetArtisticMode?.(mode);
        }, "onChange")
      }
    );
    const harmonicModes = Object.keys(HARMONIC_MODES);
    const currentHarmMode = settingsManager.get("sn-current-harmonic-mode");
    if (harmonicModes.length) {
      section.addDropDown(
        "sn-current-harmonic-mode",
        "Harmonic colour mode",
        harmonicModes,
        Math.max(0, harmonicModes.indexOf(currentHarmMode)),
        void 0,
        {
          onChange: /* @__PURE__ */ __name((e) => {
            const idx = e?.currentTarget?.selectedIndex ?? 0;
            const modeKey = harmonicModes[idx];
            settingsManager.set("sn-current-harmonic-mode", modeKey);
            globalThis.Y3K?.system?.evolveHarmonicSignature?.(modeKey);
          }, "onChange")
        }
      );
    }
    const currentHarmInt = settingsManager.get("sn-harmonic-intensity") || "0.7";
    section.addInput(
      "sn-harmonic-intensity",
      "Harmonic intensity (0-1)",
      currentHarmInt,
      "number",
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const val = e.currentTarget.value;
          settingsManager.set("sn-harmonic-intensity", val);
        }, "onChange")
      }
    );
    const currentEvolution = settingsManager.get("sn-harmonic-evolution") === "true";
    section.addToggle(
      "sn-harmonic-evolution",
      "Allow harmonic evolution",
      currentEvolution,
      {
        onClick: /* @__PURE__ */ __name((e) => {
          const checked = e.currentTarget.checked;
          settingsManager.set(
            "sn-harmonic-evolution",
            checked ? "true" : "false"
          );
        }, "onClick")
      }
    );
    const currentManual = settingsManager.get("sn-harmonic-manual-base-color") || "#ffffff";
    section.addInput(
      "sn-harmonic-manual-base-color",
      "Manual base colour",
      currentManual,
      "color",
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const val = e.currentTarget.value;
          settingsManager.set("sn-harmonic-manual-base-color", val);
          globalThis.Y3K?.system?.updateHarmonicBaseColor?.(val);
        }, "onChange")
      }
    );
    const enableAb = settingsManager.get("sn-enable-aberration") === "true";
    section.addToggle(
      "sn-enable-aberration",
      "Chromatic aberration effect",
      enableAb,
      {
        onClick: /* @__PURE__ */ __name((e) => {
          const checked = e.currentTarget.checked;
          settingsManager.set(
            "sn-enable-aberration",
            checked ? "true" : "false"
          );
        }, "onClick")
      }
    );
    const echoOptions = ["Off", "Subtle", "Balanced", "Intense"];
    const currentEcho = settingsManager.get("sn-echo-intensity") ?? "2";
    section.addDropDown(
      "sn-echo-intensity",
      "Temporal Echo Intensity",
      echoOptions,
      Math.min(3, parseInt(currentEcho, 10)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 2;
          settingsManager.set("sn-echo-intensity", `${idx}`);
        }, "onChange")
      }
    );
    const currentVisualInt = settingsManager.get("sn-visual-intensity") || "0.8";
    section.addInput(
      "sn-visual-intensity",
      "Visual intensity (0-1)",
      currentVisualInt,
      "number",
      {
        min: 0,
        max: 1,
        step: 0.05,
        onChange: /* @__PURE__ */ __name((e) => {
          const val = e.currentTarget.value;
          let num = parseFloat(val);
          if (isNaN(num)) num = 0.8;
          num = Math.max(0, Math.min(1, num));
          settingsManager.set("sn-visual-intensity", num.toFixed(2));
        }, "onChange")
      }
    );
    const animQualityOptions = ["auto", "low", "high"];
    const currentAnimQ = settingsManager.get("sn-animation-quality") || "auto";
    section.addDropDown(
      "sn-animation-quality",
      "Animation quality",
      animQualityOptions,
      Math.max(0, animQualityOptions.indexOf(currentAnimQ)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const val = animQualityOptions[idx] ?? "auto";
          settingsManager.set("sn-animation-quality", val);
        }, "onChange")
      }
    );
    const enableGlassPulse = settingsManager.get("sn-glass-beat-pulse") === "true";
    section.addToggle(
      "sn-glass-beat-pulse",
      "Glass Pulse (beat-synchronized glass effects)",
      enableGlassPulse,
      {
        onClick: /* @__PURE__ */ __name((e) => {
          const checked = e.currentTarget.checked;
          settingsManager.set(
            "sn-glass-beat-pulse",
            checked ? "true" : "false"
          );
          console.info("[StarryNight] Glass Pulse setting changed");
        }, "onClick")
      }
    );
    const currentGlassIntensity = settingsManager.get("sn-glass-base-intensity") || "0.5";
    section.addInput(
      "sn-glass-base-intensity",
      "Glass Base Intensity (0-1)",
      currentGlassIntensity,
      "number",
      {
        min: 0,
        max: 1,
        step: 0.1,
        onChange: /* @__PURE__ */ __name((e) => {
          const val = e.currentTarget.value;
          let num = parseFloat(val);
          if (isNaN(num)) num = 0.5;
          num = Math.max(0, Math.min(1, num));
          settingsManager.set("sn-glass-base-intensity", num.toFixed(1));
        }, "onChange")
      }
    );
    await section.pushSettings();
    console.log("\u2728 [StarryNight] spcr-settings panel initialised");
    const rerender = /* @__PURE__ */ __name(() => section.rerender(), "rerender");
    const history = globalThis.Spicetify?.Platform?.History;
    try {
      if (history?.listen) {
        history.listen(({ location }) => {
          if (location?.pathname === "/settings") {
            setTimeout(rerender, 100);
          }
        });
      }
    } catch (err) {
      console.warn("[StarryNight] Could not hook navigation for settings", err);
    }
    if (window.location.pathname === "/settings") {
      setTimeout(rerender, 300);
    }
  }
  var init_StarryNightSettings = __esm({
    "src-js/ui/components/StarryNightSettings.ts"() {
      "use strict";
      init_globalConfig();
      init_SettingsSection();
      init_SettingsManager();
      init_starryNightEffects();
      __name(initializeStarryNightSettings, "initializeStarryNightSettings");
    }
  });

  // src-js/visual/ui-effects/RightSidebarConsciousnessSystem.ts
  var RightSidebarConsciousnessSystem_exports = {};
  __export(RightSidebarConsciousnessSystem_exports, {
    RightSidebarConsciousnessSystem: () => RightSidebarConsciousnessSystem
  });
  var _RightSidebarConsciousnessSystem, RightSidebarConsciousnessSystem;
  var init_RightSidebarConsciousnessSystem = __esm({
    "src-js/visual/ui-effects/RightSidebarConsciousnessSystem.ts"() {
      "use strict";
      init_EventBus();
      init_BaseVisualSystem();
      init_SidebarPerformanceCoordinator();
      _RightSidebarConsciousnessSystem = class _RightSidebarConsciousnessSystem extends BaseVisualSystem {
        constructor(config, utils, perf, musicSync, settings, year3000System2 = null, coordinator) {
          super(config, utils, perf, musicSync, settings);
          // Current → target state for smooth lerp
          this.currentBeatIntensity = 0;
          this.targetBeatIntensity = 0;
          this.currentHueShift = 0;
          // degrees
          this.targetHueShift = 0;
          // Lerp smoothing factors
          this.INTENSITY_LERP = 0.25;
          this.HUE_LERP = 0.05;
          // Loop control
          this.fallbackRafId = null;
          this.lastTimestamp = performance.now();
          // Unsubscribe functions
          this.unsubBeat = null;
          this.unsubEnergy = null;
          this.year3000System = year3000System2;
          this.coordinator = coordinator || SidebarPerformanceCoordinator.getInstance({
            enableDebug: config.enableDebug,
            performanceAnalyzer: perf,
            onFlushComplete: /* @__PURE__ */ __name(() => {
              perf?.emitTrace?.(
                "[RightSidebarConsciousnessSystem] Coordinator flush completed"
              );
            }, "onFlushComplete")
          });
        }
        /* ------------------------------------------------------------------ */
        /* Initialization                                                     */
        /* ------------------------------------------------------------------ */
        async _performSystemSpecificInitialization() {
          this.unsubBeat = GlobalEventBus.subscribe(
            "music:beat",
            (payload) => this._handleBeat(payload)
          );
          this.unsubEnergy = GlobalEventBus.subscribe(
            "music:energy",
            (payload) => this._handleEnergy(payload)
          );
          this._tryRegisterWithMasterAnimation();
        }
        _tryRegisterWithMasterAnimation() {
          if (this.year3000System?.registerAnimationSystem && this.year3000System.enhancedMasterAnimationCoordinator) {
            const ok = this.year3000System.registerAnimationSystem(
              "RightSidebarConsciousnessSystem",
              this,
              "background",
              60
            );
            if (ok) return;
          }
          this._startFallbackLoop();
        }
        /* ------------------------------------------------------------------ */
        /* Event Handlers                                                     */
        /* ------------------------------------------------------------------ */
        _handleBeat({ intensity }) {
          this.targetBeatIntensity = Math.min(Math.max(intensity, 0), 1);
        }
        _handleEnergy({ energy }) {
          const deg = Math.round(energy * 120);
          this.targetHueShift = deg;
        }
        /* ------------------------------------------------------------------ */
        /* Animation Loop                                                     */
        /* ------------------------------------------------------------------ */
        onAnimate(deltaMs) {
          this._tick(deltaMs);
        }
        _startFallbackLoop() {
          const loop = /* @__PURE__ */ __name((ts) => {
            const delta = ts - this.lastTimestamp;
            this.lastTimestamp = ts;
            this._tick(delta);
            this.fallbackRafId = requestAnimationFrame(loop);
          }, "loop");
          this.fallbackRafId = requestAnimationFrame(loop);
        }
        _tick(_deltaMs) {
          this.currentBeatIntensity = this._lerp(
            this.currentBeatIntensity,
            this.targetBeatIntensity,
            this.INTENSITY_LERP
          );
          this.currentHueShift = this._lerp(
            this.currentHueShift,
            this.targetHueShift,
            this.HUE_LERP
          );
          this._queueCssVar("--sn-rs-beat-intensity", this.currentBeatIntensity);
          const glowAlpha = (0.15 + this.currentBeatIntensity * 0.45).toFixed(3);
          this._queueCssVar("--sn-rs-glow-alpha", glowAlpha);
          this._queueCssVar("--sn-rs-hue-shift", `${this.currentHueShift}deg`);
        }
        _queueCssVar(property, value) {
          this.coordinator.queueUpdate(property, String(value));
        }
        _lerp(from, to, alpha) {
          return from + (to - from) * alpha;
        }
        /* ------------------------------------------------------------------ */
        /* Cleanup                                                            */
        /* ------------------------------------------------------------------ */
        destroy() {
          super.destroy();
          this.unsubBeat?.();
          this.unsubEnergy?.();
          if (this.fallbackRafId) cancelAnimationFrame(this.fallbackRafId);
        }
      };
      __name(_RightSidebarConsciousnessSystem, "RightSidebarConsciousnessSystem");
      RightSidebarConsciousnessSystem = _RightSidebarConsciousnessSystem;
    }
  });

  // src-js/core/performance/CDFVariableBridge.ts
  var CDFVariableBridge_exports = {};
  __export(CDFVariableBridge_exports, {
    CDFVariableBridge: () => CDFVariableBridge
  });
  var _CDFVariableBridge, CDFVariableBridge;
  var init_CDFVariableBridge = __esm({
    "src-js/core/performance/CDFVariableBridge.ts"() {
      "use strict";
      init_EventBus();
      _CDFVariableBridge = class _CDFVariableBridge {
        constructor(batcher) {
          this.batcher = batcher;
          this.reduceMotionMQ = null;
          this._mqHandler = null;
          this.unsubscribe = GlobalEventBus.subscribe(
            "cdf:frameContext",
            (ctx) => this._handleFrame(ctx)
          );
          if (typeof window !== "undefined" && window.matchMedia) {
            this.reduceMotionMQ = window.matchMedia(
              "(prefers-reduced-motion: reduce)"
            );
            this._syncReducedMotion(this.reduceMotionMQ.matches);
            this._mqHandler = (e) => {
              this._syncReducedMotion(e.matches);
            };
            try {
              this.reduceMotionMQ.addEventListener("change", this._mqHandler);
            } catch {
              this.reduceMotionMQ.addListener(this._mqHandler);
            }
          }
        }
        destroy() {
          this.unsubscribe?.();
          if (this.reduceMotionMQ && this._mqHandler) {
            try {
              this.reduceMotionMQ.removeEventListener("change", this._mqHandler);
            } catch {
              this.reduceMotionMQ.removeListener(this._mqHandler);
            }
          }
        }
        // -------------------------------------------------------------------------
        // Internal helpers
        // -------------------------------------------------------------------------
        _handleFrame(ctx) {
          if (typeof ctx.scrollRatio === "number") {
            this.batcher.queueCSSVariableUpdate(
              "--sn-cdf-scroll-ratio",
              ctx.scrollRatio.toFixed(3)
            );
            this.batcher.queueCSSVariableUpdate(
              "--sn-scroll-ratio",
              ctx.scrollRatio.toFixed(3)
            );
          }
          if (typeof ctx.beatIntensity === "number") {
            const val = ctx.beatIntensity.toFixed(3);
            this.batcher.queueCSSVariableUpdate("--sn-cdf-energy", val);
            this.batcher.queueCSSVariableUpdate("--sn-nebula-beat-intensity", val);
          }
        }
        _syncReducedMotion(reduce) {
          this.batcher.queueCSSVariableUpdate("--sn-cdf-enabled", reduce ? "0" : "1");
        }
      };
      __name(_CDFVariableBridge, "CDFVariableBridge");
      CDFVariableBridge = _CDFVariableBridge;
    }
  });

  // src-js/theme.entry.ts
  init_globalConfig();
  init_year3000System();
  init_UnifiedDebugManager();

  // src-js/visual/ui-effects/Aberration/AberrationCanvas.ts
  var _AberrationCanvas = class _AberrationCanvas {
    constructor(parent, y3k = null) {
      this.parent = parent;
      this.y3k = y3k;
      this.gl = null;
      this.program = null;
      this.tex = null;
      this.strength = 0.4;
      // default; overridden via CSS var
      this.rafId = null;
      this.frameStart = 0;
      this._defaultSize = 256;
      // Bound handlers so we can remove them in destroy()
      this._boundContextLost = /* @__PURE__ */ __name((e) => this._handleContextLost(e), "_boundContextLost");
      this._boundContextRestored = /* @__PURE__ */ __name(() => this._handleContextRestored(), "_boundContextRestored");
      this.canvas = document.createElement("canvas");
      this.canvas.width = this._defaultSize;
      this.canvas.height = this._defaultSize;
      this.canvas.style.width = "100%";
      this.canvas.style.height = "100%";
      Object.assign(this.canvas.style, {
        position: "absolute",
        inset: "0",
        pointerEvents: "none",
        mixBlendMode: "overlay",
        // Changed from "screen" to prevent white bleeding
        zIndex: "-1",
        opacity: "0.6"
        // Reduced opacity to prevent harsh effects
      });
      this.parent.appendChild(this.canvas);
      this.perf = y3k?.performanceAnalyzer ?? null;
      this.canvas.addEventListener(
        "webglcontextlost",
        this._boundContextLost,
        false
      );
      this.canvas.addEventListener(
        "webglcontextrestored",
        this._boundContextRestored,
        false
      );
      this._initGL();
    }
    _initGL() {
      const gl = this.canvas.getContext("webgl", {
        premultipliedAlpha: false,
        alpha: true,
        antialias: false
      });
      if (!gl) {
        console.warn("[AberrationCanvas] WebGL not available \u2013 effect disabled");
        return;
      }
      this.gl = gl;
      const vsSource = `attribute vec2 aPos; varying vec2 vUv; void main(){ vUv = (aPos+1.0)*0.5; gl_Position = vec4(aPos,0.0,1.0); }`;
      const fsSource = `precision mediump float; uniform sampler2D uTex; uniform float uStrength; uniform float uTime; varying vec2 vUv; void main(){ float freq = 8.0; vec2 offset = vec2(sin(vUv.y*freq+uTime)*uStrength, 0.0); vec4 c; c.r = texture2D(uTex, vUv + offset).r; c.g = texture2D(uTex, vUv).g; c.b = texture2D(uTex, vUv - offset).b; c.a = clamp(uStrength * 1.5, 0.0, 0.6); gl_FragColor = c; }`;
      const compile = /* @__PURE__ */ __name((type, src) => {
        const sh = gl.createShader(type);
        gl.shaderSource(sh, src);
        gl.compileShader(sh);
        return sh;
      }, "compile");
      const vs = compile(gl.VERTEX_SHADER, vsSource);
      const fs = compile(gl.FRAGMENT_SHADER, fsSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error("[AberrationCanvas] Shader link failed");
        return;
      }
      this.program = prog;
      gl.useProgram(prog);
      const verts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
      const loc = gl.getAttribLocation(prog, "aPos");
      gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        1,
        1,
        0,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        new Uint8Array([0, 0, 0, 0])
        // Changed from white [255,255,255,255] to transparent [0,0,0,0]
      );
      this.tex = tex;
    }
    /** Public API: update strength via CSS variable (0–1) */
    setStrength(value) {
      this.strength = value;
    }
    /** Uploads a bitmap (e.g., gradient snapshot) into the shader texture. */
    updateSourceBitmap(bmp) {
      if (!this.gl || !this.tex) return;
      const gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, this.tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bmp);
    }
    /**
     * Public render hook – called by AberrationVisualSystem.onAnimate().
     * All original rendering logic from the private _render loop lives here so
     * that the effect can be orchestrated by MasterAnimationCoordinator.
     */
    render(time) {
      if (!this.gl || !this.program) return;
      const gl = this.gl;
      if (this.perf) this.frameStart = performance.now();
      gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.useProgram(this.program);
      const uTexLoc = gl.getUniformLocation(this.program, "uTex");
      const uStrLoc = gl.getUniformLocation(this.program, "uStrength");
      const uTimeLoc = gl.getUniformLocation(this.program, "uTime");
      gl.uniform1i(uTexLoc, 0);
      gl.uniform1f(uStrLoc, this.strength);
      gl.uniform1f(uTimeLoc, time * 1e-3);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      if (this.perf) {
        const dur = performance.now() - this.frameStart;
        this.perf.shouldUpdate("aberration", 500) && this.perf.endTiming("AberrationCanvas", this.frameStart);
        if (dur > 0.5) {
          console.warn(
            `[AberrationCanvas] Frame ${dur.toFixed(2)} ms exceeds 0.5 ms budget`
          );
        }
      }
    }
    destroy() {
      if (this.rafId) cancelAnimationFrame(this.rafId);
      if (this.gl) {
        const lose = this.gl.getExtension("WEBGL_lose_context");
        lose?.loseContext();
      }
      this.canvas.removeEventListener("webglcontextlost", this._boundContextLost);
      this.canvas.removeEventListener(
        "webglcontextrestored",
        this._boundContextRestored
      );
      this.canvas.remove();
    }
    /**
     * Dynamically adjusts the off-screen buffer resolution. Caller should use
     * powers of two (64–256) to keep GPU happy. Safe to call every time
     * performance mode toggles – texture & buffers are reused.
     */
    setPixelSize(size) {
      if (size === this.canvas.width) return;
      this.canvas.width = size;
      this.canvas.height = size;
    }
    // ────────────────────────────────────────────────────────────────
    // Context-loss life-cycle helpers (Phase-5)
    // ────────────────────────────────────────────────────────────────
    _handleContextLost(e) {
      e.preventDefault();
      console.warn("[AberrationCanvas] WebGL context lost \u2013 waiting for restore");
      this.gl = null;
      this.program = null;
    }
    _handleContextRestored() {
      console.info(
        "[AberrationCanvas] WebGL context restored \u2013 re-initializing GL"
      );
      this._initGL();
    }
  };
  __name(_AberrationCanvas, "AberrationCanvas");
  var AberrationCanvas = _AberrationCanvas;

  // src-js/visual/ui-effects/Aberration/AberrationVisualSystem.ts
  var _AberrationVisualSystem = class _AberrationVisualSystem {
    constructor(canvas, perf) {
      this.systemName = "AberrationCanvas";
      this._elapsed = 0;
      this._canvas = canvas;
      this._perf = perf;
    }
    /* --------------------------------------------------------------- */
    /* MasterAnimationCoordinator hooks                                */
    /* --------------------------------------------------------------- */
    /**
     * Called by the coordinator every frame (subject to frame budgeting).
     * @param deltaMs Time in milliseconds since last call.
     * @param _context Shared FrameContext from VisualSystemRegistry (unused for now).
     */
    onAnimate(deltaMs, _context) {
      this._elapsed += deltaMs;
      let start = 0;
      if (this._perf) start = this._perf.startTiming("AberrationVisualSystem");
      this._canvas.render(this._elapsed);
      if (this._perf && start) {
        this._perf.endTiming("AberrationVisualSystem", start);
      }
    }
    /**
     * Optional hook – will be invoked when MAC toggles performance modes.
     * We keep it for future Phase-2 improvements (dynamic resolution scaling).
     */
    onPerformanceModeChange(mode) {
      if (mode === "performance") {
        this._canvas.setPixelSize(128);
        this._canvas.setStrength(0.25);
      } else {
        this._canvas.setPixelSize(256);
        this._canvas.setStrength(0.4);
      }
    }
    /* --------------------------------------------------------------- */
    /* Lifecycle helpers                                               */
    /* --------------------------------------------------------------- */
    destroy() {
      this._canvas.destroy();
    }
  };
  __name(_AberrationVisualSystem, "AberrationVisualSystem");
  var AberrationVisualSystem = _AberrationVisualSystem;

  // src-js/utils/dom/getScrollNode.ts
  var SCROLL_NODE_SELECTORS = [
    ".main-view-container__scroll-node",
    // 2023-era builds
    ".main-viewContainer-scrollNode",
    // 2024 dash variant
    ".main-viewContainer__scrollNode"
    // 2024 double-underscore variant
  ].join(", ");
  function getScrollNode() {
    return document.querySelector(SCROLL_NODE_SELECTORS);
  }
  __name(getScrollNode, "getScrollNode");

  // src-js/visual/ui-effects/Aberration/AberrationManager.ts
  var instance = null;
  var visualSystem = null;
  function isAberrationEnabled() {
    try {
      const val = window.Spicetify?.LocalStorage?.get?.(
        "sn-enable-aberration"
      );
      return val !== "false";
    } catch {
      return true;
    }
  }
  __name(isAberrationEnabled, "isAberrationEnabled");
  function attach(y3k) {
    if (!isAberrationEnabled()) {
      setNebulaNoiseEnabled(false, y3k);
      return;
    }
    const node = getScrollNode();
    if (!node) return;
    if (instance && instance.parent === node) return;
    instance?.destroy();
    instance = new AberrationCanvas(node, y3k);
    if (window.__SN_DEBUG_ABERRATION) {
      console.log("[AberrationManager] canvas attached", node);
    }
    setNebulaNoiseEnabled(true, y3k);
    if (y3k && instance) {
      visualSystem = new AberrationVisualSystem(
        instance,
        y3k.performanceAnalyzer || void 0
      );
      y3k?.registerVisualSystem?.(visualSystem, "critical");
      y3k.performanceAnalyzer?.emitTrace("AberrationCanvasAttached");
    }
  }
  __name(attach, "attach");
  function setNebulaNoiseEnabled(enabled, y3k) {
    if (y3k) {
      y3k.queueCSSVariableUpdate(
        "--sn-nebula-noise-opacity",
        enabled ? "0.03" : "0"
      );
    } else {
      document.documentElement.style.setProperty(
        "--sn-nebula-noise-opacity",
        enabled ? "0.03" : "0"
      );
    }
  }
  __name(setNebulaNoiseEnabled, "setNebulaNoiseEnabled");
  function initializeAberrationManager(y3k = null) {
    attach(y3k);
    if (!instance) setNebulaNoiseEnabled(false, y3k);
    const history = window.Spicetify?.Platform?.History;
    if (history?.listen) {
      history.listen(() => setTimeout(() => attach(y3k), 0));
    }
    document.addEventListener("spicetify:appchange", () => attach(y3k));
    const observer = new MutationObserver(() => {
      if (!instance) {
        attach(y3k);
        if (!instance) setNebulaNoiseEnabled(false, y3k);
      } else {
        observer.disconnect();
      }
    });
    observer.observe(document.documentElement, {
      childList: true,
      subtree: true
    });
    document.addEventListener("year3000SystemSettingsChanged", (e) => {
      const { key, value } = e.detail || {};
      if (key === "sn-enable-aberration") {
        const enable = value === "true";
        if (enable && !instance) {
          attach(y3k);
        } else if (!enable && instance) {
          instance.destroy();
          instance = null;
          y3k?.unregisterAnimationSystem("AberrationCanvas");
          visualSystem?.destroy();
          visualSystem = null;
          y3k?.performanceAnalyzer?.emitTrace("AberrationCanvasDetached");
        }
        setNebulaNoiseEnabled(enable && !!instance, y3k);
      }
      if (key === "sn-nebula-aberration-strength") {
        const num = parseFloat(value);
        if (!Number.isNaN(num) && instance) {
          instance.setStrength(num);
        }
        y3k?.queueCSSVariableUpdate(
          "--sn-nebula-aberration-strength",
          String(value)
        );
      }
    });
  }
  __name(initializeAberrationManager, "initializeAberrationManager");

  // src-js/visual/ui-effects/AudioVisualController.ts
  init_settingKeys();
  init_CSSVariableBatcher();
  init_EventBus();

  // src-js/utils/platform/UserHistory.ts
  var LS_KEY = "sn_seen_genres_v1";
  var _UserGenreHistory = class _UserGenreHistory {
    constructor() {
      const raw = typeof localStorage !== "undefined" ? localStorage.getItem(LS_KEY) : null;
      this.seen = new Set(raw ? JSON.parse(raw) : []);
    }
    hasSeen(genre) {
      return this.seen.has(genre.toLowerCase());
    }
    markSeen(genre) {
      const key = genre.toLowerCase();
      if (!this.seen.has(key)) {
        this.seen.add(key);
        this._persist();
      }
    }
    _persist() {
      try {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(LS_KEY, JSON.stringify([...this.seen]));
        }
      } catch (_e) {
      }
    }
  };
  __name(_UserGenreHistory, "UserGenreHistory");
  var UserGenreHistory = _UserGenreHistory;

  // src-js/visual/ui-effects/AudioVisualController.ts
  function median(values) {
    if (!values.length) return 0;
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 !== 0) {
      return sorted[mid] ?? 0;
    }
    const lower = sorted[mid - 1] ?? 0;
    const upper = sorted[mid] ?? 0;
    return (lower + upper) / 2;
  }
  __name(median, "median");
  var _AudioVisualController = class _AudioVisualController {
    constructor(y3k = null, batcher, perf) {
      this.unsubscribers = [];
      this.frameDurations = [];
      // rolling window for medians
      this.enabled = true;
      this.intensitySetting = "balanced";
      this.intensityFactor = 1;
      this.genreHistory = new UserGenreHistory();
      this.activeGlowTimeout = null;
      this.interactionOffHandler = null;
      this.year3000System = y3k;
      if (batcher) {
        this.batcher = batcher;
      } else {
        const sharedBatcher = y3k?.cssVariableBatcher;
        if (sharedBatcher) {
          this.batcher = sharedBatcher;
        } else {
          this.batcher = new CSSVariableBatcher({
            batchIntervalMs: 16,
            maxBatchSize: 40
          });
        }
      }
      this.perf = perf ? perf : y3k?.performanceAnalyzer ?? null;
      const prefersReducedMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;
      const capabilityOverall = y3k?.deviceCapabilityDetector?.deviceCapabilities?.overall;
      const settings = y3k?.settingsManager;
      if (settings) {
        this.intensitySetting = settings.get(NEBULA_INTENSITY_KEY) ?? "balanced";
      }
      switch (this.intensitySetting) {
        case "disabled":
          this.enabled = false;
          break;
        case "minimal":
          this.intensityFactor = 0.6;
          break;
        case "balanced":
          this.intensityFactor = 1;
          break;
        case "intense":
          this.intensityFactor = 1.4;
          break;
      }
      if (prefersReducedMotion || capabilityOverall === "low") {
        this.enabled = false;
      }
      if (this.enabled) {
        this._subscribe();
      } else {
        if (typeof document !== "undefined") {
          document.documentElement.style.setProperty(
            "--sn-nebula-beat-intensity",
            "0"
          );
        }
      }
    }
    _subscribe() {
      this.unsubscribers.push(
        GlobalEventBus.subscribe(
          "music:beat",
          (p) => this._handleBeat(p)
        ),
        GlobalEventBus.subscribe(
          "music:genre-change",
          (p) => this._handleGenreChange(p)
        ),
        GlobalEventBus.subscribe(
          "user:scroll",
          (p) => this._handleScroll(p)
        )
      );
    }
    // ---------------------------------------------------------------------------
    // Event Handlers – all lightweight calculations to stay under 2 ms median.
    // ---------------------------------------------------------------------------
    _handleBeat(payload) {
      const t0 = performance.now();
      const safeEnergy = typeof payload.energy === "number" ? payload.energy : 0.5;
      const intensity = (0.8 + Math.min(Math.max(safeEnergy, 0), 1) * 0.6) * this.intensityFactor;
      this._queueVar("--sn-nebula-beat-intensity", intensity.toFixed(3));
      const aberrationStrength = (safeEnergy * 0.6).toFixed(3);
      this._queueVar("--sn-nebula-aberration-strength", aberrationStrength);
      this._recordDuration(t0);
    }
    _handleGenreChange(payload) {
      const t0 = performance.now();
      if (this.genreHistory.hasSeen(payload.genre)) {
        return;
      }
      this.genreHistory.markSeen(payload.genre);
      const cueOpacity = 0.18 * this.intensityFactor;
      this._queueVar("--sn-nebula-layer-0-opacity", cueOpacity.toFixed(3));
      const clearCue = /* @__PURE__ */ __name(() => {
        if (this.year3000System?.timerConsolidationSystem) {
          this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer("AudioVisualController-glowTimeout");
        } else if (this.activeGlowTimeout) {
          clearTimeout(this.activeGlowTimeout);
          this.activeGlowTimeout = null;
        }
        this._queueVar("--sn-nebula-layer-0-opacity", "0.05");
        if (this.interactionOffHandler) {
          document.removeEventListener("pointerdown", this.interactionOffHandler);
          document.removeEventListener("keydown", this.interactionOffHandler);
          this.interactionOffHandler = null;
        }
      }, "clearCue");
      if (this.year3000System?.timerConsolidationSystem) {
        this.year3000System.timerConsolidationSystem.registerConsolidatedTimer(
          "AudioVisualController-glowTimeout",
          clearCue,
          4e3,
          "normal"
        );
        this.activeGlowTimeout = null;
      } else {
        this.activeGlowTimeout = setTimeout(clearCue, 4e3);
      }
      this.interactionOffHandler = () => clearCue();
      document.addEventListener("pointerdown", this.interactionOffHandler, {
        once: true
      });
      document.addEventListener("keydown", this.interactionOffHandler, {
        once: true
      });
      this._queueVar("--sn-nebula-ease-t", "1");
      this._recordDuration(t0);
    }
    _handleScroll(payload) {
      const t0 = performance.now();
      const safeVel = typeof payload.velocity === "number" ? payload.velocity : 0;
      const vel = Math.min(Math.abs(safeVel), 50);
      const blurBoost = vel / 50 * 2 * this.intensityFactor;
      this._queueVar(
        "--sn-nebula-layer-3-blur",
        `calc(var(--sn-depth-layer-3-blur) + ${blurBoost.toFixed(2)}px)`
      );
      const baseScaleY = 150;
      let clampedVel = Math.max(Math.min(payload.velocity ?? 0, 50), -50);
      const deltaScale = clampedVel / 50 * 50;
      const noiseScale = Math.max(140, Math.min(200, baseScaleY + deltaScale));
      this._queueVar("--sn-nebula-noise-scale-y", `${noiseScale.toFixed(1)}%`);
      this._recordDuration(t0);
    }
    // ---------------------------------------------------------------------------
    // Helpers
    // ---------------------------------------------------------------------------
    _queueVar(prop, value) {
      if (!this.enabled) return;
      if (this.year3000System) {
        this.year3000System.queueCSSVariableUpdate(prop, value);
      } else {
        this.batcher.queueCSSVariableUpdate(prop, value);
      }
    }
    _recordDuration(start) {
      const duration = performance.now() - start;
      this.frameDurations.push(duration);
      if (this.frameDurations.length > _AudioVisualController.FRAME_HISTORY) {
        this.frameDurations.shift();
      }
      if (this.frameDurations.length === _AudioVisualController.FRAME_HISTORY) {
        const med = median(this.frameDurations);
        if (med > 2) {
          console.warn(
            `[AudioVisualController] Median scripting cost ${med.toFixed(
              2
            )} ms exceeds 2 ms budget.`
          );
          this._queueVar("--sn-nebula-blend-mode", "screen");
        }
      }
      this.perf?.shouldUpdate("nebulaCtr", 1e3) && this.perf?.endTiming("AudioVisualController", start);
    }
    destroy() {
      if (this.year3000System?.timerConsolidationSystem) {
        this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer("AudioVisualController-glowTimeout");
      }
      if (this.activeGlowTimeout) {
        clearTimeout(this.activeGlowTimeout);
        this.activeGlowTimeout = null;
      }
      if (this.interactionOffHandler) {
        document.removeEventListener("pointerdown", this.interactionOffHandler);
        document.removeEventListener("keydown", this.interactionOffHandler);
        this.interactionOffHandler = null;
      }
      this.unsubscribers.forEach((u) => u());
      this.unsubscribers = [];
    }
  };
  __name(_AudioVisualController, "AudioVisualController");
  _AudioVisualController.FRAME_HISTORY = 120;
  var AudioVisualController = _AudioVisualController;
  function initializeAudioVisualController(y3k = null) {
    const g2 = globalThis;
    if (g2.__SN_audioVisualController)
      return g2.__SN_audioVisualController;
    const instance2 = new AudioVisualController(y3k);
    g2.__SN_audioVisualController = instance2;
    return instance2;
  }
  __name(initializeAudioVisualController, "initializeAudioVisualController");

  // src-js/utils/platform/spicetifyReady.ts
  async function waitForSpicetifyReady(timeout = 1e4, checkInterval = 100) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      const spicetify = window.Spicetify;
      if (spicetify?.showNotification && spicetify?.Platform) {
        return true;
      }
      await new Promise((res) => setTimeout(res, checkInterval));
    }
    return false;
  }
  __name(waitForSpicetifyReady, "waitForSpicetifyReady");

  // src-js/theme.entry.ts
  init_Year3000Utilities();
  async function waitForAPI(apiPath, timeout = 5e3) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      try {
        const api = apiPath.split(".").reduce((obj, prop) => obj?.[prop], window);
        if (api) return api;
      } catch (e) {
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    return null;
  }
  __name(waitForAPI, "waitForAPI");
  function patchReactRequire() {
    const g2 = globalThis;
    if (g2.__STARLIGHT_REACT_SHIM__) return;
    const shim = /* @__PURE__ */ __name((name) => {
      if (name === "react") return g2.Spicetify?.React;
      if (name === "react-dom") return g2.Spicetify?.ReactDOM;
      throw new Error(`[StarryNight shim] Module '${name}' not available`);
    }, "shim");
    if (typeof g2.require === "function") {
      const original = g2.require.bind(g2);
      g2.require = (name) => {
        if (name === "react" || name === "react-dom") return shim(name);
        return original(name);
      };
    } else {
      g2.require = shim;
    }
    g2.__STARLIGHT_REACT_SHIM__ = true;
  }
  __name(patchReactRequire, "patchReactRequire");
  patchReactRequire();
  (/* @__PURE__ */ __name(async function catppuccinStarryNight() {
    const startTime = Date.now();
    console.log("\u{1F31F} [Catppuccin StarryNight] Theme entry point starting...");
    const spicetifyReady = await waitForSpicetifyReady(1e4);
    if (!spicetifyReady) {
      console.warn(
        "\u{1F31F} [StarryNight] Spicetify not fully ready after 10s \u2013 proceeding with degraded visual-only mode."
      );
    }
    const requiredAPIs = {
      player: await waitForAPI("Spicetify.Player", 3e3),
      platform: await waitForAPI("Spicetify.Platform", 3e3),
      menu: await waitForAPI("Spicetify.Menu", 2e3),
      react: await waitForAPI("Spicetify.React", 2e3),
      reactDOM: await waitForAPI("Spicetify.ReactDOM", 2e3)
    };
    const mainContainer = await waitForAPI(
      'document.querySelector(".main-viewContainer-scrollNode, .main-view-container__scroll-node-child")',
      1e4
    );
    Promise.resolve().then(() => (init_prismaticScrollSheen(), prismaticScrollSheen_exports)).then(
      (m) => m.initializePrismaticScrollSheen?.()
    );
    const hasRequiredAPIs = requiredAPIs.player && requiredAPIs.platform && mainContainer;
    const degradedMode = !hasRequiredAPIs;
    if (degradedMode) {
      console.log(
        "\u{1F31F} [StarryNight] Initializing in DEGRADED MODE due to missing APIs"
      );
      console.log("\u{1F31F} [StarryNight] Available APIs:", {
        player: !!requiredAPIs.player,
        platform: !!requiredAPIs.platform,
        menu: !!requiredAPIs.menu,
        react: !!requiredAPIs.react,
        reactDOM: !!requiredAPIs.reactDOM,
        mainContainer: !!mainContainer
      });
    } else {
      console.log(
        "\u{1F31F} [StarryNight] All required APIs available - initializing in FULL MODE"
      );
    }
    const ENABLE_GLOBAL_DEBUGGING = true;
    if (ENABLE_GLOBAL_DEBUGGING) {
      YEAR3000_CONFIG.enableDebug = true;
      Promise.resolve().then(() => (init_DragCartographer(), DragCartographer_exports)).then((m) => {
        m.enableDragCartography?.();
        window.getDragMap = m.getDragMap;
      });
    }
    const year3000System2 = new Year3000System(YEAR3000_CONFIG);
    initializeAudioVisualController(year3000System2);
    initializeAberrationManager(year3000System2);
    Promise.resolve().then(() => (init_EnhancedDragPreview(), EnhancedDragPreview_exports)).then(
      (m) => m.enableEnhancedDragPreview?.()
    );
    Promise.resolve().then(() => (init_QuickAddRadialMenu(), QuickAddRadialMenu_exports)).then(
      (m) => m.enableQuickAddRadialMenu?.()
    );
    try {
      if (degradedMode) {
        await year3000System2.initializeWithAvailableAPIs({
          player: requiredAPIs.player,
          platform: requiredAPIs.platform,
          config: window.Spicetify?.Config,
          degradedMode: true
        });
        console.log(
          "\u{1F31F} [StarryNight] Initialized in degraded mode - visual systems only"
        );
      } else {
        await year3000System2.initializeAllSystems();
        year3000System2.setupMusicAnalysisAndColorExtraction();
        console.log("\u{1F31F} [StarryNight] Full initialization complete");
      }
    } catch (error) {
      console.error("[StarryNight] System initialization failed:", error);
    }
    try {
      if (requiredAPIs.react && requiredAPIs.reactDOM) {
        const settingsUiModule = await Promise.resolve().then(() => (init_StarryNightSettings(), StarryNightSettings_exports));
        await settingsUiModule.initializeStarryNightSettings?.();
        console.log(
          "\u{1F31F} [StarryNight] Spicetify native settings with Year3000System integration initialized"
        );
      } else {
        console.warn(
          "\u{1F31F} [StarryNight] React APIs not available - continuing with CSS-only theme"
        );
      }
    } catch (e) {
      console.error("[StarryNight] Failed to initialize native settings:", e);
      console.warn(
        "\u{1F31F} [StarryNight] Continuing with CSS-only theme (no settings UI)"
      );
    }
    if (YEAR3000_CONFIG.enableDebug) {
      window.Y3K = {
        system: year3000System2,
        // Expose internal modules for easier debugging
        music: year3000System2.musicSyncService,
        settings: year3000System2.settingsManager,
        // Expose the superior, specialized debug tools directly
        debug: Y3K.debug,
        health: year3000System2.systemHealthMonitor,
        // Add degraded mode info
        mode: degradedMode ? "degraded" : "full",
        availableAPIs: requiredAPIs
      };
    }
    try {
      const { RightSidebarConsciousnessSystem: RightSidebarConsciousnessSystem2 } = await Promise.resolve().then(() => (init_RightSidebarConsciousnessSystem(), RightSidebarConsciousnessSystem_exports));
      const { SidebarPerformanceCoordinator: SidebarPerformanceCoordinator2 } = await Promise.resolve().then(() => (init_SidebarPerformanceCoordinator(), SidebarPerformanceCoordinator_exports));
      if (year3000System2.performanceAnalyzer) {
        const coordinator = SidebarPerformanceCoordinator2.getInstance({
          enableDebug: YEAR3000_CONFIG.enableDebug,
          performanceAnalyzer: year3000System2.performanceAnalyzer,
          onFlushComplete: /* @__PURE__ */ __name(() => {
            year3000System2.performanceAnalyzer?.emitTrace?.(
              "[SidebarPerformanceCoordinator] Flush completed"
            );
          }, "onFlushComplete")
        });
        coordinator.setupDOMObservation();
        const rsSystem = new RightSidebarConsciousnessSystem2(
          YEAR3000_CONFIG,
          Year3000Utilities_exports,
          year3000System2.performanceAnalyzer,
          year3000System2.musicSyncService,
          year3000System2.settingsManager,
          year3000System2,
          coordinator
        );
        await rsSystem.initialize();
        year3000System2.rightSidebarConsciousnessSystem = rsSystem;
        year3000System2.rightSidebarCoordinator = coordinator;
      }
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize RightSidebarConsciousnessSystem",
        err
      );
    }
    try {
      const { CDFVariableBridge: CDFVariableBridge2 } = await Promise.resolve().then(() => (init_CDFVariableBridge(), CDFVariableBridge_exports));
      if (year3000System2.cssVariableBatcher) {
        new CDFVariableBridge2(year3000System2.cssVariableBatcher);
      }
    } catch (err) {
      console.error("[StarryNight] Failed to initialize CDFVariableBridge", err);
    }
    const initTime = Date.now() - startTime;
    console.log(
      `\u{1F30C} Catppuccin StarryNight Theme initialized in ${initTime}ms (${degradedMode ? "degraded" : "full"} mode). Welcome to the future of sound!`
    );
  }, "catppuccinStarryNight"))();
})();
//# sourceMappingURL=theme.js.map
