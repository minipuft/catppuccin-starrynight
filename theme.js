"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // src-js/config/coreTheme.ts
  var CATPPUCCIN_FLAVORS, ACCENT_COLORS, CORE_THEME_VALIDATORS;
  var init_coreTheme = __esm({
    "src-js/config/coreTheme.ts"() {
      "use strict";
      CATPPUCCIN_FLAVORS = {
        latte: {
          name: "Latte",
          base: "#eff1f5",
          text: "#4c4f69",
          isDark: false
        },
        frappe: {
          name: "Frapp\xE9",
          base: "#303446",
          text: "#c6d0f5",
          isDark: true
        },
        macchiato: {
          name: "Macchiato",
          base: "#24273a",
          text: "#cad3f5",
          isDark: true
        },
        mocha: {
          name: "Mocha",
          base: "#1e1e2e",
          text: "#cdd6f4",
          isDark: true
        }
      };
      ACCENT_COLORS = [
        "rosewater",
        "flamingo",
        "pink",
        "mauve",
        "red",
        "maroon",
        "peach",
        "yellow",
        "green",
        "teal",
        "sky",
        "sapphire",
        "blue",
        "lavender",
        "text",
        "none"
      ];
      CORE_THEME_VALIDATORS = {
        flavor: /* @__PURE__ */ __name((value) => typeof value === "string" && value in CATPPUCCIN_FLAVORS, "flavor"),
        accentColor: /* @__PURE__ */ __name((value) => typeof value === "string" && ACCENT_COLORS.includes(value), "accentColor"),
        brightnessMode: /* @__PURE__ */ __name((value) => typeof value === "string" && ["bright", "balanced", "dark"].includes(value), "brightnessMode"),
        paletteSystem: /* @__PURE__ */ __name((value) => typeof value === "string" && ["catppuccin", "year3000"].includes(value), "paletteSystem"),
        gradientIntensity: /* @__PURE__ */ __name((value) => typeof value === "string" && ["disabled", "minimal", "balanced", "intense"].includes(value), "gradientIntensity"),
        glassmorphismLevel: /* @__PURE__ */ __name((value) => typeof value === "string" && ["disabled", "minimal", "moderate", "intense"].includes(value), "glassmorphismLevel"),
        webglEnabled: /* @__PURE__ */ __name((value) => typeof value === "boolean" || typeof value === "string" && ["true", "false"].includes(value), "webglEnabled"),
        animationQuality: /* @__PURE__ */ __name((value) => typeof value === "string" && ["auto", "low", "high"].includes(value), "animationQuality"),
        webglQuality: /* @__PURE__ */ __name((value) => typeof value === "string" && ["low", "medium", "high"].includes(value), "webglQuality")
      };
    }
  });

  // src-js/config/harmonicModes.ts
  var COLOR_HARMONY_MODES, MUSIC_VISUAL_SYNC, ENHANCED_BPM_CONFIG, HARMONIC_MODES;
  var init_harmonicModes = __esm({
    "src-js/config/harmonicModes.ts"() {
      "use strict";
      COLOR_HARMONY_MODES = {
        "analogous-flow": {
          rule: "analogous",
          angle: 30,
          description: "Flowing cinematic gradients with adjacent hues"
        },
        "triadic-trinity": {
          rule: "triadic",
          angle: 120,
          description: "Dramatic three-color gradient dynamics"
        },
        "complementary-yin-yang": {
          rule: "complementary",
          angle: 180,
          description: "Electric contrast gradients with opposing forces"
        },
        "tetradic-advanced-cross": {
          rule: "tetradic",
          angle: 90,
          description: "Complex four-color gradient matrix"
        },
        "split-complementary-spectrum": {
          rule: "split-complementary",
          angle: 150,
          description: "Spectrum-like gradient flows with polar contrasts"
        },
        "monochromatic-calm": {
          rule: "monochromatic",
          angle: 0,
          description: "Intense single-hue gradient depth"
        }
      };
      MUSIC_VISUAL_SYNC = {
        energyScaling: {
          low: 0.8,
          // Enhanced low energy for subtle gradients
          medium: 1.2,
          // Increased medium energy for dynamic gradients  
          high: 1.8
          // Maximum high energy for intense gradient flows
        },
        valenceScaling: {
          sad: 1,
          // Enhanced sad scaling for dramatic gradients
          neutral: 1.2,
          // Increased neutral for balanced gradients
          happy: 1.6
          // Maximum happy scaling for vibrant gradients
        },
        danceabilityEffects: {
          enable: true,
          animationSpeedMultiplier: 1.5,
          blurVariation: 0.3
        }
      };
      ENHANCED_BPM_CONFIG = {
        enable: true,
        useSmartCalculation: true,
        useRealisticData: true,
        // Tempo-based danceability estimation ranges
        danceabilityEstimation: {
          highDance: { min: 120, max: 140, value: 0.8 },
          // House/Dance music
          mediumDance: { min: 100, max: 160, value: 0.6 },
          // Pop/Electronic
          lowMediumDance: { min: 80, max: 180, value: 0.4 },
          // General music
          lowDance: { value: 0.2 }
          // Very slow/fast
        },
        // Energy estimation from tempo + loudness  
        energyEstimation: {
          tempoWeight: 0.6,
          loudnessWeight: 0.4,
          tempoRange: { min: 60, max: 180 },
          loudnessRange: { min: -60, max: 0 }
        },
        // Enhanced BPM calculation parameters
        danceabilityThresholds: {
          high: 0.7,
          // High danceability - use full tempo
          low: 0.3
          // Low danceability - may reduce tempo
        },
        energyMultiplierRange: {
          min: 0.8,
          // Minimum energy multiplier
          max: 1.4
          // Maximum energy multiplier  
        },
        tempoMultipliers: {
          highDance: 1,
          // Full tempo for danceable tracks
          mediumDance: 0.75,
          // Moderate reduction
          lowDance: 0.5
          // Significant reduction for smooth visuals
        },
        // Fallback values when audio data is unavailable
        fallbacks: {
          tempo: 120,
          loudness: -10,
          danceability: 0.5,
          energy: 0.5,
          key: 0,
          timeSignature: 4
        }
      };
      HARMONIC_MODES = {
        ...COLOR_HARMONY_MODES,
        // Legacy key mappings
        "tetradic-cosmic-cross": COLOR_HARMONY_MODES["tetradic-advanced-cross"],
        "split-complementary-aurora": COLOR_HARMONY_MODES["split-complementary-spectrum"],
        "monochromatic-meditation": COLOR_HARMONY_MODES["monochromatic-calm"]
      };
    }
  });

  // src-js/config/artisticProfiles.ts
  var ARTISTIC_MODE_PROFILES;
  var init_artisticProfiles = __esm({
    "src-js/config/artisticProfiles.ts"() {
      "use strict";
      ARTISTIC_MODE_PROFILES = {
        "corporate-safe": {
          displayName: "Corporate Safe",
          description: "Subtle gradient elegance with professional restraint and refined color transitions",
          philosophy: "Gentle gradient flows that maintain workspace harmony while providing sophisticated visual depth",
          multipliers: {
            opacity: 0.2,
            saturation: 1.15,
            // Enhanced for subtle gradient definition
            brightness: 1.08,
            // Improved brightness for gentle luminance
            contrast: 1.05,
            // Slight contrast improvement for definition
            musicEnergyBoost: 0.4,
            // Animation Parameters
            animationIntensity: 0.3,
            timeBasedEffectFactor: 0.2,
            interactionStrength: 0.2,
            advancedAnimations: false,
            visualIntensityBase: 0.9,
            // Legacy compatibility
            kineticIntensity: 0.3,
            timeBasedPlayFactor: 0.2,
            aestheticGravityStrength: 0.2,
            emergentChoreography: false
          },
          features: {
            rippleEffects: false,
            timeBasedEcho: false,
            particleStreams: false,
            predictiveHighlights: true,
            // Subtle only
            glassEffects: true,
            // Minimal
            beatSync: false,
            colorHarmony: false,
            userInteractions: false,
            // Disabled for professional environments
            aestheticGravity: false
            // Legacy compatibility
          },
          performance: {
            maxParticles: 0,
            animationThrottle: 32,
            // 30fps for efficiency
            enableGPUAcceleration: false,
            reducedMotion: true
          }
        },
        "artist-vision": {
          displayName: "Artist Vision",
          description: "Cinematic gradient expression with vibrant, flowing color transitions",
          philosophy: "Dramatic gradient harmonies that create depth and emotional resonance through bold color interactions",
          multipliers: {
            opacity: 0.35,
            saturation: 1.45,
            // Enhanced for vibrant gradients
            brightness: 1.25,
            // Increased luminance for gradient depth
            contrast: 1.3,
            // Higher contrast for dramatic effects
            musicEnergyBoost: 1.2,
            // Animation Parameters
            animationIntensity: 0.8,
            timeBasedEffectFactor: 0.7,
            interactionStrength: 0.6,
            advancedAnimations: true,
            visualIntensityBase: 1.2,
            // Legacy compatibility
            kineticIntensity: 0.8,
            timeBasedPlayFactor: 0.7,
            aestheticGravityStrength: 0.6,
            emergentChoreography: true
          },
          features: {
            rippleEffects: true,
            // Moderate intensity
            timeBasedEcho: true,
            // Subtle trails
            particleStreams: true,
            // Music-responsive
            predictiveHighlights: true,
            glassEffects: true,
            beatSync: true,
            // Musical harmony
            colorHarmony: true,
            // Respectful blending
            userInteractions: true,
            // Balanced interaction effects
            aestheticGravity: true
            // Legacy compatibility
          },
          performance: {
            maxParticles: 20,
            animationThrottle: 16,
            // 60fps
            enableGPUAcceleration: true,
            reducedMotion: false
          }
        },
        "advanced-maximum": {
          displayName: "Advanced Maximum",
          description: "Ultra-intense cinematic gradients with maximum color saturation and fluid dynamics",
          philosophy: "Maximum gradient intensity through electric color combinations that create immersive visual landscapes",
          multipliers: {
            opacity: 0.55,
            saturation: 1.65,
            // Maximum saturation for electric gradients
            brightness: 1.35,
            // Enhanced brightness for luminous effects
            contrast: 1.5,
            // Maximum contrast for dramatic depth
            musicEnergyBoost: 2.5,
            // Animation Parameters
            animationIntensity: 2,
            timeBasedEffectFactor: 3,
            interactionStrength: 2,
            advancedAnimations: true,
            visualIntensityBase: 1.8,
            // Legacy compatibility
            kineticIntensity: 2,
            timeBasedPlayFactor: 3,
            aestheticGravityStrength: 2,
            emergentChoreography: true
          },
          features: {
            rippleEffects: true,
            // Full intensity
            timeBasedEcho: true,
            // Visible trails
            particleStreams: true,
            // Attention flow
            predictiveHighlights: true,
            // Advanced prediction
            glassEffects: true,
            // Intense
            beatSync: true,
            // Full synchronization
            colorHarmony: true,
            // Dynamic evolution
            userInteractions: true,
            // Visual magnetism
            aestheticGravity: true
            // Legacy compatibility
          },
          performance: {
            maxParticles: 50,
            animationThrottle: 30,
            // 30fps for smoothness
            enableGPUAcceleration: true,
            reducedMotion: false
          }
        }
      };
      ARTISTIC_MODE_PROFILES["cosmic-maximum"] = {
        ...ARTISTIC_MODE_PROFILES["advanced-maximum"],
        displayName: "Cosmic Maximum",
        // Keep original display name for UI
        description: "Ultra-intense cinematic gradients with maximum color saturation and fluid dynamics",
        philosophy: "Maximum gradient intensity through electric color combinations that create immersive visual landscapes"
      };
    }
  });

  // src-js/config/performanceProfiles.ts
  var PERFORMANCE_PROFILES, DEFAULT_LOGGING_CONFIG;
  var init_performanceProfiles = __esm({
    "src-js/config/performanceProfiles.ts"() {
      "use strict";
      PERFORMANCE_PROFILES = {
        low: {
          maxParticles: 15,
          animationThrottle: 32,
          // ~30fps
          enableGPUAcceleration: false,
          enableAdvancedShaders: false,
          textureResolution: 0.5
        },
        balanced: {
          maxParticles: 40,
          animationThrottle: 16,
          // ~60fps
          enableGPUAcceleration: true,
          enableAdvancedShaders: false,
          textureResolution: 1
        },
        high: {
          maxParticles: 75,
          animationThrottle: 16,
          // ~60fps
          enableGPUAcceleration: true,
          enableAdvancedShaders: true,
          textureResolution: 1
        },
        ultra: {
          maxParticles: 150,
          animationThrottle: 8,
          // ~120fps
          enableGPUAcceleration: true,
          enableAdvancedShaders: true,
          textureResolution: 2
          // High-res textures
        }
      };
      DEFAULT_LOGGING_CONFIG = {
        level: "info",
        performance: {
          enableFrameBudgetWarnings: true,
          throttleWarnings: true,
          throttleInterval: 5e3,
          // ms between repeated warnings
          enableAdaptiveDegradation: true
        }
      };
    }
  });

  // src-js/config/settingKeys.ts
  var HARMONIC_INTENSITY_KEY, HARMONIC_EVOLUTION_KEY, GLASS_LEVEL_KEY;
  var init_settingKeys = __esm({
    "src-js/config/settingKeys.ts"() {
      "use strict";
      HARMONIC_INTENSITY_KEY = "sn-harmonic-intensity";
      HARMONIC_EVOLUTION_KEY = "sn-harmonic-evolution";
      GLASS_LEVEL_KEY = "sn-glassmorphism-level";
    }
  });

  // src-js/config/settingsSchema.ts
  function validateSetting(key, value) {
    const metadata = SETTINGS_METADATA[key];
    return metadata.validator(value);
  }
  function parseSetting(key, value) {
    const metadata = SETTINGS_METADATA[key];
    if (metadata.parser) {
      return metadata.parser(value);
    }
    if (metadata.validator(value)) {
      return value;
    }
    return null;
  }
  function serializeSetting(key, value) {
    const metadata = SETTINGS_METADATA[key];
    if (metadata.serializer) {
      return metadata.serializer(value);
    }
    return String(value);
  }
  function getDefaultValue(key) {
    return SETTINGS_METADATA[key].defaultValue;
  }
  function getAllSettingKeys() {
    return Object.keys(SETTINGS_METADATA);
  }
  function isValidSettingKey(key) {
    return key in SETTINGS_METADATA;
  }
  var SETTINGS_METADATA;
  var init_settingsSchema = __esm({
    "src-js/config/settingsSchema.ts"() {
      "use strict";
      init_harmonicModes();
      init_artisticProfiles();
      init_coreTheme();
      SETTINGS_METADATA = {
        // === CORE THEME SETTINGS ===
        "catppuccin-flavor": {
          defaultValue: "mocha",
          validator: CORE_THEME_VALIDATORS.flavor,
          description: "Catppuccin color theme variant",
          category: "core"
        },
        "catppuccin-accentColor": {
          defaultValue: "mauve",
          validator: CORE_THEME_VALIDATORS.accentColor,
          description: "Primary accent color for UI elements",
          category: "core"
        },
        "sn-brightness-mode": {
          defaultValue: "bright",
          validator: CORE_THEME_VALIDATORS.brightnessMode,
          description: "Overall theme brightness level",
          category: "core"
        },
        // === ADVANCED SYSTEMS ===
        "sn-palette-system": {
          defaultValue: "catppuccin",
          validator: CORE_THEME_VALIDATORS.paletteSystem,
          description: "Color palette system (Catppuccin or Year 3000)",
          category: "advanced"
        },
        "sn-artistic-mode": {
          defaultValue: "artist-vision",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && value in ARTISTIC_MODE_PROFILES, "validator"),
          description: "Visual intensity and behavior preset",
          category: "advanced"
        },
        "sn-current-harmonic-mode": {
          defaultValue: "analogous-flow",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && value in HARMONIC_MODES, "validator"),
          description: "Color harmony rule for music synchronization",
          category: "advanced"
        },
        "sn-harmonic-intensity": {
          defaultValue: 0.7,
          validator: /* @__PURE__ */ __name((value) => typeof value === "number" && value >= 0 && value <= 1, "validator"),
          parser: /* @__PURE__ */ __name((value) => {
            const parsed = parseFloat(value);
            return !isNaN(parsed) && parsed >= 0 && parsed <= 1 ? parsed : null;
          }, "parser"),
          serializer: /* @__PURE__ */ __name((value) => value.toString(), "serializer"),
          description: "Intensity of color harmony effects (0-1)",
          category: "advanced"
        },
        "sn-harmonic-evolution": {
          defaultValue: true,
          validator: /* @__PURE__ */ __name((value) => typeof value === "boolean", "validator"),
          parser: /* @__PURE__ */ __name((value) => {
            if (value === "true") return true;
            if (value === "false") return false;
            return null;
          }, "parser"),
          serializer: /* @__PURE__ */ __name((value) => value.toString(), "serializer"),
          description: "Enable dynamic color harmony evolution",
          category: "advanced"
        },
        // === VISUAL CONTROLS ===
        "sn-gradient-intensity": {
          defaultValue: "balanced",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && ["disabled", "minimal", "balanced", "intense"].includes(value), "validator"),
          description: "Master control for all gradient background effects",
          category: "visual"
        },
        "sn-glassmorphism-level": {
          defaultValue: "balanced",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && ["disabled", "minimal", "balanced", "intense"].includes(value), "validator"),
          description: "Glass-like transparency effects intensity",
          category: "visual"
        },
        // === PERFORMANCE SETTINGS ===
        "sn-webgl-enabled": {
          defaultValue: true,
          validator: /* @__PURE__ */ __name((value) => typeof value === "boolean", "validator"),
          parser: /* @__PURE__ */ __name((value) => {
            if (value === "true") return true;
            if (value === "false") return false;
            return null;
          }, "parser"),
          serializer: /* @__PURE__ */ __name((value) => value.toString(), "serializer"),
          description: "Enable WebGL-accelerated visual effects",
          category: "performance"
        },
        "sn-animation-quality": {
          defaultValue: "auto",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && ["auto", "low", "high"].includes(value), "validator"),
          description: "Animation performance vs quality balance",
          category: "performance"
        },
        "sn-webgl-quality": {
          defaultValue: "medium",
          validator: /* @__PURE__ */ __name((value) => typeof value === "string" && ["low", "medium", "high"].includes(value), "validator"),
          description: "WebGL rendering quality level",
          category: "performance"
        }
      };
      __name(validateSetting, "validateSetting");
      __name(parseSetting, "parseSetting");
      __name(serializeSetting, "serializeSetting");
      __name(getDefaultValue, "getDefaultValue");
      __name(getAllSettingKeys, "getAllSettingKeys");
      __name(isValidSettingKey, "isValidSettingKey");
    }
  });

  // src-js/config/typedSettingsManager.ts
  var _TypedSettingsManager, TypedSettingsManager;
  var init_typedSettingsManager = __esm({
    "src-js/config/typedSettingsManager.ts"() {
      "use strict";
      init_settingsSchema();
      _TypedSettingsManager = class _TypedSettingsManager {
        constructor(storage) {
          this.changeListeners = /* @__PURE__ */ new Set();
          this.cache = /* @__PURE__ */ new Map();
          this.storage = storage;
        }
        /**
         * Get a setting value with full type safety
         * Automatically parses and validates the stored value
         */
        get(key) {
          if (this.cache.has(key)) {
            return this.cache.get(key);
          }
          const metadata = SETTINGS_METADATA[key];
          const rawValue = this.storage.get(key);
          if (rawValue === null || rawValue === void 0) {
            const defaultValue = metadata.defaultValue;
            this.cache.set(key, defaultValue);
            return defaultValue;
          }
          const parsedValue = parseSetting(key, rawValue);
          if (parsedValue === null) {
            console.warn(`[TypedSettingsManager] Invalid stored value for ${key}: "${rawValue}", using default`);
            const defaultValue = metadata.defaultValue;
            this.cache.set(key, defaultValue);
            return defaultValue;
          }
          this.cache.set(key, parsedValue);
          return parsedValue;
        }
        /**
         * Set a setting value with type safety and validation
         * Automatically serializes and validates the value
         */
        set(key, value) {
          if (!validateSetting(key, value)) {
            console.error(`[TypedSettingsManager] Invalid value for ${key}:`, value);
            return false;
          }
          const oldValue = this.cache.get(key) ?? this.get(key);
          const serializedValue = serializeSetting(key, value);
          const success = this.storage.set(key, serializedValue);
          if (success) {
            this.cache.set(key, value);
            const changeEvent = {
              settingKey: key,
              oldValue,
              newValue: value,
              timestamp: Date.now()
            };
            this.notifyChangeListeners(changeEvent);
          }
          return success;
        }
        /**
         * Get multiple settings at once
         */
        getMultiple(keys) {
          const result = {};
          for (const key of keys) {
            result[key] = this.get(key);
          }
          return result;
        }
        /**
         * Set multiple settings at once
         */
        setMultiple(settings2) {
          const results = {};
          for (const [key, value] of Object.entries(settings2)) {
            if (isValidSettingKey(key)) {
              results[key] = this.set(key, value);
            }
          }
          return results;
        }
        /**
         * Get all settings with their current values
         */
        getAllSettings() {
          const result = {};
          for (const key of getAllSettingKeys()) {
            result[key] = this.get(key);
          }
          return result;
        }
        /**
         * Reset a setting to its default value
         */
        reset(key) {
          const defaultValue = getDefaultValue(key);
          return this.set(key, defaultValue);
        }
        /**
         * Reset all settings to their default values
         */
        resetAll() {
          const results = {};
          for (const key of getAllSettingKeys()) {
            results[key] = this.reset(key);
          }
          return results;
        }
        /**
         * Check if a setting exists in storage (has been set by user)
         */
        exists(key) {
          return this.storage.get(key) !== null;
        }
        /**
         * Remove a setting from storage (will fall back to default)
         */
        remove(key) {
          const success = this.storage.remove(key);
          if (success) {
            this.cache.delete(key);
          }
          return success;
        }
        /**
         * Clear the internal cache (forces re-reading from storage)
         */
        clearCache() {
          this.cache.clear();
        }
        /**
         * Add a change listener
         */
        onChange(listener) {
          this.changeListeners.add(listener);
        }
        /**
         * Remove a change listener
         */
        offChange(listener) {
          this.changeListeners.delete(listener);
        }
        /**
         * Notify all change listeners
         */
        notifyChangeListeners(event) {
          for (const listener of this.changeListeners) {
            try {
              listener(event);
            } catch (error) {
              console.error("[TypedSettingsManager] Error in change listener:", error);
            }
          }
        }
        /**
         * Validate all stored settings and report issues
         */
        validateAllSettings() {
          const result = {
            valid: 0,
            invalid: [],
            missing: []
          };
          for (const key of getAllSettingKeys()) {
            const rawValue = this.storage.get(key);
            if (rawValue === null) {
              result.missing.push({
                key,
                usingDefault: getDefaultValue(key)
              });
              continue;
            }
            const parsedValue = parseSetting(key, rawValue);
            if (parsedValue === null) {
              result.invalid.push({
                key,
                value: rawValue,
                error: "Failed to parse or validate value"
              });
            } else {
              result.valid++;
            }
          }
          return result;
        }
        /**
         * Export settings as a JSON object
         */
        export() {
          return this.getAllSettings();
        }
        /**
         * Import settings from a JSON object
         */
        import(settings2) {
          const result = {
            imported: 0,
            failed: []
          };
          for (const [key, value] of Object.entries(settings2)) {
            if (!isValidSettingKey(key)) {
              result.failed.push({ key, error: "Unknown setting key" });
              continue;
            }
            if (!validateSetting(key, value)) {
              result.failed.push({ key, error: "Invalid value for setting" });
              continue;
            }
            if (this.set(key, value)) {
              result.imported++;
            } else {
              result.failed.push({ key, error: "Failed to store setting" });
            }
          }
          return result;
        }
      };
      __name(_TypedSettingsManager, "TypedSettingsManager");
      TypedSettingsManager = _TypedSettingsManager;
    }
  });

  // src-js/config/storage/spicetifyStorage.ts
  function createSpicetifyStorage() {
    return new SpicetifyStorageAdapter();
  }
  var _SpicetifyStorageAdapter, SpicetifyStorageAdapter;
  var init_spicetifyStorage = __esm({
    "src-js/config/storage/spicetifyStorage.ts"() {
      "use strict";
      _SpicetifyStorageAdapter = class _SpicetifyStorageAdapter {
        constructor() {
          this._available = null;
        }
        /**
         * Check if Spicetify.LocalStorage is available
         */
        isAvailable() {
          if (this._available !== null) {
            return this._available;
          }
          try {
            this._available = typeof Spicetify !== "undefined" && typeof Spicetify.LocalStorage?.get === "function" && typeof Spicetify.LocalStorage?.set === "function";
            if (this._available) {
              Spicetify.LocalStorage.get("__test__");
            }
            return this._available;
          } catch (error) {
            console.warn("[SpicetifyStorageAdapter] Spicetify.LocalStorage not available:", error);
            this._available = false;
            return false;
          }
        }
        /**
         * Get value from Spicetify.LocalStorage
         */
        get(key) {
          if (!this.isAvailable()) {
            console.warn(`[SpicetifyStorageAdapter] Cannot get ${key}: Spicetify not available`);
            return null;
          }
          try {
            return Spicetify.LocalStorage.get(key);
          } catch (error) {
            console.error(`[SpicetifyStorageAdapter] Error reading key ${key}:`, error);
            return null;
          }
        }
        /**
         * Set value in Spicetify.LocalStorage
         */
        set(key, value) {
          if (!this.isAvailable()) {
            console.warn(`[SpicetifyStorageAdapter] Cannot set ${key}: Spicetify not available`);
            return false;
          }
          try {
            Spicetify.LocalStorage.set(key, value);
            return true;
          } catch (error) {
            console.error(`[SpicetifyStorageAdapter] Error setting key ${key}:`, error);
            return false;
          }
        }
        /**
         * Remove value from Spicetify.LocalStorage
         */
        remove(key) {
          if (!this.isAvailable()) {
            console.warn(`[SpicetifyStorageAdapter] Cannot remove ${key}: Spicetify not available`);
            return false;
          }
          try {
            if (typeof Spicetify.LocalStorage.remove === "function") {
              Spicetify.LocalStorage.remove(key);
            } else {
              Spicetify.LocalStorage.set(key, null);
            }
            return true;
          } catch (error) {
            console.error(`[SpicetifyStorageAdapter] Error removing key ${key}:`, error);
            return false;
          }
        }
        /**
         * Check storage health and connectivity
         */
        healthCheck() {
          const result = {
            available: false,
            readable: false,
            writable: false,
            issues: []
          };
          result.available = this.isAvailable();
          if (!result.available) {
            result.issues.push("Spicetify.LocalStorage not available");
            return result;
          }
          try {
            this.get("__health_check_read__");
            result.readable = true;
          } catch (error) {
            result.issues.push(`Read test failed: ${error}`);
          }
          try {
            const testKey = "__health_check_write__";
            const testValue = "test_" + Date.now();
            const writeSuccess = this.set(testKey, testValue);
            if (writeSuccess) {
              const readValue = this.get(testKey);
              if (readValue === testValue) {
                result.writable = true;
                this.remove(testKey);
              } else {
                result.issues.push("Write-read consistency test failed");
              }
            } else {
              result.issues.push("Write operation failed");
            }
          } catch (error) {
            result.issues.push(`Write test failed: ${error}`);
          }
          return result;
        }
        /**
         * Get diagnostic information
         */
        getDiagnostics() {
          const apiMethods = [];
          if (typeof Spicetify !== "undefined" && Spicetify.LocalStorage) {
            apiMethods.push(...Object.getOwnPropertyNames(Spicetify.LocalStorage));
          }
          return {
            spicetifyVersion: typeof Spicetify !== "undefined" ? Spicetify.version : void 0,
            apiMethods,
            testResults: this.healthCheck()
          };
        }
      };
      __name(_SpicetifyStorageAdapter, "SpicetifyStorageAdapter");
      SpicetifyStorageAdapter = _SpicetifyStorageAdapter;
      __name(createSpicetifyStorage, "createSpicetifyStorage");
    }
  });

  // src-js/config/storage/browserStorage.ts
  function createBrowserStorage(prefix) {
    return new BrowserStorageAdapter(prefix);
  }
  var _BrowserStorageAdapter, BrowserStorageAdapter;
  var init_browserStorage = __esm({
    "src-js/config/storage/browserStorage.ts"() {
      "use strict";
      _BrowserStorageAdapter = class _BrowserStorageAdapter {
        constructor(prefix = "sn-") {
          this.prefix = prefix;
        }
        /**
         * Get prefixed key for storage
         */
        getPrefixedKey(key) {
          return key.startsWith(this.prefix) ? key : `${this.prefix}${key}`;
        }
        /**
         * Check if localStorage is available
         */
        isAvailable() {
          try {
            return typeof localStorage !== "undefined" && localStorage !== null;
          } catch (error) {
            return false;
          }
        }
        /**
         * Get value from localStorage
         */
        get(key) {
          if (!this.isAvailable()) {
            console.warn(`[BrowserStorageAdapter] localStorage not available for key: ${key}`);
            return null;
          }
          try {
            return localStorage.getItem(this.getPrefixedKey(key));
          } catch (error) {
            console.error(`[BrowserStorageAdapter] Error reading key ${key}:`, error);
            return null;
          }
        }
        /**
         * Set value in localStorage
         */
        set(key, value) {
          if (!this.isAvailable()) {
            console.warn(`[BrowserStorageAdapter] localStorage not available for key: ${key}`);
            return false;
          }
          try {
            localStorage.setItem(this.getPrefixedKey(key), value);
            return true;
          } catch (error) {
            console.error(`[BrowserStorageAdapter] Error setting key ${key}:`, error);
            return false;
          }
        }
        /**
         * Remove value from localStorage
         */
        remove(key) {
          if (!this.isAvailable()) {
            console.warn(`[BrowserStorageAdapter] localStorage not available for key: ${key}`);
            return false;
          }
          try {
            localStorage.removeItem(this.getPrefixedKey(key));
            return true;
          } catch (error) {
            console.error(`[BrowserStorageAdapter] Error removing key ${key}:`, error);
            return false;
          }
        }
        /**
         * Get all keys with the configured prefix
         */
        getAllKeys() {
          if (!this.isAvailable()) {
            return [];
          }
          const keys = [];
          try {
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith(this.prefix)) {
                keys.push(key.substring(this.prefix.length));
              }
            }
          } catch (error) {
            console.error("[BrowserStorageAdapter] Error enumerating keys:", error);
          }
          return keys;
        }
        /**
         * Clear all keys with the configured prefix
         */
        clear() {
          if (!this.isAvailable()) {
            return false;
          }
          try {
            const keys = this.getAllKeys();
            for (const key of keys) {
              localStorage.removeItem(this.getPrefixedKey(key));
            }
            return true;
          } catch (error) {
            console.error("[BrowserStorageAdapter] Error clearing storage:", error);
            return false;
          }
        }
        /**
         * Get storage usage statistics
         */
        getUsageStats() {
          const stats = {
            totalKeys: 0,
            totalSize: 0,
            avgKeySize: 0
          };
          if (!this.isAvailable()) {
            return stats;
          }
          try {
            const keys = this.getAllKeys();
            stats.totalKeys = keys.length;
            for (const key of keys) {
              const value = this.get(key);
              if (value !== null) {
                stats.totalSize += key.length + value.length;
              }
            }
            stats.avgKeySize = stats.totalKeys > 0 ? stats.totalSize / stats.totalKeys : 0;
            if (typeof navigator !== "undefined" && "storage" in navigator && "estimate" in navigator.storage) {
              navigator.storage.estimate().then((estimate) => {
                if (estimate.quota !== void 0) {
                  stats.availableQuota = estimate.quota;
                }
              }).catch(() => {
              });
            }
          } catch (error) {
            console.error("[BrowserStorageAdapter] Error calculating usage stats:", error);
          }
          return stats;
        }
      };
      __name(_BrowserStorageAdapter, "BrowserStorageAdapter");
      BrowserStorageAdapter = _BrowserStorageAdapter;
      __name(createBrowserStorage, "createBrowserStorage");
    }
  });

  // src-js/config/settingsProvider.ts
  function getSettingsProvider() {
    if (!globalProvider) {
      globalProvider = new SettingsProvider();
    }
    return globalProvider;
  }
  function getSettings() {
    return getSettingsProvider().getSettings();
  }
  var _SettingsProvider, SettingsProvider, globalProvider, settings;
  var init_settingsProvider = __esm({
    "src-js/config/settingsProvider.ts"() {
      "use strict";
      init_typedSettingsManager();
      init_spicetifyStorage();
      init_browserStorage();
      _SettingsProvider = class _SettingsProvider {
        constructor(customStorage) {
          this.storageAdapter = customStorage || this.detectBestStorage();
          this.settingsManager = new TypedSettingsManager(this.storageAdapter);
        }
        /**
         * Detect and return the best available storage adapter
         */
        detectBestStorage() {
          const spicetifyAdapter = createSpicetifyStorage();
          const spicetifyHealth = spicetifyAdapter.healthCheck();
          if (spicetifyHealth.available && spicetifyHealth.readable && spicetifyHealth.writable) {
            console.log("[SettingsProvider] Using Spicetify storage adapter");
            return spicetifyAdapter;
          }
          const browserAdapter = createBrowserStorage();
          console.log("[SettingsProvider] Using browser storage adapter (localStorage)");
          return browserAdapter;
        }
        /**
         * Get the typed settings manager
         */
        getSettings() {
          return this.settingsManager;
        }
        /**
         * Get the underlying storage adapter
         */
        getStorage() {
          return this.storageAdapter;
        }
        /**
         * Get provider diagnostic information
         */
        getDiagnostics() {
          const storageType = this.storageAdapter instanceof SpicetifyStorageAdapter ? "spicetify" : this.storageAdapter instanceof BrowserStorageAdapter ? "browser" : "unknown";
          let storageHealth = null;
          if (this.storageAdapter instanceof SpicetifyStorageAdapter) {
            storageHealth = this.storageAdapter.healthCheck();
          }
          return {
            storageType,
            storageHealth,
            settingsValidation: this.settingsManager.validateAllSettings(),
            totalSettings: Object.keys(this.settingsManager.getAllSettings()).length
          };
        }
        /**
         * Migration helper: copy settings from legacy storage
         */
        async migrateFromLegacyStorage(legacySettings) {
          console.log("[SettingsProvider] Starting legacy settings migration...");
          const result = this.settingsManager.import(legacySettings);
          if (result.imported > 0) {
            console.log(`[SettingsProvider] Successfully migrated ${result.imported} settings`);
          }
          if (result.failed.length > 0) {
            console.warn(`[SettingsProvider] Failed to migrate ${result.failed.length} settings:`, result.failed);
          }
          return {
            migrated: result.imported,
            failed: result.failed
          };
        }
        /**
         * Health check for the entire settings system
         */
        healthCheck() {
          const diagnostics = this.getDiagnostics();
          const validation = diagnostics.settingsValidation;
          const result = {
            overall: "healthy",
            storage: {
              type: diagnostics.storageType,
              available: true,
              issues: []
            },
            settings: {
              valid: validation.valid,
              invalid: validation.invalid.length,
              missing: validation.missing.length
            },
            recommendations: []
          };
          if (diagnostics.storageHealth) {
            result.storage.available = diagnostics.storageHealth.available;
            if (diagnostics.storageHealth.issues) {
              result.storage.issues = diagnostics.storageHealth.issues;
            }
          }
          if (!result.storage.available || result.storage.issues.length > 0) {
            result.overall = "unhealthy";
            result.recommendations.push("Storage system needs attention");
          } else if (result.settings.invalid > 0) {
            result.overall = "degraded";
            result.recommendations.push("Some settings have invalid values");
          } else if (result.settings.missing > 5) {
            result.overall = "degraded";
            result.recommendations.push("Many settings are using defaults");
          }
          if (result.settings.invalid > 0) {
            result.recommendations.push("Run settings validation and repair");
          }
          if (diagnostics.storageType === "browser") {
            result.recommendations.push("Consider using in Spicetify environment for better integration");
          }
          return result;
        }
      };
      __name(_SettingsProvider, "SettingsProvider");
      SettingsProvider = _SettingsProvider;
      globalProvider = null;
      __name(getSettingsProvider, "getSettingsProvider");
      __name(getSettings, "getSettings");
      settings = {
        get: /* @__PURE__ */ __name((key) => getSettings().get(key), "get"),
        set: /* @__PURE__ */ __name((key, value) => getSettings().set(key, value), "set"),
        reset: /* @__PURE__ */ __name((key) => getSettings().reset(key), "reset"),
        onChange: /* @__PURE__ */ __name((listener) => getSettings().onChange(listener), "onChange"),
        export: /* @__PURE__ */ __name(() => getSettings().export(), "export"),
        import: /* @__PURE__ */ __name((settings2) => getSettings().import(settings2), "import")
      };
    }
  });

  // src-js/config/index.ts
  var init_config = __esm({
    "src-js/config/index.ts"() {
      "use strict";
      init_coreTheme();
      init_harmonicModes();
      init_artisticProfiles();
      init_performanceProfiles();
      init_settingKeys();
      init_typedSettingsManager();
      init_settingsSchema();
      init_settingsProvider();
      init_spicetifyStorage();
      init_browserStorage();
      init_config();
    }
  });

  // src-js/config/globalConfig.ts
  var HARMONIC_MODES2, ARTISTIC_MODE_PROFILES2, ADVANCED_SYSTEM_CONFIG;
  var init_globalConfig = __esm({
    "src-js/config/globalConfig.ts"() {
      "use strict";
      init_config();
      init_harmonicModes();
      init_artisticProfiles();
      init_performanceProfiles();
      HARMONIC_MODES2 = HARMONIC_MODES;
      ARTISTIC_MODE_PROFILES2 = ARTISTIC_MODE_PROFILES;
      ADVANCED_SYSTEM_CONFIG = {
        enableDebug: true,
        enableContextualIntelligence: true,
        paletteSystem: "catppuccin",
        // Default to maintain compatibility
        performanceProfiles: PERFORMANCE_PROFILES,
        // Enhanced logging configuration
        logging: DEFAULT_LOGGING_CONFIG,
        healthCheckInterval: 1e4,
        visual: {
          lightweightParticleSystem: { mode: "artist-vision" },
          spatialNexusSystem: { mode: "artist-vision" },
          dataGlyphSystem: { mode: "artist-vision" },
          beatSyncVisualSystem: { mode: "artist-vision" },
          behavioralPredictionEngine: { mode: "artist-vision" },
          predictiveMaterializationSystem: { mode: "artist-vision" },
          sidebarVisualStateSystem: { mode: "artist-vision" }
        },
        enableColorExtraction: true,
        enableMusicAnalysis: true,
        enableAdvancedSync: true,
        // NEW: Music-driven visual intensity
        musicModulationIntensity: 0.4,
        // Increased for dynamic gradient responsiveness
        // Active artistic mode for UX / visual presets
        artisticMode: "artist-vision",
        // "corporate-safe" | "artist-vision" | "advanced-maximum"
        // Context-bound method references for external calling
        boundGetCurrentMultipliers: null,
        boundGetCurrentFeatures: null,
        boundGetCurrentPerformanceSettings: null,
        // Pending artistic mode for deferred application
        _pendingArtisticMode: null,
        // Initialize bound methods to preserve context
        init() {
          this.boundGetCurrentMultipliers = this.getCurrentMultipliers.bind(this);
          this.boundGetCurrentFeatures = this.getCurrentFeatures.bind(this);
          this.boundGetCurrentPerformanceSettings = this.getCurrentPerformanceSettings.bind(this);
          const needsPreferenceLoad = !this.artisticMode || !this.paletteSystem;
          if (needsPreferenceLoad) {
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] Loading preferences (current: artistic=${this.artisticMode}, palette=${this.paletteSystem})`
              );
            }
            this.loadArtisticPreference();
          } else if (this.enableDebug) {
            console.log(
              `\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] Skipping preference load (current: artistic=${this.artisticMode}, palette=${this.paletteSystem})`
            );
          }
          if (this._pendingArtisticMode && this.isFullyInitialized()) {
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] Applying pending artistic mode: ${this._pendingArtisticMode}`
              );
            }
            this.setArtisticMode(this._pendingArtisticMode);
            this._pendingArtisticMode = null;
          }
          if (this.enableDebug) {
            console.log(
              "\u{1F527} [ADVANCED_SYSTEM_CONFIG] Initialized with context-bound methods"
            );
          }
          return this;
        },
        currentColorHarmonyMode: "analogous-flow",
        colorHarmonyBaseColor: null,
        colorHarmonyIntensity: 0.85,
        // Enhanced for cinematic gradient harmonies
        colorHarmonyEvolution: true,
        // Music sync configuration imported from modular harmonic modes
        musicVisualSync: {
          ...MUSIC_VISUAL_SYNC,
          enhancedBPM: ENHANCED_BPM_CONFIG
        },
        // Enhanced: Get current mode profile with full Year3000 parameters
        getCurrentModeProfile() {
          const mode = this.artisticMode || "artist-vision";
          return ARTISTIC_MODE_PROFILES2[mode] || ARTISTIC_MODE_PROFILES2["artist-vision"];
        },
        // Enhanced: Get current multipliers from active mode profile
        getCurrentMultipliers() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[ADVANCED_SYSTEM_CONFIG] getCurrentModeProfile method not available, using fallback multipliers"
              );
              return this["artisticMultipliers"];
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.multipliers) {
              console.warn(
                "[ADVANCED_SYSTEM_CONFIG] Invalid profile or missing multipliers, using fallback"
              );
              return this["artisticMultipliers"];
            }
            return currentProfile.multipliers;
          } catch (error) {
            console.error("[ADVANCED_SYSTEM_CONFIG] Error in getCurrentMultipliers:", error);
            return this["artisticMultipliers"];
          }
        },
        // Enhanced: Get current features from active mode profile
        getCurrentFeatures() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[ADVANCED_SYSTEM_CONFIG] getCurrentModeProfile method not available, using fallback features"
              );
              return {
                enableAdvancedEffects: true,
                enableHarmony: true,
                beatSync: true,
                colorHarmony: true
              };
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.features) {
              console.warn(
                "[ADVANCED_SYSTEM_CONFIG] Invalid profile or missing features, using fallback"
              );
              return {
                enableAdvancedEffects: true,
                enableHarmony: true,
                beatSync: true,
                colorHarmony: true
              };
            }
            return currentProfile.features;
          } catch (error) {
            console.error("[ADVANCED_SYSTEM_CONFIG] Error in getCurrentFeatures:", error);
            return {
              enableAdvancedEffects: true,
              enableHarmony: true,
              beatSync: true,
              colorHarmony: true
            };
          }
        },
        // Enhanced: Get current performance settings from active mode profile
        getCurrentPerformanceSettings() {
          try {
            if (typeof this.getCurrentModeProfile !== "function") {
              console.warn(
                "[ADVANCED_SYSTEM_CONFIG] getCurrentModeProfile method not available, using fallback performance settings"
              );
              return {
                maxParticles: 20,
                animationThrottle: 16,
                enableGPUAcceleration: true,
                reducedMotion: false
              };
            }
            const currentProfile = this.getCurrentModeProfile();
            if (!currentProfile || !currentProfile.performance) {
              console.warn(
                "[ADVANCED_SYSTEM_CONFIG] Invalid profile or missing performance settings, using fallback"
              );
              return {
                maxParticles: 20,
                animationThrottle: 16,
                enableGPUAcceleration: true,
                reducedMotion: false
              };
            }
            return currentProfile.performance;
          } catch (error) {
            console.error(
              "[ADVANCED_SYSTEM_CONFIG] Error in getCurrentPerformanceSettings:",
              error
            );
            return {
              maxParticles: 20,
              animationThrottle: 16,
              enableGPUAcceleration: true,
              reducedMotion: false
            };
          }
        },
        // Check if ADVANCED_SYSTEM_CONFIG is fully initialized with all required methods
        isFullyInitialized() {
          const requiredMethods = [
            "setArtisticMode",
            "getCurrentModeProfile",
            "getCurrentMultipliers",
            "getCurrentFeatures",
            "getCurrentPerformanceSettings"
          ];
          return requiredMethods.every(
            (method) => typeof this[method] === "function"
          );
        },
        // Safe setArtisticMode wrapper that validates state
        safeSetArtisticMode(mode) {
          if (!this.isFullyInitialized()) {
            console.warn(
              "[ADVANCED_SYSTEM_CONFIG] Not fully initialized, deferring artistic mode change"
            );
            this._pendingArtisticMode = mode;
            return false;
          }
          return this.setArtisticMode(mode);
        },
        setArtisticMode(mode) {
          const validModes = Object.keys(ARTISTIC_MODE_PROFILES2);
          if (validModes.includes(mode)) {
            const previousMode = this.artisticMode;
            this.artisticMode = mode;
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] Artistic mode changed: ${previousMode} \u2192 ${mode}`
              );
              console.log(
                `\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] New profile:`,
                this.getCurrentModeProfile()
              );
            }
            if (typeof document !== "undefined") {
              document.dispatchEvent(
                new CustomEvent("year3000ArtisticModeChanged", {
                  detail: {
                    previousMode,
                    newMode: mode,
                    profile: this.getCurrentModeProfile()
                  }
                })
              );
            }
            if (typeof globalThis.year3000System !== "undefined" && globalThis.year3000System.setGradientParameters) {
              globalThis.year3000System.setGradientParameters(
                document.documentElement
              );
            }
            return true;
          }
          console.warn(
            `[ADVANCED_SYSTEM_CONFIG] Invalid artistic mode: ${mode}. Valid modes:`,
            validModes
          );
          return false;
        },
        // ===========================================
        // 🔧 LOGGING & PERFORMANCE CONFIGURATION HELPERS
        // ===========================================
        // Set logging level for all Year 3000 systems
        setLoggingLevel(level) {
          const validLevels = ["off", "error", "warn", "info", "debug", "verbose"];
          if (validLevels.includes(level)) {
            this.logging.level = level;
            if (level !== "off") {
              console.log(`\u{1F527} [ADVANCED_SYSTEM_CONFIG] Logging level set to: ${level}`);
            }
            return true;
          }
          console.warn(
            `[ADVANCED_SYSTEM_CONFIG] Invalid logging level: ${level}. Valid levels:`,
            validLevels
          );
          return false;
        },
        // Disable performance warnings (useful for production or when performance is acceptable)
        disablePerformanceWarnings() {
          this.logging.performance.enableFrameBudgetWarnings = false;
          console.log("\u{1F527} [ADVANCED_SYSTEM_CONFIG] Performance warnings disabled");
        },
        // Enable performance warnings
        enablePerformanceWarnings() {
          this.logging.performance.enableFrameBudgetWarnings = true;
          console.log("\u{1F527} [ADVANCED_SYSTEM_CONFIG] Performance warnings enabled");
        },
        // Set performance warning throttle interval (ms)
        setPerformanceWarningThrottle(intervalMs) {
          if (typeof intervalMs === "number" && intervalMs >= 0) {
            this.logging.performance.throttleInterval = intervalMs;
            this.logging.performance.throttleWarnings = intervalMs > 0;
            console.log(
              `\u{1F527} [ADVANCED_SYSTEM_CONFIG] Performance warning throttle set to: ${intervalMs}ms`
            );
            return true;
          }
          console.warn(
            "[ADVANCED_SYSTEM_CONFIG] Invalid throttle interval. Must be a non-negative number."
          );
          return false;
        },
        // Quick setup for different environments
        setupForProduction() {
          this.setLoggingLevel("warn");
          this.disablePerformanceWarnings();
          this.logging.performance.enableAdaptiveDegradation = true;
          console.log("\u{1F527} [ADVANCED_SYSTEM_CONFIG] Configured for production environment");
        },
        setupForDevelopment() {
          this.setLoggingLevel("debug");
          this.enablePerformanceWarnings();
          this.setPerformanceWarningThrottle(2e3);
          this.logging.performance.enableAdaptiveDegradation = true;
          console.log("\u{1F527} [ADVANCED_SYSTEM_CONFIG] Configured for development environment");
        },
        setupForDebugging() {
          this.setLoggingLevel("verbose");
          this.enablePerformanceWarnings();
          this.setPerformanceWarningThrottle(500);
          this.logging.performance.enableAdaptiveDegradation = false;
          console.log("\u{1F527} [ADVANCED_SYSTEM_CONFIG] Configured for debugging environment");
        },
        // Validate configuration health and functionality
        validateConfigHealth() {
          const detailedIssues = [];
          const healthReport = {
            healthy: true,
            system: "AdvancedSystemConfig",
            details: "Configuration health validation",
            issues: [],
            metrics: {}
          };
          const configKeys = Object.keys(this);
          const functionProperties = configKeys.filter(
            (key) => typeof this[key] === "function"
          );
          for (const key of functionProperties) {
            if (!this.hasOwnProperty(key)) {
              detailedIssues.push({
                key: String(key),
                severity: "warning",
                message: `Method ${key} is not an own property, may indicate prototype chain issues.`
              });
            }
          }
          const checkProfile = /* @__PURE__ */ __name((mode) => {
            if (!ARTISTIC_MODE_PROFILES2[mode]) {
              detailedIssues.push({
                key: `artisticMode:${mode}`,
                severity: "critical",
                message: `Artistic mode profile for '${mode}' is missing.`
              });
              return;
            }
            healthReport.metrics[`${mode}Profile`] = "ok";
          }, "checkProfile");
          checkProfile(this.artisticMode);
          checkProfile("artist-vision");
          checkProfile("corporate-safe");
          if (detailedIssues.length > 0) {
            healthReport.healthy = false;
            healthReport.issues = detailedIssues.map(
              (issue) => `[${issue.severity.toUpperCase()}] ${issue.key}: ${issue.message}`
            );
            healthReport.details = detailedIssues.some((i) => i.severity === "critical") ? "Critical configuration issues detected" : "Configuration issues detected";
          }
          if (this.enableDebug) {
            console.log("[ADVANCED_SYSTEM_CONFIG] Health Check Report:", healthReport);
          }
          return healthReport;
        },
        loadArtisticPreference() {
          try {
            const saved = settings.get("sn-artistic-mode");
            const validModes = Object.keys(ARTISTIC_MODE_PROFILES2);
            if (saved && validModes.includes(String(saved)) && this.artisticMode !== saved) {
              this.artisticMode = String(saved);
              if (this.enableDebug) {
                console.log(`\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] Updated artistic mode from storage: ${saved}`);
              }
            } else if (!saved && this.artisticMode !== "artist-vision") {
              this.artisticMode = "artist-vision";
              if (this.enableDebug) {
                console.log(`\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] Reset artistic mode to default: artist-vision`);
              }
            }
            const savedPalette = settings.get("sn-palette-system");
            const validPaletteSystems = ["catppuccin", "year3000"];
            if (savedPalette && validPaletteSystems.includes(String(savedPalette)) && this.paletteSystem !== savedPalette) {
              this.paletteSystem = String(savedPalette);
              if (this.enableDebug) {
                console.log(`\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] Updated palette system from storage: ${savedPalette}`);
              }
            } else if (!savedPalette && this.paletteSystem !== "catppuccin") {
              this.paletteSystem = "catppuccin";
              if (this.enableDebug) {
                console.log(`\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] Reset palette system to default: catppuccin`);
              }
            }
            if (this.enableDebug) {
              console.log(
                `\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] Current artistic preference: ${this.artisticMode}`
              );
              console.log(
                `\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] Current palette system: ${this.paletteSystem}`
              );
            }
          } catch (error) {
            if (this.enableDebug) {
              console.warn(`\u{1F3A8} [ADVANCED_SYSTEM_CONFIG] Failed to load preferences:`, error);
            }
            this.artisticMode = "artist-vision";
            this.paletteSystem = "catppuccin";
          }
        }
      };
      if (typeof ADVANCED_SYSTEM_CONFIG.init === "function") {
        ADVANCED_SYSTEM_CONFIG.init();
      }
    }
  });

  // src-js/debug/UnifiedDebugManager.ts
  var _UnifiedDebugManager, UnifiedDebugManager, Y3KDebug, UnifiedDebugManager_default;
  var init_UnifiedDebugManager = __esm({
    "src-js/debug/UnifiedDebugManager.ts"() {
      "use strict";
      init_globalConfig();
      _UnifiedDebugManager = class _UnifiedDebugManager {
        constructor(config = {}) {
          this.registeredSystems = /* @__PURE__ */ new Map();
          this.reportHistory = [];
          this.monitoring = false;
          this.monitoringInterval = null;
          this.performanceMetrics = /* @__PURE__ */ new Map();
          this.config = {
            enableConsoleReporting: ADVANCED_SYSTEM_CONFIG.enableDebug,
            reportingInterval: 3e4,
            // 30 seconds
            enablePerformanceTracking: true,
            enableSystemHealthMonitoring: true,
            maxHistoryEntries: 50,
            verboseLogging: ADVANCED_SYSTEM_CONFIG.enableDebug,
            ...config
          };
          if (this.config.enableConsoleReporting) {
            console.log("\u{1F527} [UnifiedDebugManager] Debug system initialized");
          }
        }
        static getInstance(config) {
          if (!_UnifiedDebugManager.instance) {
            _UnifiedDebugManager.instance = new _UnifiedDebugManager(config);
          }
          return _UnifiedDebugManager.instance;
        }
        // =========================================================================
        // SYSTEM REGISTRATION & MANAGEMENT
        // =========================================================================
        /**
         * Register a system for debug monitoring
         */
        registerSystem(name, system, type = "unified") {
          const debugInfo = {
            name,
            type,
            initialized: system.initialized || false,
            healthy: true,
            lastUpdate: Date.now(),
            issues: [],
            metrics: {}
          };
          this.registeredSystems.set(name, debugInfo);
          if (this.config.verboseLogging) {
            console.log(
              `\u{1F527} [UnifiedDebugManager] Registered system: ${name} (${type})`
            );
          }
          if (this.registeredSystems.size === 1 && !this.monitoring) {
            this.startMonitoring();
          }
        }
        /**
         * Unregister a system from debug monitoring
         */
        unregisterSystem(name) {
          this.registeredSystems.delete(name);
          this.performanceMetrics.delete(name);
          if (this.config.verboseLogging) {
            console.log(`\u{1F527} [UnifiedDebugManager] Unregistered system: ${name}`);
          }
          if (this.registeredSystems.size === 0) {
            this.stopMonitoring();
          }
        }
        /**
         * Update system debug information
         */
        updateSystem(name, updates) {
          const system = this.registeredSystems.get(name);
          if (!system) return;
          Object.assign(system, updates, { lastUpdate: Date.now() });
          this.registeredSystems.set(name, system);
        }
        /**
         * Record performance metric for a system
         */
        recordMetric(systemName, metricName, value) {
          if (!this.config.enablePerformanceTracking) return;
          const system = this.registeredSystems.get(systemName);
          if (system) {
            system.metrics[metricName] = value;
            system.lastUpdate = Date.now();
          }
          const key = `${systemName}_${metricName}`;
          const history = this.performanceMetrics.get(key) || [];
          history.push(value);
          if (history.length > 100) {
            history.splice(0, history.length - 100);
          }
          this.performanceMetrics.set(key, history);
        }
        /**
         * Record system issue
         */
        recordIssue(systemName, issue) {
          const system = this.registeredSystems.get(systemName);
          if (system) {
            system.issues.push(issue);
            system.healthy = false;
            system.lastUpdate = Date.now();
            if (this.config.verboseLogging) {
              console.warn(`\u26A0\uFE0F [${systemName}] ${issue}`);
            }
          }
        }
        // =========================================================================
        // SYSTEM HEALTH CHECKING
        // =========================================================================
        /**
         * Perform health check on all registered systems
         */
        async performHealthCheck() {
          const timestamp = Date.now();
          const systemDetails = [];
          let healthySystems = 0;
          let totalIssues = 0;
          let totalFrameTime = 0;
          let totalMemory = 0;
          let frameTimeCount = 0;
          for (const [name, system] of this.registeredSystems) {
            try {
              let actualSystem = null;
              let dynamicInitializedStatus = system.initialized;
              const year3000System = globalThis.year3000System;
              if (year3000System) {
                if (year3000System.facadeCoordinator) {
                  try {
                    actualSystem = year3000System.facadeCoordinator.getCachedNonVisualSystem?.(
                      name
                    ) || await year3000System.facadeCoordinator.getNonVisualSystem?.(
                      name
                    );
                  } catch (e) {
                  }
                  if (!actualSystem) {
                    try {
                      actualSystem = year3000System.facadeCoordinator.getVisualSystem?.(name);
                    } catch (e) {
                    }
                  }
                }
                if (!actualSystem) {
                  const camelCaseName = name.charAt(0).toLowerCase() + name.slice(1);
                  actualSystem = year3000System[camelCaseName] || year3000System[name];
                }
              }
              if (!actualSystem) {
                actualSystem = globalThis[name];
              }
              if (actualSystem) {
                if (typeof actualSystem.initialized === "boolean") {
                  dynamicInitializedStatus = actualSystem.initialized;
                } else if (typeof actualSystem.isInitialized === "function") {
                  try {
                    dynamicInitializedStatus = await actualSystem.isInitialized();
                  } catch (e) {
                  }
                } else if (typeof actualSystem.getInitializationStatus === "function") {
                  try {
                    const status = await actualSystem.getInitializationStatus();
                    dynamicInitializedStatus = status?.initialized ?? status?.ready ?? false;
                  } catch (e) {
                  }
                }
              }
              const oldStatus = system.initialized;
              system.initialized = dynamicInitializedStatus;
              system.lastUpdate = timestamp;
              if (this.config.verboseLogging && oldStatus !== dynamicInitializedStatus) {
                console.log(
                  `\u{1F527} [UnifiedDebugManager] ${name} initialization status updated: ${oldStatus} \u2192 ${dynamicInitializedStatus}`
                );
              }
              if (actualSystem && typeof actualSystem.healthCheck === "function") {
                const healthResult = await actualSystem.healthCheck();
                system.healthy = healthResult.healthy ?? healthResult.ok;
                if (!healthResult.ok) {
                  system.issues = [healthResult.details || "Health check failed"];
                } else {
                  system.issues = [];
                }
              } else {
                system.healthy = dynamicInitializedStatus;
                if (!dynamicInitializedStatus) {
                  system.issues = ["System not initialized"];
                } else {
                  system.issues = [];
                }
              }
              if (system.frameTime) {
                totalFrameTime += system.frameTime;
                frameTimeCount++;
              }
              if (system.memoryUsage) {
                totalMemory += system.memoryUsage;
              }
              if (system.healthy) {
                healthySystems++;
              } else {
                totalIssues += system.issues.length;
              }
              systemDetails.push({ ...system });
            } catch (error) {
              system.healthy = false;
              system.issues = [`Health check error: ${error}`];
              totalIssues++;
              if (this.config.verboseLogging) {
                console.error(`\u274C [${name}] Health check failed:`, error);
              }
            }
          }
          const healthPercentage = this.registeredSystems.size > 0 ? healthySystems / this.registeredSystems.size : 1;
          let overallHealth;
          if (healthPercentage >= 0.9) overallHealth = "excellent";
          else if (healthPercentage >= 0.7) overallHealth = "good";
          else if (healthPercentage >= 0.5) overallHealth = "degraded";
          else overallHealth = "critical";
          if (this.config.verboseLogging) {
            console.log(
              "\u{1F527} [UnifiedDebugManager] System initialization status for recommendations:"
            );
            for (const system of systemDetails) {
              console.log(
                `   ${system.name}: ${system.initialized ? "\u2705" : "\u274C"} initialized`
              );
            }
          }
          const recommendations = this.generateRecommendations(
            systemDetails,
            overallHealth
          );
          const report = {
            timestamp,
            overallHealth,
            systemCount: this.registeredSystems.size,
            healthySystems,
            totalIssues,
            systemDetails,
            performance: {
              avgFrameTime: frameTimeCount > 0 ? totalFrameTime / frameTimeCount : 0,
              totalMemoryMB: totalMemory,
              cpuUsageEstimate: this.estimateCPUUsage()
            },
            recommendations
          };
          this.reportHistory.push(report);
          if (this.reportHistory.length > this.config.maxHistoryEntries) {
            this.reportHistory.splice(
              0,
              this.reportHistory.length - this.config.maxHistoryEntries
            );
          }
          return report;
        }
        /**
         * Generate actionable recommendations based on system state
         */
        generateRecommendations(systems, overallHealth) {
          const recommendations = [];
          if (overallHealth === "critical") {
            recommendations.push(
              "\u{1F6A8} Critical: Multiple systems failing - check console for errors"
            );
          }
          const uninitializedSystems = systems.filter((s) => !s.initialized);
          if (uninitializedSystems.length > 0) {
            recommendations.push(
              `\u26A0\uFE0F ${uninitializedSystems.length} systems not initialized: ${uninitializedSystems.map((s) => s.name).join(", ")}`
            );
          }
          const highFrameTimes = systems.filter(
            (s) => s.frameTime && s.frameTime > 16.67
          );
          if (highFrameTimes.length > 0) {
            recommendations.push(
              `\u{1F40C} Performance: ${highFrameTimes.length} systems exceeding 16.67ms frame time`
            );
          }
          const memoryIssues = systems.filter(
            (s) => s.memoryUsage && s.memoryUsage > 50
          );
          if (memoryIssues.length > 0) {
            recommendations.push(
              `\u{1F4BE} Memory: ${memoryIssues.length} systems using >50MB`
            );
          }
          if (recommendations.length === 0) {
            recommendations.push("\u2705 All systems operating within normal parameters");
          }
          return recommendations;
        }
        /**
         * Estimate CPU usage based on frame times and system activity
         */
        estimateCPUUsage() {
          let totalFrameTime = 0;
          let count = 0;
          for (const system of this.registeredSystems.values()) {
            if (system.frameTime) {
              totalFrameTime += system.frameTime;
              count++;
            }
          }
          if (count === 0) return 0;
          const avgFrameTime = totalFrameTime / count;
          return Math.min(100, avgFrameTime / 16.67 * 5);
        }
        // =========================================================================
        // MONITORING & REPORTING
        // =========================================================================
        /**
         * Start automatic monitoring
         */
        startMonitoring() {
          if (this.monitoring) return;
          this.monitoring = true;
          this.monitoringInterval = window.setInterval(() => {
            this.performHealthCheck().then((report) => {
              if (this.config.enableConsoleReporting) {
                this.logHealthReport(report);
              }
            });
          }, this.config.reportingInterval);
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Monitoring started");
          }
        }
        /**
         * Stop automatic monitoring
         */
        stopMonitoring() {
          if (!this.monitoring) return;
          this.monitoring = false;
          if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
          }
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Monitoring stopped");
          }
        }
        /**
         * Log health report to console in a readable format
         */
        logHealthReport(report) {
          if (!report) {
            this.performHealthCheck().then((r) => this.logHealthReport(r));
            return;
          }
          const statusEmoji = {
            excellent: "\u{1F31F}",
            good: "\u2705",
            degraded: "\u26A0\uFE0F",
            critical: "\u{1F6A8}"
          }[report.overallHealth];
          console.group(
            `${statusEmoji} Year 3000 System Health Report - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}`
          );
          console.log(
            `\u{1F4CA} Overall: ${report.overallHealth.toUpperCase()} (${report.healthySystems}/${report.systemCount} healthy)`
          );
          if (report.totalIssues > 0) {
            console.log(`\u{1F6A8} Issues: ${report.totalIssues} total`);
          }
          console.log(
            `\u26A1 Performance: ${report.performance.avgFrameTime.toFixed(
              2
            )}ms avg frame, ${report.performance.totalMemoryMB.toFixed(
              1
            )}MB memory, ~${report.performance.cpuUsageEstimate.toFixed(1)}% CPU`
          );
          if (report.systemDetails.length > 0) {
            console.group("\u{1F527} System Details");
            report.systemDetails.forEach((system) => {
              const emoji = system.healthy ? "\u2705" : "\u274C";
              const frameInfo = system.frameTime ? ` (${system.frameTime.toFixed(2)}ms)` : "";
              console.log(`${emoji} ${system.name} [${system.type}]${frameInfo}`);
              if (system.issues.length > 0) {
                system.issues.forEach((issue) => {
                  console.log(`    \u26A0\uFE0F ${issue}`);
                });
              }
            });
            console.groupEnd();
          }
          if (report.recommendations.length > 0) {
            console.group("\u{1F4A1} Recommendations");
            report.recommendations.forEach((rec) => console.log(`  ${rec}`));
            console.groupEnd();
          }
          console.groupEnd();
        }
        // =========================================================================
        // PUBLIC API & UTILITIES
        // =========================================================================
        /**
         * Get the latest debug report
         */
        getLatestReport() {
          return this.reportHistory[this.reportHistory.length - 1] || null;
        }
        /**
         * Get all report history
         */
        getReportHistory() {
          return [...this.reportHistory];
        }
        /**
         * Get system information
         */
        getSystemInfo(name) {
          return this.registeredSystems.get(name) || null;
        }
        /**
         * Get all registered systems
         */
        getAllSystems() {
          return Array.from(this.registeredSystems.values());
        }
        /**
         * Manual health check trigger
         */
        async checkHealth() {
          const report = await this.performHealthCheck();
          this.logHealthReport(report);
        }
        /**
         * Update debug configuration
         */
        updateConfig(config) {
          this.config = { ...this.config, ...config };
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] Configuration updated:", config);
          }
        }
        /**
         * Clear all data and reset
         */
        reset() {
          this.stopMonitoring();
          this.registeredSystems.clear();
          this.reportHistory = [];
          this.performanceMetrics.clear();
          if (this.config.verboseLogging) {
            console.log("\u{1F527} [UnifiedDebugManager] System reset");
          }
        }
        /**
         * Destroy the debug manager
         */
        destroy() {
          this.reset();
          _UnifiedDebugManager.instance = null;
        }
      };
      __name(_UnifiedDebugManager, "UnifiedDebugManager");
      UnifiedDebugManager = _UnifiedDebugManager;
      Y3KDebug = {
        debug: {
          log: /* @__PURE__ */ __name((component, message, ...args) => {
            if (ADVANCED_SYSTEM_CONFIG?.enableDebug) {
              console.log(`[${component}] ${message}`, ...args);
            }
          }, "log"),
          error: /* @__PURE__ */ __name((component, message, error) => {
            console.error(`[${component}] ${message}`, error);
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordIssue(
              component,
              `${message}${error ? `: ${error}` : ""}`
            );
          }, "error"),
          warn: /* @__PURE__ */ __name((component, message, ...args) => {
            console.warn(`[${component}] ${message}`, ...args);
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordIssue(component, message);
          }, "warn"),
          metric: /* @__PURE__ */ __name((system, metric, value) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.recordMetric(system, metric, value);
          }, "metric"),
          register: /* @__PURE__ */ __name((name, system, type) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.registerSystem(name, system, type);
          }, "register"),
          unregister: /* @__PURE__ */ __name((name) => {
            const debugManager = UnifiedDebugManager.getInstance();
            debugManager.unregisterSystem(name);
          }, "unregister"),
          checkHealth: /* @__PURE__ */ __name(() => {
            const debugManager = UnifiedDebugManager.getInstance();
            return debugManager.checkHealth();
          }, "checkHealth"),
          getReport: /* @__PURE__ */ __name(() => {
            const debugManager = UnifiedDebugManager.getInstance();
            return debugManager.getLatestReport();
          }, "getReport")
        }
      };
      if (typeof window !== "undefined") {
        window.UnifiedDebugManager = UnifiedDebugManager;
        window.Y3K = Y3KDebug;
        console.log("\u{1F527} [UnifiedDebugManager] Global debug interface available:");
        console.log("  Y3K.debug.checkHealth() - Check system health");
        console.log("  Y3K.debug.getReport() - Get latest debug report");
        console.log("  UnifiedDebugManager.getInstance() - Get debug manager");
      }
      UnifiedDebugManager_default = UnifiedDebugManager;
    }
  });

  // src-js/core/events/UnifiedEventBus.ts
  var _UnifiedEventBus, UnifiedEventBus, unifiedEventBus;
  var init_UnifiedEventBus = __esm({
    "src-js/core/events/UnifiedEventBus.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _UnifiedEventBus = class _UnifiedEventBus {
        constructor() {
          // Event subscriptions registry
          this.subscriptions = /* @__PURE__ */ new Map();
          // Event metrics and monitoring
          this.eventMetrics = {
            totalEvents: 0,
            totalSubscriptions: 0,
            activeSubscriptions: 0,
            eventsPerSecond: 0,
            topEvents: [],
            memoryUsage: 0
          };
          // Performance monitoring
          this.eventQueue = [];
          this.processingQueue = false;
          this.maxQueueSize = 1e3;
          // Cleanup management
          this.subscriptionCleanupInterval = null;
          this.metricsUpdateInterval = null;
          this.startMetricsMonitoring();
          this.startSubscriptionCleanup();
          Y3KDebug?.debug?.log("UnifiedEventBus", "Unified event bus initialized");
        }
        /**
         * Get singleton instance
         */
        static getInstance() {
          if (!_UnifiedEventBus.instance) {
            _UnifiedEventBus.instance = new _UnifiedEventBus();
          }
          return _UnifiedEventBus.instance;
        }
        /**
         * Subscribe to an event with type safety
         */
        subscribe(eventName, handler, subscriberName = "anonymous", options = {}) {
          const subscriptionId = this.generateSubscriptionId();
          if (!this.subscriptions.has(eventName)) {
            this.subscriptions.set(eventName, /* @__PURE__ */ new Map());
          }
          const subscription = {
            id: subscriptionId,
            eventName,
            handler,
            subscriberName,
            once: options.once || false,
            createdAt: Date.now(),
            triggerCount: 0
          };
          this.subscriptions.get(eventName).set(subscriptionId, subscription);
          this.eventMetrics.totalSubscriptions++;
          this.eventMetrics.activeSubscriptions++;
          Y3KDebug?.debug?.log(
            "UnifiedEventBus",
            `Subscription added: ${subscriberName} -> ${eventName}`,
            {
              subscriptionId,
              totalSubscriptions: this.eventMetrics.activeSubscriptions
            }
          );
          return subscriptionId;
        }
        /**
         * Subscribe to an event only once
         */
        once(eventName, handler, subscriberName = "anonymous") {
          return this.subscribe(eventName, handler, subscriberName, { once: true });
        }
        /**
         * Unsubscribe from an event
         */
        unsubscribe(subscriptionId) {
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            if (subscriptionMap.has(subscriptionId)) {
              const subscription = subscriptionMap.get(subscriptionId);
              subscriptionMap.delete(subscriptionId);
              if (subscriptionMap.size === 0) {
                this.subscriptions.delete(eventName);
              }
              this.eventMetrics.activeSubscriptions--;
              Y3KDebug?.debug?.log(
                "UnifiedEventBus",
                `Subscription removed: ${subscription.subscriberName} -> ${eventName}`,
                {
                  subscriptionId,
                  remainingSubscriptions: this.eventMetrics.activeSubscriptions
                }
              );
              return true;
            }
          }
          return false;
        }
        /**
         * Unsubscribe all events for a specific subscriber
         */
        unsubscribeAll(subscriberName) {
          let removedCount = 0;
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            const toRemove = Array.from(subscriptionMap.values()).filter(
              (sub) => sub.subscriberName === subscriberName
            );
            for (const subscription of toRemove) {
              subscriptionMap.delete(subscription.id);
              removedCount++;
              this.eventMetrics.activeSubscriptions--;
            }
            if (subscriptionMap.size === 0) {
              this.subscriptions.delete(eventName);
            }
          }
          if (removedCount > 0) {
            Y3KDebug?.debug?.log(
              "UnifiedEventBus",
              `Removed ${removedCount} subscriptions for: ${subscriberName}`
            );
          }
          return removedCount;
        }
        /**
         * Emit an event with type safety
         */
        async emit(eventName, data) {
          const timestamp = Date.now();
          if (this.processingQueue || this.eventQueue.length > 0) {
            if (this.eventQueue.length >= this.maxQueueSize) {
              Y3KDebug?.debug?.warn(
                "UnifiedEventBus",
                `Event queue full, dropping event: ${eventName}`
              );
              return;
            }
            this.eventQueue.push({ eventName, data, timestamp });
            this.processEventQueue();
            return;
          }
          await this.processEvent(eventName, data, timestamp);
        }
        /**
         * Emit an event synchronously (use sparingly)
         */
        emitSync(eventName, data) {
          const timestamp = Date.now();
          this.processEventSync(eventName, data, timestamp);
        }
        /**
         * Process a single event
         */
        async processEvent(eventName, data, timestamp) {
          const subscriptionMap = this.subscriptions.get(eventName);
          if (!subscriptionMap || subscriptionMap.size === 0) {
            return;
          }
          this.eventMetrics.totalEvents++;
          const handlers = [];
          const toRemove = [];
          for (const [subscriptionId, subscription] of subscriptionMap.entries()) {
            handlers.push({ subscription, handler: subscription.handler });
            if (subscription.once) {
              toRemove.push(subscriptionId);
            }
            subscription.lastTriggered = timestamp;
            subscription.triggerCount++;
          }
          const promises = handlers.map(async ({ subscription, handler }) => {
            try {
              await handler(data);
            } catch (error) {
              Y3KDebug?.debug?.error(
                "UnifiedEventBus",
                `Handler error in ${subscription.subscriberName} for ${eventName}:`,
                error
              );
              this.emitSync("system:error", {
                systemName: subscription.subscriberName,
                error: error instanceof Error ? error.message : "Unknown error",
                severity: "error",
                timestamp: Date.now()
              });
            }
          });
          await Promise.all(promises);
          for (const subscriptionId of toRemove) {
            subscriptionMap.delete(subscriptionId);
            this.eventMetrics.activeSubscriptions--;
          }
          if (subscriptionMap.size === 0) {
            this.subscriptions.delete(eventName);
          }
          Y3KDebug?.debug?.log("UnifiedEventBus", `Event processed: ${eventName}`, {
            handlerCount: handlers.length,
            processingTime: Date.now() - timestamp
          });
        }
        /**
         * Process event synchronously
         */
        processEventSync(eventName, data, timestamp) {
          const subscriptionMap = this.subscriptions.get(eventName);
          if (!subscriptionMap || subscriptionMap.size === 0) {
            return;
          }
          this.eventMetrics.totalEvents++;
          const toRemove = [];
          for (const [subscriptionId, subscription] of subscriptionMap.entries()) {
            try {
              subscription.handler(data);
              subscription.lastTriggered = timestamp;
              subscription.triggerCount++;
              if (subscription.once) {
                toRemove.push(subscriptionId);
              }
            } catch (error) {
              Y3KDebug?.debug?.error(
                "UnifiedEventBus",
                `Sync handler error in ${subscription.subscriberName} for ${eventName}:`,
                error
              );
            }
          }
          for (const subscriptionId of toRemove) {
            subscriptionMap.delete(subscriptionId);
            this.eventMetrics.activeSubscriptions--;
          }
          if (subscriptionMap.size === 0) {
            this.subscriptions.delete(eventName);
          }
        }
        /**
         * Process queued events
         */
        async processEventQueue() {
          if (this.processingQueue) return;
          this.processingQueue = true;
          while (this.eventQueue.length > 0) {
            const queueItem = this.eventQueue.shift();
            await this.processEvent(
              queueItem.eventName,
              queueItem.data,
              queueItem.timestamp
            );
          }
          this.processingQueue = false;
        }
        /**
         * Get current event metrics
         */
        getMetrics() {
          return { ...this.eventMetrics };
        }
        /**
         * Get all active subscriptions for debugging
         */
        getActiveSubscriptions() {
          const subscriptions = [];
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            for (const [subscriptionId, subscription] of subscriptionMap.entries()) {
              subscriptions.push({
                eventName,
                subscriberName: subscription.subscriberName,
                subscriptionId,
                createdAt: subscription.createdAt,
                triggerCount: subscription.triggerCount
              });
            }
          }
          return subscriptions.sort((a, b) => b.createdAt - a.createdAt);
        }
        /**
         * Start metrics monitoring
         */
        startMetricsMonitoring() {
          this.metricsUpdateInterval = window.setInterval(() => {
            this.updateMetrics();
          }, 5e3);
        }
        /**
         * Start subscription cleanup for abandoned subscriptions
         */
        startSubscriptionCleanup() {
          this.subscriptionCleanupInterval = window.setInterval(() => {
            this.cleanupAbandonedSubscriptions();
          }, 6e4);
        }
        /**
         * Update performance metrics
         */
        updateMetrics() {
          const now = Date.now();
          const recentEvents = this.eventMetrics.totalEvents;
          const eventCounts = /* @__PURE__ */ new Map();
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            let totalTriggers = 0;
            for (const subscription of subscriptionMap.values()) {
              totalTriggers += subscription.triggerCount;
            }
            eventCounts.set(eventName, totalTriggers);
          }
          this.eventMetrics.topEvents = Array.from(eventCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 10).map(([eventName, count]) => ({ eventName, count }));
          this.eventMetrics.memoryUsage = this.eventMetrics.activeSubscriptions * 256;
        }
        /**
         * Clean up abandoned subscriptions
         */
        cleanupAbandonedSubscriptions() {
          const cutoffTime = Date.now() - 3e5;
          let cleanedCount = 0;
          for (const [eventName, subscriptionMap] of this.subscriptions.entries()) {
            const toCleanup = Array.from(subscriptionMap.values()).filter(
              (sub) => !sub.lastTriggered && sub.createdAt < cutoffTime
            );
            for (const subscription of toCleanup) {
              subscriptionMap.delete(subscription.id);
              cleanedCount++;
              this.eventMetrics.activeSubscriptions--;
            }
            if (subscriptionMap.size === 0) {
              this.subscriptions.delete(eventName);
            }
          }
          if (cleanedCount > 0) {
            Y3KDebug?.debug?.log(
              "UnifiedEventBus",
              `Cleaned up ${cleanedCount} abandoned subscriptions`
            );
          }
        }
        /**
         * Generate unique subscription ID
         */
        generateSubscriptionId() {
          return `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }
        /**
         * Destroy the event bus and clean up all resources
         */
        destroy() {
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          if (this.subscriptionCleanupInterval) {
            clearInterval(this.subscriptionCleanupInterval);
            this.subscriptionCleanupInterval = null;
          }
          this.subscriptions.clear();
          this.eventQueue = [];
          this.eventMetrics = {
            totalEvents: 0,
            totalSubscriptions: 0,
            activeSubscriptions: 0,
            eventsPerSecond: 0,
            topEvents: [],
            memoryUsage: 0
          };
          Y3KDebug?.debug?.log("UnifiedEventBus", "Unified event bus destroyed");
          _UnifiedEventBus.instance = null;
        }
      };
      __name(_UnifiedEventBus, "UnifiedEventBus");
      _UnifiedEventBus.instance = null;
      UnifiedEventBus = _UnifiedEventBus;
      unifiedEventBus = UnifiedEventBus.getInstance();
    }
  });

  // src-js/types/signature.ts
  var createDefaultSignature;
  var init_signature = __esm({
    "src-js/types/signature.ts"() {
      "use strict";
      createDefaultSignature = /* @__PURE__ */ __name((userId) => ({
        version: "1.0.0",
        userId,
        createdAt: Date.now(),
        lastModified: Date.now(),
        colorMemories: /* @__PURE__ */ new Map(),
        rhythmicPreferences: /* @__PURE__ */ new Map(),
        emotionalResonanceProfile: {},
        evolutionaryTrajectory: {
          adaptability: 0.5,
          // Start balanced
          explorationFactor: 0.5,
          // Start balanced
          lastUpdate: Date.now()
        }
      }), "createDefaultSignature");
    }
  });

  // node_modules/idb/build/index.js
  function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
      IDBDatabase,
      IDBObjectStore,
      IDBIndex,
      IDBCursor,
      IDBTransaction
    ]);
  }
  function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey
    ]);
  }
  function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
      const unlisten = /* @__PURE__ */ __name(() => {
        request.removeEventListener("success", success);
        request.removeEventListener("error", error);
      }, "unlisten");
      const success = /* @__PURE__ */ __name(() => {
        resolve(wrap(request.result));
        unlisten();
      }, "success");
      const error = /* @__PURE__ */ __name(() => {
        reject(request.error);
        unlisten();
      }, "error");
      request.addEventListener("success", success);
      request.addEventListener("error", error);
    });
    reverseTransformCache.set(promise, request);
    return promise;
  }
  function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx))
      return;
    const done = new Promise((resolve, reject) => {
      const unlisten = /* @__PURE__ */ __name(() => {
        tx.removeEventListener("complete", complete);
        tx.removeEventListener("error", error);
        tx.removeEventListener("abort", error);
      }, "unlisten");
      const complete = /* @__PURE__ */ __name(() => {
        resolve();
        unlisten();
      }, "complete");
      const error = /* @__PURE__ */ __name(() => {
        reject(tx.error || new DOMException("AbortError", "AbortError"));
        unlisten();
      }, "error");
      tx.addEventListener("complete", complete);
      tx.addEventListener("error", error);
      tx.addEventListener("abort", error);
    });
    transactionDoneMap.set(tx, done);
  }
  function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
  }
  function wrapFunction(func) {
    if (getCursorAdvanceMethods().includes(func)) {
      return function(...args) {
        func.apply(unwrap(this), args);
        return wrap(this.request);
      };
    }
    return function(...args) {
      return wrap(func.apply(unwrap(this), args));
    };
  }
  function transformCachableValue(value) {
    if (typeof value === "function")
      return wrapFunction(value);
    if (value instanceof IDBTransaction)
      cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
      return new Proxy(value, idbProxyTraps);
    return value;
  }
  function wrap(value) {
    if (value instanceof IDBRequest)
      return promisifyRequest(value);
    if (transformCache.has(value))
      return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
      transformCache.set(value, newValue);
      reverseTransformCache.set(newValue, value);
    }
    return newValue;
  }
  function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap(request);
    if (upgrade) {
      request.addEventListener("upgradeneeded", (event) => {
        upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
      });
    }
    if (blocked) {
      request.addEventListener("blocked", (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion,
        event.newVersion,
        event
      ));
    }
    openPromise.then((db) => {
      if (terminated)
        db.addEventListener("close", () => terminated());
      if (blocking) {
        db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
      }
    }).catch(() => {
    });
    return openPromise;
  }
  function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
      return;
    }
    if (cachedMethods.get(prop))
      return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, "");
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
    ) {
      return;
    }
    const method = /* @__PURE__ */ __name(async function(storeName, ...args) {
      const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
      let target2 = tx.store;
      if (useIndex)
        target2 = target2.index(args.shift());
      return (await Promise.all([
        target2[targetFuncName](...args),
        isWrite && tx.done
      ]))[0];
    }, "method");
    cachedMethods.set(prop, method);
    return method;
  }
  async function* iterate(...args) {
    let cursor = this;
    if (!(cursor instanceof IDBCursor)) {
      cursor = await cursor.openCursor(...args);
    }
    if (!cursor)
      return;
    cursor = cursor;
    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
    reverseTransformCache.set(proxiedCursor, unwrap(cursor));
    while (cursor) {
      yield proxiedCursor;
      cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
      advanceResults.delete(proxiedCursor);
    }
  }
  function isIteratorProp(target, prop) {
    return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
  }
  var instanceOfAny, idbProxyableTypes, cursorAdvanceMethods, transactionDoneMap, transformCache, reverseTransformCache, idbProxyTraps, unwrap, readMethods, writeMethods, cachedMethods, advanceMethodProps, methodMap, advanceResults, ittrProxiedCursorToOriginalProxy, cursorIteratorTraps;
  var init_build = __esm({
    "node_modules/idb/build/index.js"() {
      instanceOfAny = /* @__PURE__ */ __name((object, constructors) => constructors.some((c) => object instanceof c), "instanceOfAny");
      __name(getIdbProxyableTypes, "getIdbProxyableTypes");
      __name(getCursorAdvanceMethods, "getCursorAdvanceMethods");
      transactionDoneMap = /* @__PURE__ */ new WeakMap();
      transformCache = /* @__PURE__ */ new WeakMap();
      reverseTransformCache = /* @__PURE__ */ new WeakMap();
      __name(promisifyRequest, "promisifyRequest");
      __name(cacheDonePromiseForTransaction, "cacheDonePromiseForTransaction");
      idbProxyTraps = {
        get(target, prop, receiver) {
          if (target instanceof IDBTransaction) {
            if (prop === "done")
              return transactionDoneMap.get(target);
            if (prop === "store") {
              return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
            }
          }
          return wrap(target[prop]);
        },
        set(target, prop, value) {
          target[prop] = value;
          return true;
        },
        has(target, prop) {
          if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
            return true;
          }
          return prop in target;
        }
      };
      __name(replaceTraps, "replaceTraps");
      __name(wrapFunction, "wrapFunction");
      __name(transformCachableValue, "transformCachableValue");
      __name(wrap, "wrap");
      unwrap = /* @__PURE__ */ __name((value) => reverseTransformCache.get(value), "unwrap");
      __name(openDB, "openDB");
      readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
      writeMethods = ["put", "add", "delete", "clear"];
      cachedMethods = /* @__PURE__ */ new Map();
      __name(getMethod, "getMethod");
      replaceTraps((oldTraps) => ({
        ...oldTraps,
        get: /* @__PURE__ */ __name((target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver), "get"),
        has: /* @__PURE__ */ __name((target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop), "has")
      }));
      advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
      methodMap = {};
      advanceResults = /* @__PURE__ */ new WeakMap();
      ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
      cursorIteratorTraps = {
        get(target, prop) {
          if (!advanceMethodProps.includes(prop))
            return target[prop];
          let cachedFunc = methodMap[prop];
          if (!cachedFunc) {
            cachedFunc = methodMap[prop] = function(...args) {
              advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
            };
          }
          return cachedFunc;
        }
      };
      __name(iterate, "iterate");
      __name(isIteratorProp, "isIteratorProp");
      replaceTraps((oldTraps) => ({
        ...oldTraps,
        get(target, prop, receiver) {
          if (isIteratorProp(target, prop))
            return iterate;
          return oldTraps.get(target, prop, receiver);
        },
        has(target, prop) {
          return isIteratorProp(target, prop) || oldTraps.has(target, prop);
        }
      }));
    }
  });

  // src-js/audio/TemporalMemoryService.ts
  var DB_NAME, DB_VERSION, SIGNATURE_STORE, SIGNATURE_KEY, _TemporalMemoryService, TemporalMemoryService, temporalMemoryService;
  var init_TemporalMemoryService = __esm({
    "src-js/audio/TemporalMemoryService.ts"() {
      "use strict";
      init_signature();
      init_build();
      DB_NAME = "Year3000-TemporalMemory";
      DB_VERSION = 1;
      SIGNATURE_STORE = "aestheticSignatures";
      SIGNATURE_KEY = "currentUser";
      _TemporalMemoryService = class _TemporalMemoryService {
        constructor() {
          this.dbPromise = openDB(DB_NAME, DB_VERSION, {
            upgrade(db) {
              if (!db.objectStoreNames.contains(SIGNATURE_STORE)) {
                db.createObjectStore(SIGNATURE_STORE);
              }
            }
          });
        }
        async getSignature(userId = "defaultUser") {
          try {
            const db = await this.dbPromise;
            const signature = await db.get(SIGNATURE_STORE, SIGNATURE_KEY);
            if (signature) {
              return signature;
            } else {
              const defaultSignature = createDefaultSignature(userId);
              await this.saveSignature(defaultSignature);
              return defaultSignature;
            }
          } catch (error) {
            console.error(
              "[TemporalMemoryService] Failed to get signature from IndexedDB. Returning default.",
              error
            );
            return createDefaultSignature(userId);
          }
        }
        async saveSignature(signature) {
          try {
            const db = await this.dbPromise;
            signature.lastModified = Date.now();
            await db.put(SIGNATURE_STORE, signature, SIGNATURE_KEY);
          } catch (error) {
            console.error(
              "[TemporalMemoryService] Failed to save signature to IndexedDB.",
              error
            );
          }
        }
        async resetSignature(userId = "defaultUser") {
          const defaultSignature = createDefaultSignature(userId);
          await this.saveSignature(defaultSignature);
          console.log("[TemporalMemoryService] Aesthetic signature has been reset.");
          return defaultSignature;
        }
        async getSignatureTrends(signature) {
          if (!signature) return null;
          const trends = {
            dominantColor: null,
            dominantRhythm: null,
            avgEnergy: 0,
            avgValence: 0
          };
          let dominantColor = null;
          signature.colorMemories.forEach((mem, hex) => {
            if (!dominantColor || mem.count > dominantColor.count) {
              dominantColor = { hex, count: mem.count };
            }
            trends.avgValence += mem.emotionalValence * mem.count;
          });
          let totalColorCount = 0;
          signature.colorMemories.forEach((mem) => totalColorCount += mem.count);
          if (totalColorCount > 0) {
            trends.avgValence /= totalColorCount;
          }
          trends.dominantColor = dominantColor;
          let dominantRhythm = null;
          signature.rhythmicPreferences.forEach((pattern, id) => {
            if (!dominantRhythm || pattern.count > dominantRhythm.count) {
              dominantRhythm = { id, count: pattern.count };
            }
            trends.avgEnergy += pattern.associatedEnergy * pattern.count;
          });
          let totalRhythmCount = 0;
          signature.rhythmicPreferences.forEach((p) => totalRhythmCount += p.count);
          if (totalRhythmCount > 0) {
            trends.avgEnergy /= totalRhythmCount;
          }
          trends.dominantRhythm = dominantRhythm;
          return trends;
        }
      };
      __name(_TemporalMemoryService, "TemporalMemoryService");
      TemporalMemoryService = _TemporalMemoryService;
      temporalMemoryService = new TemporalMemoryService();
    }
  });

  // src-js/core/animation/EnhancedMasterAnimationCoordinator.ts
  var _EnhancedMasterAnimationCoordinator, EnhancedMasterAnimationCoordinator;
  var init_EnhancedMasterAnimationCoordinator = __esm({
    "src-js/core/animation/EnhancedMasterAnimationCoordinator.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_TemporalMemoryService();
      _EnhancedMasterAnimationCoordinator = class _EnhancedMasterAnimationCoordinator {
        constructor(config, performanceCoordinator, cssAnimationManager, cssVariableManager) {
          this.performanceCoordinator = null;
          this.cssAnimationManager = null;
          // Animation management
          this.animations = /* @__PURE__ */ new Map();
          this.frameCallbacks = /* @__PURE__ */ new Map();
          this.callbackCounter = 0;
          // Master animation loop
          this.animationFrameId = null;
          this.isRunning = false;
          this.isPaused = false;
          // Timing and performance
          this.lastTimestamp = 0;
          this.frameCount = 0;
          this.startTime = 0;
          this.frameTimeBudget = 16;
          // 60fps
          // Performance metrics
          this.metrics = {
            totalFrames: 0,
            droppedFrames: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            performanceMode: "quality",
            activeAnimations: 0,
            activeCallbacks: 0,
            frameRate: 60,
            lastOptimization: 0
          };
          // Frame context for visual systems
          this.frameContext = {
            timestamp: 0,
            deltaMs: 0,
            performanceMode: "quality",
            frameBudget: 16,
            beatIntensity: 0,
            scrollRatio: 0,
            tiltXY: { x: 0, y: 0 }
          };
          // Performance tracking
          this.performanceHistory = [];
          this.MAX_HISTORY_SIZE = 60;
          // 1 second at 60fps
          // ===================================================================
          // 🔧 PHASE 3.1: CONSOLIDATED ANIMATION SYSTEM PROPERTIES
          // ===================================================================
          // CSS Animation Management (from CSSAnimationManager consolidation)
          this.cssVariableManager = null;
          this.cssAnimationStates = /* @__PURE__ */ new Map();
          this.activeCSSAnimations = /* @__PURE__ */ new Map();
          this.cssAnimationObservers = /* @__PURE__ */ new Map();
          // Beat synchronization state (from CSSAnimationManager consolidation)
          this.beatSyncState = {
            intensity: 0,
            tempo: 120,
            phase: 0,
            lastBeatTime: 0,
            avgBeatInterval: 500
          };
          // Musical LERP coordination (from PerformanceAwareLerpCoordinator consolidation)
          this.lerpOperations = /* @__PURE__ */ new Map();
          // Animation configuration presets (from CSSAnimationManager consolidation)
          this.CSS_ANIMATION_CONFIGS = {
            visualEffectsGentleBreathing: {
              name: "visualEffects-gentle-animation",
              duration: 4e3,
              easing: "ease-in-out",
              iterations: "infinite",
              fillMode: "none",
              playState: "running",
              delay: 0,
              direction: "normal"
            },
            energeticPulse: {
              name: "energetic-pulse-animation",
              duration: 1200,
              easing: "cubic-bezier(0.23, 1, 0.32, 1)",
              iterations: "infinite",
              fillMode: "none",
              playState: "running",
              delay: 0,
              direction: "alternate"
            },
            meditativeFlow: {
              name: "meditative-flow-animation",
              duration: 8e3,
              easing: "ease-in-out",
              iterations: "infinite",
              fillMode: "both",
              playState: "running",
              delay: 0,
              direction: "normal"
            }
          };
          // ===================================================================
          // EMERGENT CHOREOGRAPHY ENGINE INTEGRATION (from consolidation)
          // ===================================================================
          // Emergent choreography state
          this.signature = null;
          this.saveInterval = null;
          this.currentBpm = 120;
          this.currentIntensity = 0.5;
          this.emergentEventSubscriptions = [];
          // =========================================================================
          // PRIVATE METHODS
          // =========================================================================
          /**
           * Main animation loop with proper frame time budgeting
           */
          this.animate = /* @__PURE__ */ __name(() => {
            if (!this.isRunning) return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.lastTimestamp;
            if (this.isPaused) {
              this.animationFrameId = requestAnimationFrame(this.animate);
              return;
            }
            this.frameContext.timestamp = currentTime;
            this.frameContext.deltaMs = deltaTime;
            const frameStartTime = performance.now();
            const FRAME_BUDGET = this.frameTimeBudget;
            const callbackStartTime = performance.now();
            this.executeFrameCallbacks(deltaTime, currentTime);
            const callbackTime = performance.now() - callbackStartTime;
            const remainingBudget = FRAME_BUDGET - callbackTime;
            if (remainingBudget > 2) {
              this.executeAnimationSystemsWithBudget(deltaTime, currentTime, remainingBudget);
            } else {
              this.metrics.droppedFrames++;
              if (this.config.enableDebug && Math.random() < 0.1) {
                console.warn(`[EnhancedMasterAnimationCoordinator] Skipped animation systems - budget exceeded: ${callbackTime.toFixed(2)}ms`);
              }
            }
            const midFrameTime = performance.now() - frameStartTime;
            if (midFrameTime < FRAME_BUDGET * 0.7) {
              this.updateConsolidatedAnimations(currentTime, deltaTime);
            }
            if (midFrameTime < FRAME_BUDGET * 0.8) {
              this.processEmergentTick(deltaTime);
            }
            const frameTime = performance.now() - frameStartTime;
            this.updatePerformanceMetrics(frameTime);
            if (this.performanceCoordinator) {
              this.performanceCoordinator.trackSubsystem("MasterAnimationCoordinator", {
                frameTime,
                fps: this.metrics.frameRate,
                memoryUsage: performance.memory?.usedJSHeapSize || 0,
                cpuUsage: frameTime > this.frameTimeBudget ? frameTime / this.frameTimeBudget * 10 : 0
              });
            }
            this.lastTimestamp = currentTime;
            this.frameCount++;
            if (frameTime > FRAME_BUDGET * 1.5) {
              setTimeout(() => {
                this.animationFrameId = requestAnimationFrame(this.animate);
              }, 4);
            } else {
              this.animationFrameId = requestAnimationFrame(this.animate);
            }
          }, "animate");
          this.config = config;
          this.eventBus = unifiedEventBus;
          this.performanceCoordinator = performanceCoordinator || null;
          this.cssAnimationManager = cssAnimationManager || null;
          this.cssVariableManager = cssVariableManager || null;
          this.startTime = performance.now();
          this.lastTimestamp = this.startTime;
          this.currentMultipliers = this.config.cosmicMultipliers;
          this.initializeConsolidatedSystems();
          this.subscribeToEvents();
          this.initializeEmergentChoreography();
          this.updateFrameBudget();
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Initialized with unified animation coordination, CSS management, and LERP orchestration");
          }
        }
        // ===================================================================
        // CSS-FIRST PULSING COORDINATION - YEAR 3000 PERFORMANCE REVOLUTION
        // ===================================================================
        /**
         * Coordinate visual effects pulsing with CSSAnimationManager
         * Integrates beat events with CSS-first pulsing for 90%+ JavaScript overhead elimination
         */
        coordinateVisualEffectsPulsing(payload) {
          if (!this.cssAnimationManager) return;
          const energyLevel = payload.energy || payload.intensity || 0.5;
          const tempo = payload.bpm || this.currentBpm || 120;
          const energyDelta = Math.abs(energyLevel - this.currentIntensity);
          if (energyDelta < 0.1 && Math.abs(tempo - this.currentBpm) < 5) {
            return;
          }
          const visualEffectsElements = document.querySelectorAll(
            ".Root__main-view::before, .Root__main-view, [data-visual-effects-pulsing]"
          );
          if (visualEffectsElements.length > 0) {
            this.triggerConsciousnessBreathing(
              visualEffectsElements,
              energyLevel,
              tempo
            );
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] Visual effects pulsing coordinated - Energy: ${energyLevel.toFixed(2)}, Tempo: ${tempo} BPM`);
            }
          }
          this.currentIntensity = energyLevel;
          this.currentBpm = tempo;
        }
        /**
         * Get or create singleton instance
         */
        static getInstance(config, performanceCoordinator, cssAnimationManager) {
          if (!_EnhancedMasterAnimationCoordinator.instance) {
            if (!config) {
              throw new Error("EnhancedMasterAnimationCoordinator requires config for first initialization");
            }
            _EnhancedMasterAnimationCoordinator.instance = new _EnhancedMasterAnimationCoordinator(config, performanceCoordinator, cssAnimationManager);
          }
          return _EnhancedMasterAnimationCoordinator.instance;
        }
        /**
         * Register CSSAnimationManager for pulsing coordination
         */
        registerCSSAnimationManager(cssAnimationManager) {
          this.cssAnimationManager = cssAnimationManager;
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] CSSAnimationManager registered for pulsing coordination");
          }
        }
        /**
         * Register an animation system (legacy AnimationConductor compatibility)
         */
        registerAnimationSystem(name, system, priority = "normal", targetFPS = 60) {
          if (this.animations.has(name)) {
            if (this.config.enableDebug) {
              console.warn(`[EnhancedMasterAnimationCoordinator] Animation system ${name} already registered`);
            }
            return false;
          }
          const registration = {
            name,
            system,
            priority,
            targetFPS,
            type: "animation",
            enabled: true,
            frameInterval: 1e3 / targetFPS,
            lastUpdate: 0,
            frameCount: 0,
            totalTime: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            skippedFrames: 0
          };
          this.animations.set(name, registration);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered animation system: ${name} (priority: ${priority}, fps: ${targetFPS})`);
          }
          return true;
        }
        /**
         * Register a visual system (legacy VisualFrameCoordinator compatibility)
         */
        registerVisualSystem(system, priority = "normal") {
          if (this.animations.has(system.systemName)) {
            if (this.config.enableDebug) {
              console.warn(`[EnhancedMasterAnimationCoordinator] Visual system ${system.systemName} already registered`);
            }
            return false;
          }
          const registration = {
            name: system.systemName,
            system,
            priority,
            targetFPS: 60,
            type: "visual",
            enabled: true,
            frameInterval: 16.67,
            // 60fps
            lastUpdate: 0,
            frameCount: 0,
            totalTime: 0,
            averageFrameTime: 0,
            maxFrameTime: 0,
            skippedFrames: 0
          };
          this.animations.set(system.systemName, registration);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered visual system: ${system.systemName} (priority: ${priority})`);
          }
          return true;
        }
        /**
         * Register a frame callback for unified RAF management
         */
        registerFrameCallback(callback, priority = "normal", system) {
          const id = `callback_${++this.callbackCounter}`;
          const frameCallback = {
            id,
            callback,
            priority,
            system: system || void 0,
            enabled: true,
            frameCount: 0,
            totalTime: 0,
            lastExecution: 0
          };
          this.frameCallbacks.set(id, frameCallback);
          if (!this.isRunning) {
            this.startMasterAnimationLoop();
          }
          this.updateMetrics();
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Registered frame callback: ${id} (priority: ${priority})`);
          }
          return id;
        }
        /**
         * Unregister an animation system
         */
        unregisterAnimationSystem(name) {
          const removed = this.animations.delete(name);
          if (removed) {
            this.updateMetrics();
            if (this.animations.size === 0 && this.frameCallbacks.size === 0) {
              this.stopMasterAnimationLoop();
            }
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] Unregistered animation system: ${name}`);
            }
          }
          return removed;
        }
        /**
         * Unregister a frame callback
         */
        unregisterFrameCallback(id) {
          const removed = this.frameCallbacks.delete(id);
          if (removed) {
            this.updateMetrics();
            if (this.animations.size === 0 && this.frameCallbacks.size === 0) {
              this.stopMasterAnimationLoop();
            }
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] Unregistered frame callback: ${id}`);
            }
          }
          return removed;
        }
        /**
         * Start the master animation loop
         */
        startMasterAnimationLoop() {
          if (this.isRunning) return;
          this.isRunning = true;
          this.isPaused = false;
          this.lastTimestamp = performance.now();
          this.frameCount = 0;
          this.animate();
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Master animation loop started");
          }
        }
        /**
         * Stop the master animation loop
         */
        stopMasterAnimationLoop() {
          if (!this.isRunning) return;
          this.isRunning = false;
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Master animation loop stopped");
          }
        }
        /**
         * Pause the animation loop
         */
        pauseAnimationLoop() {
          this.isPaused = true;
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Animation loop paused");
          }
        }
        /**
         * Resume the animation loop
         */
        resumeAnimationLoop() {
          if (!this.isPaused) return;
          this.isPaused = false;
          this.lastTimestamp = performance.now();
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Animation loop resumed");
          }
        }
        /**
         * Set performance mode for all registered systems
         */
        setPerformanceMode(mode) {
          this.metrics.performanceMode = mode;
          this.frameContext.performanceMode = mode;
          this.frameTimeBudget = mode === "performance" ? 8 : 16;
          this.frameContext.frameBudget = this.frameTimeBudget;
          for (const registration of this.animations.values()) {
            if (registration.system.onPerformanceModeChange) {
              registration.system.onPerformanceModeChange(mode);
            }
          }
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Performance mode set to: ${mode}`);
          }
        }
        /**
         * Get current performance metrics
         */
        getPerformanceMetrics() {
          return { ...this.metrics };
        }
        /**
         * Get all registered systems
         */
        getRegisteredSystems() {
          return {
            animations: new Map(this.animations),
            callbacks: new Map(this.frameCallbacks)
          };
        }
        /**
         * Enable or disable a specific system
         */
        setSystemEnabled(name, enabled) {
          const animation = this.animations.get(name);
          if (animation) {
            animation.enabled = enabled;
            this.updateMetrics();
            if (this.config.enableDebug) {
              console.log(`[EnhancedMasterAnimationCoordinator] System ${name} ${enabled ? "enabled" : "disabled"}`);
            }
            return true;
          }
          return false;
        }
        /**
         * Get current multipliers for adaptive choreography
         */
        getCurrentMultipliers() {
          return this.currentMultipliers;
        }
        /**
         * Force update evolutionary trajectory
         */
        async updateEvolutionaryTrajectory() {
          await this._updateEvolutionaryTrajectory();
        }
        /**
         * Destroy the coordinator and clean up resources
         */
        destroy() {
          this.stopMasterAnimationLoop();
          this.destroyConsolidatedSystems();
          this.destroyEmergentChoreography();
          for (const registration of this.animations.values()) {
            if (registration.type === "visual" && "destroy" in registration.system) {
              try {
                registration.system.destroy();
              } catch (error) {
                console.error(`[EnhancedMasterAnimationCoordinator] Error destroying system ${registration.name}:`, error);
              }
            }
          }
          this.animations.clear();
          this.frameCallbacks.clear();
          if (_EnhancedMasterAnimationCoordinator.instance === this) {
            _EnhancedMasterAnimationCoordinator.instance = null;
          }
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Destroyed");
          }
        }
        /**
         * Execute frame callbacks with priority ordering
         */
        executeFrameCallbacks(deltaTime, timestamp) {
          const sortedCallbacks = Array.from(this.frameCallbacks.values()).filter((callback) => callback.enabled).sort((a, b) => {
            const priorityOrder = { critical: 0, normal: 1, background: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
          });
          for (const callback of sortedCallbacks) {
            const callbackStartTime = performance.now();
            try {
              callback.callback(deltaTime, timestamp);
              const callbackTime = performance.now() - callbackStartTime;
              callback.totalTime += callbackTime;
              callback.frameCount++;
              callback.lastExecution = timestamp;
              if (callbackTime > this.frameTimeBudget * 0.5) {
                if (this.config.enableDebug) {
                  console.warn(`[EnhancedMasterAnimationCoordinator] Callback ${callback.id} exceeded budget: ${callbackTime.toFixed(2)}ms`);
                }
              }
            } catch (error) {
              console.error(`[EnhancedMasterAnimationCoordinator] Error in callback ${callback.id}:`, error);
            }
          }
        }
        /**
         * Execute animation systems with priority ordering and FPS throttling
         */
        executeAnimationSystems(deltaTime, timestamp) {
          const sortedSystems = Array.from(this.animations.values()).filter((animation) => animation.enabled).sort((a, b) => {
            const priorityOrder = { critical: 0, normal: 1, background: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
          });
          for (const animation of sortedSystems) {
            if (timestamp - animation.lastUpdate < animation.frameInterval) {
              animation.skippedFrames++;
              continue;
            }
            const systemStartTime = performance.now();
            try {
              if (animation.type === "visual") {
                animation.system.onAnimate(deltaTime, this.frameContext);
              } else {
                const animationSystem = animation.system;
                if (animationSystem.onAnimate) {
                  animationSystem.onAnimate(deltaTime);
                }
                if (animationSystem.updateAnimation) {
                  animationSystem.updateAnimation(timestamp, deltaTime);
                }
              }
              const systemTime = performance.now() - systemStartTime;
              animation.totalTime += systemTime;
              animation.frameCount++;
              animation.lastUpdate = timestamp;
              animation.averageFrameTime = animation.totalTime / animation.frameCount;
              animation.maxFrameTime = Math.max(animation.maxFrameTime, systemTime);
              if (systemTime > this.frameTimeBudget * 0.8) {
                if (this.config.enableDebug) {
                  console.warn(`[EnhancedMasterAnimationCoordinator] System ${animation.name} exceeded budget: ${systemTime.toFixed(2)}ms`);
                }
              }
            } catch (error) {
              console.error(`[EnhancedMasterAnimationCoordinator] Error in system ${animation.name}:`, error);
            }
          }
        }
        /**
         * Execute animation systems with frame time budget enforcement
         */
        executeAnimationSystemsWithBudget(deltaTime, timestamp, budget) {
          const startTime = performance.now();
          const sortedSystems = Array.from(this.animations.values()).filter((animation) => animation.enabled).sort((a, b) => {
            const priorityOrder = { critical: 0, normal: 1, background: 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
          });
          let processedCount = 0;
          let skippedCount = 0;
          for (const animation of sortedSystems) {
            const elapsed = performance.now() - startTime;
            if (elapsed >= budget * 0.9) {
              skippedCount = sortedSystems.length - processedCount;
              if (this.config.enableDebug && skippedCount > 0) {
                console.warn(`[EnhancedMasterAnimationCoordinator] Budget exhausted: skipped ${skippedCount} systems`);
              }
              break;
            }
            if (timestamp - animation.lastUpdate < animation.frameInterval) {
              animation.skippedFrames++;
              continue;
            }
            const systemStartTime = performance.now();
            try {
              if (animation.type === "visual") {
                animation.system.onAnimate(deltaTime, this.frameContext);
              } else {
                const animationSystem = animation.system;
                if (animationSystem.onAnimate) {
                  animationSystem.onAnimate(deltaTime);
                }
                if (animationSystem.updateAnimation) {
                  animationSystem.updateAnimation(timestamp, deltaTime);
                }
              }
              const systemTime = performance.now() - systemStartTime;
              animation.totalTime += systemTime;
              animation.frameCount++;
              animation.lastUpdate = timestamp;
              animation.averageFrameTime = animation.totalTime / animation.frameCount;
              animation.maxFrameTime = Math.max(animation.maxFrameTime, systemTime);
              processedCount++;
              if (systemTime > budget * 0.3) {
                if (this.config.enableDebug) {
                  console.warn(`[EnhancedMasterAnimationCoordinator] System ${animation.name} consuming excessive budget: ${systemTime.toFixed(2)}ms`);
                }
              }
            } catch (error) {
              console.error(`[EnhancedMasterAnimationCoordinator] Error in system ${animation.name}:`, error);
              processedCount++;
            }
          }
          const totalTime = performance.now() - startTime;
          if (skippedCount > 0) {
            this.metrics.droppedFrames += skippedCount;
          }
          if (this.config.enableDebug && Math.random() < 0.02) {
            console.log(`[EnhancedMasterAnimationCoordinator] Budget usage: ${totalTime.toFixed(2)}ms/${budget.toFixed(2)}ms, processed: ${processedCount}/${sortedSystems.length}`);
          }
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics(frameTime) {
          this.metrics.totalFrames++;
          this.metrics.maxFrameTime = Math.max(this.metrics.maxFrameTime, frameTime);
          this.performanceHistory.push(frameTime);
          if (this.performanceHistory.length > this.MAX_HISTORY_SIZE) {
            this.performanceHistory.shift();
          }
          this.metrics.averageFrameTime = this.performanceHistory.reduce((sum, time) => sum + time, 0) / this.performanceHistory.length;
          this.metrics.frameRate = this.performanceHistory.length > 0 ? 1e3 / this.metrics.averageFrameTime : 60;
          if (frameTime > this.frameTimeBudget * 1.5) {
            this.metrics.droppedFrames++;
          }
          if (this.metrics.averageFrameTime > this.frameTimeBudget * 1.2 && this.metrics.performanceMode === "quality") {
            this.setPerformanceMode("performance");
            this.metrics.lastOptimization = Date.now();
          } else if (this.metrics.averageFrameTime < this.frameTimeBudget * 0.8 && this.metrics.performanceMode === "performance") {
            if (Date.now() - this.metrics.lastOptimization > 5e3) {
              this.setPerformanceMode("quality");
            }
          }
        }
        /**
         * Update frame budget based on performance mode
         */
        updateFrameBudget() {
          this.frameTimeBudget = this.metrics.performanceMode === "performance" ? 8 : 16;
          this.frameContext.frameBudget = this.frameTimeBudget;
        }
        /**
         * Update metrics counts
         */
        updateMetrics() {
          this.metrics.activeAnimations = Array.from(this.animations.values()).filter((a) => a.enabled).length;
          this.metrics.activeCallbacks = Array.from(this.frameCallbacks.values()).filter((c) => c.enabled).length;
        }
        /**
         * Subscribe to performance events
         */
        subscribeToEvents() {
          this.eventBus.subscribe("music:beat", (payload) => {
            this.frameContext.beatIntensity = payload.intensity || 0;
            this.coordinateVisualEffectsPulsing(payload);
          }, "EnhancedMasterAnimationCoordinator");
          this.eventBus.subscribe("performance:frame", (payload) => {
            if (payload.fps < 45) {
              for (const animation of this.animations.values()) {
                animation.frameInterval = Math.min(animation.frameInterval * 1.5, 33.33);
              }
              this.setPerformanceMode("performance");
            } else if (payload.fps > 55) {
              this.setPerformanceMode("quality");
            }
          }, "EnhancedMasterAnimationCoordinator");
        }
        // =========================================================================
        // EMERGENT CHOREOGRAPHY ENGINE METHODS (from consolidation)
        // =========================================================================
        /**
         * Initialize adaptive choreography functionality
         */
        async initializeEmergentChoreography() {
          try {
            this.signature = await temporalMemoryService.getSignature();
            this.registerEmergentEventListeners();
            this.saveInterval = setInterval(() => {
              if (this.signature) {
                temporalMemoryService.saveSignature(this.signature);
              }
            }, 3e4);
            if (this.config.enableDebug) {
              console.log("[EnhancedMasterAnimationCoordinator] Emergent choreography initialized");
            }
          } catch (error) {
            console.error("[EnhancedMasterAnimationCoordinator] Failed to initialize adaptive choreography:", error);
          }
        }
        /**
         * Register adaptive choreography event listeners
         */
        registerEmergentEventListeners() {
          const beatFrameSub = this.eventBus.subscribe(
            "music:beat",
            (payload) => this.handleBeatFrame(payload),
            "EnhancedMasterAnimationCoordinator"
          );
          const harmonyFrameSub = this.eventBus.subscribe(
            "colors:harmonized",
            (payload) => this.handleHarmonyFrame(payload),
            "EnhancedMasterAnimationCoordinator"
          );
          const bpmSub = this.eventBus.subscribe(
            "music:energy",
            (payload) => {
              this.currentBpm = payload.tempo;
            },
            "EnhancedMasterAnimationCoordinator"
          );
          const intensitySub = this.eventBus.subscribe(
            "music:beat",
            (payload) => {
              this.currentIntensity = payload.intensity;
            },
            "EnhancedMasterAnimationCoordinator"
          );
          this.emergentEventSubscriptions.push(
            beatFrameSub,
            harmonyFrameSub,
            bpmSub,
            intensitySub
          );
        }
        /**
         * Handle beat frame events for adaptive adaptation
         */
        handleBeatFrame(payload) {
          if (!this.signature) return;
          this.signature.lastModified = Date.now();
          this.coordinateVisualEffectsPulsing({
            intensity: payload.intensity || this.currentIntensity,
            energy: payload.energy || this.currentIntensity,
            bpm: this.currentBpm
          });
        }
        /**
         * Handle harmony frame events for adaptive adaptation
         */
        handleHarmonyFrame(payload) {
          if (!this.signature) return;
          const { kineticState } = payload;
          this.signature.lastModified = Date.now();
        }
        /**
         * Update evolutionary trajectory based on signature trends
         */
        async _updateEvolutionaryTrajectory() {
          if (!this.signature) return;
          const trends = await temporalMemoryService.getSignatureTrends(
            this.signature
          );
          if (!trends) return;
          const { avgEnergy, avgValence } = trends;
          const explorationFactor = 0.5 + (avgEnergy - 0.5) * 0.2;
          this.signature.evolutionaryTrajectory.explorationFactor = Math.max(
            0.1,
            Math.min(0.9, explorationFactor)
          );
          const adaptability = 0.5 + (Math.abs(avgValence) - 0.2) * 0.3;
          this.signature.evolutionaryTrajectory.adaptability = Math.max(
            0.1,
            Math.min(0.9, adaptability)
          );
          this.signature.evolutionaryTrajectory.lastUpdate = Date.now();
        }
        /**
         * Calculate visual pulse based on current BPM and intensity
         */
        _calculateVisualPulse(deltaMs) {
          const beatInterval = 6e4 / this.currentBpm;
          const phase = performance.now() % beatInterval / beatInterval;
          const hueShift = Math.sin(phase * 2 * Math.PI + Math.PI / 2) * 15 * this.currentIntensity;
          return {
            timestamp: performance.now(),
            bpm: this.currentBpm,
            intensity: this.currentIntensity,
            phase,
            hueShift
          };
        }
        /**
         * Calculate adaptive coefficients based on signature
         */
        _calculateAdaptiveCoefficients() {
          if (!this.signature) return;
          const { adaptability, explorationFactor } = this.signature.evolutionaryTrajectory;
          const kineticIntensity = 0.5 + adaptability * 0.5;
          const visualIntensityBase = 0.8 + explorationFactor * 0.4;
          this.currentMultipliers = {
            ...this.config.cosmicMultipliers,
            kineticIntensity,
            visualIntensityBase
          };
        }
        /**
         * Process adaptive choreography tick within animation loop
         */
        processEmergentTick(deltaMs) {
          if (!this.signature) return;
          this._calculateAdaptiveCoefficients();
          if (this.signature && Date.now() - this.signature.evolutionaryTrajectory.lastUpdate > 6e4) {
            this._updateEvolutionaryTrajectory();
          }
          const visualPulse = this._calculateVisualPulse(deltaMs);
          if (visualPulse) {
          }
          const emergentPayload = {
            timestamp: performance.now(),
            deltaMs
            // ...other adaptive data to be calculated in later phases
          };
        }
        /**
         * Clean up adaptive choreography resources
         */
        destroyEmergentChoreography() {
          if (this.signature) {
            temporalMemoryService.saveSignature(this.signature);
          }
          if (this.saveInterval) {
            clearInterval(this.saveInterval);
            this.saveInterval = null;
          }
          this.emergentEventSubscriptions.forEach((subscriptionId) => this.eventBus.unsubscribe(subscriptionId));
          this.emergentEventSubscriptions = [];
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Emergent choreography destroyed");
          }
        }
        // ===================================================================
        // 🔧 PHASE 3.1: CONSOLIDATED ANIMATION SYSTEM METHODS
        // ===================================================================
        /**
         * Initialize consolidated animation systems (from Phase 3.1 consolidation)
         */
        initializeConsolidatedSystems() {
          this.cssAnimationStates.set("default", {
            rippleActive: false,
            bloomActive: false,
            refractActive: false,
            oscillateActive: false,
            harmonizeActive: false,
            timeBasedEchoActive: false,
            gravityActive: false,
            beatSyncEnabled: true,
            intensityLevel: 0.5,
            tempoMultiplier: 1
          });
          try {
            this.eventBus.subscribe("music:beat", (payload) => {
              this.onBeatDetected(payload);
            });
            this.eventBus.subscribe("music:energy", (payload) => {
              this.onMusicalAnalysis(payload);
            });
          } catch (error) {
            console.warn("[EnhancedMasterAnimationCoordinator] Event subscription failed, using manual coordination");
          }
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Consolidated systems initialized");
          }
        }
        /**
         * Static musical LERP calculation (from MusicalLerpOrchestrator consolidation)
         */
        static calculateMusicalLerp(musicContext, animationType = "flow", baseHalfLife) {
          const tempoFactor = Math.max(0.3, Math.min(2, musicContext.tempo / 120));
          const energyFactor = Math.max(0.1, Math.min(1, musicContext.energy));
          const calculatedHalfLife = baseHalfLife || 16.67 * (2 - energyFactor) * (1 / tempoFactor);
          const typeModifiers = {
            "flow": { intensityMod: 0.7, easingPower: 1.2 },
            "pulse": { intensityMod: 1.3, easingPower: 2 },
            "smooth": { intensityMod: 0.5, easingPower: 0.8 },
            "sharp": { intensityMod: 1.1, easingPower: 3 }
          };
          const modifier = typeModifiers[animationType] || typeModifiers.flow;
          const intensity = energyFactor * modifier.intensityMod;
          const easing = /* @__PURE__ */ __name((t) => Math.pow(t, modifier.easingPower), "easing");
          return {
            halfLife: calculatedHalfLife,
            intensity,
            easing
          };
        }
        /**
         * CSS Animation Management (from CSSAnimationManager consolidation)
         */
        createCSSAnimation(name, config, element) {
          try {
            const animation = element?.animate?.({}, {
              duration: config.duration,
              easing: config.easing,
              iterations: config.iterations === "infinite" ? Infinity : config.iterations,
              fill: config.fillMode,
              delay: config.delay,
              direction: config.direction
            });
            if (animation) {
              this.activeCSSAnimations.set(name, animation);
              if (this.cssVariableManager) {
                this.cssVariableManager.batchSetVariables({
                  [`--sn-animation-${name}-duration`]: `${config.duration}ms`,
                  [`--sn-animation-${name}-easing`]: config.easing,
                  [`--sn-animation-${name}-delay`]: `${config.delay}ms`
                });
              }
            }
          } catch (error) {
            console.warn(`[EnhancedMasterAnimationCoordinator] Failed to create CSS animation ${name}:`, error);
          }
        }
        /**
         * Musical LERP coordination (from PerformanceAwareLerpCoordinator consolidation)
         */
        createMusicalLerp(id, startValue, targetValue, duration, options) {
          const lerpOperation = {
            id,
            startValue,
            targetValue,
            startTime: performance.now(),
            duration,
            easing: options.easing || ((t) => t),
            // Linear by default
            onUpdate: options.onUpdate
          };
          if (options.musicalContext) {
            lerpOperation.musicalContext = options.musicalContext;
          }
          if (options.onComplete) {
            lerpOperation.onComplete = options.onComplete;
          }
          this.lerpOperations.set(id, lerpOperation);
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Created musical LERP: ${id}`);
          }
        }
        /**
         * Beat detection handler for CSS animation synchronization
         */
        onBeatDetected(payload) {
          this.beatSyncState.intensity = payload.intensity || 0.5;
          this.beatSyncState.tempo = payload.bpm || 120;
          this.beatSyncState.lastBeatTime = performance.now();
          if (this.cssVariableManager) {
            this.cssVariableManager.batchSetVariables({
              "--sn-beat-intensity": this.beatSyncState.intensity.toString(),
              "--sn-beat-tempo": this.beatSyncState.tempo.toString(),
              "--sn-beat-phase": (performance.now() % 1e3 / 1e3).toString()
            });
          }
          this.triggerBeatSyncAnimations();
        }
        /**
         * Musical analysis handler for enhanced LERP coordination
         */
        onMusicalAnalysis(payload) {
          const musicalContext = {
            // Base MusicalContext properties
            tempo: payload.bpm || 120,
            energy: payload.energy || 0.5,
            valence: payload.valence || 0.5,
            danceability: payload.danceability || 0.5,
            emotionalTemperature: payload.emotionalTemperature || 4e3,
            beatPhase: payload.beatPhase || "sustain",
            beatConfidence: payload.beatConfidence || 0.5,
            beatInterval: payload.beatInterval || 500,
            timeSinceLastBeat: payload.timeSinceLastBeat || 0,
            // Consolidated additional properties
            bpm: payload.bpm || 120,
            beat: payload.beat || 0,
            energyLevel: payload.energy || 0.5,
            harmonicContent: payload.harmonic || 0.5,
            rhythmicStability: payload.stability || 0.8,
            harmonicComplexity: payload.harmonicComplexity || 0.5,
            rhythmicDensity: payload.rhythmicDensity || 0.5,
            spectralCentroid: payload.spectralCentroid || 0.5
          };
          this.lerpOperations.forEach((lerp2, id) => {
            if (lerp2.musicalContext) {
              lerp2.musicalContext = { ...lerp2.musicalContext, ...musicalContext };
            }
          });
        }
        /**
         * Trigger beat-synchronized animations
         */
        triggerBeatSyncAnimations() {
          this.cssAnimationStates.forEach((state, name) => {
            if (state.beatSyncEnabled) {
              const intensity = this.beatSyncState.intensity * state.intensityLevel;
              const scaledTempo = this.beatSyncState.tempo * state.tempoMultiplier;
              if (this.cssVariableManager) {
                this.cssVariableManager.batchSetVariables({
                  [`--sn-${name}-beat-intensity`]: intensity.toString(),
                  [`--sn-${name}-beat-tempo`]: scaledTempo.toString()
                });
              }
            }
          });
        }
        /**
         * Process active LERP operations during animation frame
         */
        processLerpOperations(timestamp) {
          const completedLerps = [];
          this.lerpOperations.forEach((lerp2, id) => {
            const elapsed = timestamp - lerp2.startTime;
            const progress = Math.min(elapsed / lerp2.duration, 1);
            const easedProgress = lerp2.easing(progress);
            const currentValue = lerp2.startValue + (lerp2.targetValue - lerp2.startValue) * easedProgress;
            let modulatedValue = currentValue;
            if (lerp2.musicalContext) {
              const musicalModulation = Math.sin(timestamp * 1e-3 * lerp2.musicalContext.bpm / 60) * 0.1;
              modulatedValue = currentValue + musicalModulation * lerp2.musicalContext.energyLevel;
            }
            lerp2.onUpdate(modulatedValue);
            if (progress >= 1) {
              if (lerp2.onComplete) {
                lerp2.onComplete();
              }
              completedLerps.push(id);
            }
          });
          completedLerps.forEach((id) => this.lerpOperations.delete(id));
        }
        /**
         * Enhanced animation frame update with consolidated features
         */
        updateConsolidatedAnimations(timestamp, deltaTime) {
          this.processLerpOperations(timestamp);
          this.updateCSSAnimationSync(timestamp, deltaTime);
          if (this.beatSyncState.tempo > 0) {
            const beatInterval = 6e4 / this.beatSyncState.tempo;
            const beatPhase = (timestamp - this.beatSyncState.lastBeatTime) / beatInterval;
            if (this.cssVariableManager) {
              this.cssVariableManager.setVariable("--sn-beat-phase", (beatPhase % 1).toString());
            }
          }
        }
        /**
         * Update CSS animation synchronization
         */
        updateCSSAnimationSync(timestamp, deltaTime) {
          this.activeCSSAnimations.forEach((animation, name) => {
            if (animation.playState === "running") {
              const state = this.cssAnimationStates.get(name);
              if (state?.beatSyncEnabled) {
                const tempoRatio = this.beatSyncState.tempo / 120;
                animation.playbackRate = tempoRatio * state.tempoMultiplier;
              }
            }
          });
        }
        /**
         * Get consolidated animation metrics
         */
        getConsolidatedMetrics() {
          return {
            ...this.metrics,
            activeCSSAnimations: this.activeCSSAnimations.size,
            activeLerpOperations: this.lerpOperations.size,
            beatSyncState: { ...this.beatSyncState },
            cssAnimationStates: this.cssAnimationStates.size
          };
        }
        /**
         * Cleanup consolidated systems on destroy
         */
        destroyConsolidatedSystems() {
          this.activeCSSAnimations.forEach((animation) => animation.cancel());
          this.activeCSSAnimations.clear();
          this.lerpOperations.clear();
          this.cssAnimationStates.clear();
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Consolidated systems destroyed");
          }
        }
        // ===================================================================
        // CSS ANIMATION MANAGER IMPLEMENTATION (replaces external CSSAnimationManager)
        // ===================================================================
        /**
         * Trigger consciousness breathing animation (legacy CSSAnimationManager API)
         * This method provides compatibility with systems expecting CSSAnimationManager
         */
        triggerConsciousnessBreathing(elements, energyLevel = 0.5, tempo = 120) {
          if (!elements) return;
          const elementsArray = Array.isArray(elements) ? elements : elements instanceof NodeList ? Array.from(elements) : [elements];
          elementsArray.forEach((element) => {
            if (element instanceof Element) {
              if (this.cssVariableManager) {
                this.cssVariableManager.batchSetVariables({
                  "--sn-consciousness-energy": energyLevel.toString(),
                  "--sn-consciousness-tempo": tempo.toString(),
                  "--sn-consciousness-duration": `${Math.max(1e3, 4e3 / Math.max(0.5, energyLevel))}ms`,
                  "--sn-consciousness-active": "1"
                });
              }
              element.classList.add("sn-consciousness-breathing");
              const duration = Math.max(1e3, 4e3 / Math.max(0.5, energyLevel));
              setTimeout(() => {
                element.classList.remove("sn-consciousness-breathing");
              }, duration);
            }
          });
          if (this.config.enableDebug) {
            console.log(`[EnhancedMasterAnimationCoordinator] Triggered consciousness breathing - Energy: ${energyLevel.toFixed(2)}, Tempo: ${tempo} BPM`);
          }
        }
        /**
         * Stop consciousness breathing animation (legacy CSSAnimationManager API)
         */
        stopConsciousnessBreathing() {
          const elementsWithBreathing = document.querySelectorAll(".sn-consciousness-breathing");
          elementsWithBreathing.forEach((element) => {
            element.classList.remove("sn-consciousness-breathing");
          });
          if (this.cssVariableManager) {
            this.cssVariableManager.batchSetVariables({
              "--sn-consciousness-active": "0",
              "--sn-consciousness-energy": "0",
              "--sn-consciousness-tempo": "120"
            });
          }
          if (this.config.enableDebug) {
            console.log("[EnhancedMasterAnimationCoordinator] Stopped consciousness breathing");
          }
        }
        /**
         * Trigger ripple effect animation
         * @deprecated CSS class .sn-ripple-effect does not exist in SCSS.
         * This method is currently non-functional and not used anywhere in the codebase.
         * TODO: Either implement the CSS class or remove this method entirely.
         */
        triggerRipple(element, intensity = 0.5) {
          if (!element || !(element instanceof Element)) return;
          if (this.cssVariableManager) {
            this.cssVariableManager.batchSetVariables({
              "--sn-ripple-intensity": intensity.toString(),
              "--sn-ripple-active": "1"
            });
          }
          element.classList.add("sn-ripple-effect");
          setTimeout(() => {
            element.classList.remove("sn-ripple-effect");
            if (this.cssVariableManager) {
              this.cssVariableManager.setVariable("--sn-ripple-active", "0");
            }
          }, 1e3);
        }
        /**
         * Get CSS Animation Manager interface for compatibility
         * This allows the EnhancedMasterAnimationCoordinator to act as its own CSSAnimationManager
         */
        getCSSAnimationManagerInterface() {
          return {
            triggerConsciousnessBreathing: this.triggerConsciousnessBreathing.bind(this),
            stopConsciousnessBreathing: this.stopConsciousnessBreathing.bind(this),
            triggerRipple: this.triggerRipple.bind(this)
          };
        }
      };
      __name(_EnhancedMasterAnimationCoordinator, "EnhancedMasterAnimationCoordinator");
      _EnhancedMasterAnimationCoordinator.instance = null;
      EnhancedMasterAnimationCoordinator = _EnhancedMasterAnimationCoordinator;
    }
  });

  // src-js/utils/core/ThemeUtilities.ts
  var ThemeUtilities_exports = {};
  __export(ThemeUtilities_exports, {
    adjustColor: () => adjustColor,
    bpmToAnimationFrameRate: () => bpmToAnimationFrameRate,
    bpmToInterval: () => bpmToInterval,
    calculateBreathingScale: () => calculateBreathingScale,
    calculateContrastRatio: () => calculateContrastRatio,
    calculateNavigationScale: () => calculateNavigationScale,
    calculateOklabDerivedProperties: () => calculateOklabDerivedProperties,
    calculateRhythmPhase: () => calculateRhythmPhase,
    colorDifference: () => colorDifference,
    debounce: () => debounce,
    easeBeatAnimation: () => easeBeatAnimation,
    findRequiredLuminance: () => findRequiredLuminance,
    generateHarmonicOklabColors: () => generateHarmonicOklabColors,
    getBeatPhase: () => getBeatPhase,
    getCanonicalAccent: () => getCanonicalAccent,
    getHealthMonitor: () => getHealthMonitor,
    getNextBeatTime: () => getNextBeatTime,
    getRootStyle: () => getRootStyle,
    hexToRgb: () => hexToRgb,
    hslToRgb: () => hslToRgb,
    intervalToBpm: () => intervalToBpm,
    isOnBeat: () => isOnBeat,
    isValidHexColor: () => isValidHexColor,
    lerp: () => lerp,
    lerpSmooth: () => lerpSmooth,
    lerpSmoothMusical: () => lerpSmoothMusical,
    lerpSmoothMusicalPerformance: () => lerpSmoothMusicalPerformance,
    lerpSmoothSimpleMusical: () => lerpSmoothSimpleMusical,
    oklabToRgb: () => oklabToRgb,
    processOklabColor: () => processOklabColor,
    rgbToHex: () => rgbToHex,
    rgbToHsl: () => rgbToHsl,
    rgbToOklab: () => rgbToOklab,
    sanitizeColorMap: () => sanitizeColorMap,
    sleep: () => sleep,
    throttle: () => throttle
  });
  function getRootStyle() {
    return document.documentElement;
  }
  function throttle(func, limit) {
    let inThrottle;
    return /* @__PURE__ */ __name(function throttled(...args) {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    }, "throttled");
  }
  function debounce(func, delay) {
    let timeoutId;
    return /* @__PURE__ */ __name(function debounced(...args) {
      clearTimeout(timeoutId);
      timeoutId = window.setTimeout(() => func(...args), delay);
    }, "debounced");
  }
  function isValidHexColor(value) {
    if (typeof value !== "string") {
      return false;
    }
    const trimmed = value.trim();
    const withHash = trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
    const hexPattern = /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$/;
    return hexPattern.test(withHash);
  }
  function hexToRgb(hex) {
    if (typeof hex !== "string") {
      return { r: 0, g: 0, b: 0 };
    }
    if (!isValidHexColor(hex)) {
      return { r: 0, g: 0, b: 0 };
    }
    const sanitizedHex = hex.trim();
    let processedHex = sanitizedHex.startsWith("#") ? sanitizedHex : `#${sanitizedHex}`;
    processedHex = processedHex.replace(/##+/g, "#");
    if (processedHex.length === 4) {
      processedHex = `#${processedHex[1]}${processedHex[1]}${processedHex[2]}${processedHex[2]}${processedHex[3]}${processedHex[3]}`;
    }
    const result = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(processedHex);
    if (result) {
      try {
        const rgb = {
          r: parseInt(result[1] || "0", 16),
          g: parseInt(result[2] || "0", 16),
          b: parseInt(result[3] || "0", 16)
        };
        return rgb;
      } catch (e) {
        return { r: 0, g: 0, b: 0 };
      }
    } else {
      return { r: 0, g: 0, b: 0 };
    }
  }
  function sanitizeColorMap(input) {
    console.log("\u{1F3A8} [ThemeUtilities] sanitizeColorMap input:", {
      input,
      inputKeys: input ? Object.keys(input) : [],
      inputEntries: input ? Object.entries(input) : []
    });
    const validHex = /^#?[0-9a-fA-F]{3}(?:[0-9a-fA-F]{3})?$/;
    const sanitized = {};
    if (!input || typeof input !== "object") {
      console.warn("\u{1F3A8} [ThemeUtilities] sanitizeColorMap: Invalid input type");
      return sanitized;
    }
    const droppedEntries = [];
    Object.entries(input).forEach(([key, value]) => {
      if (typeof value !== "string") {
        droppedEntries.push([key, value]);
        console.warn(`\u{1F3A8} [ThemeUtilities] Dropped non-string color: ${key} = ${value} (type: ${typeof value})`);
        return;
      }
      const trimmed = value.trim();
      if (!trimmed || trimmed === "undefined") {
        droppedEntries.push([key, value]);
        console.warn(`\u{1F3A8} [ThemeUtilities] Dropped empty/undefined color: ${key} = "${value}"`);
        return;
      }
      if (!validHex.test(trimmed)) {
        droppedEntries.push([key, value]);
        console.warn(`\u{1F3A8} [ThemeUtilities] Dropped invalid hex color: ${key} = "${value}"`);
        return;
      }
      const normalised = trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
      sanitized[key] = normalised;
    });
    console.log("\u{1F3A8} [ThemeUtilities] sanitizeColorMap output:", {
      sanitized,
      sanitizedKeys: Object.keys(sanitized),
      sanitizedEntries: Object.entries(sanitized),
      droppedCount: droppedEntries.length,
      droppedEntries
    });
    if (ADVANCED_SYSTEM_CONFIG?.enableDebug && Object.keys(input).length !== Object.keys(sanitized).length) {
      console.warn(
        `[StarryNight sanitizeColorMap] Dropped ${Object.keys(input).length - Object.keys(sanitized).length} invalid colour entries.`
      );
    }
    return sanitized;
  }
  function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h = 0, s = 0, l = (max + min) / 2;
    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }
    return { h: h * 360, s: s * 100, l: l * 100 };
  }
  function hslToRgb(h, s, l) {
    h /= 360;
    s /= 100;
    l /= 100;
    const hue2rgb = /* @__PURE__ */ __name((p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }, "hue2rgb");
    let r_val, g_val, b_val;
    if (s === 0) {
      r_val = g_val = b_val = l;
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r_val = hue2rgb(p, q, h + 1 / 3);
      g_val = hue2rgb(p, q, h);
      b_val = hue2rgb(p, q, h - 1 / 3);
    }
    return {
      r: Math.round(r_val * 255),
      g: Math.round(g_val * 255),
      b: Math.round(b_val * 255)
    };
  }
  function rgbToHex(r, g, b) {
    const normalize = /* @__PURE__ */ __name((c) => {
      if (!Number.isFinite(c)) return 0;
      const scaled = c <= 1 ? c * 255 : c;
      return Math.min(255, Math.max(0, Math.round(scaled)));
    }, "normalize");
    const [nr, ng, nb] = [normalize(r), normalize(g), normalize(b)];
    return "#" + [nr, ng, nb].map((channel) => channel.toString(16).padStart(2, "0")).join("");
  }
  function calculateContrastRatio(color1, color22) {
    const getLuminance = /* @__PURE__ */ __name((rgb) => {
      const [r_val = 0, g_val = 0, b_val = 0] = [rgb.r, rgb.g, rgb.b].map((c) => {
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * r_val + 0.7152 * g_val + 0.0722 * b_val;
    }, "getLuminance");
    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color22);
    if (!rgb1 || !rgb2) return 1;
    const lum1 = getLuminance(rgb1);
    const lum2 = getLuminance(rgb2);
    const brightest = Math.max(lum1, lum2);
    const darkest = Math.min(lum1, lum2);
    return (brightest + 0.05) / (darkest + 0.05);
  }
  function lerpSmooth(current, target, deltaTime, halfLife) {
    const EPSILON = 1e-5;
    if (halfLife <= EPSILON || deltaTime <= 0) {
      if (ADVANCED_SYSTEM_CONFIG?.enableDebug) {
        if (halfLife <= EPSILON) {
        }
      }
      return target;
    }
    const result = target + (current - target) * Math.pow(2, -deltaTime / halfLife);
    return result;
  }
  function lerpSmoothMusical(current, target, deltaTime, musicContext, animationType = "flow", baseHalfLife) {
    const musicalParams = EnhancedMasterAnimationCoordinator.calculateMusicalLerp(
      musicContext,
      animationType,
      baseHalfLife
    );
    return lerpSmooth(current, target, deltaTime, musicalParams.halfLife);
  }
  function lerpSmoothMusicalPerformance(current, target, deltaTime, musicContext, performanceCoordinator, animationType = "flow", baseHalfLife) {
    if (!performanceCoordinator?.calculatePerformanceAwareMusicalLerp) {
      return lerpSmoothMusical(current, target, deltaTime, musicContext, animationType, baseHalfLife);
    }
    return performanceCoordinator.calculatePerformanceAwareMusicalLerp(
      current,
      target,
      deltaTime,
      musicContext,
      animationType,
      baseHalfLife
    );
  }
  function lerpSmoothSimpleMusical(current, target, deltaTime, tempo = 120, energy = 0.5, baseHalfLife = 0.15) {
    const tempoFactor = Math.pow(tempo / 120, 0.3);
    const energyFactor = 1 + energy * 0.3;
    const musicalHalfLife = baseHalfLife / tempoFactor * energyFactor;
    return lerpSmooth(current, target, deltaTime, musicalHalfLife);
  }
  function bpmToInterval(bpm) {
    if (!bpm || bpm <= 0) return 500;
    return 6e4 / bpm;
  }
  function intervalToBpm(intervalMs) {
    if (!intervalMs || intervalMs <= 0) return 120;
    return 6e4 / intervalMs;
  }
  function bpmToAnimationFrameRate(bpm, framesPerBeat = 4) {
    const beatInterval = bpmToInterval(bpm);
    return beatInterval / framesPerBeat;
  }
  function isOnBeat(currentTime, trackStartTime, bpm, tolerance = 50) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatPosition = timeSinceStart % beatInterval;
    return beatPosition <= tolerance || beatPosition >= beatInterval - tolerance;
  }
  function getBeatPhase(currentTime, trackStartTime, bpm) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatPosition = timeSinceStart % beatInterval;
    return beatPosition / beatInterval;
  }
  function getNextBeatTime(currentTime, trackStartTime, bpm) {
    const beatInterval = bpmToInterval(bpm);
    const timeSinceStart = currentTime - trackStartTime;
    const beatsElapsed = Math.floor(timeSinceStart / beatInterval);
    return trackStartTime + (beatsElapsed + 1) * beatInterval;
  }
  function easeBeatAnimation(beatPhase, easingType = "ease-out") {
    switch (easingType) {
      case "ease-in":
        return beatPhase * beatPhase;
      case "linear":
        return beatPhase;
      case "ease-out":
      default:
        return beatPhase * (2 - beatPhase);
    }
  }
  function calculateRhythmPhase(currentTime, animationSpeedFactor = 1) {
    const speed = 1e-3 * animationSpeedFactor;
    return currentTime * speed % (2 * Math.PI);
  }
  function calculateBreathingScale(rhythmPhase, processedEnergy = 0.5) {
    const baseScale = 1;
    const pulseAmount = 0.02 * processedEnergy;
    const breath = Math.sin(rhythmPhase) * pulseAmount;
    return baseScale + breath;
  }
  function calculateNavigationScale(visualIntensity = 0.5, moodIdentifier = "neutral") {
    const baseScale = 1;
    const moodFactor = moodIdentifier === "energetic" ? 1.2 : moodIdentifier === "calm" ? 0.8 : 1;
    return baseScale + 0.05 * visualIntensity * moodFactor;
  }
  function rgbToOklab(r_srgb, g_srgb, b_srgb) {
    const r = r_srgb / 255;
    const g = g_srgb / 255;
    const b = b_srgb / 255;
    const l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l_ = Math.cbrt(l);
    const m_ = Math.cbrt(m);
    const s_ = Math.cbrt(s);
    return {
      L: 0.2104542553 * l_ + 0.793617785 * m_ - 0.0040720468 * s_,
      a: 1.9779984951 * l_ - 2.428592205 * m_ + 0.4505937099 * s_,
      b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.808675766 * s_
    };
  }
  function oklabToRgb(L, a, b_oklab) {
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b_oklab;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b_oklab;
    const s_ = L - 0.0894841775 * a - 1.291485548 * b_oklab;
    const l = l_ * l_ * l_;
    const m = m_ * m_ * m_;
    const s = s_ * s_ * s_;
    let r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
    let g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
    let b = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s;
    r = Math.round(Math.max(0, Math.min(1, r)) * 255);
    g = Math.round(Math.max(0, Math.min(1, g)) * 255);
    b = Math.round(Math.max(0, Math.min(1, b)) * 255);
    return { r, g, b };
  }
  function processOklabColor(oklabColor, context = {}) {
    const { L, a, b } = oklabColor;
    const C = Math.sqrt(a * a + b * b);
    let h_rad = Math.atan2(b, a);
    if (h_rad < 0) {
      h_rad += 2 * Math.PI;
    }
    const h = h_rad * (180 / Math.PI);
    const {
      energy = 0.5,
      valence = 0.5,
      artisticMode = "artist-vision"
    } = context;
    const multipliers = ADVANCED_SYSTEM_CONFIG.getCurrentMultipliers();
    let adjusted_L = L * (1 + (valence - 0.5) * 0.1);
    let adjusted_C = C * (1 + (energy - 0.5) * 0.2) * (multipliers?.saturation || 1);
    adjusted_L = Math.max(
      0,
      Math.min(1, adjusted_L * (multipliers?.brightness || 1))
    );
    return {
      L: adjusted_L,
      C: adjusted_C,
      h: C > 1e-3 ? h : null
      // Hue is meaningless if chroma is near zero
    };
  }
  function calculateOklabDerivedProperties(oklabColor) {
    const { L, C, h } = processOklabColor(oklabColor);
    const isWarm = h !== null ? h >= 0 && h < 90 || h >= 270 && h <= 360 : false;
    const isCool = h !== null ? h >= 90 && h < 270 : false;
    let mood = "neutral";
    if (L > 0.7 && C > 0.1) mood = "bright";
    else if (L < 0.4) mood = "dark";
    else if (isWarm && C > 0.1) mood = "warm";
    else if (isCool && C > 0.1) mood = "cool";
    return {
      lightness: L,
      chroma: C,
      hue: h,
      isWarm,
      isCool,
      mood
    };
  }
  function generateHarmonicOklabColors(baseOklabColor, rule = "analogous", angle = 30) {
    const baseLCH = processOklabColor(baseOklabColor);
    if (baseLCH.h === null) {
      return [baseOklabColor];
    }
    const getOklabFromLCH = /* @__PURE__ */ __name((l_val, c_val, h_deg_val) => {
      const h_rad = h_deg_val * (Math.PI / 180);
      const a_val = c_val * Math.cos(h_rad);
      const b_val = c_val * Math.sin(h_rad);
      return { L: l_val, a: a_val, b: b_val };
    }, "getOklabFromLCH");
    const colors = [baseOklabColor];
    const { L, C, h } = baseLCH;
    switch (rule) {
      case "complementary":
        colors.push(getOklabFromLCH(L, C, (h + 180) % 360));
        break;
      case "analogous":
        colors.push(getOklabFromLCH(L, C, (h + angle) % 360));
        colors.push(getOklabFromLCH(L, C, (h - angle + 360) % 360));
        break;
      case "triadic":
        colors.push(getOklabFromLCH(L, C, (h + 120) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 240) % 360));
        break;
      case "tetradic":
        colors.push(getOklabFromLCH(L, C, (h + 90) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 180) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 270) % 360));
        break;
      case "split-complementary":
        colors.push(getOklabFromLCH(L, C, (h + 180 - angle) % 360));
        colors.push(getOklabFromLCH(L, C, (h + 180 + angle) % 360));
        break;
      case "monochromatic":
        colors.push({
          L: Math.max(0, L - 0.2),
          a: baseOklabColor.a,
          b: baseOklabColor.b
        });
        colors.push({
          L: Math.min(1, L + 0.2),
          a: baseOklabColor.a,
          b: baseOklabColor.b
        });
        break;
    }
    return colors;
  }
  function lerp(start, end, amt) {
    return (1 - amt) * start + amt * end;
  }
  function colorDifference(rgb1, rgb2) {
    const lab1 = rgbToOklab(rgb1.r, rgb1.g, rgb1.b);
    const lab2 = rgbToOklab(rgb2.r, rgb2.g, rgb2.b);
    const deltaL = lab1.L - lab2.L;
    const deltaA = lab1.a - lab2.a;
    const deltaB = lab1.b - lab2.b;
    return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
  }
  function getHealthMonitor() {
    return healthMonitorInstance;
  }
  function findRequiredLuminance(color1, color22, ratio) {
    const getLuminance = /* @__PURE__ */ __name((rgb) => {
      const [r_val = 0, g_val = 0, b_val = 0] = [rgb.r, rgb.g, rgb.b].map((c) => {
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * r_val + 0.7152 * g_val + 0.0722 * b_val;
    }, "getLuminance");
    const lum2 = getLuminance(color22);
    let targetLuminance;
    targetLuminance = ratio * (lum2 + 0.05) - 0.05;
    const hsl = rgbToHsl(color1.r, color1.g, color1.b);
    const currentLuminance = getLuminance(color1);
    const luminanceRatio = targetLuminance / currentLuminance;
    return hsl.l;
  }
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function adjustColor(rgb, {
    brightness = 1,
    saturation = 1,
    hue = 0
  }) {
    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
    hsl.h = (hsl.h + hue) % 360;
    hsl.s = Math.max(0, Math.min(100, hsl.s * saturation));
    hsl.l = Math.max(0, Math.min(100, hsl.l * brightness));
    return hslToRgb(hsl.h, hsl.s, hsl.l);
  }
  function getCanonicalAccent() {
    const root = getRootStyle();
    const styles = getComputedStyle(root);
    let hex = styles.getPropertyValue("--sn-accent-hex").trim();
    let rgb = styles.getPropertyValue("--sn-accent-rgb").trim();
    if (!hex && rgb) {
      const [rStr = "0", gStr = "0", bStr = "0"] = rgb.split(/\s*,\s*/);
      const r = parseInt(rStr, 10) || 0;
      const g = parseInt(gStr, 10) || 0;
      const b = parseInt(bStr, 10) || 0;
      hex = rgbToHex(r, g, b);
    }
    if (!rgb && hex) {
      const rgbObj = hexToRgb(hex);
      if (rgbObj) {
        rgb = `${rgbObj.r},${rgbObj.g},${rgbObj.b}`;
      }
    }
    return { hex, rgb };
  }
  var _HealthMonitor, HealthMonitor, healthMonitorInstance;
  var init_ThemeUtilities = __esm({
    "src-js/utils/core/ThemeUtilities.ts"() {
      "use strict";
      init_globalConfig();
      init_EnhancedMasterAnimationCoordinator();
      __name(getRootStyle, "getRootStyle");
      __name(throttle, "throttle");
      __name(debounce, "debounce");
      __name(isValidHexColor, "isValidHexColor");
      __name(hexToRgb, "hexToRgb");
      __name(sanitizeColorMap, "sanitizeColorMap");
      __name(rgbToHsl, "rgbToHsl");
      __name(hslToRgb, "hslToRgb");
      __name(rgbToHex, "rgbToHex");
      __name(calculateContrastRatio, "calculateContrastRatio");
      __name(lerpSmooth, "lerpSmooth");
      __name(lerpSmoothMusical, "lerpSmoothMusical");
      __name(lerpSmoothMusicalPerformance, "lerpSmoothMusicalPerformance");
      __name(lerpSmoothSimpleMusical, "lerpSmoothSimpleMusical");
      __name(bpmToInterval, "bpmToInterval");
      __name(intervalToBpm, "intervalToBpm");
      __name(bpmToAnimationFrameRate, "bpmToAnimationFrameRate");
      __name(isOnBeat, "isOnBeat");
      __name(getBeatPhase, "getBeatPhase");
      __name(getNextBeatTime, "getNextBeatTime");
      __name(easeBeatAnimation, "easeBeatAnimation");
      __name(calculateRhythmPhase, "calculateRhythmPhase");
      __name(calculateBreathingScale, "calculateBreathingScale");
      __name(calculateNavigationScale, "calculateNavigationScale");
      __name(rgbToOklab, "rgbToOklab");
      __name(oklabToRgb, "oklabToRgb");
      __name(processOklabColor, "processOklabColor");
      __name(calculateOklabDerivedProperties, "calculateOklabDerivedProperties");
      __name(generateHarmonicOklabColors, "generateHarmonicOklabColors");
      __name(lerp, "lerp");
      __name(colorDifference, "colorDifference");
      _HealthMonitor = class _HealthMonitor {
        registerSystem(name, instance2) {
        }
        updateSystemMetrics(name, metrics) {
        }
      };
      __name(_HealthMonitor, "HealthMonitor");
      HealthMonitor = _HealthMonitor;
      healthMonitorInstance = new HealthMonitor();
      __name(getHealthMonitor, "getHealthMonitor");
      __name(findRequiredLuminance, "findRequiredLuminance");
      __name(sleep, "sleep");
      __name(adjustColor, "adjustColor");
      __name(getCanonicalAccent, "getCanonicalAccent");
    }
  });

  // src-js/utils/color/OKLABColorProcessor.ts
  var _OKLABColorProcessor, OKLABColorProcessor;
  var init_OKLABColorProcessor = __esm({
    "src-js/utils/color/OKLABColorProcessor.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_ThemeUtilities();
      _OKLABColorProcessor = class _OKLABColorProcessor {
        constructor(enableDebug = false) {
          this.utils = ThemeUtilities_exports;
          this.debugEnabled = enableDebug;
        }
        /**
         * Process a color through OKLAB space with enhancement preset
         */
        processColor(hexColor, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const startTime = performance.now();
          let originalRgb = null;
          try {
            originalRgb = this.utils.hexToRgb(hexColor);
            if (!originalRgb) {
              throw new Error(`Invalid hex color: ${hexColor}`);
            }
            const oklabOriginal = this.utils.rgbToOklab(
              originalRgb.r,
              originalRgb.g,
              originalRgb.b
            );
            const oklabEnhanced = this.enhanceOKLABColor(oklabOriginal, preset);
            const oklabShadow = this.generateShadowColor(oklabOriginal, preset);
            const enhancedRgb = this.utils.oklabToRgb(
              oklabEnhanced.L,
              oklabEnhanced.a,
              oklabEnhanced.b
            );
            const shadowRgb = this.utils.oklabToRgb(
              oklabShadow.L,
              oklabShadow.a,
              oklabShadow.b
            );
            const enhancedHex = this.utils.rgbToHex(
              enhancedRgb.r,
              enhancedRgb.g,
              enhancedRgb.b
            );
            const shadowHex = this.utils.rgbToHex(
              shadowRgb.r,
              shadowRgb.g,
              shadowRgb.b
            );
            const oklchEnhanced = this.convertOklabToOklch(oklabEnhanced);
            const processingTime = performance.now() - startTime;
            const result = {
              originalHex: hexColor,
              originalRgb,
              enhancedHex,
              enhancedRgb,
              shadowHex,
              shadowRgb,
              oklabOriginal,
              oklabEnhanced,
              oklabShadow,
              oklchEnhanced,
              processingTime
            };
            if (this.debugEnabled) {
              Y3KDebug?.debug?.log("OKLABColorProcessor", "Color processed:", {
                input: hexColor,
                enhanced: enhancedHex,
                shadow: shadowHex,
                preset: preset.name,
                processingTime: `${processingTime.toFixed(2)}ms`
              });
            }
            return result;
          } catch (error) {
            if (this.debugEnabled) {
              Y3KDebug?.debug?.error(
                "OKLABColorProcessor",
                "Color processing failed:",
                error
              );
            }
            const fallbackRgb = originalRgb || { r: 124, g: 58, b: 237 };
            return this.createFallbackResult(hexColor, fallbackRgb);
          }
        }
        /**
         * Process multiple colors with consistent enhancement
         */
        processColorPalette(colors, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const results = {};
          Object.entries(colors).forEach(([key, hex]) => {
            if (hex && this.utils.hexToRgb(hex)) {
              results[key] = this.processColor(hex, preset);
            }
          });
          return results;
        }
        /**
         * Generate CSS variables from processed color
         */
        generateCSSVariables(processed, prefix = "sn-oklab") {
          const cssVars = {};
          cssVars[`--${prefix}-enhanced-hex`] = processed.enhancedHex;
          cssVars[`--${prefix}-enhanced-rgb`] = `${processed.enhancedRgb.r},${processed.enhancedRgb.g},${processed.enhancedRgb.b}`;
          cssVars[`--${prefix}-enhanced-r`] = Math.round(
            processed.enhancedRgb.r
          ).toString();
          cssVars[`--${prefix}-enhanced-g`] = Math.round(
            processed.enhancedRgb.g
          ).toString();
          cssVars[`--${prefix}-enhanced-b`] = Math.round(
            processed.enhancedRgb.b
          ).toString();
          cssVars[`--${prefix}-shadow-hex`] = processed.shadowHex;
          cssVars[`--${prefix}-shadow-rgb`] = `${processed.shadowRgb.r},${processed.shadowRgb.g},${processed.shadowRgb.b}`;
          cssVars[`--${prefix}-lightness`] = processed.oklabEnhanced.L.toFixed(3);
          cssVars[`--${prefix}-chroma-a`] = processed.oklabEnhanced.a.toFixed(3);
          cssVars[`--${prefix}-chroma-b`] = processed.oklabEnhanced.b.toFixed(3);
          cssVars[`--${prefix}-oklch-l`] = processed.oklchEnhanced.L.toFixed(3);
          cssVars[`--${prefix}-oklch-c`] = processed.oklchEnhanced.C.toFixed(3);
          cssVars[`--${prefix}-oklch-h`] = processed.oklchEnhanced.H.toFixed(1);
          return cssVars;
        }
        /**
         * Interpolate between two colors in OKLAB space
         */
        interpolateOKLAB(color1Hex, color2Hex, factor, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const rgb1 = this.utils.hexToRgb(color1Hex);
          const rgb2 = this.utils.hexToRgb(color2Hex);
          if (!rgb1 || !rgb2) {
            throw new Error("Invalid hex colors for interpolation");
          }
          const oklab1 = this.utils.rgbToOklab(rgb1.r, rgb1.g, rgb1.b);
          const oklab2 = this.utils.rgbToOklab(rgb2.r, rgb2.g, rgb2.b);
          const interpolatedOklab = {
            L: oklab1.L + (oklab2.L - oklab1.L) * factor,
            a: oklab1.a + (oklab2.a - oklab1.a) * factor,
            b: oklab1.b + (oklab2.b - oklab1.b) * factor
          };
          const interpolatedRgb = this.utils.oklabToRgb(
            interpolatedOklab.L,
            interpolatedOklab.a,
            interpolatedOklab.b
          );
          const interpolatedHex = this.utils.rgbToHex(
            interpolatedRgb.r,
            interpolatedRgb.g,
            interpolatedRgb.b
          );
          return this.processColor(interpolatedHex, preset);
        }
        /**
         * Generate gradient stops in OKLAB space
         */
        generateOKLABGradient(startHex, endHex, stopCount = 5, preset = _OKLABColorProcessor.PRESETS.STANDARD) {
          const gradientStops = [];
          for (let i = 0; i < stopCount; i++) {
            const factor = i / (stopCount - 1);
            const interpolated = this.interpolateOKLAB(
              startHex,
              endHex,
              factor,
              preset
            );
            gradientStops.push(interpolated);
          }
          return gradientStops;
        }
        /**
         * Enhance color in OKLAB space
         */
        enhanceOKLABColor(oklab, preset) {
          const currentChroma = Math.sqrt(oklab.a * oklab.a + oklab.b * oklab.b);
          const enhancedL = Math.min(1, Math.max(0, oklab.L * preset.lightnessBoost));
          const chromaMultiplier = currentChroma > preset.vibrantThreshold ? preset.chromaBoost : 1;
          const enhancedA = oklab.a * chromaMultiplier;
          const enhancedB = oklab.b * chromaMultiplier;
          return { L: enhancedL, a: enhancedA, b: enhancedB };
        }
        /**
         * Generate shadow color by reducing lightness while preserving hue
         */
        generateShadowColor(oklab, preset) {
          return {
            L: Math.max(0.02, oklab.L * preset.shadowReduction),
            a: oklab.a * 0.8,
            // Slightly desaturate shadows
            b: oklab.b * 0.8
          };
        }
        /**
         * Convert OKLAB to OKLCH (cylindrical representation)
         */
        convertOklabToOklch(oklab) {
          const L = oklab.L;
          const C = Math.sqrt(oklab.a * oklab.a + oklab.b * oklab.b);
          let H = Math.atan2(oklab.b, oklab.a) * (180 / Math.PI);
          if (H < 0) H += 360;
          return { L, C, H };
        }
        /**
         * Create fallback result for error cases
         */
        createFallbackResult(hexColor, fallbackRgb) {
          const fallbackOklab = this.utils.rgbToOklab(
            fallbackRgb.r,
            fallbackRgb.g,
            fallbackRgb.b
          );
          return {
            originalHex: hexColor,
            originalRgb: fallbackRgb,
            enhancedHex: hexColor,
            enhancedRgb: fallbackRgb,
            shadowHex: "#000000",
            shadowRgb: { r: 0, g: 0, b: 0 },
            oklabOriginal: fallbackOklab,
            oklabEnhanced: fallbackOklab,
            oklabShadow: { L: 0.05, a: 0, b: 0 },
            oklchEnhanced: this.convertOklabToOklch(fallbackOklab),
            processingTime: 0
          };
        }
        /**
         * Get preset by name with fallback
         */
        static getPreset(name) {
          return _OKLABColorProcessor.PRESETS[name.toUpperCase()] || _OKLABColorProcessor.PRESETS.STANDARD;
        }
        /**
         * Create custom preset
         */
        static createCustomPreset(name, description, lightnessBoost, chromaBoost, shadowReduction = 0.3, vibrantThreshold = 0.1) {
          return {
            name,
            description,
            lightnessBoost: Math.max(0.5, Math.min(1.5, lightnessBoost)),
            chromaBoost: Math.max(0.5, Math.min(2, chromaBoost)),
            shadowReduction: Math.max(0.1, Math.min(0.5, shadowReduction)),
            vibrantThreshold: Math.max(0.05, Math.min(0.2, vibrantThreshold))
          };
        }
      };
      __name(_OKLABColorProcessor, "OKLABColorProcessor");
      // Built-in enhancement presets
      _OKLABColorProcessor.PRESETS = {
        SUBTLE: {
          name: "Subtle Enhancement",
          description: "Minimal color enhancement for conservative aesthetics",
          lightnessBoost: 1.05,
          chromaBoost: 1.1,
          shadowReduction: 0.4,
          vibrantThreshold: 0.08
        },
        STANDARD: {
          name: "Standard Enhancement",
          description: "Balanced color enhancement for general use",
          lightnessBoost: 1.1,
          chromaBoost: 1.15,
          shadowReduction: 0.3,
          vibrantThreshold: 0.1
        },
        VIBRANT: {
          name: "Vibrant Enhancement",
          description: "Enhanced vibrancy for dynamic color experiences",
          lightnessBoost: 1.15,
          chromaBoost: 1.25,
          shadowReduction: 0.25,
          vibrantThreshold: 0.12
        },
        COSMIC: {
          name: "Cosmic Enhancement",
          description: "Maximum enhancement for Year 3000 visual-effects experiences",
          lightnessBoost: 1.1,
          // Reduced from 1.2
          chromaBoost: 1.2,
          // Reduced from 1.35
          shadowReduction: 0.2,
          vibrantThreshold: 0.15
        }
      };
      OKLABColorProcessor = _OKLABColorProcessor;
    }
  });

  // src-js/audio/GenreCalculator.ts
  var _GenreCalculator, GenreCalculator;
  var init_GenreCalculator = __esm({
    "src-js/audio/GenreCalculator.ts"() {
      "use strict";
      _GenreCalculator = class _GenreCalculator {
        constructor() {
          this.coreParameters = {
            electronic: {
              energy: 0.85,
              organicSynthetic: 0.9,
              rhythmComplexity: 0.6,
              harmonicSophistication: 0.5,
              dynamicRange: 0.4,
              tempo: "fast",
              accessibility: 0.7,
              emotionalRange: "wide"
            },
            rock: {
              energy: 0.8,
              organicSynthetic: 0.3,
              rhythmComplexity: 0.6,
              harmonicSophistication: 0.5,
              dynamicRange: 0.7,
              tempo: "medium",
              accessibility: 0.8,
              emotionalRange: "wide"
            },
            classical: {
              energy: 0.4,
              organicSynthetic: 0.1,
              rhythmComplexity: 0.7,
              harmonicSophistication: 0.9,
              dynamicRange: 0.9,
              tempo: "variable",
              accessibility: 0.4,
              emotionalRange: "extreme"
            },
            jazz: {
              energy: 0.5,
              organicSynthetic: 0.2,
              rhythmComplexity: 0.8,
              harmonicSophistication: 0.9,
              dynamicRange: 0.7,
              tempo: "medium",
              accessibility: 0.5,
              emotionalRange: "wide"
            },
            hiphop: {
              energy: 0.7,
              organicSynthetic: 0.6,
              rhythmComplexity: 0.7,
              harmonicSophistication: 0.4,
              dynamicRange: 0.5,
              tempo: "medium",
              accessibility: 0.9,
              emotionalRange: "moderate"
            },
            ambient: {
              energy: 0.2,
              organicSynthetic: 0.7,
              rhythmComplexity: 0.2,
              harmonicSophistication: 0.6,
              dynamicRange: 0.6,
              tempo: "slow",
              accessibility: 0.5,
              emotionalRange: "narrow"
            },
            pop: {
              energy: 0.6,
              organicSynthetic: 0.5,
              rhythmComplexity: 0.4,
              harmonicSophistication: 0.3,
              dynamicRange: 0.3,
              tempo: "medium",
              accessibility: 0.95,
              emotionalRange: "moderate"
            },
            folk: {
              energy: 0.4,
              organicSynthetic: 0.1,
              rhythmComplexity: 0.3,
              harmonicSophistication: 0.5,
              dynamicRange: 0.6,
              tempo: "medium",
              accessibility: 0.7,
              emotionalRange: "moderate"
            },
            metal: {
              energy: 0.95,
              organicSynthetic: 0.4,
              rhythmComplexity: 0.8,
              harmonicSophistication: 0.6,
              dynamicRange: 0.6,
              tempo: "fast",
              accessibility: 0.5,
              emotionalRange: "extreme"
            },
            punk: {
              energy: 0.9,
              organicSynthetic: 0.2,
              rhythmComplexity: 0.3,
              harmonicSophistication: 0.2,
              dynamicRange: 0.5,
              tempo: "fast",
              accessibility: 0.6,
              emotionalRange: "moderate"
            },
            indie: {
              energy: 0.5,
              organicSynthetic: 0.3,
              rhythmComplexity: 0.5,
              harmonicSophistication: 0.6,
              dynamicRange: 0.7,
              tempo: "medium",
              accessibility: 0.6,
              emotionalRange: "wide"
            },
            reggae: {
              energy: 0.5,
              organicSynthetic: 0.3,
              rhythmComplexity: 0.6,
              harmonicSophistication: 0.4,
              dynamicRange: 0.5,
              tempo: "medium",
              accessibility: 0.7,
              emotionalRange: "moderate"
            },
            blues: {
              energy: 0.5,
              organicSynthetic: 0.2,
              rhythmComplexity: 0.4,
              harmonicSophistication: 0.6,
              dynamicRange: 0.7,
              tempo: "slow",
              accessibility: 0.6,
              emotionalRange: "wide"
            },
            country: {
              energy: 0.5,
              organicSynthetic: 0.2,
              rhythmComplexity: 0.3,
              harmonicSophistication: 0.4,
              dynamicRange: 0.6,
              tempo: "medium",
              accessibility: 0.8,
              emotionalRange: "moderate"
            },
            techno: {
              energy: 0.85,
              organicSynthetic: 0.95,
              rhythmComplexity: 0.7,
              harmonicSophistication: 0.4,
              dynamicRange: 0.3,
              tempo: "fast",
              accessibility: 0.6,
              emotionalRange: "narrow"
            },
            house: {
              energy: 0.75,
              organicSynthetic: 0.85,
              rhythmComplexity: 0.5,
              harmonicSophistication: 0.4,
              dynamicRange: 0.4,
              tempo: "fast",
              accessibility: 0.8,
              emotionalRange: "moderate"
            },
            trance: {
              energy: 0.8,
              organicSynthetic: 0.9,
              rhythmComplexity: 0.4,
              harmonicSophistication: 0.5,
              dynamicRange: 0.5,
              tempo: "fast",
              accessibility: 0.7,
              emotionalRange: "wide"
            },
            dubstep: {
              energy: 0.9,
              organicSynthetic: 0.95,
              rhythmComplexity: 0.8,
              harmonicSophistication: 0.3,
              dynamicRange: 0.8,
              tempo: "medium",
              accessibility: 0.5,
              emotionalRange: "extreme"
            },
            funk: {
              energy: 0.7,
              organicSynthetic: 0.3,
              rhythmComplexity: 0.8,
              harmonicSophistication: 0.6,
              dynamicRange: 0.6,
              tempo: "medium",
              accessibility: 0.7,
              emotionalRange: "moderate"
            },
            default: {
              energy: 0.5,
              organicSynthetic: 0.5,
              rhythmComplexity: 0.5,
              harmonicSophistication: 0.5,
              dynamicRange: 0.5,
              tempo: "medium",
              accessibility: 0.7,
              emotionalRange: "moderate"
            }
          };
          this.characteristicsCache = /* @__PURE__ */ new Map();
          this.visualStyleCache = /* @__PURE__ */ new Map();
        }
        static getInstance() {
          if (!_GenreCalculator.instance) {
            _GenreCalculator.instance = new _GenreCalculator();
          }
          return _GenreCalculator.instance;
        }
        calculateCharacteristics(genre) {
          const genreKey = genre;
          if (this.characteristicsCache.has(genreKey)) {
            return this.characteristicsCache.get(genreKey);
          }
          const core = this.coreParameters[genreKey] || this.coreParameters.default;
          const characteristics = {
            bassEmphasis: this.calculateBassEmphasis(core),
            midFrequencyPattern: this.calculateMidFrequencyPattern(core),
            trebleSharpness: this.calculateTrebleSharpness(core),
            dynamicRange: core.dynamicRange,
            rhythmComplexity: core.rhythmComplexity,
            syncopation: this.calculateSyncopation(core),
            grooveWeight: this.calculateGrooveWeight(core),
            tempoVariability: this.calculateTempoVariability(core),
            musicalComplexity: core.harmonicSophistication,
            dissonanceTolerance: this.calculateDissonanceTolerance(core),
            modalInfluence: this.calculateModalInfluence(core),
            microtonal: this.calculateMicrotonal(core),
            compression: this.calculateCompression(core),
            saturation: this.calculateSaturation(core),
            stereoWidth: this.calculateStereoWidth(core),
            artificialProcessing: core.organicSynthetic,
            smoothness: this.calculateSmoothness(core),
            accessibility: core.accessibility,
            experimentalFactor: this.calculateExperimentalFactor(core),
            emotionalRange: this.emotionalRangeToNumber(core.emotionalRange)
          };
          this.characteristicsCache.set(genreKey, characteristics);
          return characteristics;
        }
        calculateVisualStyle(genre) {
          const genreKey = genre;
          if (this.visualStyleCache.has(genreKey)) {
            return this.visualStyleCache.get(genreKey);
          }
          const core = this.coreParameters[genreKey] || this.coreParameters.default;
          const visualStyle = {
            primaryHueRange: this.calculatePrimaryHueRange(core),
            saturationProfile: this.calculateSaturationProfile(core),
            brightnessProfile: this.calculateBrightnessProfile(core),
            contrastLevel: this.calculateContrastLevel(core),
            gradientComplexity: this.calculateGradientComplexity(core),
            shapeGeometry: this.calculateShapeGeometry(core),
            edgeSharpness: this.calculateEdgeSharpness(core),
            symmetryLevel: this.calculateSymmetryLevel(core),
            animationStyle: this.calculateAnimationStyle(core),
            pulseBehavior: this.calculatePulseBehavior(core),
            flowDirection: this.calculateFlowDirection(core),
            transitionCharacter: this.calculateTransitionCharacter(core),
            layerBlending: this.calculateLayerBlending(core),
            depthIllusion: this.calculateDepthIllusion(core),
            particleInfluence: this.calculateParticleInfluence(core),
            nebulaCharacter: this.calculateNebulaCharacter(core),
            memoryInfluence: this.calculateMemoryInfluence(core),
            adaptationSpeed: this.calculateAdaptationSpeed(core),
            stabilityPreference: this.calculateStabilityPreference(core),
            emergencePattern: this.calculateEmergencePattern(core)
          };
          this.visualStyleCache.set(genreKey, visualStyle);
          return visualStyle;
        }
        // GenreCharacteristics calculation methods
        calculateBassEmphasis(core) {
          return (1 - core.organicSynthetic) * 0.3 + core.energy * 0.5 + core.rhythmComplexity * 0.2;
        }
        calculateMidFrequencyPattern(core) {
          return core.harmonicSophistication * 0.6 + (1 - core.organicSynthetic) * 0.4;
        }
        calculateTrebleSharpness(core) {
          return core.organicSynthetic * 0.7 + core.energy * 0.3;
        }
        calculateSyncopation(core) {
          return core.rhythmComplexity * 0.8 + (1 - core.accessibility) * 0.2;
        }
        calculateGrooveWeight(core) {
          return core.rhythmComplexity * 0.5 + (1 - core.organicSynthetic) * 0.3 + core.accessibility * 0.2;
        }
        calculateTempoVariability(core) {
          if (core.tempo === "variable") return 0.8;
          return (1 - core.accessibility) * 0.5 + core.harmonicSophistication * 0.3;
        }
        calculateDissonanceTolerance(core) {
          return (1 - core.accessibility) * 0.7 + core.harmonicSophistication * 0.3;
        }
        calculateModalInfluence(core) {
          return core.harmonicSophistication * 0.6 + (1 - core.accessibility) * 0.4;
        }
        calculateMicrotonal(core) {
          return (1 - core.accessibility) * 0.7 + (1 - core.organicSynthetic) * 0.3;
        }
        calculateCompression(core) {
          return (1 - core.dynamicRange) * 0.8 + core.accessibility * 0.2;
        }
        calculateSaturation(core) {
          return core.energy * 0.6 + (1 - core.organicSynthetic) * 0.4;
        }
        calculateStereoWidth(core) {
          return core.organicSynthetic * 0.5 + core.harmonicSophistication * 0.3 + core.accessibility * 0.2;
        }
        calculateSmoothness(core) {
          return (1 - core.organicSynthetic) * 0.6 + core.accessibility * 0.4;
        }
        calculateExperimentalFactor(core) {
          return (1 - core.accessibility) * 0.7 + core.harmonicSophistication * 0.3;
        }
        emotionalRangeToNumber(range) {
          const mapping = { narrow: 0.3, moderate: 0.5, wide: 0.7, extreme: 0.9 };
          return mapping[range];
        }
        // GenreVisualStyle calculation methods
        calculatePrimaryHueRange(core) {
          const baseHue = core.organicSynthetic * 240 + (1 - core.organicSynthetic) * 30;
          const range = core.emotionalRange === "extreme" ? 100 : core.emotionalRange === "wide" ? 80 : 60;
          return [baseHue - range / 2, baseHue + range / 2];
        }
        calculateSaturationProfile(core) {
          const baseSat = core.energy * 0.5 + core.organicSynthetic * 0.3 + 0.2;
          const variation = core.rhythmComplexity * 0.3 + (1 - core.accessibility) * 0.2;
          return [baseSat, variation];
        }
        calculateBrightnessProfile(core) {
          const baseBrightness = 0.8 + core.energy * 0.4;
          const variation = core.dynamicRange * 0.5;
          return [baseBrightness, variation];
        }
        calculateContrastLevel(core) {
          return core.energy * 0.6 + core.dynamicRange * 0.4;
        }
        calculateGradientComplexity(core) {
          return core.harmonicSophistication * 0.5 + core.rhythmComplexity * 0.3 + (1 - core.accessibility) * 0.2;
        }
        calculateShapeGeometry(core) {
          if (core.organicSynthetic > 0.7) return "geometric";
          if (core.accessibility < 0.5) return "abstract";
          if (core.harmonicSophistication > 0.7) return "hybrid";
          return "smooth";
        }
        calculateEdgeSharpness(core) {
          return core.organicSynthetic * 0.7 + (1 - core.accessibility) * 0.3;
        }
        calculateSymmetryLevel(core) {
          return core.accessibility * 0.6 + (1 - core.rhythmComplexity) * 0.4;
        }
        calculateAnimationStyle(core) {
          if (core.rhythmComplexity > 0.7 && core.energy > 0.7) return "chaotic";
          if (core.rhythmComplexity > 0.6) return "rhythmic";
          if (core.energy < 0.4) return "minimal";
          return "smooth";
        }
        calculatePulseBehavior(core) {
          if (core.rhythmComplexity > 0.7) return "syncopated";
          if (core.energy < 0.4) return "subtle";
          if (1 - core.accessibility > 0.5) return "irregular";
          return "steady";
        }
        calculateFlowDirection(core) {
          if (core.organicSynthetic > 0.7) return "linear";
          if (core.harmonicSophistication > 0.7) return "spiral";
          if (1 - core.accessibility > 0.6) return "random";
          return "radial";
        }
        calculateTransitionCharacter(core) {
          if (core.organicSynthetic > 0.7) return "mechanical";
          if (core.energy > 0.7) return "sharp";
          if (core.accessibility > 0.7) return "smooth";
          return "fluid";
        }
        calculateLayerBlending(core) {
          if (1 - core.accessibility > 0.6) return "clashing";
          if (core.harmonicSophistication > 0.7) return "complementary";
          if (core.energy > 0.7) return "contrasting";
          return "harmonious";
        }
        calculateDepthIllusion(core) {
          return core.harmonicSophistication * 0.5 + core.dynamicRange * 0.3 + (1 - core.accessibility) * 0.2;
        }
        calculateParticleInfluence(core) {
          return core.organicSynthetic * 0.6 + core.energy * 0.4;
        }
        calculateNebulaCharacter(core) {
          if (core.organicSynthetic > 0.7) return "structured";
          if (core.energy > 0.7) return "dense";
          if (core.accessibility < 0.5) return "wispy";
          return "ethereal";
        }
        calculateMemoryInfluence(core) {
          return core.harmonicSophistication * 0.5 + (1 - core.accessibility) * 0.3 + core.rhythmComplexity * 0.2;
        }
        calculateAdaptationSpeed(core) {
          return core.energy * 0.5 + core.rhythmComplexity * 0.3 + core.accessibility * 0.2;
        }
        calculateStabilityPreference(core) {
          return core.accessibility * 0.6 + (1 - core.rhythmComplexity) * 0.4;
        }
        calculateEmergencePattern(core) {
          if (core.harmonicSophistication > 0.7) return "progressive";
          if (core.rhythmComplexity > 0.7) return "cyclical";
          if (core.energy > 0.7) return "sudden";
          return "gradual";
        }
        clearCache() {
          this.characteristicsCache.clear();
          this.visualStyleCache.clear();
        }
      };
      __name(_GenreCalculator, "GenreCalculator");
      GenreCalculator = _GenreCalculator;
    }
  });

  // src-js/audio/GenreProfileManager.ts
  var GENRE_PROFILES, _GenreProfileManager, GenreProfileManager;
  var init_GenreProfileManager = __esm({
    "src-js/audio/GenreProfileManager.ts"() {
      "use strict";
      init_globalConfig();
      init_OKLABColorProcessor();
      init_GenreCalculator();
      GENRE_PROFILES = {
        // Electronic genres - high energy, vibrant colors with dynamic range
        electronic: {
          energyBoost: 1.1,
          beatEmphasis: 1.2,
          precision: 0.9,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "dynamic"
          }
        },
        dance: {
          energyBoost: 1.2,
          beatEmphasis: 1.25,
          precision: 0.95,
          oklabPreset: "COSMIC",
          colorCharacteristics: {
            vibrancyLevel: "cosmic",
            emotionalRange: "extreme",
            colorTemperature: "dynamic"
          }
        },
        house: {
          energyBoost: 1.2,
          beatEmphasis: 1.25,
          precision: 0.95,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        techno: {
          energyBoost: 1.15,
          beatEmphasis: 1.3,
          precision: 1,
          oklabPreset: "COSMIC",
          colorCharacteristics: {
            vibrancyLevel: "cosmic",
            emotionalRange: "extreme",
            colorTemperature: "cool"
          }
        },
        trance: {
          energyBoost: 1.15,
          beatEmphasis: 1.1,
          precision: 0.85,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "dynamic"
          }
        },
        // Rock genres - intense but controlled vibrancy
        rock: {
          energyBoost: 1.05,
          intensityMultiplier: 1.1,
          dynamicRange: 1.1,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        metal: {
          energyBoost: 1.15,
          intensityMultiplier: 1.2,
          dynamicRange: 1.2,
          oklabPreset: "COSMIC",
          colorCharacteristics: {
            vibrancyLevel: "cosmic",
            emotionalRange: "extreme",
            colorTemperature: "cool"
          }
        },
        punk: {
          energyBoost: 1.2,
          intensityMultiplier: 1.1,
          precision: 0.8,
          oklabPreset: "VIBRANT",
          colorCharacteristics: {
            vibrancyLevel: "vibrant",
            emotionalRange: "wide",
            colorTemperature: "dynamic"
          }
        },
        // Urban genres - rhythmic emphasis with moderate vibrancy
        hiphop: {
          beatEmphasis: 1.3,
          grooveFactor: 1.2,
          tempoMultiplier: 0.95,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "warm"
          }
        },
        rap: {
          beatEmphasis: 1.3,
          grooveFactor: 1.2,
          tempoMultiplier: 0.95,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "neutral"
          }
        },
        // Sophisticated genres - subtle, refined enhancement
        jazz: {
          adaptiveVariation: true,
          complexity: 1.2,
          smoothingFactor: 1.3,
          oklabPreset: "SUBTLE",
          colorCharacteristics: {
            vibrancyLevel: "subtle",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        classical: {
          gentleMode: true,
          dynamicRange: 1.4,
          tempoVariationHandling: "adaptive",
          oklabPreset: "SUBTLE",
          colorCharacteristics: {
            vibrancyLevel: "subtle",
            emotionalRange: "extreme",
            colorTemperature: "neutral"
          }
        },
        ambient: {
          subtleMode: true,
          intensityReduction: 0.7,
          smoothingFactor: 1.5,
          oklabPreset: "SUBTLE",
          colorCharacteristics: {
            vibrancyLevel: "subtle",
            emotionalRange: "narrow",
            colorTemperature: "cool"
          }
        },
        // Popular genres - balanced enhancement
        pop: {
          energyBoost: 1.05,
          beatEmphasis: 1.1,
          precision: 0.85,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "warm"
          }
        },
        rnb: {
          grooveFactor: 1.25,
          smoothingFactor: 1.1,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "warm"
          }
        },
        soul: {
          grooveFactor: 1.3,
          smoothingFactor: 1.15,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "wide",
            colorTemperature: "warm"
          }
        },
        // Default fallback - safe, balanced enhancement
        default: {
          balanced: true,
          energyBoost: 1,
          beatEmphasis: 1,
          precision: 1,
          oklabPreset: "STANDARD",
          colorCharacteristics: {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "neutral"
          }
        }
      };
      _GenreProfileManager = class _GenreProfileManager {
        constructor(dependencies = {}) {
          // State tracking for current genre detection
          this.currentGenre = "default";
          this.genreConfidence = 0.5;
          this.genreHistory = [];
          this.historyMaxLength = 10;
          this.config = dependencies.ADVANCED_SYSTEM_CONFIG || dependencies.YEAR3000_CONFIG || ADVANCED_SYSTEM_CONFIG;
          if (this.config.enableDebug) {
            console.log("\u{1F9EC} [GenreProfileManager] Initialized");
          }
        }
        _getGenreFromAudioFeatures(features) {
          if (!features) return "default";
          const {
            danceability = 0.5,
            energy = 0.5,
            acousticness = 0.5,
            instrumentalness = 0.5,
            tempo = 120
          } = features;
          if (instrumentalness > 0.6 && acousticness < 0.2 && energy > 0.6) {
            if (tempo > 120) return "techno";
            return "electronic";
          }
          if (danceability > 0.7 && energy > 0.7) return "dance";
          if (acousticness > 0.7 && energy < 0.4) return "classical";
          if (acousticness > 0.5 && instrumentalness < 0.1) return "jazz";
          if (energy > 0.7 && instrumentalness < 0.1 && danceability > 0.5)
            return "rock";
          if (danceability > 0.7 && instrumentalness < 0.2 && energy > 0.5 && tempo < 110)
            return "hiphop";
          return "default";
        }
        getProfileForTrack(audioFeatures) {
          const genre = this._getGenreFromAudioFeatures(audioFeatures);
          const profile = GENRE_PROFILES[genre];
          if (this.config.enableDebug) {
            console.log(
              `[GenreProfileManager] Detected genre: '${genre}'. Applying profile.`
            );
          }
          if (profile) {
            return profile;
          }
          const defaultProfile = GENRE_PROFILES.default;
          if (defaultProfile) {
            return defaultProfile;
          }
          throw new Error(
            "[GenreProfileManager] Critical: Default genre profile is missing."
          );
        }
        /**
         * Public helper that returns the genre string detected for the given audio-features without
         * allocating a full profile. Useful for colour/palette routing.
         *
         * Also updates internal state tracking (currentGenre, genreConfidence, genreHistory).
         */
        detectGenre(features) {
          const detectedGenre = this._getGenreFromAudioFeatures(features);
          const confidence = this._calculateGenreConfidence(features, detectedGenre);
          this.currentGenre = detectedGenre;
          this.genreConfidence = confidence;
          this.genreHistory.push({
            genre: detectedGenre,
            confidence,
            timestamp: Date.now()
          });
          if (this.genreHistory.length > this.historyMaxLength) {
            this.genreHistory.shift();
          }
          if (this.config.enableDebug) {
            console.log(`\u{1F9EC} [GenreProfileManager] Genre detected: '${detectedGenre}' (confidence: ${confidence.toFixed(2)})`);
          }
          return detectedGenre;
        }
        /**
         * Calculate confidence score for a detected genre based on audio features
         */
        _calculateGenreConfidence(features, genre) {
          if (!features || !genre) return 0.5;
          const { energy = 0.5, danceability = 0.5, acousticness = 0.5 } = features;
          let confidence = 0.5;
          if (genre === "electronic" && energy > 0.7 && acousticness < 0.3) confidence = 0.9;
          else if (genre === "rock" && energy > 0.7 && acousticness < 0.5) confidence = 0.85;
          else if (genre === "classical" && acousticness > 0.7 && energy < 0.4) confidence = 0.9;
          else if (genre === "jazz" && acousticness > 0.5) confidence = 0.8;
          else if (genre === "hiphop" && danceability > 0.7) confidence = 0.85;
          else if (genre === "ambient" && energy < 0.3) confidence = 0.8;
          else confidence = 0.6;
          return Math.min(1, Math.max(0, confidence));
        }
        /**
         * Get the currently detected genre
         */
        getCurrentGenre() {
          return this.currentGenre;
        }
        /**
         * Get confidence score for the current genre detection (0-1)
         */
        getGenreConfidence() {
          return this.genreConfidence;
        }
        /**
         * Get history of recent genre detections
         */
        getGenreHistory() {
          return [...this.genreHistory];
        }
        // === OKLAB INTEGRATION METHODS ===
        /**
         * Get OKLAB enhancement preset for a specific genre
         * Returns the appropriate OKLAB preset based on genre characteristics
         */
        getOKLABPresetForGenre(genre) {
          const profile = GENRE_PROFILES[genre] || GENRE_PROFILES.default;
          const presetName = profile.oklabPreset || "STANDARD";
          try {
            const preset = OKLABColorProcessor.getPreset(presetName);
            if (this.config.enableDebug) {
              console.log(`\u{1F9EC} [GenreProfileManager] OKLAB preset for genre '${genre}':`, {
                genre,
                preset: presetName,
                colorCharacteristics: profile.colorCharacteristics
              });
            }
            return preset;
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(`\u{1F9EC} [GenreProfileManager] Failed to get OKLAB preset '${presetName}' for genre '${genre}', using STANDARD:`, error);
            }
            return OKLABColorProcessor.getPreset("STANDARD");
          }
        }
        /**
         * Get OKLAB enhancement preset for a track based on its audio features
         * Automatically detects genre and returns appropriate OKLAB preset
         */
        getOKLABPresetForTrack(audioFeatures) {
          const detectedGenre = this.detectGenre(audioFeatures);
          return this.getOKLABPresetForGenre(detectedGenre);
        }
        /**
         * Get color characteristics for a specific genre
         * Returns detailed color processing guidance for visual systems
         */
        getColorCharacteristicsForGenre(genre) {
          const profile = GENRE_PROFILES[genre] || GENRE_PROFILES.default;
          const characteristics = profile.colorCharacteristics || {
            vibrancyLevel: "standard",
            emotionalRange: "moderate",
            colorTemperature: "neutral"
          };
          if (this.config.enableDebug) {
            console.log(`\u{1F9EC} [GenreProfileManager] Color characteristics for genre '${genre}':`, characteristics);
          }
          return characteristics;
        }
        /**
         * Get color characteristics for a track based on its audio features
         */
        getColorCharacteristicsForTrack(audioFeatures) {
          const detectedGenre = this.detectGenre(audioFeatures);
          return this.getColorCharacteristicsForGenre(detectedGenre);
        }
        /**
         * Create contextual OKLAB preset based on genre and additional factors
         * Allows for dynamic preset customization based on runtime conditions
         */
        createContextualOKLABPreset(audioFeatures, intensityMultiplier = 1, customSuffix = "contextual") {
          const detectedGenre = this.detectGenre(audioFeatures);
          const basePreset = this.getOKLABPresetForGenre(detectedGenre);
          const characteristics = this.getColorCharacteristicsForGenre(detectedGenre);
          const energyInfluence = audioFeatures.energy || 0.5;
          const danceabilityInfluence = audioFeatures.danceability || 0.5;
          const combinedIntensity = (energyInfluence + danceabilityInfluence) / 2 * intensityMultiplier;
          const contextualChromaBoost = basePreset.chromaBoost * (0.8 + combinedIntensity * 0.4);
          const contextualLightnessBoost = basePreset.lightnessBoost * (0.9 + combinedIntensity * 0.2);
          const contextualPreset = OKLABColorProcessor.createCustomPreset(
            `${detectedGenre}-${customSuffix}`,
            `Contextual ${basePreset.description} for ${detectedGenre}`,
            contextualLightnessBoost,
            contextualChromaBoost,
            basePreset.shadowReduction,
            basePreset.vibrantThreshold
          );
          if (this.config.enableDebug) {
            console.log(`\u{1F9EC} [GenreProfileManager] Created contextual OKLAB preset:`, {
              genre: detectedGenre,
              basePreset: basePreset.name,
              contextualPreset: contextualPreset.name,
              adjustments: {
                chromaBoost: `${basePreset.chromaBoost} \u2192 ${contextualChromaBoost}`,
                lightnessBoost: `${basePreset.lightnessBoost} \u2192 ${contextualLightnessBoost}`,
                intensityMultiplier,
                combinedIntensity
              }
            });
          }
          return contextualPreset;
        }
        /**
         * Get all available genre-OKLAB preset mappings
         * Useful for system initialization and debugging
         */
        getAllGenreOKLABMappings() {
          const mappings = {};
          Object.entries(GENRE_PROFILES).forEach(([genre, profile]) => {
            mappings[genre] = {
              preset: profile.oklabPreset || "STANDARD",
              characteristics: profile.colorCharacteristics
            };
          });
          if (this.config.enableDebug) {
            console.log("\u{1F9EC} [GenreProfileManager] All genre-OKLAB mappings:", mappings);
          }
          return mappings;
        }
        // ===================================================================
        // GENRE CHARACTERISTICS & VISUAL STYLE ACCESSORS
        // ===================================================================
        // Algorithmically calculated genre properties using GenreCalculator
        /**
         * Get audio characteristics for a specific genre
         * Returns algorithmically calculated sonic signature data
         */
        getCharacteristics(genre) {
          const calculator = GenreCalculator.getInstance();
          const characteristics = calculator.calculateCharacteristics(genre);
          if (this.config.enableDebug) {
            console.log(`\u{1F9EC} [GenreProfileManager] Characteristics for genre '${genre}':`, characteristics);
          }
          return characteristics;
        }
        /**
         * Get audio characteristics for a track based on detected genre
         */
        getCharacteristicsForTrack(audioFeatures) {
          const detectedGenre = this.detectGenre(audioFeatures);
          return this.getCharacteristics(detectedGenre);
        }
        /**
         * Get visual style parameters for a specific genre
         * Returns algorithmically calculated gradient, animation, and rendering parameters
         */
        getVisualStyle(genre) {
          const calculator = GenreCalculator.getInstance();
          const visualStyle = calculator.calculateVisualStyle(genre);
          if (this.config.enableDebug) {
            console.log(`\u{1F9EC} [GenreProfileManager] Visual style for genre '${genre}':`, visualStyle);
          }
          return visualStyle;
        }
        /**
         * Get visual style for a track based on detected genre
         */
        getVisualStyleForTrack(audioFeatures) {
          const detectedGenre = this.detectGenre(audioFeatures);
          return this.getVisualStyle(detectedGenre);
        }
        /**
         * Get complete genre data (profile + characteristics + visual style)
         * Consolidates all genre information for comprehensive system integration
         */
        getFullGenreData(genre) {
          return {
            profile: this.getProfileForTrack({}),
            characteristics: this.getCharacteristics(genre),
            visualStyle: this.getVisualStyle(genre)
          };
        }
      };
      __name(_GenreProfileManager, "GenreProfileManager");
      GenreProfileManager = _GenreProfileManager;
    }
  });

  // src-js/utils/color/EmotionalTemperatureMapper.ts
  var EMOTIONAL_TEMPERATURE_MAP, _EmotionalTemperatureMapper, EmotionalTemperatureMapper;
  var init_EmotionalTemperatureMapper = __esm({
    "src-js/utils/color/EmotionalTemperatureMapper.ts"() {
      "use strict";
      init_OKLABColorProcessor();
      EMOTIONAL_TEMPERATURE_MAP = {
        calm: {
          temperatureRange: [2700, 4e3],
          baseTemperature: 3200,
          characteristics: {
            energy: [0, 0.3],
            valence: [0.4, 0.8],
            intensity: 0.6
          },
          cssClass: "smooth-emotion-calm",
          description: "Warm, soothing, meditative states",
          oklabBaseColor: "#89b4fa",
          // Catppuccin blue - calming base
          oklabPreset: "SUBTLE",
          perceptualCharacteristics: {
            lightness: [0.6, 0.8],
            // Moderate to high lightness for calming effect
            chromaBoost: 0.9,
            // Slightly reduced chroma for gentleness
            hueShift: 15
            // Slight warm shift towards cyan-blue
          }
        },
        melancholy: {
          temperatureRange: [2200, 3500],
          baseTemperature: 2800,
          characteristics: {
            energy: [0, 0.4],
            valence: [0, 0.4],
            intensity: 0.8
          },
          cssClass: "smooth-emotion-melancholy",
          description: "Deep, introspective, amber-golden tones",
          oklabBaseColor: "#f9e2af",
          // Catppuccin yellow - warm melancholic base
          oklabPreset: "STANDARD",
          perceptualCharacteristics: {
            lightness: [0.4, 0.6],
            // Lower lightness for introspective mood
            chromaBoost: 1.1,
            // Enhanced warmth and saturation
            hueShift: -10
            // Shift towards warmer amber tones
          }
        },
        energetic: {
          temperatureRange: [5500, 7500],
          baseTemperature: 6500,
          characteristics: {
            energy: [0.6, 1],
            valence: [0.5, 1],
            intensity: 1
          },
          cssClass: "smooth-emotion-energetic",
          description: "Bright, vibrant, high-energy states",
          oklabBaseColor: "#a6e3a1",
          // Catppuccin green - vibrant energetic base
          oklabPreset: "VIBRANT",
          perceptualCharacteristics: {
            lightness: [0.7, 0.9],
            // High lightness for energy
            chromaBoost: 1.3,
            // Maximum vibrancy
            hueShift: 5
            // Slight shift towards more vibrant green
          }
        },
        aggressive: {
          temperatureRange: [8e3, 12e3],
          baseTemperature: 1e4,
          characteristics: {
            energy: [0.7, 1],
            valence: [0, 0.6],
            intensity: 1.2
          },
          cssClass: "smooth-emotion-aggressive",
          description: "Cool, intense, high-energy negative valence",
          oklabBaseColor: "#f38ba8",
          // Catppuccin red - intense aggressive base
          oklabPreset: "COSMIC",
          perceptualCharacteristics: {
            lightness: [0.5, 0.7],
            // Moderate lightness with high intensity
            chromaBoost: 1.4,
            // Maximum chroma for intensity
            hueShift: -5
            // Slight shift towards deeper red
          }
        },
        happy: {
          temperatureRange: [4500, 6500],
          baseTemperature: 5500,
          characteristics: {
            energy: [0.4, 0.8],
            valence: [0.6, 1],
            intensity: 0.9
          },
          cssClass: "smooth-emotion-happy",
          description: "Balanced, joyful, warm-white tones",
          oklabBaseColor: "#fab387",
          // Catppuccin peach - warm happy base
          oklabPreset: "STANDARD",
          perceptualCharacteristics: {
            lightness: [0.75, 0.85],
            // High lightness for joy
            chromaBoost: 1.15,
            // Enhanced warmth
            hueShift: 8
            // Shift towards warmer orange
          }
        },
        romantic: {
          temperatureRange: [2500, 3500],
          baseTemperature: 3e3,
          characteristics: {
            energy: [0.2, 0.6],
            valence: [0.5, 0.9],
            intensity: 0.7
          },
          cssClass: "smooth-emotion-romantic",
          description: "Soft, intimate, warm tones with pink accent",
          oklabBaseColor: "#f5c2e7",
          // Catppuccin pink - romantic base
          oklabPreset: "SUBTLE",
          perceptualCharacteristics: {
            lightness: [0.65, 0.8],
            // Soft, comfortable lightness
            chromaBoost: 1,
            // Natural saturation
            hueShift: 12
            // Shift towards warmer pink
          }
        },
        mysterious: {
          temperatureRange: [1800, 2800],
          baseTemperature: 2300,
          characteristics: {
            energy: [0.1, 0.5],
            valence: [0.1, 0.5],
            intensity: 0.9
          },
          cssClass: "smooth-emotion-mysterious",
          description: "Deep, enigmatic, low temperature with purple accent",
          oklabBaseColor: "#cba6f7",
          // Catppuccin mauve - mysterious base
          oklabPreset: "VIBRANT",
          perceptualCharacteristics: {
            lightness: [0.3, 0.5],
            // Low lightness for mystery
            chromaBoost: 1.2,
            // Enhanced depth
            hueShift: -15
            // Shift towards deeper purple
          }
        },
        epic: {
          temperatureRange: [7e3, 15e3],
          baseTemperature: 11e3,
          characteristics: {
            energy: [0.6, 1],
            valence: [0.3, 0.8],
            intensity: 1.3
          },
          cssClass: "smooth-emotion-epic",
          description: "Grand, cinematic, high contrast blue-gold",
          oklabBaseColor: "#74c7ec",
          // Catppuccin sapphire - epic base
          oklabPreset: "COSMIC",
          perceptualCharacteristics: {
            lightness: [0.6, 0.9],
            // Wide lightness range for drama
            chromaBoost: 1.35,
            // Maximum cinematic impact
            hueShift: 20
            // Shift towards more dramatic blue
          }
        },
        ambient: {
          temperatureRange: [3e3, 5e3],
          baseTemperature: 4e3,
          characteristics: {
            energy: [0.1, 0.4],
            valence: [0.3, 0.7],
            intensity: 0.5
          },
          cssClass: "smooth-emotion-ambient",
          description: "Atmospheric, floating, neutral temperature",
          oklabBaseColor: "#94e2d5",
          // Catppuccin teal - ambient base
          oklabPreset: "SUBTLE",
          perceptualCharacteristics: {
            lightness: [0.5, 0.7],
            // Balanced lightness for atmosphere
            chromaBoost: 0.8,
            // Reduced chroma for subtlety
            hueShift: 0
            // No hue shift for neutrality
          }
        }
      };
      _EmotionalTemperatureMapper = class _EmotionalTemperatureMapper {
        constructor(enableDebug = false) {
          this.enableDebug = enableDebug;
          this.oklabProcessor = new OKLABColorProcessor(enableDebug);
        }
        /**
         * Analyzes music data and returns the appropriate emotional temperature configuration
         */
        mapMusicToEmotionalTemperature(musicData) {
          const { energy = 0.5, valence = 0.5, danceability = 0.5, tempo = 120, mode = 1 } = musicData;
          let primaryEmotion;
          let secondaryEmotion;
          let blendRatio = 1;
          if (energy >= 0.6 && valence >= 0.6) {
            primaryEmotion = danceability > 0.7 ? "energetic" : "happy";
            if (energy > 0.8 && valence > 0.8) {
              secondaryEmotion = "epic";
              blendRatio = 0.7;
            }
          } else if (energy >= 0.6 && valence < 0.5) {
            primaryEmotion = energy > 0.8 ? "aggressive" : "epic";
            if (valence < 0.3) {
              secondaryEmotion = "mysterious";
              blendRatio = 0.8;
            }
          } else if (energy < 0.4 && valence >= 0.5) {
            primaryEmotion = valence > 0.7 ? "calm" : "romantic";
            if (energy < 0.2) {
              secondaryEmotion = "ambient";
              blendRatio = 0.6;
            }
          } else {
            primaryEmotion = valence < 0.3 ? "melancholy" : "mysterious";
            if (energy < 0.2 && valence < 0.2) {
              secondaryEmotion = "ambient";
              blendRatio = 0.8;
            }
          }
          if (musicData.genre) {
            const genreAdjustment = this.getGenreEmotionalAdjustment(musicData.genre, primaryEmotion);
            if (genreAdjustment) {
              if (genreAdjustment.override) {
                primaryEmotion = genreAdjustment.override;
              }
              if (genreAdjustment.secondary) {
                secondaryEmotion = genreAdjustment.secondary;
                blendRatio = genreAdjustment.blendRatio || 0.7;
              }
            }
          }
          const baseIntensity = EMOTIONAL_TEMPERATURE_MAP[primaryEmotion].characteristics.intensity;
          const energyBoost = energy * 0.3;
          const valenceInfluence = Math.abs(valence - 0.5) * 0.2;
          const tempoInfluence = tempo > 140 ? 0.1 : tempo < 80 ? -0.1 : 0;
          const finalIntensity = Math.max(0.1, Math.min(
            1.5,
            baseIntensity + energyBoost + valenceInfluence + tempoInfluence
          ));
          const emotionData = EMOTIONAL_TEMPERATURE_MAP[primaryEmotion];
          const [minTemp, maxTemp] = emotionData.temperatureRange;
          const temperaturePosition = energy * 0.6 + valence * 0.4;
          const temperature = minTemp + (maxTemp - minTemp) * temperaturePosition;
          const oklabPreset = OKLABColorProcessor.getPreset(emotionData.oklabPreset);
          let oklabResult;
          let perceptualColorHex;
          try {
            const customPreset = this.createContextualOKLABPreset(
              emotionData,
              finalIntensity,
              energy,
              valence
            );
            oklabResult = this.oklabProcessor.processColor(
              emotionData.oklabBaseColor,
              customPreset
            );
            perceptualColorHex = oklabResult.enhancedHex;
            if (this.enableDebug) {
              console.log("\u{1F321}\uFE0F [EmotionalTemperatureMapper] OKLAB processing:", {
                emotion: primaryEmotion,
                baseColor: emotionData.oklabBaseColor,
                preset: customPreset.name,
                enhanced: perceptualColorHex,
                oklabCoords: oklabResult.oklabEnhanced
              });
            }
          } catch (error) {
            if (this.enableDebug) {
              console.warn("\u{1F321}\uFE0F [EmotionalTemperatureMapper] OKLAB processing failed:", error);
            }
            perceptualColorHex = emotionData.oklabBaseColor;
          }
          const cssVariables = this.generateEmotionalCSSVariables(
            primaryEmotion,
            secondaryEmotion,
            finalIntensity,
            temperature,
            blendRatio,
            oklabResult,
            perceptualColorHex
          );
          const result = {
            primaryEmotion,
            ...secondaryEmotion && { secondaryEmotion },
            intensity: finalIntensity,
            temperature: Math.round(temperature),
            blendRatio,
            cssClass: emotionData.cssClass,
            cssVariables,
            // OKLAB integration
            oklabPreset,
            ...oklabResult && { oklabResult },
            ...perceptualColorHex && { perceptualColorHex }
          };
          if (this.enableDebug) {
            console.log("\u{1F321}\uFE0F [EmotionalTemperatureMapper] Music analysis result:", {
              input: { energy, valence, genre: musicData.genre },
              output: result,
              reasoning: {
                energyValenceQuadrant: this.getEnergyValenceQuadrant(energy, valence),
                genreInfluence: musicData.genre,
                intensityFactors: { baseIntensity, energyBoost, valenceInfluence, tempoInfluence }
              }
            });
          }
          return result;
        }
        /**
         * Create contextual OKLAB preset based on emotional characteristics and music data
         */
        createContextualOKLABPreset(emotionData, intensity, energy, valence) {
          const basePreset = OKLABColorProcessor.getPreset(emotionData.oklabPreset);
          const perceptualChars = emotionData.perceptualCharacteristics;
          const lightnessFactor = energy * 0.5 + valence * 0.3 + 0.2;
          const targetLightness = perceptualChars.lightness[0] + (perceptualChars.lightness[1] - perceptualChars.lightness[0]) * lightnessFactor;
          const chromaMultiplier = perceptualChars.chromaBoost * intensity * (0.8 + energy * 0.4);
          return OKLABColorProcessor.createCustomPreset(
            `${emotionData.cssClass}-contextual`,
            `Contextual ${basePreset.description} for ${emotionData.description}`,
            targetLightness / 0.5,
            // Convert to lightness boost multiplier
            chromaMultiplier,
            basePreset.shadowReduction,
            basePreset.vibrantThreshold
          );
        }
        /**
         * Get genre-specific emotional adjustments
         */
        getGenreEmotionalAdjustment(genre, currentEmotion) {
          const genreMap = {
            // Electronic genres
            "edm": { secondary: "energetic", blendRatio: 0.8 },
            "house": { secondary: "energetic", blendRatio: 0.7 },
            "ambient": { override: "ambient" },
            "downtempo": { override: "calm", secondary: "ambient", blendRatio: 0.6 },
            // Rock genres
            "metal": { override: "aggressive" },
            "hard-rock": { secondary: "aggressive", blendRatio: 0.8 },
            "alternative": { secondary: "epic", blendRatio: 0.7 },
            // Classical and orchestral
            "classical": { override: "epic", secondary: "calm", blendRatio: 0.6 },
            "soundtrack": { override: "epic" },
            "orchestral": { override: "epic" },
            // Jazz and soul
            "jazz": { override: "mysterious", secondary: "romantic", blendRatio: 0.7 },
            "blues": { override: "melancholy" },
            "soul": { secondary: "romantic", blendRatio: 0.6 },
            // Folk and acoustic
            "folk": { override: "calm", secondary: "melancholy", blendRatio: 0.6 },
            "acoustic": { override: "romantic", secondary: "calm", blendRatio: 0.7 },
            // Hip-hop and urban
            "hip-hop": { secondary: "aggressive", blendRatio: 0.8 },
            "trap": { secondary: "aggressive", blendRatio: 0.9 },
            // Pop variations
            "pop": { secondary: "happy", blendRatio: 0.7 },
            "indie-pop": { secondary: "happy", blendRatio: 0.6 }
          };
          const normalizedGenre = genre.toLowerCase().replace(/[\s-_]/g, "-");
          return genreMap[normalizedGenre] || null;
        }
        /**
         * Determine energy-valence quadrant for debugging
         */
        getEnergyValenceQuadrant(energy, valence) {
          if (energy >= 0.5 && valence >= 0.5) return "High Energy + Positive";
          if (energy >= 0.5 && valence < 0.5) return "High Energy + Negative";
          if (energy < 0.5 && valence >= 0.5) return "Low Energy + Positive";
          return "Low Energy + Negative";
        }
        /**
         * Generate CSS variables for emotional temperature integration with OKLAB enhancement
         */
        generateEmotionalCSSVariables(primary, secondary, intensity, temperature, blendRatio, oklabResult, perceptualColorHex) {
          const cssVars = {};
          cssVars["--smooth-current-emotion"] = primary;
          cssVars["--smooth-emotional-intensity"] = intensity.toString();
          cssVars["--smooth-current-temperature"] = temperature.toString();
          cssVars["--smooth-emotion-primary"] = primary;
          if (secondary) {
            cssVars["--smooth-emotion-secondary"] = secondary;
            cssVars["--smooth-emotion-blend-ratio"] = blendRatio.toString();
          }
          cssVars["--smooth-emotional-saturation"] = Math.max(0.5, intensity).toString();
          cssVars["--smooth-cinematic-contrast"] = Math.max(0.8, intensity * 1.2).toString();
          cssVars["--smooth-warmth"] = this.calculateWarmth(temperature).toString();
          const pulsingSpeed = this.calculatePulsingSpeed(primary, intensity);
          cssVars["--smooth-pulsing-cycle"] = `${pulsingSpeed}s`;
          const temperatureFilters = this.calculateTemperatureFilters(temperature, intensity);
          Object.assign(cssVars, temperatureFilters);
          if (oklabResult && perceptualColorHex) {
            cssVars["--smooth-emotion-oklab-hex"] = perceptualColorHex;
            cssVars["--smooth-emotion-oklab-rgb"] = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            cssVars["--smooth-emotion-oklab-l"] = oklabResult.oklabEnhanced.L.toFixed(3);
            cssVars["--smooth-emotion-oklab-a"] = oklabResult.oklabEnhanced.a.toFixed(3);
            cssVars["--smooth-emotion-oklab-b"] = oklabResult.oklabEnhanced.b.toFixed(3);
            cssVars["--smooth-emotion-oklch-l"] = oklabResult.oklchEnhanced.L.toFixed(3);
            cssVars["--smooth-emotion-oklch-c"] = oklabResult.oklchEnhanced.C.toFixed(3);
            cssVars["--smooth-emotion-oklch-h"] = oklabResult.oklchEnhanced.H.toFixed(1);
            cssVars["--smooth-emotion-oklab-shadow-hex"] = oklabResult.shadowHex;
            cssVars["--smooth-emotion-oklab-shadow-rgb"] = `${oklabResult.shadowRgb.r},${oklabResult.shadowRgb.g},${oklabResult.shadowRgb.b}`;
            cssVars["--smooth-perceptual-emotion-color"] = perceptualColorHex;
            cssVars["--smooth-perceptual-emotion-rgb"] = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            if (this.enableDebug) {
              console.log("\u{1F3A8} [EmotionalTemperatureMapper] Generated OKLAB CSS variables:", {
                emotion: primary,
                perceptualColor: perceptualColorHex,
                oklabCoords: oklabResult.oklabEnhanced,
                oklchCoords: oklabResult.oklchEnhanced
              });
            }
          }
          return cssVars;
        }
        /**
         * Calculate warmth factor based on temperature (0-1)
         */
        calculateWarmth(temperature) {
          if (temperature <= 4e3) {
            return 0.7 + (4e3 - temperature) / (4e3 - 1800) * 0.3;
          } else if (temperature >= 7e3) {
            return Math.max(0.2, 0.7 - (temperature - 7e3) / (15e3 - 7e3) * 0.5);
          } else {
            return 0.5 + (7e3 - temperature) / (7e3 - 4e3) * 0.2;
          }
        }
        /**
         * Calculate pulsing animation speed based on emotion and intensity
         */
        calculatePulsingSpeed(emotion, intensity) {
          const baseSpeed = {
            calm: 6,
            melancholy: 8,
            energetic: 2,
            aggressive: 1.5,
            happy: 3,
            romantic: 5,
            mysterious: 7,
            epic: 2.5,
            ambient: 10
          };
          const base = baseSpeed[emotion];
          const intensityFactor = Math.max(0.5, Math.min(2, 2 - intensity));
          return base * intensityFactor;
        }
        /**
         * Calculate temperature-based CSS filter adjustments
         */
        calculateTemperatureFilters(temperature, intensity) {
          const filters = {};
          const hueRotation = this.mapTemperatureToHue(temperature);
          filters["--smooth-temperature-hue-shift"] = `${hueRotation}deg`;
          const saturation = Math.max(0.8, Math.min(1.5, 1 + (intensity - 0.5) * 0.4));
          filters["--smooth-temperature-saturation"] = saturation.toString();
          const brightness = this.mapTemperatureToBrightness(temperature);
          filters["--smooth-temperature-brightness"] = brightness.toString();
          return filters;
        }
        /**
         * Map temperature to hue rotation (-30 to +30 degrees)
         */
        mapTemperatureToHue(temperature) {
          if (temperature <= 4e3) {
            return -15 + (4e3 - temperature) / (4e3 - 2e3) * -15;
          } else if (temperature >= 8e3) {
            return 10 + (temperature - 8e3) / (15e3 - 8e3) * 20;
          } else {
            return -5 + (temperature - 4e3) / (8e3 - 4e3) * 15;
          }
        }
        /**
         * Map temperature to brightness adjustment (0.8-1.2)
         */
        mapTemperatureToBrightness(temperature) {
          const normalized = (temperature - 2e3) / (15e3 - 2e3);
          return 0.9 + normalized * 0.3;
        }
        /**
         * Apply emotional temperature to an element via CSS class and variables
         */
        applyEmotionalTemperature(element, result) {
          const existingClasses = Array.from(element.classList).filter(
            (cls) => cls.startsWith("smooth-emotion-")
          );
          element.classList.remove(...existingClasses);
          element.classList.add(result.cssClass);
          if (result.secondaryEmotion) {
            element.classList.add(`smooth-emotion-blend-${result.secondaryEmotion}`);
          }
          Object.entries(result.cssVariables).forEach(([property, value]) => {
            element.style.setProperty(property, value);
          });
          if (this.enableDebug) {
            console.log("\u{1F3A8} [EmotionalTemperatureMapper] Applied emotional temperature:", {
              element: element.tagName,
              emotion: result.primaryEmotion,
              secondary: result.secondaryEmotion,
              intensity: result.intensity,
              temperature: result.temperature
            });
          }
        }
        /**
         * Get all available emotional states
         */
        static getAvailableEmotions() {
          return Object.keys(EMOTIONAL_TEMPERATURE_MAP);
        }
        /**
         * Get emotion characteristics for a specific state
         */
        static getEmotionCharacteristics(emotion) {
          return EMOTIONAL_TEMPERATURE_MAP[emotion];
        }
      };
      __name(_EmotionalTemperatureMapper, "EmotionalTemperatureMapper");
      EmotionalTemperatureMapper = _EmotionalTemperatureMapper;
    }
  });

  // src-js/utils/color/CatppuccinPalettes.ts
  function color(hex, h, s, l) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return {
      hex,
      rgb: `${r}, ${g}, ${b}`,
      hsl: [h, s, l],
      brightness
    };
  }
  function getBrightnessAdjustedBaseColor(flavor, brightnessMode) {
    const palette = CATPPUCCIN_PALETTES[flavor];
    const config = BRIGHTNESS_CONFIGS[brightnessMode];
    switch (brightnessMode) {
      case "bright":
        return flavor === "latte" ? palette.surface2 : palette.surface1;
      case "balanced":
        return flavor === "latte" ? palette.surface0 : palette.base;
      case "dark":
        return flavor === "latte" ? palette.mantle : palette.mantle;
      default:
        return palette.base;
    }
  }
  function getBrightnessAdjustedSurfaceColor(flavor, brightnessMode) {
    const palette = CATPPUCCIN_PALETTES[flavor];
    switch (brightnessMode) {
      case "bright":
        return flavor === "latte" ? palette.surface2 : palette.surface2;
      case "balanced":
        return flavor === "latte" ? palette.surface1 : palette.surface1;
      case "dark":
        return flavor === "latte" ? palette.surface0 : palette.surface0;
      default:
        return palette.surface1;
    }
  }
  function getCatppuccinAccentColor(flavor, accentName) {
    return CATPPUCCIN_PALETTES[flavor][accentName];
  }
  function getDefaultAccentColor(flavor) {
    const palette = CATPPUCCIN_PALETTES[flavor];
    return flavor === "latte" ? palette.blue : palette.mauve;
  }
  var CATPPUCCIN_PALETTES, BRIGHTNESS_CONFIGS;
  var init_CatppuccinPalettes = __esm({
    "src-js/utils/color/CatppuccinPalettes.ts"() {
      "use strict";
      __name(color, "color");
      CATPPUCCIN_PALETTES = {
        mocha: {
          rosewater: color("#f5e0dc", 10, 56, 91),
          flamingo: color("#f2cdcd", 0, 59, 88),
          pink: color("#f5c2e7", 316, 72, 86),
          mauve: color("#cba6f7", 267, 84, 81),
          red: color("#f38ba8", 343, 81, 75),
          maroon: color("#eba0ac", 350, 65, 77),
          peach: color("#fab387", 23, 92, 75),
          yellow: color("#f9e2af", 41, 86, 83),
          green: color("#a6e3a1", 115, 54, 76),
          teal: color("#94e2d5", 174, 57, 73),
          sky: color("#89dceb", 189, 71, 73),
          sapphire: color("#74c7ec", 199, 76, 69),
          blue: color("#89b4fa", 217, 92, 76),
          lavender: color("#b4befe", 232, 97, 85),
          text: color("#cdd6f4", 226, 64, 88),
          subtext1: color("#bac2de", 227, 35, 80),
          subtext0: color("#a6adc8", 228, 24, 72),
          overlay2: color("#9399b2", 228, 17, 64),
          overlay1: color("#7f849c", 230, 13, 55),
          overlay0: color("#6c7086", 231, 11, 47),
          surface2: color("#585b70", 233, 12, 39),
          surface1: color("#45475a", 234, 13, 31),
          surface0: color("#313244", 237, 16, 23),
          base: color("#1e1e2e", 240, 21, 15),
          mantle: color("#181825", 240, 18, 13),
          crust: color("#11111b", 240, 23, 9)
        },
        latte: {
          rosewater: color("#dc8a78", 11, 59, 67),
          flamingo: color("#dd7878", 0, 60, 67),
          pink: color("#ea76cb", 316, 73, 69),
          mauve: color("#8839ef", 266, 85, 58),
          red: color("#d20f39", 347, 87, 44),
          maroon: color("#e64553", 355, 76, 59),
          peach: color("#fe640b", 22, 99, 52),
          yellow: color("#df8e1d", 35, 77, 49),
          green: color("#40a02b", 109, 58, 40),
          teal: color("#179299", 183, 74, 35),
          sky: color("#04a5e5", 197, 97, 46),
          sapphire: color("#209fb5", 189, 70, 42),
          blue: color("#1e66f5", 220, 91, 54),
          lavender: color("#7287fd", 231, 97, 72),
          text: color("#4c4f69", 234, 16, 35),
          subtext1: color("#5c5f77", 233, 13, 41),
          subtext0: color("#6c6f85", 233, 10, 47),
          overlay2: color("#7c7f93", 232, 10, 53),
          overlay1: color("#8c8fa1", 231, 10, 59),
          overlay0: color("#9ca0b0", 228, 11, 65),
          surface2: color("#acb0be", 227, 12, 71),
          surface1: color("#bcc0cc", 226, 14, 77),
          surface0: color("#ccd0da", 225, 16, 83),
          base: color("#eff1f5", 220, 23, 95),
          mantle: color("#e6e9ef", 220, 22, 92),
          crust: color("#dce0e8", 220, 21, 89)
        },
        frappe: {
          rosewater: color("#f2d5cf", 10, 57, 88),
          flamingo: color("#eebebe", 0, 58, 84),
          pink: color("#f4b8e4", 316, 73, 84),
          mauve: color("#ca9ee6", 277, 59, 76),
          red: color("#e78284", 359, 68, 71),
          maroon: color("#ea999c", 358, 56, 76),
          peach: color("#ef9f76", 20, 79, 70),
          yellow: color("#e5c890", 40, 62, 73),
          green: color("#a6d189", 96, 44, 68),
          teal: color("#81c8be", 172, 39, 65),
          sky: color("#99d1db", 189, 48, 73),
          sapphire: color("#85c1dc", 199, 55, 69),
          blue: color("#8caaee", 222, 74, 74),
          lavender: color("#babbf1", 239, 66, 84),
          text: color("#c6d0f5", 227, 70, 87),
          subtext1: color("#b5bfe2", 229, 44, 80),
          subtext0: color("#a5adce", 230, 34, 72),
          overlay2: color("#949cbb", 231, 19, 64),
          overlay1: color("#838ba7", 232, 16, 56),
          overlay0: color("#737994", 232, 13, 49),
          surface2: color("#626880", 233, 16, 42),
          surface1: color("#51576d", 234, 16, 35),
          surface0: color("#414559", 235, 16, 30),
          base: color("#303446", 229, 19, 23),
          mantle: color("#292c3c", 231, 19, 20),
          crust: color("#232634", 229, 20, 17)
        },
        macchiato: {
          rosewater: color("#f4dbd6", 10, 58, 90),
          flamingo: color("#f0c6c6", 0, 58, 86),
          pink: color("#f5bde6", 316, 74, 85),
          mauve: color("#c6a0f6", 267, 83, 79),
          red: color("#ed8796", 351, 74, 73),
          maroon: color("#ee99a0", 357, 70, 77),
          peach: color("#f5a97f", 21, 86, 73),
          yellow: color("#eed49f", 42, 79, 78),
          green: color("#a6da95", 105, 48, 72),
          teal: color("#8bd5ca", 172, 47, 69),
          sky: color("#91d7e3", 189, 59, 73),
          sapphire: color("#7dc4e4", 199, 66, 69),
          blue: color("#8aadf4", 220, 83, 75),
          lavender: color("#b7bdf8", 238, 82, 84),
          text: color("#cad3f5", 227, 68, 88),
          subtext1: color("#b8c0e0", 228, 39, 81),
          subtext0: color("#a5adcb", 227, 27, 72),
          overlay2: color("#939ab7", 228, 20, 64),
          overlay1: color("#8087a2", 230, 15, 56),
          overlay0: color("#6e738d", 230, 12, 48),
          surface2: color("#5b6078", 233, 16, 40),
          surface1: color("#494d64", 234, 15, 33),
          surface0: color("#363a4f", 235, 16, 26),
          base: color("#24273a", 232, 23, 19),
          mantle: color("#1e2030", 233, 23, 16),
          crust: color("#181926", 236, 23, 13)
        }
      };
      BRIGHTNESS_CONFIGS = {
        bright: {
          baseColorTarget: 0.25,
          // Brighter interface colors
          surfaceColorTarget: 0.35,
          textContrastMin: 4.5
        },
        balanced: {
          baseColorTarget: 0.15,
          // Standard interface colors
          surfaceColorTarget: 0.25,
          textContrastMin: 4.5
        },
        dark: {
          baseColorTarget: 0.08,
          // Darker interface colors (deeper, less bright)
          surfaceColorTarget: 0.15,
          textContrastMin: 3
          // Slightly lower contrast for dark mode comfort
        }
      };
      __name(getBrightnessAdjustedBaseColor, "getBrightnessAdjustedBaseColor");
      __name(getBrightnessAdjustedSurfaceColor, "getBrightnessAdjustedSurfaceColor");
      __name(getCatppuccinAccentColor, "getCatppuccinAccentColor");
      __name(getDefaultAccentColor, "getDefaultAccentColor");
    }
  });

  // src-js/utils/color/Year3000Palettes.ts
  function color2(hex, h, s, l) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return {
      hex,
      rgb: `${r}, ${g}, ${b}`,
      hsl: [h, s, l],
      brightness
    };
  }
  function getBrightnessAdjustedBaseColor2(flavor, brightnessMode) {
    const palette = YEAR3000_PALETTES[flavor];
    const config = BRIGHTNESS_CONFIGS2[brightnessMode];
    switch (brightnessMode) {
      case "bright":
        return palette.surface1;
      case "balanced":
        return palette.surface0;
      case "dark":
        return palette.base;
      default:
        return palette.base;
    }
  }
  function getBrightnessAdjustedSurfaceColor2(flavor, brightnessMode) {
    const palette = YEAR3000_PALETTES[flavor];
    switch (brightnessMode) {
      case "bright":
        return palette.surface2;
      case "balanced":
        return palette.surface1;
      case "dark":
        return palette.surface0;
      default:
        return palette.surface1;
    }
  }
  function getYear3000AccentColor(flavor, accentName) {
    return YEAR3000_PALETTES[flavor][accentName];
  }
  function getDefaultAccentColor2(flavor) {
    const palette = YEAR3000_PALETTES[flavor];
    return palette.mauve;
  }
  function getCinematicGradientPair(flavor, intensity = "medium") {
    const palette = YEAR3000_PALETTES[flavor];
    switch (intensity) {
      case "low":
        return [palette.mauve, palette.blue];
      case "medium":
        return [palette.pink, palette.peach];
      case "high":
        return [palette.red, palette.teal];
      default:
        return [palette.mauve, palette.pink];
    }
  }
  function getAnimatedFlowColors(flavor) {
    const palette = YEAR3000_PALETTES[flavor];
    return {
      primary: palette.mauve,
      // Electric Purple
      secondary: palette.pink,
      // Vivid Magenta
      tertiary: palette.sky,
      // Electric Blue
      atmosphere: palette.base
      // Deep cosmic background
    };
  }
  var YEAR3000_PALETTES, BRIGHTNESS_CONFIGS2;
  var init_Year3000Palettes = __esm({
    "src-js/utils/color/Year3000Palettes.ts"() {
      "use strict";
      __name(color2, "color");
      YEAR3000_PALETTES = {
        // Subtle: Muted cinematic tones for professional environments
        subtle: {
          rosewater: color2("#e8d5d1", 15, 45, 85),
          flamingo: color2("#e5c3c3", 0, 45, 82),
          pink: color2("#d8a8cc", 316, 40, 75),
          mauve: color2("#9d7bc7", 267, 45, 65),
          // Electric Purple (muted)
          red: color2("#c85a7a", 343, 45, 60),
          maroon: color2("#c27882", 350, 35, 65),
          peach: color2("#d18a5f", 23, 50, 60),
          yellow: color2("#d4c285", 41, 45, 70),
          green: color2("#8cc98a", 115, 35, 65),
          teal: color2("#7bc5b8", 174, 35, 65),
          sky: color2("#7ab5c7", 189, 40, 65),
          sapphire: color2("#6baac7", 199, 45, 60),
          blue: color2("#7d9dd4", 217, 50, 65),
          // Electric Blue (muted)
          lavender: color2("#a8aed9", 232, 45, 75),
          text: color2("#c2c8d4", 226, 25, 80),
          subtext1: color2("#b2b8c8", 227, 20, 72),
          subtext0: color2("#9ca4b8", 228, 15, 65),
          overlay2: color2("#868ea8", 228, 12, 58),
          overlay1: color2("#757d95", 230, 10, 52),
          overlay0: color2("#656c82", 231, 8, 45),
          surface2: color2("#555c70", 233, 8, 38),
          surface1: color2("#454c5a", 234, 8, 32),
          surface0: color2("#353a46", 237, 10, 25),
          base: color2("#252832", 240, 12, 17),
          mantle: color2("#1f222a", 240, 10, 15),
          crust: color2("#181b22", 240, 15, 12)
        },
        // Balanced: Moderate cinematic intensity with vibrant gradients
        balanced: {
          rosewater: color2("#f2d8d3", 15, 60, 88),
          flamingo: color2("#eec6c6", 0, 60, 85),
          pink: color2("#e8b3d8", 316, 55, 80),
          mauve: color2("#b388d6", 267, 55, 70),
          // Electric Purple (balanced)
          red: color2("#d16b8a", 343, 55, 65),
          maroon: color2("#d08692", 350, 45, 70),
          peach: color2("#e59a6f", 23, 65, 65),
          yellow: color2("#e0d295", 41, 55, 75),
          green: color2("#9cd49a", 115, 40, 70),
          teal: color2("#8bd0c3", 174, 40, 70),
          sky: color2("#8ac0d2", 189, 50, 70),
          sapphire: color2("#7bb5d2", 199, 55, 65),
          blue: color2("#8da8e0", 217, 60, 70),
          // Electric Blue (balanced)
          lavender: color2("#b8bee5", 232, 55, 80),
          text: color2("#ced4e0", 226, 35, 85),
          subtext1: color2("#bec4d3", 227, 25, 77),
          subtext0: color2("#a8b0c3", 228, 20, 70),
          overlay2: color2("#929ab3", 228, 15, 63),
          overlay1: color2("#8289a0", 230, 12, 57),
          overlay0: color2("#72798f", 231, 10, 50),
          surface2: color2("#62697d", 233, 10, 43),
          surface1: color2("#525968", 234, 10, 37),
          surface0: color2("#424954", 237, 12, 30),
          base: color2("#2f323e", 240, 15, 22),
          mantle: color2("#282b36", 240, 12, 19),
          crust: color2("#21242e", 240, 18, 16)
        },
        // Cinematic: Full intensity Year 3000 gradients with dramatic contrast
        cinematic: {
          rosewater: color2("#fce0db", 15, 85, 92),
          flamingo: color2("#f5c9c9", 0, 85, 88),
          pink: color2("#ff6b9d", 316, 100, 70),
          // Vivid Magenta (from visual guide)
          mauve: color2("#6c5ce7", 267, 85, 65),
          // Electric Purple (from visual guide)
          red: color2("#ff4757", 343, 100, 65),
          // Cosmic Red (from visual guide)
          maroon: color2("#e84393", 350, 80, 70),
          peach: color2("#fd7f28", 23, 95, 58),
          // Luminous Orange (from visual guide)
          yellow: color2("#f39c12", 41, 88, 52),
          green: color2("#a6e3a1", 115, 54, 76),
          teal: color2("#00cec9", 174, 100, 40),
          // Neon Cyan (from visual guide)
          sky: color2("#74b9ff", 189, 100, 72),
          // Electric Blue (from visual guide)
          sapphire: color2("#0984e3", 199, 100, 46),
          blue: color2("#a29bfe", 217, 95, 80),
          lavender: color2("#c77dff", 232, 100, 75),
          text: color2("#e8f0ff", 226, 100, 95),
          subtext1: color2("#d0d8f0", 227, 65, 88),
          subtext0: color2("#b8c0d8", 228, 45, 80),
          overlay2: color2("#a0a8c0", 228, 30, 70),
          overlay1: color2("#8890a8", 230, 20, 60),
          overlay0: color2("#707890", 231, 15, 50),
          surface2: color2("#586078", 233, 15, 42),
          surface1: color2("#485060", 234, 15, 35),
          surface0: color2("#384048", 237, 18, 28),
          base: color2("#202030", 240, 25, 16),
          mantle: color2("#181828", 240, 22, 13),
          crust: color2("#101020", 240, 30, 9)
        },
        // Maximum: Ultra-intense Year 3000 with maximum saturation and contrast
        maximum: {
          rosewater: color2("#ffe5e0", 15, 100, 95),
          flamingo: color2("#ffcccc", 0, 100, 90),
          pink: color2("#ff3d7f", 316, 100, 62),
          // Maximum Vivid Magenta
          mauve: color2("#5a4fcf", 267, 100, 55),
          // Maximum Electric Purple
          red: color2("#ff2942", 343, 100, 58),
          // Maximum Cosmic Red
          maroon: color2("#e6337a", 350, 90, 65),
          peach: color2("#ff6500", 23, 100, 50),
          // Maximum Luminous Orange
          yellow: color2("#f1c40f", 48, 89, 50),
          green: color2("#00ff88", 150, 100, 50),
          teal: color2("#00ffff", 180, 100, 50),
          // Maximum Neon Cyan
          sky: color2("#4da6ff", 189, 100, 65),
          // Maximum Electric Blue
          sapphire: color2("#0066ff", 199, 100, 50),
          blue: color2("#8a7fff", 217, 100, 75),
          lavender: color2("#b347ff", 232, 100, 65),
          text: color2("#ffffff", 0, 0, 100),
          subtext1: color2("#e8e8ff", 240, 100, 95),
          subtext0: color2("#d0d0ff", 240, 100, 90),
          overlay2: color2("#b8b8ff", 240, 100, 85),
          overlay1: color2("#a0a0ff", 240, 100, 80),
          overlay0: color2("#8888ff", 240, 100, 75),
          surface2: color2("#4040aa", 240, 60, 45),
          surface1: color2("#303088", 240, 65, 35),
          surface0: color2("#202066", 240, 70, 25),
          base: color2("#0f0f33", 240, 70, 13),
          mantle: color2("#0a0a22", 240, 75, 10),
          crust: color2("#050511", 240, 80, 5)
        }
      };
      BRIGHTNESS_CONFIGS2 = {
        bright: {
          baseColorTarget: 0.25,
          // Lighter base colors
          surfaceColorTarget: 0.35,
          textContrastMin: 4.5
        },
        balanced: {
          baseColorTarget: 0.15,
          // Standard base colors  
          surfaceColorTarget: 0.25,
          textContrastMin: 4.5
        },
        dark: {
          baseColorTarget: 0.08,
          // Darker base colors
          surfaceColorTarget: 0.15,
          textContrastMin: 3
          // Slightly lower contrast for dark mode comfort
        }
      };
      __name(getBrightnessAdjustedBaseColor2, "getBrightnessAdjustedBaseColor");
      __name(getBrightnessAdjustedSurfaceColor2, "getBrightnessAdjustedSurfaceColor");
      __name(getYear3000AccentColor, "getYear3000AccentColor");
      __name(getDefaultAccentColor2, "getDefaultAccentColor");
      __name(getCinematicGradientPair, "getCinematicGradientPair");
      __name(getAnimatedFlowColors, "getAnimatedFlowColors");
    }
  });

  // src-js/utils/color/PaletteSystemManager.ts
  function getBrightnessAdjustedBaseColor3(flavor, brightnessMode = "balanced") {
    return paletteSystemManager.getBrightnessAdjustedBaseColor(flavor, brightnessMode);
  }
  function getBrightnessAdjustedSurfaceColor3(flavor, brightnessMode = "balanced") {
    return paletteSystemManager.getBrightnessAdjustedSurfaceColor(flavor, brightnessMode);
  }
  function getDefaultAccentColor3(flavor) {
    return paletteSystemManager.getDefaultAccentColor(flavor);
  }
  function getAccentColor(accentName, flavor) {
    return paletteSystemManager.getAccentColor(accentName, flavor);
  }
  var _PaletteSystemManager, PaletteSystemManager, paletteSystemManager;
  var init_PaletteSystemManager = __esm({
    "src-js/utils/color/PaletteSystemManager.ts"() {
      "use strict";
      init_globalConfig();
      init_CatppuccinPalettes();
      init_Year3000Palettes();
      init_CatppuccinPalettes();
      init_Year3000Palettes();
      _PaletteSystemManager = class _PaletteSystemManager {
        constructor() {
        }
        static getInstance() {
          if (!_PaletteSystemManager.instance) {
            _PaletteSystemManager.instance = new _PaletteSystemManager();
          }
          return _PaletteSystemManager.instance;
        }
        /**
         * Get the currently active palette system from configuration
         */
        getCurrentPaletteSystem() {
          return ADVANCED_SYSTEM_CONFIG.paletteSystem || "catppuccin";
        }
        /**
         * Get the current active palette based on configuration
         */
        getCurrentPalette() {
          const system = this.getCurrentPaletteSystem();
          return system === "year3000" ? YEAR3000_PALETTES : CATPPUCCIN_PALETTES;
        }
        /**
         * Get the current default flavor for the active palette system
         */
        getCurrentDefaultFlavor() {
          const system = this.getCurrentPaletteSystem();
          return system === "year3000" ? "balanced" : "mocha";
        }
        /**
         * Get brightness-adjusted base color from current palette system
         */
        getBrightnessAdjustedBaseColor(flavor, brightnessMode = "balanced") {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getBrightnessAdjustedBaseColor2(
              activeFlavor,
              brightnessMode
            );
          } else {
            return getBrightnessAdjustedBaseColor(
              activeFlavor,
              brightnessMode
            );
          }
        }
        /**
         * Get brightness-adjusted surface color from current palette system
         */
        getBrightnessAdjustedSurfaceColor(flavor, brightnessMode = "balanced") {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getBrightnessAdjustedSurfaceColor2(
              activeFlavor,
              brightnessMode
            );
          } else {
            return getBrightnessAdjustedSurfaceColor(
              activeFlavor,
              brightnessMode
            );
          }
        }
        /**
         * Get default accent color from current palette system
         */
        getDefaultAccentColor(flavor) {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getDefaultAccentColor2(activeFlavor);
          } else {
            return getDefaultAccentColor(activeFlavor);
          }
        }
        /**
         * Get specific accent color from current palette system
         */
        getAccentColor(accentName, flavor) {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getYear3000AccentColor(
              activeFlavor,
              accentName
            );
          } else {
            return getCatppuccinAccentColor(
              activeFlavor,
              accentName
            );
          }
        }
        /**
         * Get cinematic gradient colors (Year 3000 specific, fallback for Catppuccin)
         */
        getCinematicGradientPair(flavor, intensity = "medium") {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getCinematicGradientPair(
              activeFlavor,
              intensity
            );
          } else {
            const palette = CATPPUCCIN_PALETTES[activeFlavor];
            switch (intensity) {
              case "low":
                return [palette.mauve, palette.blue];
              case "medium":
                return [palette.pink, palette.peach];
              case "high":
                return [palette.red, palette.teal];
              default:
                return [palette.mauve, palette.pink];
            }
          }
        }
        /**
         * Get smooth flow colors (Year 3000 specific, fallback for Catppuccin)
         */
        getAnimatedFlowColors(flavor) {
          const system = this.getCurrentPaletteSystem();
          const activeFlavor = flavor || this.getCurrentDefaultFlavor();
          if (system === "year3000") {
            return getAnimatedFlowColors(activeFlavor);
          } else {
            const palette = CATPPUCCIN_PALETTES[activeFlavor];
            return {
              primary: palette.mauve,
              secondary: palette.pink,
              tertiary: palette.blue,
              atmosphere: palette.base
            };
          }
        }
        /**
         * Check if current palette system supports cinematic features
         */
        supportsCinematicFeatures() {
          return this.getCurrentPaletteSystem() === "year3000";
        }
        /**
         * Get palette system display name for UI
         */
        getPaletteSystemDisplayName() {
          const system = this.getCurrentPaletteSystem();
          return system === "year3000" ? "Year 3000 Cinematic" : "Catppuccin Classic";
        }
      };
      __name(_PaletteSystemManager, "PaletteSystemManager");
      PaletteSystemManager = _PaletteSystemManager;
      paletteSystemManager = PaletteSystemManager.getInstance();
      __name(getBrightnessAdjustedBaseColor3, "getBrightnessAdjustedBaseColor");
      __name(getBrightnessAdjustedSurfaceColor3, "getBrightnessAdjustedSurfaceColor");
      __name(getDefaultAccentColor3, "getDefaultAccentColor");
      __name(getAccentColor, "getAccentColor");
    }
  });

  // src-js/utils/core/PaletteExtensionManager.ts
  var GENRE_PALETTE_HINTS, _PaletteExtensionManager, PaletteExtensionManager;
  var init_PaletteExtensionManager = __esm({
    "src-js/utils/core/PaletteExtensionManager.ts"() {
      "use strict";
      GENRE_PALETTE_HINTS = {
        jazz: { temperatureShift: 15, saturationBoost: 1.1, warmth: 0.8 },
        electronic: { temperatureShift: -10, saturationBoost: 1.2, warmth: 0.2 },
        classical: { temperatureShift: 5, saturationBoost: 0.9, warmth: 0.6 },
        rock: { temperatureShift: 0, saturationBoost: 1.15, warmth: 0.5 },
        ambient: { temperatureShift: -5, saturationBoost: 0.8, warmth: 0.3 },
        hiphop: { temperatureShift: 8, saturationBoost: 1.25, warmth: 0.7 },
        pop: { temperatureShift: 0, saturationBoost: 1, warmth: 0.5 },
        metal: { temperatureShift: -15, saturationBoost: 1.3, warmth: 0.1 },
        indie: { temperatureShift: 10, saturationBoost: 0.95, warmth: 0.6 },
        default: { temperatureShift: 0, saturationBoost: 1, warmth: 0.5 }
      };
      _PaletteExtensionManager = class _PaletteExtensionManager {
        constructor(config, utils) {
          this.paletteCache = {};
          this.cacheTTL = 3e5;
          // 5 minutes
          this.maxCacheSize = 50;
          this.config = config;
          this.utils = utils;
        }
        // TODO: Phase 3 - Load custom palette from JSON with validation
        async loadCustomPalette(paletteId, source) {
          const cached = this.paletteCache[paletteId];
          if (cached && Date.now() - cached.timestamp < this.cacheTTL && cached.isValid) {
            if (this.config.enableDebug) {
              console.log(
                `[PaletteExtensionManager] Cache hit for palette: ${paletteId}`
              );
            }
            return cached.palette;
          }
          try {
            const fallbackPalette = this.generateFallbackPalette(paletteId);
            if (this.validatePalette(fallbackPalette)) {
              this.cachePalette(paletteId, fallbackPalette, true);
              return fallbackPalette;
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[PaletteExtensionManager] Failed to load palette ${paletteId}:`,
                error
              );
            }
          }
          return null;
        }
        // TODO: Phase 3 - Generate fallback palette for unknown themes
        generateFallbackPalette(themeName) {
          const root = this.utils.getRootStyle();
          const computedStyle = getComputedStyle(root);
          const baseColor = computedStyle.getPropertyValue("--spice-main").trim() || computedStyle.getPropertyValue("--spice-base").trim() || "#1e1e2e";
          const accentColor = (
            // Prefer Year 3000 dynamic accent if it's already available, else fall back to spice button, then to dynamic accent fallback.
            computedStyle.getPropertyValue("--sn-gradient-accent").trim() || computedStyle.getPropertyValue("--spice-button").trim() || computedStyle.getPropertyValue("--sn-dynamic-accent").trim() || computedStyle.getPropertyValue("--spice-accent").trim() || "#8caaee"
          );
          const baseRgb = this.utils.hexToRgb(
            baseColor.startsWith("#") ? baseColor : `#${baseColor}`
          );
          const accentRgb = this.utils.hexToRgb(
            accentColor.startsWith("#") ? accentColor : `#${accentColor}`
          );
          if (!baseRgb || !accentRgb) {
            const dynamicAccent = computedStyle.getPropertyValue("--sn-dynamic-accent").trim();
            const dynamicBase = computedStyle.getPropertyValue("--spice-base").trim();
            return {
              name: themeName,
              version: "1.0.0",
              accents: {
                mauve: dynamicAccent || "#ca9ee6",
                pink: "#f4b8e4",
                blue: dynamicAccent || "#8caaee",
                sapphire: "#85c1dc",
                sky: "#99d1db",
                teal: "#81c8be",
                green: "#a6d189",
                yellow: "#e5c890",
                peach: "#ef9f76",
                red: "#e78284",
                lavender: "#babbf1"
              },
              neutrals: {
                base: dynamicBase || "#1e1e2e",
                surface0: "#313244",
                surface1: "#45475a",
                surface2: "#585b70",
                overlay0: "#6c7086",
                overlay1: "#7f849c",
                overlay2: "#9399b2",
                text: "#cdd6f4"
              },
              metadata: {
                author: "PaletteExtensionManager",
                description: `Generated fallback for ${themeName}`,
                temperature: "neutral"
              }
            };
          }
          const baseHsl = this.utils.rgbToHsl(baseRgb.r, baseRgb.g, baseRgb.b);
          const accentHsl = this.utils.rgbToHsl(
            accentRgb.r,
            accentRgb.g,
            accentRgb.b
          );
          return {
            name: themeName,
            version: "1.0.0",
            accents: this.generateAccentVariations(accentHsl),
            neutrals: this.generateNeutralVariations(baseHsl),
            metadata: {
              author: "PaletteExtensionManager",
              description: `Generated palette for ${themeName}`,
              temperature: this.detectTemperature(baseHsl, accentHsl)
            }
          };
        }
        // TODO: Phase 3 - Apply genre-aware modifications to palette
        applyGenreAwareModifications(palette, genre) {
          const genreHints = GENRE_PALETTE_HINTS[genre] || GENRE_PALETTE_HINTS.default;
          if (this.config.enableDebug) {
            console.log(
              `[PaletteExtensionManager] Applying ${genre} hints to palette:`,
              genreHints
            );
          }
          const modifiedPalette = {
            ...palette,
            accents: {},
            neutrals: {},
            metadata: {
              ...palette.metadata,
              genre: [...palette.metadata?.genre || [], genre]
            }
          };
          for (const [key, color3] of Object.entries(palette.accents)) {
            modifiedPalette.accents[key] = this.applyGenreColorModification(
              color3,
              genreHints.temperatureShift,
              genreHints.saturationBoost
            );
          }
          for (const [key, color3] of Object.entries(palette.neutrals)) {
            modifiedPalette.neutrals[key] = this.applyGenreColorModification(
              color3,
              genreHints.temperatureShift * 0.3,
              // Less intense for neutrals
              genreHints.saturationBoost * 0.7
            );
          }
          return modifiedPalette;
        }
        // TODO: Phase 3 - Validate palette structure and required properties
        validatePalette(palette) {
          if (!palette || typeof palette !== "object") return false;
          if (!palette.name || typeof palette.name !== "string") return false;
          if (!palette.version || typeof palette.version !== "string") return false;
          if (!palette.accents || typeof palette.accents !== "object") return false;
          if (!palette.neutrals || typeof palette.neutrals !== "object") return false;
          const allColors = [
            ...Object.values(palette.accents),
            ...Object.values(palette.neutrals)
          ];
          for (const color3 of allColors) {
            if (typeof color3 !== "string" || !this.isValidHexColor(color3)) {
              return false;
            }
          }
          return true;
        }
        // TODO: Phase 3 - Cache management
        cachePalette(paletteId, palette, isValid) {
          if (Object.keys(this.paletteCache).length >= this.maxCacheSize) {
            const oldestEntry = Object.entries(this.paletteCache).sort(
              ([, aVal], [, bVal]) => aVal.timestamp - bVal.timestamp
            )[0];
            const oldestKey = oldestEntry?.[0];
            if (oldestKey && this.paletteCache[oldestKey]) {
              delete this.paletteCache[oldestKey];
            }
          }
          this.paletteCache[paletteId] = {
            palette,
            timestamp: Date.now(),
            isValid
          };
        }
        // TODO: Phase 3 - Generate accent color variations
        generateAccentVariations(baseHsl) {
          const variations = {};
          const hueShifts = [0, 30, 60, 120, 180, 210, 240, 300, 330, 45, 90];
          const names = [
            "primary",
            "secondary",
            "tertiary",
            "complement",
            "opposite",
            "warm1",
            "cool1",
            "accent1",
            "accent2",
            "highlight",
            "emphasis"
          ];
          hueShifts.forEach((shift, index) => {
            const name = names[index] || `variant${index}`;
            const adjustedHue = (baseHsl.h + shift) % 360;
            const rgb = this.utils.hslToRgb(adjustedHue, baseHsl.s, baseHsl.l);
            if (rgb) {
              variations[name] = this.utils.rgbToHex(rgb.r, rgb.g, rgb.b);
            }
          });
          return variations;
        }
        // TODO: Phase 3 - Generate neutral color variations
        generateNeutralVariations(baseHsl) {
          const neutrals = {};
          const lightnessLevels = [
            { name: "base", l: baseHsl.l },
            { name: "surface0", l: Math.min(95, baseHsl.l + 10) },
            { name: "surface1", l: Math.min(90, baseHsl.l + 20) },
            { name: "surface2", l: Math.min(85, baseHsl.l + 30) },
            { name: "overlay0", l: Math.min(80, baseHsl.l + 40) },
            { name: "overlay1", l: Math.min(75, baseHsl.l + 50) },
            { name: "text", l: Math.min(95, baseHsl.l + 60) }
          ];
          lightnessLevels.forEach((level) => {
            const rgb = this.utils.hslToRgb(
              baseHsl.h,
              Math.max(0, baseHsl.s - 20),
              level.l
            );
            if (rgb) {
              neutrals[level.name] = this.utils.rgbToHex(rgb.r, rgb.g, rgb.b);
            }
          });
          return neutrals;
        }
        // TODO: Phase 3 - Detect color temperature
        detectTemperature(baseHsl, accentHsl) {
          const avgHue = (baseHsl.h + accentHsl.h) / 2;
          if (avgHue >= 0 && avgHue <= 60 || avgHue >= 300 && avgHue <= 360) {
            return "warm";
          } else if (avgHue >= 120 && avgHue <= 240) {
            return "cool";
          } else {
            return "neutral";
          }
        }
        // TODO: Phase 3 - Apply genre-specific color modifications
        applyGenreColorModification(hexColor, temperatureShift, saturationBoost) {
          const rgb = this.utils.hexToRgb(hexColor);
          if (!rgb) return hexColor;
          const hsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
          const adjustedHue = (hsl.h + temperatureShift + 360) % 360;
          const adjustedSaturation = Math.max(
            0,
            Math.min(100, hsl.s * saturationBoost)
          );
          const modifiedRgb = this.utils.hslToRgb(
            adjustedHue,
            adjustedSaturation,
            hsl.l
          );
          if (modifiedRgb) {
            return this.utils.rgbToHex(modifiedRgb.r, modifiedRgb.g, modifiedRgb.b);
          }
          return hexColor;
        }
        // TODO: Phase 3 - Validate hex color format
        isValidHexColor(color3) {
          return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color3);
        }
        // TODO: Phase 3 - Public API for getting genre hints
        getGenreHints(genre) {
          return GENRE_PALETTE_HINTS[genre] || GENRE_PALETTE_HINTS.default;
        }
        // TODO: Phase 3 - Clear cache
        clearCache() {
          this.paletteCache = {};
          if (this.config.enableDebug) {
            console.log("[PaletteExtensionManager] Palette cache cleared");
          }
        }
      };
      __name(_PaletteExtensionManager, "PaletteExtensionManager");
      PaletteExtensionManager = _PaletteExtensionManager;
    }
  });

  // src-js/core/css/UnifiedCSSVariableManager.ts
  var CRITICAL_NOW_PLAYING_VARS, _UnifiedCSSVariableManager, UnifiedCSSVariableManager;
  var init_UnifiedCSSVariableManager = __esm({
    "src-js/core/css/UnifiedCSSVariableManager.ts"() {
      "use strict";
      init_UnifiedEventBus();
      CRITICAL_NOW_PLAYING_VARS = /* @__PURE__ */ new Set([
        // Legacy variables (Phase 1 migration)
        "--sn-beat-pulse-intensity",
        "--sn-animation-scale",
        "--sn-accent-hex",
        "--sn-accent-rgb",
        // New namespaced variables (Phase 2+)
        "--sn.music.beat.pulse.intensity",
        "--sn.music.animation.scale",
        "--sn.music.rhythm.phase",
        "--sn.music.spectrum.phase",
        "--sn.color.accent.hex",
        "--sn.color.accent.rgb",
        "--sn.bg.webgl.ready",
        "--sn.bg.active-backend"
      ]);
      _UnifiedCSSVariableManager = class _UnifiedCSSVariableManager {
        constructor(config, performanceCoordinator) {
          this.initialized = false;
          // === BATCHING LAYER (from UnifiedCSSVariableManager) ===
          this.cssVariableQueue = /* @__PURE__ */ new Map();
          this.batchUpdateTimer = null;
          this.rafHandle = null;
          this.microtaskScheduled = false;
          // === MANAGEMENT LAYER (from UnifiedCSSVariableManager) ===
          this.pendingTransactions = /* @__PURE__ */ new Map();
          this.transactionCounter = 0;
          this.updateQueue = /* @__PURE__ */ new Map();
          this.flushTimer = null;
          // === PERFORMANCE LAYER (from UnifiedCSSVariableManager) ===
          this.currentDeviceCapabilities = null;
          this.currentPerformanceMode = null;
          this.lastCSSUpdate = 0;
          this.cssUpdateThrottle = 100;
          // Update CSS at most every 100ms
          this.appliedClasses = /* @__PURE__ */ new Set();
          // === CONSCIOUSNESS LAYER (new integration) ===
          this.visualEffectsState = null;
          this.visualEffectsUpdateTimer = null;
          this.lastVisualEffectsUpdate = 0;
          // === ENHANCED OPTIMIZATION LAYER (from OptimizedCSSVariableManager) ===
          this.optimizedConfig = {};
          this.lastFPSCheck = 0;
          this.currentPerformanceLevel = "good";
          this.adaptiveThrottleLevel = 1;
          this.priorityQueues = /* @__PURE__ */ new Map();
          this.adaptiveMonitoringInterval = null;
          // === FRAME CONTEXT INTEGRATION (from CDFVariableBridge) ===
          this.frameContextUnsubscribe = null;
          this.reduceMotionMQ = null;
          this.mqHandler = null;
          // Performance tracking
          this.performanceMetrics = {
            totalBatches: 0,
            totalUpdates: 0,
            totalBatchTime: 0,
            maxBatchTime: 0,
            averageBatchSize: 0,
            overBudgetBatches: 0,
            conflictResolutions: 0,
            transactionCount: 0,
            visualEffectsUpdates: 0
          };
          // Priority weights for conflict resolution
          this.PRIORITY_WEIGHTS = {
            low: 1,
            normal: 2,
            high: 3,
            critical: 4
          };
          this.config = config;
          this.performanceCoordinator = performanceCoordinator;
          this.eventBus = unifiedEventBus;
          this.cssConfig = {
            // Batching configuration
            batchIntervalMs: 0,
            // 0 = coalesced; scheduling handled via rAF/microtask
            maxBatchSize: 50,
            enableDebug: config.enableDebug,
            useCssTextFastPath: false,
            autoHijack: true,
            // Performance configuration
            enableAdaptiveOptimization: true,
            enableThermalThrottling: true,
            enableBatteryOptimization: true,
            enableDeviceTierOptimization: true,
            debugPerformanceClasses: config.enableDebug,
            // Consciousness configuration
            enableVisualEffectsIntegration: true,
            visualEffectsUpdateInterval: 16,
            // 60fps
            enableMusicVisualEffects: true,
            enableAestheticVisualEffects: true,
            // Enhanced optimization features (from OptimizedCSSVariableManager)
            enableAdaptiveThrottling: true,
            priorityMappings: {
              critical: ["--sn-rs-glow-alpha", "--sn-rs-beat-intensity", "--sn-rs-hue-shift"],
              high: ["--sn-gradient-primary", "--sn-gradient-secondary", "--sn-gradient-accent"],
              normal: ["--sn-gradient-", "--sn-rs-"],
              low: ["--sn-debug-", "--sn-dev-"]
            },
            thresholds: {
              excellentFPS: 55,
              // 55+ FPS = excellent
              goodFPS: 45,
              // 45+ FPS = good
              poorFPS: 30
              // <30 FPS = poor
            }
          };
          this.optimizedConfig = this.cssConfig;
          this.currentDeviceCapabilities = this.performanceCoordinator.getDeviceCapabilities();
          this.currentPerformanceMode = this.performanceCoordinator.getCurrentPerformanceMode();
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSVariableManager] Created with visual-effects-driven CSS management"
            );
          }
        }
        // Deprecated getInstance() method removed - use dependency injection through SystemCoordinator
        // or getGlobalOptimizedCSSController() for simple utility usage
        // ===================================================================
        // IMANAGEDYSTEM INTERFACE IMPLEMENTATION
        // ===================================================================
        async initialize() {
          if (this.initialized) return;
          this.subscribeToEvents();
          this.applyInitialOptimizations();
          if (this.cssConfig.enableVisualEffectsIntegration) {
            this.startVisualEffectsIntegration();
          }
          if (this.cssConfig.autoHijack) {
            this.enableGlobalHijack();
          }
          this.initializeOptimizedFeatures();
          this.initializeFrameContextIntegration();
          this.initialized = true;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSVariableManager] Initialized with device tier:",
              this.currentDeviceCapabilities?.performanceTier
            );
          }
        }
        updateAnimation(deltaTime) {
        }
        async healthCheck() {
          const queueSize = this.cssVariableQueue.size + this.updateQueue.size;
          const pendingTransactions = this.pendingTransactions.size;
          const isHealthy = queueSize <= 1e3 && pendingTransactions <= 100;
          return {
            system: "UnifiedCSSVariableManager",
            healthy: isHealthy,
            ok: isHealthy,
            details: isHealthy ? "CSS visual-effects controller operating normally" : "High queue size or pending transactions",
            metrics: {
              queueSize,
              pendingTransactions,
              performanceMetrics: this.performanceMetrics,
              visualEffectsActive: this.visualEffectsState !== null,
              deviceTier: this.currentDeviceCapabilities?.performanceTier,
              performanceMode: this.currentPerformanceMode?.name
            }
          };
        }
        forceRepaint(reason) {
          this.flushCSSVariableBatch();
          if (this.config.enableDebug && reason) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Force repaint: ${reason}`
            );
          }
        }
        // ===================================================================
        // PUBLIC API - UNIFIED CSS VARIABLE OPERATIONS
        // ===================================================================
        /**
         * Queue a CSS variable update with priority and visual-effects awareness
         * Enhanced with adaptive throttling and priority queue management
         */
        queueCSSVariableUpdate(property, value, element = null, priority = "normal", source = "unknown") {
          const targetElement = element || document.documentElement;
          const effectivePriority = this.optimizedConfig.enableAdaptiveThrottling ? this.determineVariablePriority(property, priority) : priority;
          if (effectivePriority === "critical" || CRITICAL_NOW_PLAYING_VARS.has(property)) {
            this.applyCriticalUpdate(property, value, targetElement);
            return;
          }
          if (this.optimizedConfig.enableAdaptiveThrottling && this.priorityQueues.size > 0) {
            this.queueByPriority(property, value, targetElement, effectivePriority, source);
            return;
          }
          const elementKey = element ? `element_${element.id || element.className || "unnamed"}` : "root";
          const updateKey = `${elementKey}:${property}`;
          const update = {
            element: targetElement,
            property,
            value,
            timestamp: performance.now(),
            priority: effectivePriority,
            source
          };
          const existingUpdate = this.cssVariableQueue.get(updateKey);
          if (existingUpdate) {
            if (this.shouldReplaceUpdate(existingUpdate, update)) {
              this.cssVariableQueue.set(updateKey, update);
              this.performanceMetrics.conflictResolutions++;
            }
          } else {
            this.cssVariableQueue.set(updateKey, update);
          }
          this.performanceMetrics.totalUpdates++;
          this.scheduleFlush(effectivePriority);
          if (effectivePriority === "critical" || this.cssVariableQueue.size >= this.cssConfig.maxBatchSize) {
            this.flushCSSVariableBatch();
          }
        }
        /**
         * Update multiple CSS variables in a transaction
         */
        updateVariables(variables, priority = "normal", source = "unknown") {
          const transactionId = `tx_${++this.transactionCounter}`;
          const variableMap = new Map(Object.entries(variables));
          const transaction = {
            id: transactionId,
            variables: variableMap,
            timestamp: performance.now(),
            priority,
            completed: false
          };
          this.pendingTransactions.set(transactionId, transaction);
          for (const [property, value] of variableMap) {
            this.queueCSSVariableUpdate(
              property,
              value,
              null,
              priority,
              `${source}:${transactionId}`
            );
          }
          this.performanceMetrics.transactionCount++;
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Transaction ${transactionId} queued with ${variableMap.size} variables`
            );
          }
        }
        /**
         * Update visual-effects-driven CSS variables
         */
        updateVisualEffectsVariables(visualEffectsState) {
          if (!this.cssConfig.enableVisualEffectsIntegration) return;
          this.visualEffectsState = visualEffectsState;
          this.performanceMetrics.visualEffectsUpdates++;
          const variables = {};
          if (visualEffectsState.musicState && this.cssConfig.enableMusicVisualEffects) {
            variables["--sn.music.beat.pulse.intensity"] = visualEffectsState.musicState.intensity.toString();
            variables["--sn.music.tempo.bpm"] = visualEffectsState.musicState.bpm.toString();
            variables["--sn.music.rhythm.phase"] = `${visualEffectsState.musicState.rhythmPhase}deg`;
            variables["--sn.music.animation.scale"] = visualEffectsState.musicState.animationScale.toString();
            variables["--sn.music.energy.level"] = visualEffectsState.musicState.energy.toString();
            variables["--sn.music.valence"] = visualEffectsState.musicState.valence.toString();
          }
          if (visualEffectsState.aestheticState && this.cssConfig.enableAestheticVisualEffects) {
            variables["--sn.aesthetic.harmony.level"] = visualEffectsState.aestheticState.harmonyLevel.toString();
            variables["--sn.aesthetic.evolution.factor"] = visualEffectsState.aestheticState.evolutionFactor.toString();
            variables["--sn.color.temperature"] = visualEffectsState.aestheticState.colorTemperature.toString();
          }
          if (visualEffectsState.performanceState) {
            variables["--sn.performance.mode"] = visualEffectsState.performanceState.mode;
            variables["--sn.device.tier"] = visualEffectsState.performanceState.deviceTier;
            variables["--sn.performance.optimization.level"] = visualEffectsState.performanceState.optimizationLevel.toString();
          }
          this.updateVariables(variables, "high", "visual-effects-system");
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Consciousness state updated with ${Object.keys(variables).length} variables`
            );
          }
        }
        /**
         * Apply performance-based optimizations
         */
        applyPerformanceOptimizations(performanceMode) {
          if (!this.cssConfig.enableAdaptiveOptimization) return;
          this.currentPerformanceMode = performanceMode;
          const variables = {
            "--sn.performance.mode": performanceMode.name,
            "--sn.performance.quality.level": performanceMode.qualityLevel.toString(),
            "--sn.performance.fps.target": performanceMode.frameRate.toString(),
            "--sn.performance.frame.budget": (1e3 / performanceMode.frameRate).toString(),
            "--sn.performance.optimization.level": performanceMode.optimizationLevel.toString(),
            "--sn.performance.blur.quality": performanceMode.blurQuality.toString(),
            "--sn.performance.shadow.quality": performanceMode.shadowQuality.toString(),
            "--sn.performance.animation.quality": performanceMode.animationQuality.toString(),
            "--sn.performance.effect.quality": performanceMode.effectQuality.toString()
          };
          this.updateVariables(variables, "high", "performance-coordinator");
          this.applyPerformanceModeOptimizations();
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Performance optimizations applied for mode: ${performanceMode.name}`
            );
          }
        }
        /**
         * Get a CSS variable value
         */
        getVariable(key) {
          const computedStyle = getComputedStyle(document.documentElement);
          return computedStyle.getPropertyValue(key).trim() || null;
        }
        /**
         * Force immediate flush of all pending updates
         */
        flushUpdates() {
          this.flushCSSVariableBatch();
        }
        /**
         * Optimized CSS variable batch flush with efficient DOM operations
         */
        flushCSSVariableBatch() {
          if (this.cssVariableQueue.size === 0) return;
          const startTime = performance.now();
          const FRAME_BUDGET = 8;
          const updates = Array.from(this.cssVariableQueue.values());
          this.cssVariableQueue.clear();
          if (this.rafHandle !== null) {
            cancelAnimationFrame(this.rafHandle);
            this.rafHandle = null;
          }
          this.microtaskScheduled = false;
          try {
            const updatesByElement = /* @__PURE__ */ new Map();
            for (const update of updates) {
              if (!updatesByElement.has(update.element)) {
                updatesByElement.set(update.element, []);
              }
              updatesByElement.get(update.element).push(update);
            }
            for (const [element, elementUpdates] of updatesByElement.entries()) {
              if (performance.now() - startTime > FRAME_BUDGET) {
                for (const update of elementUpdates) {
                  const updateKey = `${update.element.id || "root"}:${update.property}`;
                  this.cssVariableQueue.set(updateKey, update);
                }
                this.scheduleFlush("high");
                break;
              }
              if (elementUpdates.length >= 3) {
                this.applyCSSTextBatch(element, elementUpdates);
              } else {
                for (const update of elementUpdates) {
                  if (_UnifiedCSSVariableManager.nativeSetProperty) {
                    _UnifiedCSSVariableManager.nativeSetProperty.call(
                      element.style,
                      update.property,
                      update.value
                    );
                  } else {
                    element.style.setProperty(update.property, update.value);
                  }
                }
              }
            }
            const batchTime = performance.now() - startTime;
            this.updatePerformanceMetrics(batchTime, updates.length);
            if (batchTime > FRAME_BUDGET && this.config.enableDebug) {
              console.warn(
                `\u{1F30C} [UnifiedCSSVariableManager] CSS batch exceeded frame budget: ${batchTime.toFixed(
                  2
                )}ms (${updates.length} updates)`
              );
            } else if (this.config.enableDebug && Math.random() < 0.05) {
              console.log(
                `\u{1F30C} [UnifiedCSSVariableManager] Efficient CSS batch: ${updates.length} updates in ${batchTime.toFixed(2)}ms`
              );
            }
          } catch (error) {
            console.error(
              "[UnifiedCSSVariableManager] Error in optimized CSS batch processing:",
              error
            );
            this.applyUpdatesWithFallback(updates);
          }
        }
        /**
         * Optimized cssText batching using efficient string building
         */
        applyCSSTextBatch(element, updates) {
          try {
            const currentStyle = element.style.cssText;
            const propertyMap = /* @__PURE__ */ new Map();
            if (currentStyle) {
              const declarations = currentStyle.split(";");
              for (const declaration of declarations) {
                const colonIndex = declaration.indexOf(":");
                if (colonIndex > 0) {
                  const property = declaration.slice(0, colonIndex).trim();
                  const value = declaration.slice(colonIndex + 1).trim();
                  if (property && value) {
                    propertyMap.set(property, value);
                  }
                }
              }
            }
            for (const update of updates) {
              propertyMap.set(update.property, update.value);
            }
            const cssDeclarations = [];
            for (const [property, value] of propertyMap) {
              cssDeclarations.push(`${property}:${value}`);
            }
            element.style.cssText = cssDeclarations.join(";");
          } catch (error) {
            for (const update of updates) {
              try {
                element.style.setProperty(update.property, update.value);
              } catch (e) {
                console.warn(`Failed to apply ${update.property}:`, e);
              }
            }
          }
        }
        /**
         * Fallback update application with error recovery
         */
        applyUpdatesWithFallback(updates) {
          for (const update of updates) {
            try {
              if (_UnifiedCSSVariableManager.nativeSetProperty) {
                _UnifiedCSSVariableManager.nativeSetProperty.call(
                  update.element.style,
                  update.property,
                  update.value
                );
              } else {
                update.element.style.setProperty(update.property, update.value);
              }
            } catch (e) {
              console.warn(
                `[UnifiedCSSVariableManager] Failed to apply CSS property ${update.property}:`,
                e
              );
            }
          }
        }
        // ===================================================================
        // CONVENIENCE METHODS FOR COMMON CSS UPDATES
        // ===================================================================
        /**
         * Set music synchronization variables
         */
        setMusicMetrics(metrics) {
          const variables = {};
          if (metrics.beatIntensity !== void 0) {
            variables["--sn.music.beat.pulse.intensity"] = metrics.beatIntensity.toString();
          }
          if (metrics.rhythmPhase !== void 0) {
            variables["--sn.music.rhythm.phase"] = `${metrics.rhythmPhase}deg`;
          }
          if (metrics.animationScale !== void 0) {
            variables["--sn.music.animation.scale"] = metrics.animationScale.toString();
          }
          if (metrics.spectrumPhase !== void 0) {
            variables["--sn.music.spectrum.phase"] = `${metrics.spectrumPhase}deg`;
          }
          if (metrics.energy !== void 0) {
            variables["--sn.music.energy.level"] = metrics.energy.toString();
          }
          if (metrics.valence !== void 0) {
            variables["--sn.music.valence"] = metrics.valence.toString();
          }
          if (metrics.bpm !== void 0) {
            variables["--sn.music.tempo.bpm"] = metrics.bpm.toString();
          }
          this.updateVariables(variables, "critical", "music-system");
        }
        /**
         * Set color variables
         */
        setColorTokens(colors) {
          const variables = {};
          if (colors.accentHex) {
            variables["--sn.color.accent.hex"] = colors.accentHex;
          }
          if (colors.accentRgb) {
            variables["--sn.color.accent.rgb"] = colors.accentRgb;
          }
          if (colors.primaryRgb) {
            variables["--sn.bg.gradient.primary.rgb"] = colors.primaryRgb;
          }
          if (colors.secondaryRgb) {
            variables["--sn.bg.gradient.secondary.rgb"] = colors.secondaryRgb;
          }
          if (colors.gradientOpacity !== void 0) {
            variables["--sn.bg.gradient.opacity"] = colors.gradientOpacity.toString();
          }
          if (colors.gradientBlur) {
            variables["--sn.bg.gradient.blur"] = colors.gradientBlur;
          }
          this.updateVariables(variables, "high", "color-system");
        }
        /**
         * Set performance variables
         */
        setPerformanceTokens(perf) {
          const variables = {};
          if (perf.webglReady !== void 0) {
            variables["--sn.bg.webgl.ready"] = perf.webglReady ? "1" : "0";
          }
          if (perf.activeBackend) {
            variables["--sn.bg.active-backend"] = perf.activeBackend;
          }
          if (perf.qualityLevel) {
            variables["--sn.perf.quality.level"] = perf.qualityLevel;
          }
          if (perf.reducedMotion !== void 0) {
            variables["--sn.anim.motion.reduced"] = perf.reducedMotion ? "1" : "0";
          }
          if (perf.gpuAcceleration !== void 0) {
            variables["--sn.perf.gpu.acceleration.enabled"] = perf.gpuAcceleration ? "1" : "0";
          }
          this.updateVariables(variables, "high", "performance-system");
        }
        /**
         * Direct property setter (convenience API)
         */
        setProperty(property, value, element = null) {
          if (property.startsWith("--spice-") && this.config.enableSpiceVariableDebug) {
            const caller = new Error().stack?.split("\n")[2]?.trim().replace(/^\s*at\s+/, "") || "unknown";
            console.log(
              `\u{1F527} [CSS Debug] Setting ${property} = ${value} (from: ${caller})`
            );
          }
          this.queueCSSVariableUpdate(property, value, element);
        }
        // ===================================================================
        // PERFORMANCE AND DEVICE OPTIMIZATION METHODS
        // ===================================================================
        /**
         * Apply device-specific CSS classes
         */
        applyDeviceOptimizations() {
          if (!this.cssConfig.enableDeviceTierOptimization || !this.currentDeviceCapabilities)
            return;
          this.removeClassesByPrefix("device-tier-");
          this.removeClassesByPrefix("device-mobile-");
          this.removeClassesByPrefix("device-gpu-");
          const tierClass = `device-tier-${this.currentDeviceCapabilities.performanceTier}`;
          this.addCSSClass(tierClass);
          if (this.currentDeviceCapabilities.isMobile) {
            this.addCSSClass("device-mobile-optimized");
          }
          if (this.currentDeviceCapabilities.gpuAcceleration) {
            this.addCSSClass("device-gpu-accelerated");
          } else {
            this.addCSSClass("device-gpu-fallback");
          }
          const memoryTier = this.getMemoryTier(
            this.currentDeviceCapabilities.memoryGB
          );
          this.addCSSClass(`device-memory-${memoryTier}`);
        }
        /**
         * Apply performance mode CSS classes
         */
        applyPerformanceModeOptimizations() {
          if (!this.currentPerformanceMode) return;
          this.removeClassesByPrefix("performance-mode-");
          const modeClass = `performance-mode-${this.currentPerformanceMode.name}`;
          this.addCSSClass(modeClass);
          const optimizationClass = `optimization-level-${this.currentPerformanceMode.optimizationLevel}`;
          this.addCSSClass(optimizationClass);
        }
        /**
         * Get performance report
         */
        getPerformanceReport() {
          const averageBatchTime = this.performanceMetrics.totalBatches > 0 ? this.performanceMetrics.totalBatchTime / this.performanceMetrics.totalBatches : 0;
          return {
            enabled: true,
            pendingUpdates: this.cssVariableQueue.size + this.updateQueue.size,
            totalUpdates: this.performanceMetrics.totalUpdates,
            totalBatches: this.performanceMetrics.totalBatches,
            averageBatchSize: Math.round(this.performanceMetrics.averageBatchSize * 10) / 10,
            averageBatchTime: Math.round(averageBatchTime * 100) / 100,
            maxBatchTime: Math.round(this.performanceMetrics.maxBatchTime * 100) / 100,
            overBudgetBatches: this.performanceMetrics.overBudgetBatches,
            conflictResolutions: this.performanceMetrics.conflictResolutions,
            transactionCount: this.performanceMetrics.transactionCount,
            visualEffectsUpdates: this.performanceMetrics.visualEffectsUpdates,
            visualEffectsActive: this.visualEffectsState !== null,
            deviceTier: this.currentDeviceCapabilities?.performanceTier,
            performanceMode: this.currentPerformanceMode?.name
          };
        }
        // ===================================================================
        // PRIVATE METHODS
        // ===================================================================
        subscribeToEvents() {
          this.eventBus.subscribe("performance:tier-changed", (payload) => {
            this.currentPerformanceMode = this.performanceCoordinator.getCurrentPerformanceMode();
            this.applyPerformanceModeOptimizations();
            this.updateCSSPerformanceVariables();
          }, "UnifiedCSSVariableManager");
          this.eventBus.subscribe("performance:frame", (payload) => {
            if (payload.temperature && payload.temperature > 80) {
              this.applyThermalOptimizations(payload.temperature);
            }
          }, "UnifiedCSSVariableManager");
        }
        applyInitialOptimizations() {
          try {
            this.applyDeviceOptimizations();
            this.applyPerformanceModeOptimizations();
            this.updateCSSPerformanceVariables();
            if (this.cssConfig.debugPerformanceClasses) {
              this.addCSSClass("debug-performance");
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[UnifiedCSSVariableManager] Error applying initial optimizations:",
                error
              );
            }
          }
        }
        applyCurrentOptimizations() {
          this.applyDeviceOptimizations();
          this.applyPerformanceModeOptimizations();
          const batteryState = this.performanceCoordinator.getBatteryState();
          const thermalState = this.performanceCoordinator.getThermalState();
          if (batteryState) {
            this.applyBatteryOptimizations(batteryState.level, batteryState.charging);
          }
          const thermalTemp = thermalState.temperature || "normal";
          this.applyThermalOptimizations(thermalTemp);
        }
        updateCSSPerformanceVariables() {
          const now = Date.now();
          if (now - this.lastCSSUpdate < this.cssUpdateThrottle) return;
          this.lastCSSUpdate = now;
          if (!this.currentPerformanceMode || !this.currentDeviceCapabilities) return;
          try {
            const variables = {
              "--sn.performance.mode": this.currentPerformanceMode.name || "balanced",
              "--sn.performance.quality.level": (this.currentPerformanceMode.qualityLevel ?? 0.8).toString(),
              "--sn.performance.fps.target": (this.currentPerformanceMode.frameRate ?? 60).toString(),
              "--sn.performance.frame.budget": (1e3 / (this.currentPerformanceMode.frameRate ?? 60)).toString(),
              "--sn.performance.optimization.level": (this.currentPerformanceMode.optimizationLevel ?? 1).toString(),
              "--sn.device.tier": this.currentDeviceCapabilities.performanceTier ?? "mid",
              "--sn.device.memory": (this.currentDeviceCapabilities.memoryGB ?? 8).toString(),
              "--sn.device.gpu": this.currentDeviceCapabilities.gpuAcceleration ?? true ? "1" : "0",
              "--sn.device.mobile": this.currentDeviceCapabilities.isMobile ?? false ? "1" : "0",
              "--sn.performance.blur.quality": (this.currentPerformanceMode.blurQuality ?? 0.8).toString(),
              "--sn.performance.shadow.quality": (this.currentPerformanceMode.shadowQuality ?? 0.8).toString(),
              "--sn.performance.animation.quality": (this.currentPerformanceMode.animationQuality ?? 0.8).toString(),
              "--sn.performance.effect.quality": (this.currentPerformanceMode.effectQuality ?? 0.8).toString()
            };
            this.updateVariables(variables, "high", "performance-coordinator");
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[UnifiedCSSVariableManager] Error updating CSS performance variables:",
                error
              );
            }
          }
        }
        startVisualEffectsIntegration() {
          if (this.visualEffectsUpdateTimer) return;
          const updateVisualEffects = /* @__PURE__ */ __name(() => {
            const now = performance.now();
            if (now - this.lastVisualEffectsUpdate >= this.cssConfig.visualEffectsUpdateInterval) {
              this.lastVisualEffectsUpdate = now;
              if (this.visualEffectsState) {
                this.updateVisualEffectsVariables(this.visualEffectsState);
              }
            }
            this.visualEffectsUpdateTimer = setTimeout(
              updateVisualEffects,
              this.cssConfig.visualEffectsUpdateInterval
            );
          }, "updateVisualEffects");
          updateVisualEffects();
        }
        shouldReplaceUpdate(existing, incoming) {
          const existingWeight = this.PRIORITY_WEIGHTS[existing.priority];
          const incomingWeight = this.PRIORITY_WEIGHTS[incoming.priority];
          if (incomingWeight > existingWeight) {
            return true;
          }
          if (incomingWeight === existingWeight) {
            return incoming.timestamp > existing.timestamp;
          }
          return false;
        }
        scheduleFlush(priority) {
          if (this.rafHandle !== null || this.microtaskScheduled) {
            return;
          }
          const flushCallback = /* @__PURE__ */ __name(() => {
            this.rafHandle = null;
            this.microtaskScheduled = false;
            this.flushCSSVariableBatch();
          }, "flushCallback");
          if (typeof document !== "undefined" && document.visibilityState === "hidden") {
            this.microtaskScheduled = true;
            queueMicrotask(flushCallback);
          } else if (typeof requestAnimationFrame === "function") {
            this.rafHandle = requestAnimationFrame(flushCallback);
          } else {
            setTimeout(flushCallback, 0);
          }
        }
        updatePerformanceMetrics(batchTime, batchSize) {
          this.performanceMetrics.totalBatches++;
          this.performanceMetrics.totalBatchTime += batchTime;
          this.performanceMetrics.maxBatchTime = Math.max(
            this.performanceMetrics.maxBatchTime,
            batchTime
          );
          this.performanceMetrics.averageBatchSize = (this.performanceMetrics.averageBatchSize * (this.performanceMetrics.totalBatches - 1) + batchSize) / this.performanceMetrics.totalBatches;
          if (batchTime > 8) {
            this.performanceMetrics.overBudgetBatches++;
            if (this.config.enableDebug) {
              console.warn(
                `[UnifiedCSSVariableManager] CSS batch took ${batchTime.toFixed(
                  2
                )}ms for ${batchSize} updates`
              );
            }
          }
        }
        enableGlobalHijack() {
          if (_UnifiedCSSVariableManager.hijackEnabled) return;
          const original = CSSStyleDeclaration.prototype.setProperty;
          _UnifiedCSSVariableManager.nativeSetProperty = original;
          const controllerInstance = this;
          CSSStyleDeclaration.prototype.setProperty = function(prop, value, priority) {
            if (prop && (prop.startsWith("--sn-") || prop.startsWith("--sn.")) && controllerInstance) {
              controllerInstance.queueCSSVariableUpdate(prop, String(value ?? ""));
            } else {
              original.call(this, prop, value, priority);
            }
          };
          _UnifiedCSSVariableManager.hijackEnabled = true;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSVariableManager] Global setProperty hijack enabled (--sn- and --sn. namespaces)"
            );
          }
        }
        addCSSClass(className) {
          if (!this.appliedClasses.has(className)) {
            document.body.classList.add(className);
            this.appliedClasses.add(className);
          }
        }
        removeCSSClass(className) {
          if (this.appliedClasses.has(className)) {
            document.body.classList.remove(className);
            this.appliedClasses.delete(className);
          }
        }
        removeClassesByPrefix(prefix) {
          const classesToRemove = Array.from(this.appliedClasses).filter(
            (className) => className.startsWith(prefix)
          );
          for (const className of classesToRemove) {
            this.removeCSSClass(className);
          }
        }
        getMemoryTier(memoryGB) {
          if (memoryGB >= 16) return "high";
          if (memoryGB >= 8) return "medium";
          if (memoryGB >= 4) return "low";
          return "minimal";
        }
        applyThermalOptimizations(thermalState) {
          if (!this.cssConfig.enableThermalThrottling) return;
          this.removeClassesByPrefix("thermal-");
          const thermalClass = `thermal-${thermalState}`;
          this.addCSSClass(thermalClass);
        }
        applyBatteryOptimizations(batteryLevel, charging) {
          if (!this.cssConfig.enableBatteryOptimization) return;
          this.removeClassesByPrefix("battery-");
          if (batteryLevel < 0.2) {
            this.addCSSClass("battery-low");
          } else if (batteryLevel < 0.5) {
            this.addCSSClass("battery-medium");
          } else {
            this.addCSSClass("battery-high");
          }
          if (charging) {
            this.addCSSClass("battery-charging");
          }
        }
        // ===================================================================
        // CONVENIENCE METHODS FROM UNIFIEDCSSVARIABLEMANAGER
        // ===================================================================
        /**
         * Update music system variables (from UnifiedCSSVariableManager)
         */
        updateMusicVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-music-${key.replace(/\./g, "-")}`;
              updates[fullKey] = String(value);
            }
          }
          this.updateVariables(updates, "critical", "music-system");
        }
        /**
         * Update color system variables (from UnifiedCSSVariableManager)
         */
        updateColorVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-color-${key.replace(/\./g, "-")}`;
              updates[fullKey] = String(value);
            }
          }
          this.updateVariables(updates, "high", "color-system");
        }
        /**
         * Update animation system variables (from UnifiedCSSVariableManager)
         */
        updateAnimationVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-anim-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.updateVariables(updates, "normal", "animation-system");
        }
        /**
         * Update performance system variables (from UnifiedCSSVariableManager)
         */
        updatePerformanceVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-performance-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.updateVariables(updates, "high", "performance-system");
        }
        /**
         * Update utility system variables (from UnifiedCSSVariableManager)
         */
        updateUtilityVariables(variables) {
          const updates = {};
          for (const [key, value] of Object.entries(variables)) {
            if (value !== void 0) {
              const fullKey = `--sn-${key.replace(/\./g, "-")}`;
              updates[fullKey] = typeof value === "boolean" ? value ? "1" : "0" : String(value);
            }
          }
          this.updateVariables(updates, "low", "utility-system");
        }
        /**
         * Queue a CSS variable update (from UnifiedCSSVariableManager compatibility)
         */
        queueUpdate(property, value, priority = "normal", source = "unknown") {
          this.queueCSSVariableUpdate(property, value, null, priority, source);
        }
        /**
         * Queue multiple CSS variable updates in a transaction (from UnifiedCSSVariableManager)
         */
        queueTransaction(variables, priority = "normal", source = "unknown") {
          const transactionId = `tx_${++this.transactionCounter}`;
          const variableMap = new Map(Object.entries(variables));
          const transaction = {
            id: transactionId,
            variables: variableMap,
            timestamp: performance.now(),
            priority,
            completed: false
          };
          this.pendingTransactions.set(transactionId, transaction);
          for (const [property, value] of variableMap) {
            this.queueUpdate(property, value, priority, `${source}:${transactionId}`);
          }
          this.performanceMetrics.transactionCount++;
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Transaction ${transactionId} queued with ${variableMap.size} variables`
            );
          }
          return transactionId;
        }
        /**
         * Force immediate flush (from UnifiedCSSVariableManager)
         */
        forceFlush() {
          this.flushCSSVariableBatch();
        }
        /**
         * Register a variable group (from UnifiedCSSVariableManager compatibility)
         */
        registerVariableGroup(name, priority = "normal", batchSize = 50, flushInterval = 16) {
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Variable group registration: ${name} (handled internally)`
            );
          }
        }
        /**
         * Update variables in a specific group (from UnifiedCSSVariableManager compatibility)
         */
        updateVariableGroup(groupName, variables, source = "unknown") {
          this.updateVariables(variables, "normal", `group:${groupName}:${source}`);
        }
        /**
         * Update configuration (from CSSVariableBatcher compatibility)
         */
        updateConfig(newConfig) {
          this.cssConfig = { ...this.cssConfig, ...newConfig };
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [UnifiedCSSVariableManager] Configuration updated:",
              newConfig
            );
          }
        }
        // ===================================================================
        // LEGACY COMPATIBILITY METHODS
        // ===================================================================
        // For backwards compatibility with UnifiedCSSVariableManager API
        flushNow() {
          this.flushCSSVariableBatch();
        }
        setBatchingEnabled(enabled) {
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Batching ${enabled ? "enabled" : "disabled"}`
            );
          }
        }
        addCriticalVariable(variable) {
          CRITICAL_NOW_PLAYING_VARS.add(variable);
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Added critical variable: ${variable}`
            );
          }
        }
        removeCriticalVariable(variable) {
          CRITICAL_NOW_PLAYING_VARS.delete(variable);
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Removed critical variable: ${variable}`
            );
          }
        }
        isCriticalVariable(variable) {
          return CRITICAL_NOW_PLAYING_VARS.has(variable);
        }
        getCriticalVariables() {
          return Array.from(CRITICAL_NOW_PLAYING_VARS);
        }
        // ===================================================================
        // SIMPLIFIED COORDINATION PATTERNS (Extracted from SharedVariableCoordination.ts)
        // ===================================================================
        /**
         * Update visual-effects intensity with simplified coordination through UnifiedEventBus
         * Replaces the complex ConsciousnessIntensityCoordinator pattern with a simple subscription-based approach
         */
        updateVisualEffectsIntensity(intensity, sourceStrategy, musicEnergy) {
          const clampedIntensity = Math.max(0, Math.min(1, intensity));
          this.queueCSSVariableUpdate(
            "--visual-effects-intensity",
            clampedIntensity.toString(),
            null,
            "high",
            `visual-effects-${sourceStrategy}`
          );
          if (this.eventBus) {
            this.eventBus.emitSync("visual-effects:intensity-changed", {
              intensity: clampedIntensity,
              userEngagement: 0.5,
              // Default engagement level
              timestamp: Date.now(),
              sourceStrategy,
              musicEnergy: musicEnergy ?? 0
            });
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Consciousness intensity updated by ${sourceStrategy}: ${clampedIntensity}`
            );
          }
        }
        /**
         * Update crossfade opacity with simplified coordination through UnifiedEventBus
         * Replaces the complex CrossfadeOpacityCoordinator pattern with a simple subscription-based approach
         */
        updateCrossfadeOpacity(opacity, sourceStrategy, webglEnabled) {
          let finalOpacity = Math.max(0, Math.min(1, opacity));
          if (!webglEnabled) {
            finalOpacity = 0;
          }
          this.queueCSSVariableUpdate(
            "--sn-gradient-crossfade-opacity",
            finalOpacity.toString(),
            null,
            "high",
            `crossfade-${sourceStrategy}`
          );
          if (this.eventBus) {
            this.eventBus.emitSync("gradient:crossfade-changed", {
              opacity: finalOpacity,
              sourceStrategy,
              webglEnabled,
              timestamp: Date.now()
            });
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [UnifiedCSSVariableManager] Crossfade opacity updated by ${sourceStrategy}: ${finalOpacity} (WebGL: ${webglEnabled})`
            );
          }
        }
        /**
         * Subscribe to visual-effects intensity changes from other strategies
         */
        subscribeToVisualEffectsChanges(callback) {
          if (!this.eventBus) {
            console.warn(
              "[UnifiedCSSVariableManager] No UnifiedEventBus available for visual-effects subscriptions"
            );
            return () => {
            };
          }
          const subscriptionId = this.eventBus.subscribe(
            "visual-effects:intensity-changed",
            callback,
            "UnifiedCSSVariableManager"
          );
          return () => this.eventBus?.unsubscribe(subscriptionId);
        }
        /**
         * Subscribe to crossfade opacity changes from other strategies
         */
        subscribeToCrossfadeChanges(callback) {
          if (!this.eventBus) {
            console.warn(
              "[UnifiedCSSVariableManager] No UnifiedEventBus available for crossfade subscriptions"
            );
            return () => {
            };
          }
          const subscriptionId = this.eventBus.subscribe(
            "gradient:crossfade-changed",
            callback,
            "UnifiedCSSVariableManager"
          );
          return () => this.eventBus?.unsubscribe(subscriptionId);
        }
        // ===============================================================================
        // LEGACY API METHODS (for backward compatibility with OptimizedCSSVariableManager)
        // ===============================================================================
        /**
         * Set single variable (legacy API compatibility)
         * Supports both old interface: (source, property, value, priority, description)
         * and new interface: (name, value, priority)
         */
        setVariable(sourceOrName, propertyOrValue, valueOrPriority, priority, description) {
          let finalProperty;
          let finalValue;
          let finalPriority;
          let finalSource;
          if (arguments.length >= 4) {
            finalProperty = propertyOrValue;
            finalValue = valueOrPriority;
            finalPriority = priority || "normal";
            finalSource = `${sourceOrName}${description ? `:${description}` : ""}`;
          } else {
            finalProperty = sourceOrName;
            finalValue = propertyOrValue;
            finalPriority = valueOrPriority || "normal";
            finalSource = "legacy-api";
          }
          const normalizedPriority = finalPriority || "normal";
          this.queueCSSVariableUpdate(finalProperty, finalValue, null, normalizedPriority, finalSource);
        }
        /**
         * Batch set variables (legacy API compatibility)
         * Supports both old interface: (source, variables, priority, description)
         * and new interface: (variables, priority)
         */
        batchSetVariables(sourceOrVariables, variablesOrPriority, priority, description) {
          let finalVariables;
          let finalPriority;
          let finalSource;
          if (typeof sourceOrVariables === "string") {
            finalVariables = variablesOrPriority;
            finalPriority = priority || "normal";
            finalSource = `${sourceOrVariables}${description ? `:${description}` : ""}`;
          } else {
            finalVariables = sourceOrVariables;
            finalPriority = variablesOrPriority || "normal";
            finalSource = "legacy-batch-api";
          }
          const normalizedPriority = finalPriority || "normal";
          this.updateVariables(finalVariables, normalizedPriority, finalSource);
        }
        // ========================================================================
        // PRIVATE IMPLEMENTATION - CONSOLIDATED OPTIMIZATION FEATURES
        // ========================================================================
        /**
         * Initialize optimized features (from OptimizedCSSVariableManager consolidation)
         */
        initializeOptimizedFeatures() {
          if (this.currentDeviceCapabilities?.performanceTier === "low") {
          }
          if (this.config.enableDebug) {
            console.log("[UnifiedCSSVariableManager] Optimized features initialized");
          }
        }
        /**
         * Initialize frame context integration (replaces CDFVariableBridge)
         */
        initializeFrameContextIntegration() {
          if (this.config.enableDebug) {
            console.log("[UnifiedCSSVariableManager] Frame context integration initialized");
          }
        }
        /**
         * Determine variable priority based on property and context
         */
        determineVariablePriority(property, requestedPriority) {
          if (property.includes("sn-critical") || property.includes("spice-main")) {
            return "critical";
          }
          if (property.includes("music") || property.includes("beat") || property.includes("energy")) {
            return "high";
          }
          if (property.includes("color") || property.includes("accent")) {
            return "normal";
          }
          return requestedPriority || "low";
        }
        /**
         * Apply critical updates immediately bypassing queue
         */
        applyCriticalUpdate(property, value, targetElement) {
          const element = targetElement || document.documentElement;
          try {
            element.style.setProperty(property, value);
            if (this.config.enableDebug) {
              console.log(`[UnifiedCSSVariableManager] Critical update applied: ${property} = ${value}`);
            }
          } catch (error) {
            console.warn("[UnifiedCSSVariableManager] Critical update failed:", error);
          }
        }
        /**
         * Queue update by priority level
         */
        queueByPriority(property, value, targetElement, priority, source) {
          if (!this.priorityQueues.has(priority)) {
            this.priorityQueues.set(priority, /* @__PURE__ */ new Map());
          }
          const queue = this.priorityQueues.get(priority);
          queue.set(property, { property, value, timestamp: Date.now() });
          if (priority === "critical" || priority === "high") {
            this.flushCSSVariableBatch();
          }
        }
        /**
         * Destroy frame context integration
         */
        destroyFrameContextIntegration() {
          if (this.config.enableDebug) {
            console.log("[UnifiedCSSVariableManager] Frame context integration destroyed");
          }
        }
        /**
         * Cleanup and destroy the manager
         */
        destroy() {
          if (this.adaptiveMonitoringInterval) {
            clearInterval(this.adaptiveMonitoringInterval);
            this.adaptiveMonitoringInterval = null;
          }
          this.destroyFrameContextIntegration();
          this.priorityQueues.clear();
          if (this.visualEffectsUpdateTimer) {
            clearTimeout(this.visualEffectsUpdateTimer);
            this.visualEffectsUpdateTimer = null;
          }
          this.cssVariableQueue.clear();
          unifiedEventBus.unsubscribeAll("UnifiedCSSVariableManager");
          this.initialized = false;
        }
      };
      __name(_UnifiedCSSVariableManager, "UnifiedCSSVariableManager");
      _UnifiedCSSVariableManager.hijackEnabled = false;
      UnifiedCSSVariableManager = _UnifiedCSSVariableManager;
    }
  });

  // src-js/core/performance/OptimizedCSSVariableManager.ts
  function setGlobalOptimizedCSSController(instance2) {
    globalOptimizedCSSController = instance2;
    console.log("\u{1F504} [OptimizedCSSVariableManager] Global compatibility layer instance set");
  }
  function getGlobalOptimizedCSSController() {
    if (!globalOptimizedCSSController) {
      console.warn("[OptimizedCSSVariableManager] Global instance not initialized yet. This may indicate an initialization order issue.");
      throw new Error("Global OptimizedCSSVariableManager not initialized. Call setGlobalOptimizedCSSController() first.");
    }
    return globalOptimizedCSSController;
  }
  var _OptimizedCSSVariableManager, OptimizedCSSVariableManager, globalOptimizedCSSController;
  var init_OptimizedCSSVariableManager = __esm({
    "src-js/core/performance/OptimizedCSSVariableManager.ts"() {
      "use strict";
      init_UnifiedCSSVariableManager();
      _OptimizedCSSVariableManager = class _OptimizedCSSVariableManager extends UnifiedCSSVariableManager {
        constructor(year3000Config, performanceCoordinator, optimizedConfig = {}) {
          const enhancedConfig = {
            enableAdaptiveThrottling: optimizedConfig.enableAdaptiveThrottling ?? true,
            priorityMappings: optimizedConfig.priorityMappings ?? {
              critical: ["--sn-rs-glow-alpha", "--sn-rs-beat-intensity", "--sn-rs-hue-shift"],
              high: ["--sn-gradient-primary", "--sn-gradient-secondary", "--sn-gradient-accent"],
              normal: ["--sn-gradient-", "--sn-rs-"],
              low: ["--sn-debug-", "--sn-dev-"]
            },
            thresholds: optimizedConfig.thresholds ?? {
              excellentFPS: 55,
              goodFPS: 45,
              poorFPS: 30
            }
          };
          super(year3000Config, performanceCoordinator);
          this.legacyConfig = {
            batchIntervalMs: optimizedConfig.batchIntervalMs ?? 16,
            maxBatchSize: optimizedConfig.maxBatchSize ?? 50,
            enableDebug: year3000Config.enableDebug,
            enableAdaptiveThrottling: enhancedConfig.enableAdaptiveThrottling,
            priorityMappings: enhancedConfig.priorityMappings,
            thresholds: enhancedConfig.thresholds,
            ...optimizedConfig
          };
          if (year3000Config.enableDebug) {
            console.log("\u{1F504} [OptimizedCSSVariableManager] Compatibility layer active - delegating to UnifiedCSSVariableManager");
          }
        }
        /**
         * Legacy method compatibility - getMedianFPS
         */
        getMedianFPS() {
          if (this.performanceCoordinator) {
            const mode = this.performanceCoordinator.getCurrentPerformanceMode();
            return mode?.frameRate || 60;
          }
          return 60;
        }
        /**
         * Legacy method compatibility - updateConfig
         */
        updateConfig(updates) {
          Object.assign(this.legacyConfig, updates);
          if (updates.batchIntervalMs || updates.maxBatchSize) {
          }
        }
        /**
         * Set single variable (legacy API compatibility)
         * Supports both old interface: (source, property, value, priority, description)
         * and new interface: (name, value, priority)
         */
        setVariable(sourceOrName, propertyOrValue, valueOrPriority, priority, description) {
          super.setVariable(sourceOrName, propertyOrValue, valueOrPriority, priority, description);
        }
        /**
         * Batch set variables (legacy API compatibility)
         * Supports both old interface: (source, variables, priority, description)
         * and new interface: (variables, priority)
         */
        batchSetVariables(sourceOrVariables, variablesOrPriority, priority, description) {
          super.batchSetVariables(sourceOrVariables, variablesOrPriority, priority, description);
        }
        /**
         * Static factory method for backward compatibility
         */
        static getGlobalInstance() {
          const globalManager = getGlobalOptimizedCSSController();
          if (globalManager instanceof _OptimizedCSSVariableManager) {
            return globalManager;
          }
          throw new Error("Global OptimizedCSSVariableManager not properly initialized");
        }
      };
      __name(_OptimizedCSSVariableManager, "OptimizedCSSVariableManager");
      OptimizedCSSVariableManager = _OptimizedCSSVariableManager;
      globalOptimizedCSSController = null;
      __name(setGlobalOptimizedCSSController, "setGlobalOptimizedCSSController");
      __name(getGlobalOptimizedCSSController, "getGlobalOptimizedCSSController");
      if (typeof process !== "undefined" && true) {
        console.warn(
          "\u26A0\uFE0F  [OptimizedCSSVariableManager] This class is deprecated. Use UnifiedCSSVariableManager with enhanced optimization features instead. This compatibility layer will be removed in a future version."
        );
      }
    }
  });

  // src-js/utils/spicetify/SemanticColorManager.ts
  function safeGetSpicetify() {
    return typeof window !== "undefined" && window.Spicetify ? window.Spicetify : null;
  }
  function isSpicetifyPlatformAvailable() {
    const spicetify = safeGetSpicetify();
    return !!spicetify?.Platform;
  }
  var _SemanticColorManager, SemanticColorManager;
  var init_SemanticColorManager = __esm({
    "src-js/utils/spicetify/SemanticColorManager.ts"() {
      "use strict";
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_ThemeUtilities();
      __name(safeGetSpicetify, "safeGetSpicetify");
      __name(isSpicetifyPlatformAvailable, "isSpicetifyPlatformAvailable");
      _SemanticColorManager = class _SemanticColorManager {
        constructor(config = {}) {
          this.colorCache = /* @__PURE__ */ new Map();
          this.lastCacheUpdate = 0;
          // IManagedSystem interface
          this.initialized = false;
          // Event tracking for proper system integration
          this.eventSubscriptionIds = [];
          this.lastColorUpdate = 0;
          this.colorUpdateCount = 0;
          this.config = {
            enableDebug: false,
            fallbackToSpiceColors: true,
            cacheDuration: 5e3,
            // 5 seconds
            ...config
          };
        }
        async initialize(cssController) {
          if (this.initialized) {
            console.warn("[SemanticColorManager] Already initialized, skipping");
            return;
          }
          try {
            this.cssController = cssController || getGlobalOptimizedCSSController();
            this.setupEventSubscriptions();
            this.initialized = true;
            this.lastColorUpdate = Date.now();
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] Initialized as IManagedSystem with", {
                mappings: _SemanticColorManager.SEMANTIC_MAPPINGS.length,
                batcherAvailable: !!this.cssController,
                spicetifyAvailable: this.isSpicetifyAvailable(),
                eventSubscriptions: this.eventSubscriptionIds.length
              });
            }
            unifiedEventBus.emitSync("system:initialized", {
              systemName: "SemanticColorManager",
              timestamp: Date.now(),
              metadata: {
                mappings: _SemanticColorManager.SEMANTIC_MAPPINGS.length,
                spicetifyAvailable: this.isSpicetifyAvailable() ? 1 : 0
              }
            });
          } catch (error) {
            console.error("[SemanticColorManager] Initialization failed:", error);
            unifiedEventBus.emitSync("system:error", {
              systemName: "SemanticColorManager",
              error: error instanceof Error ? error.message : "Initialization failed",
              severity: "critical",
              timestamp: Date.now()
            });
            throw error;
          }
        }
        async updateSemanticColors() {
          if (!this.initialized) {
            console.warn("[SemanticColorManager] Not initialized, cannot update colors");
            return;
          }
          const now = Date.now();
          if (now - this.lastCacheUpdate < (this.config.cacheDuration || 5e3)) {
            return;
          }
          console.log("\u{1F3A8} [SemanticColorManager] Starting semantic color update...");
          try {
            const colorUpdateLog = {};
            const semanticColorUpdates = {};
            const rgbColorUpdates = {};
            for (const mapping of _SemanticColorManager.SEMANTIC_MAPPINGS) {
              const color3 = await this.getSemanticColor(mapping.semanticColor);
              colorUpdateLog[mapping.cssVariable] = {
                semanticColor: mapping.semanticColor,
                retrievedColor: color3,
                fallbackColor: mapping.fallbackColor,
                description: mapping.description
              };
              semanticColorUpdates[mapping.cssVariable] = color3;
              const rgbColor = hexToRgb(color3);
              if (rgbColor) {
                const rgbVariable = mapping.cssVariable.replace("--spice-", "--spice-rgb-");
                rgbColorUpdates[rgbVariable] = `${rgbColor.r},${rgbColor.g},${rgbColor.b}`;
                colorUpdateLog[rgbVariable] = `${rgbColor.r},${rgbColor.g},${rgbColor.b}`;
              }
            }
            this.cssController.batchSetVariables(
              "SemanticColorManager",
              semanticColorUpdates,
              "high",
              // High priority for semantic color system
              "semantic-color-update"
            );
            this.cssController.batchSetVariables(
              "SemanticColorManager",
              rgbColorUpdates,
              "high",
              // High priority for RGB color variants
              "semantic-rgb-update"
            );
            console.log("\u{1F3A8} [SemanticColorManager] Color update complete:", colorUpdateLog);
            this.lastCacheUpdate = now;
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] Updated all semantic colors");
            }
          } catch (error) {
            console.error("[SemanticColorManager] Failed to update semantic colors:", error);
          }
        }
        async getSemanticColor(semanticColor) {
          const cached = this.colorCache.get(semanticColor);
          if (cached && Date.now() - this.lastCacheUpdate < (this.config.cacheDuration || 5e3)) {
            return cached;
          }
          let color3;
          try {
            const spicetify = safeGetSpicetify();
            if (this.isSpicetifyAvailable() && spicetify?.Platform?.getSemanticColors) {
              const semanticColors = await spicetify.Platform.getSemanticColors();
              color3 = semanticColors[semanticColor];
              console.log(`\u{1F3A8} [SemanticColorManager] Spicetify returned for ${semanticColor}:`, {
                rawValue: color3,
                type: typeof color3,
                isWhite: color3 === "#ffffff" || color3 === "#fff" || color3 === "white",
                isInvalid: !color3 || color3 === "undefined" || color3 === "null"
              });
            } else {
              console.warn(`\u{1F3A8} [SemanticColorManager] Spicetify not available, using fallback for ${semanticColor}`);
              color3 = this.getFallbackColor(semanticColor);
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(`[SemanticColorManager] Failed to get semantic color ${semanticColor}:`, error);
            }
            color3 = this.getFallbackColor(semanticColor);
          }
          color3 = this.validateColor(color3, semanticColor);
          this.colorCache.set(semanticColor, color3);
          return color3;
        }
        /**
         * Validate color to prevent white (#ffffff) or invalid colors from being applied
         */
        validateColor(color3, semanticColor) {
          const normalizedColor = color3?.toLowerCase().trim();
          const invalidColors = [
            "#ffffff",
            "#fff",
            "white",
            "#000000",
            "#000",
            "black",
            "",
            "undefined",
            "null",
            "transparent"
          ];
          if (!normalizedColor || invalidColors.includes(normalizedColor)) {
            const fallbackColor = this.getFallbackColor(semanticColor);
            if (this.config.enableDebug) {
              console.warn(`\u{1F527} [SemanticColorManager] Invalid color "${color3}" for ${semanticColor}, using fallback: ${fallbackColor}`);
            }
            return fallbackColor;
          }
          if (!normalizedColor.match(/^#[0-9a-f]{6}$/i) && !normalizedColor.match(/^#[0-9a-f]{3}$/i)) {
            const fallbackColor = this.getFallbackColor(semanticColor);
            if (this.config.enableDebug) {
              console.warn(`\u{1F527} [SemanticColorManager] Malformed color "${color3}" for ${semanticColor}, using fallback: ${fallbackColor}`);
            }
            return fallbackColor;
          }
          return color3;
        }
        getFallbackColor(semanticColor) {
          const mapping = _SemanticColorManager.SEMANTIC_MAPPINGS.find((m) => m.semanticColor === semanticColor);
          if (mapping) {
            return mapping.fallbackColor;
          }
          if (semanticColor.startsWith("text")) {
            return "#cad3f5";
          } else if (semanticColor.startsWith("background")) {
            return "#24273a";
          } else if (semanticColor.startsWith("essential")) {
            return "#c6a0f6";
          } else if (semanticColor.startsWith("decorative")) {
            return "#939ab7";
          }
          return "#cad3f5";
        }
        applyColorToCSS(cssVariable, color3, priority = "normal", source = "semantic-color-manager") {
          this.cssController.setVariable(
            "SemanticColorManager",
            cssVariable,
            color3,
            priority,
            source
          );
        }
        isSpicetifyAvailable() {
          return isSpicetifyPlatformAvailable();
        }
        flushUpdates() {
          if (this.cssController) {
            this.cssController.flushUpdates();
          }
        }
        clearCache() {
          this.colorCache.clear();
          this.lastCacheUpdate = 0;
        }
        /**
         * Update Spicetify variables directly with OKLAB-processed album colors
         * This bypasses CSS fallback chains and prevents Spotify overrides
         * 
         * Enhanced for comprehensive override protection across all visual systems
         */
        updateWithAlbumColors(oklabColors) {
          if (!this.initialized) {
            console.warn("[SemanticColorManager] Not initialized, cannot update with album colors");
            return;
          }
          try {
            const primaryColor = oklabColors["OKLAB_PRIMARY"] || oklabColors["VIBRANT"] || oklabColors["PRIMARY"];
            const accentColor = oklabColors["OKLAB_ACCENT"] || oklabColors["LIGHT_VIBRANT"] || oklabColors["SECONDARY"];
            const shadowColor = oklabColors["OKLAB_SHADOW"] || oklabColors["DARK_VIBRANT"] || oklabColors["DARK"];
            const highlightColor = oklabColors["OKLAB_HIGHLIGHT"] || oklabColors["VIBRANT_NON_ALARMING"] || oklabColors["LIGHT"];
            if (!primaryColor) {
              console.warn("[SemanticColorManager] No primary color found in OKLAB result, skipping update");
              return;
            }
            const colorDistribution = this.generateIntelligentColorDistribution(
              primaryColor,
              accentColor,
              shadowColor,
              highlightColor
            );
            const rgbDistribution = this.convertColorsToRgb(colorDistribution);
            const coreSpicetifyUpdates = {
              "--spice-accent": colorDistribution.primary,
              "--spice-rgb-accent": rgbDistribution.primary,
              "--spice-surface1": colorDistribution.surface1,
              "--spice-rgb-surface1": rgbDistribution.surface1,
              "--spice-button-active": colorDistribution.primary,
              "--spice-rgb-button-active": rgbDistribution.primary,
              "--spice-highlight": colorDistribution.highlight,
              "--spice-rgb-highlight": rgbDistribution.highlight,
              "--spice-press": colorDistribution.shadow,
              "--spice-rgb-press": rgbDistribution.shadow
            };
            const criticalSpicetifyUpdates = {
              "--spice-surface0": colorDistribution.surface0,
              "--spice-rgb-surface0": rgbDistribution.surface0,
              "--spice-surface2": colorDistribution.surface2,
              "--spice-rgb-surface2": rgbDistribution.surface2,
              "--spice-base": colorDistribution.base,
              "--spice-rgb-base": rgbDistribution.base
            };
            const coreLayoutSpicetifyUpdates = {
              "--spice-main": colorDistribution.base,
              "--spice-rgb-main": rgbDistribution.base,
              "--spice-main-elevated": colorDistribution.surface0,
              "--spice-rgb-main-elevated": rgbDistribution.surface0,
              "--spice-sidebar": colorDistribution.surface1,
              "--spice-rgb-sidebar": rgbDistribution.surface1,
              "--spice-text": this.generateTextColor(colorDistribution.base),
              "--spice-rgb-text": this.hexToRgb(this.generateTextColor(colorDistribution.base)),
              "--spice-subtext": this.generateSubtextColor(colorDistribution.base),
              "--spice-rgb-subtext": this.hexToRgb(this.generateSubtextColor(colorDistribution.base)),
              "--spice-highlight-elevated": colorDistribution.surface2,
              "--spice-rgb-highlight-elevated": rgbDistribution.surface2,
              // Missing Catppuccin overlay system (CRITICAL for background hierarchy)
              "--spice-overlay0": this.generateOverlayColor(colorDistribution.base, 0.04),
              "--spice-rgb-overlay0": this.hexToRgb(this.generateOverlayColor(colorDistribution.base, 0.04)),
              "--spice-overlay1": this.generateOverlayColor(colorDistribution.base, 0.08),
              "--spice-rgb-overlay1": this.hexToRgb(this.generateOverlayColor(colorDistribution.base, 0.08)),
              "--spice-overlay2": this.generateOverlayColor(colorDistribution.base, 0.12),
              "--spice-rgb-overlay2": this.hexToRgb(this.generateOverlayColor(colorDistribution.base, 0.12)),
              "--spice-crust": this.generateCrustColor(colorDistribution.base),
              "--spice-rgb-crust": this.hexToRgb(this.generateCrustColor(colorDistribution.base)),
              "--spice-mantle": this.generateMantleColor(colorDistribution.base),
              "--spice-rgb-mantle": this.hexToRgb(this.generateMantleColor(colorDistribution.base))
            };
            const visualHarmonyColorUpdates = {
              "--spice-blue": colorDistribution.harmonyPrimary,
              "--spice-rgb-blue": rgbDistribution.harmonyPrimary,
              "--spice-mauve": colorDistribution.harmonySecondary,
              "--spice-rgb-mauve": rgbDistribution.harmonySecondary,
              "--spice-teal": colorDistribution.harmonyTertiary,
              "--spice-rgb-teal": rgbDistribution.harmonyTertiary,
              // ZONE SYSTEM: Context-aware color variables for different UI zones
              "--spice-flamingo": this.generateZoneColor(colorDistribution.primary, "flamingo"),
              // Zone home secondary
              "--spice-rgb-flamingo": this.hexToRgb(this.generateZoneColor(colorDistribution.primary, "flamingo")),
              "--spice-lavender": this.generateZoneColor(colorDistribution.highlight, "lavender"),
              // Zone playlist/search primary
              "--spice-rgb-lavender": this.hexToRgb(this.generateZoneColor(colorDistribution.highlight, "lavender")),
              "--spice-peach": this.generateZoneColor(colorDistribution.surface2, "peach"),
              // Zone artist primary
              "--spice-rgb-peach": this.hexToRgb(this.generateZoneColor(colorDistribution.surface2, "peach")),
              "--spice-rosewater": this.generateZoneColor(colorDistribution.surface1, "rosewater"),
              // Zone artist/home secondary
              "--spice-rgb-rosewater": this.hexToRgb(this.generateZoneColor(colorDistribution.surface1, "rosewater")),
              "--spice-sapphire": this.generateZoneColor(colorDistribution.harmonyPrimary, "sapphire"),
              // Zone search secondary
              "--spice-rgb-sapphire": this.hexToRgb(this.generateZoneColor(colorDistribution.harmonyPrimary, "sapphire"))
            };
            const paletteSpicetifyUpdates = {
              "--spice-pink": this.generatePaletteColor(colorDistribution.primary, "pink"),
              "--spice-rgb-pink": this.hexToRgb(this.generatePaletteColor(colorDistribution.primary, "pink")),
              "--spice-sky": this.generatePaletteColor(colorDistribution.harmonyPrimary, "sky"),
              "--spice-rgb-sky": this.hexToRgb(this.generatePaletteColor(colorDistribution.harmonyPrimary, "sky")),
              "--spice-red": this.generatePaletteColor(colorDistribution.highlight, "red"),
              // Used for errors
              "--spice-rgb-red": this.hexToRgb(this.generatePaletteColor(colorDistribution.highlight, "red")),
              "--spice-maroon": this.generatePaletteColor(colorDistribution.shadow, "maroon"),
              "--spice-rgb-maroon": this.hexToRgb(this.generatePaletteColor(colorDistribution.shadow, "maroon")),
              "--spice-yellow": this.generatePaletteColor(colorDistribution.surface2, "yellow"),
              // Used for warnings
              "--spice-rgb-yellow": this.hexToRgb(this.generatePaletteColor(colorDistribution.surface2, "yellow")),
              "--spice-green": this.generatePaletteColor(colorDistribution.harmonyTertiary, "green"),
              // Used for success
              "--spice-rgb-green": this.hexToRgb(this.generatePaletteColor(colorDistribution.harmonyTertiary, "green")),
              "--spice-misc": colorDistribution.surface1,
              // Neutral grey from palette
              "--spice-rgb-misc": rgbDistribution.surface1
            };
            const effectsSpicetifyUpdates = {
              // Shimmer effect colors (harmony color variations for harmonious shimmer)
              "--spice-shimmer-primary": colorDistribution.harmonyPrimary,
              "--spice-rgb-shimmer-primary": rgbDistribution.harmonyPrimary,
              "--spice-shimmer-secondary": colorDistribution.harmonySecondary,
              "--spice-rgb-shimmer-secondary": rgbDistribution.harmonySecondary,
              "--spice-shimmer-tertiary": colorDistribution.harmonyTertiary,
              "--spice-rgb-shimmer-tertiary": rgbDistribution.harmonyTertiary,
              "--spice-shimmer-quaternary": colorDistribution.primary,
              "--spice-rgb-shimmer-quaternary": rgbDistribution.primary,
              // Particle effect colors
              "--spice-particle-glow": colorDistribution.highlight,
              "--spice-rgb-particle-glow": rgbDistribution.highlight,
              "--spice-particle-core": colorDistribution.primary,
              "--spice-rgb-particle-core": rgbDistribution.primary,
              "--spice-particle-trail": colorDistribution.shadow,
              "--spice-rgb-particle-trail": rgbDistribution.shadow,
              // Cinematic drama colors (high contrast variants)
              "--spice-cinematic-red": this.generateCinematicRed(colorDistribution.primary),
              "--spice-rgb-cinematic-red": this.hexToRgb(this.generateCinematicRed(colorDistribution.primary)),
              "--spice-cinematic-cyan": this.generateCinematicCyan(colorDistribution.primary),
              "--spice-rgb-cinematic-cyan": this.hexToRgb(this.generateCinematicCyan(colorDistribution.primary)),
              "--spice-cinematic-yellow": this.generateCinematicYellow(colorDistribution.highlight),
              "--spice-rgb-cinematic-yellow": this.hexToRgb(this.generateCinematicYellow(colorDistribution.highlight)),
              // Holographic UI colors (luminous variants)
              "--spice-holographic-primary": this.generateHolographicPrimary(colorDistribution.primary),
              "--spice-rgb-holographic-primary": this.hexToRgb(this.generateHolographicPrimary(colorDistribution.primary)),
              "--spice-holographic-accent": this.generateHolographicAccent(colorDistribution.harmonyPrimary),
              "--spice-rgb-holographic-accent": this.hexToRgb(this.generateHolographicAccent(colorDistribution.harmonyPrimary)),
              "--spice-holographic-glow": this.generateHolographicGlow(colorDistribution.highlight),
              "--spice-rgb-holographic-glow": this.hexToRgb(this.generateHolographicGlow(colorDistribution.highlight))
            };
            const allSpicetifyUpdates = {
              ...coreSpicetifyUpdates,
              ...criticalSpicetifyUpdates,
              ...coreLayoutSpicetifyUpdates,
              ...visualHarmonyColorUpdates,
              ...paletteSpicetifyUpdates,
              ...effectsSpicetifyUpdates
            };
            this.cssController.batchSetVariables(
              "SemanticColorManager",
              allSpicetifyUpdates,
              "critical",
              // Critical priority for album color coordination
              "album-spicetify-update"
            );
            const starryNightUpdates = {
              "--sn-bg-gradient-accent": colorDistribution.primary,
              "--sn-bg-gradient-accent-rgb": rgbDistribution.primary,
              "--sn-bg-gradient-primary": colorDistribution.primary,
              "--sn-bg-gradient-primary-rgb": rgbDistribution.primary,
              "--sn-bg-gradient-secondary": colorDistribution.surface1,
              "--sn-bg-gradient-secondary-rgb": rgbDistribution.surface1
            };
            this.cssController.batchSetVariables(
              "SemanticColorManager",
              starryNightUpdates,
              "critical",
              // Critical priority for StarryNight gradient synchronization
              "album-starrynight-update"
            );
            const snColorUpdates = {
              "--sn-color-accent-hex": colorDistribution.primary,
              "--sn-color-accent-rgb": rgbDistribution.primary,
              "--sn-accent-hex": colorDistribution.primary,
              "--sn-accent-rgb": rgbDistribution.primary,
              "--sn-color-extracted-primary-rgb": rgbDistribution.primary,
              "--sn-color-extracted-secondary-rgb": rgbDistribution.surface1,
              "--sn-color-harmony-complementary-rgb": rgbDistribution.shadow,
              "--sn-color-harmony-analogous-rgb": rgbDistribution.highlight,
              "--sn-color-harmony-triadic-rgb": rgbDistribution.harmonyPrimary
            };
            this.cssController.batchSetVariables(
              "SemanticColorManager",
              snColorUpdates,
              "critical",
              // Critical priority for Year 3000 System integration
              "album-y3k-integration-update"
            );
            this.clearCache();
            this.lastColorUpdate = Date.now();
            this.colorUpdateCount++;
            const totalVariablesUpdated = Object.keys(allSpicetifyUpdates).length + Object.keys(starryNightUpdates).length + Object.keys(snColorUpdates).length;
            unifiedEventBus.emitSync("colors:applied", {
              cssVariables: {
                ...allSpicetifyUpdates,
                ...starryNightUpdates,
                ...snColorUpdates
              },
              accentHex: colorDistribution.primary,
              accentRgb: rgbDistribution.primary,
              appliedAt: this.lastColorUpdate
            });
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] Comprehensive Spicetify variable update with OKLAB album colors:", {
                primaryColor: colorDistribution.primary,
                accentColor: colorDistribution.surface1,
                shadowColor: colorDistribution.shadow,
                highlightColor: colorDistribution.highlight,
                surfaceProgression: [colorDistribution.base, colorDistribution.surface0, colorDistribution.surface1, colorDistribution.surface2],
                harmonyColors: [colorDistribution.harmonyPrimary, colorDistribution.harmonySecondary, colorDistribution.harmonyTertiary],
                effectColors: {
                  shimmerColors: 4,
                  // primary, secondary, tertiary, quaternary
                  particleColors: 3,
                  // glow, core, trail
                  cinematicColors: 3,
                  // red, cyan, yellow
                  holographicColors: 3
                  // primary, accent, glow
                },
                totalSpicetifyVariablesUpdated: Object.keys(allSpicetifyUpdates).length,
                coreLayoutVariablesUpdated: Object.keys(coreLayoutSpicetifyUpdates).length,
                starryNightVariablesUpdated: Object.keys(starryNightUpdates).length,
                snColorVariablesUpdated: Object.keys(snColorUpdates).length,
                effectVariablesAdded: Object.keys(effectsSpicetifyUpdates).length,
                eventEmitted: true,
                totalVariablesUpdated
              });
            }
          } catch (error) {
            console.error("[SemanticColorManager] Failed to update with album colors:", error);
          }
        }
        /**
         * Generate intelligent color distribution for comprehensive Spicetify variable coverage
         * Uses OKLAB-inspired color science for perceptually uniform depth progression and harmony color variations
         */
        generateIntelligentColorDistribution(primaryColor, accentColor, shadowColor, highlightColor) {
          const primary = primaryColor;
          const accent = accentColor || primaryColor;
          const shadow = shadowColor || this.generateDarkerVariant(primaryColor, 0.3);
          const highlight = highlightColor || this.generateLighterVariant(primaryColor, 0.2);
          const base = this.generateDarkerVariant(primaryColor, 0.6);
          const surface0 = this.generateDarkerVariant(primaryColor, 0.4);
          const surface1 = accent;
          const surface2 = this.generateLighterVariant(accent, 0.15);
          const harmonyPrimary = this.generateHueRotatedColor(primaryColor, 120);
          const harmonySecondary = this.generateHueRotatedColor(primaryColor, -60);
          const harmonyTertiary = this.generateHueRotatedColor(primaryColor, 180);
          return {
            primary,
            surface0,
            surface1,
            surface2,
            base,
            shadow,
            highlight,
            harmonyPrimary,
            harmonySecondary,
            harmonyTertiary
          };
        }
        /**
         * Convert color distribution object to RGB strings for CSS variables
         */
        convertColorsToRgb(colorDistribution) {
          const rgbDistribution = {};
          Object.entries(colorDistribution).forEach(([key, hexColor]) => {
            rgbDistribution[key] = this.hexToRgb(hexColor);
          });
          return rgbDistribution;
        }
        /**
         * Generate a darker variant of a color by reducing lightness
         */
        generateDarkerVariant(hexColor, factor) {
          try {
            const rgb = this.hexToRgbObject(hexColor);
            if (!rgb) return hexColor;
            const r = Math.max(0, Math.round(rgb.r * (1 - factor)));
            const g = Math.max(0, Math.round(rgb.g * (1 - factor)));
            const b = Math.max(0, Math.round(rgb.b * (1 - factor)));
            return this.rgbToHex(r, g, b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate darker variant:", error);
            return hexColor;
          }
        }
        /**
         * Generate a lighter variant of a color by increasing lightness
         */
        generateLighterVariant(hexColor, factor) {
          try {
            const rgb = this.hexToRgbObject(hexColor);
            if (!rgb) return hexColor;
            const r = Math.min(255, Math.round(rgb.r + (255 - rgb.r) * factor));
            const g = Math.min(255, Math.round(rgb.g + (255 - rgb.g) * factor));
            const b = Math.min(255, Math.round(rgb.b + (255 - rgb.b) * factor));
            return this.rgbToHex(r, g, b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate lighter variant:", error);
            return hexColor;
          }
        }
        /**
         * Generate a hue-rotated variant of a color for visual harmony systems
         */
        generateHueRotatedColor(hexColor, hueDegrees) {
          try {
            const rgb = this.hexToRgbObject(hexColor);
            if (!rgb) return hexColor;
            const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
            hsl.h = (hsl.h + hueDegrees) % 360;
            if (hsl.h < 0) hsl.h += 360;
            const rotatedRgb = this.hslToRgb(hsl.h, hsl.s, hsl.l);
            return this.rgbToHex(rotatedRgb.r, rotatedRgb.g, rotatedRgb.b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate hue-rotated color:", error);
            return hexColor;
          }
        }
        /**
         * Convert hex color to RGB object
         */
        hexToRgbObject(hex) {
          const cleanHex = hex.replace("#", "");
          if (cleanHex.length !== 6) return null;
          const r = parseInt(cleanHex.substring(0, 2), 16);
          const g = parseInt(cleanHex.substring(2, 4), 16);
          const b = parseInt(cleanHex.substring(4, 6), 16);
          return { r, g, b };
        }
        /**
         * Convert RGB values to hex string
         */
        rgbToHex(r, g, b) {
          const toHex = /* @__PURE__ */ __name((n) => {
            const hex = Math.round(Math.max(0, Math.min(255, n))).toString(16);
            return hex.length === 1 ? "0" + hex : hex;
          }, "toHex");
          return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
        /**
         * Convert RGB to HSL for hue manipulation
         */
        rgbToHsl(r, g, b) {
          r /= 255;
          g /= 255;
          b /= 255;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h = 0;
          let s = 0;
          const l = (max + min) / 2;
          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return { h: h * 360, s: s * 100, l: l * 100 };
        }
        /**
         * Convert HSL back to RGB
         */
        hslToRgb(h, s, l) {
          h /= 360;
          s /= 100;
          l /= 100;
          const hue2rgb = /* @__PURE__ */ __name((p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          }, "hue2rgb");
          let r, g, b;
          if (s === 0) {
            r = g = b = l;
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
          };
        }
        /**
         * Convert hex color to RGB string for CSS variables
         */
        hexToRgb(hex) {
          const cleanHex = hex.replace("#", "");
          const r = parseInt(cleanHex.substring(0, 2), 16);
          const g = parseInt(cleanHex.substring(2, 4), 16);
          const b = parseInt(cleanHex.substring(4, 6), 16);
          return `${r}, ${g}, ${b}`;
        }
        getColorMappings() {
          return _SemanticColorManager.SEMANTIC_MAPPINGS;
        }
        // 🎨 PHASE 3: Effect-Specific Color Generators
        // Generate specialized colors for visual effect systems
        /**
         * Generate cinematic red color with high contrast characteristics
         * Based on album color psychology for dramatic effects
         */
        generateCinematicRed(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#FF0000";
            const dramaticRed = Math.min(255, rgb.r + 100);
            const warmGreen = Math.max(0, Math.min(rgb.g * 0.3, 100));
            const warmBlue = Math.max(0, Math.min(rgb.b * 0.2, 80));
            return this.rgbToHex(dramaticRed, warmGreen, warmBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate cinematic red:", error);
            return "#FF0000";
          }
        }
        /**
         * Generate cinematic cyan color complementary to the base color
         * Creates high contrast cyan for dramatic visual effects
         */
        generateCinematicCyan(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#00FFFF";
            const dramaticGreen = Math.min(255, rgb.g + 120);
            const dramaticBlue = Math.min(255, rgb.b + 140);
            const coolRed = Math.max(0, Math.min(rgb.r * 0.2, 60));
            return this.rgbToHex(coolRed, dramaticGreen, dramaticBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate cinematic cyan:", error);
            return "#00FFFF";
          }
        }
        /**
         * Generate cinematic yellow for accent dramatic effects
         * Bright, attention-grabbing yellow based on highlight color
         */
        generateCinematicYellow(highlightColor) {
          try {
            const rgb = this.hexToRgbObject(highlightColor);
            if (!rgb) return "#FFFF00";
            const brightRed = Math.min(255, rgb.r + 80);
            const brightGreen = Math.min(255, rgb.g + 100);
            const subtleBlue = Math.max(0, Math.min(rgb.b * 0.3, 120));
            return this.rgbToHex(brightRed, brightGreen, subtleBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate cinematic yellow:", error);
            return "#FFFF00";
          }
        }
        /**
         * Generate holographic primary color with luminous characteristics
         * Creates iridescent, enhanced color based on album primary
         */
        generateHolographicPrimary(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#8A2BE2";
            const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
            const enhancedSaturation = Math.min(1, hsl.s + 0.3);
            const luminousLightness = Math.min(0.8, Math.max(0.4, hsl.l + 0.1));
            const enhancedRgb = this.hslToRgb(hsl.h, enhancedSaturation, luminousLightness);
            return this.rgbToHex(enhancedRgb.r, enhancedRgb.g, enhancedRgb.b);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate holographic primary:", error);
            return "#8A2BE2";
          }
        }
        /**
         * Generate holographic accent color with prismatic shift
         * Creates complementary holographic color for accent effects
         */
        generateHolographicAccent(harmonyColor) {
          try {
            return this.generateHueRotatedColor(harmonyColor, 45);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate holographic accent:", error);
            return "#FF00FF";
          }
        }
        /**
         * Generate holographic glow color for luminous lighting effects
         * Creates soft, luminous glow based on highlight color
         */
        generateHolographicGlow(highlightColor) {
          try {
            const rgb = this.hexToRgbObject(highlightColor);
            if (!rgb) return "#E0E0FF";
            const glowIntensity = 0.7;
            const glowRed = Math.min(255, rgb.r + (255 - rgb.r) * glowIntensity);
            const glowGreen = Math.min(255, rgb.g + (255 - rgb.g) * glowIntensity);
            const glowBlue = Math.min(255, rgb.b + (255 - rgb.b) * glowIntensity);
            return this.rgbToHex(glowRed, glowGreen, glowBlue);
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate holographic glow:", error);
            return "#E0E0FF";
          }
        }
        /**
         * Generate high contrast text color based on background color
         * Creates optimal text readability for context-aware design
         */
        generateTextColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#CAD3F5";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              return "#24273A";
            } else {
              return "#CAD3F5";
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate text color:", error);
            return "#CAD3F5";
          }
        }
        /**
         * Generate medium contrast subdued text color
         * Creates secondary text with reduced contrast for hierarchy
         */
        generateSubtextColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#A5ADCB";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              return "#5B6078";
            } else {
              return "#A5ADCB";
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate subtext color:", error);
            return "#A5ADCB";
          }
        }
        /**
         * Generate progressive overlay colors for background depth hierarchy
         * Creates Catppuccin-style overlay colors with OKLAB-enhanced base
         */
        generateOverlayColor(baseColor, opacity) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return `rgba(88,91,112,${opacity})`;
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              const factor = 1 - opacity * 2;
              const overlayRed = Math.max(0, Math.round(rgb.r * factor));
              const overlayGreen = Math.max(0, Math.round(rgb.g * factor));
              const overlayBlue = Math.max(0, Math.round(rgb.b * factor));
              return this.rgbToHex(overlayRed, overlayGreen, overlayBlue);
            } else {
              const factor = opacity * 255;
              const overlayRed = Math.min(255, Math.round(rgb.r + factor));
              const overlayGreen = Math.min(255, Math.round(rgb.g + factor));
              const overlayBlue = Math.min(255, Math.round(rgb.b + factor));
              return this.rgbToHex(overlayRed, overlayGreen, overlayBlue);
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate overlay color:", error);
            return `rgba(88,91,112,${opacity})`;
          }
        }
        /**
         * Generate window frame/border crust color
         * Creates subtle border color for window chrome elements
         */
        generateCrustColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#232634";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              const crustRed = Math.max(0, Math.round(rgb.r * 0.8));
              const crustGreen = Math.max(0, Math.round(rgb.g * 0.8));
              const crustBlue = Math.max(0, Math.round(rgb.b * 0.8));
              return this.rgbToHex(crustRed, crustGreen, crustBlue);
            } else {
              const crustRed = Math.min(255, Math.round(rgb.r + 20));
              const crustGreen = Math.min(255, Math.round(rgb.g + 20));
              const crustBlue = Math.min(255, Math.round(rgb.b + 20));
              return this.rgbToHex(crustRed, crustGreen, crustBlue);
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate crust color:", error);
            return "#232634";
          }
        }
        /**
         * Generate window background mantle color
         * Creates intermediate color between base and overlay0 for window backgrounds
         */
        generateMantleColor(baseColor) {
          try {
            const rgb = this.hexToRgbObject(baseColor);
            if (!rgb) return "#1e2030";
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            if (luminance > 0.5) {
              const mantleRed = Math.max(0, Math.round(rgb.r * 0.95));
              const mantleGreen = Math.max(0, Math.round(rgb.g * 0.95));
              const mantleBlue = Math.max(0, Math.round(rgb.b * 0.95));
              return this.rgbToHex(mantleRed, mantleGreen, mantleBlue);
            } else {
              const mantleRed = Math.min(255, Math.round(rgb.r + 10));
              const mantleGreen = Math.min(255, Math.round(rgb.g + 10));
              const mantleBlue = Math.min(255, Math.round(rgb.b + 10));
              return this.rgbToHex(mantleRed, mantleGreen, mantleBlue);
            }
          } catch (error) {
            console.warn("[SemanticColorManager] Failed to generate mantle color:", error);
            return "#1e2030";
          }
        }
        /**
         * Generate zone-specific colors with context-aware hue shifts
         * Creates contextual color variations for different UI zones (home, playlist, artist, search)
         */
        generateZoneColor(baseColor, zoneType) {
          try {
            const rgb = hexToRgb(baseColor);
            if (!rgb) {
              console.warn(`\u{1F527} [SemanticColorManager] Failed to parse RGB from ${baseColor}`);
              return baseColor;
            }
            const zoneAdjustments = {
              flamingo: { rAdjust: 20, gAdjust: -10, bAdjust: -5 },
              // Warm pink for home comfort
              lavender: { rAdjust: 10, gAdjust: -5, bAdjust: 15 },
              // Cool purple for focus/playlist
              peach: { rAdjust: 25, gAdjust: 10, bAdjust: -15 },
              // Warm orange for artist discovery
              rosewater: { rAdjust: 15, gAdjust: -8, bAdjust: 0 },
              // Subtle pink for secondary elements
              sapphire: { rAdjust: -20, gAdjust: -10, bAdjust: 25 }
              // Deep blue for search precision
            };
            const config = zoneAdjustments[zoneType];
            const adjustedR = Math.max(0, Math.min(255, rgb.r + config.rAdjust));
            const adjustedG = Math.max(0, Math.min(255, rgb.g + config.gAdjust));
            const adjustedB = Math.max(0, Math.min(255, rgb.b + config.bAdjust));
            const zoneHex = rgbToHex(adjustedR, adjustedG, adjustedB);
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [SemanticColorManager] Generated ${zoneType} color: ${baseColor} \u2192 ${zoneHex} (RGB: ${rgb.r},${rgb.g},${rgb.b} \u2192 ${adjustedR},${adjustedG},${adjustedB})`);
            }
            return zoneHex;
          } catch (error) {
            console.warn(`\u{1F527} [SemanticColorManager] Failed to generate ${zoneType} color for "${baseColor}":`, error);
            return baseColor;
          }
        }
        /**
         * Generate palette-specific colors with context-aware variations
         * Creates color variations for Catppuccin palette colors (pink, sky, red, maroon, yellow, green)
         */
        generatePaletteColor(baseColor, paletteType) {
          try {
            const rgb = hexToRgb(baseColor);
            if (!rgb) {
              console.warn(`\u{1F527} [SemanticColorManager] Failed to parse RGB from ${baseColor}`);
              return baseColor;
            }
            const paletteAdjustments = {
              pink: { rAdjust: 30, gAdjust: -20, bAdjust: -10 },
              // Soft pink for decorative elements
              sky: { rAdjust: -30, gAdjust: 10, bAdjust: 30 },
              // Bright sky blue for information
              red: { rAdjust: 35, gAdjust: -25, bAdjust: -15 },
              // Vibrant red for errors/warnings
              maroon: { rAdjust: 25, gAdjust: -15, bAdjust: -10 },
              // Deep maroon for emphasis
              yellow: { rAdjust: 30, gAdjust: 25, bAdjust: -30 },
              // Bright yellow for warnings
              green: { rAdjust: -25, gAdjust: 30, bAdjust: -20 }
              // Natural green for success
            };
            const config = paletteAdjustments[paletteType];
            const adjustedR = Math.max(0, Math.min(255, rgb.r + config.rAdjust));
            const adjustedG = Math.max(0, Math.min(255, rgb.g + config.gAdjust));
            const adjustedB = Math.max(0, Math.min(255, rgb.b + config.bAdjust));
            const paletteHex = rgbToHex(adjustedR, adjustedG, adjustedB);
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [SemanticColorManager] Generated ${paletteType} color: ${baseColor} \u2192 ${paletteHex} (RGB: ${rgb.r},${rgb.g},${rgb.b} \u2192 ${adjustedR},${adjustedG},${adjustedB})`);
            }
            return paletteHex;
          } catch (error) {
            console.warn(`\u{1F527} [SemanticColorManager] Failed to generate ${paletteType} color for "${baseColor}":`, error);
            return baseColor;
          }
        }
        destroy() {
          try {
            this.cleanupEventSubscriptions();
            this.clearCache();
            this.cssController = null;
            this.initialized = false;
            this.lastColorUpdate = 0;
            this.colorUpdateCount = 0;
            unifiedEventBus.emitSync("system:destroyed", {
              systemName: "SemanticColorManager",
              timestamp: Date.now(),
              reason: "Manual destruction"
            });
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [SemanticColorManager] System destroyed and cleaned up");
            }
          } catch (error) {
            console.error("[SemanticColorManager] Error during destruction:", error);
          }
        }
        /**
         * IManagedSystem interface implementation
         */
        updateAnimation(deltaTime) {
        }
        /**
         * IManagedSystem health check implementation
         */
        async healthCheck() {
          const healthResult = {
            system: "SemanticColorManager",
            healthy: true,
            details: "SemanticColorManager operational",
            issues: [],
            metrics: {
              initialized: this.initialized,
              spicetifyAvailable: this.isSpicetifyAvailable(),
              cssControllerAvailable: !!this.cssController,
              lastColorUpdate: this.lastColorUpdate,
              colorUpdateCount: this.colorUpdateCount,
              eventSubscriptions: this.eventSubscriptionIds.length,
              cacheSize: this.colorCache.size,
              lastCacheUpdate: this.lastCacheUpdate
            }
          };
          if (!this.initialized) {
            healthResult.healthy = false;
            healthResult.issues.push("System not initialized");
          }
          if (!this.isSpicetifyAvailable()) {
            healthResult.healthy = false;
            healthResult.issues.push("Spicetify API not available");
          }
          if (this.colorUpdateCount === 0 && this.initialized) {
            healthResult.issues.push("No color updates performed since initialization");
          }
          if (this.eventSubscriptionIds.length === 0 && this.initialized) {
            healthResult.issues.push("No event subscriptions active");
          }
          if (healthResult.issues.length > 0) {
            healthResult.details = `Issues detected: ${healthResult.issues.join(", ")}`;
            if (healthResult.issues.length >= 2) {
              healthResult.healthy = false;
            }
          }
          return healthResult;
        }
        /**
         * Setup event subscriptions for system integration
         */
        setupEventSubscriptions() {
          const trackChangeId = unifiedEventBus.subscribe(
            "music:track-changed",
            async (data) => {
              if (this.config.enableDebug) {
                console.log("\u{1F3A8} [SemanticColorManager] Track changed, preparing for color refresh:", data.trackUri);
              }
              this.clearCache();
            },
            "SemanticColorManager"
          );
          const settingsChangeId = unifiedEventBus.subscribe(
            "settings:changed",
            async (data) => {
              if (data.settingKey.includes("color") || data.settingKey.includes("theme")) {
                if (this.config.enableDebug) {
                  console.log("\u{1F3A8} [SemanticColorManager] Color-related setting changed:", data.settingKey);
                }
                this.clearCache();
              }
            },
            "SemanticColorManager"
          );
          this.eventSubscriptionIds = [trackChangeId, settingsChangeId];
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [SemanticColorManager] Event subscriptions established:", this.eventSubscriptionIds.length);
          }
        }
        /**
         * Clean up event subscriptions
         */
        cleanupEventSubscriptions() {
          for (const subscriptionId of this.eventSubscriptionIds) {
            unifiedEventBus.unsubscribe(subscriptionId);
          }
          this.eventSubscriptionIds = [];
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [SemanticColorManager] Event subscriptions cleaned up");
          }
        }
        /**
         * Get system metrics for monitoring
         */
        getSystemMetrics() {
          return {
            initialized: this.initialized,
            lastColorUpdate: this.lastColorUpdate,
            colorUpdateCount: this.colorUpdateCount,
            eventSubscriptions: this.eventSubscriptionIds.length,
            cacheSize: this.colorCache.size,
            spicetifyAvailable: this.isSpicetifyAvailable()
          };
        }
      };
      __name(_SemanticColorManager, "SemanticColorManager");
      // Semantic color mappings to our CSS variables
      _SemanticColorManager.SEMANTIC_MAPPINGS = [
        // Text colors (Catppuccin Macchiato)
        { semanticColor: "textBase", cssVariable: "--spice-text", fallbackColor: "#cad3f5", description: "Primary text color" },
        { semanticColor: "textSubdued", cssVariable: "--spice-subtext", fallbackColor: "#a5adcb", description: "Secondary text color" },
        { semanticColor: "textBrightAccent", cssVariable: "--spice-accent", fallbackColor: "#c6a0f6", description: "Accent text color" },
        { semanticColor: "textNegative", cssVariable: "--spice-red", fallbackColor: "#ed8796", description: "Error text color" },
        { semanticColor: "textWarning", cssVariable: "--spice-yellow", fallbackColor: "#eed49f", description: "Warning text color" },
        { semanticColor: "textPositive", cssVariable: "--spice-green", fallbackColor: "#a6da95", description: "Success text color" },
        { semanticColor: "textAnnouncement", cssVariable: "--spice-blue", fallbackColor: "#8aadf4", description: "Info text color" },
        // Essential colors (for icons, controls) - Catppuccin Macchiato
        { semanticColor: "essentialBase", cssVariable: "--spice-button", fallbackColor: "#cad3f5", description: "Primary button color" },
        { semanticColor: "essentialSubdued", cssVariable: "--spice-button-disabled", fallbackColor: "#6e738d", description: "Disabled button color" },
        { semanticColor: "essentialBrightAccent", cssVariable: "--spice-button-active", fallbackColor: "#c6a0f6", description: "Active button color" },
        { semanticColor: "essentialNegative", cssVariable: "--spice-notification-error", fallbackColor: "#ed8796", description: "Error button color" },
        { semanticColor: "essentialWarning", cssVariable: "--spice-notification-warning", fallbackColor: "#eed49f", description: "Warning button color" },
        { semanticColor: "essentialPositive", cssVariable: "--spice-notification-success", fallbackColor: "#a6da95", description: "Success button color" },
        // Background colors - Catppuccin Macchiato
        { semanticColor: "backgroundBase", cssVariable: "--spice-main", fallbackColor: "#24273a", description: "Main background color" },
        { semanticColor: "backgroundHighlight", cssVariable: "--spice-highlight", fallbackColor: "#363a4f", description: "Highlight background color" },
        { semanticColor: "backgroundPress", cssVariable: "--spice-press", fallbackColor: "#494d64", description: "Press state background color" },
        { semanticColor: "backgroundElevatedBase", cssVariable: "--spice-card", fallbackColor: "#1e2030", description: "Card background color" },
        { semanticColor: "backgroundElevatedHighlight", cssVariable: "--spice-card-highlight", fallbackColor: "#363a4f", description: "Card highlight background" },
        { semanticColor: "backgroundTintedBase", cssVariable: "--spice-sidebar", fallbackColor: "#363a4f", description: "Sidebar background color" },
        { semanticColor: "backgroundTintedHighlight", cssVariable: "--spice-sidebar-highlight", fallbackColor: "#494d64", description: "Sidebar highlight background" },
        // Decorative colors - Catppuccin Macchiato
        { semanticColor: "decorativeBase", cssVariable: "--spice-decorative", fallbackColor: "#cad3f5", description: "Decorative element color" },
        { semanticColor: "decorativeSubdued", cssVariable: "--spice-decorative-subdued", fallbackColor: "#939ab7", description: "Subdued decorative color" }
      ];
      SemanticColorManager = _SemanticColorManager;
    }
  });

  // src-js/utils/graphics/VisualCanvasFactory.ts
  function detectWebGL2Support() {
    try {
      const testCanvas = document.createElement("canvas");
      const gl = testCanvas.getContext("webgl2");
      if (!gl) return false;
      const hasRequiredExtensions = gl.getExtension("EXT_color_buffer_float") !== null;
      return true;
    } catch (e) {
      return false;
    }
  }
  function createWebGL2Context(canvas, options) {
    try {
      const contextOptions = {
        alpha: options.alpha ?? true,
        antialias: options.antialias ?? true,
        preserveDrawingBuffer: options.preserveDrawingBuffer ?? false,
        powerPreference: "high-performance",
        failIfMajorPerformanceCaveat: false
      };
      const gl = canvas.getContext(
        "webgl2",
        contextOptions
      );
      if (!gl) return null;
      const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      return {
        canvas,
        ctx: gl,
        type: "webgl2",
        capabilities: {
          supportsGPUAcceleration: true,
          supports3D: true,
          maxTextureSize
        }
      };
    } catch (error) {
      console.warn(
        "[VisualCanvasFactory] WebGL2 context creation failed:",
        error
      );
      return null;
    }
  }
  function create2DContext(canvas, options) {
    const contextOptions = {
      alpha: options.alpha ?? true,
      desynchronized: true
      // Optimize for animations
    };
    const ctx = canvas.getContext(
      "2d",
      contextOptions
    );
    return {
      canvas,
      ctx,
      type: "2d",
      capabilities: {
        supportsGPUAcceleration: false,
        supports3D: false
      }
    };
  }
  async function createOptimizedCanvas(options) {
    const canvas = document.createElement("canvas");
    canvas.id = options.id;
    canvas.width = options.width ?? window.innerWidth;
    canvas.height = options.height ?? window.innerHeight;
    const fallbackChain = options.fallbackChain ?? ["webgl2", "2d"];
    if (options.preferredType) {
      const chain = [
        options.preferredType,
        ...fallbackChain.filter((t) => t !== options.preferredType)
      ];
      fallbackChain.splice(0, fallbackChain.length, ...chain);
    }
    for (const contextType of fallbackChain) {
      let result = null;
      switch (contextType) {
        case "webgl2":
          if (detectWebGL2Support()) {
            result = createWebGL2Context(canvas, options);
          }
          break;
        case "2d":
          result = create2DContext(canvas, options);
          break;
      }
      if (result) {
        return result;
      }
    }
    return create2DContext(canvas, options);
  }
  function detectRenderingCapabilities() {
    const webgl2 = detectWebGL2Support();
    let recommendedType = "2d";
    if (webgl2) {
      recommendedType = "webgl2";
    }
    return { webgl2, recommendedType };
  }
  var init_VisualCanvasFactory = __esm({
    "src-js/utils/graphics/VisualCanvasFactory.ts"() {
      "use strict";
      __name(detectWebGL2Support, "detectWebGL2Support");
      __name(createWebGL2Context, "createWebGL2Context");
      __name(create2DContext, "create2DContext");
      __name(createOptimizedCanvas, "createOptimizedCanvas");
      __name(detectRenderingCapabilities, "detectRenderingCapabilities");
    }
  });

  // src-js/utils/animation/visualPerformance.ts
  function selectPerformanceProfile(quality, performanceProfiles, opts = {}) {
    const { trace } = opts;
    if (!performanceProfiles || typeof performanceProfiles !== "object") {
      trace?.(
        "[visualPerformance] No performanceProfiles provided \u2013 skipping selection"
      );
      return null;
    }
    let selected = performanceProfiles[quality];
    if (!selected) {
      trace?.(
        `[visualPerformance] Profile '${quality}' not found, falling back to 'balanced'`
      );
      selected = performanceProfiles["balanced"];
    }
    if (!selected) {
      const firstKey = Object.keys(
        performanceProfiles
      )[0];
      selected = performanceProfiles[firstKey];
      trace?.(
        `[visualPerformance] Using first available profile '${firstKey}' as fallback`
      );
    }
    return selected;
  }
  var init_visualPerformance = __esm({
    "src-js/utils/animation/visualPerformance.ts"() {
      "use strict";
      __name(selectPerformanceProfile, "selectPerformanceProfile");
    }
  });

  // src-js/visual/base/BaseVisualSystem.ts
  var _BaseVisualSystem, BaseVisualSystem;
  var init_BaseVisualSystem = __esm({
    "src-js/visual/base/BaseVisualSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_VisualCanvasFactory();
      init_ThemeUtilities();
      init_visualPerformance();
      _BaseVisualSystem = class _BaseVisualSystem {
        constructor(config = ADVANCED_SYSTEM_CONFIG, utils = ThemeUtilities_exports, performanceMonitor, musicSyncService, settingsManager2) {
          // GPU-accelerated canvas support
          this.canvasCapabilities = null;
          this.activeCanvasResults = /* @__PURE__ */ new Map();
          this.config = config;
          this.utils = utils;
          this.performanceMonitor = performanceMonitor;
          this.musicSyncService = musicSyncService;
          this.settingsManager = settingsManager2;
          this.systemName = this.constructor.name;
          this.initialized = false;
          this.isActive = false;
          this.currentPerformanceProfile = {};
          this.metrics = {
            initializationTime: 0,
            updates: 0,
            errors: 0
          };
          this._resizeHandler = null;
          this.boundHandleSettingsChange = this.handleSettingsChange.bind(this);
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Constructor`);
          }
        }
        // Replace the current skeletal `initialize` method with this complete, multi-phase version.
        async initialize() {
          const initStartTime = this.config.enableDebug ? performance.now() : 0;
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing...`);
          }
          if (this.settingsManager) {
            document.addEventListener(
              "year3000SystemSettingsChanged",
              this.boundHandleSettingsChange
            );
            try {
              const detectorInstance = globalThis.year3000System?.deviceCapabilityDetector;
              let quality = "balanced";
              if (detectorInstance?.isInitialized) {
                quality = detectorInstance.recommendPerformanceQuality();
              }
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Auto-selected performance quality '${quality}' based on device capability.`);
              }
              this._applyPerformanceProfile(quality);
            } catch (e) {
              this.performanceMonitor?.emitTrace?.(
                `[${this.systemName}] Device capability detection failed; defaulting to 'balanced'.`,
                e
              );
              this._applyPerformanceProfile("balanced");
            }
          }
          await this._performSystemSpecificInitialization();
          this.initialized = true;
          this.isActive = true;
          if (this.musicSyncService) {
            if (this._validateDependenciesForSubscription()) {
              this.musicSyncService.subscribe(this, this.systemName);
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Subscribed to MusicSyncService.`);
              }
            } else {
              console.warn(
                `[${this.systemName}] Dependency validation failed; subscription skipped.`
              );
            }
          }
          if (this.config.enableDebug) {
            const duration = performance.now() - initStartTime;
            console.log(`[${this.systemName}] Initialization complete in ${duration.toFixed(2)}ms`);
          }
        }
        // Add new virtual methods for subclass extension.
        // These provide safe hooks for custom initialization logic.
        async _performSystemSpecificInitialization() {
          this.canvasCapabilities = detectRenderingCapabilities();
          if (this.canvasCapabilities) {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Canvas capabilities detected: WebGL2=${this.canvasCapabilities.webgl2}, Recommended=${this.canvasCapabilities.recommendedType}`
            );
          }
        }
        _validateDependenciesForSubscription() {
          if (typeof this.updateFromMusicAnalysis !== "function") {
            console.error(
              `[${this.systemName}] Missing updateFromMusicAnalysis method.`
            );
            return false;
          }
          if (!this.initialized) {
            console.warn(`[${this.systemName}] System not initialized.`);
            return false;
          }
          return this._performAdditionalDependencyValidation();
        }
        _performAdditionalDependencyValidation() {
          return true;
        }
        // Replace the current skeletal `destroy` method with this complete version for proper cleanup.
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying...`);
          }
          try {
            this.initialized = false;
            this.isActive = false;
            if (this.musicSyncService) {
              this.musicSyncService.unsubscribe(this.systemName);
            }
            if (this.settingsManager && this.boundHandleSettingsChange) {
              document.removeEventListener(
                "year3000SystemSettingsChanged",
                this.boundHandleSettingsChange
              );
            }
            if (this._resizeHandler) {
              window.removeEventListener("resize", this._resizeHandler);
              this._resizeHandler = null;
            }
            this._performSystemSpecificCleanup();
          } catch (error) {
            console.error(`[${this.systemName}] Error during destruction:`, error);
            this.metrics.errors++;
          }
        }
        // Add the virtual cleanup hook for subclasses.
        _performSystemSpecificCleanup() {
          for (const [id, canvasResult] of this.activeCanvasResults) {
            const canvas = canvasResult.canvas;
            if (canvas.parentNode) {
              canvas.parentNode.removeChild(canvas);
            }
            if (this.config.enableDebug) {
              console.log(
                `[${this.systemName}] Cleaned up canvas: ${id} (type: ${canvasResult.type})`
              );
            }
          }
          this.activeCanvasResults.clear();
        }
        updateFromMusicAnalysis(processedMusicData, ...args) {
        }
        /**
         * Unified animation hook called by MasterAnimationCoordinator.
         * Subclasses can override this method or implement updateAnimation for legacy support.
         *
         * @param deltaMs - Time in milliseconds since the last frame for this system
         */
        onAnimate(deltaMs) {
        }
        /**
         * IManagedSystem interface method for animation updates
         * @param deltaTime Time elapsed since last frame in milliseconds
         */
        updateAnimation(deltaTime) {
          this.onAnimate(deltaTime);
        }
        /**
         * IManagedSystem interface method for health checks
         * @returns Promise<HealthCheckResult> System health status
         */
        async healthCheck() {
          const isHealthy = this.initialized && this.isActive && this.metrics.errors === 0;
          return {
            system: this.systemName,
            healthy: isHealthy,
            metrics: {
              initialized: this.initialized,
              active: this.isActive,
              errors: this.metrics.errors,
              updates: this.metrics.updates,
              initializationTime: this.metrics.initializationTime
            },
            issues: isHealthy ? [] : [
              ...this.initialized ? [] : ["System not initialized"],
              ...this.isActive ? [] : ["System not active"],
              ...this.metrics.errors === 0 ? [] : [`${this.metrics.errors} errors detected`]
            ]
          };
        }
        updateModeConfiguration(modeConfig) {
        }
        /**
         * Base implementation of the settings-change hook. It is intentionally empty
         * now that the legacy `sn-performanceQuality` key has been removed. Subclasses
         * should override this method if they need to respond to other settings keys
         * and are still encouraged to call `super.handleSettingsChange(event)`.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        handleSettingsChange(event) {
        }
        _applyPerformanceProfile(quality) {
          if (!this.config?.performanceProfiles) {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Performance profiles not found in config.`
            );
            return;
          }
          const profile = selectPerformanceProfile(
            quality,
            this.config.performanceProfiles,
            {
              trace: /* @__PURE__ */ __name((msg) => this.performanceMonitor?.emitTrace(msg), "trace")
            }
          );
          if (profile) {
            this.currentPerformanceProfile = profile;
            this.performanceMonitor?.emitTrace?.(
              `[BaseVisualSystem (${this.systemName})] Applied performance profile '${quality}'`,
              profile
            );
          } else {
            this.performanceMonitor?.emitTrace?.(
              `[${this.systemName}] Performance profile '${quality}' not found.`
            );
          }
        }
        getCosmicState() {
          if (typeof document === "undefined") return {};
          const root = document.documentElement;
          const style = getComputedStyle(root);
          return {
            energy: parseFloat(style.getPropertyValue("--sn-kinetic-energy")) || 0.5,
            valence: parseFloat(style.getPropertyValue("--sn-kinetic-valence")) || 0.5,
            bpm: parseFloat(style.getPropertyValue("--sn-kinetic-bpm")) || 120,
            tempoMultiplier: parseFloat(style.getPropertyValue("--sn-kinetic-tempo-multiplier")) || 1,
            beatPhase: parseFloat(style.getPropertyValue("--sn-kinetic-beat-phase")) || 0,
            beatPulse: parseFloat(style.getPropertyValue("--sn-kinetic-beat-pulse")) || 0
          };
        }
        /**
         * Create GPU-accelerated optimized canvas with kinetic styling.
         * This method prioritizes WebGL2 > 2D Canvas based on device capabilities.
         */
        async _createOptimizedKineticCanvas(id, zIndex = 5, blendMode = "screen", kineticMode = "pulse") {
          const existing = document.getElementById(id);
          if (existing) {
            existing.remove();
          }
          let preferredType = "2d";
          if (this.canvasCapabilities && this.currentPerformanceProfile) {
            const quality = this.currentPerformanceProfile.quality || "balanced";
            if (quality !== "low" && this.canvasCapabilities.webgl2) {
              preferredType = "webgl2";
            }
          }
          const canvasResult = await createOptimizedCanvas({
            id,
            width: window.innerWidth,
            height: window.innerHeight,
            alpha: true,
            antialias: true,
            preferredType
          });
          const canvas = canvasResult.canvas;
          canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: ${zIndex};
      pointer-events: none;
      mix-blend-mode: ${blendMode};
    `;
          canvas.classList.add("year3000-kinetic-canvas");
          canvas.dataset.kineticMode = kineticMode;
          canvas.dataset.systemName = this.systemName;
          canvas.dataset.canvasType = canvasResult.type;
          const kineticStyles = this._getKineticStyles(kineticMode);
          Object.assign(canvas.style, kineticStyles);
          document.body.appendChild(canvas);
          this.activeCanvasResults.set(id, canvasResult);
          this._resizeHandler = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (typeof this.handleResize === "function") {
              this.handleResize();
            }
          };
          window.addEventListener("resize", this._resizeHandler);
          this._resizeHandler();
          if (this.config.enableDebug) {
            console.log(
              `[BaseVisualSystem (${this.systemName})] Created optimized kinetic canvas: ${canvasResult.type} (mode: ${kineticMode})`
            );
          }
          return canvasResult;
        }
        /**
         * Get current canvas rendering capabilities.
         */
        getCanvasCapabilities() {
          return this.canvasCapabilities;
        }
        /**
         * Check if GPU acceleration is available and active.
         */
        hasGPUAcceleration() {
          return this.canvasCapabilities?.webgl2 || false;
        }
        _createKineticCanvas(id, zIndex = 5, blendMode = "screen", kineticMode = "pulse") {
          const canvas = this._createCanvasElement(id, zIndex, blendMode);
          canvas.classList.add("year3000-kinetic-canvas");
          canvas.dataset.kineticMode = kineticMode;
          canvas.dataset.systemName = this.systemName;
          const kineticStyles = this._getKineticStyles(kineticMode);
          Object.assign(canvas.style, kineticStyles);
          if (this.config.enableDebug) {
            console.log(
              `[BaseVisualSystem (${this.systemName})] Created kinetic canvas with mode: ${kineticMode}`
            );
          }
          return canvas;
        }
        _getKineticStyles(kineticMode) {
          const baseStyles = {
            transition: "all 150ms cubic-bezier(0.25, 0.46, 0.45, 0.94)"
          };
          switch (kineticMode) {
            case "pulse":
              return {
                ...baseStyles,
                animation: "year3000-pulse calc(var(--sn-kinetic-tempo-multiplier, 1) * 1s) ease-in-out infinite"
              };
            case "breathe":
              return {
                ...baseStyles,
                animation: "year3000-breathe calc(var(--sn-kinetic-tempo-multiplier, 1) * 4s) ease-in-out infinite"
              };
            case "flow":
              return {
                ...baseStyles,
                animation: "year3000-flow calc(var(--sn-kinetic-tempo-multiplier, 1) * 8s) linear infinite"
              };
            default:
              return baseStyles;
          }
        }
        _createCanvasElement(id, zIndex, blendMode) {
          const existing = document.getElementById(id);
          if (existing) {
            existing.remove();
          }
          const canvas = document.createElement("canvas");
          canvas.id = id;
          canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: ${zIndex};
      pointer-events: none;
      mix-blend-mode: ${blendMode};
    `;
          document.body.appendChild(canvas);
          this._resizeHandler = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (typeof this.handleResize === "function") {
              this.handleResize();
            }
          };
          window.addEventListener("resize", this._resizeHandler);
          this._resizeHandler();
          return canvas;
        }
        /**
         * Apply a fully-resolved PerformanceProfile coming from Year3000System.
         * Sub-systems may override this to adjust internal parameters (particle
         * counts, throttle values, etc.). The base implementation simply stores the
         * profile so dependants can query `currentPerformanceProfile`.
         */
        applyPerformanceSettings(profile) {
          this.currentPerformanceProfile = profile;
          if (profile.quality && typeof this._applyPerformanceProfile === "function") {
            this._applyPerformanceProfile?.(profile.quality);
          }
          if (this.config.enableDebug) {
            this.performanceMonitor?.emitTrace?.(
              `[BaseVisualSystem (${this.systemName})] Performance settings applied`,
              profile
            );
          }
        }
        /**
         * Centralised settings responder invoked by Year3000System.  The base
         * implementation simply adapts the parameters into a synthetic CustomEvent
         * so that legacy subclasses overriding `handleSettingsChange` continue to
         * work without modification.  Newer systems can override this directly for
         * efficiency.
         */
        applyUpdatedSettings(key, value) {
          const evt = new CustomEvent("year3000SystemSettingsChanged", {
            detail: { key, value }
          });
          try {
            this.handleSettingsChange(evt);
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn(
                `[BaseVisualSystem] ${this.systemName} applyUpdatedSettings error`,
                err
              );
            }
          }
        }
        // ---------------------------------------------------------------------------
        // SETTINGS-AWARE REPAINT CONTRACT
        // ---------------------------------------------------------------------------
        /**
         * IManagedSystem interface method for force repaint
         * Default no-op implementation. Subclasses that cache colours, shaders, or
         * other theme-dependent resources should override and perform a lightweight
         * refresh.
         */
        forceRepaint(reason) {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Force repaint requested: ${reason || "Unknown reason"}`);
          }
        }
      };
      __name(_BaseVisualSystem, "BaseVisualSystem");
      BaseVisualSystem = _BaseVisualSystem;
    }
  });

  // src-js/visual/music/integration/MusicEmotionAnalyzer.ts
  var _MusicEmotionAnalyzer, MusicEmotionAnalyzer, _ValenceEnergyMapper, ValenceEnergyMapper, _AudioFeatureAnalyzer, AudioFeatureAnalyzer, _TemperatureCalculator, TemperatureCalculator, _VisualEffectsDetector, VisualEffectsDetector;
  var init_MusicEmotionAnalyzer = __esm({
    "src-js/visual/music/integration/MusicEmotionAnalyzer.ts"() {
      "use strict";
      _MusicEmotionAnalyzer = class _MusicEmotionAnalyzer {
        constructor(config = {}) {
          this.initialized = false;
          this.emotionHistory = [];
          this.currentEmotion = null;
          this.emotionCache = /* @__PURE__ */ new Map();
          // Subscribers for emotion updates
          this.emotionSubscribers = /* @__PURE__ */ new Set();
          this.config = {
            emotionSensitivity: 0.7,
            confidenceThreshold: 0.6,
            smoothingFactor: 0.3,
            memoryDecay: 0.1,
            visualEffectsAwareness: true,
            smoothFlowDetection: true,
            cinematicAnalysis: true,
            analysisInterval: 500,
            // 2Hz analysis rate
            cacheSize: 100,
            ...config
          };
          this.valenceEnergyMapper = new ValenceEnergyMapper();
          this.audioFeatureAnalyzer = new AudioFeatureAnalyzer();
          this.temperatureCalculator = new TemperatureCalculator();
          this.visualEffectsDetector = new VisualEffectsDetector();
        }
        // ===== SYSTEM LIFECYCLE =====
        async initialize() {
          if (this.initialized) return;
          try {
            await this.valenceEnergyMapper.initialize();
            await this.audioFeatureAnalyzer.initialize();
            await this.temperatureCalculator.initialize();
            if (this.config.visualEffectsAwareness) {
              await this.visualEffectsDetector.initialize();
            }
            this.initialized = true;
            console.log(
              "\u{1F3B5} MusicEmotionAnalyzer initialized with visual effects awareness"
            );
          } catch (error) {
            console.error("\u274C Failed to initialize MusicEmotionAnalyzer:", error);
            throw error;
          }
        }
        updateAnimation(_deltaTime) {
        }
        async healthCheck() {
          const issues = [];
          if (!this.initialized) {
            issues.push("MusicEmotionAnalyzer not initialized");
          }
          if (this.emotionHistory.length === 0) {
            issues.push("No emotion analysis history available");
          }
          if (this.currentEmotion && this.currentEmotion.confidence < this.config.confidenceThreshold) {
            issues.push(
              `Low emotion confidence: ${this.currentEmotion.confidence.toFixed(2)}`
            );
          }
          return {
            healthy: issues.length === 0,
            issues,
            metrics: {
              emotionHistorySize: this.emotionHistory.length,
              currentConfidence: this.currentEmotion?.confidence ?? 0,
              subscriberCount: this.emotionSubscribers.size,
              cacheSize: this.emotionCache.size
            }
          };
        }
        destroy() {
          this.emotionSubscribers.clear();
          this.emotionHistory = [];
          this.emotionCache.clear();
          this.currentEmotion = null;
          this.initialized = false;
        }
        // ===== PUBLIC API =====
        /**
         * Analyze audio features and extract emotional state
         */
        async analyzeEmotion(audioFeatures, audioData) {
          if (!this.initialized) {
            throw new Error(
              "MusicEmotionAnalyzer must be initialized before analysis"
            );
          }
          try {
            const cacheKey = this.createCacheKey(audioFeatures);
            if (this.emotionCache.has(cacheKey)) {
              const cachedEmotion = this.emotionCache.get(cacheKey);
              if (cachedEmotion) {
                this.updateCurrentEmotion(cachedEmotion);
                return cachedEmotion;
              }
            }
            const emotion = await this.performEmotionAnalysis(
              audioFeatures,
              audioData
            );
            this.cacheEmotion(cacheKey, emotion);
            this.updateCurrentEmotion(emotion);
            this.notifyEmotionUpdate(emotion);
            return emotion;
          } catch (error) {
            console.error("\u274C Error analyzing emotion:", error);
            return this.createNeutralEmotion(audioFeatures);
          }
        }
        /**
         * Get current emotional state
         */
        getCurrentEmotion() {
          return this.currentEmotion;
        }
        /**
         * Get emotion analysis history
         */
        getEmotionHistory(limit) {
          if (limit) {
            return this.emotionHistory.slice(-limit);
          }
          return [...this.emotionHistory];
        }
        /**
         * Subscribe to emotion updates
         */
        onEmotionUpdate(callback) {
          this.emotionSubscribers.add(callback);
          return () => {
            this.emotionSubscribers.delete(callback);
          };
        }
        /**
         * Update analysis configuration
         */
        updateConfig(newConfig) {
          this.config = { ...this.config, ...newConfig };
        }
        // ===== PRIVATE ANALYSIS METHODS =====
        async performEmotionAnalysis(audioFeatures, audioData) {
          const musicalCharacteristics = this.audioFeatureAnalyzer.extractCharacteristics(audioFeatures);
          const baseEmotion = this.valenceEnergyMapper.mapToEmotion(
            audioFeatures.valence,
            audioFeatures.energy,
            musicalCharacteristics
          );
          const colorTemperature = this.temperatureCalculator.calculateTemperature(
            baseEmotion,
            musicalCharacteristics
          );
          let visualEffectsMetrics = {};
          if (this.config.visualEffectsAwareness) {
            visualEffectsMetrics = await this.visualEffectsDetector.analyze(
              audioFeatures,
              musicalCharacteristics,
              audioData
            );
          }
          const smoothedEmotion = this.applyTemporalSmoothing(
            baseEmotion,
            musicalCharacteristics
          );
          const emotionalState = {
            primary: smoothedEmotion.primary,
            secondary: smoothedEmotion.secondary,
            intensity: smoothedEmotion.intensity,
            confidence: smoothedEmotion.confidence,
            valence: audioFeatures.valence,
            arousal: audioFeatures.energy,
            dominance: this.calculateDominance(audioFeatures, musicalCharacteristics),
            colorTemperature,
            timestamp: Date.now(),
            duration: this.calculateEmotionDuration(
              smoothedEmotion,
              musicalCharacteristics
            ),
            musicalCharacteristics: {
              ...musicalCharacteristics,
              smoothFlow: visualEffectsMetrics.smoothFlow ?? musicalCharacteristics.smoothFlow,
              cinematicDepth: visualEffectsMetrics.cinematicDepth ?? musicalCharacteristics.cinematicDepth,
              visualEffectsResonance: visualEffectsMetrics.visualEffectsResonance ?? 0.5
            }
          };
          return emotionalState;
        }
        applyTemporalSmoothing(baseEmotion, musicalCharacteristics) {
          if (!this.currentEmotion || this.config.smoothingFactor === 0) {
            return baseEmotion;
          }
          const smoothingFactor = this.config.smoothingFactor;
          const smoothedIntensity = baseEmotion.intensity * (1 - smoothingFactor) + this.currentEmotion.intensity * smoothingFactor;
          const smoothedConfidence = baseEmotion.confidence * (1 - smoothingFactor) + this.currentEmotion.confidence * smoothingFactor;
          const primary = baseEmotion.confidence > this.config.confidenceThreshold ? baseEmotion.primary : this.currentEmotion.primary;
          return {
            primary,
            secondary: baseEmotion.secondary,
            intensity: smoothedIntensity,
            confidence: smoothedConfidence
          };
        }
        calculateDominance(audioFeatures, characteristics) {
          const tempoFactor = Math.min(characteristics.tempo / 140, 1);
          const energyFactor = audioFeatures.energy;
          const loudnessFactor = Math.min((audioFeatures.loudness + 60) / 60, 1);
          return tempoFactor * 0.3 + energyFactor * 0.4 + loudnessFactor * 0.3;
        }
        calculateEmotionDuration(emotion, characteristics) {
          const baseDuration = 2e3;
          const tempoMultiplier = 6e4 / characteristics.tempo;
          const stabilityMultiplier = emotion.confidence * 2;
          return Math.min(
            baseDuration * tempoMultiplier * stabilityMultiplier,
            1e4
          );
        }
        createCacheKey(audioFeatures) {
          const precision = 100;
          return [
            Math.round(audioFeatures.valence * precision),
            Math.round(audioFeatures.energy * precision),
            Math.round(audioFeatures.danceability * precision),
            Math.round(audioFeatures.acousticness * precision),
            audioFeatures.key,
            audioFeatures.mode
          ].join("-");
        }
        cacheEmotion(key, emotion) {
          if (this.emotionCache.size >= this.config.cacheSize) {
            const firstKey = this.emotionCache.keys().next().value;
            if (firstKey !== void 0) {
              this.emotionCache.delete(firstKey);
            }
          }
          this.emotionCache.set(key, emotion);
        }
        updateCurrentEmotion(emotion) {
          this.currentEmotion = emotion;
          this.emotionHistory.push(emotion);
          if (this.emotionHistory.length > 1e3) {
            this.emotionHistory = this.emotionHistory.slice(-500);
          }
        }
        notifyEmotionUpdate(emotion) {
          this.emotionSubscribers.forEach((callback) => {
            try {
              callback(emotion);
            } catch (error) {
              console.error("\u274C Error in emotion subscriber callback:", error);
            }
          });
        }
        createNeutralEmotion(audioFeatures) {
          return {
            primary: "serenity",
            secondary: [],
            intensity: 0.5,
            confidence: 0.3,
            valence: audioFeatures.valence ?? 0.5,
            arousal: audioFeatures.energy ?? 0.5,
            dominance: 0.5,
            colorTemperature: 6500,
            // Neutral daylight temperature
            timestamp: Date.now(),
            duration: 3e3,
            musicalCharacteristics: this.audioFeatureAnalyzer.extractCharacteristics(audioFeatures)
          };
        }
      };
      __name(_MusicEmotionAnalyzer, "MusicEmotionAnalyzer");
      MusicEmotionAnalyzer = _MusicEmotionAnalyzer;
      _ValenceEnergyMapper = class _ValenceEnergyMapper {
        async initialize() {
        }
        mapToEmotion(valence, energy, characteristics) {
          let primary;
          let secondary = [];
          let intensity;
          let confidence = 0.8;
          if (valence >= 0.6 && energy >= 0.6) {
            primary = characteristics.danceability > 0.7 ? "excitement" : "joy";
            secondary = ["joy", "excitement"];
            intensity = Math.min(valence + energy - 0.2, 1);
          } else if (valence >= 0.6 && energy < 0.4) {
            primary = characteristics.acousticness > 0.6 ? "serenity" : "love";
            secondary = ["serenity", "love"];
            intensity = valence * 0.8;
          } else if (valence < 0.4 && energy >= 0.6) {
            primary = characteristics.mode === 0 ? "anger" : "fear";
            secondary = ["anger", "fear"];
            intensity = energy;
          } else if (valence < 0.4 && energy < 0.4) {
            primary = characteristics.acousticness > 0.5 ? "melancholy" : "sadness";
            secondary = ["sadness", "melancholy"];
            intensity = (1 - valence) * 0.8;
          } else {
            if (characteristics.instrumentalness > 0.8) {
              primary = "transcendence";
              secondary = ["transcendence", "visual-effects"];
            } else {
              primary = "nostalgia";
              secondary = ["nostalgia"];
            }
            intensity = Math.abs(valence - 0.5) + Math.abs(energy - 0.5);
            confidence = 0.6;
          }
          if (characteristics.smoothFlow > 0.8) {
            secondary.push("smooth-flow");
          }
          if (characteristics.visualEffectsResonance > 0.7) {
            secondary.push("visual-effects");
          }
          return { primary, secondary, intensity, confidence };
        }
      };
      __name(_ValenceEnergyMapper, "ValenceEnergyMapper");
      ValenceEnergyMapper = _ValenceEnergyMapper;
      _AudioFeatureAnalyzer = class _AudioFeatureAnalyzer {
        async initialize() {
        }
        extractCharacteristics(audioFeatures) {
          return {
            tempo: audioFeatures.tempo,
            key: audioFeatures.key,
            mode: audioFeatures.mode,
            timeSignature: audioFeatures.timeSignature,
            energy: audioFeatures.energy,
            danceability: audioFeatures.danceability,
            acousticness: audioFeatures.acousticness,
            instrumentalness: audioFeatures.instrumentalness,
            liveness: audioFeatures.liveness,
            speechiness: audioFeatures.speechiness,
            // Calculate visual-effects-specific metrics
            smoothFlow: this.calculateSmoothFlow(audioFeatures),
            cinematicDepth: this.calculateCinematicDepth(audioFeatures),
            visualEffectsResonance: this.calculateVisualEffectsResonance(audioFeatures)
          };
        }
        calculateSmoothFlow(features) {
          const acousticWeight = features.acousticness * 0.4;
          const tempoWeight = (1 - Math.min(features.tempo / 140, 1)) * 0.3;
          const energyWeight = (1 - features.energy) * 0.2;
          const danceWeight = features.danceability * 0.1;
          return Math.min(
            acousticWeight + tempoWeight + energyWeight + danceWeight,
            1
          );
        }
        calculateCinematicDepth(features) {
          const instrumentalWeight = features.instrumentalness * 0.4;
          const liveWeight = (1 - features.liveness) * 0.2;
          const speechWeight = (1 - features.speechiness) * 0.2;
          const energyWeight = Math.abs(features.energy - 0.5) * 0.2;
          return Math.min(
            instrumentalWeight + liveWeight + speechWeight + energyWeight,
            1
          );
        }
        calculateVisualEffectsResonance(features) {
          const valenceBalance = 1 - Math.abs(features.valence - 0.5) * 2;
          const energyBalance = 1 - Math.abs(features.energy - 0.4) * 2;
          const instrumentalWeight = features.instrumentalness * 0.3;
          const acousticWeight = features.acousticness * 0.2;
          return Math.max(
            0,
            (valenceBalance + energyBalance) * 0.5 + instrumentalWeight + acousticWeight
          );
        }
      };
      __name(_AudioFeatureAnalyzer, "AudioFeatureAnalyzer");
      AudioFeatureAnalyzer = _AudioFeatureAnalyzer;
      _TemperatureCalculator = class _TemperatureCalculator {
        async initialize() {
        }
        calculateTemperature(emotion, characteristics) {
          let baseTemperature;
          switch (emotion.primary) {
            case "joy":
            case "excitement":
              baseTemperature = 8e3;
              break;
            case "love":
            case "serenity":
              baseTemperature = 3e3;
              break;
            case "anger":
              baseTemperature = 15e3;
              break;
            case "fear":
              baseTemperature = 12e3;
              break;
            case "sadness":
            case "melancholy":
              baseTemperature = 2e3;
              break;
            case "nostalgia":
              baseTemperature = 2500;
              break;
            case "transcendence":
            case "visual-effects":
              baseTemperature = 6500;
              break;
            case "smooth-flow":
              baseTemperature = 4e3;
              break;
            default:
              baseTemperature = 6500;
          }
          const intensityAdjustment = (emotion.intensity - 0.5) * 2e3;
          const tempoAdjustment = (characteristics.tempo - 120) * 10;
          const energyAdjustment = (characteristics.energy - 0.5) * 1e3;
          const finalTemperature = baseTemperature + intensityAdjustment + tempoAdjustment + energyAdjustment;
          return Math.max(1e3, Math.min(2e4, finalTemperature));
        }
      };
      __name(_TemperatureCalculator, "TemperatureCalculator");
      TemperatureCalculator = _TemperatureCalculator;
      _VisualEffectsDetector = class _VisualEffectsDetector {
        async initialize() {
        }
        async analyze(audioFeatures, characteristics, audioData) {
          let smoothFlow = characteristics.smoothFlow;
          let cinematicDepth = characteristics.cinematicDepth;
          let visualEffectsResonance = characteristics.visualEffectsResonance;
          if (audioData?.waveform) {
            const waveformAnalysis = this.analyzeWaveformPatterns(audioData.waveform);
            smoothFlow = Math.min(
              1,
              smoothFlow + waveformAnalysis.smoothness * 0.2
            );
            cinematicDepth = Math.min(
              1,
              cinematicDepth + waveformAnalysis.dynamicRange * 0.3
            );
            visualEffectsResonance = Math.min(
              1,
              visualEffectsResonance + waveformAnalysis.harmonicComplexity * 0.2
            );
          }
          return {
            smoothFlow,
            cinematicDepth,
            visualEffectsResonance
          };
        }
        analyzeWaveformPatterns(waveform) {
          let smoothness = 0;
          let dynamicRange = 0;
          let harmonicComplexity = 0;
          if (waveform.length > 1) {
            let totalVariation = 0;
            for (let i = 1; i < waveform.length; i++) {
              const current = waveform[i];
              const previous = waveform[i - 1];
              if (current !== void 0 && previous !== void 0) {
                totalVariation += Math.abs(current - previous);
              }
            }
            smoothness = 1 - Math.min(totalVariation / waveform.length, 1);
            const max = Math.max(...waveform);
            const min = Math.min(...waveform);
            dynamicRange = max - min;
            harmonicComplexity = Math.min(this.estimateHarmonicContent(waveform), 1);
          }
          return { smoothness, dynamicRange, harmonicComplexity };
        }
        estimateHarmonicContent(waveform) {
          let zeroCrossings = 0;
          for (let i = 1; i < waveform.length; i++) {
            const current = waveform[i];
            const previous = waveform[i - 1];
            if (current !== void 0 && previous !== void 0) {
              if (current >= 0 !== previous >= 0) {
                zeroCrossings++;
              }
            }
          }
          return Math.min(zeroCrossings / (waveform.length * 0.1), 1);
        }
      };
      __name(_VisualEffectsDetector, "VisualEffectsDetector");
      VisualEffectsDetector = _VisualEffectsDetector;
    }
  });

  // src-js/audio/ColorHarmonyEngine.ts
  var _ColorHarmonyEngine, ColorHarmonyEngine;
  var init_ColorHarmonyEngine = __esm({
    "src-js/audio/ColorHarmonyEngine.ts"() {
      "use strict";
      init_settingKeys();
      init_GenreProfileManager();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      init_PaletteSystemManager();
      init_PaletteExtensionManager();
      init_ThemeUtilities();
      init_SemanticColorManager();
      init_BaseVisualSystem();
      init_MusicEmotionAnalyzer();
      _ColorHarmonyEngine = class _ColorHarmonyEngine extends BaseVisualSystem {
        constructor(config, utils, performanceMonitor, settingsManager2) {
          super(
            config,
            utils || ThemeUtilities_exports,
            performanceMonitor,
            null,
            // No direct music service dependency
            settingsManager2 || null
          );
          this.animationEngine = null;
          // User-specified color harmony intensity (0-1). Multiplies defaultBlendRatio.
          this.userIntensity = 0.7;
          this.evolutionEnabled = true;
          this._evolutionTimer = null;
          // Timer ref for debounce
          this._pendingPaletteRefresh = null;
          // Track last applied genre to avoid redundant palette refreshes
          this._lastGenre = null;
          this.systemName = "ColorHarmonyEngine";
          this.paletteExtensionManager = new PaletteExtensionManager(
            this.config,
            this.utils
          );
          this.semanticColorManager = new SemanticColorManager({
            enableDebug: this.config.enableDebug,
            fallbackToSpiceColors: true,
            cacheDuration: 5e3
          });
          this.currentTheme = this.detectCurrentTheme();
          const extendedConfig = config;
          if (extendedConfig && typeof extendedConfig.colorHarmonyIntensity === "number" && Number.isFinite(extendedConfig.colorHarmonyIntensity)) {
            const clamped = Math.max(
              0,
              Math.min(1, extendedConfig.colorHarmonyIntensity)
            );
            this.userIntensity = clamped;
          }
          this.harmonyMetrics = {
            totalHarmonyCalculations: 0,
            musicInfluencedAdjustments: 0,
            temporalMemoryEvents: 0,
            performance: []
          };
          this.musicalMemory = {
            recentTracks: [],
            userColorPreferences: /* @__PURE__ */ new Map(),
            energyHistory: [],
            maxMemorySize: 50
          };
          this.kineticState = {
            currentPulse: 0,
            animationPhase: 0,
            lastBeatTime: 0,
            visualMomentum: 0
          };
          this.catppuccinPalettes = {
            frappe: {
              accents: {
                rosewater: "#f2d5cf",
                flamingo: "#eebebe",
                pink: "#ff6b9d",
                // Enhanced magenta for gradient drama
                mauve: "#c77dff",
                // Intensified purple for depth
                red: "#ff4757",
                // Vivid red for cinematic contrast
                maroon: "#ea999c",
                peach: "#ff7675",
                // Warmer orange for gradient flows
                yellow: "#fdcb6e",
                // Golden yellow for luminance
                green: "#6c5ce7",
                // Purple-blue for unique gradients
                teal: "#00cec9",
                // Cyan for electric contrast
                sky: "#74b9ff",
                // Bright blue for sky gradients
                sapphire: "#0984e3",
                // Deep blue for depth
                blue: "#a29bfe",
                // Lavender-blue for softness
                lavender: "#fd79a8"
                // Pink-lavender for warmth
              },
              neutrals: {
                base: "#303446",
                surface0: "#414559",
                surface1: "#51576d",
                surface2: "#626880"
              }
            },
            latte: {
              accents: {
                rosewater: "#dc8a78",
                flamingo: "#dd7878",
                pink: "#e84393",
                // Vibrant magenta for light theme gradients
                mauve: "#a55eea",
                // Rich purple for contrast
                red: "#fd79a8",
                // Warm red-pink for luminous gradients
                maroon: "#e64553",
                peach: "#fd7f28",
                // Bright orange for warmth
                yellow: "#f39c12",
                // Golden amber for energy
                green: "#00b894",
                // Teal-green for balance
                teal: "#00cec9",
                // Cyan for freshness
                sky: "#0984e3",
                // Deep sky blue
                sapphire: "#6c5ce7",
                // Purple-blue for depth
                blue: "#74b9ff",
                // Light blue for airiness
                lavender: "#a29bfe"
                // Soft lavender for gentleness
              },
              neutrals: {
                base: "#eff1f5",
                surface0: "#e6e9ef",
                surface1: "#dce0e8",
                surface2: "#c5c9d1"
              }
            },
            macchiato: {
              accents: {
                rosewater: "#f4dbd6",
                flamingo: "#f0c6c6",
                pink: "#ff6b9d",
                // Enhanced magenta for gradient drama
                mauve: "#c77dff",
                // Intensified purple for depth
                red: "#ff4757",
                // Vivid red for cinematic contrast
                maroon: "#ee99a0",
                peach: "#ff7675",
                // Warmer orange for gradient flows
                yellow: "#fdcb6e",
                // Golden yellow for luminance
                green: "#6c5ce7",
                // Purple-blue for unique gradients
                teal: "#00cec9",
                // Cyan for electric contrast
                sky: "#74b9ff",
                // Bright blue for sky gradients
                sapphire: "#0984e3",
                // Deep blue for depth
                blue: "#a29bfe",
                // Lavender-blue for softness
                lavender: "#fd79a8"
                // Pink-lavender for warmth
              },
              neutrals: {
                base: "#24273a",
                surface0: "#363a4f",
                surface1: "#494d64",
                surface2: "#5b6078"
              }
            },
            mocha: {
              accents: {
                rosewater: "#f5e0dc",
                flamingo: "#f2cdcd",
                pink: "#ff6b9d",
                // Enhanced magenta for gradient drama
                mauve: "#c77dff",
                // Intensified purple for depth
                red: "#ff4757",
                // Vivid red for cinematic contrast
                maroon: "#eba0ac",
                peach: "#ff7675",
                // Warmer orange for gradient flows
                yellow: "#fdcb6e",
                // Golden yellow for luminance
                green: "#6c5ce7",
                // Purple-blue for unique gradients
                teal: "#00cec9",
                // Cyan for electric contrast
                sky: "#74b9ff",
                // Bright blue for sky gradients
                sapphire: "#0984e3",
                // Deep blue for depth
                blue: "#a29bfe",
                // Lavender-blue for softness
                lavender: "#fd79a8"
                // Pink-lavender for warmth
              },
              neutrals: {
                base: "#1e1e2e",
                surface0: "#313244",
                surface1: "#45475a",
                surface2: "#585b70"
              }
            }
          };
          this.vibrancyConfig = {
            defaultBlendRatio: 0.75,
            // Dramatic extracted color dominance for cinematic gradients
            minimumSaturation: 0.6,
            // High saturation for vibrant gradient aesthetics
            maximumDesaturation: 0.1,
            // Minimal desaturation to maintain intensity
            contrastBoostIntensity: 1.4,
            // Enhanced contrast for dramatic depth
            harmonyTolerance: 0.3,
            // Tighter harmony for cohesive gradient flows
            // 🎨 Cinematic Gradient Enhancement Factors
            artisticSaturationBoost: 1.35,
            // Strong saturation for vibrant gradient aesthetics
            enhancedLuminanceBoost: 1.25,
            // Enhanced luminance for gradient depth
            energyResponsiveness: 0.8,
            // High energy responsiveness for dynamic gradients
            // 🌟 Cinematic Gradient Blending Based on Artistic Mode
            getBlendRatio(artisticMode = "artist-vision") {
              const ratios = {
                "corporate-safe": 0.6,
                // Moderate: 60% extracted for professional gradients
                "artist-vision": 0.75,
                // Cinematic: 75% extracted for balanced drama
                "advanced-maximum": 0.85,
                // Maximum: 85% extracted for full intensity!
                "cosmic-maximum": 0.85
                // Legacy alias - Maximum: 85% extracted for full intensity!
              };
              return ratios[artisticMode] || this.defaultBlendRatio;
            }
          };
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Initialized with Year 3000 Quantum Empathy"
            );
          }
          if (config && typeof config.colorHarmonyEvolution === "boolean") {
            this.evolutionEnabled = config.colorHarmonyEvolution;
          } else if (config && typeof config.harmonicEvolution === "boolean") {
            this.evolutionEnabled = config.harmonicEvolution;
          }
          this.emotionalTemperatureMapper = new EmotionalTemperatureMapper(
            this.config.enableDebug
          );
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.musicEmotionAnalyzer = new MusicEmotionAnalyzer({
            emotionSensitivity: 0.7,
            confidenceThreshold: 0.6,
            visualEffectsAwareness: true,
            smoothFlowDetection: true,
            cinematicAnalysis: true,
            analysisInterval: 500
            // 2Hz analysis rate
          });
          this.genreProfileManager = new GenreProfileManager();
          this.oklabState = {
            currentPreset: OKLABColorProcessor.PRESETS.STANDARD,
            processedPalette: {},
            perceptualGradientCache: /* @__PURE__ */ new Map(),
            colorHarmonyCache: /* @__PURE__ */ new Map(),
            lastProcessingTime: 0,
            colorVariationCache: /* @__PURE__ */ new Map()
          };
          this.emotionalState = {
            currentEmotion: null,
            emotionHistory: [],
            lastEmotionUpdate: 0,
            emotionInfluenceIntensity: 0.8
            // Strong emotion influence by default
          };
          this.genreState = {
            currentGenre: "unknown",
            genreConfidence: 0,
            genreHistory: [],
            lastGenreUpdate: 0,
            genreInfluenceIntensity: 0.7
            // Moderate genre influence by default
          };
          this._boundSettingsChangeHandler = this._handleSettingsChange.bind(this);
          this._boundArtisticModeHandler = this._handleArtisticModeChanged.bind(this);
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this._boundSettingsChangeHandler
          );
          document.addEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          if (this.evolutionEnabled) {
            this._startEvolutionLoop();
          }
        }
        /**
         * Get current active palette from PaletteSystemManager
         * Falls back to hardcoded catppuccinPalettes for compatibility
         */
        getCurrentActivePalette() {
          try {
            const paletteSystem = paletteSystemManager.getCurrentPaletteSystem();
            if (paletteSystem === "year3000") {
              const year3000Palette = paletteSystemManager.getCurrentPalette();
              const currentFlavor = paletteSystemManager.getCurrentDefaultFlavor();
              const activePalette = year3000Palette[currentFlavor];
              if (!activePalette) {
                throw new Error(`No palette found for flavor: ${currentFlavor}`);
              }
              const accents = {};
              const neutrals = {};
              Object.entries(activePalette).forEach(([key, color3]) => {
                if (["base", "surface0", "surface1", "surface2", "mantle", "crust"].includes(key)) {
                  neutrals[key] = color3.hex;
                } else {
                  accents[key] = color3.hex;
                }
              });
              return { accents, neutrals };
            } else {
              return this.catppuccinPalettes[this.currentTheme];
            }
          } catch (error) {
            console.warn("[ColorHarmonyEngine] Failed to get active palette, using fallback:", error);
            return this.catppuccinPalettes[this.currentTheme];
          }
        }
        // Unified implementation
        updateAnimation(timestampOrDelta, maybeDelta) {
          const delta = maybeDelta ?? timestampOrDelta;
          this.onAnimate(delta);
        }
        // TODO: Implement proper onAnimate method for Year 3000 per-frame updates
        onAnimate(deltaMs) {
          this._updateCSSVariables(deltaMs);
          this._calculateBeatPulse(deltaMs);
          unifiedEventBus.emitSync("performance:frame", {
            deltaTime: deltaMs,
            fps: 60,
            memoryUsage: performance.memory?.usedJSHeapSize || 0,
            timestamp: performance.now()
          });
        }
        // 🔧 PHASE 2: Emit harmony state instead of applying CSS directly
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _updateCSSVariables(_deltaMs) {
          const harmonyVariables = {
            "--sn-harmony-energy": this.kineticState.visualMomentum.toFixed(3),
            "--sn-harmony-pulse": this.kineticState.currentPulse.toFixed(3),
            "--sn-harmony-animation-phase": (Math.sin(this.kineticState.animationPhase) * 0.5 + 0.5).toFixed(3)
          };
          if (this.kineticState.musicIntensityMultiplier !== void 0) {
            harmonyVariables["--sn-harmony-intensity"] = this.kineticState.musicIntensityMultiplier.toFixed(3);
          }
          if (this.kineticState.valenceGravity !== void 0) {
            harmonyVariables["--sn-harmony-valence"] = this.kineticState.valenceGravity.toFixed(3);
          }
          if (this.kineticState.beatPhase !== void 0) {
            harmonyVariables["--sn-harmony-beat-phase"] = this.kineticState.beatPhase.toFixed(3);
          }
          if (this.kineticState.hueShift !== void 0) {
            harmonyVariables["--sn-harmony-hue-shift"] = `${this.kineticState.hueShift.toFixed(1)}deg`;
          }
          const glow = Math.max(0, Math.min(1, this.kineticState.currentPulse * 1.2));
          harmonyVariables["--sn-text-glow-intensity"] = glow.toFixed(3);
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: harmonyVariables,
            timestamp: Date.now()
          });
        }
        // TODO: Private method for calculating beat pulse effects
        _calculateBeatPulse(deltaMs) {
          this.kineticState.currentPulse *= Math.pow(0.95, deltaMs / 16.67);
          this.kineticState.animationPhase += deltaMs / 1e3 * 0.5;
          if (this.kineticState.animationPhase > 2 * Math.PI) {
            this.kineticState.animationPhase -= 2 * Math.PI;
          }
          this._emitGradientAnimationEvents(deltaMs);
        }
        /**
         * Emit gradient animation events for dimensional audioAnalysis integration
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _emitGradientAnimationEvents(_deltaMs) {
          const currentEnergy = this._calculateCurrentEnergyLevel();
          const beatDetected = this._detectBeatFromAudioAnalysis();
          if (Math.random() < 0.1) {
            unifiedEventBus.emit("music:energy", {
              energy: currentEnergy.energy,
              valence: currentEnergy.valence,
              tempo: 120,
              timestamp: performance.now()
            });
          }
          if (beatDetected.detected) {
            unifiedEventBus.emit("music:beat", {
              intensity: beatDetected.intensity,
              confidence: beatDetected.confidence,
              timestamp: performance.now(),
              bpm: 120
              // Default BPM value
            });
          }
        }
        /**
         * Calculate current energy level from music analysis data
         */
        _calculateCurrentEnergyLevel() {
          const animationEnergy = 0.5 + Math.sin(this.kineticState.animationPhase) * 0.3;
          return {
            energy: Math.max(0.2, animationEnergy),
            valence: 0.5 + this.kineticState.currentPulse * 0.3,
            arousal: 0.4 + this.kineticState.currentPulse * 0.4
          };
        }
        /**
         * Detect beats from current audio analysis for gradient animation
         */
        _detectBeatFromAudioAnalysis() {
          const pulseThreshold = 0.3;
          const currentPulse = this.kineticState.currentPulse;
          if (currentPulse > pulseThreshold) {
            return {
              detected: true,
              intensity: Math.min(1, currentPulse * 1.5),
              confidence: Math.min(
                1,
                (currentPulse - pulseThreshold) / (1 - pulseThreshold)
              )
            };
          }
          const animationBeat = Math.sin(this.kineticState.animationPhase) > 0.8;
          if (animationBeat) {
            return {
              detected: true,
              intensity: 0.4,
              confidence: 0.6
            };
          }
          return { detected: false, intensity: 0, confidence: 0 };
        }
        async initialize() {
          await super.initialize();
          const cssVisualEffectsController = this.performanceMonitor ? this.performanceMonitor.cssVisualEffectsController : void 0;
          this.semanticColorManager.initialize(cssVisualEffectsController);
          unifiedEventBus.subscribe(
            "colors:extracted",
            this.handleColorExtraction.bind(this),
            "ColorHarmonyEngine"
          );
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Initialized as independent OKLAB color processor."
            );
          }
          try {
            await this.musicEmotionAnalyzer.initialize();
            this.musicEmotionAnalyzer.onEmotionUpdate((emotion) => {
              this.handleEmotionUpdate(emotion);
            });
            if (this.config.enableDebug) {
              console.log(
                "\u{1F3AD} [ColorHarmonyEngine] MusicEmotionAnalyzer initialized with audioAnalysis awareness"
              );
            }
          } catch (error) {
            console.warn(
              "\u{1F3AD} [ColorHarmonyEngine] Failed to initialize MusicEmotionAnalyzer:",
              error
            );
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3B6} [ColorHarmonyEngine] GenreProfileManager ready for genre detection"
            );
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Initialized with Year 3000 Quantum Empathy via BaseVisualSystem and SemanticColorManager."
            );
            console.log(
              "\u{1F3A8} [ColorHarmonyEngine] Subscribed to 'colors/extracted' events for strategy pattern processing."
            );
          }
          this.initialized = true;
        }
        /**
         * Handle emotion updates from MusicEmotionAnalyzer
         * Updates emotional state and triggers audioAnalysis-aware color processing
         */
        handleEmotionUpdate(emotion) {
          if (!this.initialized) return;
          try {
            this.emotionalState.currentEmotion = emotion;
            this.emotionalState.emotionHistory.push(emotion);
            this.emotionalState.lastEmotionUpdate = Date.now();
            if (this.emotionalState.emotionHistory.length > 50) {
              this.emotionalState.emotionHistory = this.emotionalState.emotionHistory.slice(-25);
            }
            unifiedEventBus.emit("music:emotion-analyzed", {
              emotion,
              colorTemperature: emotion.colorTemperature,
              visualEffectsLevel: emotion.musicalCharacteristics.visualEffectsResonance,
              smoothFlow: emotion.musicalCharacteristics.smoothFlow,
              cinematicDepth: emotion.musicalCharacteristics.cinematicDepth,
              timestamp: emotion.timestamp
            });
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3AD} [ColorHarmonyEngine] Emotion updated: ${emotion.primary} (intensity: ${emotion.intensity.toFixed(
                  2
                )}, confidence: ${emotion.confidence.toFixed(2)})`
              );
            }
            this.triggerEmotionalColorUpdate(emotion);
          } catch (error) {
            console.error(
              "\u{1F3AD} [ColorHarmonyEngine] Error handling emotion update:",
              error
            );
          }
        }
        /**
         * Trigger color update based on emotional state
         */
        triggerEmotionalColorUpdate(emotion) {
          if (this.emotionalState.emotionInfluenceIntensity > 0 && emotion.confidence > 0.6) {
            if (this._pendingPaletteRefresh) {
              clearTimeout(this._pendingPaletteRefresh);
            }
            this._pendingPaletteRefresh = setTimeout(() => {
              this.refreshPaletteWithEmotion(emotion);
              this._pendingPaletteRefresh = null;
            }, 100);
          }
        }
        /**
         * Refresh palette with emotional influence
         */
        async refreshPaletteWithEmotion(emotion) {
          try {
            const emotionalContext = {
              primaryEmotion: emotion.primary,
              emotionIntensity: emotion.intensity,
              colorTemperature: emotion.colorTemperature,
              valence: emotion.valence,
              arousal: emotion.arousal,
              dominance: emotion.dominance,
              smoothFlow: emotion.musicalCharacteristics.smoothFlow,
              cinematicDepth: emotion.musicalCharacteristics.cinematicDepth,
              visualEffectsResonance: emotion.musicalCharacteristics.visualEffectsResonance
            };
            unifiedEventBus.emit("music:emotional-context-updated", emotionalContext);
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3AD} [ColorHarmonyEngine] Refreshing colors with ${emotion.primary} emotion influence`
              );
            }
          } catch (error) {
            console.error(
              "\u{1F3AD} [ColorHarmonyEngine] Error refreshing palette with emotion:",
              error
            );
          }
        }
        async healthCheck() {
          if (!this.getCurrentActivePalette()) {
            return {
              healthy: false,
              ok: false,
              details: `Current theme '${this.currentTheme}' not found in palettes.`,
              issues: [`Current theme '${this.currentTheme}' not found in palettes.`],
              system: "ColorHarmonyEngine"
            };
          }
          return {
            healthy: true,
            ok: true,
            details: "Palettes are loaded correctly.",
            issues: [],
            system: "ColorHarmonyEngine"
          };
        }
        // ============================================================================
        // IColorProcessor Strategy Pattern Implementation
        // ============================================================================
        /**
         * Process colors according to Catppuccin harmony strategy with enhanced OKLAB integration
         * Implements the Strategy pattern for color processing with comprehensive system utilization
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const { rawColors, trackUri, musicData } = context;
            const optimalPreset = this.determineOptimalOKLABPreset(context);
            this.oklabState.currentPreset = optimalPreset;
            const genreData = await this.analyzeGenreAesthetics(musicData, rawColors);
            const emotionalTemperature = await this.getAdvancedEmotionalTemperature(
              musicData,
              rawColors
            );
            const processedColors = await this.blendWithAdvancedOKLAB(
              rawColors,
              musicData,
              emotionalTemperature,
              genreData || void 0
            );
            const accentHex = processedColors["VIBRANT"] || processedColors["PROMINENT"] || Object.values(processedColors)[0] || "#a6adc8";
            const rgb = this.utils.hexToRgb(accentHex);
            const accentRgb = rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "166,173,200";
            try {
              const harmonizedEventData = {
                processedColors,
                accentHex,
                accentRgb,
                originalColors: rawColors,
                trackUri,
                musicData,
                timestamp: Date.now(),
                strategies: ["ColorHarmonyEngine"],
                processingTime: performance.now() - startTime,
                coordinationMetrics: {
                  detectedGenre: genreData?.genre || "unknown",
                  genreConfidence: genreData?.confidence || 0,
                  emotionalState: this.emotionalState.currentEmotion?.primary || "neutral",
                  oklabPreset: optimalPreset?.name || "standard",
                  coordinationStrategy: "genre-emotion-color-unified",
                  musicInfluenceStrength: this.genreState.genreInfluenceIntensity
                }
              };
              unifiedEventBus.emitSync("colors:harmonized", harmonizedEventData);
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F3A8} [ColorHarmonyEngine] Emitted colors:harmonized via UnifiedEventBus (facade pattern):",
                  {
                    processedColors: Object.keys(processedColors),
                    accentHex,
                    noDomEvents: "correct architecture"
                  }
                );
              }
            } catch (eventError) {
              if (this.config.enableDebug) {
                console.warn(
                  "[ColorHarmonyEngine] Failed to emit colors:harmonized event:",
                  eventError
                );
              }
            }
            const processingTime = performance.now() - startTime;
            this.harmonyMetrics.totalHarmonyCalculations++;
            this.harmonyMetrics.performance.push(processingTime);
            const result = {
              processedColors,
              accentHex,
              accentRgb,
              metadata: {
                strategy: "CatppuccinHarmony",
                processingTime,
                cacheKey: `catppuccin-${trackUri}-${this.currentTheme}`,
                colorHarmonyIntensity: this.userIntensity
              },
              context
            };
            const cssVariables = this.generateAdvancedOKLABCSSVariables(result);
            const colorVariations = this.generateColorVariations(result);
            Object.assign(cssVariables, colorVariations);
            this.applyCSSVariablesToDOM(cssVariables);
            this.generatePerceptualGradientData(result);
            this.updateAdvancedHarmonyMetrics(result, processingTime);
            unifiedEventBus.emitSync("colors:harmonized", {
              processedColors: result.processedColors,
              accentHex: result.accentHex,
              accentRgb: result.accentRgb,
              strategies: result.metadata?.strategy ? [result.metadata.strategy] : ["ColorHarmonyEngine"],
              processingTime,
              trackUri: result.context.trackUri
            });
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3A8} [ColorHarmonyEngine] Processed colors via strategy pattern in ${processingTime.toFixed(
                  2
                )}ms`,
                {
                  accentHex,
                  strategy: "CatppuccinHarmony",
                  cssVariablesCount: Object.keys(cssVariables).length
                }
              );
            }
            return result;
          } catch (error) {
            console.error("[ColorHarmonyEngine] Strategy processing failed:", error);
            return {
              processedColors: { VIBRANT: "#a6adc8" },
              accentHex: "#a6adc8",
              accentRgb: "166,173,200",
              metadata: {
                strategy: "CatppuccinHarmony",
                processingTime: performance.now() - startTime,
                error: String(error)
              },
              context
            };
          }
        }
        /**
         * Get strategy name for identification
         */
        getStrategyName() {
          return "CatppuccinHarmony";
        }
        /**
         * Check if this strategy can process the given context
         */
        canProcess(context) {
          return context && context.rawColors && Object.keys(context.rawColors).length > 0;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          const baseTime = 5;
          const colorCount = Object.keys(context.rawColors || {}).length;
          const complexityFactor = Math.max(1, colorCount / 5);
          return baseTime * complexityFactor;
        }
        /**
         * Handle color extraction events from unifiedEventBus
         * Event-driven entry point for strategy pattern
         */
        async handleColorExtraction(data) {
          try {
            if (!this.initialized) {
              if (this.config.enableDebug) {
                console.warn(
                  "[ColorHarmonyEngine] Received color extraction event but not initialized"
                );
              }
              return;
            }
            const context = {
              rawColors: data.rawColors,
              trackUri: data.trackUri,
              timestamp: data.timestamp,
              colorHarmonyMode: this.currentTheme,
              harmonicMode: this.currentTheme,
              // Legacy compatibility
              musicData: data.musicData,
              performanceHints: {
                preferLightweight: false,
                enableAdvancedBlending: true,
                maxProcessingTime: 100
              }
            };
            if (this.canProcess(context)) {
              await this.processColors(context);
            } else {
              if (this.config.enableDebug) {
                console.warn(
                  "[ColorHarmonyEngine] Cannot process color context:",
                  context
                );
              }
            }
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Error handling color extraction event:",
              error
            );
          }
        }
        /**
         * Generate CSS variables from color result
         */
        generateCSSVariables(result) {
          const cssVars = {};
          cssVars["--sn-accent-hex"] = result.accentHex;
          cssVars["--sn-accent-rgb"] = result.accentRgb;
          cssVars[_ColorHarmonyEngine.CANONICAL_HEX_VAR] = result.accentHex;
          cssVars[_ColorHarmonyEngine.CANONICAL_RGB_VAR] = result.accentRgb;
          const processedColors = result.processedColors;
          const primaryColor = processedColors["VIBRANT"] || processedColors["PROMINENT"] || result.accentHex;
          const secondaryColor = processedColors["DARK_VIBRANT"] || processedColors["DESATURATED"] || primaryColor;
          const accentColor = processedColors["VIBRANT_NON_ALARMING"] || processedColors["LIGHT_VIBRANT"] || primaryColor;
          cssVars["--sn-bg-gradient-primary"] = primaryColor;
          cssVars["--sn-bg-gradient-secondary"] = secondaryColor;
          cssVars["--sn-bg-gradient-accent"] = accentColor;
          const primaryRgb = this.utils.hexToRgb(primaryColor);
          const secondaryRgb = this.utils.hexToRgb(secondaryColor);
          const accentRgb = this.utils.hexToRgb(accentColor);
          if (primaryRgb) {
            cssVars["--sn-bg-gradient-primary-rgb"] = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          }
          if (secondaryRgb) {
            cssVars["--sn-bg-gradient-secondary-rgb"] = `${secondaryRgb.r},${secondaryRgb.g},${secondaryRgb.b}`;
          }
          if (accentRgb) {
            cssVars["--sn-bg-gradient-accent-rgb"] = `${accentRgb.r},${accentRgb.g},${accentRgb.b}`;
          }
          this.generateOKLABVariables(cssVars, result);
          if (this.config.enableDebug) {
            console.log(
              "\u{1F527} [ColorHarmonyEngine] Generated background gradient CSS variables:",
              {
                primary: `${primaryColor} -> ${cssVars["--sn-bg-gradient-primary-rgb"]}`,
                secondary: `${secondaryColor} -> ${cssVars["--sn-bg-gradient-secondary-rgb"]}`,
                accent: `${accentColor} -> ${cssVars["--sn-bg-gradient-accent-rgb"]}`,
                totalVariables: Object.keys(cssVars).length,
                note: "CSS mapping automatically updates --sn-gradient-* variables"
              }
            );
          }
          return cssVars;
        }
        /**
         * Generate OKLAB-processed CSS variables for perceptual color processing
         */
        generateOKLABVariables(cssVars, result) {
          try {
            const primaryHex = result.accentHex;
            const processedColors = result.processedColors;
            const secondaryHex = processedColors["DARK_VIBRANT"] || processedColors["DESATURATED"] || primaryHex;
            const primaryRgb = this.utils.hexToRgb(primaryHex);
            const secondaryRgb = this.utils.hexToRgb(secondaryHex);
            if (primaryRgb) {
              const oklabPrimary = this.utils.rgbToOklab(
                primaryRgb.r,
                primaryRgb.g,
                primaryRgb.b
              );
              const enhancedOklab = {
                L: Math.min(1, oklabPrimary.L * 1.1),
                // Slight lightness boost
                a: oklabPrimary.a * 1.15,
                // Enhanced chroma for vibrancy
                b: oklabPrimary.b * 1.15
              };
              const enhancedRgb = this.utils.oklabToRgb(
                enhancedOklab.L,
                enhancedOklab.a,
                enhancedOklab.b
              );
              cssVars["--sn-color-oklab-bright-highlight-rgb"] = `${enhancedRgb.r},${enhancedRgb.g},${enhancedRgb.b}`;
              cssVars["--sn-color-oklab-primary-r"] = Math.round(
                enhancedRgb.r
              ).toString();
              cssVars["--sn-color-oklab-primary-g"] = Math.round(
                enhancedRgb.g
              ).toString();
              cssVars["--sn-color-oklab-primary-b"] = Math.round(
                enhancedRgb.b
              ).toString();
              cssVars["--sn-color-oklab-accent-r"] = Math.round(
                enhancedRgb.r
              ).toString();
              cssVars["--sn-color-oklab-accent-g"] = Math.round(
                enhancedRgb.g
              ).toString();
              cssVars["--sn-color-oklab-accent-b"] = Math.round(
                enhancedRgb.b
              ).toString();
              cssVars["--sn-color-oklab-accent-luminance"] = enhancedOklab.L.toFixed(3);
              const oklch = this.convertOklabToOklch(enhancedOklab);
              cssVars["--sn-color-oklch-accent-l"] = oklch.L.toFixed(3);
              cssVars["--sn-color-oklch-accent-c"] = oklch.C.toFixed(3);
              cssVars["--sn-color-oklch-accent-h"] = oklch.H.toFixed(1);
              cssVars["--sn-color-oklch-primary-l"] = oklch.L.toFixed(3);
              cssVars["--sn-color-oklch-primary-c"] = oklch.C.toFixed(3);
              cssVars["--sn-color-oklch-primary-h"] = oklch.H.toFixed(1);
            }
            if (secondaryRgb) {
              const oklabSecondary = this.utils.rgbToOklab(
                secondaryRgb.r,
                secondaryRgb.g,
                secondaryRgb.b
              );
              const shadowOklab = {
                L: Math.max(0.05, oklabSecondary.L * 0.3),
                // Much darker for shadow
                a: oklabSecondary.a * 0.8,
                // Slightly desaturated
                b: oklabSecondary.b * 0.8
              };
              const shadowRgb = this.utils.oklabToRgb(
                shadowOklab.L,
                shadowOklab.a,
                shadowOklab.b
              );
              cssVars["--sn-color-oklab-dynamic-shadow-rgb"] = `${shadowRgb.r},${shadowRgb.g},${shadowRgb.b}`;
              cssVars["--sn-color-oklab-base-luminance"] = shadowOklab.L.toFixed(3);
            }
            if (this.config.enableDebug) {
              console.log(
                "\u{1F52C} [ColorHarmonyEngine] Generated OKLAB-processed variables:",
                {
                  primaryColor: primaryHex,
                  secondaryColor: secondaryHex,
                  oklabVariablesCount: Object.keys(cssVars).filter(
                    (k) => k.includes("oklab")
                  ).length,
                  oklchVariablesCount: Object.keys(cssVars).filter(
                    (k) => k.includes("oklch")
                  ).length
                }
              );
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "\u{1F52C} [ColorHarmonyEngine] OKLAB processing failed, using fallbacks:",
                error
              );
            }
            const fallbackRgb = this.utils.hexToRgb(result.accentHex);
            if (fallbackRgb) {
              cssVars["--sn-color-oklab-bright-highlight-rgb"] = `${fallbackRgb.r},${fallbackRgb.g},${fallbackRgb.b}`;
              cssVars["--sn-color-oklab-dynamic-shadow-rgb"] = `${Math.round(
                fallbackRgb.r * 0.3
              )},${Math.round(fallbackRgb.g * 0.3)},${Math.round(
                fallbackRgb.b * 0.3
              )}`;
            }
          }
        }
        /**
         * Convert OKLAB to OKLCH (cylindrical representation)
         */
        convertOklabToOklch(oklab) {
          const L = oklab.L;
          const C = Math.sqrt(oklab.a * oklab.a + oklab.b * oklab.b);
          let H = Math.atan2(oklab.b, oklab.a) * (180 / Math.PI);
          if (H < 0) H += 360;
          return { L, C, H };
        }
        detectCurrentTheme() {
          const rootElement = this.utils.getRootStyle();
          if (!rootElement) {
            console.warn(
              "[ColorHarmonyEngine detectCurrentTheme] Root element not found. Defaulting to mocha."
            );
            return "mocha";
          }
          const computedRootStyle = getComputedStyle(rootElement);
          const baseColorHex = computedRootStyle.getPropertyValue("--spice-main").trim();
          const normalizedBaseColor = baseColorHex.startsWith("#") ? baseColorHex.substring(1).toUpperCase() : baseColorHex.toUpperCase();
          const themeMap = {
            "303446": "frappe",
            EFF1F5: "latte",
            "24273A": "macchiato",
            "1E1E2E": "mocha"
          };
          const knownTheme = themeMap[normalizedBaseColor];
          if (knownTheme) {
            if (this.config.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Detected Catppuccin theme: ${knownTheme}`
              );
            }
            return knownTheme;
          }
          if (this.config.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] Unknown theme detected (${normalizedBaseColor}), attempting to generate fallback`
            );
          }
          const fallbackThemeName = `custom-${normalizedBaseColor.toLowerCase()}`;
          try {
            const fallbackPalette = this.paletteExtensionManager.generateFallbackPalette(fallbackThemeName);
            if (this.config.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Generated fallback palette for theme: ${fallbackThemeName}`,
                fallbackPalette
              );
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[ColorHarmonyEngine] Failed to generate fallback palette:`,
                error
              );
            }
          }
          if (this.config.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] Falling back to mocha theme for unknown base color: ${normalizedBaseColor}`
            );
          }
          return "mocha";
        }
        // TODO: Phase 3 - New method to get genre-aware palette
        async _getGenreAwarePalette(genre) {
          const basePalette = this.getCurrentActivePalette();
          if (!genre || !basePalette) {
            return basePalette;
          }
          try {
            const customPalette = {
              name: this.currentTheme,
              version: "1.0.0",
              accents: basePalette.accents,
              neutrals: basePalette.neutrals,
              metadata: {
                author: "Catppuccin",
                description: `${this.currentTheme} flavor`,
                temperature: "neutral"
              }
            };
            const modifiedPalette = this.paletteExtensionManager.applyGenreAwareModifications(
              customPalette,
              genre
            );
            return {
              accents: modifiedPalette.accents,
              neutrals: modifiedPalette.neutrals
            };
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                `[ColorHarmonyEngine] Failed to apply genre modifications for ${genre}:`,
                error
              );
            }
            return basePalette;
          }
        }
        getMusicIntensityMultiplier(energy = 0.5, valence = 0.5) {
          const baseMultiplier = this.config.getCurrentMultipliers().musicEnergyBoost;
          const energyBoost = energy > 0.7 ? 1.3 : energy > 0.4 ? 1 : 0.8;
          const valenceBoost = valence > 0.6 ? 1.2 : valence < 0.4 ? 0.9 : 1;
          return baseMultiplier * energyBoost * valenceBoost;
        }
        validateColorHarmony(color3, context = "general") {
          const startTime = performance.now();
          this.harmonyMetrics.totalHarmonyCalculations++;
          const contextRequirements = {
            general: {
              minContrast: 1.8,
              minHarmony: this.vibrancyConfig.harmonyTolerance
            },
            search: { minContrast: 2.8, minHarmony: 0.4 },
            navigation: { minContrast: 2.5, minHarmony: 0.45 },
            text: { minContrast: 4.5, minHarmony: 0.6 },
            accent: { minContrast: 1.5, minHarmony: 0.3 }
          };
          const requirements = contextRequirements[context] || contextRequirements["general"];
          const currentPalette = this.getCurrentActivePalette();
          if (!currentPalette?.neutrals?.base) {
            const errorMsg = `[StarryNight] Catppuccin palette or base neutral not found for theme: ${this.currentTheme}`;
            console.error(errorMsg);
            return {
              isValid: false,
              error: "Palette configuration error.",
              contrastRatio: 0,
              harmonyScore: 0,
              meetsContrast: false,
              isHarmonious: false,
              artisticMode: this.config.artisticMode,
              adjustedRequirements: requirements,
              recommendations: []
            };
          }
          const backgroundColor = currentPalette.neutrals.base;
          const colorHex = this.utils.rgbToHex(color3.r, color3.g, color3.b);
          const contrastRatio = this.utils.calculateContrastRatio(
            colorHex,
            backgroundColor
          );
          const harmonyScore = this.calculateHarmonyScore(color3, currentPalette);
          const currentMode = this.config.artisticMode;
          const adjustedRequirements = { ...requirements };
          if (currentMode === "advanced-maximum" || currentMode === "cosmic-maximum") {
            adjustedRequirements.minContrast *= 0.7;
            adjustedRequirements.minHarmony *= 0.6;
          } else if (currentMode === "artist-vision") {
            adjustedRequirements.minContrast *= 0.85;
            adjustedRequirements.minHarmony *= 0.8;
          }
          const meetsContrast = contrastRatio >= adjustedRequirements.minContrast;
          const isHarmonious = harmonyScore >= adjustedRequirements.minHarmony;
          const endTime = performance.now();
          this.harmonyMetrics.performance.push(endTime - startTime);
          return {
            isValid: meetsContrast && isHarmonious,
            contrastRatio,
            harmonyScore,
            meetsContrast,
            isHarmonious,
            artisticMode: currentMode,
            adjustedRequirements,
            recommendations: this.generateRecommendations(
              color3,
              contrastRatio,
              harmonyScore,
              adjustedRequirements
            )
          };
        }
        calculateHarmonyScore(color3, palette) {
          const colorHsl = this.utils.rgbToHsl(color3.r, color3.g, color3.b);
          let maxHarmony = 0;
          const accentColors = Object.values(palette.accents);
          for (const accentColor of accentColors) {
            const accentRgb = this.utils.hexToRgb(accentColor);
            if (!accentRgb) continue;
            const accentHsl = this.utils.rgbToHsl(
              accentRgb.r,
              accentRgb.g,
              accentRgb.b
            );
            const hueDiff = Math.abs(colorHsl.h - accentHsl.h);
            const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);
            const harmoniousAngles = [
              0,
              30,
              60,
              90,
              120,
              150,
              180,
              210,
              240,
              270,
              300,
              330
            ];
            const isHarmonious = harmoniousAngles.some(
              (angle) => Math.abs(normalizedHueDiff - angle) < 20
            );
            if (isHarmonious) {
              const harmonyStrength = 1 - Math.min(
                ...harmoniousAngles.map(
                  (angle) => Math.abs(normalizedHueDiff - angle)
                )
              ) / 20;
              maxHarmony = Math.max(maxHarmony, harmonyStrength);
            }
          }
          return maxHarmony;
        }
        findBestHarmoniousAccent(rgb, palette) {
          let bestAccent = {
            name: "mauve",
            hex: this.utils.getRootStyle()?.style.getPropertyValue("--sn-dynamic-accent")?.trim() || this.utils.getRootStyle()?.style.getPropertyValue("--spice-accent")?.trim() || "#cba6f7",
            // Fallback to default mauve hex
            rgb: { r: 203, g: 166, b: 247 }
          };
          const accentPriority = [
            "mauve",
            "lavender",
            "blue",
            "sapphire",
            "sky",
            "pink",
            "peach",
            "teal"
          ];
          let bestScore = -1;
          const inputHsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
          for (const accentName of accentPriority) {
            const accentHex = palette.accents[accentName];
            if (accentHex) {
              const accentRgb = this.utils.hexToRgb(accentHex);
              if (!accentRgb) continue;
              const accentHsl = this.utils.rgbToHsl(
                accentRgb.r,
                accentRgb.g,
                accentRgb.b
              );
              const hueDiff = Math.abs(inputHsl.h - accentHsl.h);
              const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);
              const harmonyScore = 1 - normalizedHueDiff / 180;
              const saturationBonus = accentHsl.s * 0.3;
              const totalScore = harmonyScore + saturationBonus;
              if (totalScore > bestScore) {
                bestScore = totalScore;
                bestAccent = {
                  name: accentName,
                  hex: accentHex,
                  rgb: accentRgb
                };
              }
            }
          }
          return bestAccent;
        }
        blendColors(rgb1, rgb2, ratio = this.vibrancyConfig.defaultBlendRatio) {
          const r = Math.max(0, Math.min(1, ratio));
          const oklab1 = this.utils.rgbToOklab(rgb1.r, rgb1.g, rgb1.b);
          const oklab2 = this.utils.rgbToOklab(rgb2.r, rgb2.g, rgb2.b);
          const lerp2 = /* @__PURE__ */ __name((a, b) => a * r + b * (1 - r), "lerp");
          const blendedOklab = {
            L: lerp2(oklab1.L, oklab2.L),
            a: lerp2(oklab1.a, oklab2.a),
            b: lerp2(oklab1.b, oklab2.b)
          };
          const blendedRgb = this.utils.oklabToRgb(
            blendedOklab.L,
            blendedOklab.a,
            blendedOklab.b
          );
          const blendedHsl = this.utils.rgbToHsl(
            blendedRgb.r,
            blendedRgb.g,
            blendedRgb.b
          );
          const artisticMode = this.config?.artisticMode ?? "artist-vision";
          const animationMultipliers = this.animationEngine?.getCurrentMultipliers?.() || void 0;
          const shouldUseEmergent = (artisticMode === "advanced-maximum" || artisticMode === "cosmic-maximum") && !!animationMultipliers;
          const validMultipliers = animationMultipliers || {};
          const saturationBoostFactor = shouldUseEmergent ? (validMultipliers.visualIntensityBase || 1) * 1.25 : this.vibrancyConfig.artisticSaturationBoost;
          const luminanceBoostFactor = shouldUseEmergent ? (validMultipliers.aestheticGravityStrength || 1) * 1.15 : this.vibrancyConfig.enhancedLuminanceBoost;
          blendedHsl.s = Math.max(
            blendedHsl.s,
            this.vibrancyConfig.minimumSaturation * 100
          );
          blendedHsl.s = Math.min(100, blendedHsl.s * saturationBoostFactor);
          if (artisticMode !== "corporate-safe") {
            blendedHsl.l = Math.min(95, blendedHsl.l * luminanceBoostFactor);
          }
          const finalRgb = this.utils.hslToRgb(
            blendedHsl.h,
            blendedHsl.s,
            blendedHsl.l
          );
          return { r: finalRgb.r, g: finalRgb.g, b: finalRgb.b };
        }
        blendWithCatppuccin(extractedColors, musicContext = null) {
          this.performanceMonitor?.emitTrace?.(
            "[ColorHarmonyEngine] Starting blendWithCatppuccin"
          );
          let emotionalTemperature = null;
          if (musicContext) {
            try {
              const musicAnalysis = {
                energy: musicContext.energy || 0.5,
                valence: musicContext.valence || 0.5,
                danceability: musicContext.danceability,
                tempo: musicContext.enhancedBPM || musicContext.tempo,
                loudness: musicContext.loudness,
                acousticness: musicContext.acousticness,
                instrumentalness: musicContext.instrumentalness,
                speechiness: musicContext.speechiness,
                mode: musicContext.mode,
                key: musicContext.key,
                genre: musicContext.genre
              };
              emotionalTemperature = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(
                musicAnalysis
              );
              if (emotionalTemperature) {
                unifiedEventBus.emit("system:css-variables", {
                  source: "ColorHarmonyEngine",
                  variables: emotionalTemperature.cssVariables,
                  timestamp: Date.now()
                });
                document.body.classList.remove(
                  ...Array.from(document.body.classList).filter(
                    (c) => c.startsWith("smooth-emotion-")
                  )
                );
                document.body.classList.add(emotionalTemperature.cssClass);
                if (emotionalTemperature.secondaryEmotion) {
                  document.body.classList.add(
                    `smooth-emotion-blend-${emotionalTemperature.secondaryEmotion}`
                  );
                }
              }
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F321}\uFE0F [ColorHarmonyEngine] Applied emotional temperature:",
                  emotionalTemperature
                );
              }
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn(
                  "\u{1F321}\uFE0F [ColorHarmonyEngine] Failed to apply emotional temperature:",
                  error
                );
              }
            }
          }
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [ColorHarmonyEngine] blendWithCatppuccin debug:", {
              extractedColors,
              musicContext,
              emotionalTemperature,
              currentTheme: this.currentTheme,
              vibrancyConfig: this.vibrancyConfig,
              userIntensity: this.userIntensity
            });
          }
          const currentPalette = this.getCurrentActivePalette();
          if (!currentPalette) {
            console.error(
              `[StarryNight] Catppuccin palette not found for theme: ${this.currentTheme}`
            );
            return extractedColors;
          }
          const harmonizedColors = {};
          for (const [role, color3] of Object.entries(extractedColors)) {
            if (!color3) continue;
            const extractedRgb = this.utils.hexToRgb(color3);
            if (!extractedRgb) {
              if (this.config.enableDebug) {
                console.warn(
                  `\u{1F3A8} [ColorHarmonyEngine] Failed to parse color for role ${role}: ${color3}`
                );
              }
              harmonizedColors[role] = color3;
              continue;
            }
            const extractedHsl = this.utils.rgbToHsl(
              extractedRgb.r,
              extractedRgb.g,
              extractedRgb.b
            );
            const saturationCheck = extractedHsl.s >= this.vibrancyConfig.minimumSaturation * 100;
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [ColorHarmonyEngine] Processing color ${role}:`, {
                originalColor: color3,
                rgb: extractedRgb,
                hsl: extractedHsl,
                saturationCheck,
                minimumSaturationRequired: this.vibrancyConfig.minimumSaturation * 100,
                actualSaturation: extractedHsl.s
              });
            }
            const bestAccent = this.findBestHarmoniousAccent(
              extractedRgb,
              currentPalette
            );
            if (!bestAccent?.rgb) {
              console.warn(
                `[StarryNight] Could not find a valid harmonious accent for role: ${role}. Using original color.`
              );
              harmonizedColors[role] = color3;
              continue;
            }
            let blendRatio = this.vibrancyConfig.getBlendRatio(
              this.config.artisticMode
            );
            if (emotionalTemperature) {
              const emotionalIntensity = emotionalTemperature.intensity;
              blendRatio *= emotionalIntensity * this.userIntensity;
              const temperatureInfluence = this.calculateTemperatureBlendInfluence(
                emotionalTemperature.temperature
              );
              blendRatio *= temperatureInfluence;
              blendRatio = Math.max(0, Math.min(1, blendRatio));
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F321}\uFE0F [ColorHarmonyEngine] Emotional temperature blend adjustment:",
                  {
                    originalRatio: this.vibrancyConfig.getBlendRatio(
                      this.config.artisticMode
                    ),
                    emotionalIntensity,
                    temperatureInfluence,
                    finalBlendRatio: blendRatio,
                    temperature: emotionalTemperature.temperature
                  }
                );
              }
            } else if (musicContext) {
              const musicIntensity = this.getMusicIntensityMultiplier(
                musicContext.energy,
                musicContext.valence
              );
              blendRatio *= musicIntensity * this.userIntensity;
              blendRatio = Math.max(0, Math.min(1, blendRatio));
            }
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [ColorHarmonyEngine] Blending ${role}:`, {
                extractedRgb,
                bestAccent: bestAccent.hex,
                blendRatio,
                artisticMode: this.config.artisticMode
              });
            }
            const finalRgb = this.blendColors(
              extractedRgb,
              bestAccent.rgb,
              blendRatio
            );
            const finalHex = this.utils.rgbToHex(finalRgb.r, finalRgb.g, finalRgb.b);
            harmonizedColors[role] = finalHex;
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3A8} [ColorHarmonyEngine] Final color for ${role}: ${color3} \u2192 ${finalHex}`
              );
            }
          }
          this.harmonyMetrics.musicInfluencedAdjustments++;
          this.performanceMonitor?.emitTrace?.(
            "[ColorHarmonyEngine] Completed blendWithCatppuccin"
          );
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [ColorHarmonyEngine] Final harmonized result:", {
              inputColors: extractedColors,
              outputColors: harmonizedColors,
              colorCount: Object.keys(harmonizedColors).length
            });
          }
          this.updateSemanticColorsWithHarmonizedPalette(harmonizedColors);
          return harmonizedColors;
        }
        /**
         * Updates semantic colors using the harmonized palette
         * Integrates with Spicetify's semantic color system for consistent theming
         */
        updateSemanticColorsWithHarmonizedPalette(harmonizedColors) {
          if (!this.semanticColorManager) {
            return;
          }
          try {
            this.semanticColorManager.updateWithAlbumColors(harmonizedColors);
            const primaryColor = harmonizedColors["VIBRANT"] || harmonizedColors["PRIMARY"];
            const secondaryColor = harmonizedColors["DARK_VIBRANT"] || harmonizedColors["SECONDARY"];
            const accentColor = harmonizedColors["VIBRANT_NON_ALARMING"] || harmonizedColors["LIGHT_VIBRANT"];
            if (primaryColor) {
              this.semanticColorManager.getSemanticColor("essentialBrightAccent").then((color3) => {
                const blendedColor = this.blendWithSemanticColor(
                  primaryColor,
                  color3,
                  0.7
                );
                this.applyCSSVariable("--spice-accent", blendedColor);
                this.applyCSSVariable("--spice-button-active", blendedColor);
              });
            }
            if (secondaryColor) {
              this.semanticColorManager.getSemanticColor("backgroundElevatedHighlight").then((color3) => {
                const blendedColor = this.blendWithSemanticColor(
                  secondaryColor,
                  color3,
                  0.5
                );
                this.applyCSSVariable("--spice-highlight", blendedColor);
              });
            }
            if (accentColor) {
              this.semanticColorManager.getSemanticColor("textBrightAccent").then((color3) => {
                const blendedColor = this.blendWithSemanticColor(
                  accentColor,
                  color3,
                  0.6
                );
                this.applyCSSVariable("--spice-text-accent", blendedColor);
              });
            }
            this.semanticColorManager.flushUpdates();
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[ColorHarmonyEngine] Failed to update semantic colors:",
                error
              );
            }
          }
        }
        /**
         * Blends a harmonized color with a semantic color for consistency
         */
        blendWithSemanticColor(harmonizedHex, semanticHex, blendRatio) {
          const harmonizedRgb = this.utils.hexToRgb(harmonizedHex);
          const semanticRgb = this.utils.hexToRgb(semanticHex);
          if (!harmonizedRgb || !semanticRgb) {
            return harmonizedHex;
          }
          const blendedRgb = this.blendColors(harmonizedRgb, semanticRgb, blendRatio);
          return this.utils.rgbToHex(blendedRgb.r, blendedRgb.g, blendedRgb.b);
        }
        /**
         * 🔧 PHASE 2: Emit CSS variable instead of applying directly
         */
        applyCSSVariable(property, value) {
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: { [property]: value },
            timestamp: Date.now()
          });
        }
        /**
         * Apply multiple CSS variables to the DOM efficiently
         * Enhanced with comprehensive UI component support and robust fallbacks
         */
        applyCSSVariablesToDOM(cssVariables) {
          const year3000System = globalThis.year3000System;
          const cssVisualEffectsController = year3000System?.cssVisualEffectsController || this.performanceMonitor?.cssVisualEffectsController || year3000System?.facadeCoordinator?.getCachedNonVisualSystem?.(
            "UnifiedCSSVariableManager"
          );
          const enhancedCssVariables = this.enhanceCSSVariablesForUIComponents(cssVariables);
          if (cssVisualEffectsController && typeof cssVisualEffectsController.batchSetVariables === "function") {
            try {
              cssVisualEffectsController.batchSetVariables(
                "ColorHarmonyEngine",
                enhancedCssVariables,
                "high",
                // High priority for color processing
                "color-harmony-oklab-processing"
              );
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F527} [ColorHarmonyEngine] Applied CSS variables via cssVisualEffectsController batcher"
                );
              }
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn(
                  "\u{1F527} [ColorHarmonyEngine] cssVisualEffectsController.batchSetVariables failed, using direct application:",
                  error
                );
              }
              this.applyVariablesDirectly(enhancedCssVariables);
            }
          } else {
            if (this.config.enableDebug) {
              console.log(
                "\u{1F527} [ColorHarmonyEngine] cssVisualEffectsController not available, using direct DOM application"
              );
            }
            this.applyVariablesDirectly(enhancedCssVariables);
          }
          unifiedEventBus.emitSync("colors:applied", {
            cssVariables: enhancedCssVariables,
            accentHex: enhancedCssVariables["--sn-accent-hex"] || "#a6adc8",
            accentRgb: enhancedCssVariables["--sn-accent-rgb"] || "166,173,200",
            appliedAt: Date.now()
          });
          if (this.config.enableDebug) {
            console.log(
              "\u{1F52C} [ColorHarmonyEngine] Applied enhanced CSS variables to DOM:",
              {
                totalVariables: Object.keys(enhancedCssVariables).length,
                oklabVariables: Object.keys(enhancedCssVariables).filter(
                  (k) => k.includes("oklab")
                ).length,
                oklchVariables: Object.keys(enhancedCssVariables).filter(
                  (k) => k.includes("oklch")
                ).length,
                gradientVariables: Object.keys(enhancedCssVariables).filter(
                  (k) => k.includes("gradient")
                ).length,
                spiceVariables: Object.keys(enhancedCssVariables).filter(
                  (k) => k.includes("spice")
                ).length,
                sidebarVariables: Object.keys(enhancedCssVariables).filter(
                  (k) => k.includes("sidebar")
                ).length,
                cssVisualEffectsControllerUsed: !!cssVisualEffectsController
              }
            );
          }
        }
        /**
         * Enhance CSS variables with UI component-specific mappings
         * Maps OKLAB-processed colors to variables that sidebar, now-playing, and other UI components expect
         */
        enhanceCSSVariablesForUIComponents(cssVariables) {
          const enhanced = { ...cssVariables };
          const accentHex = enhanced["--sn-accent-hex"] || enhanced[_ColorHarmonyEngine.CANONICAL_HEX_VAR];
          const accentRgb = enhanced["--sn-accent-rgb"] || enhanced[_ColorHarmonyEngine.CANONICAL_RGB_VAR];
          const primaryHex = enhanced["--sn-bg-gradient-primary"];
          const primaryRgb = enhanced["--sn-bg-gradient-primary-rgb"];
          const secondaryHex = enhanced["--sn-bg-gradient-secondary"];
          const secondaryRgb = enhanced["--sn-bg-gradient-secondary-rgb"];
          if (accentHex && accentRgb) {
            enhanced["--spice-accent"] = accentHex;
            enhanced["--spice-button"] = accentHex;
            enhanced["--spice-button-active"] = accentHex;
            enhanced["--spice-rgb-accent"] = accentRgb;
            enhanced["--spice-rgb-button"] = accentRgb;
            enhanced["--spice-text-accent"] = accentHex;
            enhanced["--sn-sidebar-entanglement-color-rgb"] = accentRgb;
            enhanced["--sn-sidebar-accent-color"] = accentHex;
            enhanced["--sn-sidebar-accent-rgb"] = accentRgb;
            enhanced["--sn-sidebar-dynamic-accent"] = accentHex;
            enhanced["--sn-nowplaying-accent-color"] = accentHex;
            enhanced["--sn-nowplaying-accent-rgb"] = accentRgb;
            enhanced["--sn-nowplaying-primary-color"] = accentHex;
            enhanced["--sn-nowplaying-primary-rgb"] = accentRgb;
            enhanced["--sn-main-feed-accent-color"] = accentHex;
            enhanced["--sn-main-feed-accent-rgb"] = accentRgb;
            enhanced["--sn-content-accent-color"] = accentHex;
            enhanced["--sn-content-accent-rgb"] = accentRgb;
          }
          if (primaryHex && primaryRgb) {
            enhanced["--sn-primary-gradient-color"] = primaryHex;
            enhanced["--sn-primary-gradient-rgb"] = primaryRgb;
            enhanced["--sn-main-feed-primary-color"] = primaryHex;
            enhanced["--sn-main-feed-primary-rgb"] = primaryRgb;
          }
          if (secondaryHex && secondaryRgb) {
            enhanced["--sn-secondary-gradient-color"] = secondaryHex;
            enhanced["--sn-secondary-gradient-rgb"] = secondaryRgb;
            enhanced["--sn-main-feed-secondary-color"] = secondaryHex;
            enhanced["--sn-main-feed-secondary-rgb"] = secondaryRgb;
          }
          const oklabBrightHighlight = enhanced["--sn-color-oklab-bright-highlight-rgb"];
          if (oklabBrightHighlight) {
            enhanced["--sn-audioAnalysis-bright-accent-rgb"] = oklabBrightHighlight;
            enhanced["--sn-layered-accent-rgb"] = oklabBrightHighlight;
            enhanced["--smooth-layered-rgb"] = oklabBrightHighlight;
            enhanced["--sn-holographic-accent-rgb"] = oklabBrightHighlight;
            enhanced["--smooth-holographic-rgb"] = oklabBrightHighlight;
          }
          const oklabDynamicShadow = enhanced["--sn-color-oklab-dynamic-shadow-rgb"];
          if (oklabDynamicShadow) {
            enhanced["--sn-audioAnalysis-shadow-rgb"] = oklabDynamicShadow;
            enhanced["--sn-depth-shadow-rgb"] = oklabDynamicShadow;
          }
          return enhanced;
        }
        /**
         * 🔧 PHASE 2: Emit CSS variables instead of applying directly
         */
        applyVariablesDirectly(cssVariables) {
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: cssVariables,
            timestamp: Date.now()
          });
        }
        generateRecommendations(color3, contrastRatio, harmonyScore, requirements) {
          const recommendations = [];
          const currentPalette = this.getCurrentActivePalette();
          const baseRgb = this.utils.hexToRgb(currentPalette?.neutrals?.base || "#1e1e2e");
          if (!baseRgb) {
            return [];
          }
          if (contrastRatio < requirements.minContrast) {
            const targetL = this.utils.findRequiredLuminance(
              color3,
              baseRgb,
              requirements.minContrast
            );
            const currentHsl = this.utils.rgbToHsl(color3.r, color3.g, color3.b);
            const adjustedRgbArr = this.utils.hslToRgb(
              currentHsl.h,
              currentHsl.s,
              targetL
            );
            const adjustedRgb = {
              r: adjustedRgbArr.r,
              g: adjustedRgbArr.g,
              b: adjustedRgbArr.b
            };
            recommendations.push({
              type: "contrast",
              suggestion: `Adjust luminance to meet contrast of ${requirements.minContrast}`,
              recommendedColor: this.utils.rgbToHex(
                adjustedRgb.r,
                adjustedRgb.g,
                adjustedRgb.b
              )
            });
          }
          if (harmonyScore < requirements.minHarmony) {
            const harmoniousAccent = this.findBestHarmoniousAccent(
              color3,
              currentPalette
            );
            const blendedColor = this.blendColors(color3, harmoniousAccent.rgb, 0.5);
            recommendations.push({
              type: "harmony",
              suggestion: `Blend with harmonious accent color to improve score to at least ${requirements.minHarmony}`,
              recommendedColor: this.utils.rgbToHex(
                blendedColor.r,
                blendedColor.g,
                blendedColor.b
              )
            });
          }
          return recommendations;
        }
        getPerformanceReport() {
          return {
            system: this.systemName,
            metrics: this.harmonyMetrics,
            kineticState: this.kineticState,
            musicalMemorySize: this.musicalMemory.recentTracks.length,
            currentTheme: this.currentTheme
          };
        }
        updateFromMusicAnalysis(processedMusicData, rawFeatures, trackUri) {
          if (!processedMusicData) return;
          const g = processedMusicData.genre;
          if (g && g !== this._lastGenre) {
            this._applyGenrePalette(g).then(() => {
              this._lastGenre = g;
              this._forcePaletteRepaint();
            });
          }
          this._updateMusicalMemory(processedMusicData, trackUri);
          this._updateKineticState(processedMusicData);
          this._applyAestheticGravity(processedMusicData);
          this._calculateMusicAwareDynamics(processedMusicData);
        }
        // TODO: Phase 2 - New method for music-aware dynamic calculations
        _calculateMusicAwareDynamics(musicData) {
          const {
            energy = 0.5,
            valence = 0.5,
            enhancedBPM = 120,
            beatOccurred = false
          } = musicData;
          const musicIntensityMultiplier = this._calculateMusicIntensityMultiplier(
            energy,
            valence
          );
          const beatPhase = this._calculateBeatPhase(enhancedBPM);
          const valenceGravity = (valence - 0.5) * 2;
          const hueShift = this._calculateHueShift(beatOccurred, energy, beatPhase);
          this.kineticState = {
            ...this.kineticState,
            musicIntensityMultiplier,
            beatPhase,
            valenceGravity,
            hueShift
          };
        }
        // TODO: Phase 2 - Calculate music intensity based on energy and valence
        _calculateMusicIntensityMultiplier(energy, valence) {
          const baseIntensity = energy * 0.7 + valence * 0.3;
          const contrastBoost = Math.abs(valence - 0.5) * 0.4;
          return Math.max(0.1, Math.min(2, baseIntensity + contrastBoost));
        }
        // TODO: Phase 2 - Calculate beat phase for cyclic effects
        _calculateBeatPhase(enhancedBPM) {
          const now = performance.now();
          const beatInterval = 6e4 / enhancedBPM;
          const timeSinceStart = now % beatInterval;
          return timeSinceStart / beatInterval;
        }
        // TODO: Phase 2 - Calculate dynamic hue shift for beat effects
        _calculateHueShift(beatOccurred, energy, beatPhase) {
          if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
            return 0;
          }
          const artisticMode = this.config.artisticMode;
          const baseAmplitude = artisticMode === "advanced-maximum" || artisticMode === "cosmic-maximum" ? 8 : 5;
          let hueShift = Math.sin(beatPhase * 2 * Math.PI) * baseAmplitude;
          if (beatOccurred) {
            const beatBoost = artisticMode === "advanced-maximum" || artisticMode === "cosmic-maximum" ? 12 : 10;
            hueShift += energy * beatBoost;
          }
          const clampRange = artisticMode === "advanced-maximum" || artisticMode === "cosmic-maximum" ? 25 : 15;
          return Math.max(-clampRange, Math.min(clampRange, hueShift));
        }
        _updateMusicalMemory(musicData, trackUri) {
          this.musicalMemory.recentTracks.unshift({
            trackUri,
            ...musicData,
            timestamp: Date.now()
          });
          if (this.musicalMemory.recentTracks.length > this.musicalMemory.maxMemorySize) {
            this.musicalMemory.recentTracks.pop();
          }
          this.musicalMemory.energyHistory.unshift(musicData.energy);
          if (this.musicalMemory.energyHistory.length > 20) {
            this.musicalMemory.energyHistory.pop();
          }
          this.harmonyMetrics.temporalMemoryEvents++;
        }
        _updateKineticState(musicData) {
          const { energy, enhancedBPM, beatOccurred } = musicData;
          const now = performance.now();
          if (beatOccurred) {
            this.kineticState.lastBeatTime = now;
            this.kineticState.currentPulse = 1;
          } else {
            this.kineticState.currentPulse *= 0.95;
          }
          const timeSinceLastBeat = now - this.kineticState.lastBeatTime;
          const beatInterval = 6e4 / (enhancedBPM || 120);
          this.kineticState.animationPhase = timeSinceLastBeat % beatInterval / beatInterval * 2 * Math.PI;
          this.kineticState.visualMomentum = this.utils.lerp(
            this.kineticState.visualMomentum,
            energy,
            0.1
          );
        }
        // 🔧 PHASE 2: Emit gravity variables instead of applying CSS directly
        _applyAestheticGravity(musicData) {
          const { visualIntensity, valence, energy } = musicData;
          const gravityX = (valence - 0.5) * 2;
          const gravityY = (energy - 0.5) * 2;
          const gravityStrength = visualIntensity;
          unifiedEventBus.emit("system:css-variables", {
            source: "ColorHarmonyEngine",
            variables: {
              "--sn-gravity-x": gravityX.toFixed(3),
              "--sn-gravity-y": gravityY.toFixed(3),
              "--sn-gravity-strength": gravityStrength.toFixed(3)
            },
            timestamp: Date.now()
          });
        }
        generateHarmonicVariations(baseRgb) {
          const oklab = this.utils.rgbToOklab(baseRgb.r, baseRgb.g, baseRgb.b);
          const darkOklabL = Math.max(0, Math.min(1, oklab.L * 0.75));
          const darkRgb = this.utils.oklabToRgb(darkOklabL, oklab.a, oklab.b);
          const lightOklabL = Math.max(0, Math.min(1, oklab.L * 1.25));
          const lightRgb = this.utils.oklabToRgb(lightOklabL, oklab.a, oklab.b);
          return {
            darkVibrantHex: this.utils.rgbToHex(darkRgb.r, darkRgb.g, darkRgb.b),
            lightVibrantHex: this.utils.rgbToHex(lightRgb.r, lightRgb.g, lightRgb.b)
          };
        }
        /**
         * Get current gradient colors optimized for WebGL texture creation
         * Uses variable inheritance from OKLAB processed audioAnalysis-aware colors
         * @param stopCount Number of gradient stops to generate (default: 5)
         * @returns Array of RGB color objects or null if unavailable
         */
        getCurrentGradient(stopCount = 5) {
          try {
            const currentPalette = this.getCurrentActivePalette();
            if (!currentPalette) {
              return null;
            }
            const rootEl = this.utils.getRootStyle();
            if (!rootEl) {
              return this.generateFallbackGradient(stopCount);
            }
            const computedStyle = getComputedStyle(rootEl);
            const inheritedColors = this.getInheritedGradientColors(computedStyle);
            if (!inheritedColors) {
              Y3KDebug?.debug?.warn(
                "ColorHarmonyEngine",
                "Failed to inherit processed gradient variables, using fallback"
              );
              return this.generateFallbackGradient(stopCount);
            }
            const gradientColors = [];
            const musicInfluence = this.kineticState.musicIntensityMultiplier || 1;
            const hueShift = this.kineticState.hueShift || 0;
            const valenceGravity = this.kineticState.valenceGravity || 0.5;
            const emotionalTemperature = this.emotionalState?.currentEmotion?.colorTemperature || 0.5;
            const { primary, secondary, accent, emotional, tertiary } = inheritedColors;
            const baseColors = [
              primary,
              // Deep audioAnalysis base
              secondary,
              // Harmonic transition
              accent,
              // Vibrational peak
              emotional,
              // Emotional resonance
              tertiary
              // Transcendent highlight
            ];
            for (let i = 0; i < stopCount; i++) {
              const position = i / (stopCount - 1);
              let interpolatedColor;
              if (stopCount === 1) {
                interpolatedColor = accent;
              } else {
                const colorIndex = position * (baseColors.length - 1);
                const lowerIndex = Math.floor(colorIndex);
                const upperIndex = Math.min(lowerIndex + 1, baseColors.length - 1);
                const interpolationFactor = colorIndex - lowerIndex;
                const temperatureInfluence = Math.sin(emotionalTemperature * Math.PI) * 0.3;
                const adjustedFactor = Math.max(
                  0,
                  Math.min(1, interpolationFactor + temperatureInfluence)
                );
                const color1 = baseColors[lowerIndex];
                const color22 = baseColors[upperIndex];
                if (color1 && color22) {
                  interpolatedColor = {
                    r: color1.r + (color22.r - color1.r) * adjustedFactor,
                    g: color1.g + (color22.g - color1.g) * adjustedFactor,
                    b: color1.b + (color22.b - color1.b) * adjustedFactor
                  };
                } else {
                  interpolatedColor = accent;
                }
              }
              let finalColor = this._applyVisualEffectsModulation(interpolatedColor, {
                musicInfluence,
                valenceGravity,
                hueShift,
                emotionalTemperature,
                position
              });
              gradientColors.push({
                r: Math.round(Math.max(0, Math.min(255, finalColor.r))),
                g: Math.round(Math.max(0, Math.min(255, finalColor.g))),
                b: Math.round(Math.max(0, Math.min(255, finalColor.b)))
              });
            }
            if (this.config?.enableDebug) {
              console.log(
                `[ColorHarmonyEngine] Generated gradient with ${stopCount} stops:`,
                gradientColors
              );
            }
            return gradientColors;
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "Unknown error";
            const errorDetails = {
              method: "getCurrentGradient",
              stopCount,
              currentTheme: this.currentTheme,
              kineticState: this.kineticState,
              timestamp: Date.now(),
              error: errorMessage
            };
            Y3KDebug?.debug?.error(
              "ColorHarmonyEngine",
              "Failed to generate gradient colors",
              errorDetails
            );
            unifiedEventBus.emit("system:error", {
              systemName: "ColorHarmonyEngine",
              error: `Gradient generation failed: ${errorMessage}`,
              severity: "error",
              timestamp: Date.now()
            });
            try {
              const fallbackColors = this.generateFallbackGradient(stopCount);
              if (fallbackColors && fallbackColors.length > 0) {
                Y3KDebug?.debug?.warn(
                  "ColorHarmonyEngine",
                  "Using fallback gradient after error",
                  { fallbackColorCount: fallbackColors.length }
                );
                return fallbackColors;
              }
            } catch (fallbackError) {
              Y3KDebug?.debug?.error(
                "ColorHarmonyEngine",
                "Fallback gradient generation also failed",
                fallbackError
              );
            }
            return null;
          }
        }
        /**
         * Get inherited gradient colors from processed OKLAB CSS variables
         * Uses variable inheritance instead of manual CSS reading
         */
        getInheritedGradientColors(computedStyle) {
          try {
            const primaryRgb = this.parseRGBVariable(
              computedStyle,
              "--sn-oklab-processed-primary-rgb"
            ) || this.parseRGBVariable(computedStyle, "--sn-bg-gradient-primary-rgb") || this.parseRGBVariable(
              computedStyle,
              "--sn-musical-harmony-primary-rgb"
            );
            const secondaryRgb = this.parseRGBVariable(
              computedStyle,
              "--sn-oklab-processed-secondary-rgb"
            ) || this.parseRGBVariable(computedStyle, "--sn-bg-gradient-secondary-rgb") || this.parseRGBVariable(
              computedStyle,
              "--sn-musical-harmony-secondary-rgb"
            );
            const accentRgb = this.parseRGBVariable(
              computedStyle,
              "--sn-oklab-processed-accent-rgb"
            ) || this.parseRGBVariable(computedStyle, "--sn-bg-gradient-accent-rgb") || this.parseRGBVariable(computedStyle, "--sn-color-accent-rgb");
            const emotionalRgb = this.parseRGBVariable(
              computedStyle,
              "--sn-oklab-emotional-temperature-rgb"
            ) || this.parseRGBVariable(
              computedStyle,
              "--sn-emotional-temperature-warm-rgb"
            ) || accentRgb;
            const tertiaryRgb = this.parseRGBVariable(
              computedStyle,
              "--sn-oklab-processed-bright-highlight-rgb"
            ) || this.parseRGBVariable(computedStyle, "--sn-audioAnalysis-flow-rgb") || this.parseRGBVariable(
              computedStyle,
              "--sn-musical-harmony-tertiary-rgb"
            );
            if (!primaryRgb || !accentRgb) {
              Y3KDebug?.debug?.warn(
                "ColorHarmonyEngine",
                "Missing essential inherited colors",
                {
                  hasPrimary: !!primaryRgb,
                  hasAccent: !!accentRgb
                }
              );
              return null;
            }
            return {
              primary: primaryRgb,
              secondary: secondaryRgb || primaryRgb,
              accent: accentRgb,
              emotional: emotionalRgb || accentRgb,
              tertiary: tertiaryRgb || accentRgb
            };
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ColorHarmonyEngine",
              "Failed to inherit gradient colors:",
              error
            );
            return null;
          }
        }
        /**
         * Parse RGB variable from CSS computed style with fallback chain
         */
        parseRGBVariable(computedStyle, variableName) {
          try {
            const value = computedStyle.getPropertyValue(variableName).trim();
            if (!value) return null;
            const rgbMatch = value.match(/(\d+),\s*(\d+),\s*(\d+)/);
            if (rgbMatch && rgbMatch[1] && rgbMatch[2] && rgbMatch[3]) {
              return {
                r: parseInt(rgbMatch[1], 10),
                g: parseInt(rgbMatch[2], 10),
                b: parseInt(rgbMatch[3], 10)
              };
            }
            return null;
          } catch (error) {
            return null;
          }
        }
        /**
         * Interpolate between two colors using perceptually aware interpolation
         */
        interpolateOKLABColors(color1, color22, factor) {
          const gamma = 2.2;
          const r1 = Math.pow(color1.r / 255, gamma);
          const g1 = Math.pow(color1.g / 255, gamma);
          const b1 = Math.pow(color1.b / 255, gamma);
          const r2 = Math.pow(color22.r / 255, gamma);
          const g2 = Math.pow(color22.g / 255, gamma);
          const b2 = Math.pow(color22.b / 255, gamma);
          const rInterp = r1 + (r2 - r1) * factor;
          const gInterp = g1 + (g2 - g1) * factor;
          const bInterp = b1 + (b2 - b1) * factor;
          return {
            r: Math.round(Math.pow(rInterp, 1 / gamma) * 255),
            g: Math.round(Math.pow(gInterp, 1 / gamma) * 255),
            b: Math.round(Math.pow(bInterp, 1 / gamma) * 255)
          };
        }
        /**
         * Apply audioAnalysis modulation to color (preserves OKLAB processing)
         */
        _applyVisualEffectsModulation(color3, modulation) {
          try {
            const hsl = this.utils.rgbToHsl(color3.r, color3.g, color3.b);
            let { h, s, l } = hsl;
            s = Math.max(0, Math.min(1, s * (0.7 + modulation.musicInfluence * 0.6)));
            h = (h + modulation.hueShift + (modulation.emotionalTemperature - 0.5) * 60) % 360;
            const gravityEffect = modulation.valenceGravity * 0.2 * Math.sin(modulation.position * Math.PI);
            l = Math.max(0.1, Math.min(0.9, l + gravityEffect));
            const modulatedRgb = this.utils.hslToRgb(h, s, l);
            return {
              r: modulatedRgb.r,
              g: modulatedRgb.g,
              b: modulatedRgb.b
            };
          } catch (error) {
            return color3;
          }
        }
        /**
         * Generate fallback gradient colors when primary generation fails
         * Uses safe Catppuccin colors to prevent complete gradient failure
         */
        generateFallbackGradient(stopCount) {
          try {
            const fallbackHexColors = [
              "#1e1e2e",
              // Base
              "#313244",
              // Surface0
              "#45475a",
              // Surface1
              "#585b70",
              // Surface2
              "#cba6f7",
              // Mauve (primary accent)
              "#f5c2e7",
              // Pink
              "#fab387"
              // Peach
            ];
            if (stopCount < 2 || stopCount > fallbackHexColors.length) {
              Y3KDebug?.debug?.warn(
                "ColorHarmonyEngine",
                `Invalid fallback stopCount: ${stopCount}, using default`
              );
              stopCount = Math.min(Math.max(stopCount, 2), fallbackHexColors.length);
            }
            const fallbackColors = [];
            for (let i = 0; i < stopCount; i++) {
              const colorIndex = Math.floor(
                i / (stopCount - 1) * (fallbackHexColors.length - 1)
              );
              const hex = fallbackHexColors[colorIndex];
              const rgb = hex ? this.utils.hexToRgb(hex) : null;
              if (rgb) {
                fallbackColors.push(rgb);
              } else {
                fallbackColors.push({
                  r: 203,
                  g: 166,
                  b: 247
                  // Mauve fallback
                });
              }
            }
            if (fallbackColors.length < 2) {
              fallbackColors.push(
                { r: 30, g: 30, b: 46 },
                // Base
                { r: 203, g: 166, b: 247 }
                // Mauve
              );
            }
            Y3KDebug?.debug?.log(
              "ColorHarmonyEngine",
              `Generated fallback gradient with ${fallbackColors.length} colors`,
              fallbackColors
            );
            return fallbackColors;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ColorHarmonyEngine",
              "Critical error in fallback gradient generation",
              error
            );
            return null;
          }
        }
        /**
         * Analyze music and update emotional state for audioAnalysis-aware color processing
         * This method connects the Music → Emotion → Color flow
         */
        async analyzeMusicEmotion(audioFeatures, audioData) {
          if (!this.initialized || !this.musicEmotionAnalyzer) {
            if (this.config.enableDebug) {
              console.warn(
                "\u{1F3AD} [ColorHarmonyEngine] Cannot analyze music emotion: not initialized"
              );
            }
            return null;
          }
          try {
            const emotion = await this.musicEmotionAnalyzer.analyzeEmotion(
              audioFeatures,
              audioData
            );
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3AD} [ColorHarmonyEngine] Analyzed music emotion: ${emotion.primary} (${emotion.intensity.toFixed(
                  2
                )} intensity, ${emotion.confidence.toFixed(2)} confidence)`
              );
            }
            return emotion;
          } catch (error) {
            console.error(
              "\u{1F3AD} [ColorHarmonyEngine] Error analyzing music emotion:",
              error
            );
            return null;
          }
        }
        /**
         * Get current emotional state
         */
        getCurrentEmotion() {
          return this.emotionalState?.currentEmotion || null;
        }
        /**
         * Get emotion history for audioAnalysis flow analysis
         */
        getEmotionHistory(limit = 10) {
          if (!this.emotionalState?.emotionHistory) return [];
          return this.emotionalState.emotionHistory.slice(-limit);
        }
        /**
         * Set emotion influence intensity (0-1) for color processing
         */
        setEmotionInfluenceIntensity(intensity) {
          if (this.emotionalState) {
            this.emotionalState.emotionInfluenceIntensity = Math.max(
              0,
              Math.min(1, intensity)
            );
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3AD} [ColorHarmonyEngine] Emotion influence intensity set to ${this.emotionalState.emotionInfluenceIntensity}`
              );
            }
          }
        }
        /**
         * Create a color variant with lightness, saturation, and hue adjustments
         */
        _createVariant(baseColor, lightnessFactor, valenceGravity, hueShift) {
          const oklab = this.utils.rgbToOklab(baseColor.r, baseColor.g, baseColor.b);
          const newL = Math.max(0, Math.min(1, oklab.L + lightnessFactor * 0.2));
          const chromaScale = 0.8 + valenceGravity * 0.4;
          const newA = oklab.a * chromaScale;
          const newB = oklab.b * chromaScale;
          const hueAdjustment = hueShift * 0.1;
          const adjustedA = newA * Math.cos(hueAdjustment) - newB * Math.sin(hueAdjustment);
          const adjustedB = newA * Math.sin(hueAdjustment) + newB * Math.cos(hueAdjustment);
          return this.utils.oklabToRgb(newL, adjustedA, adjustedB);
        }
        /**
         * Apply music intensity influence to color
         */
        _applyMusicInfluence(color3, intensity, position) {
          const positionEffect = 1 + Math.sin(position * Math.PI) * 0.2;
          const effectiveIntensity = Math.max(
            0.7,
            Math.min(1.3, intensity * positionEffect)
          );
          return {
            r: color3.r * effectiveIntensity,
            g: color3.g * effectiveIntensity,
            b: color3.b * effectiveIntensity
          };
        }
        // =========================
        // PUBLIC API – User Control
        // =========================
        /**
         * Update user-defined color harmony intensity (0–1). Values outside range are clamped.
         */
        setIntensity(value) {
          const clamped = Math.max(0, Math.min(1, value));
          this.userIntensity = clamped;
          if (this.config?.enableDebug) {
            console.log(
              `[ColorHarmonyEngine] User color harmony intensity set to ${clamped}`
            );
          }
        }
        /**
         * External systems can push a pre-computed RGB palette to the engine.
         * Currently this simply triggers a palette refresh so all CSS variables
         * are recalculated.  Future phases may blend these colours directly.
         *
         * @param colors – Array of RGB objects ({ r,g,b }) representing the new palette
         */
        updatePalette(colors) {
          if (!colors?.length) return;
          if (this.config?.enableDebug) {
            console.log("[ColorHarmonyEngine] updatePalette invoked", {
              count: colors.length
            });
          }
          this.forceRepaint("external-palette");
        }
        // ============================
        // Settings / Event Integration
        // ============================
        _handleSettingsChange(event) {
          const { key, value } = event.detail || {};
          switch (key) {
            case HARMONIC_INTENSITY_KEY: {
              const num = parseFloat(value);
              if (!Number.isNaN(num)) {
                this.setIntensity(num);
              }
              break;
            }
            case HARMONIC_EVOLUTION_KEY: {
              const enabled = value === "true" || value === true;
              this._setEvolutionEnabled(enabled);
              break;
            }
          }
        }
        _handleArtisticModeChanged() {
          this.currentTheme = this.detectCurrentTheme();
          if (!this._pendingPaletteRefresh) {
            this._pendingPaletteRefresh = setTimeout(() => {
              this._pendingPaletteRefresh = null;
              this.refreshPalette();
            }, 80);
          }
        }
        _forcePaletteRepaint() {
          this.kineticState.hueShift = (this.kineticState.hueShift || 0) + 0.01;
        }
        // Evolution helpers
        _startEvolutionLoop() {
          if (this._evolutionTimer) return;
          const basePeriod = 3e4;
          const period = basePeriod / Math.max(0.1, this.userIntensity);
          this._evolutionTimer = setInterval(() => {
            const step = 2 * this.userIntensity;
            const current = this.kineticState.hueShift ?? 0;
            this.kineticState.hueShift = (current + step + 360) % 360 - 180;
          }, period);
        }
        _stopEvolutionLoop() {
          if (this._evolutionTimer) {
            clearInterval(this._evolutionTimer);
            this._evolutionTimer = null;
          }
        }
        _setEvolutionEnabled(enabled) {
          if (this.evolutionEnabled === enabled) return;
          this.evolutionEnabled = enabled;
          if (enabled) this._startEvolutionLoop();
          else this._stopEvolutionLoop();
        }
        // Clean up listeners when destroyed
        destroy() {
          this._stopEvolutionLoop();
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this._boundSettingsChangeHandler
          );
          document.removeEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          if (this.semanticColorManager) {
            this.semanticColorManager.destroy();
          }
          if (this.musicEmotionAnalyzer) {
            this.musicEmotionAnalyzer.destroy();
          }
          if (this.emotionalState) {
            this.emotionalState.currentEmotion = null;
            this.emotionalState.emotionHistory = [];
          }
          super.destroy?.();
        }
        /**
         * Public helper that triggers a colour rebake based on the current track.
         * Prefer calling the global Year3000System where available so the full
         * pipeline (extraction → harmonisation → CSS variable batch) is reused.
         */
        async refreshPalette() {
          try {
            const y3kSystem = globalThis.year3000System;
            if (y3kSystem?.updateColorsFromCurrentTrack) {
              await y3kSystem.updateColorsFromCurrentTrack();
              return;
            }
            const root = this.utils.getRootStyle();
            if (!root) return;
            const styles = getComputedStyle(root);
            const primary = styles.getPropertyValue("--sn-gradient-primary").trim();
            if (primary) {
              const rgb = this.utils.hexToRgb(primary);
              const variables = {
                "--sn-bg-gradient-primary": primary
              };
              if (rgb) {
                variables["--sn-bg-gradient-primary-rgb"] = `${rgb.r},${rgb.g},${rgb.b}`;
              }
              unifiedEventBus.emit("system:css-variables", {
                source: "ColorHarmonyEngine",
                variables,
                timestamp: Date.now()
              });
            }
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn("[ColorHarmonyEngine] refreshPalette failed", err);
            }
          }
        }
        /**
         * Swap Catppuccin palette accents & neutrals based on detected genre.
         * Executes asynchronously to avoid blocking audio thread.
         */
        async _applyGenrePalette(genre) {
          try {
            const palette = await this._getGenreAwarePalette(genre);
            if (!palette) return;
            this.catppuccinPalettes[this.currentTheme] = palette;
            await this.refreshPalette();
            if (this.config.enableDebug) {
              console.log(`\u{1F3A8} [ColorHarmonyEngine] Genre changed to: ${genre}`);
            }
          } catch (err) {
            if (this.config.enableDebug) {
              console.warn("[ColorHarmonyEngine] _applyGenrePalette failed", err);
            }
          }
        }
        setEmergentEngine(engine) {
          this.animationEngine = engine;
        }
        // ---------------------------------------------------------------------------
        // 🔄 SETTINGS-AWARE REPAINT IMPLEMENTATION
        // ---------------------------------------------------------------------------
        /**
         * Calculate temperature-based blend influence for emotional temperature integration
         * Maps color temperature (1000K-20000K) to blend ratio influence (0.7-1.3)
         */
        calculateTemperatureBlendInfluence(temperature) {
          const normalized = Math.max(
            0,
            Math.min(1, (temperature - 1e3) / (2e4 - 1e3))
          );
          if (temperature <= 4e3) {
            const warmFactor = (4e3 - temperature) / (4e3 - 1e3);
            return 1 + warmFactor * 0.3;
          } else if (temperature >= 8e3) {
            const coolFactor = (temperature - 8e3) / (2e4 - 8e3);
            return 1.1 + coolFactor * 0.2;
          } else {
            const midFactor = Math.abs(temperature - 6e3) / 2e3;
            return 0.9 + midFactor * 0.2;
          }
        }
        /**
         * Re-apply the current palette immediately.  This is extremely lightweight
         * (just re-blends colours + sets CSS vars) so it can be called synchronously
         * from Year3000System after a relevant settings change.
         */
        forceRepaint(_reason = "settings-change") {
          this.refreshPalette?.();
        }
        // ============================================================================
        // 🌟 ENHANCED OKLAB INTEGRATION METHODS
        // ============================================================================
        /**
         * Determine optimal OKLAB enhancement preset based on musical and visual context
         */
        determineOptimalOKLABPreset(context) {
          const musicData = context.musicData;
          let selectedPreset = OKLABColorProcessor.PRESETS.STANDARD;
          if (musicData) {
            const { energy = 0.5, valence = 0.5 } = musicData;
            if (energy > 0.8 && valence > 0.7) {
              selectedPreset = OKLABColorProcessor.PRESETS.COSMIC;
            } else if (energy > 0.7 && valence < 0.4) {
              selectedPreset = OKLABColorProcessor.PRESETS.VIBRANT;
            } else if (energy < 0.3) {
              selectedPreset = OKLABColorProcessor.PRESETS.SUBTLE;
            }
          }
          if (context.performanceHints?.preferLightweight) {
            selectedPreset = OKLABColorProcessor.PRESETS.SUBTLE;
          }
          if (this.config?.enableDebug) {
            console.log("\u{1F52C} [ColorHarmonyEngine] OKLAB preset selection:", {
              energy: musicData?.energy,
              valence: musicData?.valence,
              selectedPreset: selectedPreset.name,
              reason: this.getPresetSelectionReason(musicData, context)
            });
          }
          return selectedPreset;
        }
        /**
         * Get comprehensive emotional temperature analysis using EmotionalTemperatureMapper
         * Enhanced with album art color analysis for multi-sensory emotion intelligence
         */
        async getAdvancedEmotionalTemperature(musicData, albumArtColors) {
          if (!this.emotionalTemperatureMapper || !musicData) {
            return null;
          }
          try {
            const analysisData = {
              energy: musicData.energy || 0.5,
              valence: musicData.valence || 0.5,
              danceability: musicData.danceability,
              tempo: musicData.tempo,
              loudness: musicData.loudness,
              acousticness: musicData.acousticness,
              instrumentalness: musicData.instrumentalness,
              speechiness: musicData.speechiness,
              mode: musicData.mode,
              key: musicData.key,
              genre: musicData.genre
            };
            const enhancedAnalysisData = await this.enhanceWithAlbumArtPsychology(
              analysisData,
              albumArtColors
            );
            const emotionalResult = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(
              enhancedAnalysisData
            );
            if (this.config?.enableDebug) {
              console.log(
                "\u{1F321}\uFE0F [ColorHarmonyEngine] Advanced emotional temperature with album art enhancement:",
                {
                  input: analysisData,
                  enhanced: enhancedAnalysisData,
                  albumArtInfluence: albumArtColors ? Object.keys(albumArtColors).length + " colors" : "None",
                  emotion: emotionalResult.primaryEmotion,
                  secondaryEmotion: emotionalResult.secondaryEmotion,
                  intensity: emotionalResult.intensity,
                  temperature: emotionalResult.temperature,
                  oklabPreset: emotionalResult.oklabPreset.name,
                  perceptualColor: emotionalResult.perceptualColorHex
                }
              );
            }
            return emotionalResult;
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Advanced emotional temperature analysis failed:",
              error
            );
            return null;
          }
        }
        /**
         * Enhance music emotion analysis with album art color psychology
         * Uses color theory and psychological associations to calibrate emotion detection
         * Creating a multi-sensory approach to artist audioAnalysis recognition
         */
        async enhanceWithAlbumArtPsychology(originalAnalysis, albumArtColors) {
          if (!albumArtColors || Object.keys(albumArtColors).length === 0) {
            return originalAnalysis;
          }
          try {
            const colorPsychology = this.analyzeAlbumArtPsychology(albumArtColors);
            const enhanced = { ...originalAnalysis };
            const currentEnergy = enhanced.energy || 0.5;
            const currentValence = enhanced.valence || 0.5;
            if (colorPsychology.warmth > 0.6) {
              enhanced.energy = Math.min(
                1,
                currentEnergy * (1 + colorPsychology.warmth * 0.3)
              );
              enhanced.valence = Math.min(
                1,
                currentValence + colorPsychology.warmth * 0.2
              );
            }
            if (colorPsychology.coolness > 0.6) {
              enhanced.energy = Math.max(
                0,
                currentEnergy * (1 - colorPsychology.coolness * 0.2)
              );
              if (colorPsychology.saturation > 0.5) {
                enhanced.valence = Math.min(
                  1,
                  currentValence + colorPsychology.coolness * 0.15
                );
              }
            }
            if (colorPsychology.saturation > 0.7) {
              enhanced.energy = Math.min(
                1,
                currentEnergy + colorPsychology.saturation * 0.2
              );
            }
            if (colorPsychology.saturation < 0.3) {
              enhanced.valence = Math.max(0, currentValence - 0.15);
              enhanced.energy = Math.max(0, currentEnergy - 0.1);
            }
            if (colorPsychology.darkness > 0.7) {
              const finalEnergy = enhanced.energy || currentEnergy;
              if (finalEnergy > 0.6) {
                enhanced.energy = Math.min(1, finalEnergy + 0.1);
              } else {
                enhanced.valence = Math.max(
                  0,
                  (enhanced.valence || currentValence) - 0.2
                );
              }
            }
            if (colorPsychology.brightness > 0.8) {
              enhanced.valence = Math.min(
                1,
                (enhanced.valence || currentValence) + colorPsychology.brightness * 0.2
              );
            }
            if (colorPsychology.harmony > 0.8) {
              enhanced.valence = Math.min(
                1,
                (enhanced.valence || currentValence) + 0.1
              );
            } else if (colorPsychology.harmony < 0.3) {
              enhanced.energy = Math.min(
                1,
                (enhanced.energy || currentEnergy) + 0.15
              );
            }
            if (this.config?.enableDebug) {
              console.log(
                "\u{1F3A8} [ColorHarmonyEngine] Album art psychology enhancement:",
                {
                  original: {
                    energy: originalAnalysis.energy || 0.5,
                    valence: originalAnalysis.valence || 0.5
                  },
                  enhanced: {
                    energy: enhanced.energy || 0.5,
                    valence: enhanced.valence || 0.5
                  },
                  colorPsychology,
                  adjustments: {
                    energyChange: (enhanced.energy || 0.5) - (originalAnalysis.energy || 0.5),
                    valenceChange: (enhanced.valence || 0.5) - (originalAnalysis.valence || 0.5)
                  }
                }
              );
            }
            return enhanced;
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Album art psychology enhancement failed:",
              error
            );
            return originalAnalysis;
          }
        }
        /**
         * Analyze album art colors for psychological and emotional indicators
         * 🎨 PHASE 2.3: Enhanced with genre indicators and artist audioAnalysis recognition
         * Based on color psychology research and artist expression patterns
         */
        analyzeAlbumArtPsychology(albumArtColors) {
          try {
            const colors = Object.values(albumArtColors);
            if (colors.length === 0) {
              return {
                warmth: 0.5,
                coolness: 0.5,
                saturation: 0.5,
                brightness: 0.5,
                darkness: 0.5,
                harmony: 0.5,
                dominantHue: 180,
                emotionalIntensity: 0.5,
                genreIndicators: {
                  electronicLikelihood: 0.5,
                  smoothLikelihood: 0.5,
                  metalHardcoreLikelihood: 0.5,
                  popCommercialLikelihood: 0.5,
                  jazzClassicalLikelihood: 0.5,
                  folkAcousticLikelihood: 0.5
                },
                artistAwareness: {
                  visualSophistication: 0.5,
                  artisticIntention: 0.5,
                  culturalIndicators: [],
                  emotionalDepth: 0.5
                }
              };
            }
            let totalWarmth = 0, totalCoolness = 0, totalSaturation = 0;
            let totalBrightness = 0, totalDarkness = 0;
            const hues = [];
            for (const color3 of colors) {
              const rgb = this.utils.hexToRgb(color3);
              if (!rgb) continue;
              const hsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
              const { h, s, l } = hsl;
              hues.push(h);
              if (h >= 0 && h <= 60 || h >= 300 && h <= 360) {
                totalWarmth += s * l;
              } else if (h >= 120 && h <= 240) {
                totalCoolness += s * l;
              }
              totalSaturation += s;
              totalBrightness += l;
              totalDarkness += 1 - l;
            }
            const count = colors.length;
            const avgWarmth = totalWarmth / count;
            const avgCoolness = totalCoolness / count;
            const avgSaturation = totalSaturation / count;
            const avgBrightness = totalBrightness / count;
            const avgDarkness = totalDarkness / count;
            const harmony = this.calculateColorHarmony(hues);
            const dominantHue = this.calculateDominantHue(hues);
            const emotionalIntensity = Math.min(
              1,
              (avgSaturation + this.calculateContrast(colors)) / 2
            );
            const genreIndicators = this._analyzeGenreIndicatorsFromColors({
              warmth: Math.min(1, avgWarmth),
              coolness: Math.min(1, avgCoolness),
              saturation: avgSaturation,
              brightness: avgBrightness,
              darkness: avgDarkness,
              harmony,
              dominantHue,
              emotionalIntensity
            });
            const artistAwareness = this._analyzeArtistAwareness(colors, {
              avgSaturation,
              avgBrightness,
              harmony,
              emotionalIntensity,
              colorCount: colors.length
            });
            return {
              warmth: Math.min(1, avgWarmth),
              coolness: Math.min(1, avgCoolness),
              saturation: avgSaturation,
              brightness: avgBrightness,
              darkness: avgDarkness,
              harmony,
              dominantHue,
              emotionalIntensity,
              genreIndicators,
              artistAwareness
            };
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Album art psychology analysis failed:",
              error
            );
            return {
              warmth: 0.5,
              coolness: 0.5,
              saturation: 0.5,
              brightness: 0.5,
              darkness: 0.5,
              harmony: 0.5,
              dominantHue: 180,
              emotionalIntensity: 0.5,
              genreIndicators: {
                electronicLikelihood: 0.5,
                smoothLikelihood: 0.5,
                metalHardcoreLikelihood: 0.5,
                popCommercialLikelihood: 0.5,
                jazzClassicalLikelihood: 0.5,
                folkAcousticLikelihood: 0.5
              },
              artistAwareness: {
                visualSophistication: 0.5,
                artisticIntention: 0.5,
                culturalIndicators: [],
                emotionalDepth: 0.5
              }
            };
          }
        }
        /**
         * Calculate color harmony score based on hue relationships
         */
        calculateColorHarmony(hues) {
          if (hues.length <= 1) return 1;
          let harmonyScore = 0;
          const harmonyTypes = [
            60,
            // Complementary
            120,
            // Triadic
            30,
            // Analogous
            90
            // Tetradic
          ];
          for (let i = 0; i < hues.length; i++) {
            for (let j = i + 1; j < hues.length; j++) {
              const hue1 = hues[i];
              const hue2 = hues[j];
              if (hue1 === void 0 || hue2 === void 0) continue;
              const diff = Math.abs(hue1 - hue2);
              const minDiff = Math.min(diff, 360 - diff);
              for (const harmonic of harmonyTypes) {
                if (Math.abs(minDiff - harmonic) <= 15) {
                  harmonyScore += 1;
                }
              }
            }
          }
          const maxPossible = hues.length * (hues.length - 1) / 2;
          return Math.min(1, harmonyScore / maxPossible);
        }
        /**
         * Calculate dominant hue from hue array
         */
        calculateDominantHue(hues) {
          if (hues.length === 0) return 180;
          const segments = new Array(12).fill(0);
          for (const hue of hues) {
            const segment = Math.floor(hue / 30);
            segments[segment]++;
          }
          const maxSegment = segments.indexOf(Math.max(...segments));
          return maxSegment * 30 + 15;
        }
        /**
         * Calculate contrast level between colors
         */
        calculateContrast(colors) {
          if (colors.length <= 1) return 0;
          let totalContrast = 0;
          let comparisons = 0;
          for (let i = 0; i < colors.length; i++) {
            for (let j = i + 1; j < colors.length; j++) {
              const color1 = colors[i];
              const color22 = colors[j];
              if (!color1 || !color22) continue;
              const rgb1 = this.utils.hexToRgb(color1);
              const rgb2 = this.utils.hexToRgb(color22);
              if (rgb1 && rgb2) {
                const lum1 = (rgb1.r * 0.299 + rgb1.g * 0.587 + rgb1.b * 0.114) / 255;
                const lum2 = (rgb2.r * 0.299 + rgb2.g * 0.587 + rgb2.b * 0.114) / 255;
                totalContrast += Math.abs(lum1 - lum2);
                comparisons++;
              }
            }
          }
          return comparisons > 0 ? totalContrast / comparisons : 0;
        }
        /**
         * Blend colors using advanced OKLAB processing for perceptually uniform results
         */
        async blendWithAdvancedOKLAB(rawColors, musicData, emotionalTemperature, genreData) {
          const processedColors = { ...rawColors };
          try {
            const optimalPreset = emotionalTemperature?.oklabPreset || this.oklabState.currentPreset;
            let genreAdjustedPreset = optimalPreset;
            if (genreData && genreData.confidence > 0.5 && this.genreState.genreInfluenceIntensity > 0) {
              genreAdjustedPreset = this.applyGenreColorAesthetics(
                optimalPreset,
                genreData
              );
            }
            const colorPriorities = [
              "PRIMARY",
              "VIBRANT",
              "PROMINENT",
              "VIBRANT_NON_ALARMING",
              "LIGHT_VIBRANT"
            ];
            for (const colorKey of colorPriorities) {
              const colorHex = rawColors[colorKey];
              if (colorHex && this.isValidHex(colorHex)) {
                try {
                  const genreKey = genreData ? `-${genreData.genre}` : "";
                  const cacheKey = `${colorHex}-${genreAdjustedPreset.name}${genreKey}`;
                  if (this.oklabState.processedPalette[cacheKey]) {
                    processedColors[colorKey] = this.oklabState.processedPalette[cacheKey].enhancedHex;
                    continue;
                  }
                  const adjustedColorHex = this.applyBrightnessModeMultipliers(colorHex);
                  const oklabResult = this.oklabProcessor.processColor(
                    adjustedColorHex,
                    genreAdjustedPreset
                  );
                  processedColors[colorKey] = oklabResult.enhancedHex;
                  this.oklabState.processedPalette[cacheKey] = oklabResult;
                  if (this.config?.enableDebug) {
                    console.log(
                      `\u{1F3A8} [ColorHarmonyEngine] OKLAB enhanced ${colorKey}:`,
                      {
                        original: colorHex,
                        enhanced: oklabResult.enhancedHex,
                        preset: optimalPreset.name,
                        processingTime: oklabResult.processingTime
                      }
                    );
                  }
                } catch (error) {
                  console.warn(
                    `[ColorHarmonyEngine] OKLAB processing failed for ${colorKey}:`,
                    error
                  );
                }
              }
            }
            if (emotionalTemperature?.perceptualColorHex && processedColors.PRIMARY) {
              try {
                const blendResult = this.oklabProcessor.interpolateOKLAB(
                  processedColors.PRIMARY,
                  emotionalTemperature.perceptualColorHex,
                  emotionalTemperature.intensity * 0.3,
                  // Blend factor based on intensity
                  optimalPreset
                );
                processedColors.EMOTIONAL_BLEND = blendResult.enhancedHex;
                if (this.config?.enableDebug) {
                  console.log("\u{1F321}\uFE0F [ColorHarmonyEngine] Emotional color blending:", {
                    primary: processedColors.PRIMARY,
                    emotionalColor: emotionalTemperature.perceptualColorHex,
                    blendFactor: emotionalTemperature.intensity * 0.3,
                    result: blendResult.enhancedHex
                  });
                }
              } catch (error) {
                console.warn(
                  "[ColorHarmonyEngine] Emotional color blending failed:",
                  error
                );
              }
            }
            this.oklabState.lastProcessingTime = Date.now();
            const albumArtInfluence = this.getAlbumArtInfluenceSetting();
            if (albumArtInfluence > 0 && rawColors && Object.keys(rawColors).length > 0) {
              try {
                const albumBlendedColors = await this._applyDirectAlbumColorBlending(
                  processedColors,
                  rawColors,
                  albumArtInfluence,
                  genreAdjustedPreset
                );
                Object.assign(processedColors, albumBlendedColors);
                if (this.config?.enableDebug) {
                  console.log(
                    "\u{1F3A8} [ColorHarmonyEngine] Applied direct album color blending:",
                    {
                      albumInfluence: (albumArtInfluence * 100).toFixed(1) + "%",
                      blendedKeys: Object.keys(albumBlendedColors),
                      note: "album colors now directly influence final UI colors"
                    }
                  );
                }
              } catch (error) {
                console.warn(
                  "[ColorHarmonyEngine] Direct album color blending failed:",
                  error
                );
              }
            }
            if (this.semanticColorManager) {
              try {
                this.semanticColorManager.updateWithAlbumColors(processedColors);
                if (this.config?.enableDebug) {
                  console.log(
                    "\u{1F3A8} [ColorHarmonyEngine] Applied comprehensive Spicetify variable updates via strategy pattern:",
                    {
                      processedColorCount: Object.keys(processedColors).length,
                      methodUsed: "blendWithAdvancedOKLAB"
                    }
                  );
                }
              } catch (error) {
                console.warn(
                  "[ColorHarmonyEngine] Failed to update Spicetify variables via strategy pattern:",
                  error
                );
              }
            }
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Advanced OKLAB blending failed:",
              error
            );
          }
          return processedColors;
        }
        /**
         * Apply progressive resistance to color intensity to prevent oversaturation
         * Uses asymptotic approach - harder to increase as limits are approached
         */
        applyProgressiveResistance(currentValue, multiplier, upperBound, lowerBound = 0) {
          const normalizedValue = (currentValue - lowerBound) / (upperBound - lowerBound);
          if (multiplier >= 1) {
            const resistance = Math.pow(normalizedValue, 2);
            const effectiveMultiplier = 1 + (multiplier - 1) * (1 - resistance);
            const result = currentValue * effectiveMultiplier;
            return Math.max(lowerBound, Math.min(result, upperBound));
          } else {
            const resistance = Math.pow(1 - normalizedValue, 2);
            const effectiveMultiplier = 1 - (1 - multiplier) * (1 - resistance);
            const result = currentValue * effectiveMultiplier;
            return Math.max(lowerBound, Math.min(result, upperBound));
          }
        }
        /**
         * Apply brightness mode multipliers from CSS variables to color processing
         * This ensures user brightness/saturation settings override base Catppuccin colors
         * Now includes progressive resistance to prevent oversaturation
         */
        applyBrightnessModeMultipliers(colorHex) {
          try {
            const computedStyle = getComputedStyle(document.documentElement);
            const saturationMultiplier = parseFloat(computedStyle.getPropertyValue("--sn-bg-gradient-saturation")) || 1;
            const brightnessMultiplier = parseFloat(computedStyle.getPropertyValue("--sn-bg-gradient-brightness")) || 1;
            const contrastMultiplier = parseFloat(computedStyle.getPropertyValue("--sn-bg-gradient-contrast")) || 1;
            if (saturationMultiplier === 1 && brightnessMultiplier === 1 && contrastMultiplier === 1) {
              return colorHex;
            }
            const rgb = this.utils.hexToRgb(colorHex);
            if (!rgb) return colorHex;
            const hsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
            if (!hsl) return colorHex;
            const adjustedHsl = {
              h: hsl.h,
              // Keep hue unchanged
              s: this.applyProgressiveResistance(hsl.s, saturationMultiplier, 85, 0),
              // Clamped saturation
              l: this.applyProgressiveResistance(hsl.l, brightnessMultiplier, 75, 15)
              // Clamped lightness
            };
            const adjustedRgb = this.utils.hslToRgb(adjustedHsl.h, adjustedHsl.s, adjustedHsl.l);
            const adjustedHex = adjustedRgb ? this.utils.rgbToHex(adjustedRgb.r, adjustedRgb.g, adjustedRgb.b) : colorHex;
            if (this.config?.enableDebug) {
              console.log(`\u{1F3A8} [ColorHarmonyEngine] Applied brightness mode multipliers:`, {
                original: colorHex,
                adjusted: adjustedHex,
                multipliers: { saturation: saturationMultiplier, brightness: brightnessMultiplier, contrast: contrastMultiplier },
                hslChange: { from: hsl, to: adjustedHsl }
              });
            }
            return adjustedHex;
          } catch (error) {
            console.warn("[ColorHarmonyEngine] Failed to apply brightness mode multipliers:", error);
            return colorHex;
          }
        }
        /**
         * Generate advanced CSS variables with comprehensive OKLAB integration
         */
        generateAdvancedOKLABCSSVariables(result) {
          const cssVariables = {};
          try {
            Object.entries(result.processedColors).forEach(([key, value]) => {
              if (value && typeof value === "string") {
                cssVariables[`--sn-processed-${key.toLowerCase()}`] = value;
              }
            });
            Object.entries(this.oklabState.processedPalette).forEach(
              ([cacheKey, oklabResult]) => {
                const [originalColor, presetName] = cacheKey.split("-");
                if (originalColor && presetName) {
                  const prefix = `sn-oklab-${presetName.toLowerCase()}`;
                  const oklabVars = this.oklabProcessor.generateCSSVariables(
                    oklabResult,
                    prefix
                  );
                  Object.assign(cssVariables, oklabVars);
                }
              }
            );
            if (this.oklabState.perceptualGradientCache.size > 0) {
              const gradientEntries = Array.from(
                this.oklabState.perceptualGradientCache.entries()
              );
              const [gradientKey, gradientStops] = gradientEntries[0] || [];
              if (gradientStops && gradientStops.length > 0) {
                gradientStops.forEach((stop, index) => {
                  const percentage = index / (gradientStops.length - 1) * 100;
                  cssVariables[`--sn-oklab-gradient-stop-${index}`] = stop.enhancedHex;
                  cssVariables[`--sn-oklab-gradient-stop-${index}-rgb`] = `${stop.enhancedRgb.r},${stop.enhancedRgb.g},${stop.enhancedRgb.b}`;
                  cssVariables[`--sn-oklab-gradient-stop-${index}-pos`] = `${percentage}%`;
                });
                const gradientString = gradientStops.map((stop, index) => {
                  const percentage = index / (gradientStops.length - 1) * 100;
                  return `${stop.enhancedHex} ${percentage}%`;
                }).join(", ");
                cssVariables["--sn-oklab-perceptual-gradient"] = `linear-gradient(135deg, ${gradientString})`;
                cssVariables["--sn-oklab-gradient-stop-count"] = gradientStops.length.toString();
              }
            }
            if (result.processedColors.EMOTIONAL_BLEND) {
              cssVariables["--sn-audioAnalysis-emotional-color"] = result.processedColors.EMOTIONAL_BLEND;
              const emotionalRgb = hexToRgb(
                result.processedColors.EMOTIONAL_BLEND
              );
              if (emotionalRgb) {
                cssVariables["--sn-audioAnalysis-emotional-rgb"] = `${emotionalRgb.r},${emotionalRgb.g},${emotionalRgb.b}`;
              }
            }
            cssVariables["--sn-oklab-preset-active"] = this.oklabState.currentPreset.name;
            cssVariables["--sn-oklab-cache-size"] = Object.keys(
              this.oklabState.processedPalette
            ).length.toString();
            cssVariables["--sn-oklab-last-processing"] = this.oklabState.lastProcessingTime.toString();
            if (this.config?.enableDebug) {
              console.log(
                "\u{1F3A8} [ColorHarmonyEngine] Generated advanced OKLAB CSS variables:",
                {
                  totalVariables: Object.keys(cssVariables).length,
                  gradientStops: this.oklabState.perceptualGradientCache.size,
                  oklabProcessedColors: Object.keys(this.oklabState.processedPalette).length
                }
              );
            }
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Advanced OKLAB CSS variable generation failed:",
              error
            );
          }
          return cssVariables;
        }
        /**
         * 🎨 PHASE 2 OPTIMIZATION: Generate pre-computed color variations for runtime animation
         *
         * This method eliminates expensive runtime CSS filters (hue-rotate, saturate, brightness)
         * by pre-computing color variations in OKLAB space when track changes occur.
         *
         * Performance Impact:
         * - Eliminates 15-25ms per frame from runtime filter calculations
         * - Pre-computation happens once per track change (~100ms one-time cost)
         * - Visual systems can lookup pre-computed variants instead of calculating
         *
         * @param result - Processed color result from track analysis
         * @returns CSS variables for pre-computed color variations
         */
        generateColorVariations(result) {
          const variations = {};
          try {
            const baseColorHex = result.accentHex;
            const trackUri = result.context?.trackUri || "";
            const cacheKey = `${trackUri}-${baseColorHex}`;
            if (this.oklabState.colorVariationCache.has(cacheKey)) {
              const cached = this.oklabState.colorVariationCache.get(cacheKey);
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F3A8} [ColorHarmonyEngine] Using cached color variations:",
                  { trackUri, baseColor: baseColorHex, variantCount: Object.keys(cached).length }
                );
              }
              return cached;
            }
            const baseRgb = this.utils.hexToRgb(baseColorHex);
            if (!baseRgb) {
              if (this.config.enableDebug) {
                console.warn("[ColorHarmonyEngine] Failed to parse base color for variations:", baseColorHex);
              }
              return variations;
            }
            const baseOklab = this.utils.rgbToOklab(baseRgb.r, baseRgb.g, baseRgb.b);
            const baseOklch = this.convertOklabToOklch(baseOklab);
            for (let i = 0; i < 16; i++) {
              const hueIndex = i % 4;
              const satIndex = Math.floor(i / 4);
              const hueOffset = -15 + hueIndex * (30 / 4);
              const saturationMultiplier = 0.7 + satIndex * (0.6 / 3);
              const variantOklch = {
                L: baseOklch.L,
                C: baseOklch.C * saturationMultiplier,
                // Saturation in chroma
                H: (baseOklch.H + hueOffset + 360) % 360
                // Hue rotation
              };
              const variantOklab = this.convertOklchToOklab(variantOklch);
              const variantRgb = this.utils.oklabToRgb(
                variantOklab.L,
                variantOklab.a,
                variantOklab.b
              );
              variations[`--sn-shimmer-variant-${i}-rgb`] = `${Math.round(variantRgb.r)},${Math.round(variantRgb.g)},${Math.round(variantRgb.b)}`;
            }
            for (let i = 0; i < 8; i++) {
              const hueOffset = -5 + i * 10 / 7;
              const atmosphereOklch = {
                L: baseOklch.L,
                C: baseOklch.C * 0.85,
                // Slightly desaturated for atmosphere
                H: (baseOklch.H + hueOffset + 360) % 360
              };
              const atmosphereOklab = this.convertOklchToOklab(atmosphereOklch);
              const atmosphereRgb = this.utils.oklabToRgb(
                atmosphereOklab.L,
                atmosphereOklab.a,
                atmosphereOklab.b
              );
              variations[`--sn-atmosphere-variant-${i}-rgb`] = `${Math.round(atmosphereRgb.r)},${Math.round(atmosphereRgb.g)},${Math.round(atmosphereRgb.b)}`;
            }
            if (trackUri && baseColorHex) {
              this.oklabState.colorVariationCache.set(cacheKey, variations);
              if (this.oklabState.colorVariationCache.size > 50) {
                const firstKey = this.oklabState.colorVariationCache.keys().next().value;
                if (firstKey) {
                  this.oklabState.colorVariationCache.delete(firstKey);
                }
              }
            }
            if (this.config.enableDebug) {
              console.log(
                "\u{1F3A8} [ColorHarmonyEngine] Generated color variations:",
                {
                  baseColor: baseColorHex,
                  trackUri: trackUri || "unknown",
                  shimmerVariants: 16,
                  atmosphereVariants: 8,
                  totalVariables: Object.keys(variations).length,
                  cached: true,
                  cacheSize: this.oklabState.colorVariationCache.size,
                  performanceNote: "Pre-computed to eliminate runtime filters"
                }
              );
            }
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Color variation generation failed:",
              error
            );
          }
          return variations;
        }
        /**
         * Convert OKLCH (cylindrical) to OKLAB (Cartesian)
         */
        convertOklchToOklab(oklch) {
          const L = oklch.L;
          const hueRadians = oklch.H * Math.PI / 180;
          const a = oklch.C * Math.cos(hueRadians);
          const b = oklch.C * Math.sin(hueRadians);
          return { L, a, b };
        }
        /**
         * Generate perceptual gradient data using OKLAB interpolation for smooth color transitions
         */
        generatePerceptualGradientData(result) {
          try {
            const primaryColor = result.processedColors.PRIMARY;
            const secondaryColor = result.processedColors.SECONDARY || result.processedColors.EMOTIONAL_BLEND;
            if (!primaryColor || !this.isValidHex(primaryColor)) {
              return;
            }
            const startColor = primaryColor;
            const endColor = secondaryColor && this.isValidHex(secondaryColor) ? secondaryColor : this.generateComplementaryColor(primaryColor);
            const gradientKey = `${startColor}-${endColor}-${this.oklabState.currentPreset.name}`;
            if (this.oklabState.perceptualGradientCache.has(gradientKey)) {
              return;
            }
            const stopCount = 7;
            const gradientStops = this.oklabProcessor.generateOKLABGradient(
              startColor,
              endColor,
              stopCount,
              this.oklabState.currentPreset
            );
            this.oklabState.perceptualGradientCache.set(gradientKey, gradientStops);
            if (this.oklabState.perceptualGradientCache.size > 10) {
              const firstKey = this.oklabState.perceptualGradientCache.keys().next().value;
              if (firstKey) {
                this.oklabState.perceptualGradientCache.delete(firstKey);
              }
            }
            if (this.config?.enableDebug) {
              console.log(
                "\u{1F308} [ColorHarmonyEngine] Generated perceptual gradient data:",
                {
                  startColor,
                  endColor,
                  stopCount,
                  preset: this.oklabState.currentPreset.name,
                  cacheKey: gradientKey,
                  cacheSize: this.oklabState.perceptualGradientCache.size
                }
              );
            }
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Perceptual gradient generation failed:",
              error
            );
          }
        }
        /**
         * Update advanced harmony metrics with comprehensive performance and quality tracking
         */
        updateAdvancedHarmonyMetrics(result, processingTime) {
          try {
            const primaryColor = result.processedColors.PRIMARY;
            const secondaryColor = result.processedColors.SECONDARY;
            let harmonyScore = 0.5;
            if (primaryColor && this.isValidHex(primaryColor)) {
              const primaryRgb = hexToRgb(primaryColor);
              if (primaryRgb) {
                const vibrancy = this.calculateColorVibrancy(primaryRgb);
                harmonyScore = Math.min(1, vibrancy * 0.8 + 0.2);
              }
            }
            const metrics = {
              processingTime,
              harmonyScore,
              oklabProcessedColors: Object.keys(this.oklabState.processedPalette).length,
              perceptualGradientsCached: this.oklabState.perceptualGradientCache.size,
              currentPreset: this.oklabState.currentPreset.name,
              lastUpdate: Date.now()
            };
            if (result.metadata) {
              result.metadata.advancedHarmonyMetrics = metrics;
            }
            if (this.config?.enableDebug) {
              console.log(
                "\u{1F4CA} [ColorHarmonyEngine] Advanced harmony metrics updated:",
                metrics
              );
            }
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Advanced harmony metrics update failed:",
              error
            );
          }
        }
        // ============================================================================
        // 🔧 UTILITY METHODS FOR ENHANCED OKLAB INTEGRATION
        // ============================================================================
        /**
         * Get preset selection reasoning for debugging
         */
        getPresetSelectionReason(musicData, context) {
          if (!musicData) return "No music data available";
          const { energy = 0.5, valence = 0.5 } = musicData;
          if (context.performanceHints?.preferLightweight)
            return "Performance optimization requested";
          if (energy > 0.8 && valence > 0.7) return "High energy + positive valence";
          if (energy > 0.7 && valence < 0.4) return "High energy + negative valence";
          if (energy < 0.3) return "Low energy music";
          return "Standard balanced processing";
        }
        /**
         * Generate complementary color for gradient endpoints
         */
        generateComplementaryColor(hexColor) {
          try {
            const rgb = hexToRgb(hexColor);
            if (!rgb) return hexColor;
            const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
            const complementHue = (hsl.h + 180) % 360;
            const complementRgb = this.hslToRgb(complementHue, hsl.s, hsl.l);
            return rgbToHex(
              complementRgb.r,
              complementRgb.g,
              complementRgb.b
            );
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Complementary color generation failed:",
              error
            );
            return hexColor;
          }
        }
        /**
         * Calculate color vibrancy metric (0-1)
         */
        calculateColorVibrancy(rgb) {
          const max = Math.max(rgb.r, rgb.g, rgb.b);
          const min = Math.min(rgb.r, rgb.g, rgb.b);
          const delta = max - min;
          if (max === 0) return 0;
          const saturation = delta / max;
          const lightness = max / 255;
          const lightnessFactor = 1 - Math.abs(lightness - 0.5) * 2;
          return saturation * lightnessFactor;
        }
        /**
         * Validate hex color format
         */
        isValidHex(hex) {
          return /^#[0-9A-Fa-f]{6}$/.test(hex);
        }
        /**
         * Convert RGB to HSL color space
         */
        rgbToHsl(r, g, b) {
          r /= 255;
          g /= 255;
          b /= 255;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const delta = max - min;
          let h = 0;
          let s = 0;
          const l = (max + min) / 2;
          if (delta !== 0) {
            s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
            switch (max) {
              case r:
                h = (g - b) / delta + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / delta + 2;
                break;
              case b:
                h = (r - g) / delta + 4;
                break;
            }
            h /= 6;
          }
          return { h: h * 360, s, l };
        }
        /**
         * Convert HSL to RGB color space
         */
        hslToRgb(h, s, l) {
          h /= 360;
          const hue2rgb = /* @__PURE__ */ __name((p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          }, "hue2rgb");
          let r, g, b;
          if (s === 0) {
            r = g = b = l;
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
          };
        }
        // ============================================================================
        // GENRE AESTHETIC INTELLIGENCE METHODS
        // ============================================================================
        /**
         * Analyze current music for genre-specific aesthetic characteristics
         */
        async analyzeGenreAesthetics(musicData, albumArtColors) {
          try {
            if (!this.genreProfileManager) {
              return null;
            }
            const currentGenre = this.genreProfileManager.getCurrentGenre();
            const genreConfidence = this.genreProfileManager.getGenreConfidence();
            if (genreConfidence < 0.3) {
              return null;
            }
            const genreCharacteristics = this.genreProfileManager.getCharacteristics(currentGenre);
            const genreVisualStyle = this.genreProfileManager.getVisualStyle(currentGenre);
            let albumGenreHarmonyScore = 1;
            let genreValidatedByAlbumColors = genreConfidence;
            if (albumArtColors && Object.keys(albumArtColors).length > 0) {
              try {
                const albumColorAnalysis = this._analyzeAlbumGenreHarmony(
                  albumArtColors,
                  currentGenre,
                  genreCharacteristics
                );
                albumGenreHarmonyScore = albumColorAnalysis.harmonyScore;
                genreValidatedByAlbumColors = genreConfidence * albumGenreHarmonyScore;
                if (this.config.enableDebug) {
                  console.log(
                    `\u{1F3A8} [ColorHarmonyEngine] Album-Genre harmony analysis:`,
                    {
                      genre: currentGenre,
                      originalConfidence: (genreConfidence * 100).toFixed(1) + "%",
                      harmonyScore: (albumGenreHarmonyScore * 100).toFixed(1) + "%",
                      validatedConfidence: (genreValidatedByAlbumColors * 100).toFixed(1) + "%",
                      albumColorCount: Object.keys(albumArtColors).length
                    }
                  );
                }
              } catch (error) {
                console.warn(
                  "[ColorHarmonyEngine] Album-genre harmony analysis failed:",
                  error
                );
              }
            }
            this.genreState.currentGenre = currentGenre;
            this.genreState.genreConfidence = genreValidatedByAlbumColors;
            this.genreState.lastGenreUpdate = Date.now();
            this.genreState.genreHistory.unshift({
              genre: currentGenre,
              confidence: genreValidatedByAlbumColors,
              // Use album-enhanced confidence
              timestamp: Date.now()
            });
            if (this.genreState.genreHistory.length > 10) {
              this.genreState.genreHistory = this.genreState.genreHistory.slice(
                0,
                10
              );
            }
            if (this.config.enableDebug) {
              console.log(
                `\u{1F3B6} [ColorHarmonyEngine] Genre aesthetic analysis: ${currentGenre} (${(genreValidatedByAlbumColors * 100).toFixed(1)}% album-validated confidence)`
              );
            }
            return {
              genre: currentGenre,
              confidence: genreValidatedByAlbumColors,
              // Return album-enhanced confidence
              characteristics: genreCharacteristics,
              visualStyle: genreVisualStyle
            };
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Error analyzing genre aesthetics:",
              error
            );
            return null;
          }
        }
        /**
         * Apply genre-specific characteristics to OKLAB color preset
         */
        applyGenreColorAesthetics(basePreset, genreData) {
          const { characteristics, visualStyle, confidence } = genreData;
          const genreAdjustedPreset = {
            ...basePreset,
            name: `${basePreset.name}-${genreData.genre}`,
            description: `${basePreset.description} with ${genreData.genre} aesthetic characteristics`
          };
          const genreInfluence = confidence * this.genreState.genreInfluenceIntensity;
          if (characteristics.saturation > 0.7) {
            genreAdjustedPreset.chromaBoost = Math.min(
              2,
              basePreset.chromaBoost + 0.3 * genreInfluence
            );
          } else if (characteristics.saturation < 0.3) {
            genreAdjustedPreset.chromaBoost = Math.max(
              0.8,
              basePreset.chromaBoost - 0.2 * genreInfluence
            );
          }
          if (characteristics.musicalComplexity > 0.7) {
            genreAdjustedPreset.vibrantThreshold = Math.max(
              0.05,
              basePreset.vibrantThreshold - 0.05 * genreInfluence
            );
          } else if (characteristics.musicalComplexity < 0.3) {
            genreAdjustedPreset.vibrantThreshold = Math.min(
              0.2,
              basePreset.vibrantThreshold + 0.03 * genreInfluence
            );
          }
          if (characteristics.emotionalRange > 0.7 && characteristics.smoothness > 0.6) {
            genreAdjustedPreset.lightnessBoost = Math.max(
              0.9,
              basePreset.lightnessBoost - 0.1 * genreInfluence
            );
          } else if (characteristics.artificialProcessing > 0.7) {
            genreAdjustedPreset.lightnessBoost = Math.min(
              1.4,
              basePreset.lightnessBoost + 0.2 * genreInfluence
            );
          }
          if (visualStyle.contrastLevel > 0.7) {
            genreAdjustedPreset.shadowReduction = Math.max(
              0.1,
              basePreset.shadowReduction - 0.1 * genreInfluence
            );
          } else if (characteristics.smoothness > 0.6) {
            genreAdjustedPreset.shadowReduction = Math.min(
              0.5,
              basePreset.shadowReduction + 0.1 * genreInfluence
            );
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F3A8} [ColorHarmonyEngine] Applied ${genreData.genre} aesthetics to ${basePreset.name} preset:`,
              {
                chromaBoost: `${basePreset.chromaBoost} \u2192 ${genreAdjustedPreset.chromaBoost}`,
                lightnessBoost: `${basePreset.lightnessBoost} \u2192 ${genreAdjustedPreset.lightnessBoost}`,
                vibrantThreshold: `${basePreset.vibrantThreshold} \u2192 ${genreAdjustedPreset.vibrantThreshold}`,
                genreInfluence: `${(genreInfluence * 100).toFixed(1)}%`
              }
            );
          }
          return genreAdjustedPreset;
        }
        /**
         * 🎨 PHASE 2.1: Analyze album color harmony with detected genre for enhanced validation
         */
        _analyzeAlbumGenreHarmony(albumArtColors, genre, genreCharacteristics) {
          try {
            let harmonyScore = 1;
            let explanationParts = [];
            const albumHslColors = Object.entries(albumArtColors).map(([role, hex]) => {
              const rgb = this.utils.hexToRgb(hex);
              return rgb ? this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b) : null;
            }).filter((hsl) => hsl !== null);
            if (albumHslColors.length === 0) {
              return {
                harmonyScore: 1,
                explanation: "No valid album colors found"
              };
            }
            const avgSaturation = albumHslColors.reduce((sum, hsl) => sum + hsl.s, 0) / albumHslColors.length;
            const expectedSaturation = genreCharacteristics.saturation || 0.5;
            const saturationDiff = Math.abs(avgSaturation / 100 - expectedSaturation);
            if (saturationDiff < 0.2) {
              harmonyScore *= 1.1;
              explanationParts.push(
                `album saturation matches genre (\xB1${(saturationDiff * 100).toFixed(
                  1
                )}%)`
              );
            } else if (saturationDiff > 0.4) {
              harmonyScore *= 0.85;
              explanationParts.push(
                `album saturation differs from genre expectations (${(saturationDiff * 100).toFixed(1)}% diff)`
              );
            }
            const avgHue = albumHslColors.reduce((sum, hsl) => sum + hsl.h, 0) / albumHslColors.length;
            const isWarmAlbum = avgHue >= 15 && avgHue <= 45 || avgHue >= 315 && avgHue <= 345;
            const isCoolAlbum = avgHue >= 180 && avgHue <= 270;
            const expectedWarmth = genreCharacteristics.energyLevel || 0.5;
            if (expectedWarmth > 0.6 && isWarmAlbum) {
              harmonyScore *= 1.15;
              explanationParts.push("warm album colors match high-energy genre");
            } else if (expectedWarmth < 0.4 && isCoolAlbum) {
              harmonyScore *= 1.1;
              explanationParts.push("cool album colors match low-energy genre");
            } else if (expectedWarmth > 0.6 && isCoolAlbum || expectedWarmth < 0.4 && isWarmAlbum) {
              harmonyScore *= 0.9;
              explanationParts.push(
                "album color temperature differs from genre energy"
              );
            }
            const avgLightness = albumHslColors.reduce((sum, hsl) => sum + hsl.l, 0) / albumHslColors.length;
            const isDarkAlbum = avgLightness < 40;
            const isBrightAlbum = avgLightness > 70;
            if (genre.includes("metal") || genre.includes("goth") || genre.includes("dark")) {
              if (isDarkAlbum) {
                harmonyScore *= 1.2;
                explanationParts.push("dark album aesthetic matches genre");
              } else if (isBrightAlbum) {
                harmonyScore *= 0.8;
                explanationParts.push(
                  "bright album conflicts with dark genre aesthetic"
                );
              }
            } else if (genre.includes("pop") || genre.includes("dance") || genre.includes("electronic")) {
              if (isBrightAlbum) {
                harmonyScore *= 1.15;
                explanationParts.push(
                  "bright album aesthetic matches energetic genre"
                );
              }
            }
            const colorHues = albumHslColors.map((hsl) => hsl.h);
            const hueSpread = Math.max(...colorHues) - Math.min(...colorHues);
            const isMonochromatic = hueSpread < 30;
            const isPolychromatic = hueSpread > 120;
            const expectedComplexity = genreCharacteristics.musicalComplexity || genreCharacteristics.harmonicComplexity || 0.5;
            if (expectedComplexity > 0.7 && isPolychromatic) {
              harmonyScore *= 1.1;
              explanationParts.push("diverse album colors match complex genre");
            } else if (expectedComplexity < 0.3 && isMonochromatic) {
              harmonyScore *= 1.1;
              explanationParts.push("unified album colors match simple genre");
            }
            harmonyScore = Math.max(0.7, Math.min(1.3, harmonyScore));
            const explanation = explanationParts.length > 0 ? explanationParts.join("; ") : "album colors analyzed for genre harmony";
            return {
              harmonyScore,
              explanation
            };
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Album-genre harmony analysis error:",
              error
            );
            return {
              harmonyScore: 1,
              explanation: "harmony analysis failed, using default confidence"
            };
          }
        }
        /**
         * 🎨 PHASE 2.2: Get album art influence setting (0-1) for user control
         */
        getAlbumArtInfluenceSetting() {
          return 0.5;
        }
        /**
         * 🎨 PHASE 2.2: Apply direct album color blending using OKLAB for perceptual uniformity
         */
        async _applyDirectAlbumColorBlending(processedColors, albumArtColors, albumInfluence, oklabPreset) {
          const blendedColors = {};
          try {
            const albumDominantColors = this._extractDominantAlbumColors(albumArtColors);
            if (albumDominantColors.length === 0) {
              return {};
            }
            const blendTargets = [
              "PRIMARY",
              "VIBRANT",
              "PROMINENT",
              "VIBRANT_NON_ALARMING"
            ];
            for (const colorKey of blendTargets) {
              const processedColor = processedColors[colorKey];
              if (!processedColor || !this.isValidHex(processedColor)) {
                continue;
              }
              try {
                const bestAlbumColor = this._selectHarmoniousAlbumColor(
                  processedColor,
                  albumDominantColors
                );
                if (bestAlbumColor) {
                  const blendResult = this.oklabProcessor.interpolateOKLAB(
                    processedColor,
                    bestAlbumColor,
                    albumInfluence * 0.6,
                    // Scale down for subtle but noticeable effect
                    oklabPreset
                  );
                  blendedColors[colorKey] = blendResult.enhancedHex;
                  if (this.config?.enableDebug) {
                    console.log(
                      `\u{1F3A8} [ColorHarmonyEngine] Album-blended ${colorKey}:`,
                      {
                        original: processedColor,
                        albumColor: bestAlbumColor,
                        blended: blendResult.enhancedHex,
                        blendFactor: (albumInfluence * 0.6).toFixed(2)
                      }
                    );
                  }
                }
              } catch (error) {
                console.warn(
                  `[ColorHarmonyEngine] Album blending failed for ${colorKey}:`,
                  error
                );
              }
            }
            if (albumDominantColors.length > 0 && albumInfluence > 0.3) {
              try {
                const mostVibrantAlbum = this._selectMostVibrantColor(albumDominantColors);
                if (mostVibrantAlbum) {
                  const albumAccentResult = this.oklabProcessor.processColor(
                    mostVibrantAlbum,
                    oklabPreset
                  );
                  blendedColors["ALBUM_ACCENT"] = albumAccentResult.enhancedHex;
                  if (this.config?.enableDebug) {
                    console.log("\u{1F3A8} [ColorHarmonyEngine] Created ALBUM_ACCENT:", {
                      source: mostVibrantAlbum,
                      enhanced: albumAccentResult.enhancedHex
                    });
                  }
                }
              } catch (error) {
                console.warn(
                  "[ColorHarmonyEngine] Album accent creation failed:",
                  error
                );
              }
            }
            return blendedColors;
          } catch (error) {
            console.error(
              "[ColorHarmonyEngine] Direct album color blending error:",
              error
            );
            return {};
          }
        }
        /**
         * 🎨 PHASE 2.2: Extract dominant colors from album art for blending
         */
        _extractDominantAlbumColors(albumArtColors) {
          const dominantColors = [];
          const colorPriorities = [
            "VIBRANT",
            "DOMINANT",
            "PRIMARY",
            "PROMINENT",
            "LIGHT_VIBRANT",
            "DARK_VIBRANT"
          ];
          for (const priority of colorPriorities) {
            const color3 = albumArtColors[priority];
            if (color3 && this.isValidHex(color3)) {
              dominantColors.push(color3);
            }
          }
          if (dominantColors.length < 3) {
            Object.values(albumArtColors).forEach((color3) => {
              if (color3 && this.isValidHex(color3) && !dominantColors.includes(color3)) {
                dominantColors.push(color3);
              }
            });
          }
          return dominantColors.slice(0, 5);
        }
        /**
         * 🎨 PHASE 2.2: Select the most harmonious album color for blending with a processed color
         */
        _selectHarmoniousAlbumColor(processedColor, albumColors) {
          if (albumColors.length === 0) return null;
          try {
            const processedRgb = this.utils.hexToRgb(processedColor);
            if (!processedRgb) return albumColors[0] || null;
            const processedHsl = this.utils.rgbToHsl(
              processedRgb.r,
              processedRgb.g,
              processedRgb.b
            );
            let bestColor = albumColors[0] || null;
            let bestHarmonyScore = 0;
            for (const albumColor of albumColors) {
              const albumRgb = this.utils.hexToRgb(albumColor);
              if (!albumRgb) continue;
              const albumHsl = this.utils.rgbToHsl(
                albumRgb.r,
                albumRgb.g,
                albumRgb.b
              );
              const hueDiff = Math.abs(processedHsl.h - albumHsl.h);
              const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);
              let harmonyScore = 0;
              if (normalizedHueDiff < 30) {
                harmonyScore = 0.9;
              } else if (normalizedHueDiff > 150 && normalizedHueDiff < 210) {
                harmonyScore = 0.8;
              } else if (normalizedHueDiff > 90 && normalizedHueDiff < 150) {
                harmonyScore = 0.6;
              } else {
                harmonyScore = 0.4;
              }
              const saturationDiff = Math.abs(processedHsl.s - albumHsl.s);
              if (saturationDiff < 20) {
                harmonyScore += 0.1;
              }
              if (harmonyScore > bestHarmonyScore) {
                bestHarmonyScore = harmonyScore;
                bestColor = albumColor;
              }
            }
            return bestColor;
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Harmonious color selection failed:",
              error
            );
            return albumColors[0] || null;
          }
        }
        /**
         * 🎨 PHASE 2.2: Select the most vibrant color from album colors
         */
        _selectMostVibrantColor(albumColors) {
          if (albumColors.length === 0) return null;
          try {
            let mostVibrant = albumColors[0] || null;
            let highestVibrancy = 0;
            for (const color3 of albumColors) {
              const rgb = this.utils.hexToRgb(color3);
              if (!rgb) continue;
              const hsl = this.utils.rgbToHsl(rgb.r, rgb.g, rgb.b);
              const vibrancy = hsl.s / 100 * (1 - Math.abs(hsl.l - 50) / 50);
              if (vibrancy > highestVibrancy) {
                highestVibrancy = vibrancy;
                mostVibrant = color3;
              }
            }
            return mostVibrant;
          } catch (error) {
            console.warn(
              "[ColorHarmonyEngine] Most vibrant color selection failed:",
              error
            );
            return albumColors[0] || null;
          }
        }
        /**
         * 🎨 PHASE 2.3: Analyze genre indicators from color psychology characteristics
         */
        _analyzeGenreIndicatorsFromColors(colorPsychology) {
          const {
            warmth,
            coolness,
            saturation,
            brightness,
            darkness,
            harmony,
            dominantHue,
            emotionalIntensity
          } = colorPsychology;
          const electronicLikelihood = Math.min(
            1,
            saturation * 0.4 + coolness * 0.3 + (brightness > 0.7 || darkness < 0.3 ? 0.2 : 0) + (dominantHue >= 180 && dominantHue <= 270 ? 0.1 : 0)
            // Blues/cyans
          );
          const smoothLikelihood = Math.min(
            1,
            (warmth > coolness ? warmth : 0) * 0.3 + (saturation >= 0.3 && saturation <= 0.7 ? 0.3 : 0) + (brightness >= 0.4 && brightness <= 0.7 ? 0.2 : 0) + harmony * 0.2
            // Natural colors tend to be harmonious
          );
          const metalHardcoreLikelihood = Math.min(
            1,
            darkness * 0.4 + emotionalIntensity * 0.3 + (dominantHue >= 0 && dominantHue <= 30 || dominantHue >= 330 ? 0.2 : 0) + // Reds
            (saturation > 0.6 || saturation < 0.2 ? 0.1 : 0)
            // High contrast
          );
          const popCommercialLikelihood = Math.min(
            1,
            (brightness > 0.6 ? brightness * 0.3 : 0) + saturation * 0.3 + (warmth > 0.5 ? warmth * 0.2 : 0) + (emotionalIntensity > 0.5 ? 0.2 : 0)
          );
          const jazzClassicalLikelihood = Math.min(
            1,
            harmony * 0.4 + (saturation >= 0.4 && saturation <= 0.8 ? 0.3 : 0) + (brightness >= 0.3 && brightness <= 0.8 ? 0.2 : 0) + (warmth + coolness) / 2 * 0.1
            // Balanced temperature
          );
          const folkAcousticLikelihood = Math.min(
            1,
            warmth * 0.4 + (saturation >= 0.2 && saturation <= 0.6 ? 0.3 : 0) + harmony * 0.2 + (dominantHue >= 15 && dominantHue <= 60 ? 0.1 : 0)
            // Earth tones (oranges/browns)
          );
          return {
            electronicLikelihood,
            smoothLikelihood,
            metalHardcoreLikelihood,
            popCommercialLikelihood,
            jazzClassicalLikelihood,
            folkAcousticLikelihood
          };
        }
        /**
         * 🎨 PHASE 2.3: Analyze artist audioAnalysis through color sophistication and intention
         */
        _analyzeArtistAwareness(colors, metrics) {
          const {
            avgSaturation,
            avgBrightness,
            harmony,
            emotionalIntensity,
            colorCount
          } = metrics;
          const visualSophistication = Math.min(
            1,
            harmony * 0.4 + // Good color relationships indicate sophistication
            (colorCount > 2 && colorCount <= 5 ? 0.3 : 0.1) + // Appropriate complexity
            (avgSaturation >= 0.3 && avgSaturation <= 0.8 ? 0.2 : 0) + // Balanced saturation
            (avgBrightness >= 0.2 && avgBrightness <= 0.8 ? 0.1 : 0)
            // Appropriate brightness range
          );
          const artisticIntention = Math.min(
            1,
            harmony * 0.5 + // Harmonious colors suggest intention
            emotionalIntensity * 0.3 + // Strong emotional content suggests purpose
            (colorCount >= 2 && colorCount <= 4 ? 0.2 : 0)
            // Focused palette suggests curation
          );
          const culturalIndicators = [];
          if (avgSaturation > 0.8 && emotionalIntensity > 0.7) {
            culturalIndicators.push("high-energy-culture");
          }
          if (harmony > 0.7 && avgSaturation < 0.6) {
            culturalIndicators.push("minimalist-aesthetic");
          }
          if (avgBrightness < 0.3 && emotionalIntensity > 0.6) {
            culturalIndicators.push("dark-artistic");
          }
          if (avgBrightness > 0.7 && avgSaturation > 0.6) {
            culturalIndicators.push("commercial-pop");
          }
          const emotionalDepth = Math.min(
            1,
            emotionalIntensity * 0.5 + (avgSaturation > 0.4 ? 0.2 : 0) + // Saturated colors convey more emotion
            (harmony > 0.5 ? 0.2 : 0) + // Harmonious colors suggest emotional maturity
            (colorCount >= 3 ? 0.1 : 0)
            // Multiple colors allow for emotional complexity
          );
          return {
            visualSophistication,
            artisticIntention,
            culturalIndicators,
            emotionalDepth
          };
        }
      };
      __name(_ColorHarmonyEngine, "ColorHarmonyEngine");
      /**
       * Canonical accent CSS custom property names.
       *  – `--sn-accent-hex`  : Hex string (e.g. "#cba6f7")
       *  – `--sn-accent-rgb`  : Comma-separated R,G,B channels (e.g. "203,166,247")
       *
       * These are written by the Year3000System colour pipeline and are considered
       * the single source-of-truth accent accessed by SCSS and visual systems.
       */
      _ColorHarmonyEngine.CANONICAL_HEX_VAR = "--sn-accent-hex";
      _ColorHarmonyEngine.CANONICAL_RGB_VAR = "--sn-accent-rgb";
      ColorHarmonyEngine = _ColorHarmonyEngine;
    }
  });

  // src-js/utils/platform/SpicetifyCompat.ts
  var _SpicetifyCompat, SpicetifyCompat;
  var init_SpicetifyCompat = __esm({
    "src-js/utils/platform/SpicetifyCompat.ts"() {
      "use strict";
      _SpicetifyCompat = class _SpicetifyCompat {
        /**
         * Get audio data with fallback handling
         * Uses correct Spicetify.getAudioData() API with fallback to legacy patterns
         */
        static async getAudioData() {
          try {
            if (typeof Spicetify !== "undefined" && Spicetify.getAudioData) {
              return await Spicetify.getAudioData();
            } else {
              console.warn("[SpicetifyCompat] Spicetify.getAudioData not available");
              return null;
            }
          } catch (error) {
            console.error("[SpicetifyCompat] Error fetching audio data:", error);
            return null;
          }
        }
        /**
         * Check if Spicetify APIs are available
         */
        static isAvailable() {
          return typeof Spicetify !== "undefined" && !!Spicetify.getAudioData;
        }
        /**
         * Retry wrapper for audio data fetching
         */
        static async getAudioDataWithRetry(retryDelay = 200, maxRetries = 10) {
          for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
              const audioData = await this.getAudioData();
              if (audioData) {
                return audioData;
              }
            } catch (error) {
              if (attempt < maxRetries - 1) {
                console.log(
                  `[SpicetifyCompat] Retrying audio data fetch (${attempt + 1}/${maxRetries})...`
                );
                await new Promise((resolve) => setTimeout(resolve, retryDelay));
              } else {
                console.warn(
                  `[SpicetifyCompat] Audio data fetch failed after ${maxRetries} attempts:`,
                  error
                );
              }
            }
          }
          return null;
        }
      };
      __name(_SpicetifyCompat, "SpicetifyCompat");
      SpicetifyCompat = _SpicetifyCompat;
    }
  });

  // src-js/audio/MusicSyncService.ts
  function safeGetSpicetify2() {
    return typeof window !== "undefined" && window.Spicetify ? window.Spicetify : null;
  }
  function isCosmosAsyncAvailable() {
    const spicetify = safeGetSpicetify2();
    return !!spicetify?.CosmosAsync;
  }
  var MUSIC_SYNC_CONFIG, _MusicSyncService, MusicSyncService;
  var init_MusicSyncService = __esm({
    "src-js/audio/MusicSyncService.ts"() {
      "use strict";
      init_globalConfig();
      init_UnifiedEventBus();
      init_ThemeUtilities();
      init_SpicetifyCompat();
      init_config();
      init_GenreProfileManager();
      init_OKLABColorProcessor();
      init_EmotionalTemperatureMapper();
      __name(safeGetSpicetify2, "safeGetSpicetify");
      __name(isCosmosAsyncAvailable, "isCosmosAsyncAvailable");
      MUSIC_SYNC_CONFIG = {
        enableDebug: true,
        enableBeatSynchronization: true,
        enableGenreAnalysis: true,
        enableMoodAdaptation: true,
        bpmCalculation: {
          useEnhancedAlgorithm: true,
          danceabilityWeight: 0.9,
          energyWeight: 0.6,
          bpmWeight: 0.6,
          energyThreshold: 0.5,
          danceabilityThreshold: 0.5,
          bpmThreshold: 0.8,
          maxBPM: 180,
          minBPM: 60
        },
        performance: {
          cacheSize: 100,
          cacheTTL: 3e5,
          maxRetries: 10,
          retryDelay: 200,
          enableMetrics: true,
          processingTimeTarget: 50
        },
        synchronization: {
          beatAccuracyTarget: 50,
          maxSyncDelay: 1e3,
          adaptiveQuality: true,
          predictiveCaching: true,
          debounceRapidChanges: 200
        },
        genreProfiles: {
          electronic: { intensityMultiplier: 1.2, precisionBoost: 1.1 },
          jazz: { smoothingFactor: 1.3, adaptiveVariation: true },
          classical: { gentleMode: true, tempoVariationHandling: "adaptive" },
          rock: { energyBoost: 1.15, consistentTiming: true },
          ambient: { subtleMode: true, intensityReduction: 0.7 },
          hiphop: { beatEmphasis: 1.25, rhythmPrecision: "high" },
          default: { balanced: true }
        },
        musicVisualSync: {
          enhancedBPM: {
            fallbacks: {
              tempo: 120,
              loudness: -5,
              key: 0,
              timeSignature: 4
            },
            danceabilityEstimation: {
              highDance: { min: 125, max: 145, value: 0.8 },
              mediumDance: { min: 100, max: 124, value: 0.7 },
              lowMediumDance: { min: 80, max: 99, value: 0.6 },
              lowDance: { value: 0.5 }
            },
            energyEstimation: {
              tempoRange: { min: 80, max: 160 },
              loudnessRange: { min: -15, max: 0 },
              tempoWeight: 0.6,
              loudnessWeight: 0.4
            }
          }
        }
      };
      _MusicSyncService = class _MusicSyncService {
        constructor(dependencies = {}) {
          this.isInitialized = false;
          this.currentTrack = null;
          this.audioData = null;
          this.currentTrackUri = null;
          this.latestProcessedData = null;
          // High-precision beat scheduling
          this.beatSchedulerTimer = null;
          // Phase 1: Song Change Debouncing
          this.songChangeDebounceTimer = null;
          this.nextBeatIndex = 0;
          this.currentSongBeats = [];
          this.songStartTimestamp = 0;
          this.metrics = {
            bpmCalculations: 0,
            beatSyncs: 0,
            cacheHits: 0,
            cacheMisses: 0,
            avgProcessingTime: 0,
            performance: [],
            errors: 0,
            updates: 0
          };
          this.unifiedCache = /* @__PURE__ */ new Map();
          this.subscribers = /* @__PURE__ */ new Map();
          this.beatSync = {
            lastBeatTime: 0,
            nextBeatTime: 0,
            beatInterval: 0,
            confidence: 0,
            isActive: false
          };
          this.performanceInterval = null;
          this.cacheCleanupInterval = null;
          // Increment this prefix whenever cache schema changes to avoid stale data
          this.CACHE_KEY_VERSION_PREFIX = "v3";
          // Phase 1: Event Processing State Tracking for Loop Prevention
          this.eventProcessingState = {
            isProcessingEvent: false,
            eventChain: [],
            lastEventTime: 0,
            consecutiveEvents: 0
          };
          this.MAX_CONSECUTIVE_EVENTS = 5;
          this.EVENT_RESET_TIMEOUT = 3e3;
          /** Current unit beat direction vector (updated each beat). */
          this.currentBeatVector = { x: 0, y: 0 };
          this.config = dependencies.ADVANCED_SYSTEM_CONFIG || dependencies.YEAR3000_CONFIG || ADVANCED_SYSTEM_CONFIG;
          this.utils = dependencies.ThemeUtilities || ThemeUtilities_exports;
          this.settingsManager = dependencies.settingsManager || null;
          this.year3000System = dependencies.year3000System || null;
          this.genreProfileManager = dependencies.genreProfileManager || new GenreProfileManager({ ADVANCED_SYSTEM_CONFIG: this.config });
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.emotionalTemperatureMapper = new EmotionalTemperatureMapper(this.config.enableDebug);
          this.cacheTTL = MUSIC_SYNC_CONFIG.performance.cacheTTL;
          this.userPreferences = this.loadUserPreferences();
          if (this.config.enableDebug) {
            console.log("\u{1F3B5} MusicSyncService constructor called");
            console.log(
              "\u{1F3B5} [MusicSyncService] Initialized with GenreProfileManager support"
            );
          }
        }
        /**
         * Public getter for initialization status (required for AdaptivePerformanceSystem dependency validation)
         */
        get initialized() {
          return this.isInitialized;
        }
        async initialize() {
          try {
            if (this.config.enableDebug) {
              console.log("\u{1F3B5} Initializing unified MusicSyncService...");
            }
            if (!SpicetifyCompat.isAvailable()) {
              console.warn(
                "[MusicSyncService] Spicetify audio data API not available at initialization. Some features may be limited."
              );
            }
            this.setupCacheManagement();
            if (MUSIC_SYNC_CONFIG.performance.enableMetrics) {
              this.setupPerformanceMonitoring();
            }
            this.isInitialized = true;
            if (this.config.enableDebug) {
              console.log("\u{1F31F} MusicSyncService initialized successfully!");
            }
          } catch (error) {
            console.error("\u274C MusicSyncService initialization failed:", error);
            this.metrics.errors++;
          }
        }
        // === SUBSCRIBER MANAGEMENT ===
        subscribe(systemInstance, systemName) {
          if (!systemInstance || typeof systemInstance.updateFromMusicAnalysis !== "function") {
            console.warn(
              `[MusicSyncService] Invalid system or missing updateFromMusicAnalysis method: ${systemName}`
            );
            return;
          }
          if (this.subscribers.has(systemName)) {
            if (this.config.enableDebug) {
              console.warn(
                `[MusicSyncService] System ${systemName} already subscribed.`
              );
            }
            return;
          }
          this.subscribers.set(systemName, systemInstance);
          if (this.config.enableDebug) {
            console.log(`[MusicSyncService] System subscribed: ${systemName}`);
          }
          if (this.latestProcessedData && systemInstance.initialized) {
            try {
              systemInstance.updateFromMusicAnalysis(
                this.latestProcessedData,
                null,
                this.currentTrackUri
              );
            } catch (error) {
              console.error(
                `[MusicSyncService] Error notifying new subscriber ${systemName}:`,
                error
              );
            }
          }
        }
        unsubscribe(systemName) {
          if (this.subscribers.has(systemName)) {
            this.subscribers.delete(systemName);
            if (this.config.enableDebug) {
              console.log(`[MusicSyncService] System unsubscribed: ${systemName}`);
            }
          }
        }
        notifySubscribers(processedData, rawFeatures, trackUri) {
          if (!this.isInitialized) {
            console.warn(
              "[MusicSyncService] Not initialized, cannot notify subscribers."
            );
            return;
          }
          this.latestProcessedData = processedData;
          for (const [name, system] of this.subscribers) {
            try {
              if (system.initialized && typeof system.updateFromMusicAnalysis === "function") {
                system.updateFromMusicAnalysis(processedData, rawFeatures, trackUri);
              }
            } catch (error) {
              console.error(
                `[MusicSyncService] Error notifying subscriber ${name}:`,
                error
              );
              this.metrics.errors++;
            }
          }
        }
        // === DATA FETCHING & CACHING ===
        async fetchAudioData(options = {}) {
          const {
            retryDelay = MUSIC_SYNC_CONFIG.performance.retryDelay,
            maxRetries = MUSIC_SYNC_CONFIG.performance.maxRetries
          } = options;
          const spicetify = safeGetSpicetify2();
          const currentTrackUri = spicetify?.Player?.data?.item?.uri;
          if (!currentTrackUri) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] No current track URI to fetch audio data."
              );
            }
            return null;
          }
          const cacheKey = this.generateCacheKey(currentTrackUri, "audioData");
          const cached = this.getFromCache(cacheKey);
          if (cached?.audioData) {
            if (this.isValidAudioData(cached.audioData)) {
              this.metrics.cacheHits++;
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Cache hit for audioData: ${cacheKey}`
                );
              }
              return cached.audioData;
            }
            this.unifiedCache.delete(cacheKey);
          }
          this.metrics.cacheMisses++;
          for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
              const spicetifyAudioData = await SpicetifyCompat.getAudioData();
              if (!spicetifyAudioData) continue;
              const audioData = this.convertSpicetifyToAudioData(spicetifyAudioData);
              if (this.isValidAudioData(audioData)) {
                this.setInCache(cacheKey, { audioData });
                return audioData;
              }
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Audio analysis unavailable (attempt ${attempt + 1}/${maxRetries}). Retrying\u2026`
                );
              }
            } catch (error) {
              if (attempt === maxRetries - 1) {
                if (this.config.enableDebug) {
                  console.warn(
                    `[MusicSyncService] Audio data fetch error on final attempt:`,
                    error
                  );
                }
                this.metrics.errors++;
                const fallback = {
                  tempo: 120,
                  energy: 0.5,
                  valence: 0.5,
                  loudness: -10,
                  key: 0,
                  time_signature: 4,
                  danceability: 0.5,
                  acousticness: 0.5,
                  instrumentalness: 0,
                  speechiness: 0.05,
                  liveness: 0.2,
                  mode: 1
                };
                if (this.config.enableDebug) {
                  console.warn(
                    `[MusicSyncService] All audio-data attempts failed \u2013 using fallback defaults`
                  );
                }
                return fallback;
              }
            }
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
          }
          return null;
        }
        async getAudioFeatures() {
          try {
            const spicetify = safeGetSpicetify2();
            const currentTrack = spicetify?.Player?.data?.item;
            if (!currentTrack?.uri) return null;
            const trackId = currentTrack.uri.split(":")[2] || "fallback";
            const cacheKey = this.generateCacheKey(trackId, "features");
            const cached = this.getFromCache(
              cacheKey
            );
            if (cached?.audioFeatures) {
              this.metrics.cacheHits++;
              if (this.config.enableDebug) {
                console.log(
                  `[MusicSyncService] Cache hit for audioFeatures: ${cacheKey}`
                );
              }
              return cached.audioFeatures;
            }
            this.metrics.cacheMisses++;
            const spicetifyForCosmos = safeGetSpicetify2();
            if (!isCosmosAsyncAvailable() || !spicetifyForCosmos?.CosmosAsync) {
              throw new Error("CosmosAsync not available");
            }
            const response = await spicetifyForCosmos.CosmosAsync.get(
              `https://api.spotify.com/v1/audio-features/${trackId}`
            );
            const features = {
              danceability: response.danceability,
              energy: response.energy,
              valence: response.valence,
              acousticness: response.acousticness,
              instrumentalness: response.instrumentalness,
              tempo: response.tempo
            };
            this.setInCache(cacheKey, { audioFeatures: features });
            return features;
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] Could not fetch audio features:",
                error
              );
            }
            return null;
          }
        }
        generateCacheKey(identifier, type = "default") {
          return `${this.CACHE_KEY_VERSION_PREFIX}-${identifier}-${type}`;
        }
        getFromCache(key) {
          const cached = this.unifiedCache.get(key);
          if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
            return cached.data;
          }
          if (cached) {
            this.unifiedCache.delete(key);
          }
          return null;
        }
        setInCache(key, data) {
          this.unifiedCache.set(key, {
            data,
            timestamp: Date.now()
          });
        }
        // === ENHANCED BPM CALCULATION ===
        async calculateEnhancedBPM(audioData, options = {}) {
          const startTime = performance.now();
          try {
            if (!audioData?.tempo) {
              if (this.config.enableDebug) {
                console.warn("[MusicSyncService] No BPM data available for track");
              }
              return this.getFallbackBPM();
            }
            const trackBPM = audioData.tempo;
            const config = {
              ...MUSIC_SYNC_CONFIG.bpmCalculation,
              ...options
            };
            const audioFeatures = await this.getAudioFeatures();
            if (!audioFeatures) {
              if (this.config.enableDebug) {
                console.log("[MusicSyncService] Using basic BPM calculation");
              }
              return this.validateBPM(trackBPM);
            }
            const { danceability, energy, valence = 0.5 } = audioFeatures;
            if (this.config.enableDebug) {
              console.log(
                `[MusicSyncService] Audio features - Danceability: ${danceability}, Energy: ${energy}, Valence: ${valence}`
              );
            }
            const profile = this.genreProfileManager.getProfileForTrack(
              audioFeatures || void 0
            );
            const detectedGenre = this.genreProfileManager.detectGenre(
              audioFeatures || void 0
            );
            const enhancedBPM = this.computeAdvancedBPM({
              trackBPM,
              danceability,
              energy,
              valence,
              config,
              profile
            });
            const spicetify = safeGetSpicetify2();
            const currentTrack = spicetify?.Player?.data?.item || spicetify?.Player?.data;
            const uriParts = currentTrack?.uri?.split(":") ?? [];
            const trackId = uriParts.length > 2 && uriParts[2] ? uriParts[2] : "fallback";
            const cacheKey = this.generateCacheKey(trackId, "bpm");
            this.setInCache(cacheKey, {
              bpm: enhancedBPM,
              audioFeatures
            });
            this.metrics.bpmCalculations++;
            if (this.config.enableDebug) {
              console.log(
                `[MusicSyncService] Enhanced BPM: ${enhancedBPM} (original: ${trackBPM})`
              );
            }
            return enhancedBPM;
          } catch (error) {
            console.error("[MusicSyncService] BPM calculation failed:", error);
            this.metrics.errors++;
            return this.getFallbackBPM();
          }
        }
        computeAdvancedBPM(params) {
          const { trackBPM, danceability, energy, valence, config, profile } = params;
          const {
            danceabilityWeight,
            energyWeight,
            bpmWeight,
            energyThreshold,
            danceabilityThreshold,
            bpmThreshold,
            maxBPM,
            minBPM
          } = config;
          const normalizedBPM = Math.min(trackBPM / 120, 2);
          let adjustedDanceabilityWeight = danceabilityWeight;
          let adjustedEnergyWeight = energyWeight;
          let adjustedBpmWeight = bpmWeight;
          if (danceability < danceabilityThreshold) {
            adjustedDanceabilityWeight *= danceability;
          }
          if (energy < energyThreshold) {
            adjustedEnergyWeight *= energy;
          }
          if (normalizedBPM < bpmThreshold) {
            adjustedBpmWeight = 0.9;
          }
          let valenceInfluence = 1;
          if (valence > 0.6) {
            valenceInfluence = 1.05;
          } else if (valence < 0.4 && energy < 0.5) {
            valenceInfluence = 0.95;
          }
          const weightSum = adjustedDanceabilityWeight + adjustedEnergyWeight + adjustedBpmWeight;
          const weightedAverage = (danceability * adjustedDanceabilityWeight + energy * adjustedEnergyWeight + normalizedBPM * adjustedBpmWeight) / weightSum;
          let enhancedBPM = weightedAverage * 120 * valenceInfluence;
          if (profile.beatEmphasis) {
            enhancedBPM *= profile.beatEmphasis;
          }
          enhancedBPM = Math.max(minBPM, Math.min(maxBPM, enhancedBPM));
          return Math.round(enhancedBPM * 100) / 100;
        }
        validateBPM(bpm) {
          const { minBPM, maxBPM } = MUSIC_SYNC_CONFIG.bpmCalculation;
          return Math.max(minBPM, Math.min(maxBPM * 2, Math.round(bpm * 100) / 100));
        }
        getFallbackBPM() {
          return 75;
        }
        // === FEATURE ESTIMATION & FALLBACKS ===
        estimateDanceabilityFromTempo(tempo) {
          const config = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.danceabilityEstimation;
          if (tempo >= config.highDance.min && tempo <= config.highDance.max) {
            return config.highDance.value;
          }
          if (tempo >= config.mediumDance.min && tempo <= config.mediumDance.max) {
            return config.mediumDance.value;
          }
          if (tempo >= config.lowMediumDance.min && tempo <= config.lowMediumDance.max) {
            return config.lowMediumDance.value;
          }
          return config.lowDance.value;
        }
        estimateEnergyFromTempoLoudness(tempo, loudness) {
          const config = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.energyEstimation;
          const tempoFactor = Math.max(
            0,
            Math.min(
              1,
              (tempo - config.tempoRange.min) / (config.tempoRange.max - config.tempoRange.min)
            )
          );
          const loudnessFactor = Math.max(
            0,
            Math.min(
              1,
              (loudness - config.loudnessRange.min) / (config.loudnessRange.max - config.loudnessRange.min)
            )
          );
          return tempoFactor * config.tempoWeight + loudnessFactor * config.loudnessWeight;
        }
        estimateValenceFromKey(key) {
          const majorKeys = [0, 2, 4, 5, 7, 9, 11];
          return majorKeys.includes(key) ? 0.6 : 0.4;
        }
        getFallbackProcessedData(trackUri) {
          const fallbacks = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks;
          const fallbackBeatInterval = 6e4 / fallbacks.tempo;
          return {
            trackUri,
            timestamp: Date.now(),
            tempo: fallbacks.tempo,
            loudness: fallbacks.loudness,
            key: fallbacks.key,
            timeSignature: fallbacks.timeSignature,
            estimatedDanceability: this.estimateDanceabilityFromTempo(
              fallbacks.tempo
            ),
            estimatedEnergy: this.estimateEnergyFromTempoLoudness(
              fallbacks.tempo,
              fallbacks.loudness
            ),
            estimatedValence: 0.5,
            energy: 0.5,
            valence: 0.5,
            processedEnergy: 0.5,
            visualIntensity: 0.5,
            moodIdentifier: "neutral",
            baseBPM: fallbacks.tempo,
            enhancedBPM: fallbacks.tempo,
            beatInterval: fallbackBeatInterval,
            bmpCalculationMethod: "fallback",
            dataSource: "fallback"
          };
        }
        // === OKLAB-ENHANCED COLOR PROCESSING ===
        /**
         * Create OKLAB-enhanced fallback colors based on music emotional context
         * Uses EmotionalTemperatureMapper to determine appropriate emotional state and OKLAB processing
         */
        async createOKLABEnhancedFallbackColors(audioFeatures) {
          const baseFallbackColors = {
            VIBRANT: "#f2cdcd",
            // Catppuccin rosewater
            DARK_VIBRANT: "#cba6f7",
            // Catppuccin mauve  
            LIGHT_VIBRANT: "#f5c2e7",
            // Catppuccin pink
            PROMINENT: "#cba6f7",
            // Catppuccin mauve
            VIBRANT_NON_ALARMING: "#f2cdcd",
            // Catppuccin rosewater
            DESATURATED: "#9399b2"
            // Catppuccin overlay1
          };
          if (!audioFeatures || typeof audioFeatures.energy !== "number" || typeof audioFeatures.valence !== "number") {
            const standardPreset = OKLABColorProcessor.getPreset("STANDARD");
            const processedColors2 = {};
            for (const [key, color3] of Object.entries(baseFallbackColors)) {
              try {
                const oklabResult = this.oklabProcessor.processColor(color3, standardPreset);
                processedColors2[key] = oklabResult.enhancedHex;
              } catch (error) {
                if (this.config.enableDebug) {
                  console.warn(`\u{1F3A8} [MusicSyncService] OKLAB processing failed for ${key}:`, error);
                }
                processedColors2[key] = color3;
              }
            }
            return processedColors2;
          }
          const musicAnalysisData = {
            energy: audioFeatures.energy,
            valence: audioFeatures.valence,
            danceability: audioFeatures.danceability,
            tempo: audioFeatures.tempo,
            mode: audioFeatures.mode,
            genre: this.genreProfileManager.detectGenre(audioFeatures)
          };
          const emotionalResult = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(musicAnalysisData);
          let preset;
          if (emotionalResult.intensity >= 1) {
            preset = OKLABColorProcessor.getPreset("COSMIC");
          } else if (emotionalResult.intensity >= 0.7) {
            preset = OKLABColorProcessor.getPreset("VIBRANT");
          } else if (emotionalResult.intensity >= 0.5) {
            preset = OKLABColorProcessor.getPreset("STANDARD");
          } else {
            preset = OKLABColorProcessor.getPreset("SUBTLE");
          }
          const processedColors = {};
          for (const [key, color3] of Object.entries(baseFallbackColors)) {
            try {
              const oklabResult = this.oklabProcessor.processColor(color3, preset);
              processedColors[key] = oklabResult.enhancedHex;
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn(`\u{1F3A8} [MusicSyncService] OKLAB processing failed for ${key}:`, error);
              }
              processedColors[key] = color3;
            }
          }
          processedColors["--sn-emotional-primary"] = emotionalResult.perceptualColorHex || emotionalResult.primaryEmotion;
          processedColors["--sn-emotional-intensity"] = emotionalResult.intensity.toString();
          processedColors["--sn-emotional-preset"] = preset.name;
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [MusicSyncService] Created OKLAB-enhanced fallback colors:", {
              emotion: emotionalResult.primaryEmotion,
              intensity: emotionalResult.intensity,
              preset: preset.name,
              oklabCoordination: processedColors,
              musicContext: { energy: audioFeatures.energy, valence: audioFeatures.valence }
            });
          }
          return processedColors;
        }
        /**
         * Enhance successfully extracted colors with OKLAB processing based on music emotional context
         * Applies perceptually uniform color processing while preserving the original color relationships
         */
        async enhanceExtractedColorsWithOKLAB(extractedColors, audioFeatures) {
          const enhancedColors = {};
          let preset = OKLABColorProcessor.getPreset("STANDARD");
          if (audioFeatures && typeof audioFeatures.energy === "number" && typeof audioFeatures.valence === "number") {
            const musicAnalysisData = {
              energy: audioFeatures.energy,
              valence: audioFeatures.valence,
              danceability: audioFeatures.danceability,
              tempo: audioFeatures.tempo,
              mode: audioFeatures.mode,
              genre: this.genreProfileManager.detectGenre(audioFeatures)
            };
            const emotionalResult = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(musicAnalysisData);
            if (emotionalResult.intensity >= 1) {
              preset = OKLABColorProcessor.getPreset("COSMIC");
            } else if (emotionalResult.intensity >= 0.7) {
              preset = OKLABColorProcessor.getPreset("VIBRANT");
            } else if (emotionalResult.intensity >= 0.5) {
              preset = OKLABColorProcessor.getPreset("STANDARD");
            } else {
              preset = OKLABColorProcessor.getPreset("SUBTLE");
            }
            enhancedColors["--sn-emotional-primary"] = emotionalResult.perceptualColorHex || `oklabColorProcessor-${emotionalResult.primaryEmotion}`;
            enhancedColors["--sn-emotional-intensity"] = emotionalResult.intensity.toString();
            enhancedColors["--sn-emotional-temperature"] = emotionalResult.temperature.toString();
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [MusicSyncService] Applying OKLAB enhancement with emotional context:", {
                emotion: emotionalResult.primaryEmotion,
                intensity: emotionalResult.intensity,
                preset: preset.name,
                colorCount: Object.keys(extractedColors).length
              });
            }
          }
          for (const [key, color3] of Object.entries(extractedColors)) {
            if (!color3 || typeof color3 !== "string" || !color3.startsWith("#")) {
              enhancedColors[key] = color3;
              continue;
            }
            try {
              const oklabResult = this.oklabProcessor.processColor(color3, preset);
              enhancedColors[key] = oklabResult.enhancedHex;
              enhancedColors[`${key}-oklab-l`] = oklabResult.oklabEnhanced.L.toFixed(3);
              enhancedColors[`${key}-oklab-a`] = oklabResult.oklabEnhanced.a.toFixed(3);
              enhancedColors[`${key}-oklab-b`] = oklabResult.oklabEnhanced.b.toFixed(3);
              enhancedColors[`${key}-oklch-c`] = oklabResult.oklchEnhanced.C.toFixed(3);
              enhancedColors[`${key}-oklch-h`] = oklabResult.oklchEnhanced.H.toFixed(1);
            } catch (error) {
              if (this.config.enableDebug) {
                console.warn(`\u{1F3A8} [MusicSyncService] OKLAB processing failed for ${key} (${color3}):`, error);
              }
              enhancedColors[key] = color3;
            }
          }
          enhancedColors["--sn-oklab-preset"] = preset.name;
          enhancedColors["--sn-oklab-enhanced"] = "true";
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [MusicSyncService] OKLAB color enhancement completed:", {
              originalCount: Object.keys(extractedColors).length,
              enhancedCount: Object.keys(enhancedColors).length,
              preset: preset.name,
              sampleEnhanced: {
                original: extractedColors.VIBRANT || extractedColors[Object.keys(extractedColors)[0] || ""],
                enhanced: enhancedColors.VIBRANT || enhancedColors[Object.keys(enhancedColors)[0] || ""]
              }
            });
          }
          return enhancedColors;
        }
        // === MAIN PROCESSING PIPELINE ===
        async processAudioFeatures(rawSpicetifyAudioFeatures, trackUri, trackDurationMs) {
          if (!this.isInitialized) {
            console.warn("[MusicSyncService] Not initialized, skipping processing.");
            return;
          }
          this.stopBeatScheduler();
          this.currentTrackUri = trackUri;
          const cacheKey = this.generateCacheKey(trackUri, "processed");
          const cached = this.getFromCache(cacheKey);
          if (cached?.processedData) {
            this.notifySubscribers(cached.processedData, null, trackUri);
            return;
          }
          try {
            let audioAnalysisData = rawSpicetifyAudioFeatures;
            if (!audioAnalysisData) {
              audioAnalysisData = await this.fetchAudioData();
            }
            if (!audioAnalysisData) {
              throw new Error("Failed to fetch or receive audio data.");
            }
            if (audioAnalysisData.beats && audioAnalysisData.beats.length > 0) {
              this.currentSongBeats = audioAnalysisData.beats;
              this.songStartTimestamp = Date.now();
              this.nextBeatIndex = 0;
              this.scheduleNextBeatEvent();
            }
            const enhancedBPM = await this.calculateEnhancedBPM(audioAnalysisData);
            const beatInterval = enhancedBPM > 0 ? 6e4 / enhancedBPM : 0;
            const trackData = audioAnalysisData;
            const {
              tempo = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.tempo,
              loudness = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.loudness,
              key = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.key,
              time_signature: timeSignature = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks.timeSignature
            } = trackData;
            const audioFeatures = await this.getAudioFeatures();
            const estimatedDanceability = audioFeatures?.danceability ?? this.estimateDanceabilityFromTempo(tempo);
            const estimatedEnergy = audioFeatures?.energy ?? this.estimateEnergyFromTempoLoudness(tempo, loudness);
            const estimatedValence = audioFeatures?.valence ?? this.estimateValenceFromKey(key);
            const artisticMultipliers = this.config.getCurrentMultipliers?.() || {
              musicEnergyBoost: 1,
              visualIntensityBase: 1
            };
            const processedEnergy = Math.max(
              0.1,
              Math.min(
                1,
                estimatedEnergy * (artisticMultipliers.musicEnergyBoost || 1)
              )
            );
            const baseIntensity = estimatedEnergy * 0.6 + estimatedDanceability * 0.4;
            const visualIntensity = baseIntensity * (artisticMultipliers.visualIntensityBase || 1);
            let moodIdentifier = "neutral";
            if (estimatedValence > 0.6 && estimatedEnergy > 0.6) {
              moodIdentifier = "energetic-happy";
            } else if (estimatedValence > 0.6 && estimatedEnergy <= 0.6) {
              moodIdentifier = "calm-happy";
            } else if (estimatedValence <= 0.4 && estimatedEnergy > 0.6) {
              moodIdentifier = "intense-moody";
            } else if (estimatedValence <= 0.4 && estimatedEnergy <= 0.4) {
              moodIdentifier = "calm-melancholy";
            }
            const animationSpeedFactor = Math.max(0.5, 0.8 + visualIntensity * 0.4);
            const genreTag = this.genreProfileManager.detectGenre(
              audioFeatures || void 0
            );
            const processedData = {
              trackUri,
              timestamp: Date.now(),
              tempo,
              loudness,
              key,
              timeSignature,
              duration: trackDurationMs,
              estimatedDanceability,
              estimatedEnergy,
              estimatedValence,
              energy: estimatedEnergy,
              valence: estimatedValence,
              processedEnergy,
              visualIntensity,
              moodIdentifier,
              baseBPM: tempo,
              enhancedBPM,
              beatInterval,
              bmpCalculationMethod: "unified-service",
              dataSource: "unified-music-sync-service",
              beatOccurred: false,
              animationSpeedFactor,
              genre: genreTag
            };
            this.setInCache(cacheKey, { processedData });
            this.latestProcessedData = processedData;
            if (this.config.enableDebug) {
              console.log("\u{1F3B5} [MusicSyncService] Processed music data:", {
                baseTempo: tempo,
                enhancedBPM,
                mood: moodIdentifier,
                energy: estimatedEnergy.toFixed(2),
                visualIntensity: visualIntensity.toFixed(2)
              });
            }
            this.notifySubscribers(
              processedData,
              rawSpicetifyAudioFeatures,
              trackUri
            );
            unifiedEventBus.emitSync("music:beat", {
              bpm: processedData.enhancedBPM,
              intensity: processedData.visualIntensity,
              timestamp: performance.now(),
              confidence: 0.8
            });
            unifiedEventBus.emitSync("music:energy", {
              energy: processedData.energy || 0.5,
              valence: processedData.valence || 0.5,
              tempo: processedData.enhancedBPM,
              timestamp: performance.now()
            });
            unifiedEventBus.emitSync("performance:frame", {
              deltaTime: 16,
              // Approximate frame time
              fps: 60,
              memoryUsage: performance.memory?.usedJSHeapSize || 0,
              timestamp: performance.now()
            });
            if (this.config.enableDebug) {
              console.log(
                "[MusicSyncService] Successfully processed audio features.",
                {
                  baseTempo: tempo,
                  enhancedBPM,
                  mood: moodIdentifier,
                  energy: estimatedEnergy.toFixed(2),
                  visualIntensity: visualIntensity.toFixed(2)
                }
              );
            }
          } catch (error) {
            console.error("[MusicSyncService] Processing failed:", error);
            this.metrics.errors++;
            const fallbackData = this.getFallbackProcessedData(trackUri);
            this.latestProcessedData = fallbackData;
            this.notifySubscribers(fallbackData, null, trackUri);
          }
        }
        /**
         * Re-extract colours & (optionally) recompute beat analysis for the current
         * track.  When `force === true` the method runs even if the track URI hasn't
         * changed (used after live settings updates so gradients repaint instantly).
         */
        async processSongUpdate(force = false) {
          const spicetify = safeGetSpicetify2();
          const trackUri = spicetify?.Player?.data?.item?.uri;
          if (!trackUri) return;
          if (!force && trackUri === this.currentTrackUri) {
            return;
          }
          if (this.songChangeDebounceTimer) {
            clearTimeout(this.songChangeDebounceTimer);
          }
          if (force) {
            await this._processSongUpdateInternal(trackUri);
            return;
          }
          this.songChangeDebounceTimer = setTimeout(async () => {
            this.songChangeDebounceTimer = null;
            await this._processSongUpdateInternal(trackUri);
          }, MUSIC_SYNC_CONFIG.synchronization.debounceRapidChanges);
        }
        /**
         * Internal implementation of song processing, extracted for debouncing.
         * 🔧 PHASE 1: Enhanced with event loop prevention and chain tracking
         */
        async _processSongUpdateInternal(trackUri) {
          if (this.eventProcessingState.isProcessingEvent) {
            if (this.config.enableDebug) {
              console.warn("\u{1F504} [MusicSyncService] Already processing song update - skipping to prevent recursion");
            }
            return;
          }
          this.eventProcessingState.isProcessingEvent = true;
          this.eventProcessingState.lastEventTime = Date.now();
          this.eventProcessingState.consecutiveEvents++;
          this.eventProcessingState.eventChain.push("_processSongUpdateInternal");
          if (this.eventProcessingState.consecutiveEvents > this.MAX_CONSECUTIVE_EVENTS) {
            console.error("\u{1F504} [MusicSyncService] CRITICAL: Too many consecutive events - circuit breaker activated", {
              consecutiveEvents: this.eventProcessingState.consecutiveEvents,
              eventChain: this.eventProcessingState.eventChain
            });
            this._resetEventProcessingState();
            return;
          }
          const resetTimeout = setTimeout(() => {
            if (this.config.enableDebug) {
              console.warn("\u{1F504} [MusicSyncService] Event processing timeout - resetting state");
            }
            this._resetEventProcessingState();
          }, this.EVENT_RESET_TIMEOUT);
          try {
            this.invalidateTrackCaches(trackUri);
            const spicetify = safeGetSpicetify2();
            const trackDuration = spicetify?.Player?.data?.item?.duration || 0;
            const results = await Promise.allSettled([
              this.getAudioFeatures(),
              this.robustColorExtraction(trackUri)
              // 🔧 IMPROVED: More robust color extraction
            ]);
            const audioFeatures = results[0].status === "fulfilled" ? results[0].value : null;
            const rawColors = results[1].status === "fulfilled" ? results[1].value : null;
            if (results[0].status === "rejected") {
              if (this.config.enableDebug) {
                console.warn(
                  "[MusicSyncService] Audio features retrieval failed, continuing without music analysis:",
                  results[0].reason
                );
              }
            }
            if (results[1].status === "rejected") {
              if (this.config.enableDebug) {
                console.warn(
                  "[MusicSyncService] Color extraction failed, continuing without color processing:",
                  results[1].reason
                );
              }
            }
            if (this.config.enableDebug) {
              const successCount = (audioFeatures ? 1 : 0) + (rawColors ? 1 : 0);
              if (successCount === 1) {
                console.log(
                  `[MusicSyncService] Graceful degradation: Continuing with ${audioFeatures ? "audio features only" : "color extraction only"}`
                );
              } else if (successCount === 2) {
                console.log("[MusicSyncService] Full feature extraction successful");
              } else {
                console.warn(
                  "[MusicSyncService] Both strategies failed, will use fallback data"
                );
              }
            }
            console.log("\u{1F3A8} [MusicSyncService] Raw colors BEFORE sanitization:", {
              rawColors,
              rawColorType: typeof rawColors,
              rawColorKeys: rawColors ? Object.keys(rawColors) : [],
              rawColorEntries: rawColors ? Object.entries(rawColors) : []
            });
            const colors = this.utils.sanitizeColorMap(
              rawColors || {}
            );
            console.log("\u{1F3A8} [MusicSyncService] Colors AFTER sanitization:", {
              sanitizedColors: colors,
              sanitizedColorType: typeof colors,
              sanitizedColorKeys: Object.keys(colors),
              sanitizedColorEntries: Object.entries(colors),
              colorCount: Object.keys(colors).length,
              droppedCount: rawColors ? Object.keys(rawColors).length - Object.keys(colors).length : 0
            });
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [MusicSyncService] Color extraction debug:", {
                trackUri,
                rawColorsReceived: rawColors,
                sanitizedColors: colors,
                colorCount: Object.keys(colors).length,
                colorExtractorFailed: results[1].status === "rejected"
              });
            }
            let finalColors = colors;
            let usingFallback = false;
            if (Object.keys(colors).length > 0) {
              try {
                finalColors = await this.enhanceExtractedColorsWithOKLAB(colors, audioFeatures);
                if (this.config.enableDebug) {
                  console.log("\u{1F3A8} [MusicSyncService] Successfully enhanced extracted colors with OKLAB processing");
                }
              } catch (oklabError) {
                if (this.config.enableDebug) {
                  console.warn("\u{1F3A8} [MusicSyncService] OKLAB enhancement failed, using original extracted colors:", oklabError);
                }
                finalColors = colors;
              }
            }
            if (Object.keys(colors).length === 0) {
              try {
                const fallbackColors = await this.createOKLABEnhancedFallbackColors(audioFeatures);
                finalColors = fallbackColors;
                usingFallback = true;
                if (this.config.enableDebug) {
                  console.warn(
                    "\u{1F3A8} [MusicSyncService] Color extraction failed, using OKLAB-enhanced Catppuccin fallback colors with emotional context"
                  );
                }
              } catch (oklabError) {
                if (this.config.enableDebug) {
                  console.warn("\u{1F3A8} [MusicSyncService] OKLAB fallback processing failed, using static fallback colors:", oklabError);
                }
                finalColors = {
                  VIBRANT: "#f2cdcd",
                  // Catppuccin rosewater
                  DARK_VIBRANT: "#cba6f7",
                  // Catppuccin mauve
                  LIGHT_VIBRANT: "#f5c2e7",
                  // Catppuccin pink
                  PROMINENT: "#cba6f7",
                  // Catppuccin mauve
                  VIBRANT_NON_ALARMING: "#f2cdcd",
                  // Catppuccin rosewater
                  DESATURATED: "#9399b2"
                  // Catppuccin overlay1
                };
                usingFallback = true;
              }
            }
            const colorContext = {
              rawColors: finalColors,
              trackUri,
              timestamp: Date.now(),
              colorHarmonyMode: this.config.currentColorHarmonyMode || "catppuccin",
              harmonicMode: this.config.currentColorHarmonyMode || "catppuccin",
              // Legacy compatibility
              musicData: audioFeatures ? {
                energy: audioFeatures.energy,
                valence: audioFeatures.valence,
                tempo: audioFeatures.tempo,
                genre: this.genreProfileManager.detectGenre(audioFeatures)
              } : void 0,
              performanceHints: {
                preferLightweight: false,
                enableAdvancedBlending: true,
                maxProcessingTime: 100
                // 100ms max for color processing
              }
            };
            console.log("\u{1F3A8} [MusicSyncService] FINAL colors before event emission:", {
              finalColors,
              finalColorKeys: Object.keys(finalColors),
              finalColorEntries: Object.entries(finalColors),
              usingFallback,
              extractionFailed: Object.keys(colors).length === 0
            });
            const eventData = {
              rawColors: colorContext.rawColors,
              trackUri: colorContext.trackUri,
              timestamp: Date.now()
            };
            if (colorContext.musicData) {
              eventData.musicData = colorContext.musicData;
            }
            console.log("\u{1F3A8} [MusicSyncService] Emitting colors:extracted event with data:", {
              eventData,
              rawColorKeys: eventData.rawColors ? Object.keys(eventData.rawColors) : [],
              rawColorEntries: eventData.rawColors ? Object.entries(eventData.rawColors) : []
            });
            unifiedEventBus.emitSync("colors:extracted", eventData);
            if (this.config.enableDebug) {
              console.log(
                "\u{1F3B5} [MusicSyncService] Emitted colors:extracted event for strategy processing",
                {
                  trackUri,
                  colorCount: Object.keys(finalColors).length,
                  usingFallback,
                  extractionFailed: Object.keys(colors).length === 0
                }
              );
            }
            if (audioFeatures) {
              const provisionalAudioData = this.convertFeaturesToAudioData(audioFeatures);
              await this.processAudioFeatures(
                provisionalAudioData,
                trackUri,
                trackDuration
              );
            }
            (async () => {
              const fullAnalysis = await this.fetchAudioData();
              if (this.isValidAudioData(fullAnalysis)) {
                await this.processAudioFeatures(
                  fullAnalysis,
                  trackUri,
                  trackDuration
                );
              }
            })();
          } catch (error) {
            console.error(
              `[MusicSyncService] Error processing song update for ${trackUri}:`,
              error
            );
            this.metrics.errors++;
          } finally {
            clearTimeout(resetTimeout);
            this._resetEventProcessingState();
            const chainIndex = this.eventProcessingState.eventChain.indexOf("_processSongUpdateInternal");
            if (chainIndex > -1) {
              this.eventProcessingState.eventChain.splice(chainIndex, 1);
            }
          }
        }
        /**
         * Phase 1: Reset event processing state for loop prevention
         */
        _resetEventProcessingState() {
          this.eventProcessingState.isProcessingEvent = false;
          this.eventProcessingState.eventChain = [];
          const now = Date.now();
          const timeSinceLastEvent = now - this.eventProcessingState.lastEventTime;
          if (timeSinceLastEvent > this.EVENT_RESET_TIMEOUT) {
            this.eventProcessingState.consecutiveEvents = 0;
          } else {
            const decayFactor = Math.min(1, timeSinceLastEvent / this.EVENT_RESET_TIMEOUT);
            this.eventProcessingState.consecutiveEvents = Math.floor(
              this.eventProcessingState.consecutiveEvents * (1 - decayFactor)
            );
          }
          if (this.config.enableDebug && this.eventProcessingState.consecutiveEvents > 0) {
            console.log("\u{1F504} [MusicSyncService] Event processing state reset", {
              consecutiveEvents: this.eventProcessingState.consecutiveEvents,
              timeSinceLastEvent
            });
          }
        }
        // === LIFECYCLE & HELPERS ===
        setupCacheManagement() {
          this.cacheCleanupInterval = setInterval(() => {
            const now = Date.now();
            for (const [key, cacheEntry] of this.unifiedCache.entries()) {
              if (now - cacheEntry.timestamp > this.cacheTTL) {
                this.unifiedCache.delete(key);
              }
            }
          }, this.cacheTTL);
        }
        setupPerformanceMonitoring() {
          this.performanceInterval = setInterval(() => {
            if (this.metrics.performance.length > 0) {
              const avg = this.metrics.performance.reduce((a, b) => a + b, 0) / this.metrics.performance.length;
              this.metrics.avgProcessingTime = avg;
              this.metrics.performance = [];
            }
          }, 6e4);
        }
        loadUserPreferences() {
          try {
            return {
              enableMusicSync: true,
              // Always enabled since no specific setting exists
              audioAnalysisQuality: settings.get("sn-webgl-quality") || "medium",
              gradientIntensity: settings.get("sn-gradient-intensity") || "balanced",
              artisticMode: settings.get("sn-artistic-mode") || "artist-vision"
            };
          } catch (e) {
            return {
              enableMusicSync: true,
              audioAnalysisQuality: "medium",
              gradientIntensity: "balanced",
              artisticMode: "artist-vision"
            };
          }
        }
        saveUserPreferences() {
          try {
            if (this.config.enableDebug) {
              console.log("[MusicSyncService] User preferences updated via settings system");
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.warn(
                "[MusicSyncService] Could not save user preferences:",
                error
              );
            }
          }
        }
        updateConfiguration(newConfig) {
          const previousConfig = { ...MUSIC_SYNC_CONFIG };
          Object.assign(MUSIC_SYNC_CONFIG, newConfig);
          if (this.config.enableDebug) {
            console.log("\u{1F3B5} [MusicSyncService] Configuration updated", {
              from: previousConfig,
              to: MUSIC_SYNC_CONFIG
            });
          }
          this.cacheTTL = MUSIC_SYNC_CONFIG.performance.cacheTTL;
          if (previousConfig.performance.enableMetrics !== MUSIC_SYNC_CONFIG.performance.enableMetrics) {
            if (MUSIC_SYNC_CONFIG.performance.enableMetrics) {
              this.setupPerformanceMonitoring();
            } else if (this.performanceInterval) {
              clearInterval(this.performanceInterval);
              this.performanceInterval = null;
            }
          }
        }
        destroy() {
          if (this.songChangeDebounceTimer) {
            clearTimeout(this.songChangeDebounceTimer);
            this.songChangeDebounceTimer = null;
          }
          this.stopBeatScheduler();
          if (this.performanceInterval) clearInterval(this.performanceInterval);
          if (this.cacheCleanupInterval) clearInterval(this.cacheCleanupInterval);
          this.subscribers.clear();
          this.unifiedCache.clear();
          this.isInitialized = false;
          this.latestProcessedData = null;
          this.metrics = {
            bpmCalculations: 0,
            beatSyncs: 0,
            cacheHits: 0,
            cacheMisses: 0,
            avgProcessingTime: 0,
            performance: [],
            errors: 0,
            updates: 0
          };
          this.cacheCleanupInterval = null;
        }
        // Legacy method for backward compatibility - now uses event-driven pattern
        setColorHarmonyEngine(engine) {
          if (this.config.enableDebug) {
            console.log(
              "\u{1F3B5} [MusicSyncService] setColorHarmonyEngine called - now using event-driven pattern instead of direct dependency."
            );
          }
        }
        getLatestProcessedData() {
          return this.latestProcessedData;
        }
        /**
         * Get the latest beat vector (unit direction) for visual systems that need
         * directional rhythm cues. Falls back to {0,0} when unavailable.
         */
        getCurrentBeatVector() {
          return { ...this.currentBeatVector };
        }
        stopBeatScheduler() {
          if (this.beatSchedulerTimer) {
            clearTimeout(this.beatSchedulerTimer);
            this.beatSchedulerTimer = null;
          }
        }
        triggerBeatEvent() {
          const GOLDEN_RATIO = 0.61803398875;
          const angle = this.nextBeatIndex * GOLDEN_RATIO % 1 * Math.PI * 2;
          this.currentBeatVector = { x: Math.cos(angle), y: Math.sin(angle) };
          if (this.latestProcessedData) {
            const beatUpdate = {
              ...this.latestProcessedData,
              beatOccurred: true,
              beatVector: this.currentBeatVector
            };
            this.notifySubscribers(beatUpdate, null, this.currentTrackUri);
          }
          this.nextBeatIndex++;
          this.scheduleNextBeatEvent();
        }
        scheduleNextBeatEvent() {
          if (this.nextBeatIndex >= this.currentSongBeats.length) {
            return;
          }
          const nextBeat = this.currentSongBeats[this.nextBeatIndex];
          if (!nextBeat) {
            return;
          }
          const timeSinceSongStart = Date.now() - this.songStartTimestamp;
          const delay = nextBeat.start * 1e3 - timeSinceSongStart;
          if (delay >= 0) {
            this.beatSchedulerTimer = setTimeout(
              () => this.triggerBeatEvent(),
              delay
            );
          } else {
            this.nextBeatIndex++;
            this.scheduleNextBeatEvent();
          }
        }
        /**
         * Validate that the returned audio analysis object actually contains usable
         * information (primarily tempo). Spotify may return an empty object when the
         * analysis is not ready yet – treating that as valid poisons the cache.
         */
        isValidAudioData(data) {
          return !!data && typeof data.tempo === "number" && data.tempo > 0;
        }
        /**
         * Remove any cached entries (audioData, features, bpm, processed) belonging
         * to the provided track URI. Useful when switching tracks to ensure we do
         * not reuse stale or invalid data cached under the previous song.
         */
        invalidateTrackCaches(trackUri) {
          if (!trackUri) return;
          for (const key of this.unifiedCache.keys()) {
            if (key.includes(trackUri)) {
              this.unifiedCache.delete(key);
            }
          }
        }
        /**
         * Convert the lightweight `audio-features` payload into a pseudo `AudioData`
         * object so the rest of the pipeline (which expects full analysis) can work
         * immediately. Missing properties are filled with sensible defaults.
         */
        convertFeaturesToAudioData(features) {
          const fb = MUSIC_SYNC_CONFIG.musicVisualSync.enhancedBPM.fallbacks;
          return {
            tempo: features.tempo,
            energy: features.energy,
            valence: features.valence,
            loudness: fb.loudness,
            key: fb.key,
            time_signature: fb.timeSignature,
            danceability: features.danceability,
            acousticness: features.acousticness,
            instrumentalness: features.instrumentalness,
            speechiness: 0,
            liveness: 0,
            mode: 0
            // Optional arrays left undefined – beat grid will arrive later
          };
        }
        /**
         * Convert SpicetifyAudioFeatures to internal AudioData format
         * Handles property name mapping and provides fallback values
         */
        convertSpicetifyToAudioData(spicetifyData) {
          return {
            tempo: spicetifyData.tempo,
            energy: spicetifyData.energy,
            valence: spicetifyData.valence,
            loudness: spicetifyData.loudness,
            key: spicetifyData.key,
            time_signature: spicetifyData.time_signature || spicetifyData.timeSignature,
            danceability: spicetifyData.danceability,
            acousticness: spicetifyData.acousticness,
            instrumentalness: spicetifyData.instrumentalness,
            speechiness: spicetifyData.speechiness,
            liveness: spicetifyData.liveness,
            mode: spicetifyData.mode
            // Optional arrays can be undefined for now
          };
        }
        /**
         * 🔧 IMPROVED: Robust color extraction with retry logic and fallbacks
         */
        async robustColorExtraction(trackUri, maxRetries = 3) {
          console.log("\u{1F3A8} [MusicSyncService] Starting robust color extraction:", {
            trackUri,
            maxRetries,
            timestamp: Date.now()
          });
          for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
              if (!trackUri) {
                console.warn(
                  "\u{1F3A8} [MusicSyncService] Empty trackUri provided to color extraction"
                );
                return null;
              }
              console.log(`\u{1F3A8} [MusicSyncService] Calling Spicetify.colorExtractor (attempt ${attempt})...`);
              const spicetify = safeGetSpicetify2();
              if (!spicetify?.colorExtractor) {
                throw new Error("colorExtractor not available");
              }
              const colors = await spicetify.colorExtractor(trackUri);
              console.log(
                `\u{1F3A8} [MusicSyncService] Raw color extraction result (attempt ${attempt}):`,
                {
                  trackUri,
                  success: !!colors,
                  colorsType: typeof colors,
                  colorsIsNull: colors === null,
                  colorsIsUndefined: colors === void 0,
                  colorCount: colors ? Object.keys(colors).length : 0,
                  rawColors: colors,
                  colorKeys: colors ? Object.keys(colors) : [],
                  colorValues: colors ? Object.values(colors) : []
                }
              );
              if (colors && typeof colors === "object" && Object.keys(colors).length > 0) {
                Object.entries(colors).forEach(([key, value]) => {
                  console.log(`\u{1F3A8} [MusicSyncService] Extracted color: ${key} = ${value}`);
                });
                return colors;
              } else {
                console.warn(`\u{1F3A8} [MusicSyncService] Color extraction returned empty/invalid data on attempt ${attempt}`);
              }
            } catch (error) {
              console.error(
                `\u{1F3A8} [MusicSyncService] Color extraction attempt ${attempt} failed with error:`,
                error,
                {
                  errorMessage: error instanceof Error ? error.message : String(error),
                  errorStack: error instanceof Error ? error.stack : void 0
                }
              );
              if (attempt < maxRetries) {
                const waitTime = 100 * attempt;
                console.log(`\u{1F3A8} [MusicSyncService] Waiting ${waitTime}ms before retry...`);
                await new Promise((resolve) => setTimeout(resolve, waitTime));
              }
            }
          }
          console.error(
            `\u{1F3A8} [MusicSyncService] CRITICAL: All color extraction attempts failed for ${trackUri}`
          );
          return null;
        }
        // -------------------------------------------------------------------
        // External adapter integration helpers ------------------------------
        // -------------------------------------------------------------------
        /**
         * Adapter-facing helper to push music metrics without relying on the
         * full processing pipeline.  Currently a no-op placeholder that may be
         * expanded in future phases.
         */
        updateMetrics(metrics) {
          this.latestProcessedData = metrics;
        }
        /**
         * Get current music state for visual effects systems
         */
        getCurrentMusicState() {
          if (!this.latestProcessedData || !this.audioData) {
            return null;
          }
          return {
            emotion: this.latestProcessedData.emotion || null,
            beat: {
              tempo: this.latestProcessedData.bpm || this.audioData.tempo || 120,
              energy: this.latestProcessedData.energy || this.audioData.energy || 0.5,
              timestamp: Date.now()
            },
            intensity: this.latestProcessedData.intensity || this.audioData.energy || 0.5
          };
        }
        /**
         * Health check method for system status reporting
         */
        async healthCheck() {
          try {
            const isSpicetifyAvailable = SpicetifyCompat.isAvailable();
            const hasSubscribers = this.subscribers.size > 0;
            const hasRecentData = this.latestProcessedData !== null;
            const totalOperations = this.metrics.bpmCalculations + this.metrics.beatSyncs + this.metrics.cacheHits + this.metrics.cacheMisses;
            const errorRate = totalOperations > 0 ? this.metrics.errors / totalOperations : 0;
            if (!this.isInitialized) {
              return {
                status: "critical",
                message: "System not initialized",
                details: { initialized: this.isInitialized, spicetifyAvailable: isSpicetifyAvailable }
              };
            }
            if (!isSpicetifyAvailable) {
              return {
                status: "degraded",
                message: "Spicetify audio data API not available - running in limited mode",
                details: {
                  initialized: this.isInitialized,
                  spicetifyAvailable: isSpicetifyAvailable,
                  subscribers: hasSubscribers,
                  recentData: hasRecentData,
                  errorRate
                }
              };
            }
            if (errorRate > 0.5) {
              return {
                status: "degraded",
                message: `High error rate detected: ${(errorRate * 100).toFixed(1)}%`,
                details: {
                  initialized: this.isInitialized,
                  spicetifyAvailable: isSpicetifyAvailable,
                  subscribers: hasSubscribers,
                  recentData: hasRecentData,
                  errorRate,
                  errors: this.metrics.errors,
                  totalOperations
                }
              };
            }
            return {
              status: "healthy",
              message: "Music sync service operational",
              details: {
                initialized: this.isInitialized,
                spicetifyAvailable: isSpicetifyAvailable,
                subscribers: hasSubscribers,
                subscriberCount: this.subscribers.size,
                recentData: hasRecentData,
                errorRate,
                bpmCalculations: this.metrics.bpmCalculations,
                beatSyncs: this.metrics.beatSyncs,
                cacheHits: this.metrics.cacheHits,
                cacheMisses: this.metrics.cacheMisses,
                avgProcessingTime: this.metrics.avgProcessingTime,
                errors: this.metrics.errors,
                updates: this.metrics.updates
              }
            };
          } catch (error) {
            return {
              status: "critical",
              message: `Health check failed: ${error instanceof Error ? error.message : "Unknown error"}`,
              details: { error: error instanceof Error ? error.message : "Unknown error" }
            };
          }
        }
      };
      __name(_MusicSyncService, "MusicSyncService");
      MusicSyncService = _MusicSyncService;
    }
  });

  // src-js/core/performance/TimerConsolidationSystem.ts
  var _TimerConsolidationSystem, TimerConsolidationSystem;
  var init_TimerConsolidationSystem = __esm({
    "src-js/core/performance/TimerConsolidationSystem.ts"() {
      "use strict";
      _TimerConsolidationSystem = class _TimerConsolidationSystem {
        constructor(config = {}) {
          this._timerRegistry = /* @__PURE__ */ new Map();
          this._timerMasterInterval = null;
          this.config = {
            timerIntervalMs: config.timerIntervalMs || 50,
            maxTimerBudget: config.maxTimerBudget || 10,
            enableDebug: config.enableDebug || false,
            ...config
          };
          this._timerPerformanceMetrics = {
            totalExecutions: 0,
            totalTime: 0,
            maxExecutionTime: 0,
            averageExecutionTime: 0,
            skippedTimers: 0,
            timerCallbacks: /* @__PURE__ */ new Map()
          };
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Initialized");
          }
        }
        initialize() {
          if (this.config.enableDebug) {
            console.log(
              "\u23F1\uFE0F [TimerConsolidationSystem] Timer consolidation initialized"
            );
          }
        }
        registerConsolidatedTimer(timerId, callback, intervalMs, priority = "normal") {
          if (this._timerRegistry.has(timerId)) {
            console.warn(
              `[TimerConsolidationSystem] Timer ${timerId} already registered`
            );
            return;
          }
          const timerConfig = {
            callback,
            intervalMs,
            priority,
            lastExecution: 0,
            enabled: true,
            executionCount: 0,
            totalExecutionTime: 0,
            maxExecutionTime: 0,
            skippedExecutions: 0
          };
          this._timerRegistry.set(timerId, timerConfig);
          this._timerPerformanceMetrics.timerCallbacks.set(timerId, {
            calls: 0,
            totalTime: 0,
            maxTime: 0
          });
          if (this.config.enableDebug) {
            console.log(
              `\u23F1\uFE0F [TimerConsolidationSystem] Registered timer: ${timerId} (${intervalMs}ms, ${priority} priority)`
            );
          }
          if (this._timerRegistry.size === 1 && !this._timerMasterInterval) {
            this._startMasterTimer();
          }
        }
        unregisterConsolidatedTimer(timerId) {
          if (this._timerRegistry.has(timerId)) {
            this._timerRegistry.delete(timerId);
            this._timerPerformanceMetrics.timerCallbacks.delete(timerId);
            if (this.config.enableDebug) {
              console.log(
                `\u23F1\uFE0F [TimerConsolidationSystem] Unregistered timer: ${timerId}`
              );
            }
            if (this._timerRegistry.size === 0) {
              this._stopMasterTimer();
            }
          }
        }
        _startMasterTimer() {
          if (this._timerMasterInterval) return;
          this._timerMasterInterval = setInterval(() => {
            this._executeMasterTimerFrame();
          }, this.config.timerIntervalMs);
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Master timer started");
          }
        }
        _stopMasterTimer() {
          if (this._timerMasterInterval) {
            clearInterval(this._timerMasterInterval);
            this._timerMasterInterval = null;
          }
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Master timer stopped");
          }
        }
        _executeMasterTimerFrame() {
          const frameStartTime = performance.now();
          let remainingBudget = this.config.maxTimerBudget;
          const timersByPriority = Array.from(this._timerRegistry.entries()).sort(
            ([, a], [, b]) => {
              const priorityOrder = { critical: 0, normal: 1, background: 2 };
              return priorityOrder[a.priority] - priorityOrder[b.priority];
            }
          );
          for (const [timerId, config] of timersByPriority) {
            if (!config.enabled || remainingBudget <= 0 && config.priority === "background") {
              if (remainingBudget <= 0) config.skippedExecutions++;
              continue;
            }
            const timeSinceLastExecution = frameStartTime - config.lastExecution;
            if (timeSinceLastExecution < config.intervalMs) {
              continue;
            }
            const timerStartTime = performance.now();
            try {
              config.callback();
              const timerExecutionTime = performance.now() - timerStartTime;
              config.executionCount++;
              config.totalExecutionTime += timerExecutionTime;
              config.maxExecutionTime = Math.max(
                config.maxExecutionTime,
                timerExecutionTime
              );
              config.lastExecution = frameStartTime;
              const stats = this._timerPerformanceMetrics.timerCallbacks.get(timerId);
              if (stats) {
                stats.calls++;
                stats.totalTime += timerExecutionTime;
                stats.maxTime = Math.max(stats.maxTime, timerExecutionTime);
              }
              remainingBudget -= timerExecutionTime;
            } catch (error) {
              console.error(
                `[TimerConsolidationSystem] Error in timer ${timerId}:`,
                error
              );
              config.enabled = false;
            }
          }
          const totalFrameTime = performance.now() - frameStartTime;
          this._updateTimerPerformanceMetrics(totalFrameTime);
        }
        _updateTimerPerformanceMetrics(frameTime) {
          const metrics = this._timerPerformanceMetrics;
          metrics.totalExecutions++;
          metrics.totalTime += frameTime;
          metrics.maxExecutionTime = Math.max(metrics.maxExecutionTime, frameTime);
          metrics.averageExecutionTime = metrics.totalTime / metrics.totalExecutions;
          if (frameTime > this.config.maxTimerBudget) {
            metrics.skippedTimers++;
          }
        }
        destroy() {
          this._stopMasterTimer();
          this._timerRegistry.clear();
          if (this.config.enableDebug) {
            console.log("\u23F1\uFE0F [TimerConsolidationSystem] Destroyed");
          }
        }
      };
      __name(_TimerConsolidationSystem, "TimerConsolidationSystem");
      TimerConsolidationSystem = _TimerConsolidationSystem;
    }
  });

  // src-js/core/performance/UnifiedPerformanceCoordinator.ts
  var _PerformanceAnalyzer, PerformanceAnalyzer, UnifiedPerformanceCoordinator;
  var init_UnifiedPerformanceCoordinator = __esm({
    "src-js/core/performance/UnifiedPerformanceCoordinator.ts"() {
      "use strict";
      init_UnifiedEventBus();
      _PerformanceAnalyzer = class _PerformanceAnalyzer {
        constructor(config, performanceAnalyzer2) {
          this.performanceAnalyzer = null;
          // Subsystem tracking
          this.subsystemMetrics = /* @__PURE__ */ new Map();
          // Optimization management
          this.optimizationStrategies = /* @__PURE__ */ new Map();
          this.adaptiveOptimizationEnabled = false;
          this.optimizationInterval = null;
          // Issue tracking
          this.activeIssues = /* @__PURE__ */ new Map();
          this.issueHistory = [];
          // Health monitoring
          this.lastHealthCheck = 0;
          this.healthCheckInterval = null;
          this.HEALTH_CHECK_INTERVAL = 5e3;
          // Initialized in initializeThermalMonitoring
          this.batteryState = null;
          // Initialized in constructor
          this.frameTimeHistory = [];
          this.memoryUsageHistory = [];
          this.lastOptimizationTime = 0;
          this.optimizationCooldown = 5e3;
          // 5 seconds
          // Performance thresholds
          this.PERFORMANCE_THRESHOLDS = {
            frameTime: {
              warning: 16.67,
              // 60fps
              critical: 33.33
              // 30fps
            },
            memoryUsage: {
              warning: 50 * 1024 * 1024,
              // 50MB
              critical: 100 * 1024 * 1024
              // 100MB
            },
            cpuUsage: {
              warning: 15,
              // 15%
              critical: 30
              // 30%
            },
            fps: {
              warning: 50,
              critical: 30
            }
          };
          // Performance modes configuration (from PerformanceOptimizationManager)
          this.PERFORMANCE_MODES = {
            battery: {
              name: "battery",
              qualityLevel: 0.4,
              animationQuality: 0.3,
              effectQuality: 0.2,
              blurQuality: 0.3,
              shadowQuality: 0.2,
              frameRate: 30,
              optimizationLevel: 3
            },
            balanced: {
              name: "balanced",
              qualityLevel: 0.8,
              animationQuality: 0.8,
              effectQuality: 0.7,
              blurQuality: 0.8,
              shadowQuality: 0.7,
              frameRate: 60,
              optimizationLevel: 1
            },
            performance: {
              name: "performance",
              qualityLevel: 1,
              animationQuality: 1,
              effectQuality: 1,
              blurQuality: 1,
              shadowQuality: 1,
              frameRate: 60,
              optimizationLevel: 0
            },
            auto: {
              name: "auto",
              qualityLevel: 0.8,
              // Will be dynamically adjusted
              animationQuality: 0.8,
              effectQuality: 0.8,
              blurQuality: 0.8,
              shadowQuality: 0.8,
              frameRate: 60,
              optimizationLevel: 1
            }
          };
          this.config = config;
          this.performanceAnalyzer = performanceAnalyzer2 || null;
          this.eventBus = unifiedEventBus;
          this.initializeDeviceCapabilities();
          this.initializeThermalMonitoring();
          this.initializeBatteryMonitoring();
          this.currentPerformanceMode = this.PERFORMANCE_MODES.auto;
          this.initializeDefaultStrategies();
          this.startHealthMonitoring();
          this.subscribeToEvents();
          if (this.config.enableDebug) {
            console.log("[PerformanceAnalyzer] Initialized with enhanced device capabilities, thermal monitoring, and battery optimization");
          }
        }
        /**
         * Get or create singleton instance
         */
        static getInstance(config, performanceAnalyzer2) {
          if (!_PerformanceAnalyzer.instance) {
            if (!config || !performanceAnalyzer2) {
              throw new Error("PerformanceAnalyzer requires config and performanceAnalyzer for first initialization");
            }
            _PerformanceAnalyzer.instance = new _PerformanceAnalyzer(config, performanceAnalyzer2);
          }
          return _PerformanceAnalyzer.instance;
        }
        /**
         * Track performance metrics for a subsystem
         */
        trackSubsystem(name, metrics) {
          const currentTime = performance.now();
          const existingMetrics = this.subsystemMetrics.get(name) || {
            name,
            frameTime: 0,
            memoryUsage: 0,
            cpuUsage: 0,
            fps: 60,
            lastUpdate: currentTime,
            status: "healthy",
            issues: []
          };
          const updatedMetrics = {
            ...existingMetrics,
            ...metrics,
            lastUpdate: currentTime
          };
          updatedMetrics.status = this.calculateHealthStatus(updatedMetrics);
          this.updateSubsystemIssues(updatedMetrics);
          this.subsystemMetrics.set(name, updatedMetrics);
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.recordMetric?.(`subsystem_${name}_frame_time`, updatedMetrics.frameTime);
            this.performanceAnalyzer.recordMetric?.(`subsystem_${name}_memory`, updatedMetrics.memoryUsage);
            this.performanceAnalyzer.recordMetric?.(`subsystem_${name}_fps`, updatedMetrics.fps);
          }
          if (this.adaptiveOptimizationEnabled && updatedMetrics.status !== "healthy") {
            this.checkAndTriggerOptimization(updatedMetrics);
          }
          if (this.config.enableDebug && updatedMetrics.status !== "healthy") {
            console.warn(`[PerformanceAnalyzer] Subsystem ${name} status: ${updatedMetrics.status}`, updatedMetrics);
          }
        }
        /**
         * Get comprehensive system health report
         */
        getSystemHealth() {
          const currentTime = performance.now();
          const subsystems = new Map(this.subsystemMetrics);
          let healthyCount = 0;
          let warningCount = 0;
          let criticalCount = 0;
          for (const metrics of subsystems.values()) {
            switch (metrics.status) {
              case "healthy":
                healthyCount++;
                break;
              case "warning":
                warningCount++;
                break;
              case "critical":
                criticalCount++;
                break;
            }
          }
          const totalSubsystems = subsystems.size;
          let overall = "healthy";
          if (criticalCount > 0) {
            overall = "critical";
          } else if (warningCount > 0) {
            overall = "warning";
          }
          const performanceScore = this.calculatePerformanceScore(subsystems);
          const recommendations = this.generateRecommendations(subsystems);
          const healthReport = {
            overall,
            totalSubsystems,
            healthySubsystems: healthyCount,
            warningSubsystems: warningCount,
            criticalSubsystems: criticalCount,
            subsystems,
            recommendations,
            performanceScore,
            lastUpdate: currentTime
          };
          this.lastHealthCheck = currentTime;
          return healthReport;
        }
        /**
         * Start monitoring (required by Year3000System interface)
         */
        startMonitoring() {
          this.enableAdaptiveOptimization();
          if (!this.healthCheckInterval) {
            this.startHealthMonitoring();
          }
          if (this.config.enableDebug) {
            console.log("[PerformanceAnalyzer] Monitoring started");
          }
        }
        /**
         * Enable adaptive optimization
         */
        enableAdaptiveOptimization() {
          if (this.adaptiveOptimizationEnabled) return;
          this.adaptiveOptimizationEnabled = true;
          this.optimizationInterval = setInterval(() => {
            this.performOptimizationCheck();
          }, 2e3);
          if (this.config.enableDebug) {
            console.log("[PerformanceAnalyzer] Adaptive optimization enabled");
          }
        }
        /**
         * Disable adaptive optimization
         */
        disableAdaptiveOptimization() {
          if (!this.adaptiveOptimizationEnabled) return;
          this.adaptiveOptimizationEnabled = false;
          if (this.optimizationInterval) {
            clearInterval(this.optimizationInterval);
            this.optimizationInterval = null;
          }
          if (this.config.enableDebug) {
            console.log("[PerformanceAnalyzer] Adaptive optimization disabled");
          }
        }
        /**
         * Register an optimization strategy
         */
        registerOptimizationStrategy(strategy) {
          this.optimizationStrategies.set(strategy.name, strategy);
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Registered optimization strategy: ${strategy.name}`);
          }
        }
        /**
         * Trigger optimization for a specific issue
         */
        triggerOptimization(issue) {
          this.activeIssues.set(`${issue.subsystem}:${issue.type}`, issue);
          this.issueHistory.push(issue);
          if (this.issueHistory.length > 100) {
            this.issueHistory.shift();
          }
          const applicableStrategies = Array.from(this.optimizationStrategies.values()).filter((strategy) => strategy.subsystem === issue.subsystem || strategy.subsystem === "*").sort((a, b) => b.priority - a.priority);
          for (const strategy of applicableStrategies) {
            const subsystemMetrics = this.subsystemMetrics.get(issue.subsystem);
            if (subsystemMetrics && strategy.condition(subsystemMetrics)) {
              try {
                strategy.action(subsystemMetrics);
                if (this.config.enableDebug) {
                  console.log(`[PerformanceAnalyzer] Applied optimization strategy: ${strategy.name} for ${issue.subsystem}`);
                }
                break;
              } catch (error) {
                console.error(`[PerformanceAnalyzer] Error applying optimization strategy ${strategy.name}:`, error);
              }
            }
          }
        }
        /**
         * Get current performance metrics for debugging
         */
        getMetrics() {
          return {
            subsystems: new Map(this.subsystemMetrics),
            issues: new Map(this.activeIssues),
            strategies: new Map(this.optimizationStrategies),
            adaptiveOptimizationEnabled: this.adaptiveOptimizationEnabled
          };
        }
        /**
         * Destroy the coordinator and clean up resources
         */
        destroy() {
          this.disableAdaptiveOptimization();
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          this.subsystemMetrics.clear();
          this.optimizationStrategies.clear();
          this.activeIssues.clear();
          this.issueHistory = [];
          if (_PerformanceAnalyzer.instance === this) {
            _PerformanceAnalyzer.instance = null;
          }
          if (this.config.enableDebug) {
            console.log("[PerformanceAnalyzer] Destroyed");
          }
        }
        // =========================================================================
        // PRIVATE METHODS
        // =========================================================================
        /**
         * Initialize default optimization strategies
         */
        initializeDefaultStrategies() {
          this.registerOptimizationStrategy({
            name: "memory-cleanup",
            type: "memory_cleanup",
            priority: 100,
            subsystem: "*",
            description: "Trigger garbage collection and memory cleanup",
            condition: /* @__PURE__ */ __name((metrics) => metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
            }, "action")
          });
          this.registerOptimizationStrategy({
            name: "fps-optimization",
            type: "reduce_quality",
            priority: 80,
            subsystem: "*",
            description: "Reduce quality settings to improve FPS",
            condition: /* @__PURE__ */ __name((metrics) => metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
            }, "action")
          });
          this.registerOptimizationStrategy({
            name: "cpu-throttling",
            type: "throttle_updates",
            priority: 70,
            subsystem: "*",
            description: "Throttle update frequency to reduce CPU usage",
            condition: /* @__PURE__ */ __name((metrics) => metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning, "condition"),
            action: /* @__PURE__ */ __name((metrics) => {
            }, "action")
          });
        }
        /**
         * Calculate health status for subsystem
         */
        calculateHealthStatus(metrics) {
          const issues = [];
          if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.critical) {
            issues.push("critical-frame-time");
          } else if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.warning) {
            issues.push("warning-frame-time");
          }
          if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.critical) {
            issues.push("critical-memory");
          } else if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning) {
            issues.push("warning-memory");
          }
          if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.critical) {
            issues.push("critical-cpu");
          } else if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning) {
            issues.push("warning-cpu");
          }
          if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.critical) {
            issues.push("critical-fps");
          } else if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning) {
            issues.push("warning-fps");
          }
          metrics.issues = issues;
          if (issues.some((issue) => issue.startsWith("critical"))) {
            return "critical";
          } else if (issues.some((issue) => issue.startsWith("warning"))) {
            return "warning";
          } else {
            return "healthy";
          }
        }
        /**
         * Update subsystem issues based on thresholds
         */
        updateSubsystemIssues(metrics) {
          const issueKey = `${metrics.name}:performance`;
          if (metrics.status === "healthy") {
            if (this.activeIssues.has(issueKey)) {
              const issue = this.activeIssues.get(issueKey);
              issue.resolved = true;
              this.activeIssues.delete(issueKey);
            }
          } else {
            const issue = {
              type: "render",
              severity: metrics.status === "critical" ? "critical" : "medium",
              subsystem: metrics.name,
              message: `Performance degradation detected: ${metrics.issues.join(", ")}`,
              timestamp: Date.now(),
              resolved: false
            };
            this.activeIssues.set(issueKey, issue);
          }
        }
        /**
         * Check and trigger optimization if needed
         */
        checkAndTriggerOptimization(metrics) {
          const issueKey = `${metrics.name}:performance`;
          const issue = this.activeIssues.get(issueKey);
          if (issue && !issue.resolved) {
            this.triggerOptimization(issue);
          }
        }
        /**
         * Perform periodic optimization check
         */
        performOptimizationCheck() {
          const currentTime = performance.now();
          for (const [name, metrics] of this.subsystemMetrics) {
            if (currentTime - metrics.lastUpdate > 1e4) {
              continue;
            }
            if (metrics.status !== "healthy") {
              this.checkAndTriggerOptimization(metrics);
            }
          }
        }
        /**
         * Calculate overall performance score
         */
        calculatePerformanceScore(subsystems) {
          if (subsystems.size === 0) return 100;
          let totalScore = 0;
          for (const metrics of subsystems.values()) {
            let subsystemScore = 100;
            if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.warning) {
              subsystemScore -= 20;
            }
            if (metrics.frameTime > this.PERFORMANCE_THRESHOLDS.frameTime.critical) {
              subsystemScore -= 30;
            }
            if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.warning) {
              subsystemScore -= 15;
            }
            if (metrics.memoryUsage > this.PERFORMANCE_THRESHOLDS.memoryUsage.critical) {
              subsystemScore -= 25;
            }
            if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.warning) {
              subsystemScore -= 10;
            }
            if (metrics.cpuUsage > this.PERFORMANCE_THRESHOLDS.cpuUsage.critical) {
              subsystemScore -= 20;
            }
            if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.warning) {
              subsystemScore -= 15;
            }
            if (metrics.fps < this.PERFORMANCE_THRESHOLDS.fps.critical) {
              subsystemScore -= 25;
            }
            totalScore += Math.max(0, subsystemScore);
          }
          return Math.round(totalScore / subsystems.size);
        }
        /**
         * Generate recommendations based on system health
         */
        generateRecommendations(subsystems) {
          const recommendations = [];
          const allIssues = Array.from(subsystems.values()).flatMap((metrics) => metrics.issues);
          const issueCounts = /* @__PURE__ */ new Map();
          for (const issue of allIssues) {
            issueCounts.set(issue, (issueCounts.get(issue) || 0) + 1);
          }
          for (const [issue, count] of issueCounts) {
            if (count >= 2) {
              switch (issue) {
                case "critical-frame-time":
                case "warning-frame-time":
                  recommendations.push("Consider reducing animation quality or frequency");
                  break;
                case "critical-memory":
                case "warning-memory":
                  recommendations.push("Memory cleanup needed - consider reducing cache sizes");
                  break;
                case "critical-cpu":
                case "warning-cpu":
                  recommendations.push("High CPU usage detected - consider throttling updates");
                  break;
                case "critical-fps":
                case "warning-fps":
                  recommendations.push("Low FPS detected - consider disabling non-essential effects");
                  break;
              }
            }
          }
          if (recommendations.length === 0) {
            recommendations.push("System performance is optimal");
          }
          return recommendations;
        }
        /**
         * Start health monitoring
         */
        startHealthMonitoring() {
          this.healthCheckInterval = setInterval(() => {
            this.getSystemHealth();
          }, this.HEALTH_CHECK_INTERVAL);
        }
        /**
         * Subscribe to performance events
         */
        subscribeToEvents() {
        }
        // ===============================================================================
        // ENHANCED CAPABILITIES FROM PERFORMANCEOPTIMIZATIONMANAGER CONSOLIDATION
        // ===============================================================================
        /**
         * Initialize device capabilities detection
         */
        initializeDeviceCapabilities() {
          const nav = navigator;
          const memory = performance.memory;
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
          let maxTextureSize = 2048;
          if (gl) {
            maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE) || 2048;
          }
          const estimatedMemory = memory ? Math.round(memory.jsHeapSizeLimit / (1024 * 1024 * 1024)) : 4;
          let performanceTier = "medium";
          if (estimatedMemory >= 8 && nav.hardwareConcurrency >= 8 && maxTextureSize >= 4096) {
            performanceTier = "premium";
          } else if (estimatedMemory >= 4 && nav.hardwareConcurrency >= 4) {
            performanceTier = "high";
          } else if (estimatedMemory >= 2 && nav.hardwareConcurrency >= 2) {
            performanceTier = "medium";
          } else {
            performanceTier = "low";
          }
          this.deviceCapabilities = {
            performanceTier,
            memoryGB: estimatedMemory,
            cpuCores: nav.hardwareConcurrency || 4,
            gpuAcceleration: !!gl,
            isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(nav.userAgent),
            supportsWebGL: !!gl,
            supportsBackdropFilter: CSS.supports("backdrop-filter", "blur(10px)"),
            maxTextureSize,
            devicePixelRatio: window.devicePixelRatio || 1
          };
          if (this.config.enableDebug) {
            console.log("[PerformanceAnalyzer] Device capabilities detected:", this.deviceCapabilities);
          }
        }
        /**
         * Initialize thermal state monitoring
         */
        initializeThermalMonitoring() {
          this.thermalState = {
            temperature: "normal",
            throttleLevel: 0,
            cpuUsage: 0,
            gpuUsage: 0,
            memoryUsage: 0
          };
          setInterval(() => {
            this.updateThermalState();
          }, 1e4);
        }
        /**
         * Initialize battery monitoring if available
         */
        async initializeBatteryMonitoring() {
          try {
            const nav = navigator;
            if ("getBattery" in nav) {
              const battery = await nav.getBattery();
              this.batteryState = {
                level: battery.level,
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
              };
              battery.addEventListener("levelchange", () => {
                if (this.batteryState) {
                  this.batteryState.level = battery.level;
                  this.adjustPerformanceModeForBattery();
                }
              });
              battery.addEventListener("chargingchange", () => {
                if (this.batteryState) {
                  this.batteryState.charging = battery.charging;
                  this.adjustPerformanceModeForBattery();
                }
              });
              if (this.config.enableDebug) {
                console.log("[PerformanceAnalyzer] Battery monitoring initialized");
              }
            }
          } catch (error) {
            if (this.config.enableDebug) {
              console.log("[PerformanceAnalyzer] Battery API not available");
            }
          }
        }
        /**
         * Update thermal state based on performance metrics
         */
        updateThermalState() {
          const currentFPS = this.performanceAnalyzer?.getMedianFPS?.() || 60;
          const memory = performance.memory;
          const memoryUsage = memory ? memory.usedJSHeapSize / memory.jsHeapSizeLimit : 0;
          let temperature = "normal";
          let throttleLevel = 0;
          if (currentFPS < 30 || memoryUsage > 0.9) {
            temperature = "critical";
            throttleLevel = 0.8;
          } else if (currentFPS < 45 || memoryUsage > 0.7) {
            temperature = "hot";
            throttleLevel = 0.4;
          } else if (currentFPS < 55 || memoryUsage > 0.5) {
            temperature = "warm";
            throttleLevel = 0.2;
          }
          this.thermalState = {
            temperature,
            throttleLevel,
            cpuUsage: Math.min(1 - currentFPS / 60, 1),
            gpuUsage: 0,
            // TODO: Implement GPU usage detection
            memoryUsage
          };
          if (temperature === "critical" && this.currentPerformanceMode.name !== "battery") {
            this.setPerformanceMode("battery");
          } else if (temperature === "normal" && this.currentPerformanceMode.name === "battery") {
            this.setPerformanceMode("auto");
          }
        }
        /**
         * Adjust performance mode based on battery state
         */
        adjustPerformanceModeForBattery() {
          if (!this.batteryState) return;
          if (!this.batteryState.charging && this.batteryState.level < 0.2) {
            this.setPerformanceMode("battery");
          } else if (this.batteryState.charging && this.currentPerformanceMode.name === "battery") {
            this.setPerformanceMode("auto");
          }
        }
        /**
         * Set performance mode
         */
        setPerformanceMode(modeName) {
          const mode = this.PERFORMANCE_MODES[modeName];
          if (!mode) return;
          this.currentPerformanceMode = mode;
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Performance mode changed to: ${modeName}`);
          }
        }
        /**
         * Get current device capabilities
         */
        getDeviceCapabilities() {
          return { ...this.deviceCapabilities };
        }
        /**
         * Get current thermal state
         */
        getThermalState() {
          return { ...this.thermalState };
        }
        /**
         * Get current battery state
         */
        getBatteryState() {
          return this.batteryState ? { ...this.batteryState } : null;
        }
        /**
         * Get current performance mode
         */
        getCurrentPerformanceMode() {
          return { ...this.currentPerformanceMode };
        }
        // ===============================================================================
        // LEGACY API METHODS (from SimplePerformanceCoordinator consolidation)
        // ===============================================================================
        /**
         * Emit trace event (legacy API compatibility)
         */
        emitTrace(event, data) {
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Trace: ${event}`, data);
          }
        }
        /**
         * Record metric (legacy API compatibility)
         */
        recordMetric(name, value) {
          const subsystemMatch = name.match(/^subsystem_(.+)_(.+)$/);
          if (subsystemMatch && subsystemMatch.length >= 3) {
            const subsystemName = subsystemMatch[1] || "unknown";
            const metricType = subsystemMatch[2] || "unknown";
            const existing = this.subsystemMetrics.get(subsystemName) || {
              name: subsystemName,
              frameTime: 0,
              memoryUsage: 0,
              cpuUsage: 0,
              fps: 60,
              lastUpdate: performance.now(),
              status: "healthy",
              issues: []
            };
            switch (metricType) {
              case "frame_time":
                existing.frameTime = value;
                break;
              case "memory":
                existing.memoryUsage = value;
                break;
              case "fps":
                existing.fps = value;
                break;
              case "cpu":
                existing.cpuUsage = value;
                break;
            }
            this.trackSubsystem(subsystemName, existing);
          }
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Metric: ${name}=${value}`);
          }
        }
        /**
         * Get median FPS (legacy API compatibility)
         */
        getMedianFPS() {
          const fpsValues = Array.from(this.subsystemMetrics.values()).map((m) => m.fps);
          if (fpsValues.length > 0) {
            fpsValues.sort((a, b) => a - b);
            const mid = Math.floor(fpsValues.length / 2);
            return fpsValues.length % 2 === 0 ? ((fpsValues[mid - 1] || 0) + (fpsValues[mid] || 0)) / 2 : fpsValues[mid] || 0;
          }
          const tier = this.deviceCapabilities.performanceTier;
          switch (tier) {
            case "premium":
              return 60;
            case "high":
              return 60;
            case "medium":
              return 50;
            case "low":
              return 30;
            default:
              return 30;
          }
        }
        /**
         * Calculate health score (legacy API compatibility)
         */
        calculateHealthScore() {
          const healthReport = this.getSystemHealth();
          return healthReport.performanceScore / 100;
        }
        /**
         * Check if quality should be reduced (legacy API compatibility)
         */
        shouldReduceQuality() {
          const tier = this.deviceCapabilities.performanceTier;
          const thermalState = this.thermalState.temperature;
          const healthScore = this.calculateHealthScore();
          return tier === "low" || thermalState === "hot" || thermalState === "critical" || healthScore < 0.5;
        }
        /**
         * Time operation (legacy API compatibility)
         */
        timeOperation(name, operation) {
          const start = performance.now();
          const result = operation();
          const duration = performance.now() - start;
          this.recordMetric(`operation_${name}_duration`, duration);
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Operation ${name}: ${duration.toFixed(2)}ms`);
          }
          return result;
        }
        /**
         * Time async operation (legacy API compatibility)
         */
        async timeOperationAsync(name, operation) {
          const start = performance.now();
          const result = await operation();
          const duration = performance.now() - start;
          this.recordMetric(`async_operation_${name}_duration`, duration);
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Async operation ${name}: ${duration.toFixed(2)}ms`);
          }
          return result;
        }
        /**
         * Get average time for operation (legacy API compatibility)
         */
        getAverageTime(name) {
          const tier = this.deviceCapabilities.performanceTier;
          switch (tier) {
            case "premium":
              return 3;
            case "high":
              return 5;
            case "medium":
              return 15;
            case "low":
              return 30;
            default:
              return 15;
          }
        }
        /**
         * Update budget (legacy API compatibility)
         */
        updateBudget(name, value) {
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Budget update ignored: ${name}=${value} (using adaptive optimization instead)`);
          }
        }
        /**
         * Start timing (legacy API compatibility)
         */
        startTiming(name) {
          const timingId = `${name}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Timing started: ${name} (${timingId})`);
          }
          return timingId;
        }
        /**
         * End timing (legacy API compatibility)
         */
        endTiming(timingId, context) {
          if (this.config.enableDebug) {
            console.log(`[PerformanceAnalyzer] Timing ended: ${timingId}`, context);
          }
        }
        // ===============================================================================
        // WEBGL INTEGRATION (from SimplePerformanceCoordinator consolidation)
        // ===============================================================================
        /**
         * Get WebGL status (legacy API compatibility)
         */
        getWebGLStatus() {
          const webglSupported = this.deviceCapabilities.supportsWebGL;
          const performanceTier = this.deviceCapabilities.performanceTier;
          if (!webglSupported) {
            return {
              state: "disabled",
              quality: "low",
              enabled: false
            };
          }
          let quality = "medium";
          if (performanceTier === "premium" || performanceTier === "high") {
            quality = this.thermalState.temperature === "normal" ? "high" : "medium";
          } else if (performanceTier === "low" || this.thermalState.temperature === "critical") {
            quality = "low";
          }
          return {
            state: "webgl-active",
            quality,
            enabled: true
          };
        }
        /**
         * Get performance summary (legacy API compatibility)
         */
        getPerformanceSummary() {
          const webglStatus = this.getWebGLStatus();
          const healthReport = this.getSystemHealth();
          const deviceTier = this.deviceCapabilities.performanceTier === "premium" ? "high" : this.deviceCapabilities.performanceTier;
          const deviceDescription = `${this.deviceCapabilities.memoryGB}GB RAM, ${this.deviceCapabilities.cpuCores} cores, ${this.deviceCapabilities.supportsWebGL ? "WebGL" : "No WebGL"}${this.deviceCapabilities.isMobile ? ", Mobile" : ""}`;
          const confidence = healthReport.performanceScore / 100;
          const reasoning = [];
          reasoning.push(`Device tier: ${deviceTier} (${this.deviceCapabilities.performanceTier})`);
          reasoning.push(`Memory: ${this.deviceCapabilities.memoryGB}GB`);
          reasoning.push(`CPU cores: ${this.deviceCapabilities.cpuCores}`);
          if (this.deviceCapabilities.supportsWebGL) {
            reasoning.push(`WebGL supported (${this.deviceCapabilities.maxTextureSize}px max texture)`);
          }
          if (this.thermalState.temperature !== "normal") {
            reasoning.push(`Thermal state: ${this.thermalState.temperature}`);
          }
          const energyBoost = this.currentPerformanceMode.name === "performance" && this.thermalState.temperature === "normal" && (this.batteryState?.charging || (this.batteryState?.level || 0) > 0.5 || !this.batteryState);
          return {
            deviceTier,
            deviceDescription,
            confidence,
            reasoning,
            webglStatus,
            energyBoost,
            settings: this.currentPerformanceMode
          };
        }
        /**
         * Get device tier (legacy API compatibility)
         */
        getDeviceTier() {
          return this.deviceCapabilities.performanceTier === "premium" ? "high" : this.deviceCapabilities.performanceTier;
        }
        /**
         * Get device description (legacy API compatibility)
         */
        getDeviceDescription() {
          return `${this.deviceCapabilities.memoryGB}GB RAM, ${this.deviceCapabilities.cpuCores} cores, ${this.deviceCapabilities.supportsWebGL ? "WebGL" : "No WebGL"}${this.deviceCapabilities.isMobile ? ", Mobile" : ""}`;
        }
        /**
         * Check if energy boost is active (legacy API compatibility)
         */
        hasEnergyBoost() {
          return this.currentPerformanceMode.name === "performance" && this.thermalState.temperature === "normal" && (this.batteryState?.charging || (this.batteryState?.level || 0) > 0.5 || !this.batteryState);
        }
        /**
         * Get current effective settings (legacy API compatibility)
         */
        getCurrentSettings() {
          return {
            performanceMode: this.currentPerformanceMode,
            deviceCapabilities: this.deviceCapabilities,
            thermalState: this.thermalState,
            batteryState: this.batteryState,
            webglStatus: this.getWebGLStatus()
          };
        }
      };
      __name(_PerformanceAnalyzer, "PerformanceAnalyzer");
      _PerformanceAnalyzer.instance = null;
      PerformanceAnalyzer = _PerformanceAnalyzer;
      UnifiedPerformanceCoordinator = PerformanceAnalyzer;
    }
  });

  // src-js/core/performance/SimplePerformanceCoordinator.ts
  var _PerformanceManager, PerformanceManager, SimplePerformanceCoordinator;
  var init_SimplePerformanceCoordinator = __esm({
    "src-js/core/performance/SimplePerformanceCoordinator.ts"() {
      "use strict";
      init_UnifiedPerformanceCoordinator();
      init_globalConfig();
      init_UnifiedDebugManager();
      _PerformanceManager = class _PerformanceManager {
        constructor(enhancedDeviceTierDetector, webglIntegration) {
          this.initialized = false;
          if (typeof process !== "undefined" && true) {
            console.warn(
              "\u26A0\uFE0F  [PerformanceManager] Direct instantiation is deprecated. Use PerformanceManager.getInstance() instead. This ensures proper system-wide performance management."
            );
          }
          this.config = ADVANCED_SYSTEM_CONFIG;
          try {
            this.unifiedCoordinator = PerformanceAnalyzer.getInstance(this.config, this);
          } catch {
            this.unifiedCoordinator = new PerformanceAnalyzer(this.config, this);
          }
          Y3KDebug?.debug?.log("PerformanceManager", "High-level performance management - delegating to PerformanceAnalyzer");
        }
        async initialize() {
          if (this.initialized) return;
          this.initialized = true;
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", "Compatibility layer initialized - delegating to PerformanceAnalyzer");
        }
        async healthCheck() {
          if (!this.initialized) {
            return {
              healthy: false,
              details: "Not initialized",
              system: "SimplePerformanceCoordinator"
            };
          }
          const unifiedHealth = this.unifiedCoordinator.getSystemHealth();
          return {
            healthy: unifiedHealth.overall === "healthy",
            details: unifiedHealth.overall === "healthy" ? `Performance monitoring active (${unifiedHealth.totalSubsystems} subsystems)` : `Performance issues detected: ${unifiedHealth.recommendations.join(", ")}`,
            system: "SimplePerformanceCoordinator"
          };
        }
        destroy() {
          this.initialized = false;
          Y3KDebug?.debug?.log("SimplePerformanceCoordinator", "Compatibility layer destroyed");
        }
        updateAnimation(deltaTime) {
        }
        // =============================================================================
        // PUBLIC API - Delegated to PerformanceAnalyzer
        // =============================================================================
        /**
         * Get the performance system for direct access
         * @deprecated Use PerformanceAnalyzer directly instead
         */
        getPerformanceSystem() {
          return this.unifiedCoordinator;
        }
        /**
         * Get current device performance tier
         */
        getDeviceTier() {
          return this.unifiedCoordinator.getDeviceTier();
        }
        /**
         * Get device description for debugging
         */
        getDeviceDescription() {
          return this.unifiedCoordinator.getDeviceDescription();
        }
        /**
         * Check if energy boost is currently active
         */
        hasEnergyBoost() {
          return this.unifiedCoordinator.hasEnergyBoost();
        }
        /**
         * Get current effective performance settings
         */
        getCurrentSettings() {
          return this.unifiedCoordinator.getCurrentSettings();
        }
        /**
         * Get WebGL integration status
         */
        getWebGLStatus() {
          return this.unifiedCoordinator.getWebGLStatus();
        }
        /**
         * Get performance summary for debugging
         */
        getPerformanceSummary() {
          return this.unifiedCoordinator.getPerformanceSummary();
        }
        // =============================================================================
        // REQUIRED INTERFACE COMPATIBILITY
        // =============================================================================
        /**
         * Start monitoring (required by Year3000System interface)
         */
        startMonitoring() {
          this.unifiedCoordinator.startMonitoring();
          Y3KDebug?.debug?.log("PerformanceManager", "Monitoring started (delegated to PerformanceAnalyzer)");
        }
        // =============================================================================
        // ESSENTIAL LEGACY API METHODS (Delegated to PerformanceAnalyzer)
        // =============================================================================
        emitTrace(event, data) {
          return this.unifiedCoordinator.emitTrace(event, data);
        }
        recordMetric(name, value) {
          return this.unifiedCoordinator.recordMetric(name, value);
        }
        getMedianFPS() {
          return this.unifiedCoordinator.getMedianFPS();
        }
        calculateHealthScore() {
          return this.unifiedCoordinator.calculateHealthScore();
        }
        shouldReduceQuality() {
          return this.unifiedCoordinator.shouldReduceQuality();
        }
        timeOperation(name, operation) {
          return this.unifiedCoordinator.timeOperation(name, operation);
        }
        async timeOperationAsync(name, operation) {
          return this.unifiedCoordinator.timeOperationAsync(name, operation);
        }
        getAverageTime(name) {
          return this.unifiedCoordinator.getAverageTime(name);
        }
        updateBudget(name, value) {
          return this.unifiedCoordinator.updateBudget(name, value);
        }
        startTiming(name) {
          return this.unifiedCoordinator.startTiming(name);
        }
        endTiming(timingId, context) {
          return this.unifiedCoordinator.endTiming(timingId, context);
        }
      };
      __name(_PerformanceManager, "PerformanceManager");
      PerformanceManager = _PerformanceManager;
      SimplePerformanceCoordinator = PerformanceManager;
      if (typeof process !== "undefined" && true) {
        console.warn(
          "\u26A0\uFE0F  [SimplePerformanceCoordinator] This module is deprecated. Use PerformanceManager from this same module instead. The SimplePerformanceCoordinator alias will be removed in a future version."
        );
      }
    }
  });

  // src-js/core/performance/DeviceCapabilityDetector.ts
  var _DeviceCapabilityDetector, DeviceCapabilityDetector;
  var init_DeviceCapabilityDetector = __esm({
    "src-js/core/performance/DeviceCapabilityDetector.ts"() {
      "use strict";
      _DeviceCapabilityDetector = class _DeviceCapabilityDetector {
        constructor(config = {}) {
          this.deviceCapabilities = null;
          this.isInitialized = false;
          // New: Cache for expensive computations
          this.benchmarkCache = /* @__PURE__ */ new Map();
          this.detectionStartTime = 0;
          this.config = {
            enableDebug: config.enableDebug || false,
            runStressTests: config.runStressTests !== false,
            spicetifyContext: config.spicetifyContext || this._detectSpicetifyContext(),
            ...config
          };
          if (this.config.enableDebug) {
            console.log(
              "\u{1F50D} [DeviceCapabilityDetector] Initialized",
              this.config.spicetifyContext ? "(Spicetify-optimized)" : "(Standard)"
            );
          }
        }
        // New: Detect if we're running in Spicetify context
        _detectSpicetifyContext() {
          return !!window.Spicetify;
        }
        async initialize() {
          if (this.isInitialized) {
            return this.deviceCapabilities;
          }
          this.detectionStartTime = performance.now();
          if (this.config.enableDebug) {
            console.log(
              "\u{1F50D} [DeviceCapabilityDetector] Starting enhanced capability detection...",
              this.config.spicetifyContext ? "(Spicetify mode)" : "(Standard mode)"
            );
          }
          const memoryData = await this._analyzeMemoryCapabilities();
          const cpuData = await this._analyzeCPUCapabilities();
          const gpuData = await this._analyzeGPUCapabilities();
          this.deviceCapabilities = {
            memory: memoryData,
            cpu: cpuData,
            gpu: gpuData,
            browser: {
              supportsOffscreenCanvas: this._detectOffscreenCanvasSupport(),
              supportsWorkers: this._detectWorkerSupport(),
              supportsSharedArrayBuffer: this._detectSharedArrayBufferSupport(),
              supportsWASM: this._detectWASMSupport(),
              supportsCSSHoudini: this._detectCSSHoudiniSupport()
            },
            display: {
              pixelRatio: window.devicePixelRatio || 1,
              refreshRate: await this._detectRefreshRate(),
              colorGamut: this._detectColorGamut(),
              contrastRatio: this._detectContrastCapability(),
              reducedMotion: this._detectReducedMotion()
            },
            network: {
              effectiveType: navigator.connection?.effectiveType || "unknown",
              downlink: navigator.connection?.downlink || 0,
              rtt: navigator.connection?.rtt || 0,
              saveData: navigator.connection?.saveData || false
            },
            overall: "detecting",
            spicetifyProfile: await this._createSpicetifyProfile(memoryData, cpuData, gpuData)
          };
          if (this.config.runStressTests) {
            await this._runCapabilityTests();
            this.deviceCapabilities.spicetifyProfile = await this._createSpicetifyProfile(
              this.deviceCapabilities.memory,
              this.deviceCapabilities.cpu,
              this.deviceCapabilities.gpu
            );
          }
          this.deviceCapabilities.overall = this._calculateOverallPerformanceLevel();
          this.isInitialized = true;
          const detectionTime = performance.now() - this.detectionStartTime;
          if (this.config.enableDebug) {
            console.log(
              "\u{1F4CA} [DeviceCapabilityDetector] Enhanced detection completed in",
              `${detectionTime.toFixed(1)}ms`,
              "\nSpicetify Profile:",
              this.deviceCapabilities.spicetifyProfile
            );
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F4CA} [DeviceCapabilityDetector] Capabilities detected:",
              this.deviceCapabilities
            );
          }
          return this.deviceCapabilities;
        }
        // New: Get enhanced Spicetify device profile
        getSpicetifyProfile() {
          return this.deviceCapabilities?.spicetifyProfile || null;
        }
        // New: Get recommended quality level (0-100)
        getRecommendedQualityLevel() {
          return this.deviceCapabilities?.spicetifyProfile?.recommendedQualityLevel || 50;
        }
        // Enhanced memory capability analysis with continuous scoring
        async _analyzeMemoryCapabilities() {
          const deviceMemory = navigator.deviceMemory;
          const hasMemoryAPI = typeof deviceMemory === "number";
          const estimatedMemory = deviceMemory || this._estimateMemoryFromOtherSources();
          const jsHeapSizeLimit = performance.memory?.jsHeapSizeLimit || 0;
          const estimatedAvailable = this._estimateAvailableMemory();
          const spicetifyOverhead = this.config.spicetifyContext ? this._estimateSpicetifyOverhead() : 0;
          const score = this._calculateMemoryScore(estimatedMemory, jsHeapSizeLimit, estimatedAvailable);
          return {
            total: estimatedMemory,
            score,
            level: score >= 7 ? "high" : score >= 4 ? "medium" : "low",
            jsHeapSizeLimit,
            estimatedAvailable,
            spicetifyOverhead,
            confidenceLevel: hasMemoryAPI ? 0.9 : 0.6
            // Lower confidence when API unavailable
          };
        }
        _detectMemoryLevel() {
          const memory = navigator.deviceMemory || 6;
          if (memory >= 8) return "high";
          if (memory >= 4) return "medium";
          return "low";
        }
        _estimateAvailableMemory() {
          if (performance.memory) {
            return performance.memory.jsHeapSizeLimit - performance.memory.usedJSHeapSize;
          }
          return (navigator.deviceMemory || 4) * 1024 * 1024 * 1024 * 0.7;
        }
        // Enhanced CPU capability analysis with performance benchmarking
        async _analyzeCPUCapabilities() {
          const cores = navigator.hardwareConcurrency || 4;
          const singleThreadPerformance = await this._benchmarkSingleThreadPerformance();
          const thermalThrottlingRisk = this._estimateThermalThrottlingRisk(cores);
          const score = this._calculateCPUScore(cores, singleThreadPerformance);
          return {
            cores,
            score,
            level: score >= 7 ? "high" : score >= 4 ? "medium" : "low",
            singleThreadPerformance,
            thermalThrottlingRisk,
            confidenceLevel: cores > 1 ? 0.8 : 0.5
            // Lower confidence for single-core detection
          };
        }
        _detectCPULevel() {
          const cores = navigator.hardwareConcurrency || 4;
          if (cores >= 8) return "high";
          if (cores >= 4) return "medium";
          return "low";
        }
        _detectWebGLSupport() {
          try {
            const canvas = document.createElement("canvas");
            return !!(canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
          } catch (e) {
            return false;
          }
        }
        _detectWebGL2Support() {
          try {
            const canvas = document.createElement("canvas");
            return !!canvas.getContext("webgl2");
          } catch (e) {
            return false;
          }
        }
        _getMaxTextureSize() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            return gl ? gl.getParameter(gl.MAX_TEXTURE_SIZE) : 0;
          } catch (e) {
            return 0;
          }
        }
        _getGPUVendor() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) return "unknown";
            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            return debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "unknown";
          } catch (e) {
            return "unknown";
          }
        }
        _getGPURenderer() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) return "unknown";
            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            return debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "unknown";
          } catch (e) {
            return "unknown";
          }
        }
        // Enhanced GPU capability analysis with WebGL performance testing
        async _analyzeGPUCapabilities() {
          const supportsWebGL = this._detectWebGLSupport();
          const supportsWebGL2 = this._detectWebGL2Support();
          const maxTextureSize = this._getMaxTextureSize();
          const vendor = this._getGPUVendor();
          const renderer = this._getGPURenderer();
          const webglCapabilityScore = await this._benchmarkWebGLCapabilities();
          const score = this._calculateGPUScore(renderer, webglCapabilityScore, supportsWebGL2, maxTextureSize);
          return {
            supportsWebGL,
            supportsWebGL2,
            maxTextureSize,
            score,
            level: score >= 7 ? "high" : score >= 4 ? "medium" : "low",
            vendor,
            renderer,
            webglCapabilityScore,
            confidenceLevel: supportsWebGL ? 0.8 : 0.3
            // Much lower confidence without WebGL
          };
        }
        _detectGPULevel() {
          const renderer = this._getGPURenderer().toLowerCase();
          if (/rtx|radeon rx|gtx 16|gtx 20|apple m[1-9]|iris xe/.test(renderer)) {
            return "high";
          }
          if (/gtx|radeon|intel iris|intel uhd|vega|ryzen/.test(renderer)) {
            return "medium";
          }
          return "low";
        }
        _detectOffscreenCanvasSupport() {
          return typeof OffscreenCanvas !== "undefined";
        }
        _detectWorkerSupport() {
          return typeof Worker !== "undefined";
        }
        _detectSharedArrayBufferSupport() {
          return typeof SharedArrayBuffer !== "undefined";
        }
        _detectWASMSupport() {
          return typeof WebAssembly !== "undefined";
        }
        _detectCSSHoudiniSupport() {
          return typeof CSS !== "undefined" && CSS.paintWorklet !== void 0;
        }
        async _detectRefreshRate() {
          return new Promise((resolve) => {
            let lastTime = performance.now();
            let frameCount = 0;
            const samples = [];
            const measure = /* @__PURE__ */ __name(() => {
              const currentTime = performance.now();
              const delta = currentTime - lastTime;
              samples.push(1e3 / delta);
              lastTime = currentTime;
              frameCount++;
              if (frameCount < 10) {
                requestAnimationFrame(measure);
              } else {
                const avgFPS = samples.reduce((a, b) => a + b, 0) / samples.length;
                resolve(Math.round(avgFPS));
              }
            }, "measure");
            requestAnimationFrame(measure);
          });
        }
        _detectColorGamut() {
          if (window.matchMedia("(color-gamut: p3)").matches) return "p3";
          if (window.matchMedia("(color-gamut: srgb)").matches) return "srgb";
          return "limited";
        }
        _detectContrastCapability() {
          if (window.matchMedia("(dynamic-range: high)").matches) return "high";
          if (window.matchMedia("(contrast: high)").matches) return "high";
          return "standard";
        }
        _detectReducedMotion() {
          return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        }
        async _runCapabilityTests() {
          if (this.deviceCapabilities) {
            this.deviceCapabilities.gpu.stressTestScore = await this._runGPUStressTest();
            this.deviceCapabilities.memory.stressTestScore = await this._runMemoryStressTest();
          }
          if (this.config.enableDebug) {
            console.log("\u26A1 [DeviceCapabilityDetector] Capability tests completed");
          }
        }
        async _runGPUStressTest() {
          return 0;
        }
        async _runMemoryStressTest() {
          return 0;
        }
        // New: Enhanced scoring and helper methods
        _estimateMemoryFromOtherSources() {
          const cores = navigator.hardwareConcurrency || 4;
          const screen = window.screen;
          let estimate = 4;
          if (cores >= 8) estimate = 16;
          else if (cores >= 6) estimate = 12;
          else if (cores >= 4) estimate = 8;
          else if (cores >= 2) estimate = 6;
          if (screen.width * screen.height > 2073600) estimate *= 1.5;
          return Math.round(estimate);
        }
        _estimateSpicetifyOverhead() {
          return this.config.spicetifyContext ? 0.15 : 0;
        }
        _calculateMemoryScore(memory, heapLimit, available) {
          let score = Math.min(memory / 2, 10);
          if (heapLimit > 0) {
            const heapGB = heapLimit / (1024 * 1024 * 1024);
            score = Math.max(score, Math.min(heapGB, 10));
          }
          if (this.config.spicetifyContext) {
            score *= 0.85;
          }
          return Math.min(Math.max(score, 1), 10);
        }
        async _benchmarkSingleThreadPerformance() {
          const cacheKey = "singleThreadPerf";
          if (this.benchmarkCache.has(cacheKey)) {
            return this.benchmarkCache.get(cacheKey);
          }
          return new Promise((resolve) => {
            const start = performance.now();
            let result = 0;
            for (let i = 0; i < 5e5; i++) {
              result += Math.sin(i) * Math.cos(i);
            }
            const duration = performance.now() - start;
            const score = Math.max(1, Math.min(10, 50 / duration));
            this.benchmarkCache.set(cacheKey, score);
            resolve(score);
          });
        }
        _estimateThermalThrottlingRisk(cores) {
          const isMobile = /Mobi|Android/i.test(navigator.userAgent);
          let risk = 0.1;
          if (cores >= 8) risk += 0.2;
          if (isMobile) risk += 0.3;
          return Math.min(risk, 1);
        }
        _calculateCPUScore(cores, singleThreadPerf) {
          const coreScore = Math.min(cores / 2, 10);
          const perfWeight = 0.7;
          return Math.min(coreScore * (1 - perfWeight) + singleThreadPerf * perfWeight, 10);
        }
        async _benchmarkWebGLCapabilities() {
          const cacheKey = "webglCapability";
          if (this.benchmarkCache.has(cacheKey)) {
            return this.benchmarkCache.get(cacheKey);
          }
          if (!this._detectWebGLSupport()) {
            this.benchmarkCache.set(cacheKey, 0);
            return 0;
          }
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
          if (!gl) {
            this.benchmarkCache.set(cacheKey, 0);
            return 0;
          }
          let score = 2;
          if (gl.getExtension("OES_texture_float")) score += 1;
          if (gl.getExtension("WEBGL_depth_texture")) score += 1;
          if (gl.getExtension("OES_element_index_uint")) score += 1;
          const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          if (maxTextureSize >= 4096) score += 2;
          else if (maxTextureSize >= 2048) score += 1;
          const maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
          if (maxVertexAttribs >= 16) score += 1;
          if (gl instanceof WebGL2RenderingContext) score += 2;
          this.benchmarkCache.set(cacheKey, Math.min(score, 10));
          return Math.min(score, 10);
        }
        _calculateGPUScore(renderer, webglScore, hasWebGL2, maxTexture) {
          let score = webglScore;
          const rendererLower = renderer.toLowerCase();
          if (/rtx|radeon rx|apple m[1-9]|arc a/.test(rendererLower)) {
            score += 2;
          } else if (/gtx|radeon|vega|iris xe|ryzen/.test(rendererLower)) {
            score += 1;
          } else if (/intel|qualcomm|mali|adreno/.test(rendererLower)) {
            score += 0.5;
          }
          return Math.min(Math.max(score, 1), 10);
        }
        async _createSpicetifyProfile(memory, cpu, gpu) {
          const memoryScore = memory.score;
          const cpuScore = cpu.score;
          const gpuScore = gpu.score;
          const compositeScore = Math.round(
            (memoryScore * 0.3 + cpuScore * 0.4 + gpuScore * 0.3) * 10
          );
          let recommendedQuality = Math.min(compositeScore, 100);
          if (this.config.spicetifyContext) {
            recommendedQuality *= 1 - memory.spicetifyOverhead;
          }
          recommendedQuality = Math.max(recommendedQuality, 20);
          const confidenceLevel = (memory.confidenceLevel + cpu.confidenceLevel + gpu.confidenceLevel) / 3;
          return {
            memoryScore,
            cpuScore,
            gpuScore,
            compositeScore,
            spicetifyOverhead: memory.spicetifyOverhead,
            userQualityPreference: "auto",
            // Default, will be overridden by settings
            confidenceLevel,
            recommendedQualityLevel: Math.round(recommendedQuality)
          };
        }
        _calculateOverallPerformanceLevel() {
          if (!this.deviceCapabilities) return "low";
          const compositeScore = this.deviceCapabilities.spicetifyProfile.compositeScore;
          const confidence = this.deviceCapabilities.spicetifyProfile.confidenceLevel;
          const adjustedScore = compositeScore * (0.7 + confidence * 0.3);
          if (adjustedScore >= 70) return "high";
          if (adjustedScore >= 40) return "medium";
          return "low";
        }
        getCapabilities() {
          if (!this.isInitialized) {
            console.warn(
              "[DeviceCapabilityDetector] Not initialized - call initialize() first"
            );
            return null;
          }
          return this.deviceCapabilities;
        }
        /**
         * Check if WebGL support is available (for BackgroundStrategySelector)
         */
        hasWebGLSupport() {
          if (this.isInitialized && this.deviceCapabilities) {
            return this.deviceCapabilities.gpu.supportsWebGL;
          }
          return this._detectWebGLSupport();
        }
        /**
         * Check if WebGL2 support is available
         */
        hasWebGL2Support() {
          if (this.isInitialized && this.deviceCapabilities) {
            return this.deviceCapabilities.gpu.supportsWebGL2;
          }
          return this._detectWebGL2Support();
        }
        destroy() {
          this.deviceCapabilities = null;
          this.isInitialized = false;
          if (this.config.enableDebug) {
            console.log("\u{1F50D} [DeviceCapabilityDetector] Destroyed");
          }
        }
        /**
         * Recommend a performance-quality label that callers (e.g., visual systems)
         * can use to pick an appropriate performance profile.
         * Returns one of `"low" | "balanced" | "high"`.
         */
        recommendPerformanceQuality() {
          if (!this.isInitialized || !this.deviceCapabilities) {
            return "balanced";
          }
          switch (this.deviceCapabilities.overall) {
            case "high":
              return "high";
            case "medium":
              return "balanced";
            case "low":
            default:
              return "low";
          }
        }
        // ===================================================================
        // ENHANCED TIER DETECTION (from EnhancedDeviceTierDetector)
        // ===================================================================
        /**
         * Enhanced tier detection with focus on giving most users full experience
         * Integrated from EnhancedDeviceTierDetector
         */
        static detectTier() {
          const capabilities = this._analyzeBasicCapabilities();
          const reasoning = [];
          let tier = "medium";
          let confidence = 0.8;
          if (this._isHighTierDevice(capabilities, reasoning)) {
            tier = "high";
            confidence = 0.9;
          } else if (this._isLowTierDevice(capabilities, reasoning)) {
            tier = "low";
            confidence = 0.85;
          } else {
            reasoning.push("Standard modern device - full experience enabled");
            reasoning.push(`${capabilities.memory}GB RAM, ${capabilities.cores} cores, WebGL2: ${capabilities.webgl2}`);
          }
          const result = {
            tier,
            confidence,
            reasoning,
            capabilities
          };
          console.log("\u{1F50D} [DeviceCapabilityDetector] Enhanced tier detection complete", result);
          return result;
        }
        static _analyzeBasicCapabilities() {
          const memory = navigator.deviceMemory || this._estimateMemory();
          const cores = navigator.hardwareConcurrency || this._estimateCores();
          const webgl = this._checkWebGLSupport();
          const webgl2 = this._checkWebGL2Support();
          const userAgent = navigator.userAgent;
          const platform = navigator.platform || "unknown";
          return {
            memory,
            cores,
            webgl,
            webgl2,
            userAgent,
            platform,
            hardwareInfo: {
              isHighEnd: this._detectHighEndHardware(memory, cores, userAgent),
              isMobile: this._isMobileDevice(userAgent, platform),
              isOldDevice: this._isOldDevice(userAgent),
              hasPerformanceIndicators: this._hasPerformanceIndicators(userAgent)
            }
          };
        }
        static _isHighTierDevice(capabilities, reasoning) {
          const { memory, cores, webgl2, hardwareInfo } = capabilities;
          const hasHighEndSpecs = memory >= 8 && cores >= 6 && webgl2;
          if (!hasHighEndSpecs) {
            return false;
          }
          const indicators = [];
          if (memory >= 16) indicators.push("16+GB RAM");
          if (cores >= 8) indicators.push("8+ CPU cores");
          if (hardwareInfo.hasPerformanceIndicators) indicators.push("Performance GPU detected");
          if (hardwareInfo.isHighEnd) indicators.push("High-end hardware signatures");
          if (indicators.length >= 2) {
            reasoning.push("High-end device detected");
            reasoning.push(`Specs: ${memory}GB RAM, ${cores} cores, WebGL2: ${webgl2}`);
            reasoning.push(`Indicators: ${indicators.join(", ")}`);
            return true;
          }
          if (this._isGamingOrWorkstation(capabilities)) {
            reasoning.push("Gaming/workstation device detected");
            reasoning.push(`High-performance device indicators found`);
            return true;
          }
          return false;
        }
        static _isLowTierDevice(capabilities, reasoning) {
          const { memory, cores, webgl2, hardwareInfo } = capabilities;
          const reasons = [];
          if (memory < 4) {
            reasons.push(`Low memory: ${memory}GB`);
          }
          if (cores < 4) {
            reasons.push(`Few CPU cores: ${cores}`);
          }
          if (!webgl2) {
            reasons.push("No WebGL2 support");
          }
          if (hardwareInfo.isOldDevice) {
            reasons.push("Legacy device detected");
          }
          if (hardwareInfo.isMobile && memory <= 4 && cores <= 4) {
            reasons.push("Resource-constrained mobile device");
          }
          if (reasons.length >= 2) {
            reasoning.push("Budget/legacy device detected - enabling performance optimizations");
            reasoning.push(...reasons);
            return true;
          }
          return false;
        }
        static _estimateMemory() {
          const ua = navigator.userAgent.toLowerCase();
          if (ua.includes("mobile") || ua.includes("android")) {
            return 4;
          }
          if (ua.includes("ipad") || ua.includes("tablet")) {
            return 6;
          }
          return 8;
        }
        static _estimateCores() {
          const ua = navigator.userAgent.toLowerCase();
          if (ua.includes("mobile")) {
            return 4;
          }
          return 4;
        }
        static _checkWebGLSupport() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            const hasWebGL = gl !== null;
            canvas.remove();
            return hasWebGL;
          } catch {
            return false;
          }
        }
        static _checkWebGL2Support() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl2");
            const hasWebGL2 = gl !== null;
            canvas.remove();
            return hasWebGL2;
          } catch {
            return false;
          }
        }
        static _detectHighEndHardware(memory, cores, userAgent) {
          const ua = userAgent.toLowerCase();
          const indicators = [
            ua.includes("gaming"),
            ua.includes("nvidia"),
            ua.includes("amd"),
            ua.includes("geforce"),
            ua.includes("radeon"),
            memory >= 16,
            cores >= 8
          ];
          return indicators.filter(Boolean).length >= 2;
        }
        static _isMobileDevice(userAgent, platform) {
          const ua = userAgent.toLowerCase();
          const p = platform.toLowerCase();
          return ua.includes("mobile") || ua.includes("android") || ua.includes("iphone") || ua.includes("ipad") || p.includes("arm") || "ontouchstart" in window;
        }
        static _isOldDevice(userAgent) {
          const ua = userAgent.toLowerCase();
          const oldBrowsers = [
            /chrome\/[1-6]\d\./,
            // Chrome < 70
            /firefox\/[1-5]\d\./,
            // Firefox < 60
            /safari\/[1-9]\./,
            // Very old Safari
            /msie|trident/
            // Internet Explorer
          ];
          return oldBrowsers.some((pattern) => pattern.test(ua));
        }
        static _hasPerformanceIndicators(userAgent) {
          const ua = userAgent.toLowerCase();
          const indicators = [
            "nvidia",
            "amd",
            "geforce",
            "radeon",
            "quadro",
            "gaming",
            "performance"
          ];
          return indicators.some((indicator) => ua.includes(indicator));
        }
        static _isGamingOrWorkstation(capabilities) {
          const { userAgent, memory, cores } = capabilities;
          const ua = userAgent.toLowerCase();
          const gamingIndicators = [
            ua.includes("gaming"),
            ua.includes("nvidia"),
            ua.includes("geforce"),
            ua.includes("rog"),
            // ASUS ROG
            ua.includes("alienware"),
            memory >= 16 && cores >= 8
          ];
          return gamingIndicators.filter(Boolean).length >= 2;
        }
      };
      __name(_DeviceCapabilityDetector, "DeviceCapabilityDetector");
      DeviceCapabilityDetector = _DeviceCapabilityDetector;
    }
  });

  // src-js/core/performance/EnhancedDeviceTierDetector.ts
  var _EnhancedDeviceTierDetector, EnhancedDeviceTierDetector;
  var init_EnhancedDeviceTierDetector = __esm({
    "src-js/core/performance/EnhancedDeviceTierDetector.ts"() {
      "use strict";
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      _EnhancedDeviceTierDetector = class _EnhancedDeviceTierDetector {
        /**
         * Detect device performance tier with focus on giving most users full experience
         * @deprecated Use DeviceCapabilityDetector.detectTier() instead
         */
        static detectTier() {
          if (typeof process !== "undefined" && true) {
            console.warn(
              "\u26A0\uFE0F  [EnhancedDeviceTierDetector] This class is deprecated. Use DeviceCapabilityDetector.detectTier() instead. This compatibility layer will be removed in a future version."
            );
          }
          const result = DeviceCapabilityDetector.detectTier();
          Y3KDebug?.debug?.log("EnhancedDeviceTierDetector", "Compatibility layer - delegating to DeviceCapabilityDetector", result);
          return result;
        }
        /**
         * Legacy method compatibility - _analyzeDeviceCapabilities
         * @deprecated Use DeviceCapabilityDetector.detectTier() instead
         */
        static _analyzeDeviceCapabilities() {
          const memory = navigator.deviceMemory || this._estimateMemory();
          const cores = navigator.hardwareConcurrency || this._estimateCores();
          const webgl = this._checkWebGLSupport();
          const webgl2 = this._checkWebGL2Support();
          const userAgent = navigator.userAgent;
          const platform = navigator.platform || "unknown";
          return {
            memory,
            cores,
            webgl,
            webgl2,
            userAgent,
            platform,
            hardwareInfo: {
              isHighEnd: this._detectHighEndHardware(memory, cores, userAgent),
              isMobile: this._isMobileDevice(userAgent, platform),
              isOldDevice: this._isOldDevice(userAgent),
              hasPerformanceIndicators: this._hasPerformanceIndicators(userAgent)
            }
          };
        }
        // Legacy helper methods for backward compatibility
        static _estimateMemory() {
          const ua = navigator.userAgent.toLowerCase();
          if (ua.includes("mobile") || ua.includes("android")) return 4;
          if (ua.includes("ipad") || ua.includes("tablet")) return 6;
          return 8;
        }
        static _estimateCores() {
          const ua = navigator.userAgent.toLowerCase();
          if (ua.includes("mobile")) return 4;
          return 4;
        }
        static _checkWebGLSupport() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            const hasWebGL = gl !== null;
            canvas.remove();
            return hasWebGL;
          } catch {
            return false;
          }
        }
        static _checkWebGL2Support() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl2");
            const hasWebGL2 = gl !== null;
            canvas.remove();
            return hasWebGL2;
          } catch {
            return false;
          }
        }
        static _detectHighEndHardware(memory, cores, userAgent) {
          const ua = userAgent.toLowerCase();
          const indicators = [
            ua.includes("gaming"),
            ua.includes("nvidia"),
            ua.includes("amd"),
            ua.includes("geforce"),
            ua.includes("radeon"),
            memory >= 16,
            cores >= 8
          ];
          return indicators.filter(Boolean).length >= 2;
        }
        static _isMobileDevice(userAgent, platform) {
          const ua = userAgent.toLowerCase();
          const p = platform.toLowerCase();
          return ua.includes("mobile") || ua.includes("android") || ua.includes("iphone") || ua.includes("ipad") || p.includes("arm") || "ontouchstart" in window;
        }
        static _isOldDevice(userAgent) {
          const ua = userAgent.toLowerCase();
          const oldBrowsers = [
            /chrome\/[1-6]\d\./,
            // Chrome < 70
            /firefox\/[1-5]\d\./,
            // Firefox < 60
            /safari\/[1-9]\./,
            // Very old Safari
            /msie|trident/
            // Internet Explorer
          ];
          return oldBrowsers.some((pattern) => pattern.test(ua));
        }
        static _hasPerformanceIndicators(userAgent) {
          const ua = userAgent.toLowerCase();
          const indicators = [
            "nvidia",
            "amd",
            "geforce",
            "radeon",
            "quadro",
            "gaming",
            "performance"
          ];
          return indicators.some((indicator) => ua.includes(indicator));
        }
        /**
         * Get device description string for debugging and logging
         * @deprecated Use DeviceCapabilityDetector.getDeviceInfo() instead
         */
        static getDeviceDescription(capabilities) {
          if (typeof process !== "undefined" && true) {
            console.warn(
              "\u26A0\uFE0F  [EnhancedDeviceTierDetector] getDeviceDescription is deprecated. Use DeviceCapabilityDetector.getDeviceInfo() instead."
            );
          }
          const { memory, cores, platform, hardwareInfo } = capabilities;
          const deviceType = hardwareInfo.isMobile ? "Mobile" : "Desktop";
          const qualifiers = [];
          if (hardwareInfo.isHighEnd) qualifiers.push("High-End");
          if (hardwareInfo.isOldDevice) qualifiers.push("Legacy");
          return `${deviceType} Device (${memory}GB RAM, ${cores} cores, ${platform})${qualifiers.length ? ` [${qualifiers.join(", ")}]` : ""}`;
        }
      };
      __name(_EnhancedDeviceTierDetector, "EnhancedDeviceTierDetector");
      EnhancedDeviceTierDetector = _EnhancedDeviceTierDetector;
      if (typeof process !== "undefined" && true) {
        console.warn(
          "\u26A0\uFE0F  [EnhancedDeviceTierDetector] This class is deprecated. Use DeviceCapabilityDetector.detectTier() instead. This compatibility layer will be removed in a future version."
        );
      }
    }
  });

  // src-js/core/performance/SimpleTierBasedPerformanceSystem.ts
  var _SimpleTierBasedPerformanceSystem, SimpleTierBasedPerformanceSystem;
  var init_SimpleTierBasedPerformanceSystem = __esm({
    "src-js/core/performance/SimpleTierBasedPerformanceSystem.ts"() {
      "use strict";
      init_EnhancedDeviceTierDetector();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      _SimpleTierBasedPerformanceSystem = class _SimpleTierBasedPerformanceSystem {
        constructor(enhancedDeviceTierDetector) {
          this.initialized = false;
          this.webglIntegration = null;
          // Performance state
          this.deviceTier = "medium";
          this.tierDetectionResult = null;
          this.energyBoostActive = false;
          this.energyBoostTimeout = null;
          // Configuration
          this.tierSettings = {
            low: {
              webglQuality: "low",
              animationDensity: 0.6,
              // Still decent for budget devices
              updateFrequency: 45,
              // Smooth enough
              particleMultiplier: 0.4,
              corridorEffects: false,
              // Only restriction for low tier
              advancedFeatures: false,
              experimentalFeatures: false
            },
            medium: {
              webglQuality: "high",
              // Full experience for standard devices
              animationDensity: 0.9,
              // Near maximum
              updateFrequency: 60,
              // Full smoothness
              particleMultiplier: 1,
              // Full particles
              corridorEffects: true,
              // Full corridor effects
              advancedFeatures: true,
              // All standard features
              experimentalFeatures: false
            },
            high: {
              webglQuality: "high",
              animationDensity: 1,
              // Maximum
              updateFrequency: 60,
              particleMultiplier: 1.2,
              // Extra particles for high-end
              corridorEffects: true,
              advancedFeatures: true,
              experimentalFeatures: true
              // Experimental features for enthusiasts
            }
          };
          this.energyBoostSettings = {
            animationBoost: 1.3,
            // 30% boost during energetic songs
            particleBoost: 1.5,
            // 50% more particles
            duration: 1e4
            // 10 seconds after song change
          };
          this.enhancedDeviceTierDetector = enhancedDeviceTierDetector;
          this.currentSettings = this.tierSettings.medium;
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "Initialized with tier-based performance management");
        }
        async initialize() {
          if (this.initialized) return;
          this.tierDetectionResult = EnhancedDeviceTierDetector.detectTier();
          this.deviceTier = this.tierDetectionResult.tier;
          this.currentSettings = this.tierSettings[this.deviceTier];
          this._setupMusicAnalysisListener();
          this._applyTierSettings();
          this.initialized = true;
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "Initialization complete", {
            deviceTier: this.deviceTier,
            confidence: this.tierDetectionResult.confidence,
            reasoning: this.tierDetectionResult.reasoning,
            deviceDescription: EnhancedDeviceTierDetector.getDeviceDescription(this.tierDetectionResult.capabilities),
            settings: this.currentSettings
          });
        }
        async healthCheck() {
          if (!this.initialized) {
            return {
              healthy: false,
              details: "Not initialized",
              system: "SimpleTierBasedPerformanceSystem"
            };
          }
          return {
            healthy: true,
            details: `Performance tier: ${this.deviceTier}, Energy boost: ${this.energyBoostActive ? "active" : "inactive"}`,
            system: "SimpleTierBasedPerformanceSystem"
          };
        }
        destroy() {
          if (this.energyBoostTimeout) {
            clearTimeout(this.energyBoostTimeout);
            this.energyBoostTimeout = null;
          }
          unifiedEventBus.unsubscribe("colors:extracted");
          unifiedEventBus.unsubscribe("music:track-changed");
          this.initialized = false;
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "Destroyed");
        }
        updateAnimation(deltaTime) {
        }
        // =============================================================================
        // PUBLIC API
        // =============================================================================
        /**
         * Register WebGL integration for performance management
         */
        registerWebGLIntegration(integration) {
          this.webglIntegration = integration;
          if (this.initialized) {
            this._applyWebGLSettings();
          }
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "WebGL integration registered");
        }
        /**
         * Get detected device tier
         */
        getDeviceTier() {
          return this.deviceTier;
        }
        /**
         * Get full tier detection result including reasoning and device capabilities
         */
        getTierDetectionResult() {
          return this.tierDetectionResult;
        }
        /**
         * Get human-readable device description
         */
        getDeviceDescription() {
          return this.tierDetectionResult ? EnhancedDeviceTierDetector.getDeviceDescription(this.tierDetectionResult.capabilities) : "Unknown device";
        }
        /**
         * Get current tier settings
         */
        getCurrentSettings() {
          return { ...this.currentSettings };
        }
        /**
         * Check if energy boost is currently active
         */
        hasEnergyBoost() {
          return this.energyBoostActive;
        }
        /**
         * Get effective settings including energy boost
         */
        getEffectiveSettings() {
          const base = { ...this.currentSettings };
          if (this.energyBoostActive) {
            return {
              ...base,
              animationDensity: Math.min(1, base.animationDensity * this.energyBoostSettings.animationBoost),
              particleMultiplier: base.particleMultiplier * this.energyBoostSettings.particleBoost,
              energyBoosted: true
            };
          }
          return {
            ...base,
            energyBoosted: false
          };
        }
        /**
         * Force a specific tier (for testing/debugging)
         */
        setTier(tier) {
          this.deviceTier = tier;
          this.currentSettings = this.tierSettings[tier];
          this._applyTierSettings();
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", `Tier manually set to ${tier}`);
        }
        // =============================================================================
        // PRIVATE IMPLEMENTATION
        // =============================================================================
        _setupMusicAnalysisListener() {
          unifiedEventBus.subscribe("colors:extracted", (data) => {
            if (data.musicData) {
              this._handleMusicAnalysis({
                energy: data.musicData.energy || 0.5,
                valence: data.musicData.valence || 0.5,
                bpm: data.musicData.tempo || 120,
                genre: data.musicData.genre || "unknown"
              });
            }
          });
          unifiedEventBus.subscribe("music:track-changed", (data) => {
            this._handleSongChange(data);
          });
        }
        _handleSongChange(data) {
          if (data.analysis) {
            this._checkEnergyBoost(data.analysis);
          }
        }
        _handleMusicAnalysis(analysis) {
          this._checkEnergyBoost(analysis);
        }
        _checkEnergyBoost(analysis) {
          const isEnergeticSong = analysis.energy > 0.7 && analysis.bpm > 130 && (analysis.danceability || 0) > 0.6;
          const shouldBoost = isEnergeticSong && !this.energyBoostActive;
          const shouldUnboost = !isEnergeticSong && this.energyBoostActive;
          if (shouldBoost) {
            this._activateEnergyBoost(analysis);
          } else if (shouldUnboost) {
            this._deactivateEnergyBoost();
          }
        }
        _activateEnergyBoost(analysis) {
          this.energyBoostActive = true;
          if (this.energyBoostTimeout) {
            clearTimeout(this.energyBoostTimeout);
          }
          this._applyTierSettings();
          this.energyBoostTimeout = window.setTimeout(() => {
            this._deactivateEnergyBoost();
          }, this.energyBoostSettings.duration);
          unifiedEventBus.emit("performance:tier-changed", {
            tier: this.deviceTier,
            // Convert tier format
            previousTier: this.deviceTier,
            timestamp: Date.now()
          });
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "Energy boost activated", {
            bpm: analysis.bpm,
            energy: analysis.energy,
            danceability: analysis.danceability
          });
        }
        _deactivateEnergyBoost() {
          if (!this.energyBoostActive) return;
          this.energyBoostActive = false;
          if (this.energyBoostTimeout) {
            clearTimeout(this.energyBoostTimeout);
            this.energyBoostTimeout = null;
          }
          this._applyTierSettings();
          unifiedEventBus.emit("performance:tier-changed", {
            tier: this.deviceTier,
            previousTier: this.deviceTier,
            timestamp: Date.now()
          });
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "Energy boost deactivated");
        }
        _applyTierSettings() {
          this._applyWebGLSettings();
          this._applySystemSettings();
          const effectiveSettings = this.getEffectiveSettings();
          unifiedEventBus.emit("performance:tier-changed", {
            tier: this.deviceTier,
            previousTier: this.deviceTier,
            timestamp: Date.now()
          });
        }
        _applyWebGLSettings() {
          if (!this.webglIntegration) return;
          const effectiveSettings = this.getEffectiveSettings();
          this.webglIntegration.setQuality(effectiveSettings.webglQuality);
          Y3KDebug?.debug?.log("SimpleTierBasedPerformanceSystem", "WebGL settings applied", {
            tier: this.deviceTier,
            quality: effectiveSettings.webglQuality,
            energyBoosted: effectiveSettings.energyBoosted
          });
        }
        _applySystemSettings() {
          const effectiveSettings = this.getEffectiveSettings();
          unifiedEventBus.emit("performance:frame", {
            deltaTime: 16,
            // Approximate 60fps
            fps: effectiveSettings.updateFrequency,
            memoryUsage: 0.5,
            // Placeholder
            timestamp: Date.now()
          });
        }
      };
      __name(_SimpleTierBasedPerformanceSystem, "SimpleTierBasedPerformanceSystem");
      SimpleTierBasedPerformanceSystem = _SimpleTierBasedPerformanceSystem;
    }
  });

  // src-js/core/webgl/UnifiedWebGLController.ts
  var _UnifiedWebGLController, UnifiedWebGLController;
  var init_UnifiedWebGLController = __esm({
    "src-js/core/webgl/UnifiedWebGLController.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_UnifiedEventBus();
      _UnifiedWebGLController = class _UnifiedWebGLController {
        constructor(deviceCapabilities) {
          this.initialized = false;
          this.currentState = "disabled";
          // Registered WebGL systems (ordered by priority)
          this.webglSystems = /* @__PURE__ */ new Map();
          // Performance monitoring
          this.lastStateChange = 0;
          this.stateChangeHistory = [];
          // User preference tracking
          this.userExplicitlyDisabled = false;
          this.userExplicitQuality = null;
          this.deviceCapabilities = deviceCapabilities;
          this.config = {
            enabled: true,
            quality: "medium",
            forceEnabled: false,
            allowPerformanceAdjustment: true
          };
          Y3KDebug?.debug?.log("UnifiedWebGLController", "Initialized with unified WebGL management");
        }
        async initialize() {
          if (this.initialized) return;
          if (!this.deviceCapabilities.isInitialized) {
            await this.deviceCapabilities.initialize();
          }
          await this._loadSettings();
          await this._determineInitialState();
          this._setupEventListeners();
          this._applyStateToAllSystems();
          this.initialized = true;
          Y3KDebug?.debug?.log("UnifiedWebGLController", "Initialization complete", {
            state: this.currentState,
            quality: this.config.quality,
            systemCount: this.webglSystems.size
          });
        }
        async healthCheck() {
          if (!this.initialized) {
            return {
              healthy: false,
              details: "Not initialized",
              system: "UnifiedWebGLController"
            };
          }
          const systemIssues = [];
          for (const [name, ref] of this.webglSystems) {
            if (ref.system.healthCheck) {
              try {
                const health = await ref.system.healthCheck();
                if (!health.healthy) {
                  systemIssues.push(`${name}: ${health.details || "unhealthy"}`);
                }
              } catch (error) {
                systemIssues.push(`${name}: health check failed`);
              }
            }
          }
          const recentStateChanges = this.stateChangeHistory.filter((change) => Date.now() - change.timestamp < 3e4).length;
          if (systemIssues.length > 0 || recentStateChanges > 3) {
            return {
              healthy: true,
              // Still working, but with issues
              details: `Issues detected: ${systemIssues.join(", ")}`,
              issues: systemIssues,
              system: "UnifiedWebGLController"
            };
          }
          return {
            healthy: true,
            details: "All WebGL systems operating normally",
            system: "UnifiedWebGLController"
          };
        }
        destroy() {
          this._setState("disabled");
          this.webglSystems.clear();
          unifiedEventBus.unsubscribe("settings:changed");
          unifiedEventBus.unsubscribe("system:state-changed");
          this.initialized = false;
          Y3KDebug?.debug?.log("UnifiedWebGLController", "Destroyed - all WebGL systems disabled");
        }
        updateAnimation(deltaTime) {
          if (this.currentState === "webgl-active") {
            for (const [name, ref] of this.webglSystems) {
              if (ref.system.updateAnimation) {
                try {
                  ref.system.updateAnimation(deltaTime);
                } catch (error) {
                  Y3KDebug?.debug?.warn("UnifiedWebGLController", `Animation update failed for ${name}:`, error);
                }
              }
            }
          }
        }
        // =============================================================================
        // PUBLIC API - Simple Developer Interface
        // =============================================================================
        /**
         * Enable all WebGL effects
         */
        enable() {
          this.userExplicitlyDisabled = false;
          this.config.enabled = true;
          this._determineAndApplyState();
          this._saveSettings();
          Y3KDebug?.debug?.log("UnifiedWebGLController", "WebGL enabled by user");
        }
        /**
         * Disable all WebGL effects (fallback to CSS)
         */
        disable() {
          this.userExplicitlyDisabled = true;
          this.config.enabled = false;
          this._setState("css-fallback");
          this._saveSettings();
          Y3KDebug?.debug?.log("UnifiedWebGLController", "WebGL disabled by user");
        }
        /**
         * Set quality level for all WebGL effects
         */
        setQuality(quality) {
          this.userExplicitQuality = quality;
          this.config.quality = quality;
          this._applyQualityToAllSystems();
          this._saveSettings();
          Y3KDebug?.debug?.log("UnifiedWebGLController", `Quality set to ${quality} by user`);
        }
        /**
         * Check if WebGL is currently enabled and active
         */
        isEnabled() {
          return this.currentState === "webgl-active";
        }
        /**
         * Check if WebGL is available (device supports it)
         */
        isAvailable() {
          const profile = this.deviceCapabilities.getSpicetifyProfile();
          return profile?.webglCapabilities?.available || false;
        }
        /**
         * Get current WebGL state
         */
        getState() {
          return this.currentState;
        }
        /**
         * Get current quality level
         */
        getQuality() {
          return this.config.quality;
        }
        /**
         * Force enable WebGL (override device capability detection)
         */
        forceEnable(force = true) {
          this.config.forceEnabled = force;
          this._determineAndApplyState();
          this._saveSettings();
          Y3KDebug?.debug?.log("UnifiedWebGLController", `Force enable set to ${force}`);
        }
        // =============================================================================
        // SYSTEM REGISTRATION
        // =============================================================================
        /**
         * Register a WebGL system for unified management
         */
        registerSystem(name, system, priority = 0) {
          this.webglSystems.set(name, {
            system,
            name,
            priority
          });
          if (this.initialized) {
            this._applyStateToSystem(name, system);
          }
          Y3KDebug?.debug?.log("UnifiedWebGLController", `System registered: ${name} (priority: ${priority})`);
        }
        /**
         * Unregister a WebGL system
         */
        unregisterSystem(name) {
          const systemRef = this.webglSystems.get(name);
          if (systemRef) {
            if (systemRef.system.setEnabled) {
              systemRef.system.setEnabled(false);
            }
            this.webglSystems.delete(name);
            Y3KDebug?.debug?.log("UnifiedWebGLController", `System unregistered: ${name}`);
          }
        }
        // =============================================================================
        // PERFORMANCE SYSTEM INTEGRATION
        // =============================================================================
        /**
         * Called by performance system to suggest quality adjustment
         */
        suggestQualityAdjustment(suggestedQuality, reason) {
          if (!this.config.allowPerformanceAdjustment) {
            Y3KDebug?.debug?.log("UnifiedWebGLController", `Performance adjustment ignored (not allowed): ${reason}`);
            return;
          }
          if (this.userExplicitQuality !== null) {
            Y3KDebug?.debug?.log("UnifiedWebGLController", `Performance adjustment ignored (user set explicit quality): ${reason}`);
            return;
          }
          if (this.config.quality !== suggestedQuality) {
            const oldQuality = this.config.quality;
            this.config.quality = suggestedQuality;
            this._applyQualityToAllSystems();
            Y3KDebug?.debug?.log("UnifiedWebGLController", `Quality adjusted by performance system: ${oldQuality} \u2192 ${suggestedQuality} (${reason})`);
          }
        }
        /**
         * Called by performance system to temporarily disable WebGL
         */
        performanceDisable(reason) {
          if (!this.config.allowPerformanceAdjustment || this.userExplicitlyDisabled === false) {
            return;
          }
          if (this.currentState === "webgl-active") {
            this._setState("css-fallback");
            Y3KDebug?.debug?.log("UnifiedWebGLController", `WebGL disabled by performance system: ${reason}`);
          }
        }
        /**
         * Called by performance system to re-enable WebGL when performance improves
         */
        performanceEnable(reason) {
          if (!this.config.allowPerformanceAdjustment || this.userExplicitlyDisabled) {
            return;
          }
          if (this.currentState === "css-fallback" && this.config.enabled) {
            this._determineAndApplyState();
            Y3KDebug?.debug?.log("UnifiedWebGLController", `WebGL re-enabled by performance system: ${reason}`);
          }
        }
        // =============================================================================
        // PRIVATE IMPLEMENTATION
        // =============================================================================
        async _loadSettings() {
          try {
            const webglEnabled = localStorage.getItem("sn-webgl-enabled");
            const webglQuality = localStorage.getItem("sn-webgl-quality");
            const webglForceEnabled = localStorage.getItem("sn-webgl-force-enabled");
            if (webglEnabled !== null) {
              this.config.enabled = webglEnabled === "true";
              if (webglEnabled === "false") {
                this.userExplicitlyDisabled = true;
              }
            }
            if (webglQuality && ["low", "medium", "high"].includes(webglQuality)) {
              this.config.quality = webglQuality;
              this.userExplicitQuality = webglQuality;
            }
            if (webglForceEnabled !== null) {
              this.config.forceEnabled = webglForceEnabled === "true";
            }
            Y3KDebug?.debug?.log("UnifiedWebGLController", "Settings loaded", this.config);
          } catch (error) {
            Y3KDebug?.debug?.warn("UnifiedWebGLController", "Failed to load settings:", error);
          }
        }
        _saveSettings() {
          try {
            localStorage.setItem("sn-webgl-enabled", this.config.enabled.toString());
            localStorage.setItem("sn-webgl-quality", this.config.quality);
            localStorage.setItem("sn-webgl-force-enabled", this.config.forceEnabled.toString());
          } catch (error) {
            Y3KDebug?.debug?.warn("UnifiedWebGLController", "Failed to save settings:", error);
          }
        }
        async _determineInitialState() {
          if (!this.config.enabled || this.userExplicitlyDisabled) {
            this._setState("css-fallback");
            return;
          }
          if (this.config.forceEnabled || this.isAvailable()) {
            this._setState("webgl-active");
          } else {
            this._setState("css-fallback");
          }
        }
        _determineAndApplyState() {
          if (!this.config.enabled || this.userExplicitlyDisabled) {
            this._setState("css-fallback");
          } else if (this.config.forceEnabled || this.isAvailable()) {
            this._setState("webgl-active");
          } else {
            this._setState("css-fallback");
          }
        }
        _setState(newState) {
          if (this.currentState === newState) return;
          const oldState = this.currentState;
          this.currentState = newState;
          this.lastStateChange = Date.now();
          this.stateChangeHistory.push({
            state: newState,
            quality: this.config.quality,
            timestamp: this.lastStateChange
          });
          if (this.stateChangeHistory.length > 20) {
            this.stateChangeHistory = this.stateChangeHistory.slice(-20);
          }
          this._applyStateToAllSystems();
          unifiedEventBus.emit("performance:tier-changed", {
            tier: newState,
            previousTier: oldState,
            timestamp: this.lastStateChange
          });
          Y3KDebug?.debug?.log("UnifiedWebGLController", `State changed: ${oldState} \u2192 ${newState}`);
        }
        _applyStateToAllSystems() {
          const sortedSystems = Array.from(this.webglSystems.entries()).sort(([, a], [, b]) => b.priority - a.priority);
          for (const [name, ref] of sortedSystems) {
            this._applyStateToSystem(name, ref.system);
          }
        }
        _applyStateToSystem(name, system) {
          try {
            const isWebGLActive = this.currentState === "webgl-active";
            if (system.setEnabled) {
              system.setEnabled(isWebGLActive);
            }
            if (isWebGLActive && system.setQuality) {
              system.setQuality(this.config.quality);
            }
            if (name === "corridor-effects" && system.setEnabled) {
              const shouldEnableCorridors = isWebGLActive && (this.config.quality === "medium" || this.config.quality === "high");
              system.setEnabled(shouldEnableCorridors);
            }
          } catch (error) {
            Y3KDebug?.debug?.warn("UnifiedWebGLController", `Failed to apply state to ${name}:`, error);
          }
        }
        _applyQualityToAllSystems() {
          if (this.currentState !== "webgl-active") return;
          for (const [name, ref] of this.webglSystems) {
            try {
              if (ref.system.setQuality) {
                ref.system.setQuality(this.config.quality);
              }
              if (name === "corridor-effects") {
                const shouldEnable = this.config.quality === "medium" || this.config.quality === "high";
                if (ref.system.setEnabled) {
                  ref.system.setEnabled(shouldEnable);
                }
              }
            } catch (error) {
              Y3KDebug?.debug?.warn("UnifiedWebGLController", `Failed to apply quality to ${name}:`, error);
            }
          }
          unifiedEventBus.emit("performance:tier-changed", {
            tier: this.config.quality,
            previousTier: this.config.quality,
            timestamp: Date.now()
          });
        }
        _setupEventListeners() {
          unifiedEventBus.subscribe("settings:changed", (data) => {
            if (data.settingKey === "sn-webgl-enabled") {
              this.config.enabled = data.newValue === "true";
              this.userExplicitlyDisabled = data.newValue === "false";
              this._determineAndApplyState();
            } else if (data.settingKey === "sn-webgl-quality") {
              this.setQuality(data.newValue);
            } else if (data.settingKey === "sn-webgl-force-enabled") {
              this.config.forceEnabled = data.newValue === "true";
              this._determineAndApplyState();
            }
          });
          unifiedEventBus.subscribe("performance:tier-changed", (data) => {
            const qualityFromTier = data.tier === "excellent" ? "high" : data.tier === "good" ? "medium" : "low";
            if (qualityFromTier !== this.config.quality) {
              this.setQuality(qualityFromTier);
            }
          });
        }
      };
      __name(_UnifiedWebGLController, "UnifiedWebGLController");
      UnifiedWebGLController = _UnifiedWebGLController;
    }
  });

  // src-js/core/webgl/WebGLSystemInterface.ts
  var _WebGLQualityMapper, WebGLQualityMapper;
  var init_WebGLSystemInterface = __esm({
    "src-js/core/webgl/WebGLSystemInterface.ts"() {
      "use strict";
      _WebGLQualityMapper = class _WebGLQualityMapper {
        /**
         * Map quality level to animation density (0.0 - 1.0)
         */
        static getAnimationDensity(quality) {
          switch (quality) {
            case "low":
              return 0.3;
            case "medium":
              return 0.7;
            case "high":
              return 1;
          }
        }
        /**
         * Map quality level to update frequency (Hz)
         */
        static getUpdateFrequency(quality) {
          switch (quality) {
            case "low":
              return 30;
            case "medium":
              return 45;
            case "high":
              return 60;
          }
        }
        /**
         * Map quality level to shader complexity (0.0 - 1.0)
         */
        static getShaderComplexity(quality) {
          switch (quality) {
            case "low":
              return 0.4;
            case "medium":
              return 0.7;
            case "high":
              return 1;
          }
        }
        /**
         * Map quality level to particle count multiplier
         */
        static getParticleMultiplier(quality) {
          switch (quality) {
            case "low":
              return 0.3;
            case "medium":
              return 0.6;
            case "high":
              return 1;
          }
        }
        /**
         * Check if corridor effects should be enabled at this quality level
         */
        static shouldEnableCorridorEffects(quality) {
          return quality === "medium" || quality === "high";
        }
        /**
         * Check if advanced features should be enabled at this quality level
         */
        static shouldEnableAdvancedFeatures(quality) {
          return quality === "high";
        }
        /**
         * Get CSS mix-blend-mode based on quality level
         */
        static getBlendMode(quality) {
          switch (quality) {
            case "low":
              return "normal";
            case "medium":
              return "screen";
            case "high":
              return "screen";
          }
        }
        /**
         * Get frame throttling based on quality level (ms between frames)
         */
        static getFrameThrottling(quality) {
          switch (quality) {
            case "low":
              return 33;
            case "medium":
              return 22;
            case "high":
              return 16;
          }
        }
      };
      __name(_WebGLQualityMapper, "WebGLQualityMapper");
      WebGLQualityMapper = _WebGLQualityMapper;
    }
  });

  // src-js/visual/backgrounds/WebGLGradientAdapter.ts
  var _WebGLGradientAdapter, WebGLGradientAdapter;
  var init_WebGLGradientAdapter = __esm({
    "src-js/visual/backgrounds/WebGLGradientAdapter.ts"() {
      "use strict";
      init_WebGLSystemInterface();
      init_UnifiedDebugManager();
      _WebGLGradientAdapter = class _WebGLGradientAdapter {
        constructor(system) {
          this.enabled = false;
          this.quality = "medium";
          this.system = system;
          Y3KDebug?.debug?.log("WebGLGradientAdapter", "Created adapter for WebGL gradient system");
        }
        setEnabled(enabled) {
          if (this.enabled === enabled) return;
          this.enabled = enabled;
          if (enabled) {
            this._enableSystem();
          } else {
            this._disableSystem();
          }
          Y3KDebug?.debug?.log("WebGLGradientAdapter", `WebGL gradient ${enabled ? "enabled" : "disabled"}`);
        }
        setQuality(quality) {
          if (this.quality === quality) return;
          this.quality = quality;
          if (this.enabled) {
            this._applyQualitySettings();
          }
          Y3KDebug?.debug?.log("WebGLGradientAdapter", `Quality set to ${quality}`);
        }
        isEnabled() {
          return this.enabled;
        }
        isCapable() {
          return this._checkWebGLCapability();
        }
        getQuality() {
          return this.quality;
        }
        getSystemName() {
          return "WebGL Gradient Background";
        }
        _enableSystem() {
          try {
            const intensityMapping = this._mapQualityToIntensity(this.quality);
            if (this.system["settingsManager"]) {
              this.system["settingsManager"].set("sn-gradient-intensity", intensityMapping);
              this.system["settingsManager"].set("sn-webgl-enabled", "true");
            }
            if (!this.system.initialized) {
              this.system.initialize();
            }
            this._applyQualitySettings();
          } catch (error) {
            Y3KDebug?.debug?.warn("WebGLGradientAdapter", "Failed to enable system:", error);
          }
        }
        _disableSystem() {
          try {
            if (this.system["settingsManager"]) {
              this.system["settingsManager"].set("sn-gradient-intensity", "disabled");
            }
            if (typeof this.system["disable"] === "function") {
              this.system["disable"]();
            } else if (typeof this.system.destroy === "function") {
              this.system.destroy();
            }
          } catch (error) {
            Y3KDebug?.debug?.warn("WebGLGradientAdapter", "Failed to disable system:", error);
          }
        }
        _applyQualitySettings() {
          try {
            const settings2 = this.system["settings"];
            if (!settings2) return;
            settings2.flowStrength = this._getFlowStrength(this.quality);
            settings2.noiseScale = this._getNoiseScale(this.quality);
            settings2.corridorIntensity = this._getColorIntensity(this.quality);
            const updateFrequency = WebGLQualityMapper.getUpdateFrequency(this.quality);
            if (this.system["updateFrequency"] !== void 0) {
              this.system["updateFrequency"] = updateFrequency;
            }
            if (typeof this.system.forceRepaint === "function") {
              this.system.forceRepaint(`quality-change-${this.quality}`);
            }
          } catch (error) {
            Y3KDebug?.debug?.warn("WebGLGradientAdapter", "Failed to apply quality settings:", error);
          }
        }
        _mapQualityToIntensity(quality) {
          switch (quality) {
            case "low":
              return "minimal";
            case "medium":
              return "balanced";
            case "high":
              return "intense";
            default:
              return "balanced";
          }
        }
        _getFlowStrength(quality) {
          switch (quality) {
            case "low":
              return 0.3;
            case "medium":
              return 0.7;
            case "high":
              return 1;
            default:
              return 0.7;
          }
        }
        _getAnimationSpeed(quality) {
          switch (quality) {
            case "low":
              return 0.5;
            case "medium":
              return 0.8;
            case "high":
              return 1.2;
            default:
              return 0.8;
          }
        }
        _getNoiseScale(quality) {
          switch (quality) {
            case "low":
              return 1.5;
            case "medium":
              return 2;
            case "high":
              return 2.8;
            default:
              return 2;
          }
        }
        _getColorIntensity(quality) {
          switch (quality) {
            case "low":
              return 0.6;
            case "medium":
              return 0.8;
            case "high":
              return 1;
            default:
              return 0.8;
          }
        }
        _checkWebGLCapability() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
            canvas.remove();
            return gl !== null;
          } catch {
            return false;
          }
        }
      };
      __name(_WebGLGradientAdapter, "WebGLGradientAdapter");
      WebGLGradientAdapter = _WebGLGradientAdapter;
    }
  });

  // src-js/core/webgl/WebGLSystemsIntegration.ts
  var _WebGLSystemsIntegration, WebGLSystemsIntegration;
  var init_WebGLSystemsIntegration = __esm({
    "src-js/core/webgl/WebGLSystemsIntegration.ts"() {
      "use strict";
      init_UnifiedWebGLController();
      init_WebGLGradientAdapter();
      init_UnifiedDebugManager();
      _WebGLSystemsIntegration = class _WebGLSystemsIntegration {
        constructor(deviceCapabilities) {
          this.initialized = false;
          this.webglGradientSystem = null;
          this.webglGradientAdapter = null;
          this.controller = new UnifiedWebGLController(deviceCapabilities);
          Y3KDebug?.debug?.log("WebGLSystemsIntegration", "Created WebGL systems integration");
        }
        async initialize() {
          if (this.initialized) return;
          await this.controller.initialize();
          await this._registerWebGLSystems();
          this.initialized = true;
          Y3KDebug?.debug?.log("WebGLSystemsIntegration", "Integration initialized", {
            controllerState: this.controller.getState(),
            quality: this.controller.getQuality(),
            registeredSystems: this._getRegisteredSystemNames()
          });
        }
        async healthCheck() {
          if (!this.initialized) {
            return {
              healthy: false,
              details: "Not initialized",
              system: "WebGLSystemsIntegration"
            };
          }
          const controllerHealth = await this.controller.healthCheck();
          if (!controllerHealth.healthy) {
            return {
              healthy: false,
              details: `Controller unhealthy: ${controllerHealth.details}`,
              system: "WebGLSystemsIntegration"
            };
          }
          const systemIssues = [];
          if (this.webglGradientSystem) {
            try {
              const gradientHealth = await this.webglGradientSystem.healthCheck();
              if (!gradientHealth.ok) {
                systemIssues.push(`WebGL Gradient: ${gradientHealth.details}`);
              }
            } catch (error) {
              systemIssues.push("WebGL Gradient: health check failed");
            }
          }
          return {
            healthy: true,
            details: systemIssues.length > 0 ? `Some system issues: ${systemIssues.join(", ")}` : "All WebGL systems healthy",
            issues: systemIssues,
            system: "WebGLSystemsIntegration"
          };
        }
        destroy() {
          if (this.webglGradientSystem) {
            this.webglGradientSystem.destroy();
          }
          this.controller.destroy();
          this.initialized = false;
          Y3KDebug?.debug?.log("WebGLSystemsIntegration", "Integration destroyed");
        }
        updateAnimation(deltaTime) {
          if (this.initialized) {
            this.controller.updateAnimation(deltaTime);
          }
        }
        // =============================================================================
        // PUBLIC API - Simplified WebGL Management
        // =============================================================================
        /**
         * Get the unified WebGL controller for direct access
         */
        getController() {
          return this.controller;
        }
        /**
         * Enable all WebGL effects
         */
        enableWebGL() {
          this.controller.enable();
        }
        /**
         * Disable all WebGL effects
         */
        disableWebGL() {
          this.controller.disable();
        }
        /**
         * Set quality for all WebGL effects
         */
        setQuality(quality) {
          this.controller.setQuality(quality);
        }
        /**
         * Check if WebGL is currently active
         */
        isWebGLActive() {
          return this.controller.isEnabled();
        }
        /**
         * Get current WebGL state
         */
        getWebGLState() {
          return this.controller.getState();
        }
        /**
         * Get current quality level
         */
        getQuality() {
          return this.controller.getQuality();
        }
        // =============================================================================
        // PERFORMANCE SYSTEM INTEGRATION
        // =============================================================================
        /**
         * Called by tier-based performance system to set quality level
         */
        handlePerformanceQualityAdjustment(suggestedQuality, reason) {
          this.controller.suggestQualityAdjustment(suggestedQuality, reason);
        }
        /**
         * Called by performance system to temporarily disable WebGL
         */
        handlePerformanceDisable(reason) {
          this.controller.performanceDisable(reason);
        }
        /**
         * Called by performance system to re-enable WebGL
         */
        handlePerformanceEnable(reason) {
          this.controller.performanceEnable(reason);
        }
        /**
         * Set quality based on device tier (simplified approach)
         */
        setQualityFromTier(tier) {
          this.controller.setQuality(tier);
          Y3KDebug?.debug?.log("WebGLSystemsIntegration", `Quality set from device tier: ${tier}`);
        }
        // =============================================================================
        // PRIVATE IMPLEMENTATION
        // =============================================================================
        async _registerWebGLSystems() {
          try {
            await this._registerWebGLGradientSystem();
            Y3KDebug?.debug?.log("WebGLSystemsIntegration", "All WebGL systems registered successfully");
          } catch (error) {
            Y3KDebug?.debug?.warn("WebGLSystemsIntegration", "Failed to register some WebGL systems:", error);
          }
        }
        async _registerWebGLGradientSystem() {
          try {
            const year3000System = globalThis.year3000System;
            if (!year3000System) {
              Y3KDebug?.debug?.warn("WebGLSystemsIntegration", "Year3000System not available");
              return;
            }
            const possibleSystems = [
              "webglGradientBackgroundSystem",
              "flowingLiquidConsciousnessSystem",
              "webglBackgroundSystem"
            ];
            let foundSystem = null;
            for (const systemName of possibleSystems) {
              if (year3000System[systemName]) {
                foundSystem = year3000System[systemName];
                break;
              }
            }
            if (!foundSystem) {
              Y3KDebug?.debug?.warn("WebGLSystemsIntegration", "WebGL gradient system not found in Year3000System");
              return;
            }
            this.webglGradientSystem = foundSystem;
            this.webglGradientAdapter = new WebGLGradientAdapter(this.webglGradientSystem);
            this.controller.registerSystem(
              "webgl-gradient-background",
              this.webglGradientAdapter,
              100
              // High priority
            );
            Y3KDebug?.debug?.log("WebGLSystemsIntegration", "WebGL gradient system registered");
          } catch (error) {
            Y3KDebug?.debug?.warn("WebGLSystemsIntegration", "Failed to register WebGL gradient system:", error);
          }
        }
        _getRegisteredSystemNames() {
          const systemNames = [];
          if (this.webglGradientAdapter) {
            systemNames.push("WebGL Gradient Background");
          }
          return systemNames;
        }
      };
      __name(_WebGLSystemsIntegration, "WebGLSystemsIntegration");
      WebGLSystemsIntegration = _WebGLSystemsIntegration;
    }
  });

  // src-js/core/performance/PerformanceBudgetManager.ts
  var _PerformanceBudgetManager, PerformanceBudgetManager;
  var init_PerformanceBudgetManager = __esm({
    "src-js/core/performance/PerformanceBudgetManager.ts"() {
      "use strict";
      _PerformanceBudgetManager = class _PerformanceBudgetManager {
        constructor(config = {}, performanceAnalyzer2) {
          this.cssVariableManager = null;
          // Optimization state
          this.optimizationLevel = "none";
          this.disabledFeatures = /* @__PURE__ */ new Set();
          this.config = {
            budgets: {
              animationFrame: 16.67,
              // 60 FPS
              cssVariableUpdate: 2,
              domObservation: 5,
              audioAnalysis: 10,
              visualEffects: 8,
              userInteraction: 100
            },
            autoOptimize: {
              enabled: true,
              violationThreshold: 5,
              recoveryThreshold: 80
            },
            enableDebug: false,
            ...config
          };
          this.performanceAnalyzer = performanceAnalyzer2;
          this.setupBudgetMonitoring();
        }
        static getInstance(config, performanceAnalyzer2) {
          if (!_PerformanceBudgetManager.instance && performanceAnalyzer2) {
            _PerformanceBudgetManager.instance = new _PerformanceBudgetManager(
              config,
              performanceAnalyzer2
            );
          }
          return _PerformanceBudgetManager.instance;
        }
        /**
         * Register CSS Variable Batcher for optimization
         */
        registerUnifiedCSSVariableManager(batcher) {
          this.cssVariableManager = batcher;
        }
        /**
         * Set up automatic budget monitoring and optimization
         */
        setupBudgetMonitoring() {
          if (!this.config.autoOptimize.enabled) return;
          setInterval(() => {
            this.checkBudgets();
          }, 5e3);
        }
        /**
         * Check budget violations and trigger optimizations
         * Note: Tier-based system doesn't generate budget violations, 
         * so this primarily monitors health score
         */
        checkBudgets() {
          const healthScore = this.performanceAnalyzer.calculateHealthScore();
          if (healthScore >= this.config.autoOptimize.recoveryThreshold) {
            this.recoverOptimizations();
          }
        }
        /**
         * Optimize a specific operation that's violating budget
         */
        optimizeOperation(operation) {
          if (this.disabledFeatures.has(operation)) return;
          switch (operation) {
            case "cssVariableUpdate":
              this.optimizeCSSVariableUpdates();
              break;
            case "domObservation":
              this.optimizeDOMObservation();
              break;
            case "visualEffects":
              this.optimizeVisualEffects();
              break;
            case "audioAnalysis":
              this.optimizeAudioAnalysis();
              break;
          }
          this.disabledFeatures.add(operation);
          if (this.config.enableDebug) {
            console.log(`\u{1F3AF} [PerformanceBudgetManager] Optimized ${operation} due to budget violations`);
          }
        }
        /**
         * Optimize CSS variable updates
         */
        optimizeCSSVariableUpdates() {
          if (!this.cssVariableManager) return;
          this.cssVariableManager.updateConfig({
            batchIntervalMs: 32,
            // Reduce to 30 FPS
            maxBatchSize: 25
            // Smaller batches
          });
        }
        /**
         * Optimize DOM observation
         */
        optimizeDOMObservation() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-dom-observation", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Optimize visual effects
         */
        optimizeVisualEffects() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-visual-effects", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Optimize audio analysis
         */
        optimizeAudioAnalysis() {
          document.dispatchEvent(new CustomEvent("year3000:optimize-audio-analysis", {
            detail: { level: this.optimizationLevel }
          }));
        }
        /**
         * Escalate optimization level
         */
        escalateOptimization() {
          if (this.optimizationLevel === "none") {
            this.optimizationLevel = "conservative";
          } else if (this.optimizationLevel === "conservative") {
            this.optimizationLevel = "aggressive";
          }
          if (this.config.enableDebug) {
            console.log(`\u{1F3AF} [PerformanceBudgetManager] Escalated to ${this.optimizationLevel} optimization`);
          }
        }
        /**
         * Recover from optimizations when performance improves
         */
        recoverOptimizations() {
          if (this.optimizationLevel === "none") return;
          this.disabledFeatures.clear();
          if (this.cssVariableManager) {
            this.cssVariableManager.updateConfig({
              batchIntervalMs: 16,
              maxBatchSize: 50
            });
          }
          document.dispatchEvent(new CustomEvent("year3000:recover-optimizations", {
            detail: { previousLevel: this.optimizationLevel }
          }));
          this.optimizationLevel = "none";
          if (this.config.enableDebug) {
            console.log("\u{1F3AF} [PerformanceBudgetManager] Recovered from optimizations");
          }
        }
        /**
         * Get current optimization status
         */
        getOptimizationStatus() {
          return {
            level: this.optimizationLevel,
            disabledFeatures: Array.from(this.disabledFeatures),
            budgetViolations: [],
            // Tier-based system doesn't generate budget violations
            healthScore: this.performanceAnalyzer.calculateHealthScore()
          };
        }
        /**
         * Manually trigger optimization for testing
         */
        manualOptimize(operation) {
          this.optimizeOperation(operation);
        }
        /**
         * Manually recover from optimizations
         */
        manualRecover() {
          this.recoverOptimizations();
        }
        /**
         * Update performance budgets
         */
        updateBudgets(budgets) {
          this.config.budgets = { ...this.config.budgets, ...budgets };
          for (const [operation, budget] of Object.entries(budgets)) {
            this.performanceAnalyzer.updateBudget(operation, budget);
          }
        }
        /**
         * Destroy and cleanup
         */
        destroy() {
          this.disabledFeatures.clear();
          this.cssVariableManager = null;
          _PerformanceBudgetManager.instance = null;
        }
      };
      __name(_PerformanceBudgetManager, "PerformanceBudgetManager");
      _PerformanceBudgetManager.instance = null;
      PerformanceBudgetManager = _PerformanceBudgetManager;
    }
  });

  // src-js/ui/managers/SettingsManager.ts
  var _SettingsManager, SettingsManager;
  var init_SettingsManager = __esm({
    "src-js/ui/managers/SettingsManager.ts"() {
      "use strict";
      init_globalConfig();
      init_ThemeUtilities();
      init_config();
      _SettingsManager = class _SettingsManager {
        constructor(config = ADVANCED_SYSTEM_CONFIG, harmonicModes = HARMONIC_MODES2, utils = ThemeUtilities_exports) {
          this.initialized = false;
          this.initialized = true;
          if (config?.enableDebug) {
            console.log("[SettingsManager] Initialized with new type-safe backend");
          }
        }
        forceRepaint(reason) {
          if (typeof document !== "undefined") {
            document.documentElement.style.display = "none";
            document.documentElement.offsetHeight;
            document.documentElement.style.display = "";
          }
        }
        async initialize() {
          this.initialized = true;
        }
        async healthCheck() {
          return {
            healthy: this.initialized,
            system: "SettingsManager",
            details: this.initialized ? "Settings manager operational" : "Settings manager not initialized"
          };
        }
        updateAnimation() {
        }
        destroy() {
          this.initialized = false;
        }
        // Settings operations using the new typed settings system
        get(key) {
          try {
            switch (key) {
              case "artisticMode":
                return settings.get("sn-artistic-mode");
              case "paletteSystem":
                return settings.get("sn-palette-system");
              case "gradientIntensity":
                return settings.get("sn-gradient-intensity");
              case "webglEnabled":
                return settings.get("sn-webgl-enabled");
              case "animationQuality":
                return settings.get("sn-animation-quality");
              default:
                if (typeof key === "string" && key.startsWith("sn-")) {
                  return settings.get(key);
                }
                return void 0;
            }
          } catch (error) {
            console.warn(`[SettingsManager] Failed to get setting ${String(key)}:`, error);
            return void 0;
          }
        }
        getAllowedValues(key) {
          switch (key) {
            case "artisticMode":
              return Object.keys(ARTISTIC_MODE_PROFILES2);
            case "paletteSystem":
              return ["catppuccin", "year3000"];
            case "gradientIntensity":
              return ["disabled", "minimal", "balanced", "intense"];
            case "webglEnabled":
              return [true, false];
            case "animationQuality":
              return ["auto", "low", "high"];
            default:
              return void 0;
          }
        }
        set(key, value) {
          try {
            switch (key) {
              case "artisticMode":
                return settings.set("sn-artistic-mode", value);
              case "paletteSystem":
                return settings.set("sn-palette-system", value);
              case "gradientIntensity":
                return settings.set("sn-gradient-intensity", value);
              case "webglEnabled":
                return settings.set("sn-webgl-enabled", Boolean(value));
              case "animationQuality":
                return settings.set("sn-animation-quality", value);
              default:
                if (typeof key === "string" && key.startsWith("sn-")) {
                  return settings.set(key, value);
                }
                console.warn(`[SettingsManager] Unknown setting key: ${String(key)}`);
                return false;
            }
          } catch (error) {
            console.warn(`[SettingsManager] Failed to set setting ${String(key)}:`, error);
            return false;
          }
        }
        getAllSettings() {
          return {
            artisticMode: this.get("artisticMode") || "artist-vision",
            paletteSystem: this.get("paletteSystem") || "catppuccin",
            gradientIntensity: this.get("gradientIntensity") || "balanced",
            webglEnabled: this.get("webglEnabled") ?? true,
            animationQuality: this.get("animationQuality") || "auto"
          };
        }
        validateAndRepair() {
          console.log("[SettingsManager] Settings validation handled by typed system");
        }
        resetAllToDefaults() {
          try {
            settings.set("sn-artistic-mode", "artist-vision");
            settings.set("sn-palette-system", "catppuccin");
            settings.set("sn-gradient-intensity", "balanced");
            settings.set("sn-webgl-enabled", true);
            settings.set("sn-animation-quality", "auto");
            console.log("[SettingsManager] Reset all settings to defaults");
          } catch (error) {
            console.warn("[SettingsManager] Failed to reset settings:", error);
          }
        }
        // Harmonic mode helpers
        getCurrentHarmonicMode() {
          const currentMode = settings.get("sn-artistic-mode") || "artist-vision";
          const harmonicMapping = {
            "artist-vision": "analogous-flow",
            "cosmic-maximum": "triadic-balance",
            "corporate-safe": "monochromatic-smooth"
          };
          const harmonicKey = harmonicMapping[String(currentMode)] || "analogous-flow";
          const harmonicMode = HARMONIC_MODES2[harmonicKey];
          return harmonicMode || HARMONIC_MODES2["analogous-flow"];
        }
        getHarmonicMode(key) {
          return HARMONIC_MODES2[key];
        }
      };
      __name(_SettingsManager, "SettingsManager");
      SettingsManager = _SettingsManager;
    }
  });

  // src-js/core/services/LoadingStateService.ts
  var _LoadingStateService, LoadingStateService;
  var init_LoadingStateService = __esm({
    "src-js/core/services/LoadingStateService.ts"() {
      "use strict";
      _LoadingStateService = class _LoadingStateService {
        constructor(config) {
          this.initialized = false;
          this.observer = null;
          this.loadingElements = /* @__PURE__ */ new WeakSet();
          this.activeContexts = /* @__PURE__ */ new Map();
          this.config = {
            enableLoadingAnimations: true,
            enableGrainTexture: true,
            enableMusicSync: false,
            intensity: "normal",
            performanceMode: false
          };
          // Performance tracking
          this.detectionCount = 0;
          this.applicationCount = 0;
          this.lastPerformanceCheck = Date.now();
          // Context detection selectors
          this.CONTEXT_SELECTORS = {
            playlist: [
              '.main-entityHeader-container[data-testid="playlist-header"]',
              ".main-trackList-trackListRow",
              '[data-testid="playlist-tracklist"]'
            ],
            artist: [
              '.main-entityHeader-container[data-testid="artist-header"]',
              '[data-testid="artist-page"]'
            ],
            search: [
              '[data-testid="search-page"]',
              ".main-searchSection-searchSection"
            ],
            home: [
              '[data-testid="home-page"]',
              ".main-home-content"
            ]
          };
          // Spotify loading indicator patterns
          this.LOADING_INDICATORS = [
            '[aria-busy="true"]',
            ".loading-indicator",
            ".skeleton-loader",
            '[data-testid*="loading"]',
            ".main-skeleton-skeletonLoader"
          ];
          if (config) {
            this.config = { ...this.config, ...config };
          }
        }
        /**
         * Initialize the loading state service
         * Sets up DOM mutation observer and applies initial state detection
         */
        async initialize() {
          if (this.initialized) return;
          try {
            if (!document.body) {
              throw new Error("DOM not ready - cannot initialize LoadingStateService");
            }
            this.observer = new MutationObserver((mutations) => {
              this.handleMutations(mutations);
            });
            this.observer.observe(document.body, {
              childList: true,
              subtree: true,
              attributes: true,
              attributeFilter: ["aria-busy", "class", "data-testid"]
            });
            this.performInitialScan();
            this.initialized = true;
            console.log("[LoadingStateService] Initialized successfully");
          } catch (error) {
            console.error("[LoadingStateService] Initialization failed:", error);
            throw error;
          }
        }
        /**
         * Update animation states (called each frame by SystemCoordinator)
         */
        updateAnimation(deltaTime) {
          if (!this.initialized || !this.config.enableLoadingAnimations) return;
          const now = Date.now();
          if (now - this.lastPerformanceCheck > 5e3) {
            this.cleanupStaleStates();
            this.lastPerformanceCheck = now;
          }
        }
        /**
         * Perform health check on the service
         */
        async healthCheck() {
          const isHealthy = this.initialized && this.observer !== null;
          const statusDetails = [
            `Initialized: ${this.initialized}`,
            `Observer active: ${this.observer !== null}`,
            `Active contexts: ${this.activeContexts.size}`,
            `Detection count: ${this.detectionCount}`,
            `Application count: ${this.applicationCount}`,
            `Config: ${JSON.stringify(this.config)}`
          ].join(", ");
          return {
            system: "LoadingStateService",
            healthy: isHealthy,
            ok: isHealthy,
            details: statusDetails,
            metrics: {
              initialized: this.initialized,
              isActive: this.observer !== null,
              totalOperations: this.detectionCount + this.applicationCount,
              activeLoadingStates: this.activeContexts.size
            }
          };
        }
        /**
         * Cleanup and destroy the service
         */
        destroy() {
          if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
          }
          this.activeContexts.forEach((context, element) => {
            this.removeLoadingState(element);
          });
          this.activeContexts.clear();
          this.loadingElements = /* @__PURE__ */ new WeakSet();
          this.initialized = false;
          console.log("[LoadingStateService] Destroyed");
        }
        /**
         * Update service configuration
         */
        updateConfig(config) {
          this.config = { ...this.config, ...config };
          if (!this.config.enableLoadingAnimations) {
            this.activeContexts.forEach((_, element) => {
              this.removeLoadingState(element);
            });
            this.activeContexts.clear();
          }
        }
        /**
         * Handle DOM mutations from MutationObserver
         */
        handleMutations(mutations) {
          const startTime = performance.now();
          const budget = this.config.performanceMode ? 5 : 10;
          for (const mutation of mutations) {
            if (performance.now() - startTime > budget) break;
            if (mutation.type === "attributes") {
              this.handleAttributeChange(mutation);
            } else if (mutation.type === "childList") {
              this.handleChildListChange(mutation);
            }
          }
          this.detectionCount++;
        }
        /**
         * Handle attribute changes (aria-busy, class, data-testid)
         */
        handleAttributeChange(mutation) {
          const element = mutation.target;
          const isLoading = this.isElementLoading(element);
          if (isLoading && !this.loadingElements.has(element)) {
            const context = this.detectContext(element);
            this.applyLoadingState(element, context);
          } else if (!isLoading && this.loadingElements.has(element)) {
            this.removeLoadingState(element);
          }
        }
        /**
         * Handle child list changes (new elements added)
         */
        handleChildListChange(mutation) {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType !== Node.ELEMENT_NODE) return;
            const element = node;
            if (this.isElementLoading(element)) {
              const context = this.detectContext(element);
              this.applyLoadingState(element, context);
            }
            const loadingChildren = element.querySelectorAll(this.LOADING_INDICATORS.join(", "));
            loadingChildren.forEach((child) => {
              if (!this.loadingElements.has(child)) {
                const context = this.detectContext(child);
                this.applyLoadingState(child, context);
              }
            });
          });
        }
        /**
         * Perform initial scan of DOM for existing loading states
         */
        performInitialScan() {
          const loadingElements = document.querySelectorAll(this.LOADING_INDICATORS.join(", "));
          loadingElements.forEach((element) => {
            const context = this.detectContext(element);
            this.applyLoadingState(element, context);
          });
        }
        /**
         * Check if element has loading indicators
         * CRITICAL: Only check for Spotify's native loading indicators, NOT our applied classes
         * to avoid circular logic that prevents cleanup
         */
        isElementLoading(element) {
          if (element.getAttribute("aria-busy") === "true") return true;
          const classList = element.classList;
          if (classList.contains("skeleton-loader") || classList.contains("loading-indicator") || classList.contains("main-skeleton-skeletonLoader")) {
            return true;
          }
          const testId = element.getAttribute("data-testid");
          if (testId && testId.includes("loading")) return true;
          return false;
        }
        /**
         * Detect UI context for context-aware loading styles
         */
        detectContext(element) {
          let current = element;
          while (current && current !== document.body) {
            if (this.CONTEXT_SELECTORS.playlist.some((sel) => current.matches(sel))) {
              return "playlist";
            }
            if (this.CONTEXT_SELECTORS.artist.some((sel) => current.matches(sel))) {
              return "artist";
            }
            if (this.CONTEXT_SELECTORS.search.some((sel) => current.matches(sel))) {
              return "search";
            }
            if (this.CONTEXT_SELECTORS.home.some((sel) => current.matches(sel))) {
              return "home";
            }
            current = current.parentElement;
          }
          return "default";
        }
        /**
         * Apply loading state with context-aware styling
         */
        applyLoadingState(element, context) {
          if (!this.config.enableLoadingAnimations) return;
          element.classList.add("loading-state");
          element.classList.add(`loading-context-${context}`);
          element.classList.add(`loading-intensity-${this.config.intensity}`);
          if (this.config.enableGrainTexture) {
            element.classList.add("loading-grain-texture");
          }
          if (this.config.enableMusicSync) {
            element.classList.add("loading-music-sync");
          }
          this.loadingElements.add(element);
          this.activeContexts.set(element, {
            type: context,
            element,
            appliedAt: Date.now()
          });
          this.applicationCount++;
        }
        /**
         * Remove loading state from element
         */
        removeLoadingState(element) {
          element.classList.remove(
            "loading-state",
            "loading-context-playlist",
            "loading-context-artist",
            "loading-context-search",
            "loading-context-home",
            "loading-context-default",
            "loading-intensity-subtle",
            "loading-intensity-normal",
            "loading-intensity-intense",
            "loading-grain-texture",
            "loading-music-sync"
          );
          this.activeContexts.delete(element);
        }
        /**
         * Cleanup stale loading states (elements removed from DOM or no longer loading)
         */
        cleanupStaleStates() {
          const now = Date.now();
          const staleThreshold = 3e4;
          this.activeContexts.forEach((context, element) => {
            if (!document.body.contains(element)) {
              this.activeContexts.delete(element);
              return;
            }
            if (!this.isElementLoading(element)) {
              this.removeLoadingState(element);
              return;
            }
            if (now - context.appliedAt > staleThreshold) {
              this.removeLoadingState(element);
            }
          });
        }
        /**
         * Get current service statistics
         */
        getStatistics() {
          return {
            initialized: this.initialized,
            activeContexts: this.activeContexts.size,
            detectionCount: this.detectionCount,
            applicationCount: this.applicationCount,
            config: this.config
          };
        }
      };
      __name(_LoadingStateService, "LoadingStateService");
      LoadingStateService = _LoadingStateService;
    }
  });

  // src-js/audio/EmotionalGradientMapper.ts
  var _EmotionalGradientMapper, EmotionalGradientMapper;
  var init_EmotionalGradientMapper = __esm({
    "src-js/audio/EmotionalGradientMapper.ts"() {
      "use strict";
      init_OptimizedCSSVariableManager();
      init_UnifiedDebugManager();
      init_EmotionalTemperatureMapper();
      _EmotionalGradientMapper = class _EmotionalGradientMapper {
        constructor(cssController, musicSyncService = null, settingsManager2 = null) {
          this.musicSyncService = null;
          this.settingsManager = null;
          this.currentEmotionalProfile = null;
          this.emotionalHistory = [];
          this.maxHistorySize = 50;
          // Keep 50 frames of emotional history
          this.isActive = false;
          this.boundSpectralHandler = null;
          this.boundSettingsHandler = null;
          this.currentEmotionalTemperature = null;
          // Mood-to-gradient mapping profiles
          this.moodProfiles = {
            euphoric: {
              hueShift: 15,
              // Warm yellows/oranges
              saturationMultiplier: 1.3,
              // Vibrant colors (reduced from 1.4)
              brightnessMultiplier: 1.2,
              // Bright (reduced from 1.3)
              contrastMultiplier: 1.2,
              // High contrast
              animationSpeed: 1.5,
              // Fast animations
              pulseIntensity: 0.8,
              // Strong pulse
              layerHarmony: 0.9,
              // Harmonious
              discordLevel: 0.1,
              // Low discord
              transitionSpeed: 0.8
              // Quick transitions
            },
            content: {
              hueShift: 5,
              // Subtle warm shift
              saturationMultiplier: 1.1,
              // Slightly saturated
              brightnessMultiplier: 1.1,
              // Slightly bright
              contrastMultiplier: 1,
              // Normal contrast
              animationSpeed: 0.8,
              // Slower animations
              pulseIntensity: 0.4,
              // Gentle pulse
              layerHarmony: 0.95,
              // Very harmonious
              discordLevel: 0.05,
              // Very low discord
              transitionSpeed: 1.5
              // Smooth transitions
            },
            melancholic: {
              hueShift: -30,
              // Cool blues/purples
              saturationMultiplier: 0.8,
              // Desaturated (increased from 0.7)
              brightnessMultiplier: 0.8,
              // Darker
              contrastMultiplier: 0.9,
              // Lower contrast
              animationSpeed: 0.6,
              // Slow animations
              pulseIntensity: 0.3,
              // Weak pulse
              layerHarmony: 0.8,
              // Somewhat harmonious
              discordLevel: 0.2,
              // Some discord
              transitionSpeed: 2
              // Very smooth transitions
            },
            aggressive: {
              hueShift: -15,
              // Reds/magentas
              saturationMultiplier: 1.3,
              // Very saturated (reduced from 1.6)
              brightnessMultiplier: 1.2,
              // Bright
              contrastMultiplier: 1.5,
              // High contrast
              animationSpeed: 2,
              // Very fast
              pulseIntensity: 1,
              // Maximum pulse
              layerHarmony: 0.6,
              // Less harmonious
              discordLevel: 0.4,
              // Notable discord
              transitionSpeed: 0.5
              // Sharp transitions
            },
            mysterious: {
              hueShift: -45,
              // Deep purples/blues
              saturationMultiplier: 0.9,
              // Slightly desaturated
              brightnessMultiplier: 0.8,
              // Dark (increased from 0.7)
              contrastMultiplier: 1.3,
              // High contrast
              animationSpeed: 0.7,
              // Medium-slow
              pulseIntensity: 0.6,
              // Moderate pulse
              layerHarmony: 0.7,
              // Somewhat mysterious
              discordLevel: 0.3,
              // Moderate discord
              transitionSpeed: 1.8
              // Gradual transitions
            },
            peaceful: {
              hueShift: 25,
              // Soft greens/blues
              saturationMultiplier: 0.8,
              // Gentle saturation
              brightnessMultiplier: 1,
              // Natural brightness
              contrastMultiplier: 0.9,
              // Soft contrast
              animationSpeed: 0.5,
              // Very slow
              pulseIntensity: 0.2,
              // Minimal pulse
              layerHarmony: 1,
              // Perfect harmony
              discordLevel: 0,
              // No discord
              transitionSpeed: 3
              // Very smooth
            },
            dramatic: {
              hueShift: 0,
              // Full spectrum
              saturationMultiplier: 1.3,
              // High saturation
              brightnessMultiplier: 1.1,
              // Bright
              contrastMultiplier: 1.4,
              // High contrast
              animationSpeed: 1.2,
              // Dynamic
              pulseIntensity: 0.9,
              // Strong pulse
              layerHarmony: 0.6,
              // Dynamic tension
              discordLevel: 0.4,
              // Intentional discord
              transitionSpeed: 0.7
              // Dramatic transitions
            },
            ambient: {
              hueShift: 10,
              // Subtle shifts
              saturationMultiplier: 0.8,
              // Very desaturated (increased from 0.6)
              brightnessMultiplier: 0.9,
              // Soft
              contrastMultiplier: 0.8,
              // Low contrast
              animationSpeed: 0.3,
              // Very slow
              pulseIntensity: 0.1,
              // Barely perceptible
              layerHarmony: 0.9,
              // Harmonious
              discordLevel: 0.1,
              // Minimal discord
              transitionSpeed: 4
              // Ultra-smooth
            },
            chaotic: {
              hueShift: 0,
              // Full spectrum chaos
              saturationMultiplier: 1.3,
              // High saturation (reduced from 1.5)
              brightnessMultiplier: 1.2,
              // Bright
              contrastMultiplier: 1.6,
              // Very high contrast
              animationSpeed: 2.5,
              // Chaotic speed
              pulseIntensity: 0.9,
              // Strong pulse
              layerHarmony: 0.3,
              // Low harmony
              discordLevel: 0.7,
              // High discord
              transitionSpeed: 0.3
              // Rapid transitions
            },
            nostalgic: {
              hueShift: -10,
              // Slight cool shift
              saturationMultiplier: 0.8,
              // Faded colors
              brightnessMultiplier: 0.95,
              // Slightly dimmed
              contrastMultiplier: 0.9,
              // Soft contrast
              animationSpeed: 0.7,
              // Reflective pace
              pulseIntensity: 0.4,
              // Gentle pulse
              layerHarmony: 0.85,
              // Mostly harmonious
              discordLevel: 0.15,
              // Slight melancholy
              transitionSpeed: 2.2
              // Smooth, flowing
            },
            heroic: {
              hueShift: 20,
              // Warm, golden tones
              saturationMultiplier: 1.2,
              // Rich colors
              brightnessMultiplier: 1.2,
              // Bright and bold (reduced from 1.25)
              contrastMultiplier: 1.3,
              // Strong contrast
              animationSpeed: 1.3,
              // Bold movement
              pulseIntensity: 0.7,
              // Strong pulse
              layerHarmony: 0.8,
              // Confident harmony
              discordLevel: 0.2,
              // Controlled tension
              transitionSpeed: 1
              // Confident transitions
            },
            contemplative: {
              hueShift: -5,
              // Neutral with slight cool
              saturationMultiplier: 0.9,
              // Thoughtful saturation
              brightnessMultiplier: 1,
              // Balanced brightness
              contrastMultiplier: 1.1,
              // Clear contrast
              animationSpeed: 0.6,
              // Thoughtful pace
              pulseIntensity: 0.3,
              // Gentle reflection
              layerHarmony: 0.8,
              // Balanced harmony
              discordLevel: 0.2,
              // Contemplative tension
              transitionSpeed: 2.5
              // Thoughtful transitions
            },
            neutral: {
              hueShift: 0,
              // No shift
              saturationMultiplier: 1,
              // Natural saturation
              brightnessMultiplier: 1,
              // Natural brightness
              contrastMultiplier: 1,
              // Natural contrast
              animationSpeed: 1,
              // Normal speed
              pulseIntensity: 0.5,
              // Moderate pulse
              layerHarmony: 0.75,
              // Balanced
              discordLevel: 0.25,
              // Balanced discord
              transitionSpeed: 1.5
              // Moderate transitions
            }
          };
          this.cssController = cssController || getGlobalOptimizedCSSController();
          this.musicSyncService = musicSyncService;
          this.settingsManager = settingsManager2;
          this.currentGradientState = this.createNeutralGradientState();
          this.emotionalTemperatureMapper = new EmotionalTemperatureMapper(true);
          this.moodToEmotionMap = {
            euphoric: "energetic",
            content: "happy",
            melancholic: "melancholy",
            aggressive: "aggressive",
            mysterious: "mysterious",
            peaceful: "calm",
            dramatic: "epic",
            ambient: "ambient",
            chaotic: "aggressive",
            // Map chaotic to aggressive for high energy
            nostalgic: "melancholy",
            heroic: "epic",
            contemplative: "calm",
            neutral: "ambient"
          };
          this.boundSpectralHandler = this.handleSpectralData.bind(this);
          this.boundSettingsHandler = this.handleSettingsChange.bind(this);
        }
        async initialize() {
          if (this.boundSpectralHandler) {
            document.addEventListener(
              "music-sync:data-updated",
              this.boundSpectralHandler
            );
          }
          if (this.boundSettingsHandler) {
            document.addEventListener(
              "year3000SystemSettingsChanged",
              this.boundSettingsHandler
            );
          }
          this.isActive = true;
          Y3KDebug?.debug?.log(
            "EmotionalGradientMapper",
            "Emotional mapping system initialized"
          );
        }
        createNeutralGradientState() {
          return {
            hueShift: 0,
            saturationMultiplier: 1,
            brightnessMultiplier: 1,
            contrastMultiplier: 1,
            animationSpeed: 1,
            pulseIntensity: 0.5,
            flowDirection: 0,
            layerHarmony: 0.75,
            discordLevel: 0.25,
            depthPerception: 0.5,
            transitionSpeed: 1.5,
            smoothing: 0.7,
            responsiveness: 0.8
          };
        }
        handleSpectralData(event) {
          if (!this.isActive) return;
          const customEvent = event;
          const musicData = customEvent.detail;
          if (!musicData) return;
          const emotionalProfile = this.analyzeEmotionalContent(musicData);
          try {
            const musicAnalysisData = {
              energy: emotionalProfile.energy,
              valence: emotionalProfile.valence,
              danceability: emotionalProfile.arousal,
              // Map arousal to danceability
              tempo: 120,
              // Default, could be enhanced with actual tempo detection
              loudness: emotionalProfile.dynamics,
              acousticness: 1 - emotionalProfile.complexity,
              // Inverse relationship
              instrumentalness: 0.5,
              // Default
              speechiness: 0.1,
              // Default low
              mode: emotionalProfile.mode === "major" ? 1 : 0,
              key: 0,
              // Default
              genre: this.inferGenreFromProfile(emotionalProfile)
            };
            this.currentEmotionalTemperature = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(
              musicAnalysisData
            );
            this.applyEmotionalTemperatureToDocument(
              this.currentEmotionalTemperature
            );
            Y3KDebug?.debug?.log(
              "EmotionalGradientMapper",
              "\u{1F321}\uFE0F Applied emotional temperature:",
              {
                mood: emotionalProfile.mood,
                emotionalState: this.currentEmotionalTemperature.primaryEmotion,
                temperature: this.currentEmotionalTemperature.temperature,
                intensity: this.currentEmotionalTemperature.intensity
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "EmotionalGradientMapper",
              "\u{1F321}\uFE0F Failed to apply emotional temperature:",
              error
            );
          }
          this.storeEmotionalHistory(emotionalProfile);
          const newGradientState = this.mapEmotionToGradient(emotionalProfile);
          this.currentGradientState = this.smoothGradientTransition(
            this.currentGradientState,
            newGradientState,
            emotionalProfile.stability
          );
          this.updateGradientVariables();
          this.currentEmotionalProfile = emotionalProfile;
        }
        analyzeEmotionalContent(musicData) {
          const valence = musicData.valence || 0.5;
          const energy = musicData.energy || 0.5;
          const arousal = musicData.danceability || 0.5;
          const tension = this.calculateTension(musicData);
          const mode = this.detectMode(musicData);
          const dynamics = this.calculateDynamics(musicData);
          const complexity = this.calculateComplexity(musicData);
          const stability = this.calculateStability();
          const predictability = this.calculatePredictability();
          const mood = this.classifyMood(valence, energy, arousal, tension, mode);
          const confidence = this.calculateMoodConfidence(
            valence,
            energy,
            arousal,
            tension
          );
          return {
            valence,
            energy,
            arousal,
            tension,
            mode,
            dynamics,
            complexity,
            stability,
            predictability,
            mood,
            confidence
          };
        }
        calculateTension(musicData) {
          const loudnessInfluence = Math.abs((musicData.loudness || 0) / -60);
          const tempoInfluence = musicData.tempo ? Math.min(1, (musicData.tempo - 60) / 140) : 0.5;
          const acousticnessReduction = 1 - (musicData.acousticness || 0.5);
          const speechinessInfluence = musicData.speechiness || 0;
          return Math.max(
            0,
            Math.min(
              1,
              loudnessInfluence * 0.4 + tempoInfluence * 0.3 + acousticnessReduction * 0.2 + speechinessInfluence * 0.1
            )
          );
        }
        calculateDynamics(musicData) {
          const loudnessComponent = Math.abs((musicData.loudness || 0) / -60);
          const energyComponent = musicData.energy || 0.5;
          return Math.max(0, Math.min(1, (loudnessComponent + energyComponent) / 2));
        }
        calculateComplexity(musicData) {
          const instrumentalComplexity = musicData.instrumentalness || 0.5;
          const speechComplexity = musicData.speechiness || 0;
          const acousticSimplicity = 1 - (musicData.acousticness || 0.5);
          return Math.max(0, Math.min(1, (instrumentalComplexity + speechComplexity + acousticSimplicity) / 3));
        }
        detectMode(musicData) {
          if (typeof musicData.mode === "number") {
            return musicData.mode === 1 ? "major" : "minor";
          }
          const valence = musicData.valence || 0.5;
          const acousticness = musicData.acousticness || 0.5;
          if (valence > 0.6 && acousticness > 0.5) {
            return "major";
          } else if (valence < 0.4 || acousticness < 0.3) {
            return "minor";
          }
          return "neutral";
        }
        calculateStability() {
          if (this.emotionalHistory.length < 2) return 0.5;
          const recentFrames = Math.min(10, this.emotionalHistory.length);
          let variance = 0;
          for (let i = 1; i < recentFrames; i++) {
            const current = this.emotionalHistory[this.emotionalHistory.length - i];
            const previous = this.emotionalHistory[this.emotionalHistory.length - i - 1];
            if (current && previous) {
              variance += Math.abs(current.valence - previous.valence);
              variance += Math.abs(current.energy - previous.energy);
              variance += Math.abs(current.arousal - previous.arousal);
            }
          }
          return Math.max(0, Math.min(1, 1 - variance / (recentFrames * 3)));
        }
        calculatePredictability() {
          if (this.emotionalHistory.length < 5) return 0.5;
          const recent = this.emotionalHistory.slice(-5);
          let patterns = 0;
          for (let i = 1; i < recent.length; i++) {
            const current = recent[i];
            const previous = recent[i - 1];
            if (current && previous) {
              const valenceTrend = current.valence - previous.valence;
              const energyTrend = current.energy - previous.energy;
              if (Math.abs(valenceTrend) < 0.1 && Math.abs(energyTrend) < 0.1) {
                patterns++;
              }
            }
          }
          return patterns / (recent.length - 1);
        }
        classifyMood(valence, energy, arousal, tension, mode) {
          if (valence > 0.7 && energy > 0.7) return "euphoric";
          if (valence > 0.7 && energy < 0.3) return "content";
          if (valence < 0.3 && energy < 0.3) return "melancholic";
          if (valence < 0.3 && energy > 0.7) return "aggressive";
          if (valence < 0.4 && tension > 0.6) return "mysterious";
          if (valence > 0.6 && tension < 0.3) return "peaceful";
          if (tension > 0.7 && arousal > 0.6) return "dramatic";
          if (energy < 0.4 && arousal < 0.4) return "ambient";
          if (tension > 0.6 && energy > 0.6) return "chaotic";
          if (mode === "minor" && valence > 0.3 && valence < 0.7) return "nostalgic";
          if (mode === "major" && energy > 0.6 && valence > 0.5) return "heroic";
          if (arousal < 0.5 && valence > 0.4 && valence < 0.6) return "contemplative";
          return "neutral";
        }
        calculateMoodConfidence(valence, energy, arousal, tension) {
          const clarity = [valence, energy, arousal, tension].map(
            (value) => Math.abs(value - 0.5) * 2
            // Distance from neutral
          );
          return clarity.reduce((sum, c) => sum + c, 0) / clarity.length;
        }
        mapEmotionToGradient(emotionalProfile) {
          const baseMoodProfile = this.moodProfiles[emotionalProfile.mood];
          const baseState = {
            ...this.createNeutralGradientState(),
            ...baseMoodProfile
          };
          return {
            ...baseState,
            hueShift: baseState.hueShift + (emotionalProfile.valence - 0.5) * 20,
            saturationMultiplier: baseState.saturationMultiplier * (0.5 + emotionalProfile.arousal * 0.5),
            brightnessMultiplier: baseState.brightnessMultiplier * (0.7 + emotionalProfile.energy * 0.6),
            contrastMultiplier: baseState.contrastMultiplier * (0.6 + emotionalProfile.tension * 0.8),
            animationSpeed: baseState.animationSpeed * (0.3 + emotionalProfile.energy * 1.4),
            pulseIntensity: baseState.pulseIntensity * emotionalProfile.arousal,
            flowDirection: emotionalProfile.valence * 360,
            layerHarmony: baseState.layerHarmony * (0.3 + emotionalProfile.stability * 0.7),
            discordLevel: baseState.discordLevel * (0.1 + emotionalProfile.tension * 0.9),
            depthPerception: 0.3 + emotionalProfile.complexity * 0.7,
            transitionSpeed: baseState.transitionSpeed / (0.5 + emotionalProfile.predictability * 1.5),
            smoothing: 0.4 + emotionalProfile.stability * 0.6,
            responsiveness: 0.4 + emotionalProfile.confidence * 0.6
          };
        }
        smoothGradientTransition(current, target, stability) {
          const smoothingFactor = 0.1 + stability * 0.4;
          return {
            hueShift: this.lerp(current.hueShift, target.hueShift, smoothingFactor),
            saturationMultiplier: this.lerp(
              current.saturationMultiplier,
              target.saturationMultiplier,
              smoothingFactor
            ),
            brightnessMultiplier: this.lerp(
              current.brightnessMultiplier,
              target.brightnessMultiplier,
              smoothingFactor
            ),
            contrastMultiplier: this.lerp(
              current.contrastMultiplier,
              target.contrastMultiplier,
              smoothingFactor
            ),
            animationSpeed: this.lerp(
              current.animationSpeed,
              target.animationSpeed,
              smoothingFactor
            ),
            pulseIntensity: this.lerp(
              current.pulseIntensity,
              target.pulseIntensity,
              smoothingFactor
            ),
            flowDirection: this.lerp(
              current.flowDirection,
              target.flowDirection,
              smoothingFactor
            ),
            layerHarmony: this.lerp(
              current.layerHarmony,
              target.layerHarmony,
              smoothingFactor
            ),
            discordLevel: this.lerp(
              current.discordLevel,
              target.discordLevel,
              smoothingFactor
            ),
            depthPerception: this.lerp(
              current.depthPerception,
              target.depthPerception,
              smoothingFactor
            ),
            transitionSpeed: this.lerp(
              current.transitionSpeed,
              target.transitionSpeed,
              smoothingFactor * 0.5
            ),
            smoothing: this.lerp(current.smoothing, target.smoothing, 0.1),
            responsiveness: this.lerp(
              current.responsiveness,
              target.responsiveness,
              0.1
            )
          };
        }
        lerp(a, b, t) {
          return a + (b - a) * Math.max(0, Math.min(1, t));
        }
        updateGradientVariables() {
          const state = this.currentGradientState;
          const emotionalVariables = {
            "--sn-emotional-hue-shift": `${state.hueShift}deg`,
            "--sn-emotional-saturation-multiplier": state.saturationMultiplier.toString(),
            "--sn-emotional-brightness-multiplier": state.brightnessMultiplier.toString(),
            "--sn-emotional-contrast-multiplier": state.contrastMultiplier.toString(),
            "--sn-emotional-animation-speed": state.animationSpeed.toString(),
            "--sn-emotional-pulse-intensity": state.pulseIntensity.toString(),
            "--sn-emotional-flow-direction": `${state.flowDirection}deg`,
            "--sn-emotional-layer-harmony": state.layerHarmony.toString(),
            "--sn-emotional-discord-level": state.discordLevel.toString(),
            "--sn-emotional-depth-perception": state.depthPerception.toString(),
            "--sn-emotional-transition-speed": state.transitionSpeed.toString()
          };
          this.cssController.batchSetVariables(
            "EmotionalGradientMapper",
            emotionalVariables,
            "normal",
            // Normal priority for emotional gradient updates
            "emotional-gradient-mapping"
          );
          if (this.currentEmotionalTemperature) {
            const temperatureVariables = {
              ...this.currentEmotionalTemperature.cssVariables,
              "--sn-emotional-temperature": this.currentEmotionalTemperature.temperature.toString(),
              "--sn-emotional-temperature-intensity": this.currentEmotionalTemperature.intensity.toString(),
              "--sn-emotional-temperature-class": this.currentEmotionalTemperature.cssClass,
              "--sn-emotional-temperature-blend": this.currentEmotionalTemperature.intensity.toString()
            };
            this.cssController.batchSetVariables(
              "EmotionalGradientMapper",
              temperatureVariables,
              "high",
              // High priority for emotional temperature (affects perception)
              "emotional-temperature-mapping"
            );
            Y3KDebug?.debug?.log(
              "EmotionalGradientMapper",
              "\u{1F321}\uFE0F Applied temperature CSS variables:",
              {
                temperature: this.currentEmotionalTemperature.temperature,
                intensity: this.currentEmotionalTemperature.intensity,
                cssClass: this.currentEmotionalTemperature.cssClass,
                variableCount: Object.keys(
                  this.currentEmotionalTemperature.cssVariables
                ).length
              }
            );
          }
          this.updateEmotionalGradientCoordination(state);
          if (this.currentEmotionalProfile) {
            const moodVariables = {
              "--sn-current-mood": this.currentEmotionalProfile.mood,
              "--sn-mood-confidence": this.currentEmotionalProfile.confidence.toString(),
              "--sn-emotional-valence": this.currentEmotionalProfile.valence.toString(),
              "--sn-emotional-energy": this.currentEmotionalProfile.energy.toString()
            };
            this.cssController.batchSetVariables(
              "EmotionalGradientMapper",
              moodVariables,
              "normal",
              // Normal priority for mood information
              "mood-state-tracking"
            );
          }
        }
        /**
         * Coordinate emotional modifications with the consolidated --sn-bg-gradient-* system
         */
        updateEmotionalGradientCoordination(state) {
          const rootStyle = getComputedStyle(document.documentElement);
          const currentPrimary = rootStyle.getPropertyValue("--sn-bg-gradient-primary").trim();
          const currentSecondary = rootStyle.getPropertyValue("--sn-bg-gradient-secondary").trim();
          const currentAccent = rootStyle.getPropertyValue("--sn-bg-gradient-accent").trim();
          if (currentPrimary || currentSecondary || currentAccent) {
            const backgroundGradientVariables = {
              "--sn-bg-gradient-flow-x": (state.flowDirection * 0.01).toString(),
              "--sn-bg-gradient-flow-y": (Math.sin(state.flowDirection * Math.PI / 180) * 0.5).toString(),
              "--sn-bg-gradient-opacity": (0.8 * state.layerHarmony).toString(),
              "--sn-bg-gradient-blur": `${120 * (1 + state.depthPerception * 0.5)}px`,
              "--sn-bg-gradient-saturation": state.saturationMultiplier.toString(),
              "--sn-bg-gradient-brightness": state.brightnessMultiplier.toString(),
              "--sn-bg-gradient-contrast": state.contrastMultiplier.toString()
            };
            this.cssController.batchSetVariables(
              "EmotionalGradientMapper",
              backgroundGradientVariables,
              "normal",
              // Normal priority for background gradient coordination
              "bg-gradient-coordination"
            );
            Y3KDebug?.debug?.log(
              "EmotionalGradientMapper",
              `Coordinated emotional modifications with gradient system: flow=${state.flowDirection}\xB0, opacity=${0.8 * state.layerHarmony}`
            );
          }
        }
        storeEmotionalHistory(profile) {
          this.emotionalHistory.push(profile);
          if (this.emotionalHistory.length > this.maxHistorySize) {
            this.emotionalHistory.shift();
          }
        }
        handleSettingsChange(event) {
          const customEvent = event;
          const { key, value } = customEvent.detail;
          if (key.startsWith("sn-emotional-") || key.startsWith("sn-gradient-")) {
            Y3KDebug?.debug?.log(
              "EmotionalGradientMapper",
              "Settings changed, updating emotional sensitivity"
            );
          }
        }
        getCurrentEmotionalProfile() {
          return this.currentEmotionalProfile;
        }
        getCurrentGradientState() {
          return { ...this.currentGradientState };
        }
        getEmotionalHistory() {
          return [...this.emotionalHistory];
        }
        setMoodOverride(mood, duration = 5e3) {
          const overrideProfile = this.moodProfiles[mood];
          if (overrideProfile) {
            this.currentGradientState = {
              ...this.currentGradientState,
              ...overrideProfile
            };
            this.updateGradientVariables();
            setTimeout(() => {
              Y3KDebug?.debug?.log(
                "EmotionalGradientMapper",
                "Mood override expired, returning to automatic detection"
              );
            }, duration);
          }
        }
        /**
         * 🌡️ Apply emotional temperature CSS classes and variables to the document
         */
        applyEmotionalTemperatureToDocument(emotionalTemperature) {
          const existingClasses = Array.from(document.body.classList).filter(
            (cls) => cls.startsWith("smooth-emotion-")
          );
          document.body.classList.remove(...existingClasses);
          document.body.classList.add(emotionalTemperature.cssClass);
          if (emotionalTemperature.secondaryEmotion) {
            document.body.classList.add(
              `smooth-emotion-blend-${emotionalTemperature.secondaryEmotion}`
            );
          }
          this.cssController.batchSetVariables(
            "EmotionalGradientMapper",
            emotionalTemperature.cssVariables,
            "high",
            // High priority for emotional temperature document updates
            "emotional-temperature-document"
          );
          Y3KDebug?.debug?.log(
            "EmotionalGradientMapper",
            "\u{1F321}\uFE0F Applied emotional temperature to document:",
            {
              primaryClass: emotionalTemperature.cssClass,
              secondaryEmotion: emotionalTemperature.secondaryEmotion,
              cssVariableCount: Object.keys(emotionalTemperature.cssVariables).length
            }
          );
        }
        /**
         * 🌡️ Infer genre from emotional profile for temperature mapping
         */
        inferGenreFromProfile(profile) {
          const { mood, energy, valence, tension, arousal, mode } = profile;
          if (mood === "aggressive" || energy > 0.8 && valence < 0.4) {
            return tension > 0.7 ? "metal" : "hard-rock";
          }
          if (mood === "euphoric" || energy > 0.7 && valence > 0.7) {
            return arousal > 0.8 ? "edm" : "pop";
          }
          if (mood === "melancholic" || energy < 0.4 && valence < 0.4) {
            return mode === "minor" ? "blues" : "folk";
          }
          if (mood === "peaceful" || energy < 0.3 && valence > 0.6) {
            return "ambient";
          }
          if (mood === "dramatic" || tension > 0.6 && energy > 0.5) {
            return "classical";
          }
          if (mood === "mysterious" || valence < 0.5 && tension > 0.5) {
            return "jazz";
          }
          if (mood === "heroic" || mode === "major" && energy > 0.6) {
            return "soundtrack";
          }
          return "indie-pop";
        }
        /**
         * Get current emotional temperature result
         */
        getCurrentEmotionalTemperature() {
          return this.currentEmotionalTemperature;
        }
        /**
         * Set emotional temperature override (for testing or manual control)
         */
        setEmotionalTemperatureOverride(emotionalState, intensity = 1, duration = 5e3) {
          try {
            const mockMusicData = {
              energy: intensity,
              valence: intensity > 0.5 ? 0.7 : 0.3,
              // High intensity usually positive
              genre: "override"
            };
            const overrideTemperature = this.emotionalTemperatureMapper.mapMusicToEmotionalTemperature(
              mockMusicData
            );
            overrideTemperature.primaryEmotion = emotionalState;
            overrideTemperature.intensity = intensity;
            overrideTemperature.cssClass = `smooth-emotion-${emotionalState}`;
            this.currentEmotionalTemperature = overrideTemperature;
            this.applyEmotionalTemperatureToDocument(overrideTemperature);
            Y3KDebug?.debug?.log(
              "EmotionalGradientMapper",
              "\u{1F321}\uFE0F Applied emotional temperature override:",
              {
                emotion: emotionalState,
                intensity,
                duration
              }
            );
            setTimeout(() => {
              Y3KDebug?.debug?.log(
                "EmotionalGradientMapper",
                "\u{1F321}\uFE0F Emotional temperature override expired"
              );
            }, duration);
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "EmotionalGradientMapper",
              "\u{1F321}\uFE0F Failed to apply emotional temperature override:",
              error
            );
          }
        }
        destroy() {
          this.isActive = false;
          if (this.boundSpectralHandler) {
            document.removeEventListener(
              "music-sync:data-updated",
              this.boundSpectralHandler
            );
          }
          if (this.boundSettingsHandler) {
            document.removeEventListener(
              "year3000SystemSettingsChanged",
              this.boundSettingsHandler
            );
          }
          if (this.currentEmotionalTemperature) {
            const existingClasses = Array.from(document.body.classList).filter(
              (cls) => cls.startsWith("smooth-emotion-")
            );
            document.body.classList.remove(...existingClasses);
          }
          this.emotionalHistory = [];
          this.currentEmotionalProfile = null;
          this.currentEmotionalTemperature = null;
          Y3KDebug?.debug?.log(
            "EmotionalGradientMapper",
            "Emotional mapping system destroyed"
          );
        }
      };
      __name(_EmotionalGradientMapper, "EmotionalGradientMapper");
      EmotionalGradientMapper = _EmotionalGradientMapper;
    }
  });

  // src-js/audio/GradientDirectionalFlowSystem.ts
  var _GradientDirectionalFlowSystem, GradientDirectionalFlowSystem;
  var init_GradientDirectionalFlowSystem = __esm({
    "src-js/audio/GradientDirectionalFlowSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_UnifiedDebugManager();
      init_BaseVisualSystem();
      _GradientDirectionalFlowSystem = class _GradientDirectionalFlowSystem extends BaseVisualSystem {
        // 30 FPS for smooth flow
        constructor(config = ADVANCED_SYSTEM_CONFIG, utils, performanceMonitor, musicSyncService = null, settingsManager2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this.colorHarmonyEngine = null;
          this.lastBeatTime = 0;
          this.lastFlowUpdate = 0;
          this.flowSmoothingBuffer = [];
          this.currentGenre = null;
          this.boundBeatHandler = null;
          this.boundGenreHandler = null;
          this.boundSpectralHandler = null;
          this.boundEnergyHandler = null;
          this.updateThrottleInterval = 1e3 / 30;
          this.colorHarmonyEngine = null;
          const cssController = OptimizedCSSVariableManager.getGlobalInstance();
          if (cssController) {
            this.cssVariableController = cssController;
          } else {
            Y3KDebug?.debug?.warn(
              "GradientDirectionalFlowSystem",
              "OptimizedCSSVariableManager not available, CSS integration disabled"
            );
            this.cssVariableController = null;
          }
          this.flowSettings = {
            enabled: true,
            flowSensitivity: 0.8,
            beatResponseStrength: 0.9,
            genreAdaptation: true,
            spectralSeparation: true,
            smoothingFactor: 0.7,
            maxFlowIntensity: 1,
            // Corridor-specific settings
            corridorFlowEnabled: true,
            // Enable corridor flow for dual-layer effect
            radialFlowStrength: 0.8,
            inwardFlowIntensity: 0.7,
            // Slightly increased for better corridor visibility
            corridorBeatResponse: 1.3
            // Enhanced beat response for corridor effects
          };
          this.currentFlowVector = {
            x: 0,
            y: 0,
            intensity: 0,
            timestamp: performance.now()
          };
          this.currentRadialFlow = {
            angle: 0,
            radius: 0.5,
            intensity: 0,
            inwardFlow: 0,
            timestamp: performance.now()
          };
          this.genreFlowPatterns = {
            electronic: { x: 1, y: 0.2, intensity: 0.9, timestamp: 0 },
            ambient: { x: 0.3, y: 0.8, intensity: 0.4, timestamp: 0 },
            rock: { x: 0.7, y: 0.5, intensity: 0.8, timestamp: 0 },
            pop: { x: 0.6, y: 0.6, intensity: 0.7, timestamp: 0 },
            jazz: { x: 0.4, y: 0.7, intensity: 0.6, timestamp: 0 },
            classical: { x: 0.2, y: 0.9, intensity: 0.5, timestamp: 0 },
            default: { x: 0.5, y: 0.5, intensity: 0.6, timestamp: 0 }
          };
          this.spectralFlowMapping = {
            bassFlow: { x: 0.8, y: 0.2, intensity: 0.7, timestamp: 0 },
            midFlow: { x: 0.5, y: 0.6, intensity: 0.6, timestamp: 0 },
            trebleFlow: { x: 0.3, y: 0.9, intensity: 0.5, timestamp: 0 },
            harmonyFlow: { x: 0.6, y: 0.4, intensity: 0.8, timestamp: 0 }
          };
          this.boundBeatHandler = this.handleBeatEvent.bind(this);
          this.boundGenreHandler = this.handleGenreChange.bind(this);
          this.boundSpectralHandler = this.handleSpectralAnalysis.bind(this);
          this.boundEnergyHandler = this.handleEnergyChange.bind(this);
          this.flowSmoothingBuffer = Array(5).fill(null).map(() => ({ ...this.currentFlowVector }));
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          this.subscribeToMusicEvents();
          this.startFlowUpdates();
          Y3KDebug?.debug?.log(
            "GradientDirectionalFlowSystem",
            "Gradient flow system initialized"
          );
        }
        subscribeToMusicEvents() {
          if (this.boundBeatHandler) {
            document.addEventListener("music-sync:beat", this.boundBeatHandler);
          }
          if (this.boundGenreHandler) {
            document.addEventListener(
              "music-sync:genre-detected",
              this.boundGenreHandler
            );
          }
          if (this.boundSpectralHandler) {
            document.addEventListener(
              "music-sync:spectral-analysis",
              this.boundSpectralHandler
            );
          }
          if (this.boundEnergyHandler) {
            document.addEventListener(
              "music-sync:energy-changed",
              this.boundEnergyHandler
            );
          }
        }
        handleBeatEvent(event) {
          const currentTime = performance.now();
          if (currentTime - this.lastBeatTime < 50) return;
          this.lastBeatTime = currentTime;
          const customEvent = event;
          const { intensity, bpm, confidence } = customEvent.detail;
          const beatFlowVector = this.calculateBeatFlow(intensity, bpm, confidence);
          const genreModifiedFlow = this.applyGenreModifications(beatFlowVector);
          this.updateFlowVector(genreModifiedFlow);
          Y3KDebug?.debug?.log(
            "GradientDirectionalFlowSystem",
            `Beat flow: ${beatFlowVector.x.toFixed(2)}, ${beatFlowVector.y.toFixed(
              2
            )}, intensity: ${beatFlowVector.intensity.toFixed(2)}`
          );
        }
        handleGenreChange(event) {
          const customEvent = event;
          const { genre, confidence } = customEvent.detail;
          this.currentGenre = genre;
          if (this.flowSettings.genreAdaptation && confidence > 0.7) {
            this.adaptFlowToGenre(genre);
          }
          Y3KDebug?.debug?.log(
            "GradientDirectionalFlowSystem",
            `Genre flow adaptation: ${genre} (confidence: ${confidence.toFixed(2)})`
          );
        }
        handleSpectralAnalysis(event) {
          const customEvent = event;
          const spectralData = customEvent.detail;
          if (!this.flowSettings.spectralSeparation) return;
          const spectralFlow = this.mapSpectralToFlow(spectralData);
          const blendedFlow = this.blendSpectralFlow(spectralFlow);
          this.updateFlowVector(blendedFlow);
        }
        handleEnergyChange(event) {
          const customEvent = event;
          const { energy, valence } = customEvent.detail;
          const energyModulation = energy * this.flowSettings.flowSensitivity;
          const valenceModulation = valence * 0.5;
          this.currentFlowVector.intensity = Math.min(
            this.flowSettings.maxFlowIntensity,
            energyModulation + valenceModulation
          );
        }
        calculateBeatFlow(intensity, bpm, confidence) {
          const beatPhase = performance.now() / 1e3 * (bpm / 60);
          const flowAngle = beatPhase * Math.PI * 2;
          const flowMagnitude = intensity * this.flowSettings.beatResponseStrength * confidence;
          const flowX = Math.cos(flowAngle) * flowMagnitude;
          const flowY = Math.sin(flowAngle) * flowMagnitude;
          return {
            x: flowX,
            y: flowY,
            intensity: flowMagnitude,
            timestamp: performance.now()
          };
        }
        applyGenreModifications(flowVector) {
          if (!this.flowSettings.genreAdaptation || !this.currentGenre) {
            return flowVector;
          }
          const genrePattern = this.genreFlowPatterns[this.currentGenre.genre] || this.genreFlowPatterns.default;
          const blendFactor = 0.3;
          return {
            x: flowVector.x * (1 - blendFactor) + genrePattern.x * blendFactor,
            y: flowVector.y * (1 - blendFactor) + genrePattern.y * blendFactor,
            intensity: flowVector.intensity * (1 - blendFactor) + genrePattern.intensity * blendFactor,
            timestamp: performance.now()
          };
        }
        mapSpectralToFlow(spectralData) {
          const { bassEnergy, midEnergy, trebleEnergy, harmonicContent } = spectralData;
          this.spectralFlowMapping.bassFlow = {
            x: bassEnergy * 0.8,
            y: bassEnergy * 0.2,
            intensity: bassEnergy,
            timestamp: performance.now()
          };
          this.spectralFlowMapping.midFlow = {
            x: midEnergy * 0.6,
            y: midEnergy * 0.6,
            intensity: midEnergy,
            timestamp: performance.now()
          };
          this.spectralFlowMapping.trebleFlow = {
            x: trebleEnergy * 0.2,
            y: trebleEnergy * 0.8,
            intensity: trebleEnergy,
            timestamp: performance.now()
          };
          this.spectralFlowMapping.harmonyFlow = {
            x: harmonicContent * 0.5,
            y: harmonicContent * 0.7,
            intensity: harmonicContent,
            timestamp: performance.now()
          };
          return this.spectralFlowMapping;
        }
        blendSpectralFlow(spectralFlow) {
          const weights = { bass: 0.4, mid: 0.3, treble: 0.2, harmony: 0.1 };
          const blendedX = spectralFlow.bassFlow.x * weights.bass + spectralFlow.midFlow.x * weights.mid + spectralFlow.trebleFlow.x * weights.treble + spectralFlow.harmonyFlow.x * weights.harmony;
          const blendedY = spectralFlow.bassFlow.y * weights.bass + spectralFlow.midFlow.y * weights.mid + spectralFlow.trebleFlow.y * weights.treble + spectralFlow.harmonyFlow.y * weights.harmony;
          const blendedIntensity = spectralFlow.bassFlow.intensity * weights.bass + spectralFlow.midFlow.intensity * weights.mid + spectralFlow.trebleFlow.intensity * weights.treble + spectralFlow.harmonyFlow.intensity * weights.harmony;
          return {
            x: blendedX,
            y: blendedY,
            intensity: blendedIntensity,
            timestamp: performance.now()
          };
        }
        updateFlowVector(newFlow) {
          this.flowSmoothingBuffer.push(newFlow);
          if (this.flowSmoothingBuffer.length > 5) {
            this.flowSmoothingBuffer.shift();
          }
          const smoothedFlow = this.calculateSmoothedFlow();
          this.currentFlowVector = smoothedFlow;
          if (this.flowSettings.corridorFlowEnabled) {
            this.updateRadialFlow(smoothedFlow);
          }
          this.updateCSSVariables();
        }
        calculateSmoothedFlow() {
          const buffer = this.flowSmoothingBuffer;
          const smoothingFactor = this.flowSettings.smoothingFactor;
          let smoothedX = buffer[0]?.x || 0;
          let smoothedY = buffer[0]?.y || 0;
          let smoothedIntensity = buffer[0]?.intensity || 0;
          for (let i = 1; i < buffer.length; i++) {
            smoothedX = smoothedX * smoothingFactor + buffer[i].x * (1 - smoothingFactor);
            smoothedY = smoothedY * smoothingFactor + buffer[i].y * (1 - smoothingFactor);
            smoothedIntensity = smoothedIntensity * smoothingFactor + buffer[i].intensity * (1 - smoothingFactor);
          }
          return {
            x: smoothedX,
            y: smoothedY,
            intensity: smoothedIntensity,
            timestamp: performance.now()
          };
        }
        updateRadialFlow(linearFlow) {
          const centerX = 0.5;
          const centerY = 0.5;
          const currentTime = performance.now() / 1e3;
          const rotationPhase = currentTime * 0.1;
          const baseAngle = rotationPhase + linearFlow.x * Math.PI * 2;
          const inwardVectorX = -Math.cos(baseAngle);
          const inwardVectorY = -Math.sin(baseAngle);
          const distanceFromCenter = Math.sqrt(
            inwardVectorX * inwardVectorX + inwardVectorY * inwardVectorY
          );
          const normalizedInwardX = inwardVectorX / (distanceFromCenter || 1);
          const normalizedInwardY = inwardVectorY / (distanceFromCenter || 1);
          const baseInwardFlow = this.flowSettings.inwardFlowIntensity;
          const beatModifier = this.calculateBeatModifier();
          const genreModifier = this.calculateGenreInwardModifier();
          const inwardFlow = Math.min(
            1,
            baseInwardFlow * beatModifier * genreModifier * this.flowSettings.corridorBeatResponse
          );
          this.currentRadialFlow = {
            angle: Math.atan2(normalizedInwardY, normalizedInwardX),
            // Angle of inward flow
            radius: Math.min(1, distanceFromCenter * this.flowSettings.radialFlowStrength),
            intensity: linearFlow.intensity,
            inwardFlow,
            timestamp: performance.now()
          };
          if (this.cssVariableController) {
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-inward-vector-x",
              normalizedInwardX.toFixed(3)
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-inward-vector-y",
              normalizedInwardY.toFixed(3)
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-radial-distance",
              distanceFromCenter.toFixed(3)
            );
          }
        }
        calculateBeatModifier() {
          if (!this.musicSyncService) return 1;
          const musicState = this.musicSyncService.getCurrentMusicState();
          if (!musicState) return 1;
          const currentTime = performance.now();
          const timeSinceLastBeat = currentTime - this.lastBeatTime;
          const beatDecayTime = 500;
          const beatDecay = Math.max(0, 1 - timeSinceLastBeat / beatDecayTime);
          const beatEnergy = musicState.beat?.energy ?? 0.5;
          return 0.6 + beatEnergy * 0.8 + beatDecay * 0.4;
        }
        calculateGenreInwardModifier() {
          if (!this.currentGenre) return 1;
          const genreModifiers = {
            electronic: 1.2,
            // Strong inward pull for electronic
            ambient: 0.8,
            // Gentle for ambient
            rock: 1,
            // Balanced for rock
            pop: 0.9,
            // Slightly less for pop
            jazz: 0.7,
            // Subtle for jazz
            classical: 0.6
            // Very subtle for classical
          };
          const genreKey = this.currentGenre.genre;
          return genreModifiers[genreKey] ?? 1;
        }
        updateCSSVariables() {
          const currentTime = performance.now();
          if (currentTime - this.lastFlowUpdate < this.updateThrottleInterval) return;
          this.lastFlowUpdate = currentTime;
          if (this.cssVariableController) {
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-flow-direction-x",
              this.currentFlowVector.x.toFixed(3)
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-flow-direction-y",
              this.currentFlowVector.y.toFixed(3)
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-flow-intensity",
              this.currentFlowVector.intensity.toFixed(3)
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-flow-strength",
              (this.currentFlowVector.intensity * 0.8).toFixed(3)
            );
            const flowAngle = Math.atan2(
              this.currentFlowVector.y,
              this.currentFlowVector.x
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-flow-angle",
              `${(flowAngle * 180 / Math.PI).toFixed(1)}deg`
            );
            if (this.flowSettings.corridorFlowEnabled) {
              this.cssVariableController.queueCSSVariableUpdate(
                "--sn-corridor-flow-angle",
                this.currentRadialFlow.angle.toFixed(3)
              );
              this.cssVariableController.queueCSSVariableUpdate(
                "--sn-corridor-flow-radius",
                this.currentRadialFlow.radius.toFixed(3)
              );
              this.cssVariableController.queueCSSVariableUpdate(
                "--sn-corridor-inward-flow",
                this.currentRadialFlow.inwardFlow.toFixed(3)
              );
              this.cssVariableController.queueCSSVariableUpdate(
                "--sn-corridor-flow-intensity",
                this.currentRadialFlow.intensity.toFixed(3)
              );
              this.cssVariableController.queueCSSVariableUpdate(
                "--sn-corridor-flow-enabled",
                "1"
              );
            } else {
              this.cssVariableController.queueCSSVariableUpdate(
                "--sn-corridor-flow-enabled",
                "0"
              );
            }
          }
        }
        adaptFlowToGenre(genre) {
          const genrePattern = this.genreFlowPatterns[genre.genre] || this.genreFlowPatterns.default;
          document.dispatchEvent(
            new CustomEvent("gradient-flow:genre-adapted", {
              detail: {
                genre,
                flowPattern: genrePattern,
                timestamp: performance.now()
              }
            })
          );
        }
        startFlowUpdates() {
          const updateFlow = /* @__PURE__ */ __name(() => {
            if (!this.isActive) return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.lastFlowUpdate;
            this.animateFlowPatterns(deltaTime);
            setTimeout(updateFlow, this.updateThrottleInterval);
          }, "updateFlow");
          updateFlow();
        }
        animateFlowPatterns(deltaTime) {
          const animationPhase = performance.now() / 1e3 * 0.1;
          const baseX = this.currentFlowVector.x;
          const baseY = this.currentFlowVector.y;
          const animatedX = baseX + Math.sin(animationPhase) * 0.05;
          const animatedY = baseY + Math.cos(animationPhase) * 0.05;
          if (this.cssVariableController) {
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-flow-animated-x",
              animatedX.toFixed(3)
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-flow-animated-y",
              animatedY.toFixed(3)
            );
          }
        }
        updateAnimation(deltaTime) {
          this.animateFlowPatterns(deltaTime);
        }
        async healthCheck() {
          const isHealthy = this.flowSettings.enabled && this.currentFlowVector.timestamp > 0 && this.musicSyncService !== null;
          return {
            system: "GradientDirectionalFlowSystem",
            healthy: isHealthy,
            metrics: {
              enabled: this.flowSettings.enabled,
              lastUpdateTime: this.currentFlowVector.timestamp,
              musicSyncConnected: !!this.musicSyncService,
              flowIntensity: this.currentFlowVector.intensity
            },
            issues: isHealthy ? [] : [
              ...this.flowSettings.enabled ? [] : ["System disabled"],
              ...this.currentFlowVector.timestamp > 0 ? [] : ["No flow updates"],
              ...this.musicSyncService ? [] : ["Music sync disconnected"]
            ]
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.boundBeatHandler) {
            document.removeEventListener("music-sync:beat", this.boundBeatHandler);
          }
          if (this.boundGenreHandler) {
            document.removeEventListener(
              "music-sync:genre-detected",
              this.boundGenreHandler
            );
          }
          if (this.boundSpectralHandler) {
            document.removeEventListener(
              "music-sync:spectral-analysis",
              this.boundSpectralHandler
            );
          }
          if (this.boundEnergyHandler) {
            document.removeEventListener(
              "music-sync:energy-changed",
              this.boundEnergyHandler
            );
          }
          this.boundBeatHandler = null;
          this.boundGenreHandler = null;
          this.boundSpectralHandler = null;
          this.boundEnergyHandler = null;
        }
        // Public API for flow control
        setFlowSensitivity(sensitivity) {
          this.flowSettings.flowSensitivity = Math.max(0, Math.min(1, sensitivity));
        }
        setBeatResponseStrength(strength) {
          this.flowSettings.beatResponseStrength = Math.max(0, Math.min(1, strength));
        }
        setGenreAdaptation(enabled) {
          this.flowSettings.genreAdaptation = enabled;
        }
        setSpectralSeparation(enabled) {
          this.flowSettings.spectralSeparation = enabled;
        }
        getCurrentFlowVector() {
          return { ...this.currentFlowVector };
        }
        getFlowSettings() {
          return { ...this.flowSettings };
        }
        getGenreFlowPatterns() {
          return { ...this.genreFlowPatterns };
        }
        // ========================================================================
        // PUBLIC CORRIDOR FLOW METHODS
        // ========================================================================
        /**
         * Enable or disable corridor flow effects
         * @param enabled Whether to enable corridor flow mapping
         */
        setCorridorFlowEnabled(enabled) {
          this.flowSettings.corridorFlowEnabled = enabled;
          if (this.cssVariableController) {
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-corridor-flow-enabled",
              enabled ? "1" : "0"
            );
          }
          Y3KDebug?.debug?.log(
            "GradientDirectionalFlowSystem",
            `Corridor flow ${enabled ? "enabled" : "disabled"}`
          );
        }
        /**
         * Get current radial flow vector for corridor effects
         * @returns Current radial flow state
         */
        getCurrentRadialFlow() {
          return { ...this.currentRadialFlow };
        }
        /**
         * Update corridor flow settings
         * @param settings Partial corridor flow settings to update
         */
        updateCorridorFlowSettings(settings2) {
          if (settings2.radialFlowStrength !== void 0) {
            this.flowSettings.radialFlowStrength = Math.max(0, Math.min(2, settings2.radialFlowStrength));
          }
          if (settings2.inwardFlowIntensity !== void 0) {
            this.flowSettings.inwardFlowIntensity = Math.max(0, Math.min(1, settings2.inwardFlowIntensity));
          }
          if (settings2.corridorBeatResponse !== void 0) {
            this.flowSettings.corridorBeatResponse = Math.max(0, Math.min(3, settings2.corridorBeatResponse));
          }
          Y3KDebug?.debug?.log(
            "GradientDirectionalFlowSystem",
            "Corridor flow settings updated",
            settings2
          );
        }
        /**
         * Get corridor flow mapping for external systems
         * @returns Object containing both linear and radial flow data
         */
        getCorridorFlowMapping() {
          return {
            linearFlow: { ...this.currentFlowVector },
            radialFlow: { ...this.currentRadialFlow },
            enabled: this.flowSettings.corridorFlowEnabled
          };
        }
        /**
         * Calculate true inward vectors for any screen position
         * This method provides the mathematical foundation for corridor effects
         * by calculating vectors that point directly toward screen center from any position
         * 
         * @param screenX Normalized screen X coordinate (0.0 to 1.0)
         * @param screenY Normalized screen Y coordinate (0.0 to 1.0)
         * @returns Object containing inward vector components and distance from center
         */
        calculateInwardVectorForPosition(screenX, screenY) {
          const centerX = 0.5;
          const centerY = 0.5;
          const deltaX = centerX - screenX;
          const deltaY = centerY - screenY;
          const distanceFromCenter = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          const normalizedInwardX = distanceFromCenter > 1e-3 ? deltaX / distanceFromCenter : 0;
          const normalizedInwardY = distanceFromCenter > 1e-3 ? deltaY / distanceFromCenter : 0;
          const distanceBasedIntensity = Math.min(1, distanceFromCenter * 2);
          const musicBasedIntensity = this.currentFlowVector.intensity * this.flowSettings.inwardFlowIntensity;
          const beatEnhancement = this.calculateBeatModifier();
          const flowIntensity = distanceBasedIntensity * musicBasedIntensity * beatEnhancement;
          return {
            inwardX: normalizedInwardX,
            inwardY: normalizedInwardY,
            distanceFromCenter,
            flowIntensity: Math.min(1, flowIntensity)
          };
        }
        /**
         * Get optimized inward flow vectors for corridor shader coordination
         * This provides pre-calculated inward vectors for common shader sampling points
         * @returns Array of inward vectors for shader efficiency
         */
        getInwardFlowVectorsForShader() {
          const vectors2 = [];
          const vectorCount = 8;
          for (let i = 0; i < vectorCount; i++) {
            const angle = i / vectorCount * Math.PI * 2;
            const radiusFromCenter = 0.4;
            const sampleX = 0.5 + Math.cos(angle) * radiusFromCenter;
            const sampleY = 0.5 + Math.sin(angle) * radiusFromCenter;
            const inwardVector = this.calculateInwardVectorForPosition(sampleX, sampleY);
            vectors2.push({
              angle,
              inwardX: inwardVector.inwardX,
              inwardY: inwardVector.inwardY,
              intensity: inwardVector.flowIntensity
            });
          }
          return vectors2;
        }
      };
      __name(_GradientDirectionalFlowSystem, "GradientDirectionalFlowSystem");
      GradientDirectionalFlowSystem = _GradientDirectionalFlowSystem;
    }
  });

  // src-js/visual/backgrounds/DepthLayeredGradientSystem.ts
  var _DepthLayeredGradientSystem, DepthLayeredGradientSystem;
  var init_DepthLayeredGradientSystem = __esm({
    "src-js/visual/backgrounds/DepthLayeredGradientSystem.ts"() {
      "use strict";
      init_EmotionalGradientMapper();
      init_GenreProfileManager();
      init_globalConfig();
      init_UnifiedEventBus();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_ThemeUtilities();
      init_BaseVisualSystem();
      _DepthLayeredGradientSystem = class _DepthLayeredGradientSystem extends BaseVisualSystem {
        constructor(config = ADVANCED_SYSTEM_CONFIG, utils, performanceMonitor, musicSyncService = null, settingsManager2 = null, year3000System = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this.colorHarmonyEngine = null;
          this.emotionalGradientMapper = null;
          this.genreProfileManager = null;
          this.containerElement = null;
          this.backgroundContainer = null;
          // Musical visual effects spectral data
          this.spectralData = {
            bassResponse: 0,
            midResponse: 0,
            trebleResponse: 0,
            vocalPresence: 0
          };
          // ✅ RAF LOOP CONSOLIDATION: Removed animationFrameId (coordinator manages animation)
          this.lastAnimationTime = 0;
          this.scrollY = 0;
          this.scrollX = 0;
          this.boundScrollHandler = null;
          this.boundResizeHandler = null;
          this.eventSubscriptionIds = [];
          // Visual effects coordinator integration
          this.visualEffectsCoordinator = null;
          this.currentVisualEffectState = null;
          // LERP smoothing half-life values (in seconds) for framerate-independent animations
          this.lerpHalfLifeValues = {
            parallaxOffset: 0.15,
            // Smooth parallax movement
            opacity: 0.2,
            // Gentle opacity transitions
            blur: 0.25,
            // Smooth blur changes
            hueRotate: 0.3,
            // Gradual color shifts
            scale: 0.18
            // Smooth scale transitions
          };
          // Make systemName publicly accessible for the interface
          this.systemName = "DepthLayeredGradientSystem";
          this.layerTemplates = {
            // Enhanced cosmic blob with multiple bubble formations
            cosmic: {
              gradient: "radial-gradient(ellipse 60% 40% at 25% 30%, rgba(88, 91, 112, 0.9) 0%, rgba(49, 50, 68, 0.5) 40%, transparent 80%), radial-gradient(ellipse 40% 60% at 75% 70%, rgba(49, 50, 68, 0.7) 0%, rgba(30, 30, 46, 0.3) 50%, transparent 85%), radial-gradient(circle 30% at 50% 50%, rgba(88, 91, 112, 0.4) 0%, transparent 70%)",
              animation: "cosmic-drift",
              duration: "120s"
            },
            // Enhanced void with deep bubble patterns
            void: {
              gradient: "radial-gradient(ellipse 50% 35% at 40% 25%, rgba(30, 30, 46, 0.95) 0%, rgba(49, 50, 68, 0.7) 35%, transparent 90%), radial-gradient(ellipse 35% 50% at 65% 75%, rgba(49, 50, 68, 0.8) 0%, rgba(88, 91, 112, 0.4) 45%, transparent 85%), radial-gradient(circle 25% at 20% 80%, rgba(30, 30, 46, 0.6) 0%, transparent 80%)",
              animation: "void-expansion",
              duration: "480s"
            },
            // Multi-blob formation with dynamic positioning
            multiBlobPrimary: {
              gradient: "radial-gradient(circle 20% at 15% 20%, rgba(203, 166, 247, 0.6) 0%, rgba(203, 166, 247, 0.2) 50%, transparent 70%), radial-gradient(circle 25% at 45% 60%, rgba(245, 194, 231, 0.5) 0%, rgba(245, 194, 231, 0.15) 45%, transparent 75%), radial-gradient(circle 18% at 75% 35%, rgba(137, 180, 250, 0.55) 0%, rgba(137, 180, 250, 0.18) 48%, transparent 72%), radial-gradient(circle 15% at 85% 85%, rgba(203, 166, 247, 0.4) 0%, transparent 65%)",
              animation: "multi-blob-primary",
              duration: "200s"
            },
            // Multi-blob secondary layer with different positioning
            multiBlobSecondary: {
              gradient: "radial-gradient(circle 22% at 30% 75%, rgba(250, 179, 135, 0.5) 0%, rgba(250, 179, 135, 0.12) 50%, transparent 75%), radial-gradient(circle 28% at 70% 25%, rgba(166, 227, 161, 0.45) 0%, rgba(166, 227, 161, 0.1) 48%, transparent 78%), radial-gradient(circle 16% at 10% 50%, rgba(245, 194, 231, 0.52) 0%, rgba(245, 194, 231, 0.15) 46%, transparent 70%), radial-gradient(circle 20% at 90% 60%, rgba(137, 180, 250, 0.4) 0%, transparent 68%)",
              animation: "multi-blob-secondary",
              duration: "280s"
            },
            // Large smooth blob formations
            smoothBubbles: {
              gradient: "radial-gradient(ellipse 45% 35% at 35% 40%, rgba(203, 166, 247, 0.4) 0%, rgba(203, 166, 247, 0.1) 60%, transparent 90%), radial-gradient(ellipse 35% 45% at 70% 65%, rgba(137, 180, 250, 0.35) 0%, rgba(137, 180, 250, 0.08) 65%, transparent 95%), radial-gradient(circle 25% at 25% 75%, rgba(245, 194, 231, 0.3) 0%, transparent 80%), radial-gradient(ellipse 20% 30% at 80% 20%, rgba(250, 179, 135, 0.25) 0%, transparent 75%)",
              animation: "smooth-bubble-flow",
              duration: "320s"
            },
            // Nebula with enhanced blob-like structure
            nebula: {
              gradient: "conic-gradient(from 45deg, rgba(203, 166, 247, 0.3) 0%, rgba(245, 194, 231, 0.2) 25%, rgba(250, 179, 135, 0.1) 50%, rgba(166, 227, 161, 0.2) 75%, rgba(203, 166, 247, 0.3) 100%)",
              animation: "nebula-flow",
              duration: "180s"
            },
            // Stellar motion enhanced
            stellar: {
              gradient: "linear-gradient(45deg, rgba(137, 180, 250, 0.2) 0%, rgba(203, 166, 247, 0.1) 25%, rgba(245, 194, 231, 0.2) 50%, rgba(250, 179, 135, 0.1) 75%, rgba(166, 227, 161, 0.2) 100%)",
              animation: "stellar-motion",
              duration: "240s"
            },
            // Dimensional shift enhanced
            dimensional: {
              gradient: "linear-gradient(135deg, rgba(137, 180, 250, 0.1) 0%, rgba(203, 166, 247, 0.2) 20%, rgba(245, 194, 231, 0.1) 40%, rgba(250, 179, 135, 0.2) 60%, rgba(166, 227, 161, 0.1) 80%, rgba(137, 180, 250, 0.2) 100%)",
              animation: "dimensional-shift",
              duration: "360s"
            }
          };
          this.colorHarmonyEngine = year3000System?.colorHarmonyEngine || null;
          this.visualEffectsCoordinator = year3000System?.backgroundConsciousnessChoreographer || null;
          this.cssVariableController = null;
          this.deviceCapabilities = new DeviceCapabilityDetector();
          this.depthLayers = /* @__PURE__ */ new Map();
          this.visualEffectsLayers = /* @__PURE__ */ new Map();
          this.depthSettings = {
            enabled: true,
            layerCount: 6,
            maxDepth: 1e3,
            parallaxStrength: 0.5,
            depthFogIntensity: 0.7,
            infiniteScrolling: true,
            qualityLevel: "medium",
            performanceMode: false,
            musicalVisualEffects: {
              enabled: true,
              activityLevel: 0.7,
              temporalMemory: 0.3,
              harmonicSensitivity: 0.6,
              flowDynamics: 0.4,
              stellarDensity: 0.5,
              dimensionalDepth: 3
            }
          };
          this.performanceMetrics = {
            totalLayers: 0,
            visibleLayers: 0,
            averageDepth: 0,
            parallaxRange: 0,
            renderTime: 0,
            memoryUsage: 0
          };
          this.boundScrollHandler = this.handleScroll.bind(this);
          this.boundResizeHandler = this.handleResize.bind(this);
          this.adaptToDeviceCapabilities();
        }
        /**
         * Dependency injection setter for CSS Variable Controller
         * Called by VisualSystemFacade during system initialization
         */
        setOptimizedCSSVariableManager(cssController) {
          this.cssVariableController = cssController;
          this.initializeMusicalVisualEffects();
        }
        /**
         * Initialize musical visual effects components (async version)
         */
        async initializeMusicalVisualEffectsAsync() {
          this.initializeMusicalVisualEffects();
          if (this.emotionalGradientMapper) {
            await this.emotionalGradientMapper.initialize();
          }
        }
        /**
         * Initialize musical visual effects components
         */
        initializeMusicalVisualEffects() {
          if (!this.cssVariableController) {
            Y3KDebug?.debug?.warn(
              "DepthLayeredGradientSystem",
              "CSS variable controller not available, musical visual effects disabled"
            );
            return;
          }
          try {
            this.emotionalGradientMapper = new EmotionalGradientMapper(
              this.cssVariableController,
              this.musicSyncService,
              this.settingsManager
            );
            this.genreProfileManager = new GenreProfileManager();
            Y3KDebug?.debug?.log(
              "DepthLayeredGradientSystem",
              "Musical visual effects components initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DepthLayeredGradientSystem",
              "Failed to initialize musical visual effects:",
              error
            );
            this.emotionalGradientMapper = null;
            this.genreProfileManager = null;
          }
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          this.loadSettings();
          this.createContainerElements();
          this.createDepthAnimations();
          this.initializeDepthLayers();
          this.initializeVisualEffectsLayers();
          if (this.cssVariableController) {
            await this.initializeMusicalVisualEffectsAsync();
          }
          this.setupEventListeners();
          this.registerWithVisualEffectsCoordinator();
          Y3KDebug?.debug?.log(
            "DepthLayeredGradientSystem",
            "Depth-layered gradient system initialized"
          );
        }
        loadSettings() {
          if (!this.settingsManager) return;
          try {
            const qualitySetting = this.settingsManager.get(
              "sn-depth-quality"
            );
            if (qualitySetting) {
              this.depthSettings.qualityLevel = qualitySetting;
              this.adjustQualitySettings();
            }
            const enabledSetting = this.settingsManager.get(
              "sn-depth-enabled"
            );
            if (enabledSetting !== void 0) {
              this.depthSettings.enabled = enabledSetting;
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "DepthLayeredGradientSystem",
              "Failed to load settings:",
              error
            );
          }
        }
        adaptToDeviceCapabilities() {
          const recommendation = this.deviceCapabilities.recommendPerformanceQuality();
          switch (recommendation) {
            case "low":
              this.depthSettings.qualityLevel = "low";
              this.depthSettings.layerCount = 3;
              this.depthSettings.performanceMode = true;
              break;
            case "balanced":
              this.depthSettings.qualityLevel = "medium";
              this.depthSettings.layerCount = 6;
              this.depthSettings.performanceMode = false;
              break;
            case "high":
              this.depthSettings.qualityLevel = "high";
              this.depthSettings.layerCount = 9;
              this.depthSettings.performanceMode = false;
              break;
          }
        }
        adjustQualitySettings() {
          switch (this.depthSettings.qualityLevel) {
            case "low":
              this.depthSettings.layerCount = 3;
              this.depthSettings.parallaxStrength = 0.3;
              this.depthSettings.depthFogIntensity = 0.5;
              break;
            case "medium":
              this.depthSettings.layerCount = 6;
              this.depthSettings.parallaxStrength = 0.5;
              this.depthSettings.depthFogIntensity = 0.7;
              break;
            case "high":
              this.depthSettings.layerCount = 9;
              this.depthSettings.parallaxStrength = 0.8;
              this.depthSettings.depthFogIntensity = 0.9;
              break;
          }
        }
        createContainerElements() {
          this.containerElement = document.querySelector(".Root__main-view") || document.querySelector(".main-view-container") || document.body;
          this.backgroundContainer = document.createElement("div");
          this.backgroundContainer.className = "sn-depth-background-container";
          this.backgroundContainer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -20;
      pointer-events: none;
      overflow: hidden;
      perspective: 1000px;
      transform-style: preserve-3d;
    `;
          this.containerElement.insertBefore(
            this.backgroundContainer,
            this.containerElement.firstChild
          );
        }
        createDepthAnimations() {
          const styleElement = document.createElement("style");
          styleElement.textContent = `
      .sn-depth-layer {
        position: absolute;
        width: 120%;
        height: 120%;
        top: -10%;
        left: -10%;
        pointer-events: none;
        transform-style: preserve-3d;
        will-change: transform, opacity;
      }

      @keyframes cosmic-drift {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        25% { transform: translate3d(-2%, 1%, 0) rotate(0.5deg) scale(1.02); }
        50% { transform: translate3d(0, -1%, 0) rotate(0deg) scale(0.98); }
        75% { transform: translate3d(2%, 0.5%, 0) rotate(-0.5deg) scale(1.01); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes nebula-flow {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        33% { transform: translate3d(1%, -1%, 0) rotate(1deg) scale(1.03); }
        66% { transform: translate3d(-1%, 1%, 0) rotate(-1deg) scale(0.97); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes stellar-motion {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        20% { transform: translate3d(-1%, 0.5%, 0) rotate(0.3deg) scale(1.01); }
        40% { transform: translate3d(0.5%, -0.5%, 0) rotate(-0.3deg) scale(0.99); }
        60% { transform: translate3d(1%, 0.5%, 0) rotate(0.2deg) scale(1.02); }
        80% { transform: translate3d(-0.5%, 1%, 0) rotate(-0.2deg) scale(0.98); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes quantum-field {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); filter: blur(0px); }
        25% { transform: translate3d(0.5%, -0.5%, 0) rotate(0.1deg) scale(1.01); filter: blur(0.5px); }
        50% { transform: translate3d(-0.5%, 0.5%, 0) rotate(-0.1deg) scale(0.99); filter: blur(1px); }
        75% { transform: translate3d(0.3%, 0.3%, 0) rotate(0.05deg) scale(1.005); filter: blur(0.3px); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); filter: blur(0px); }
      }

      @keyframes dimensional-shift {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        16% { transform: translate3d(0.2%, -0.2%, 0) rotate(0.1deg) scale(1.005); }
        32% { transform: translate3d(-0.2%, 0.2%, 0) rotate(-0.1deg) scale(0.995); }
        48% { transform: translate3d(0.1%, 0.1%, 0) rotate(0.05deg) scale(1.002); }
        64% { transform: translate3d(-0.1%, -0.1%, 0) rotate(-0.05deg) scale(0.998); }
        80% { transform: translate3d(0.15%, 0%, 0) rotate(0.02deg) scale(1.001); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes void-expansion {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.9; }
        50% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1.1); opacity: 0.6; }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.9; }
      }

      @keyframes multi-blob-primary {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.8; }
        20% { transform: translate3d(1%, -0.5%, 0) rotate(0.3deg) scale(1.03); opacity: 0.9; }
        40% { transform: translate3d(-0.5%, 1%, 0) rotate(-0.2deg) scale(0.97); opacity: 0.7; }
        60% { transform: translate3d(0.8%, 0.3%, 0) rotate(0.4deg) scale(1.05); opacity: 0.85; }
        80% { transform: translate3d(-0.3%, -0.8%, 0) rotate(-0.3deg) scale(0.98); opacity: 0.75; }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.8; }
      }

      @keyframes multi-blob-secondary {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.7; }
        25% { transform: translate3d(-1.2%, 0.8%, 0) rotate(-0.4deg) scale(1.04); opacity: 0.85; }
        50% { transform: translate3d(0.6%, -0.6%, 0) rotate(0.3deg) scale(0.96); opacity: 0.6; }
        75% { transform: translate3d(0.3%, 1.1%, 0) rotate(-0.2deg) scale(1.02); opacity: 0.8; }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.7; }
      }

      @keyframes smooth-bubble-flow {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.75; }
        12% { transform: translate3d(0.4%, -0.3%, 0) rotate(0.15deg) scale(1.02); opacity: 0.85; }
        24% { transform: translate3d(-0.3%, 0.6%, 0) rotate(-0.25deg) scale(0.98); opacity: 0.65; }
        36% { transform: translate3d(0.7%, 0.2%, 0) rotate(0.35deg) scale(1.04); opacity: 0.8; }
        48% { transform: translate3d(-0.2%, -0.5%, 0) rotate(-0.15deg) scale(0.99); opacity: 0.7; }
        60% { transform: translate3d(0.5%, 0.8%, 0) rotate(0.25deg) scale(1.03); opacity: 0.85; }
        72% { transform: translate3d(-0.6%, -0.1%, 0) rotate(-0.3deg) scale(0.97); opacity: 0.6; }
        84% { transform: translate3d(0.1%, -0.7%, 0) rotate(0.1deg) scale(1.01); opacity: 0.8; }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.75; }
      }

      @media (prefers-reduced-motion: reduce) {
        .sn-depth-layer {
          animation: none !important;
        }
      }
    `;
          document.head.appendChild(styleElement);
        }
        initializeDepthLayers() {
          if (!this.backgroundContainer) return;
          const layerTemplateKeys = Object.keys(this.layerTemplates);
          for (let i = 0; i < this.depthSettings.layerCount; i++) {
            const depth = (i + 1) * (this.depthSettings.maxDepth / this.depthSettings.layerCount);
            const templateKey = layerTemplateKeys[i % layerTemplateKeys.length];
            const template = this.layerTemplates[templateKey];
            const layerElement = document.createElement("div");
            layerElement.className = "sn-depth-layer";
            layerElement.id = `sn-depth-layer-${i}`;
            const depthFactor = depth / this.depthSettings.maxDepth;
            const parallaxFactor = 1 - depthFactor * this.depthSettings.parallaxStrength;
            const opacity = 1 - depthFactor * this.depthSettings.depthFogIntensity;
            const scale = 1 + depthFactor * 0.2;
            const blur = depthFactor * 3;
            layerElement.style.cssText = `
        background: ${template.gradient};
        transform: translate3d(0, 0, ${-depth}px) scale(${scale});
        opacity: ${opacity};
        filter: blur(${blur}px);
        animation: ${template.animation} ${template.duration} ease-in-out infinite;
        animation-delay: ${i * 0.5}s;
      `;
            const depthLayer = {
              id: `depth-layer-${i}`,
              element: layerElement,
              depth,
              parallaxFactor,
              opacityRange: [opacity * 0.5, opacity],
              scaleRange: [scale * 0.95, scale * 1.05],
              rotationSpeed: 0.01 + i * 1e-3,
              colorShift: i * 30,
              blurAmount: blur,
              animationPhase: i * Math.PI / 4,
              enabled: true,
              // Initialize LERP smoothing properties (current = target initially)
              currentOffsetY: 0,
              targetOffsetY: 0,
              currentOpacity: opacity,
              targetOpacity: opacity,
              currentBlur: blur,
              targetBlur: blur,
              currentHueRotate: 0,
              targetHueRotate: 0,
              currentScale: scale,
              targetScale: scale
            };
            this.depthLayers.set(depthLayer.id, depthLayer);
            this.backgroundContainer.appendChild(layerElement);
          }
          this.updatePerformanceMetrics();
          Y3KDebug?.debug?.log(
            "DepthLayeredGradientSystem",
            `Initialized ${this.depthLayers.size} depth layers`
          );
        }
        /**
         * Initialize visual effects layers from FluxVisualEffectsLayers functionality
         */
        initializeVisualEffectsLayers() {
          if (!this.backgroundContainer || !this.depthSettings.musicalVisualEffects.enabled) {
            return;
          }
          const currentFPS = this.performanceMonitor?.averageFPS || 60;
          const isLowEndDevice = this.performanceMonitor?.getDeviceTier?.() === "low" || false;
          const shouldReduceQuality = this.performanceMonitor?.shouldReduceQuality?.() || false;
          if (currentFPS < 45 || isLowEndDevice || shouldReduceQuality) {
            this.depthSettings.musicalVisualEffects.enabled = false;
            Y3KDebug?.debug?.log(
              "DepthLayeredGradientSystem",
              `Performance mode activated - visual effects layers disabled (FPS: ${currentFPS})`
            );
            return;
          }
          const targetContainer = this.findSpotifyContainer();
          const harmonicLayer = document.createElement("div");
          harmonicLayer.className = "sn-harmonic-layer";
          harmonicLayer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: -8;
      pointer-events: none;
      will-change: auto;
    `;
          const flowDynamicsLayer = document.createElement("div");
          flowDynamicsLayer.className = "sn-flow-dynamics-primary";
          flowDynamicsLayer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: -7;
      pointer-events: none;
      will-change: auto;
    `;
          const waveDynamicsLayer = document.createElement("div");
          waveDynamicsLayer.className = "sn-wave-dynamics";
          waveDynamicsLayer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: -5;
      pointer-events: none;
      will-change: transform, opacity, clip-path;
    `;
          const flowEffectsLayer = document.createElement("div");
          flowEffectsLayer.className = "sn-flow-effects";
          flowEffectsLayer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: -4;
      pointer-events: none;
      will-change: transform, opacity, clip-path;
    `;
          const proceduralNebulaLayer = document.createElement("div");
          proceduralNebulaLayer.className = "sn-procedural-nebula";
          proceduralNebulaLayer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: -3;
      pointer-events: none;
      will-change: transform, opacity, filter;
    `;
          const stellarLayer = document.createElement("div");
          stellarLayer.className = "sn-stellar-layer";
          stellarLayer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: -6;
      pointer-events: none;
      will-change: auto;
    `;
          this.visualEffectsLayers.set("harmonic", harmonicLayer);
          this.visualEffectsLayers.set("flowDynamics", flowDynamicsLayer);
          this.visualEffectsLayers.set("waveDynamics", waveDynamicsLayer);
          this.visualEffectsLayers.set("flowEffects", flowEffectsLayer);
          this.visualEffectsLayers.set("proceduralNebula", proceduralNebulaLayer);
          this.visualEffectsLayers.set("stellar", stellarLayer);
          targetContainer.appendChild(harmonicLayer);
          targetContainer.appendChild(flowDynamicsLayer);
          targetContainer.appendChild(stellarLayer);
          targetContainer.appendChild(waveDynamicsLayer);
          targetContainer.appendChild(flowEffectsLayer);
          targetContainer.appendChild(proceduralNebulaLayer);
          Y3KDebug?.debug?.log(
            "DepthLayeredGradientSystem",
            `Initialized ${this.visualEffectsLayers.size} visual effects layers`
          );
        }
        /**
         * Find Spotify container for visual effects layers
         */
        findSpotifyContainer() {
          const containers = [
            ".Root__main-view",
            ".main-view-container",
            ".main-gridContainer-gridContainer",
            ".Root__top-container",
            "body"
          ];
          for (const selector of containers) {
            const element = document.querySelector(selector);
            if (element) {
              return element;
            }
          }
          return document.body;
        }
        setupEventListeners() {
          if (this.boundScrollHandler) {
            window.addEventListener("scroll", this.boundScrollHandler, {
              passive: true
            });
          }
          if (this.boundResizeHandler) {
            window.addEventListener("resize", this.boundResizeHandler, {
              passive: true
            });
          }
          const musicBeatSub = unifiedEventBus.subscribe(
            "music:beat",
            this.handleMusicBeat.bind(this),
            "DepthLayeredGradientSystem"
          );
          this.eventSubscriptionIds.push(musicBeatSub);
          const musicEnergySub = unifiedEventBus.subscribe(
            "music:energy",
            this.handleMusicEnergy.bind(this),
            "DepthLayeredGradientSystem"
          );
          this.eventSubscriptionIds.push(musicEnergySub);
          Y3KDebug?.debug?.log(
            "DepthLayeredGradientSystem",
            "Event listeners set up",
            {
              unifiedEventSubscriptions: this.eventSubscriptionIds.length
            }
          );
        }
        handleScroll(event) {
          this.scrollY = window.scrollY;
          this.scrollX = window.scrollX;
          this.updateParallaxEffects();
        }
        handleResize(event) {
          this.updateLayerDimensions();
        }
        handleMusicBeat(data) {
          this.pulseDepthLayers(data.intensity);
          this.handleMusicalVisualEffectsBeat(data.intensity);
          Y3KDebug?.debug?.log("DepthLayeredGradientSystem", "Music beat processed", {
            bpm: data.bpm,
            intensity: data.intensity
          });
        }
        handleMusicEnergy(data) {
          this.updateDepthWithMusicEnergy(data.energy);
          this.handleMusicalVisualEffectsSpectralData({
            energy: data.energy,
            valence: data.valence
          });
          Y3KDebug?.debug?.log(
            "DepthLayeredGradientSystem",
            "Music energy processed",
            {
              energy: data.energy,
              valence: data.valence
            }
          );
        }
        /**
         * Handle musical visual effects beat effects (from FluxVisualEffectsLayers)
         */
        handleMusicalVisualEffectsBeat(intensity) {
          if (!this.depthSettings.musicalVisualEffects.enabled) return;
          this.updateFlowDynamics(intensity);
        }
        /**
         * Handle musical visual effects spectral data (from FluxVisualEffectsLayers)
         */
        handleMusicalVisualEffectsSpectralData(data) {
          if (!this.depthSettings.musicalVisualEffects.enabled) return;
          this.spectralData.bassResponse = data.energy * 0.8;
          this.spectralData.midResponse = data.energy * 0.6;
          this.spectralData.trebleResponse = data.energy * 0.4;
          this.spectralData.vocalPresence = data.valence * 0.7;
          this.updateSpectralVariables();
        }
        updateParallaxEffects() {
          if (!this.depthSettings.infiniteScrolling) return;
          this.depthLayers.forEach((layer) => {
            const parallaxY = this.scrollY * layer.parallaxFactor;
            const parallaxX = this.scrollX * layer.parallaxFactor * 0.5;
            if (this.cssVariableController) {
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-x`, `${parallaxX}px`);
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-y`, `${parallaxY}px`);
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-z`, `${-layer.depth}px`);
            }
          });
        }
        updateLayerDimensions() {
          this.depthLayers.forEach((layer) => {
            const depthFactor = layer.depth / this.depthSettings.maxDepth;
            const scale = 1 + depthFactor * 0.2;
            if (this.cssVariableController) {
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-scale`, scale.toString());
            }
          });
        }
        updateDepthWithMusicEnergy(energy) {
          const energyModulation = energy * 0.3;
          this.depthLayers.forEach((layer) => {
            const baseOpacity = layer.opacityRange[0];
            const maxOpacity = layer.opacityRange[1];
            const newOpacity = baseOpacity + energyModulation * (maxOpacity - baseOpacity);
            if (this.cssVariableController) {
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-opacity`, newOpacity.toString());
            }
          });
        }
        pulseDepthLayers(intensity) {
          const pulseStrength = intensity * 0.1;
          this.depthLayers.forEach((layer) => {
            const baseScale = layer.scaleRange[0];
            const maxScale = layer.scaleRange[1];
            const pulseScale = baseScale + pulseStrength * (maxScale - baseScale);
            if (this.cssVariableController) {
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-pulse-scale`, pulseScale.toString());
              setTimeout(() => {
                if (this.cssVariableController) {
                  this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-pulse-scale`, baseScale.toString());
                }
              }, 200);
            }
          });
        }
        /**
         * ✅ RAF LOOP REMOVED - Managed by EnhancedMasterAnimationCoordinator
         *
         * Benefits:
         * - Single RAF loop for all systems (not 5-8 independent loops)
         * - Shared deltaTime calculation (eliminates redundant performance.now() calls)
         * - Coordinated frame budget management
         * - Priority-based execution order
         * - Increased target from 30 FPS to 60 FPS (coordinator manages this)
         *
         * Old method removed: startAnimationLoop()
         * Replacement: updateAnimation(deltaTime) called by coordinator
         * Note: updateDepthAnimations() still called, now from updateAnimation()
         */
        updateDepthAnimations(deltaTime) {
          const deltaTimeSeconds = deltaTime / 1e3;
          this.depthLayers.forEach((layer) => {
            layer.animationPhase += layer.rotationSpeed * deltaTime * 1e-3;
            this.updateLayerTargetsFromMusic(layer);
            layer.currentOffsetY = lerpSmooth(
              layer.currentOffsetY,
              layer.targetOffsetY,
              deltaTimeSeconds,
              this.lerpHalfLifeValues.parallaxOffset
            );
            layer.currentOpacity = lerpSmooth(
              layer.currentOpacity,
              layer.targetOpacity,
              deltaTimeSeconds,
              this.lerpHalfLifeValues.opacity
            );
            layer.currentBlur = lerpSmooth(
              layer.currentBlur,
              layer.targetBlur,
              deltaTimeSeconds,
              this.lerpHalfLifeValues.blur
            );
            layer.currentHueRotate = lerpSmooth(
              layer.currentHueRotate,
              layer.targetHueRotate,
              deltaTimeSeconds,
              this.lerpHalfLifeValues.hueRotate
            );
            layer.currentScale = lerpSmooth(
              layer.currentScale,
              layer.targetScale,
              deltaTimeSeconds,
              this.lerpHalfLifeValues.scale
            );
            this.applyLayerProperties(layer);
          });
        }
        /**
         * Update layer target values based on music analysis and visual effects state
         */
        updateLayerTargetsFromMusic(layer) {
          const musicState = this.musicSyncService?.getCurrentMusicState();
          if (musicState) {
            const { intensity, beat, emotion } = musicState;
            const animationFactor = Math.sin(layer.animationPhase) * 0.05 * intensity;
            const baseOpacity = layer.opacityRange[0] + (layer.opacityRange[1] - layer.opacityRange[0]) * 0.5;
            layer.targetOpacity = Math.max(
              0,
              Math.min(1, baseOpacity + animationFactor)
            );
            layer.targetOffsetY = this.scrollY * layer.parallaxFactor + Math.sin(layer.animationPhase * 0.5) * intensity * 10;
            const baseScale = layer.scaleRange[0] + (layer.scaleRange[1] - layer.scaleRange[0]) * 0.5;
            layer.targetScale = baseScale + intensity * 0.05;
            layer.targetBlur = layer.blurAmount + intensity * 2;
            if (emotion) {
              const emotionHue = emotion === "energetic" ? 15 : emotion === "calm" ? -10 : emotion === "melancholy" ? -20 : 0;
              layer.targetHueRotate = emotionHue + layer.colorShift * 0.1;
            }
          } else {
            const animationFactor = Math.sin(layer.animationPhase) * 0.02;
            const baseOpacity = layer.opacityRange[0] + (layer.opacityRange[1] - layer.opacityRange[0]) * 0.5;
            layer.targetOpacity = Math.max(
              0,
              Math.min(1, baseOpacity + animationFactor)
            );
            layer.targetOffsetY = this.scrollY * layer.parallaxFactor;
            layer.targetScale = layer.scaleRange[0] + (layer.scaleRange[1] - layer.scaleRange[0]) * 0.5;
            layer.targetBlur = layer.blurAmount;
            layer.targetHueRotate = 0;
          }
        }
        /**
         * Apply the current smoothed properties to the layer element
         */
        applyLayerProperties(layer) {
          if (this.cssVariableController) {
            this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-offset-y`, `${layer.currentOffsetY}px`);
            this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-depth-z`, `${-layer.depth}px`);
            this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-scale`, layer.currentScale.toString());
            this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-opacity`, layer.currentOpacity.toString());
            this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-blur`, `${layer.currentBlur}px`);
            this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-hue`, `${layer.currentHueRotate}deg`);
          }
        }
        updatePerformanceMetrics() {
          this.performanceMetrics.totalLayers = this.depthLayers.size;
          this.performanceMetrics.visibleLayers = Array.from(
            this.depthLayers.values()
          ).filter((layer) => layer.currentOpacity > 0.01).length;
          this.performanceMetrics.averageDepth = Array.from(this.depthLayers.values()).reduce(
            (sum, layer) => sum + layer.depth,
            0
          ) / this.depthLayers.size;
          this.performanceMetrics.parallaxRange = this.depthSettings.parallaxStrength;
          this.performanceMetrics.renderTime = performance.now() - this.lastAnimationTime;
          if (this.cssVariableController) {
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-depth-layers-total",
              this.performanceMetrics.totalLayers.toString()
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-depth-layers-visible",
              this.performanceMetrics.visibleLayers.toString()
            );
          }
        }
        /**
         * Update visual effects variables (from FluxVisualEffectsLayers)
         */
        updateVisualEffectsVariables() {
          if (!this.cssVariableController || !this.depthSettings.musicalVisualEffects.enabled) return;
          const currentFPS = this.performanceMonitor?.currentFPS || 60;
          if (currentFPS < 40 && this.depthSettings.musicalVisualEffects.enabled) {
            this.depthSettings.musicalVisualEffects.enabled = false;
            this.destroyVisualEffectsLayers();
            Y3KDebug?.debug?.log(
              "DepthLayeredGradientSystem",
              `Runtime performance degradation detected - visual effects layers disabled (FPS: ${currentFPS})`
            );
            return;
          }
          const settings2 = this.depthSettings.musicalVisualEffects;
          const updates = [
            ["--sn-gradient-activity-level", settings2.activityLevel.toString()],
            ["--sn-gradient-temporal-memory", settings2.temporalMemory.toString()],
            ["--sn-gradient-harmonic-resonance", settings2.harmonicSensitivity.toString()],
            ["--sn-gradient-flow-dynamics", settings2.flowDynamics.toString()],
            ["--sn-gradient-nebula-density", settings2.stellarDensity.toString()],
            ["--sn-gradient-dimensional-depth", settings2.dimensionalDepth.toString()],
            // Pre-calculate derived values to reduce CPU overhead
            ["--sn-gradient-layer-activity", "1"],
            ["--sn-gradient-layer-temporal", "0.8"],
            ["--sn-gradient-layer-harmonic", (settings2.harmonicSensitivity * 0.6).toString()],
            ["--sn-gradient-layer-flow", (settings2.flowDynamics * 0.4).toString()],
            ["--sn-gradient-layer-stellar", (settings2.stellarDensity * 0.2).toString()],
            // Wave dynamics (reduce precision to improve performance)
            ["--sn-gradient-wave-intensity", (Math.round(settings2.activityLevel * 40) / 100).toString()],
            ["--sn-gradient-flow-intensity", (Math.round(settings2.harmonicSensitivity * 30) / 100).toString()],
            ["--sn-gradient-temporal-flow-speed", Math.max(0.5, Math.round(settings2.temporalMemory * 100) / 100).toString()]
          ];
          updates.forEach(([property, value]) => {
            if (property && value !== void 0 && this.cssVariableController) {
              this.cssVariableController.queueCSSVariableUpdate(property, value);
            }
          });
        }
        /**
         * Update spectral variables (from FluxVisualEffectsLayers)
         */
        updateSpectralVariables() {
          if (!this.cssVariableController) return;
          this.cssVariableController.queueCSSVariableUpdate(
            "--sn-gradient-bass-response",
            this.spectralData.bassResponse.toString()
          );
          this.cssVariableController.queueCSSVariableUpdate(
            "--sn-gradient-mid-response",
            this.spectralData.midResponse.toString()
          );
          this.cssVariableController.queueCSSVariableUpdate(
            "--sn-gradient-treble-response",
            this.spectralData.trebleResponse.toString()
          );
          this.cssVariableController.queueCSSVariableUpdate(
            "--sn-gradient-vocal-presence",
            this.spectralData.vocalPresence.toString()
          );
        }
        /**
         * Update flow dynamics (from FluxVisualEffectsLayers)
         */
        updateFlowDynamics(beatIntensity) {
          if (!this.cssVariableController) return;
          const flowIntensity = Math.min(
            this.depthSettings.musicalVisualEffects.flowDynamics + beatIntensity * 0.3,
            1
          );
          this.cssVariableController.queueCSSVariableUpdate(
            "--sn-gradient-flow-dynamics",
            flowIntensity.toString()
          );
          setTimeout(() => {
            if (this.cssVariableController) {
              this.cssVariableController.queueCSSVariableUpdate(
                "--sn-gradient-flow-dynamics",
                this.depthSettings.musicalVisualEffects.flowDynamics.toString()
              );
            }
          }, 500);
        }
        /**
         * Destroy visual effects layers (from FluxVisualEffectsLayers)
         */
        destroyVisualEffectsLayers() {
          this.visualEffectsLayers.forEach((layer, key) => {
            if (layer.parentNode) {
              layer.parentNode.removeChild(layer);
            }
          });
          this.visualEffectsLayers.clear();
          if (this.cssVariableController) {
            const resetVariables = [
              "--sn-gradient-activity-level",
              "--sn-gradient-layer-activity",
              "--sn-gradient-layer-temporal",
              "--sn-gradient-layer-harmonic",
              "--sn-gradient-layer-flow",
              "--sn-gradient-layer-stellar"
            ];
            resetVariables.forEach((variable) => {
              this.cssVariableController.queueCSSVariableUpdate(variable, "0");
            });
          }
        }
        /**
         * ✅ RAF LOOP CONSOLIDATION: Now receives deltaTime from coordinator
         * Calls updateDepthAnimations() which was previously called from internal RAF loop
         */
        updateAnimation(deltaTime) {
          if (!this.isActive) return;
          this.updateDepthAnimations(deltaTime);
          this.updatePerformanceMetrics();
          if (this.depthSettings.musicalVisualEffects.enabled && this.cssVariableController) {
            const currentTime = performance.now();
            const temporalPhase = currentTime / 1e4 % 1;
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-gradient-temporal-phase",
              temporalPhase.toString()
            );
            if (currentTime % 1e3 < 16) {
              this.updateVisualEffectsVariables();
            }
          }
        }
        async healthCheck() {
          const isHealthy = this.depthSettings.enabled && this.depthLayers.size > 0 && this.backgroundContainer !== null;
          return {
            system: "DepthLayeredGradientSystem",
            healthy: isHealthy,
            metrics: {
              enabled: this.depthSettings.enabled,
              layerCount: this.depthLayers.size,
              hasContainer: !!this.backgroundContainer,
              layerSettings: this.depthSettings.layerCount
            },
            issues: isHealthy ? [] : [
              ...this.depthSettings.enabled ? [] : ["System disabled"],
              ...this.depthLayers.size > 0 ? [] : ["No active layers"],
              ...this.backgroundContainer ? [] : ["Missing container element"]
            ]
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.visualEffectsCoordinator) {
            try {
              this.visualEffectsCoordinator.unregisterVisualEffectsParticipant(
                "DepthLayeredGradientSystem"
              );
              Y3KDebug?.debug?.log(
                "DepthLayeredGradientSystem",
                "Unregistered from visual effects coordinator"
              );
            } catch (error) {
              Y3KDebug?.debug?.error(
                "DepthLayeredGradientSystem",
                "Error unregistering from visual effects coordinator:",
                error
              );
            }
          }
          if (this.boundScrollHandler) {
            window.removeEventListener("scroll", this.boundScrollHandler);
          }
          if (this.boundResizeHandler) {
            window.removeEventListener("resize", this.boundResizeHandler);
          }
          this.eventSubscriptionIds.forEach((subscriptionId) => {
            unifiedEventBus.unsubscribe(subscriptionId);
          });
          this.eventSubscriptionIds = [];
          this.depthLayers.forEach((layer) => {
            if (layer.element.parentNode) {
              layer.element.parentNode.removeChild(layer.element);
            }
          });
          this.depthLayers.clear();
          this.destroyVisualEffectsLayers();
          if (this.emotionalGradientMapper) {
            this.emotionalGradientMapper.destroy();
            this.emotionalGradientMapper = null;
          }
          this.genreProfileManager = null;
          if (this.backgroundContainer && this.backgroundContainer.parentNode) {
            this.backgroundContainer.parentNode.removeChild(this.backgroundContainer);
            this.backgroundContainer = null;
          }
          this.boundScrollHandler = null;
          this.boundResizeHandler = null;
        }
        // Public API
        setDepthEnabled(enabled) {
          this.depthSettings.enabled = enabled;
          if (this.backgroundContainer) {
            this.backgroundContainer.style.display = enabled ? "block" : "none";
          }
        }
        setQualityLevel(quality) {
          this.depthSettings.qualityLevel = quality;
          this.adjustQualitySettings();
          this.depthLayers.forEach((layer) => {
            if (layer.element.parentNode) {
              layer.element.parentNode.removeChild(layer.element);
            }
          });
          this.depthLayers.clear();
          this.initializeDepthLayers();
        }
        setParallaxStrength(strength) {
          this.depthSettings.parallaxStrength = Math.max(0, Math.min(1, strength));
          this.depthLayers.forEach((layer) => {
            const depthFactor = layer.depth / this.depthSettings.maxDepth;
            layer.parallaxFactor = 1 - depthFactor * this.depthSettings.parallaxStrength;
          });
        }
        setDepthFogIntensity(intensity) {
          this.depthSettings.depthFogIntensity = Math.max(0, Math.min(1, intensity));
          this.depthLayers.forEach((layer) => {
            const depthFactor = layer.depth / this.depthSettings.maxDepth;
            const opacity = 1 - depthFactor * this.depthSettings.depthFogIntensity;
            if (this.cssVariableController) {
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-fog-opacity`, opacity.toString());
            }
            layer.currentOpacity = opacity;
          });
        }
        getDepthSettings() {
          return { ...this.depthSettings };
        }
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        getDepthLayerCount() {
          return this.depthLayers.size;
        }
        getVisibleLayerCount() {
          return this.performanceMetrics.visibleLayers;
        }
        // ===================================================================
        // MUSICAL VISUAL EFFECTS API (from FluxVisualEffectsLayers)
        // ===================================================================
        setVisualEffectsLevel(level) {
          this.depthSettings.musicalVisualEffects.activityLevel = Math.max(0, Math.min(1, level));
          this.updateVisualEffectsVariables();
        }
        setTemporalMemory(memory) {
          this.depthSettings.musicalVisualEffects.temporalMemory = Math.max(0, Math.min(1, memory));
          this.updateVisualEffectsVariables();
        }
        setHarmonicSensitivity(sensitivity) {
          this.depthSettings.musicalVisualEffects.harmonicSensitivity = Math.max(0, Math.min(1, sensitivity));
          this.updateVisualEffectsVariables();
        }
        setStellarDrift(drift) {
          if (this.cssVariableController) {
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-gradient-stellar-drift",
              `${drift}deg`
            );
          }
        }
        getVisualEffectsMetrics() {
          return {
            activityLevel: this.depthSettings.musicalVisualEffects.activityLevel,
            temporalMemory: this.depthSettings.musicalVisualEffects.temporalMemory,
            harmonicSensitivity: this.depthSettings.musicalVisualEffects.harmonicSensitivity,
            flowDynamics: this.depthSettings.musicalVisualEffects.flowDynamics,
            stellarDensity: this.depthSettings.musicalVisualEffects.stellarDensity,
            dimensionalDepth: this.depthSettings.musicalVisualEffects.dimensionalDepth,
            spectralData: { ...this.spectralData },
            emotionalProfile: this.emotionalGradientMapper?.getCurrentEmotionalProfile() || null,
            gradientState: this.emotionalGradientMapper?.getCurrentGradientState() || null,
            currentGenre: this.genreProfileManager?.getCurrentGenre() || null,
            genreConfidence: this.genreProfileManager?.getGenreConfidence() || 0,
            genreHistory: this.genreProfileManager?.getGenreHistory() || []
          };
        }
        getEmotionalGradientMapper() {
          return this.emotionalGradientMapper;
        }
        getGenreProfileManager() {
          return this.genreProfileManager;
        }
        // ===================================================================
        // VISUAL EFFECTS COORDINATOR INTEGRATION
        // ===================================================================
        /**
         * Register this depth system as a visual effects participant
         */
        registerWithVisualEffectsCoordinator() {
          if (!this.visualEffectsCoordinator) {
            Y3KDebug?.debug?.log(
              "DepthLayeredGradientSystem",
              "Visual effects coordinator not available, skipping registration"
            );
            return;
          }
          try {
            this.visualEffectsCoordinator.registerVisualEffectsParticipant(this);
            Y3KDebug?.debug?.log(
              "DepthLayeredGradientSystem",
              "Successfully registered with visual effects coordinator"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DepthLayeredGradientSystem",
              "Failed to register with visual effects coordinator:",
              error
            );
          }
        }
        // ===================================================================
        // BACKGROUND SYSTEM PARTICIPANT INTERFACE IMPLEMENTATION
        // ===================================================================
        get systemPriority() {
          return "high";
        }
        getVisualEffectsContribution() {
          return {
            depthPerception: this.depthSettings.maxDepth / 10,
            // Normalize to 0-1
            layerCount: this.depthLayers.size,
            parallaxStrength: this.depthSettings.parallaxStrength,
            fogDensity: this.depthSettings.depthFogIntensity,
            infinityPerception: this.depthSettings.infiniteScrolling ? 1 : 0.5,
            spatialAwareness: this.performanceMetrics.visibleLayers / this.performanceMetrics.totalLayers
          };
        }
        onVisualEffectsFieldUpdate(field) {
          try {
            this.currentVisualEffectState = field;
            this.updateDepthFromVisualEffects(field);
            Y3KDebug?.debug?.log(
              "DepthLayeredGradientSystem",
              "Updated from visual effects field:",
              {
                rhythmicPulse: field.pulseRate,
                depthPerception: field.depthPerception,
                animationCycle: field.pulseRate
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DepthLayeredGradientSystem",
              "Error updating from visual effects field:",
              error
            );
          }
        }
        /**
         * Update depth layers based on visual effects field
         */
        updateDepthFromVisualEffects(field) {
          const visualEffectsParallax = this.depthSettings.parallaxStrength * (0.7 + field.pulseRate * 0.6);
          for (const [layerId, layer] of this.depthLayers.entries()) {
            if (!layer.element) continue;
            const baseOpacity = layer.opacityRange[0] + (layer.opacityRange[1] - layer.opacityRange[0]) * field.flowDirection.x;
            const visualEffectsOpacity = baseOpacity * (0.8 + field.depthPerception * 0.4);
            const animationScale = 1 + Math.sin(field.pulseRate * Math.PI * 2) * 0.05;
            const baseScale = layer.scaleRange[0] + (layer.scaleRange[1] - layer.scaleRange[0]) * field.energyLevel;
            const visualEffectsScale = baseScale * animationScale;
            if (this.cssVariableController) {
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-effect-opacity`, visualEffectsOpacity.toString());
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-effect-scale`, visualEffectsScale.toString());
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-effect-translate-z`, `${layer.depth * visualEffectsParallax}px`);
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-effect-rotate`, `${layer.animationPhase * layer.rotationSpeed}deg`);
              const visualEffectsBlur = layer.blurAmount * (1 + field.depthPerception * 0.5);
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-effect-blur`, `${visualEffectsBlur}px`);
            }
            layer.currentOpacity = visualEffectsOpacity;
          }
          if (this.cssVariableController) {
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-depth-activity-parallax",
              visualEffectsParallax.toString()
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-depth-perception-intensity",
              field.depthPerception.toString()
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-depth-fog-intensity",
              this.depthSettings.depthFogIntensity.toString()
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-depth-spatial-awareness",
              (this.performanceMetrics.visibleLayers / this.performanceMetrics.totalLayers).toString()
            );
          }
        }
        /**
         * Update layer scales with animation pattern
         */
        updateLayerScalesWithAnimation(animationPhase) {
          const animationModulation = Math.sin(animationPhase * Math.PI * 2) * 0.03;
          for (const layer of this.depthLayers.values()) {
            if (!layer.element) continue;
            const baseScale = layer.scaleRange[0] + (layer.scaleRange[1] - layer.scaleRange[0]) * 0.5;
            const animationScale = baseScale * (1 + animationModulation);
            if (this.cssVariableController) {
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-anim-scale`, animationScale.toString());
            }
          }
        }
        /**
         * Update depth fog intensity across all layers
         */
        updateDepthFogIntensity() {
          for (const layer of this.depthLayers.values()) {
            if (!layer.element) continue;
            const fogIntensity = layer.depth / this.depthSettings.maxDepth * this.depthSettings.depthFogIntensity;
            const fogOpacity = Math.max(0, Math.min(0.8, fogIntensity));
            const fogSpread = 50 * fogIntensity;
            if (this.cssVariableController) {
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-fog-spread`, `${fogSpread}px`);
              this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-fog-opacity`, fogOpacity.toString());
            }
          }
        }
        /**
         * Update depth perception settings
         */
        updateDepthPerception() {
          const layerArray = Array.from(this.depthLayers.values()).sort(
            (a, b) => a.depth - b.depth
          );
          layerArray.forEach((layer, index) => {
            const depthRatio = index / (layerArray.length - 1);
            layer.depth = depthRatio * this.depthSettings.maxDepth;
            if (layer.element) {
              const translateZ = layer.depth * this.depthSettings.parallaxStrength;
              if (this.cssVariableController) {
                this.cssVariableController.queueCSSVariableUpdate(`--layer-${layer.depth}-translate-z`, `${translateZ}px`);
              }
            }
          });
        }
        // =========================================================================
        // BACKGROUND SYSTEM PARTICIPANT INTERFACE
        // =========================================================================
        onVisualStateUpdate(state) {
          this.onVisualEffectsFieldUpdate(state);
        }
        onVisualEffectEvent(eventType, payload) {
          switch (eventType) {
            case "visual-effects:rhythm-shift":
              if (payload.intensity) {
                this.depthSettings.parallaxStrength = Math.min(10, payload.intensity * 5);
              }
              break;
            case "visual-effects:color-shift":
              this.forceRepaint?.("color-shift");
              break;
            case "visual-effects:energy-surge":
              if (payload.intensity > 0.6) {
                this.depthSettings.depthFogIntensity = Math.min(1, payload.intensity);
              }
              break;
          }
        }
        getVisualContribution() {
          return {
            depthPerception: this.depthSettings.parallaxStrength / 10,
            effectDepth: this.depthSettings.depthFogIntensity,
            visualCoherence: this.depthSettings.maxDepth / 100
          };
        }
        // ===================================================================
        // BACKWARD COMPATIBILITY ALIASES
        // ===================================================================
        /** @deprecated Use onVisualEffectsFieldUpdate */
        onConsciousnessFieldUpdate(field) {
          return this.onVisualEffectsFieldUpdate(field);
        }
        /** @deprecated Use getVisualEffectsContribution */
        getConsciousnessContribution() {
          return this.getVisualEffectsContribution();
        }
        /** @deprecated Use setVisualEffectsLevel */
        setConsciousnessLevel(level) {
          return this.setVisualEffectsLevel(level);
        }
        /** @deprecated Use getVisualEffectsMetrics */
        getConsciousnessMetrics() {
          return this.getVisualEffectsMetrics();
        }
        /** @deprecated Use onVisualEffectsEvent */
        onChoreographyEvent(eventType, payload) {
          return this.onVisualEffectEvent(eventType, payload);
        }
      };
      __name(_DepthLayeredGradientSystem, "DepthLayeredGradientSystem");
      DepthLayeredGradientSystem = _DepthLayeredGradientSystem;
    }
  });

  // src-js/utils/graphics/ShaderLoader.ts
  var ShaderLoader_exports = {};
  __export(ShaderLoader_exports, {
    DEFAULT_VERTEX_SHADER: () => DEFAULT_VERTEX_SHADER,
    ShaderLoader: () => ShaderLoader,
    createGradientTexture: () => createGradientTexture
  });
  function createGradientTexture(gl, stops, width = 256) {
    try {
      if (!gl) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "WebGL context is null or undefined"
        );
        return null;
      }
      if (!stops || stops.length === 0) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Invalid or empty color stops array"
        );
        return null;
      }
      if (width <= 0 || width > 8192) {
        Y3KDebug?.debug?.error("ShaderLoader", `Invalid texture width: ${width}`);
        return null;
      }
      const glError = gl.getError();
      if (glError !== gl.NO_ERROR) {
        Y3KDebug?.debug?.warn(
          "ShaderLoader",
          `WebGL context has pending error: ${glError}`
        );
      }
      if (gl.isContextLost()) {
        Y3KDebug?.debug?.error("ShaderLoader", "WebGL context is lost");
        return null;
      }
      const canvas = document.createElement("canvas");
      if (!canvas) {
        Y3KDebug?.debug?.error("ShaderLoader", "Failed to create canvas element");
        return null;
      }
      canvas.width = width;
      canvas.height = 1;
      const ctx = canvas.getContext("2d", { willReadFrequently: false });
      if (!ctx) {
        Y3KDebug?.debug?.error("ShaderLoader", "Failed to get 2D canvas context");
        return null;
      }
      const validStops = stops.filter((stop) => {
        if (typeof stop.r !== "number" || typeof stop.g !== "number" || typeof stop.b !== "number" || typeof stop.a !== "number" || typeof stop.position !== "number") {
          Y3KDebug?.debug?.warn(
            "ShaderLoader",
            "Invalid color stop found, skipping"
          );
          return false;
        }
        if (stop.position < 0 || stop.position > 1) {
          Y3KDebug?.debug?.warn(
            "ShaderLoader",
            `Invalid color stop position: ${stop.position}, clamping`
          );
          stop.position = Math.max(0, Math.min(1, stop.position));
        }
        return true;
      });
      if (validStops.length === 0) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "No valid color stops after validation"
        );
        return null;
      }
      validStops.sort((a, b) => a.position - b.position);
      const gradient = ctx.createLinearGradient(0, 0, width, 0);
      if (!gradient) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Failed to create linear gradient"
        );
        return null;
      }
      try {
        validStops.forEach((stop, index) => {
          const r = Math.max(0, Math.min(255, Math.round(stop.r * 255)));
          const g = Math.max(0, Math.min(255, Math.round(stop.g * 255)));
          const b = Math.max(0, Math.min(255, Math.round(stop.b * 255)));
          const a = Math.max(0, Math.min(1, stop.a));
          const color3 = `rgba(${r}, ${g}, ${b}, ${a})`;
          gradient.addColorStop(stop.position, color3);
        });
      } catch (error) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Failed to add color stops to gradient:",
          error
        );
        return null;
      }
      try {
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, 1);
      } catch (error) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Failed to fill canvas with gradient:",
          error
        );
        return null;
      }
      const texture = gl.createTexture();
      if (!texture) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Failed to create WebGL texture - gl.createTexture() returned null"
        );
        return null;
      }
      try {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const bindError = gl.getError();
        if (bindError !== gl.NO_ERROR) {
          Y3KDebug?.debug?.error(
            "ShaderLoader",
            `WebGL error after texture binding: ${bindError}`
          );
          gl.deleteTexture(texture);
          return null;
        }
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          canvas
        );
        const uploadError = gl.getError();
        if (uploadError !== gl.NO_ERROR) {
          Y3KDebug?.debug?.error(
            "ShaderLoader",
            `WebGL error after texture upload: ${uploadError}`
          );
          gl.deleteTexture(texture);
          return null;
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        const paramError = gl.getError();
        if (paramError !== gl.NO_ERROR) {
          Y3KDebug?.debug?.error(
            "ShaderLoader",
            `WebGL error after setting texture parameters: ${paramError}`
          );
          gl.deleteTexture(texture);
          return null;
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
        Y3KDebug?.debug?.log(
          "ShaderLoader",
          `Gradient texture created successfully: ${width}x1, ${validStops.length} stops`
        );
        return texture;
      } catch (error) {
        Y3KDebug?.debug?.error(
          "ShaderLoader",
          "Exception during WebGL texture operations:",
          error
        );
        if (texture) {
          gl.deleteTexture(texture);
        }
        return null;
      }
    } catch (error) {
      Y3KDebug?.debug?.error(
        "ShaderLoader",
        `Gradient texture creation failed: ${error instanceof Error ? error.message : "Unknown error"}`
      );
      return null;
    }
  }
  var _ShaderLoader, ShaderLoader, DEFAULT_VERTEX_SHADER;
  var init_ShaderLoader = __esm({
    "src-js/utils/graphics/ShaderLoader.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _ShaderLoader = class _ShaderLoader {
        /**
         * Load and compile a fragment shader from source
         * @param gl WebGL2 rendering context
         * @param source GLSL fragment shader source code
         * @param cacheKey Optional cache key (defaults to hash of source)
         * @returns Compiled WebGL shader or null on failure
         */
        static loadFragment(gl, source, cacheKey) {
          const key = cacheKey || this.hashSource(source);
          const contextCache = this.getContextCache(gl);
          if (contextCache[key]) {
            return contextCache[key];
          }
          try {
            const shader = this.compileShader(gl, gl.FRAGMENT_SHADER, source);
            if (shader) {
              contextCache[key] = shader;
              Y3KDebug?.debug?.log(
                "ShaderLoader",
                `Fragment shader compiled: ${key.substring(0, 8)}...`
              );
            }
            return shader;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ShaderLoader",
              `Fragment shader compilation failed: ${error}`
            );
            return null;
          }
        }
        /**
         * Load and compile a vertex shader from source
         * @param gl WebGL2 rendering context
         * @param source GLSL vertex shader source code
         * @param cacheKey Optional cache key
         * @returns Compiled WebGL shader or null on failure
         */
        static loadVertex(gl, source, cacheKey) {
          const key = cacheKey || this.hashSource(source);
          const contextCache = this.getContextCache(gl);
          if (contextCache[key]) {
            return contextCache[key];
          }
          try {
            const shader = this.compileShader(gl, gl.VERTEX_SHADER, source);
            if (shader) {
              contextCache[key] = shader;
              Y3KDebug?.debug?.log(
                "ShaderLoader",
                `Vertex shader compiled: ${key.substring(0, 8)}...`
              );
            }
            return shader;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ShaderLoader",
              `Vertex shader compilation failed: ${error}`
            );
            return null;
          }
        }
        /**
         * Create a shader program from vertex and fragment shaders
         * @param gl WebGL2 rendering context
         * @param vertexShader Compiled vertex shader
         * @param fragmentShader Compiled fragment shader
         * @returns WebGL program or null on failure
         */
        static createProgram(gl, vertexShader, fragmentShader) {
          try {
            const program = gl.createProgram();
            if (!program) return null;
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
              const info = gl.getProgramInfoLog(program);
              gl.deleteProgram(program);
              throw new Error(`Program linking failed: ${info}`);
            }
            return program;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "ShaderLoader",
              `Program creation failed: ${error}`
            );
            return null;
          }
        }
        /**
         * Clear shader cache for a specific WebGL context
         * @param gl WebGL2 rendering context
         */
        static clearCache(gl) {
          const contextCache = this.cache.get(gl);
          if (contextCache) {
            Object.values(contextCache).forEach((shader) => {
              gl.deleteShader(shader);
            });
            this.cache.delete(gl);
          }
        }
        /**
         * Clear all shader caches (use on theme hot-reload)
         */
        static clearAllCaches() {
          this.cache.clear();
        }
        static compileShader(gl, type, source) {
          const shader = gl.createShader(type);
          if (!shader) return null;
          gl.shaderSource(shader, source);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            const info = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error(`Shader compilation failed: ${info}`);
          }
          return shader;
        }
        /**
         * Clear shader cache for a specific WebGL context
         * This should be called when the WebGL context is lost to prevent
         * reusing invalid shader objects after context restoration
         */
        static clearContextCache(gl) {
          if (this.cache.has(gl)) {
            const contextCache = this.cache.get(gl);
            Object.values(contextCache).forEach((shader) => {
              if (shader && gl && !gl.isContextLost()) {
                try {
                  gl.deleteShader(shader);
                } catch (e) {
                }
              }
            });
            this.cache.set(gl, {});
            Y3KDebug?.debug?.log(
              "ShaderLoader",
              "Context cache cleared due to WebGL context loss/restore"
            );
          }
        }
        static getContextCache(gl) {
          if (!this.cache.has(gl)) {
            this.cache.set(gl, {});
          }
          return this.cache.get(gl);
        }
        static hashSource(source) {
          let hash = 0;
          for (let i = 0; i < source.length; i++) {
            const char = source.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
          }
          return hash.toString(16);
        }
      };
      __name(_ShaderLoader, "ShaderLoader");
      _ShaderLoader.cache = /* @__PURE__ */ new Map();
      ShaderLoader = _ShaderLoader;
      DEFAULT_VERTEX_SHADER = `#version 300 es
precision mediump float;

in vec2 a_position;
out vec2 v_uv;

void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;
      __name(createGradientTexture, "createGradientTexture");
    }
  });

  // src-js/visual/effects/ConsolidatedShaderLibrary.ts
  var STANDARD_VISUAL_EFFECTS_VERTEX_SHADER, SHARED_NOISE_FUNCTIONS, VISUAL_EFFECTS_MODULATION_FUNCTIONS, CORRIDOR_SDF_FUNCTIONS, STANDARD_VISUAL_EFFECTS_UNIFORMS, _ShaderTemplate, ShaderTemplate, _ShaderLogicPatterns, ShaderLogicPatterns, _AdvancedShaderLibrary, AdvancedShaderLibrary, _ShaderOptimizationUtils, ShaderOptimizationUtils, VISUAL_EFFECTS_SHADER_LIBRARY;
  var init_ConsolidatedShaderLibrary = __esm({
    "src-js/visual/effects/ConsolidatedShaderLibrary.ts"() {
      "use strict";
      STANDARD_VISUAL_EFFECTS_VERTEX_SHADER = `#version 300 es
in vec2 a_position;
void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;
      SHARED_NOISE_FUNCTIONS = `
// Shared simplex noise implementation for visual effects
vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
  vec2 i = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);
  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod289(i);
  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m;
  m = m*m;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
  vec3 g;
  g.x = a0.x * x0.x + h.x * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}`;
      VISUAL_EFFECTS_MODULATION_FUNCTIONS = `
// Enhanced visualEffects-aware animation effect with multi-phase patterns
float visualEffectsPulsing(float time, float phase, float intensity) {
  return sin(time * 0.05 + phase) * intensity;
}

// Deep visualEffects animation with emotional resonance
float deepVisualEffectsPulsing(float time, float phase, float emotionalIntensity) {
  float primaryBreath = sin(time * 0.04 + phase) * 0.6;
  float secondaryBreath = sin(time * 0.07 + phase * 1.3) * 0.3;
  float emotionalBreath = sin(time * 0.02 + phase * 0.7) * 0.2;
  return (primaryBreath + secondaryBreath + emotionalBreath) * emotionalIntensity;
}

// Rhythmic pulse modulation from visualEffects field
float rhythmicPulseModulation(float baseValue, float rhythmicPulse, float intensity) {
  return baseValue * (1.0 + rhythmicPulse * intensity);
}

// Musical flow direction calculation
vec2 calculateMusicalFlow(vec2 baseDirection, vec2 musicFlow, float sensitivity) {
  return baseDirection + musicFlow * sensitivity;
}

// Energy resonance modulation
float energyResonanceModulation(float baseValue, float energyResonance, float minMult, float maxMult) {
  return baseValue * (minMult + energyResonance * (maxMult - minMult));
}

// Surface fluidity effect
float surfaceFluidityEffect(float value, float fluidityIndex) {
  return mix(value, value * 1.2, fluidityIndex);
}

// === ADVANCED VISUAL_EFFECTS FIELD PATTERNS ===

// Multi-dimensional visualEffects field intensity calculation
float visualEffectsFieldIntensity(vec2 position, float time, float musicEnergy) {
  // Primary visualEffects wave
  float primaryField = snoise(position * 2.0 + time * 0.1) * 0.6;
  
  // Secondary awareness resonance
  float secondaryField = snoise(position * 4.0 + time * 0.05) * 0.3;
  
  // Musical visualEffects enhancement
  float musicalField = snoise(position * 6.0 + time * 0.15) * 0.2;
  
  // Combine visualEffects layers
  float combinedField = primaryField + secondaryField + (musicalField * musicEnergy);
  return clamp(combinedField * 0.5 + 0.5, 0.0, 1.0);
}

// Multi-dimensional awareness patterns for color modulation
vec3 awarenessResonance(vec3 baseColor, float visualEffectsLevel, float musicIntensity) {
  // VisualEffects-aware color temperature shift
  float temperatureShift = visualEffectsLevel * 0.3;
  vec3 warmShift = vec3(1.0 + temperatureShift, 1.0 + temperatureShift * 0.5, 1.0);
  vec3 coolShift = vec3(1.0, 1.0 + temperatureShift * 0.3, 1.0 + temperatureShift);
  
  // Musical intensity affects color saturation
  float saturationBoost = 1.0 + musicIntensity * 0.4;
  
  // Apply visualEffects-aware color modulation
  vec3 temperatureColor = mix(coolShift, warmShift, visualEffectsLevel);
  return baseColor * temperatureColor * saturationBoost;
}

// Temporal flow patterns for Year 3000 streaming effects
vec2 temporalFlowDirection(vec2 position, float time, vec2 musicFlow) {
  // Primary temporal stream
  vec2 primaryFlow = vec2(
    sin(time * 0.08 + position.x * 3.0),
    cos(time * 0.06 + position.y * 2.5)
  ) * 0.02;
  
  // Secondary visualEffects flow
  vec2 visualEffectsFlow = vec2(
    sin(time * 0.05 + position.y * 4.0),
    cos(time * 0.04 + position.x * 3.5)
  ) * 0.015;
  
  // Musical synchronization flow
  vec2 musicalSync = musicFlow * 0.01;
  
  return primaryFlow + visualEffectsFlow + musicalSync;
}

// Surface visualEffects dynamics for smooth boundaries
float surfaceVisualEffectsFlow(vec2 position, float fluidityIndex, float awarenessLevel) {
  // Base surface oscillation
  float surfaceBase = sin(position.x * 8.0 + position.y * 6.0) * 0.1;
  
  // VisualEffects-driven surface flexibility
  float visualEffectsFlex = awarenessLevel * fluidityIndex * 0.2;
  
  // Smooth surface animation
  float surfaceBreath = sin(position.x * 3.0 + position.y * 4.0) * 0.05;
  
  return surfaceBase + visualEffectsFlex + surfaceBreath;
}

// Advanced visualEffects animation patterns
float visualEffectsMemoryPulsing(float time, float phase, float memoryIntensity) {
  // Primary visualEffects rhythm
  float primaryRhythm = sin(time * 0.03 + phase) * 0.5;
  
  // Memory echo patterns
  float memoryEcho = sin(time * 0.08 + phase * 1.7) * 0.3 * memoryIntensity;
  
  // Deep awareness pulse
  float awarenessePulse = sin(time * 0.015 + phase * 0.5) * 0.2;
  
  return primaryRhythm + memoryEcho + awarenessePulse;
}`;
      CORRIDOR_SDF_FUNCTIONS = `
// Convert screen coordinates to polar coordinates for radial flow
vec2 toPolar(vec2 uv) {
  vec2 centered = uv - 0.5;
  float angle = atan(centered.y, centered.x);
  float radius = length(centered);
  return vec2(angle, radius);
}

// Convert polar coordinates back to cartesian
vec2 fromPolar(vec2 polar) {
  float angle = polar.x;
  float radius = polar.y;
  return vec2(cos(angle) * radius, sin(angle) * radius) + 0.5;
}

// Signed distance field for a circle
float circleSDF(vec2 uv, vec2 center, float radius) {
  return length(uv - center) - radius;
}

// Smooth minimum for blending SDFs
float smin(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

// Enhanced multiple bubble corridors with smooth visualEffects-aware animations
float bubbleCorridors(vec2 uv, float time, float intensity) {
  // ===== ENHANCED PRIMARY BUBBLE APERTURES =====
  // Create 6 main circular apertures arranged in a ring with dynamic bubble count
  float baseBubbleCount = 6.0;
  float dynamicBubbleCount = baseBubbleCount + floor(intensity * 2.0); // 6-8 bubbles based on intensity
  float ringRadius = 0.28 + sin(time * 0.15) * 0.08; // Pulsing ring radius (0.20-0.36)
  
  float minBubbleDistance = 2.0; // Track closest bubble distance
  
  // Calculate distance to each bubble position with enhanced smooth movement
  for(float i = 0.0; i < dynamicBubbleCount; i += 1.0) {
    // Enhanced smooth rotation with animation rhythm
    float bubbleAngle = (i / dynamicBubbleCount) * 2.0 * 3.14159 + time * 0.08;
    
    // Add smooth spiral motion for visualEffects effect
    float spiralOffset = sin(time * 0.25 + i * 0.6) * 0.15;
    float dynamicRingRadius = ringRadius + spiralOffset;
    
    // Bubble center position with enhanced smooth movement
    vec2 bubbleCenter = vec2(0.5) + vec2(
      cos(bubbleAngle) * dynamicRingRadius,
      sin(bubbleAngle) * dynamicRingRadius
    );
    
    // Enhanced animation/pulsing animation with multi-frequency modulation
    float animationPhase = sin(time * 0.6 + i * 0.8) * 0.04;
    float smoothPhase = sin(time * 0.35 + i * 1.2) * 0.03;
    float visualEffectsPhase = sin(time * 0.18 + i * 0.5) * 0.025;
    
    vec2 smoothMovement = vec2(
      sin(time * 0.3 + i * 0.7) * (animationPhase + smoothPhase),
      cos(time * 0.4 + i * 0.9) * (animationPhase + visualEffectsPhase)
    );
    
    vec2 animatedCenter = bubbleCenter + smoothMovement;
    
    // Calculate distance from current pixel to this bubble center
    float distanceToBubble = length(uv - animatedCenter);
    minBubbleDistance = min(minBubbleDistance, distanceToBubble);
  }
  
  // ===== ENHANCED BUBBLE APERTURE SIZING =====
  // Enhanced bubble size with multi-wave expansion patterns
  float baseBubbleSize = 0.08 * intensity;
  float primaryPulse = sin(time * 1.5) * 0.35;
  float smoothPulse = sin(time * 0.8) * 0.25;
  float visualEffectsPulse = sin(time * 2.2) * 0.15;
  
  float expandedBubbleSize = baseBubbleSize * (1.0 + primaryPulse + smoothPulse + visualEffectsPulse);
  
  // Create clean circular apertures with enhanced soft edges
  float primaryBubbleMask = 1.0 - smoothstep(expandedBubbleSize * 0.6, expandedBubbleSize * 1.1, minBubbleDistance);
  
  // ===== ENHANCED SECONDARY BUBBLE LAYER =====
  // Add smaller secondary bubbles with smooth movement
  float secondaryBubbleCount = 4.0 + floor(intensity * 1.0); // 4-5 secondary bubbles
  float baseSecondaryRadius = 0.15;
  float secondaryRingRadius = baseSecondaryRadius * (1.0 + sin(time * 0.12) * 0.3);
  float minSecondaryDistance = 2.0;
  
  for(float i = 0.0; i < secondaryBubbleCount; i += 1.0) {
    // Counter-rotating secondary bubbles with smooth offset
    float secondaryAngle = (i / secondaryBubbleCount) * 2.0 * 3.14159 - time * 0.15 + 1.57;
    
    // Add smooth wobble to secondary bubble positions
    float wobbleX = sin(time * 0.45 + i * 1.1) * 0.02;
    float wobbleY = cos(time * 0.55 + i * 0.8) * 0.02;
    
    vec2 secondaryCenter = vec2(0.5) + vec2(
      cos(secondaryAngle) * secondaryRingRadius + wobbleX,
      sin(secondaryAngle) * secondaryRingRadius + wobbleY
    );
    
    float distanceToSecondary = length(uv - secondaryCenter);
    minSecondaryDistance = min(minSecondaryDistance, distanceToSecondary);
  }
  
  float secondaryBubbleSize = baseBubbleSize * 0.5 * (1.0 + sin(time * 1.8) * 0.3);
  float secondaryBubbleMask = 1.0 - smoothstep(secondaryBubbleSize * 0.6, secondaryBubbleSize * 1.0, minSecondaryDistance);
  secondaryBubbleMask *= 0.75; // Make secondary bubbles dimmer for depth
  
  // ===== ENHANCED CENTER SPOTLIGHT BUBBLE =====
  // Enhanced central bubble with complex pulsing patterns
  float centerDistance = length(uv - vec2(0.5));
  float centerPrimaryPulse = sin(time * 2.0) * 0.4;
  float centerSecondaryPulse = sin(time * 3.5) * 0.2;
  float centerPulsingPulse = sin(time * 0.6) * 0.3;
  
  float centerBubbleSize = 0.06 * intensity * (1.0 + centerPrimaryPulse + centerSecondaryPulse + centerPulsingPulse);
  float centerBubbleMask = 1.0 - smoothstep(centerBubbleSize * 0.4, centerBubbleSize * 0.9, centerDistance);
  
  // ===== ENHANCED COMBINATION AND BLENDING =====
  // Use smooth maximum for smooth blending instead of hard max
  float corridorMask = primaryBubbleMask;
  corridorMask = max(corridorMask, secondaryBubbleMask * 0.9);
  corridorMask = max(corridorMask, centerBubbleMask * 1.1); // Center bubble slightly stronger
  
  // Enhanced radial falloff with smooth variation
  vec2 center = uv - vec2(0.5);
  float radialDistance = length(center);
  float smoothVariation = sin(time * 0.3 + radialDistance * 8.0) * 0.05;
  float radialFalloff = 1.0 - smoothstep(0.0, 0.65 + smoothVariation, radialDistance);
  corridorMask *= radialFalloff;
  
  // Enhanced smooth animation pattern with visualEffects harmonics
  float primaryPulsing = sin(time * 0.4) * 0.15;
  float secondaryPulsing = sin(time * 0.25) * 0.08;
  float visualEffectsPulsing = sin(time * 0.6) * 0.05;
  float animationCycle = 0.85 + primaryPulsing + secondaryPulsing + visualEffectsPulsing;
  corridorMask *= animationCycle;
  
  // Add subtle noise variation for smooth visualEffects texture
  float noisePattern = sin(radialDistance * 12.0 + time * 0.5) * cos(radialDistance * 8.0 - time * 0.3) * 0.03;
  corridorMask += noisePattern * intensity * 0.5;
  
  return clamp(corridorMask, 0.0, 1.0);
}

// Perspective depth calculation for inward flow
float calculatePerspectiveDepth(vec2 uv, float time, float flowStrength) {
  vec2 polar = toPolar(uv);
  float radius = polar.y;
  
  // Create perspective tunnel effect
  float depth = 1.0 - radius;
  depth = pow(depth, 2.2); // Gamma correction for natural falloff
  
  // Add inward flow animation
  float flowPhase = time * flowStrength + radius * 8.0;
  depth += sin(flowPhase) * 0.05 * (1.0 - radius);
  
  return clamp(depth, 0.0, 1.0);
}

// Dynamic aperture sizing based on music response
float musicResponsiveAperture(float baseMask, float beatIntensity, float bassResponse) {
  // Beat response expands apertures
  float beatExpansion = 1.0 + beatIntensity * 0.3;
  
  // Bass response adds pulsing
  float bassPulse = sin(bassResponse * 10.0) * 0.1;
  
  // Apply modulations
  float responsiveMask = baseMask * beatExpansion + bassPulse;
  
  return clamp(responsiveMask, 0.0, 1.0);
}

// ===================================================================
// DUNGEON CORRIDOR TUNNEL FUNCTIONS
// ===================================================================

// Signed distance field for rounded rectangle (corridor tunnel shape)
float roundedRectangleSDF(vec2 uv, vec2 center, vec2 size, float radius) {
  vec2 d = abs(uv - center) - size;
  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius;
}

// Apply perspective transformation for 3D tunnel illusion
vec2 perspectiveTunnelTransform(vec2 uv, float depth, float focalLength) {
  // Transform to centered coordinates
  vec2 centered = uv - 0.5;
  
  // Apply perspective projection with vanishing point at center
  float perspectiveFactor = focalLength / (focalLength + depth);
  vec2 perspective = centered * perspectiveFactor;
  
  // Return to UV space
  return perspective + 0.5;
}

// Calculate surface normal from SDF for lighting
vec2 tunnelNormalFromSDF(vec2 uv, vec2 center, vec2 size, float radius) {
  const float epsilon = 0.001;
  
  float centerSDF = roundedRectangleSDF(uv, center, size, radius);
  float rightSDF = roundedRectangleSDF(uv + vec2(epsilon, 0.0), center, size, radius);
  float upSDF = roundedRectangleSDF(uv + vec2(0.0, epsilon), center, size, radius);
  
  return normalize(vec2(rightSDF - centerSDF, upSDF - centerSDF));
}

// Advanced lighting system for dungeon corridors
vec3 calculateTunnelLighting(vec2 uv, float tunnelMask, vec2 normal, float depth, float time, float intensity) {
  // ===== AMBIENT SHADOW LAYER =====
  // Create dark base for corridor walls
  float ambientShadow = 0.15; // Base darkness level
  vec3 shadowColor = vec3(0.05, 0.08, 0.12); // Cool blue-gray shadows
  
  // ===== EDGE HIGHLIGHT LAYER =====
  // Bright rim lighting along corridor edges using surface normals
  float edgeIntensity = 1.0 - smoothstep(0.0, 0.3, tunnelMask);
  float edgeHighlight = pow(edgeIntensity, 2.0) * 0.8;
  
  // Edge lighting color shifts with music (warmer for high energy)
  vec3 edgeLightColor = mix(
    vec3(0.4, 0.5, 0.8), // Cool blue edge light
    vec3(0.8, 0.6, 0.3), // Warm orange edge light
    intensity * 0.7
  );
  
  // ===== END LIGHT SOURCE =====
  // Dynamic light at tunnel end that pulses with music
  float distanceFromCenter = length(uv - vec2(0.5));
  float endLightFalloff = 1.0 / (1.0 + distanceFromCenter * 4.0); // Inverse square falloff
  
  // Music-responsive light intensity with animation effect
  float lightPulse = sin(time * 2.0) * 0.3 + 0.7;
  float endLightIntensity = intensity * lightPulse * endLightFalloff;
  
  // End light color temperature (cooler when distant, warmer when close)
  vec3 endLightColor = mix(
    vec3(0.3, 0.4, 0.9), // Cool distant light
    vec3(0.9, 0.7, 0.4), // Warm close light  
    endLightIntensity
  );
  
  // ===== FRESNEL EFFECT =====
  // Edge lighting intensity based on viewing angle
  vec2 viewDirection = normalize(uv - vec2(0.5));
  float fresnel = pow(1.0 - abs(dot(normal, viewDirection)), 2.0);
  
  // ===== COMBINE LIGHTING LAYERS =====
  vec3 ambientLayer = shadowColor * ambientShadow;
  vec3 edgeLayer = edgeLightColor * edgeHighlight * fresnel;
  vec3 endLayer = endLightColor * endLightIntensity * tunnelMask;
  
  // Apply depth-based attenuation
  float depthAttenuation = 1.0 - smoothstep(0.0, 1.0, depth);
  
  return (ambientLayer + edgeLayer + endLayer) * depthAttenuation;
}

// Create multiple dungeon corridor tunnels with realistic lighting
float dungeonCorridorTunnels(vec2 uv, float time, float intensity) {
  // ===== MAIN CORRIDOR TUNNELS =====
  float corridorCount = 4.0;
  float minCorridorDistance = 2.0;
  
  for(float i = 0.0; i < corridorCount; i += 1.0) {
    float corridorAngle = (i / corridorCount) * 2.0 * 3.14159 + time * 0.05;
    
    // Corridor center position with slight offset for smooth feel
    vec2 corridorOffset = vec2(
      cos(corridorAngle) * 0.25,
      sin(corridorAngle) * 0.25
    );
    vec2 corridorCenter = vec2(0.5) + corridorOffset;
    
    // Apply perspective transformation for depth illusion
    float depth = 0.3 + sin(time * 0.3 + i) * 0.1;
    vec2 perspectiveUV = perspectiveTunnelTransform(uv, depth, 2.0);
    
    // Create elongated corridor tunnel shape
    vec2 corridorSize = vec2(0.15, 0.04) * (1.0 + intensity * 0.3); // Width varies with music
    float cornerRadius = 0.01;
    
    // Calculate distance to this corridor tunnel
    float corridorDistance = roundedRectangleSDF(perspectiveUV, corridorCenter, corridorSize, cornerRadius);
    minCorridorDistance = min(minCorridorDistance, corridorDistance);
  }
  
  // ===== SECONDARY TUNNEL LAYER =====
  // Add smaller secondary tunnels for depth complexity
  float secondaryCount = 2.0;
  float minSecondaryDistance = 2.0;
  
  for(float i = 0.0; i < secondaryCount; i += 1.0) {
    float secondaryAngle = (i / secondaryCount) * 2.0 * 3.14159 + time * 0.08 + 1.57;
    
    vec2 secondaryOffset = vec2(
      cos(secondaryAngle) * 0.15,
      sin(secondaryAngle) * 0.15  
    );
    vec2 secondaryCenter = vec2(0.5) + secondaryOffset;
    
    // Deeper perspective for secondary tunnels
    float secondaryDepth = 0.5 + sin(time * 0.2 + i) * 0.1;
    vec2 secondaryPerspectiveUV = perspectiveTunnelTransform(uv, secondaryDepth, 2.5);
    
    vec2 secondarySize = vec2(0.08, 0.025) * (1.0 + intensity * 0.2);
    float secondaryDistance = roundedRectangleSDF(secondaryPerspectiveUV, secondaryCenter, secondarySize, 0.005);
    minSecondaryDistance = min(minSecondaryDistance, secondaryDistance);
  }
  
  // ===== COMBINE TUNNEL LAYERS =====
  float primaryMask = 1.0 - smoothstep(0.0, 0.02, minCorridorDistance);
  float secondaryMask = 1.0 - smoothstep(0.0, 0.015, minSecondaryDistance);
  secondaryMask *= 0.7; // Dimmer secondary tunnels
  
  float combinedMask = max(primaryMask, secondaryMask);
  
  // ===== RADIAL FALLOFF FOR FOCUS =====
  vec2 center = uv - vec2(0.5);
  float radialDistance = length(center);
  float radialFalloff = 1.0 - smoothstep(0.2, 0.8, radialDistance);
  
  // ===== ORGANIC BREATHING PATTERN =====
  float animationCycle = 0.9 + sin(time * 0.4) * 0.1;
  
  return clamp(combinedMask * radialFalloff * animationCycle, 0.0, 1.0);
}

// Enhanced corridor gradient reveal with advanced dual-layer blending
vec4 corridorGradientReveal(vec2 uv, sampler2D gradientTex, float corridorMask, float time, float intensity) {
  // ===== ENHANCED BASE LAYER: Musical flow with visualEffects awareness =====
  vec2 baseFlowUV = uv;
  vec2 flowDirection = normalize(vec2(1.0, 0.0));
  
  // Enhanced musical flow with multi-frequency modulation
  #ifdef HAS_FLOW_UNIFORMS
    flowDirection = normalize(u_musicalFlow.xy + vec2(0.001, 0.0));
  #endif
  
  // Multi-layered flow animation with visualEffects patterns
  float primaryFlow = sin(time * 0.1) * 0.02;
  float smoothFlow = sin(time * 0.07) * 0.015;
  float visualEffectsFlow = sin(time * 0.13) * 0.008;
  
  baseFlowUV += flowDirection * (primaryFlow + smoothFlow + visualEffectsFlow);
  vec4 baseGradient = texture(gradientTex, vec2(baseFlowUV.x, 0.5));
  
  // Enhanced base layer with depth awareness
  vec2 polar = toPolar(uv);
  float baseDepthModulation = 1.0 + polar.y * 0.2; // Subtle depth variation
  baseGradient.rgb *= baseDepthModulation;
  
  // ===== ENHANCED CORRIDOR LAYER: Multi-dimensional inward flow =====
  float angle = polar.x;
  float radius = polar.y;
  
  // Advanced inward flow with multi-phase animation
  float primaryInwardPhase = time * 0.15 + radius * 6.0;
  float secondaryInwardPhase = time * 0.08 + radius * 4.5;
  float visualEffectsInwardPhase = time * 0.22 + radius * 8.0;
  
  // Multi-layered inward flow combining multiple patterns
  float primaryInwardFlow = radius - (sin(primaryInwardPhase) * 0.1);
  float secondaryInwardFlow = radius - (cos(secondaryInwardPhase) * 0.06);
  float visualEffectsInwardFlow = radius - (sin(visualEffectsInwardPhase) * 0.04);
  
  float combinedInwardFlow = mix(
    mix(primaryInwardFlow, secondaryInwardFlow, 0.3),
    visualEffectsInwardFlow, 0.2
  );
  
  // Enhanced gradient sampling with dual-layer coordination
  vec2 corridorFlowUV = vec2(
    fract(angle / (2.0 * 3.14159) + time * 0.02), // Slow rotation for smooth feel
    clamp(combinedInwardFlow, 0.0, 1.0)
  );
  vec4 corridorGradient = texture(gradientTex, corridorFlowUV);
  
  // ===== ADVANCED DEPTH AND PERSPECTIVE =====
  float depth = calculatePerspectiveDepth(uv, time, intensity);
  
  // Enhanced tunnel brightness with smooth variation
  float smoothBrightnessVariation = sin(angle * 3.0 + time * 0.3) * 0.1;
  float tunnelBrightness = 1.0 + depth * 0.9 + smoothBrightnessVariation;
  corridorGradient.rgb *= tunnelBrightness;
  
  // Advanced color shift with visualEffects-aware color temperature
  vec3 warmShift = vec3(1.15, 1.05, 0.85); // Warm center
  vec3 coolShift = vec3(0.9, 1.0, 1.1);    // Cool edges
  vec3 colorTemperature = mix(coolShift, warmShift, depth);
  corridorGradient.rgb = mix(corridorGradient.rgb, corridorGradient.rgb * colorTemperature, depth * 0.4);
  
  // ===== ENHANCED DUAL-LAYER BLENDING =====
  // Multi-stage aperture masking for smooth blending
  float softApertureMask = smoothstep(0.2, 0.8, corridorMask);
  float sharpApertureMask = smoothstep(0.4, 0.6, corridorMask);
  float smoothApertureMask = mix(softApertureMask, sharpApertureMask, 0.6);
  
  // Enhanced blending with visualEffects-aware mixing
  float visualEffectsBlendFactor = 0.7 + sin(time * 0.4 + radius * 4.0) * 0.2;
  float dynamicIntensity = intensity * visualEffectsBlendFactor;
  
  // Primary blend: base and corridor layers
  vec4 primaryBlend = mix(baseGradient, corridorGradient, smoothApertureMask * dynamicIntensity);
  
  // ===== ADVANCED APERTURE EFFECTS =====
  // Enhanced rim lighting with smooth variation 
  float rimLightBase = corridorMask * (1.0 - smoothApertureMask);
  float rimLightVariation = sin(angle * 4.0 + time * 0.5) * 0.3 + 0.7;
  float enhancedRimLight = rimLightBase * rimLightVariation * 0.6;
  
  // Aperture glow effect for depth illusion
  float apertureGlow = softApertureMask * (1.0 - sharpApertureMask) * 0.4;
  vec3 glowColor = corridorGradient.rgb * 1.2;
  
  // ===== VISUAL_EFFECTS-AWARE COLOR HARMONIZATION =====
  // Harmonize colors between layers for smooth visualEffects effect
  vec3 harmonizedColor = mix(
    primaryBlend.rgb,
    (primaryBlend.rgb + corridorGradient.rgb) * 0.5,
    smoothApertureMask * 0.3
  );
  
  // Final composition with enhanced rim and glow effects
  vec4 finalColor = vec4(harmonizedColor, primaryBlend.a);
  finalColor.rgb += vec3(enhancedRimLight) * dynamicIntensity;
  finalColor.rgb += glowColor * apertureGlow * dynamicIntensity;
  
  // Smooth animation effect for visualEffects integration
  float animationCycle = 0.95 + sin(time * 0.3) * 0.05;
  finalColor.rgb *= animationCycle;
  
  return finalColor;
}

// Advanced dungeon corridor gradient reveal with realistic lighting
vec4 dungeonCorridorGradientReveal(vec2 uv, sampler2D gradientTex, float corridorMask, float time, float intensity) {
  // ===== BASE LAYER: Dark stone/metal corridor walls =====
  vec4 baseWallColor = vec4(0.1, 0.12, 0.15, 1.0); // Dark stone base
  
  // ===== CORRIDOR TUNNEL CALCULATION =====
  // Use dungeon corridor tunnels instead of simple bubbles
  float tunnelMask = dungeonCorridorTunnels(uv, time, intensity);
  
  // ===== LIGHTING CALCULATION =====
  // Calculate lighting for tunnel areas
  vec2 tunnelCenter = vec2(0.5); // Simplified center for normal calculation
  vec2 tunnelSize = vec2(0.15, 0.04);
  vec2 surfaceNormal = tunnelNormalFromSDF(uv, tunnelCenter, tunnelSize, 0.01);
  
  float depth = length(uv - vec2(0.5)) * 0.5; // Distance-based depth
  vec3 tunnelLighting = calculateTunnelLighting(uv, tunnelMask, surfaceNormal, depth, time, intensity);
  
  // ===== CORRIDOR LAYER: Inward flowing magical light =====
  // Convert to polar coordinates for inward flow calculation
  vec2 polar = toPolar(uv);
  float angle = polar.x;
  float radius = polar.y;
  
  // Create magical inward flow animation - light streams toward center
  float magicalFlowPhase = time * 0.2 + radius * 8.0; // Faster flow for magical effect
  float inwardFlow = radius - (sin(magicalFlowPhase) * 0.15); // More dramatic flow
  
  // Sample gradient using inward flow for magical light colors
  vec2 corridorFlowUV = vec2(
    angle / (2.0 * 3.14159), // Normalize angle for gradient sampling
    clamp(inwardFlow, 0.0, 1.0) // Use inward flow for magical color variation
  );
  vec4 magicalLightGradient = texture(gradientTex, corridorFlowUV);
  
  // ===== ENHANCE MAGICAL LIGHT WITH MUSIC RESPONSIVENESS =====
  // Enhance magical light colors based on music intensity
  magicalLightGradient.rgb *= 1.5 + intensity * 0.8; // Brighter with music
  
  // Add magical shimmer effect
  float shimmerPhase = time * 4.0 + uv.x * 10.0 + uv.y * 8.0;
  float shimmer = sin(shimmerPhase) * 0.1 + 0.9;
  magicalLightGradient.rgb *= shimmer;
  
  // ===== DEPTH AND PERSPECTIVE EFFECTS =====
  float perspectiveDepth = calculatePerspectiveDepth(uv, time, intensity * 1.2);
  
  // Enhance magical light with depth - brighter toward tunnel end
  float tunnelEndBrightness = 1.0 + perspectiveDepth * 1.5;
  magicalLightGradient.rgb *= tunnelEndBrightness;
  
  // ===== CORRIDOR WALL TEXTURING =====
  // Add stone/metal texture to walls using noise-like patterns
  float wallTexturePhase = uv.x * 20.0 + uv.y * 15.0;
  float wallTexture = sin(wallTexturePhase) * 0.1 + 0.9;
  baseWallColor.rgb *= wallTexture;
  
  // ===== ADVANCED APERTURE BLENDING =====
  // Smooth tunnel aperture with realistic falloff
  float apertureMask = smoothstep(0.1, 0.8, tunnelMask);
  
  // ===== LIGHTING INTEGRATION =====
  // Apply calculated lighting to both wall and magical light
  vec4 litWallColor = baseWallColor;
  litWallColor.rgb += tunnelLighting; // Add ambient shadows, edge highlights, end illumination
  
  // Blend wall color with magical light streaming through tunnels
  vec4 finalColor = mix(litWallColor, magicalLightGradient, apertureMask * intensity);
  
  // ===== RIM LIGHTING FOR DEPTH ILLUSION =====
  // Enhanced rim lighting around tunnel apertures
  float rimIntensity = tunnelMask * (1.0 - apertureMask) * 0.8;
  vec3 rimColor = mix(
    vec3(0.3, 0.4, 0.8), // Cool rim light
    vec3(0.8, 0.5, 0.2), // Warm rim light
    intensity
  );
  finalColor.rgb += rimColor * rimIntensity;
  
  // ===== ATMOSPHERIC PERSPECTIVE =====
  // Add slight fog/haze effect for distance illusion
  float atmosphericHaze = depth * 0.2;
  vec3 hazeColor = vec3(0.15, 0.18, 0.25);
  finalColor.rgb = mix(finalColor.rgb, hazeColor, atmosphericHaze);
  
  return finalColor;
}`;
      STANDARD_VISUAL_EFFECTS_UNIFORMS = `
// Time and resolution (universal)
uniform float u_time;
uniform vec2 u_resolution;

// Enhanced visualEffects field uniforms
uniform float u_rhythmicPulse;
uniform vec2 u_musicalFlow;
uniform float u_energyResonance;
uniform float u_animationCycle;
uniform float u_surfaceFluidityIndex;

// Advanced visualEffects control uniforms
uniform float u_visualEffectsLevel;        // 0-1 current visualEffects intensity
uniform float u_awarenessLevel;           // 0-1 current awareness depth
uniform float u_emotionalIntensity;       // 0-1 emotional resonance strength
uniform float u_memoryIntensity;          // 0-1 visualEffects memory patterns
uniform vec2 u_temporalFlowDirection;     // Year 3000 temporal stream direction
uniform float u_visualEffectsTemperature; // Color temperature shift from visualEffects

// Enhanced music sync uniforms
uniform float u_musicEnergy;
uniform float u_musicValence;
uniform float u_beatIntensity;
uniform float u_bassResponse;
uniform float u_musicalVisualEffectsSync; // Music-visualEffects synchronization level
uniform float u_genreVisualEffectsShift;  // Genre-specific visualEffects adjustments

// Corridor-specific uniforms
uniform float u_corridorIntensity;
uniform float u_corridorFlowStrength;
uniform float u_corridorDepthEffect;
uniform float u_corridorBubbleScale;

// Dungeon corridor uniforms
uniform float u_dungeonEnabled;
uniform float u_tunnelWidth;
uniform float u_lightingIntensity;
uniform float u_atmosphericHaze;
uniform vec3 u_wallColor;`;
      _ShaderTemplate = class _ShaderTemplate {
        /**
         * Build a complete fragment shader from components
         */
        static buildFragmentShader(options) {
          const {
            precision = "precision mediump float;",
            additionalUniforms = "",
            additionalFunctions = "",
            mainShaderLogic,
            includeNoiseFunctions = true,
            includeVisualEffectsFunctions = true,
            includeCorridorFunctions = false
          } = options;
          let shader = `#version 300 es
${precision}

`;
          shader += STANDARD_VISUAL_EFFECTS_UNIFORMS + "\n\n";
          if (additionalUniforms) {
            shader += additionalUniforms + "\n\n";
          }
          shader += "out vec4 fragColor;\n\n";
          if (includeNoiseFunctions) {
            shader += SHARED_NOISE_FUNCTIONS + "\n\n";
          }
          if (includeVisualEffectsFunctions) {
            shader += VISUAL_EFFECTS_MODULATION_FUNCTIONS + "\n\n";
          }
          if (includeCorridorFunctions) {
            shader += CORRIDOR_SDF_FUNCTIONS + "\n\n";
          }
          if (additionalFunctions) {
            shader += additionalFunctions + "\n\n";
          }
          shader += "void main() {\n";
          shader += "  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n\n";
          shader += mainShaderLogic;
          shader += "\n}";
          return shader;
        }
        /**
         * Generate enhanced standard uniform names list for visualEffects systems
         */
        static getStandardUniformNames() {
          return [
            "u_time",
            "u_resolution",
            "u_rhythmicPulse",
            "u_musicalFlow",
            "u_energyResonance",
            "u_animationCycle",
            "u_surfaceFluidityIndex",
            "u_visualEffectsLevel",
            "u_awarenessLevel",
            "u_emotionalIntensity",
            "u_memoryIntensity",
            "u_temporalFlowDirection",
            "u_visualEffectsTemperature",
            "u_musicEnergy",
            "u_musicValence",
            "u_beatIntensity",
            "u_bassResponse",
            "u_musicalVisualEffectsSync",
            "u_genreVisualEffectsShift"
          ];
        }
        /**
         * Generate WebGL-specific uniform names (for WebGL system)
         */
        static getWebGLUniformNames() {
          return [
            ...this.getStandardUniformNames(),
            "u_gradientTex",
            "u_flowStrength",
            "u_noiseScale",
            "u_colorIntensity",
            "u_patternScale",
            "u_animationSpeed"
          ];
        }
        /**
         * Generate liquid-specific uniform names (for Liquid system)
         */
        static getLiquidUniformNames() {
          return [
            ...this.getStandardUniformNames(),
            "u_gradientTex",
            "u_flowStrength",
            "u_noiseScale",
            "u_liquidPhase",
            "u_animationIntensity",
            "u_auroraFlow",
            "u_flowDirection",
            "u_liquidTurbulence",
            "u_visualEffectsDepth",
            "u_waveY",
            "u_waveHeight",
            "u_waveOffset",
            "u_blurExp",
            "u_blurMax"
          ];
        }
        /**
         * Get corridor-specific uniform names for system coordination
         * @returns Array of uniform names used in corridor shaders
         */
        static getCorridorUniformNames() {
          return [
            // Standard visualEffects uniforms
            "u_time",
            "u_resolution",
            "u_gradientTex",
            "u_rhythmicPulse",
            "u_musicalFlow",
            "u_energyResonance",
            "u_animationCycle",
            "u_surfaceFluidityIndex",
            "u_musicEnergy",
            "u_musicValence",
            "u_beatIntensity",
            "u_bassResponse",
            // Corridor-specific uniforms
            "u_corridorIntensity",
            "u_corridorFlowStrength",
            "u_corridorDepthEffect",
            "u_corridorBubbleScale"
          ];
        }
        /**
         * Get tunnel visualization-specific uniform names for advanced tunnel effects
         * @returns Array of uniform names used in tunnel visualization shaders
         */
        static getTunnelVisualizationUniformNames() {
          return [
            // Include all tunnel uniforms
            ...this.getCorridorUniformNames(),
            // Tunnel visualization-specific uniforms
            "u_tunnelEnabled",
            "u_tunnelWidth",
            "u_lightingIntensity",
            "u_atmosphericHaze",
            "u_wallColor"
          ];
        }
      };
      __name(_ShaderTemplate, "ShaderTemplate");
      ShaderTemplate = _ShaderTemplate;
      _ShaderLogicPatterns = class _ShaderLogicPatterns {
        /**
         * Enhanced music-driven flow calculation with advanced patterns
         */
        static musicFlowLogic() {
          return `
  // Calculate enhanced music-driven flow
  vec2 flowDirection = calculateMusicalFlow(vec2(1.0, 0.5), u_musicalFlow, 0.5);
  float flowStrength = rhythmicPulseModulation(0.5, u_rhythmicPulse, 0.3);
  
  // Add temporal flow patterns for Year 3000 effects
  vec2 temporalFlow = temporalFlowDirection(uv, u_time, u_temporalFlowDirection);
  flowDirection += temporalFlow;
  
  // Apply enhanced animation modulation with emotional resonance
  float animationMod = deepVisualEffectsPulsing(u_time, 0.0, u_emotionalIntensity);
  flowStrength *= (1.0 + animationMod);
  
  // Apply visualEffects field intensity
  float fieldIntensity = visualEffectsFieldIntensity(uv, u_time, u_musicEnergy);
  flowStrength *= (0.5 + fieldIntensity * 0.5);`;
        }
        /**
         * Enhanced noise-based texture sampling with advanced audio patterns
         */
        static audioNoiseSampling() {
          return `
  // Generate enhanced audio-modulated noise
  vec2 noiseUV = uv + flowDirection * u_time * 0.03;
  
  // Multi-layered visualEffects noise patterns
  float noise1 = snoise(noiseUV * 2.0);
  float noise2 = snoise(noiseUV * 4.0) * 0.5;
  float memoryNoise = snoise(noiseUV * 1.5 + u_time * 0.01) * u_memoryIntensity * 0.3;
  
  // Apply visualEffects field modulation
  float visualEffectsModulation = visualEffectsFieldIntensity(noiseUV, u_time, u_musicEnergy);
  
  // Combine noise with enhanced visualEffects influence
  float t = (noise1 + noise2 + memoryNoise) * energyResonanceModulation(1.0, u_energyResonance, 0.5, 1.5);
  t *= visualEffectsModulation;
  t = clamp(t * 0.5 + 0.5, 0.0, 1.0);`;
        }
        /**
         * Enhanced visualEffects-aware vignette with surface dynamics
         */
        static visualEffectsVignette() {
          return `
  // Apply enhanced visualEffects-aware vignette
  vec2 center = uv - 0.5;
  float animation = deepVisualEffectsPulsing(u_time, u_animationCycle, u_emotionalIntensity);
  
  // Add surface visualEffects flow for smooth boundaries
  float surfaceFlow = surfaceVisualEffectsFlow(uv, u_surfaceFluidityIndex, u_awarenessLevel);
  
  // Calculate visualEffects-aware vignette with surface dynamics
  float vignette = (0.9 + animation + surfaceFlow) - dot(center, center) * 0.3;
  
  // Apply awareness resonance to color
  color.rgb = awarenessResonance(color.rgb, u_visualEffectsLevel, u_musicEnergy);
  color.rgb *= vignette;`;
        }
        /**
         * Standard music-responsive alpha modulation
         */
        static musicResponsiveAlpha() {
          return `
  // Music-responsive alpha modulation
  float musicAlpha = 0.8 + u_beatIntensity * 0.2 + u_bassResponse * 0.1;
  color.a *= musicAlpha;`;
        }
        /**
         * Standard shimmer/aurora effect
         */
        static auroraShimmerEffect() {
          return `
  // Aurora shimmer overlay
  float shimmerPhase = u_time * 3.0 + uv.x * 15.0 + uv.y * 10.0;
  float shimmer = sin(shimmerPhase) * 0.03 + 0.97;
  color.rgb *= shimmer;`;
        }
      };
      __name(_ShaderLogicPatterns, "ShaderLogicPatterns");
      ShaderLogicPatterns = _ShaderLogicPatterns;
      _AdvancedShaderLibrary = class _AdvancedShaderLibrary {
        /**
         * WebGL gradient shader fragment
         * Optimized version of WebGL gradient shader logic
         */
        static webglGradientFragment() {
          return `
  ${ShaderLogicPatterns.musicFlowLogic()}
  
  // WebGL-specific gradient sampling
  ${ShaderLogicPatterns.audioNoiseSampling()}
  
  // Sample gradient texture
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));
  
  // Apply visualEffects effects
  ${ShaderLogicPatterns.visualEffectsVignette()}
  ${ShaderLogicPatterns.musicResponsiveAlpha()}
  
  fragColor = color;`;
        }
        /**
         * Liquid effects shader fragment
         * Core liquid effects with audio-visual integration
         */
        static liquidEffectsFragment() {
          return `
  ${ShaderLogicPatterns.musicFlowLogic()}
  
  // Liquid-specific turbulence and phase
  float liquidPhase = u_liquidPhase + u_rhythmicPulse * 0.5;
  vec2 turbulenceUV = uv * u_liquidTurbulence;
  float turbulence = snoise(turbulenceUV + u_time * 0.01);
  
  // Liquid visualEffects noise
  vec2 liquidUV = uv + flowDirection * u_time * 0.03;
  liquidUV += vec2(sin(u_time * 0.04 + liquidPhase), cos(u_time * 0.03 + liquidPhase)) * 0.02;
  float liquidNoise = snoise(liquidUV * 2.0 + turbulence * 0.1);
  
  float t = clamp(liquidNoise * 0.5 + 0.5, 0.0, 1.0);
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));
  
  ${ShaderLogicPatterns.visualEffectsVignette()}
  ${ShaderLogicPatterns.auroraShimmerEffect()}
  ${ShaderLogicPatterns.musicResponsiveAlpha()}
  
  fragColor = color;`;
        }
        /**
         * Corridor bubble visualEffects fragment
         * Inward-flowing corridor effect with bubble apertures
         */
        static corridorBubbleFragment() {
          return `
  ${ShaderLogicPatterns.musicFlowLogic()}
  
  // Calculate corridor bubble mask
  float corridorMask = bubbleCorridors(uv, u_time, u_corridorIntensity * u_corridorBubbleScale);
  
  // Apply music-responsive aperture modulation
  corridorMask = musicResponsiveAperture(corridorMask, u_beatIntensity, u_bassResponse);
  
  // Generate corridor gradient reveal effect
  vec4 color = corridorGradientReveal(uv, u_gradientTex, corridorMask, u_time, u_corridorIntensity);
  
  // Apply visualEffects effects
  ${ShaderLogicPatterns.visualEffectsVignette()}
  
  // Enhanced music responsiveness for corridor effects
  float corridorMusicAlpha = 0.85 + u_beatIntensity * 0.15 + u_bassResponse * 0.05;
  color.a *= corridorMusicAlpha;
  
  // Apply corridor depth effect for enhanced dimensionality
  float depth = calculatePerspectiveDepth(uv, u_time, u_corridorFlowStrength);
  color.rgb = mix(color.rgb, color.rgb * (1.0 + depth * 0.3), u_corridorDepthEffect);
  
  fragColor = color;`;
        }
        /**
         * Dungeon corridor visualEffects fragment
         * Advanced tunnel corridors with realistic lighting and magical light sources  
         */
        static dungeonCorridorFragment() {
          return `
  ${ShaderLogicPatterns.musicFlowLogic()}
  
  // Calculate dungeon corridor tunnel mask
  float corridorMask = dungeonCorridorTunnels(uv, u_time, u_corridorIntensity * u_corridorBubbleScale);
  
  // Apply music-responsive corridor modulation  
  corridorMask = musicResponsiveAperture(corridorMask, u_beatIntensity, u_bassResponse);
  
  // Generate advanced dungeon corridor gradient reveal effect with realistic lighting
  vec4 color = dungeonCorridorGradientReveal(uv, u_gradientTex, corridorMask, u_time, u_corridorIntensity);
  
  // Apply visualEffects effects for smooth integration
  ${ShaderLogicPatterns.visualEffectsVignette()}
  
  // Enhanced music responsiveness for dungeon atmosphere
  float dungeonMusicAlpha = 0.9 + u_beatIntensity * 0.1 + u_bassResponse * 0.05;
  color.a *= dungeonMusicAlpha;
  
  // Apply corridor depth effect for enhanced dimensionality
  float depth = calculatePerspectiveDepth(uv, u_time, u_corridorFlowStrength);
  color.rgb = mix(color.rgb, color.rgb * (1.0 + depth * 0.4), u_corridorDepthEffect);
  
  // Add subtle magical shimmer for mystical atmosphere
  float magicalShimmer = sin(u_time * 5.0 + uv.x * 12.0 + uv.y * 8.0) * 0.05 + 0.95;
  color.rgb *= magicalShimmer;
  
  fragColor = color;`;
        }
        /**
         * Advanced visualEffects field fragment
         * Multi-dimensional visualEffects patterns with Year 3000 temporal effects
         */
        static advancedVisualEffectsFieldFragment() {
          return `
  ${ShaderLogicPatterns.musicFlowLogic()}
  
  // Calculate multi-dimensional visualEffects field
  float visualEffectsField = visualEffectsFieldIntensity(uv, u_time, u_musicEnergy);
  
  // Apply temporal flow effects for Year 3000 streaming
  vec2 temporalUV = uv + temporalFlowDirection(uv, u_time, u_temporalFlowDirection);
  
  // Enhanced visualEffects noise sampling with memory patterns
  ${ShaderLogicPatterns.audioNoiseSampling()}
  
  // Sample gradient with visualEffects field modulation
  vec4 color = texture(u_gradientTex, vec2(t * visualEffectsField, 0.5));
  
  // Apply awareness resonance for visualEffects-aware color
  color.rgb = awarenessResonance(color.rgb, u_visualEffectsLevel, u_musicEnergy);
  
  // Enhanced surface visualEffects effects
  float surfaceEffect = surfaceVisualEffectsFlow(temporalUV, u_surfaceFluidityIndex, u_awarenessLevel);
  color.rgb *= (1.0 + surfaceEffect * 0.3);
  
  // Apply visualEffects memory animation
  float memoryPulsing = visualEffectsMemoryPulsing(u_time, u_animationCycle, u_memoryIntensity);
  color.a *= (0.8 + memoryPulsing * 0.2 + u_beatIntensity * 0.1);
  
  // Enhanced visualEffects vignette
  ${ShaderLogicPatterns.visualEffectsVignette()}
  
  fragColor = color;`;
        }
        /**
         * Surface visualEffects dynamics fragment
         * Smooth boundary system with visualEffects-aware surface behavior
         */
        static surfaceVisualEffectsDynamicsFragment() {
          return `
  ${ShaderLogicPatterns.musicFlowLogic()}
  
  // Calculate surface visualEffects position with flow
  vec2 surfaceUV = uv;
  surfaceUV += temporalFlowDirection(uv, u_time, u_temporalFlowDirection);
  
  // Apply surface visualEffects flow for smooth boundaries
  float surfaceFlow = surfaceVisualEffectsFlow(surfaceUV, u_surfaceFluidityIndex, u_awarenessLevel);
  surfaceUV += vec2(surfaceFlow * 0.02);
  
  // Enhanced noise sampling with surface distortion
  vec2 noiseUV = surfaceUV + flowDirection * u_time * 0.03;
  float surfaceNoise = snoise(noiseUV * 3.0 + surfaceFlow);
  float visualEffectsNoise = snoise(noiseUV * 1.5) * u_visualEffectsLevel;
  
  // Combine surface and visualEffects noise
  float t = (surfaceNoise * 0.6 + visualEffectsNoise * 0.4) * 0.5 + 0.5;
  t = clamp(t, 0.0, 1.0);
  
  // Sample gradient with surface visualEffects modulation
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));
  
  // Apply visualEffects field influence to surface
  float fieldInfluence = visualEffectsFieldIntensity(surfaceUV, u_time, u_musicEnergy);
  color.rgb = awarenessResonance(color.rgb, fieldInfluence, u_musicEnergy);
  
  // Enhanced surface animation with emotional resonance
  float surfacePulsing = deepVisualEffectsPulsing(u_time, u_animationCycle, u_emotionalIntensity);
  color.rgb *= (0.9 + surfacePulsing * 0.2 + surfaceFlow * 0.1);
  
  // Musical visualEffects synchronization
  color.a *= (0.85 + u_musicalVisualEffectsSync * 0.15 + u_beatIntensity * 0.1);
  
  // Apply enhanced vignette with surface dynamics
  ${ShaderLogicPatterns.visualEffectsVignette()}
  
  fragColor = color;`;
        }
      };
      __name(_AdvancedShaderLibrary, "AdvancedShaderLibrary");
      AdvancedShaderLibrary = _AdvancedShaderLibrary;
      _ShaderOptimizationUtils = class _ShaderOptimizationUtils {
        /**
         * Generate optimized shader based on performance level
         */
        static generateOptimizedShader(baseShaderLogic, performanceLevel) {
          switch (performanceLevel) {
            case "high":
              return baseShaderLogic;
            case "medium":
              return baseShaderLogic.replace(/snoise\(.*?\)/g, "snoise($1)").replace(/\* 0\.0[1-9]/g, "* 0.02");
            case "low":
              return baseShaderLogic.replace(/snoise\(.*?\) \* 0\.[0-9]+/g, "0.5").replace(/sin\(.*?\) \* 0\.[0-9]+/g, "0.0");
            default:
              return baseShaderLogic;
          }
        }
        /**
         * Calculate shader complexity score for performance monitoring
         */
        static calculateShaderComplexity(shaderSource) {
          let complexity = 0;
          complexity += (shaderSource.match(/snoise/g) || []).length * 10;
          complexity += (shaderSource.match(/sin|cos|tan/g) || []).length * 2;
          complexity += (shaderSource.match(/texture/g) || []).length * 3;
          complexity += (shaderSource.match(/mix|smoothstep/g) || []).length * 1;
          return complexity;
        }
        /**
         * Generate fallback shader for low-performance situations
         */
        static generateFallbackShader() {
          return ShaderTemplate.buildFragmentShader({
            includeNoiseFunctions: false,
            includeVisualEffectsFunctions: false,
            additionalUniforms: "uniform sampler2D u_gradientTex;",
            mainShaderLogic: `
  // Minimal fallback visualEffects shader
  float t = uv.x + sin(u_time * 0.5 + u_rhythmicPulse) * 0.1;
  t = clamp(t, 0.0, 1.0);
  
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));
  color.a *= 0.8 + u_beatIntensity * 0.2;
  
  fragColor = color;`
          });
        }
      };
      __name(_ShaderOptimizationUtils, "ShaderOptimizationUtils");
      ShaderOptimizationUtils = _ShaderOptimizationUtils;
      VISUAL_EFFECTS_SHADER_LIBRARY = {
        // Templates and builders
        Template: ShaderTemplate,
        // Shared components
        VERTEX_SHADER: STANDARD_VISUAL_EFFECTS_VERTEX_SHADER,
        NOISE_FUNCTIONS: SHARED_NOISE_FUNCTIONS,
        VISUAL_EFFECTS_FUNCTIONS: VISUAL_EFFECTS_MODULATION_FUNCTIONS,
        CORRIDOR_FUNCTIONS: CORRIDOR_SDF_FUNCTIONS,
        STANDARD_UNIFORMS: STANDARD_VISUAL_EFFECTS_UNIFORMS,
        // Logic patterns
        LogicPatterns: ShaderLogicPatterns,
        // Enhanced visual effects fragments
        Fragments: AdvancedShaderLibrary,
        // Optimization utilities
        Optimization: ShaderOptimizationUtils,
        // Advanced visualEffects effects
        AdvancedEffects: {
          VISUAL_EFFECTS_FIELD_PATTERNS: [
            "visualEffectsFieldIntensity",
            "awarenessResonance",
            "temporalFlowDirection",
            "surfaceVisualEffectsFlow",
            "visualEffectsMemoryPulsing"
          ],
          YEAR_3000_PATTERNS: [
            "temporalFlowDirection",
            "visualEffectsMemoryPulsing",
            "deepVisualEffectsPulsing"
          ],
          MEMBRANE_DYNAMICS: [
            "surfaceVisualEffectsFlow",
            "surfaceFluidityEffect"
          ]
        }
      };
    }
  });

  // src-js/visual/background/WebGLRenderer.ts
  var webglVisualEffectsShader, corridorBubbleShader, _WebGLGradientBackgroundSystem, WebGLGradientBackgroundSystem;
  var init_WebGLRenderer = __esm({
    "src-js/visual/background/WebGLRenderer.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_ShaderLoader();
      init_BaseVisualSystem();
      init_ConsolidatedShaderLibrary();
      webglVisualEffectsShader = ShaderTemplate.buildFragmentShader({
        additionalUniforms: `
// WebGL-specific uniforms
uniform sampler2D u_gradientTex;
uniform float u_flowStrength;
uniform float u_noiseScale;
uniform float u_colorIntensity;
uniform float u_patternScale;
uniform float u_animationSpeed;

// Wave stack uniforms
uniform float u_waveY[2];
uniform float u_waveHeight[2];
uniform float u_waveOffset[2];
uniform float u_blurExp;
uniform float u_blurMax;`,
        additionalFunctions: `
// Octave noise for richer detail
float octaveNoise(vec2 uv, float octaves, float persistence, float scale) {
  float value = 0.0;
  float amplitude = 1.0;
  float frequency = scale;
  float maxValue = 0.0;

  for(float i = 0.0; i < octaves; i++) {
    value += snoise(uv * frequency) * amplitude;
    maxValue += amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return value / maxValue;
}

// Wave alpha calculation
float waveAlpha(vec2 uv, int waveIndex) {
  float y = uv.y;
  float waveCenter = u_waveY[waveIndex];
  float waveHeight = u_waveHeight[waveIndex];

  float distance = abs(y - waveCenter);
  return 1.0 - smoothstep(0.0, waveHeight * 0.5, distance);
}

// Dynamic blur calculation
float calculateBlur(vec2 uv) {
  vec2 center = vec2(0.5, 0.5);
  float distance = length(uv - center);
  float blur = pow(distance, u_blurExp);
  return clamp(blur, 0.0, u_blurMax);
}`,
        mainShaderLogic: VISUAL_EFFECTS_SHADER_LIBRARY.Fragments.webglGradientFragment()
      });
      corridorBubbleShader = ShaderTemplate.buildFragmentShader({
        additionalUniforms: `
// WebGL-specific uniforms
uniform sampler2D u_gradientTex;
uniform float u_flowStrength;
uniform float u_noiseScale;`,
        includeCorridorFunctions: true,
        mainShaderLogic: VISUAL_EFFECTS_SHADER_LIBRARY.Fragments.corridorBubbleFragment()
      });
      _WebGLGradientBackgroundSystem = class _WebGLGradientBackgroundSystem extends BaseVisualSystem {
        constructor(config = ADVANCED_SYSTEM_CONFIG, utils, performanceMonitor, musicSyncService = null, settingsManager2 = null, year3000System = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this.canvas = null;
          this.wrapper = null;
          this.gl = null;
          this.shaderProgram = null;
          this.corridorShaderProgram = null;
          this.uniforms = {};
          this.corridorUniforms = {};
          this.gradientTexture = null;
          this.vertexBuffer = null;
          this.vao = null;
          this.settings = {
            enabled: true,
            intensity: "balanced",
            webglPersistenceMode: "adaptive",
            // Default to current behavior, user can change to "persistent"
            flowStrength: 0.7,
            noiseScale: 1.2,
            waveY: [0.25, 0.75],
            // Wave positions from theme metrics
            waveHeight: [0.4, 0.3],
            // Wave heights for smooth blending
            waveOffset: [2.5, -1.8],
            // Time offsets for wave independence
            blurExp: 1.2,
            // Blur power function exponent
            blurMax: 0.6,
            // Maximum blur amount
            // Corridor bubble settings
            corridorEnabled: false,
            // Start disabled for smooth transition
            corridorIntensity: 0.8,
            corridorFlowStrength: 1.2,
            corridorDepthEffect: 0.6,
            corridorBubbleScale: 1
          };
          this.isWebGLAvailable = false;
          // ✅ RAF LOOP CONSOLIDATION: Removed animationId (coordinator manages animation)
          this.startTime = 0;
          this.lastFrameTime = 0;
          this.frameThrottleInterval = 1e3 / 60;
          // ✅ Increased to 60 FPS (coordinator target)
          this.colorHarmonyEngine = null;
          this.cssVisualEffectsController = null;
          this.eventSubscriptionIds = [];
          this.prefersReducedMotion = false;
          // VisualEffects choreographer integration
          this.visualEffectsChoreographer = null;
          this.currentVisualEffectsField = null;
          this.webglReady = false;
          // Texture creation throttling and debouncing
          this.textureUpdatePending = false;
          this.lastTextureUpdate = 0;
          this.textureUpdateDebounceTimer = null;
          this.textureUpdateThrottleMs = 50;
          // Minimum time between texture updates (made mutable for quality scaling)
          this.textureUpdateDebounceMs = 300;
          // Debounce time for rapid events
          this.textureCreationInProgress = false;
          // WebGL context management (Enhanced Context Recovery with Exponential Backoff)
          this.contextLost = false;
          this.pendingContextRestore = false;
          this.contextLossCount = 0;
          // Track consecutive context losses
          this.maxContextLossRetries = 10;
          // Allow up to 10 attempts over 30 seconds
          this.lastSuccessfulRender = 0;
          // Track successful renders for context loss reset
          this.contextRecoveryTimeouts = [100, 200, 400, 800, 1600, 3200, 5e3, 5e3, 5e3, 5e3];
          // Exponential backoff in ms
          this.currentRecoveryAttempt = 0;
          // Quality scaling properties
          this.currentQualityLevel = null;
          this.qualityCapabilities = [
            { name: "webgl-rendering", enabled: true, qualityLevel: "high" },
            {
              name: "shader-complexity",
              enabled: true,
              qualityLevel: "high"
            },
            { name: "noise-octaves", enabled: true, qualityLevel: "medium" },
            { name: "wave-layers", enabled: true, qualityLevel: "medium" },
            { name: "blur-effects", enabled: true, qualityLevel: "low" },
            { name: "flow-strength", enabled: true, qualityLevel: "low" },
            // Corridor-specific quality capabilities
            { name: "corridor-effects", enabled: true, qualityLevel: "high" },
            { name: "corridor-sdf-complexity", enabled: true, qualityLevel: "medium" },
            { name: "corridor-bubble-layers", enabled: true, qualityLevel: "medium" },
            { name: "corridor-depth-effects", enabled: true, qualityLevel: "low" }
          ];
          this.qualityAdjustments = {};
          // Required BackgroundSystemParticipant implementation
          this.systemName = "WebGLGradientBackgroundSystem";
          // Event deduplication tracking
          this.lastColorHarmonizedData = null;
          this.lastColorHarmonizedTime = 0;
          this.resize = /* @__PURE__ */ __name(() => {
            if (!this.canvas) return;
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            this.canvas.width = displayWidth * dpr;
            this.canvas.height = displayHeight * dpr;
            this.canvas.style.width = displayWidth + "px";
            this.canvas.style.height = displayHeight + "px";
          }, "resize");
          this.colorHarmonyEngine = year3000System?.colorHarmonyEngine || null;
          this.visualEffectsChoreographer = year3000System?.backgroundVisualEffectsChoreographer || null;
          this.prefersReducedMotion = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;
        }
        get systemPriority() {
          return "high";
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          const year3000System = globalThis.year3000System;
          this.cssController = year3000System?.cssVisualEffectsController || getGlobalOptimizedCSSController();
          this.isWebGLAvailable = this.checkWebGL2Support();
          if (!this.isWebGLAvailable) {
            if (this.shouldAttemptWebGLRecovery()) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "WebGL2 not available but persistence mode enabled - attempting WebGL1 compatibility mode"
              );
              this.isWebGLAvailable = this.checkWebGL1Support();
              if (!this.isWebGLAvailable) {
                Y3KDebug?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "Neither WebGL2 nor WebGL1 available despite persistence mode"
                );
                this.fallbackToCSSGradient();
                return;
              }
            } else {
              this.fallbackToCSSGradient();
              return;
            }
          }
          const deviceDetector = new DeviceCapabilityDetector();
          await deviceDetector.initialize();
          const performanceQuality = deviceDetector.recommendPerformanceQuality();
          const capabilities = deviceDetector.getCapabilities();
          if (performanceQuality === "low") {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Low performance device detected - trying minimal WebGL quality",
              {
                performanceQuality,
                deviceCapabilities: capabilities?.overall,
                memoryLevel: capabilities?.memory.level,
                gpuLevel: capabilities?.gpu.level
              }
            );
            this.frameThrottleInterval = 1e3 / 20;
            this.textureUpdateThrottleMs = 1e3;
            this.settings.corridorEnabled = false;
            this.settings.intensity = "minimal";
            this.settings.flowStrength = 0.3;
          } else {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Device capabilities acceptable for WebGL",
              {
                performanceQuality,
                deviceCapabilities: capabilities?.overall
              }
            );
          }
          this.loadSettings();
          if (!this.settings.enabled) {
            this.fallbackToCSSGradient();
            return;
          }
          try {
            await this.initializeWebGL();
            this.subscribeToEvents();
            this.registerWithVisualEffectsChoreographer();
            const webglInitVariables = {
              "--sn.bg.webgl.ready": "1",
              "--sn.bg.webgl.enabled": "1",
              "--sn.bg.active-backend": "hybrid",
              "--sn-gradient-crossfade-opacity": "0.5"
              // 50% blend
            };
            this.cssController.batchSetVariables(
              "WebGLGradientBackgroundSystem",
              webglInitVariables,
              "high",
              // High priority for WebGL initialization
              "webgl-initialization"
            );
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL gradient system initialized successfully"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Failed to initialize WebGL gradient:",
              error
            );
            this.fallbackToCSSGradient();
          }
        }
        checkWebGL2Support() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl2");
            if (!gl) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "WebGL2 context creation failed"
              );
              return false;
            }
            const requiredExtensions = ["EXT_color_buffer_float"];
            const missingExtensions = [];
            for (const ext of requiredExtensions) {
              if (!gl.getExtension(ext)) {
                missingExtensions.push(ext);
              }
            }
            if (missingExtensions.length > 0) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "Missing WebGL2 extensions:",
                missingExtensions
              );
            }
            const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            const maxRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL2 capability check:",
              {
                maxTextureSize,
                maxRenderbufferSize,
                missingExtensions: missingExtensions.length > 0 ? missingExtensions : "none"
              }
            );
            return true;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "WebGL2 support check failed:",
              error
            );
            return false;
          }
        }
        checkWebGL1Support() {
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "WebGL1 context creation failed"
              );
              return false;
            }
            const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            const maxRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL1 fallback capability check:",
              {
                maxTextureSize,
                maxRenderbufferSize
              }
            );
            return true;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "WebGL1 support check failed:",
              error
            );
            return false;
          }
        }
        findSpotifyContainer() {
          const containers = [
            ".Root__main-view",
            ".main-view-container",
            ".main-gridContainer-gridContainer",
            ".Root__top-container",
            "body"
          ];
          for (const selector of containers) {
            const element = document.querySelector(selector);
            if (element) {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                `Found container: ${selector}`
              );
              return element;
            }
          }
          Y3KDebug?.debug?.warn(
            "WebGLGradientBackgroundSystem",
            "No Spotify container found, falling back to body"
          );
          return document.body;
        }
        loadSettings() {
          if (!this.settingsManager) return;
          try {
            const webglEnabled = this.settingsManager.get("sn-webgl-enabled");
            const webglForceEnabled = this.settingsManager.get("sn-webgl-force-enabled");
            const persistenceMode = this.settingsManager.get("sn-webgl-persistence-mode");
            const intensitySetting = this.settingsManager.get("sn-gradient-intensity");
            if (webglEnabled === "false" && webglForceEnabled !== "true") {
              this.settings.enabled = false;
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "WebGL disabled by user setting"
              );
              return;
            }
            this.settings.webglPersistenceMode = persistenceMode || "adaptive";
            if (intensitySetting === "disabled") {
              this.settings.enabled = false;
              return;
            }
            this.settings.intensity = intensitySetting || "balanced";
            switch (this.settings.intensity) {
              case "minimal":
                this.settings.flowStrength = 0.4;
                this.settings.noiseScale = 0.8;
                this.settings.waveHeight = [0.3, 0.2];
                this.settings.waveOffset = [1.5, -1];
                this.settings.blurExp = 1;
                this.settings.blurMax = 0.4;
                break;
              case "balanced":
                this.settings.flowStrength = 0.7;
                this.settings.noiseScale = 1.2;
                this.settings.waveHeight = [0.4, 0.3];
                this.settings.waveOffset = [2.5, -1.8];
                this.settings.blurExp = 1.2;
                this.settings.blurMax = 0.6;
                break;
              case "intense":
                this.settings.flowStrength = 1;
                this.settings.noiseScale = 1.6;
                this.settings.waveHeight = [0.5, 0.4];
                this.settings.waveOffset = [3.5, -2.5];
                this.settings.blurExp = 1.4;
                this.settings.blurMax = 0.8;
                break;
            }
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Settings loaded:",
              {
                webglEnabled,
                webglForceEnabled,
                persistenceMode: this.settings.webglPersistenceMode,
                intensity: this.settings.intensity,
                enabled: this.settings.enabled
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "Failed to load settings, using defaults:",
              error
            );
          }
        }
        /**
         * Handle runtime setting changes (implements ISettingsResponsiveSystem pattern)
         */
        applyUpdatedSettings(key, value) {
          if (!this.settingsManager) return;
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Runtime setting changed: ${key} = ${value}`
          );
          try {
            switch (key) {
              case "sn-webgl-enabled":
                if (value === "false") {
                  this.settings.enabled = false;
                  this.destroy();
                } else if (value === "true" && !this.settings.enabled) {
                  this.settings.enabled = true;
                  if (!this.gl && this.canvas) {
                    this.initialize();
                  }
                }
                break;
              case "sn-webgl-force-enabled":
                const webglEnabled = this.settingsManager.get("sn-webgl-enabled");
                if (webglEnabled === "false" && value !== "true") {
                  this.settings.enabled = false;
                  this.destroy();
                }
                break;
              case "sn-webgl-persistence-mode":
                this.settings.webglPersistenceMode = value || "adaptive";
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `Persistence mode changed to: ${this.settings.webglPersistenceMode}`
                );
                break;
              case "sn-gradient-intensity":
                if (value === "disabled") {
                  this.settings.enabled = false;
                } else {
                  this.settings.enabled = true;
                  this.settings.intensity = value || "balanced";
                  switch (this.settings.intensity) {
                    case "minimal":
                      this.settings.flowStrength = 0.4;
                      this.settings.noiseScale = 0.8;
                      this.settings.waveHeight = [0.3, 0.2];
                      this.settings.waveOffset = [1.5, -1];
                      this.settings.blurExp = 1;
                      this.settings.blurMax = 0.4;
                      break;
                    case "balanced":
                      this.settings.flowStrength = 0.7;
                      this.settings.noiseScale = 1.2;
                      this.settings.waveHeight = [0.4, 0.3];
                      this.settings.waveOffset = [2.5, -1.8];
                      this.settings.blurExp = 1.2;
                      this.settings.blurMax = 0.6;
                      break;
                    case "intense":
                      this.settings.flowStrength = 1;
                      this.settings.noiseScale = 1.6;
                      this.settings.waveHeight = [0.5, 0.4];
                      this.settings.waveOffset = [3.5, -2.5];
                      this.settings.blurExp = 1.4;
                      this.settings.blurMax = 0.8;
                      break;
                  }
                }
                break;
              default:
                return;
            }
            this.forceRepaint?.(`setting-change:${key}`);
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              `Failed to apply runtime setting ${key}:`,
              error
            );
          }
        }
        async initializeWebGL() {
          this.wrapper = document.createElement("div");
          this.wrapper.className = "sn-gradient-effects-wrapper";
          this.wrapper.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -11;
      pointer-events: none;
      overflow: hidden;
    `;
          this.canvas = document.createElement("canvas");
          this.canvas.id = "sn-webgl-gradient";
          this.canvas.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    `;
          this.wrapper.appendChild(this.canvas);
          try {
            this.gl = this.canvas.getContext("webgl2", {
              alpha: true,
              antialias: false,
              depth: false,
              stencil: false,
              powerPreference: "default"
            });
            if (!this.gl) {
              throw new Error(
                "WebGL2 context creation returned null - likely unsupported"
              );
            }
            this.setupContextLossHandlers();
            const testResult = this.gl.getParameter(this.gl.VERSION);
            if (!testResult) {
              throw new Error(
                "WebGL2 context appears non-functional - getParameter failed"
              );
            }
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "WebGL2 context created successfully:",
              {
                version: testResult,
                renderer: this.gl.getParameter(this.gl.RENDERER),
                vendor: this.gl.getParameter(this.gl.VENDOR)
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "WebGL2 context creation failed:",
              error
            );
            throw new Error(
              `Failed to create WebGL2 context: ${error instanceof Error ? error.message : "Unknown error"}`
            );
          }
          await this.compileShaders();
          this.createGeometry();
          await this.updateGradientTexture();
          this.setupUniforms();
          this.resize();
          const targetContainer = this.findSpotifyContainer();
          targetContainer.appendChild(this.wrapper);
          window.addEventListener("resize", this.resize.bind(this));
        }
        async compileShaders() {
          if (!this.gl) throw new Error("WebGL context not available");
          let vertexShader = null;
          let fragmentShader = null;
          let shaderVariant = "full";
          vertexShader = ShaderLoader.loadVertex(this.gl, DEFAULT_VERTEX_SHADER);
          if (!vertexShader) {
            throw new Error("Failed to compile vertex shader - even basic vertex shader failed");
          }
          const fragmentShaderVariants = [
            {
              name: "full",
              shader: webglVisualEffectsShader,
              description: "Full visualEffects shader with all features"
            },
            {
              name: "simplified",
              shader: this.getSimplifiedFragmentShader(),
              description: "Simplified shader without complex noise functions"
            },
            {
              name: "basic",
              shader: this.getBasicFragmentShader(),
              description: "Basic gradient shader with minimal features"
            },
            {
              name: "emergency",
              shader: this.getEmergencyFragmentShader(),
              description: "Emergency shader for maximum hardware compatibility"
            }
          ];
          for (const variant of fragmentShaderVariants) {
            try {
              fragmentShader = ShaderLoader.loadFragment(this.gl, variant.shader);
              if (fragmentShader) {
                shaderVariant = variant.name;
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `Successfully compiled shader variant: ${variant.name}`,
                  { description: variant.description }
                );
                break;
              }
            } catch (error) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                `Failed to compile ${variant.name} shader variant:`,
                error
              );
              continue;
            }
          }
          if (!fragmentShader) {
            throw new Error("Failed to compile any fragment shader variant");
          }
          this.shaderProgram = ShaderLoader.createProgram(
            this.gl,
            vertexShader,
            fragmentShader
          );
          if (!this.shaderProgram) {
            throw new Error("Failed to create shader program");
          }
          const corridorFragmentShader = ShaderLoader.loadFragment(
            this.gl,
            corridorBubbleShader
          );
          if (!corridorFragmentShader) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "Failed to compile corridor shader - corridor effects disabled"
            );
            this.settings.corridorEnabled = false;
            return;
          }
          this.corridorShaderProgram = ShaderLoader.createProgram(
            this.gl,
            vertexShader,
            // Reuse vertex shader
            corridorFragmentShader
          );
          if (!this.corridorShaderProgram) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "Failed to create corridor shader program - corridor effects disabled"
            );
            this.settings.corridorEnabled = false;
          }
        }
        createGeometry() {
          if (!this.gl || !this.shaderProgram) return;
          const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
          this.vertexBuffer = this.gl.createBuffer();
          this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
          this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
          this.vao = this.gl.createVertexArray();
          this.gl.bindVertexArray(this.vao);
          const positionLocation = this.gl.getAttribLocation(
            this.shaderProgram,
            "a_position"
          );
          this.gl.enableVertexAttribArray(positionLocation);
          this.gl.vertexAttribPointer(
            positionLocation,
            2,
            this.gl.FLOAT,
            false,
            0,
            0
          );
          this.gl.bindVertexArray(null);
        }
        setupUniforms() {
          if (!this.gl || !this.shaderProgram) return;
          this.uniforms.u_time = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_time"
          );
          this.uniforms.u_gradientTex = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_gradientTex"
          );
          this.uniforms.u_resolution = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_resolution"
          );
          this.uniforms.u_flowStrength = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_flowStrength"
          );
          this.uniforms.u_noiseScale = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_noiseScale"
          );
          this.uniforms.u_waveY = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveY"
          );
          this.uniforms.u_waveHeight = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveHeight"
          );
          this.uniforms.u_waveOffset = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveOffset"
          );
          this.uniforms.u_blurExp = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_blurExp"
          );
          this.uniforms.u_blurMax = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_blurMax"
          );
          if (this.corridorShaderProgram) {
            this.setupCorridorUniforms();
          }
        }
        setupCorridorUniforms() {
          if (!this.gl || !this.corridorShaderProgram) return;
          const corridorUniformNames = ShaderTemplate.getCorridorUniformNames();
          for (const uniformName of corridorUniformNames) {
            this.corridorUniforms[uniformName] = this.gl.getUniformLocation(
              this.corridorShaderProgram,
              uniformName
            );
          }
        }
        updateVisualEffectsUniforms(uniforms, time) {
          if (!this.gl) return;
          const visualEffectsField = this.currentVisualEffectsField;
          const rhythmicPulse = visualEffectsField?.pulseRate ?? 0.5;
          if (uniforms.u_rhythmicPulse) {
            this.gl.uniform1f(uniforms.u_rhythmicPulse, rhythmicPulse);
          }
          const musicalFlow = visualEffectsField?.flowDirection ?? { x: 0, y: 0 };
          if (uniforms.u_musicalFlow && musicalFlow) {
            this.gl.uniform2f(uniforms.u_musicalFlow, musicalFlow.x ?? 0, musicalFlow.y ?? 0);
          }
          const energyResonance = visualEffectsField?.energyLevel ?? 0.5;
          if (uniforms.u_energyResonance) {
            this.gl.uniform1f(uniforms.u_energyResonance, energyResonance);
          }
          const pulsingCycle = Math.sin(time * 0.05) * 0.5 + 0.5;
          if (uniforms.u_pulsingCycle) {
            this.gl.uniform1f(uniforms.u_pulsingCycle, pulsingCycle);
          }
          const surfaceFluidityIndex = visualEffectsField?.fluidIntensity ?? 0.3;
          if (uniforms.u_surfaceFluidityIndex) {
            this.gl.uniform1f(uniforms.u_surfaceFluidityIndex, surfaceFluidityIndex);
          }
          if (this.musicSyncService) {
            const musicState = this.musicSyncService.getCurrentMusicState();
            if (musicState) {
              const musicEnergy = musicState.beat?.energy ?? 0.5;
              const musicValence = musicState.emotion?.valence ?? 0.5;
              const beatIntensity = musicState.intensity ?? 0;
              const bassResponse = musicState.beat?.energy ?? 0;
              if (uniforms.u_musicEnergy) {
                this.gl.uniform1f(uniforms.u_musicEnergy, musicEnergy);
              }
              if (uniforms.u_musicValence) {
                this.gl.uniform1f(uniforms.u_musicValence, musicValence);
              }
              if (uniforms.u_beatIntensity) {
                this.gl.uniform1f(uniforms.u_beatIntensity, beatIntensity);
              }
              if (uniforms.u_bassResponse) {
                this.gl.uniform1f(uniforms.u_bassResponse, bassResponse);
              }
            }
          }
        }
        async updateGradientTexture() {
          if (!this.gl) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "No WebGL context available"
            );
            return;
          }
          if (!this.isContextValid()) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "WebGL context invalid, attempting recovery"
            );
            if (this.contextLost && !this.pendingContextRestore) {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "Attempting WebGL context recovery"
              );
              this.fallbackToCSSGradient();
            }
            return;
          }
          const preError = this.gl.getError();
          if (preError !== this.gl.NO_ERROR) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              `WebGL error detected before texture update: ${preError}`
            );
            while (this.gl.getError() !== this.gl.NO_ERROR) {
            }
          }
          if (this.textureCreationInProgress) {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Texture creation already in progress, skipping update"
            );
            return;
          }
          this.textureCreationInProgress = true;
          try {
            let colorStops = this.getDefaultGradientStops();
            let colorSource = "default";
            if (this.colorHarmonyEngine) {
              try {
                const currentGradient = this.colorHarmonyEngine.getCurrentGradient(5);
                if (currentGradient && currentGradient.length > 0) {
                  colorStops = currentGradient.map((color3, index) => ({
                    r: color3.r / 255,
                    g: color3.g / 255,
                    b: color3.b / 255,
                    a: 1,
                    position: index / (currentGradient.length - 1)
                  }));
                  colorSource = "ColorHarmonyEngine";
                  Y3KDebug?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    `Updated gradient texture with ${colorStops.length} stops from ColorHarmonyEngine`
                  );
                } else {
                  const cssColorStops = this.getCSSGradientStops();
                  if (cssColorStops && cssColorStops.length > 0) {
                    colorStops = cssColorStops;
                    colorSource = "CSS variables";
                    Y3KDebug?.debug?.log(
                      "WebGLGradientBackgroundSystem",
                      `ColorHarmonyEngine returned empty, using CSS gradient fallback with ${colorStops.length} stops`
                    );
                  }
                }
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  "Failed to get gradient from ColorHarmonyEngine, trying CSS fallback:",
                  error
                );
                const cssColorStops = this.getCSSGradientStops();
                if (cssColorStops && cssColorStops.length > 0) {
                  colorStops = cssColorStops;
                  colorSource = "CSS variables (engine failed)";
                  Y3KDebug?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    `Using CSS gradient fallback after ColorHarmonyEngine error with ${colorStops.length} stops`
                  );
                }
              }
            } else {
              const cssColorStops = this.getCSSGradientStops();
              if (cssColorStops && cssColorStops.length > 0) {
                colorStops = cssColorStops;
                colorSource = "CSS variables (no engine)";
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `No ColorHarmonyEngine available, using CSS gradient fallback with ${colorStops.length} stops`
                );
              }
            }
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Final color source: ${colorSource}, stops: ${colorStops.length}`
            );
            if (this.gl.isContextLost()) {
              throw new Error("WebGL context was lost during gradient preparation");
            }
            if (this.gradientTexture) {
              try {
                this.gl.deleteTexture(this.gradientTexture);
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  "Error deleting old texture:",
                  error
                );
              }
              this.gradientTexture = null;
            }
            if (!colorStops || colorStops.length === 0) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "No valid color stops, using defaults"
              );
              colorStops = this.getDefaultGradientStops();
            }
            let newTexture = null;
            let attempts = 0;
            const maxAttempts = 3;
            while (!newTexture && attempts < maxAttempts) {
              attempts++;
              try {
                if (this.gl.isContextLost()) {
                  throw new Error(
                    "WebGL context lost during texture creation attempt"
                  );
                }
                newTexture = createGradientTexture(this.gl, colorStops);
                if (newTexture) {
                  Y3KDebug?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    `Gradient texture created successfully on attempt ${attempts}`
                  );
                  break;
                }
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  `Texture creation attempt ${attempts} failed:`,
                  error
                );
                if (attempts < maxAttempts) {
                  await new Promise((resolve) => setTimeout(resolve, attempts * 10));
                }
              }
            }
            if (!newTexture) {
              Y3KDebug?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Failed to create gradient texture after all attempts - trying default colors"
              );
              try {
                const defaultStops = this.getDefaultGradientStops();
                const fallbackTexture = createGradientTexture(this.gl, defaultStops);
                if (!fallbackTexture) {
                  throw new Error(
                    "Failed to create gradient texture even with default colors"
                  );
                }
                this.gradientTexture = fallbackTexture;
                colorStops = defaultStops;
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  "Using default gradient fallback after all attempts failed"
                );
              } catch (fallbackError) {
                Y3KDebug?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "Default gradient fallback failed, attempting emergency solid color:",
                  fallbackError
                );
                try {
                  const emergencySolidStops = [
                    { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 0 },
                    // Catppuccin base
                    { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 1 }
                    // Same color
                  ];
                  const emergencyTexture = createGradientTexture(this.gl, emergencySolidStops);
                  if (emergencyTexture) {
                    this.gradientTexture = emergencyTexture;
                    colorStops = emergencySolidStops;
                    Y3KDebug?.debug?.warn(
                      "WebGLGradientBackgroundSystem",
                      "Using emergency solid color texture as final fallback"
                    );
                  } else {
                    throw new Error("Emergency solid color texture creation failed");
                  }
                } catch (emergencyError) {
                  Y3KDebug?.debug?.error(
                    "WebGLGradientBackgroundSystem",
                    "Emergency solid color texture failed:",
                    emergencyError
                  );
                  throw new Error(
                    `All gradient texture creation methods failed: ${emergencyError}`
                  );
                }
              }
            } else {
              this.gradientTexture = newTexture;
            }
            this.lastTextureUpdate = performance.now();
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Gradient texture updated successfully using ${colorSource}`,
              {
                colorStops: colorStops.length,
                source: colorSource,
                firstColor: colorStops[0] ? `rgb(${Math.round(colorStops[0].r * 255)},${Math.round(
                  colorStops[0].g * 255
                )},${Math.round(colorStops[0].b * 255)})` : "none"
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Critical error in updateGradientTexture:",
              error
            );
            if (error instanceof Error && error.message.includes("context")) {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "WebGL context-related error detected, switching to CSS fallback"
              );
              this.fallbackToCSSGradient();
            } else {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "Attempting simple texture recovery with default colors"
              );
              try {
                this.gradientTexture = null;
                const defaultStops = this.getDefaultGradientStops();
                if (this.gl && !this.gl.isContextLost()) {
                  this.gradientTexture = createGradientTexture(this.gl, defaultStops);
                  if (this.gradientTexture) {
                    Y3KDebug?.debug?.log(
                      "WebGLGradientBackgroundSystem",
                      "Successfully recovered with default gradient"
                    );
                  } else {
                    throw new Error("Recovery attempt failed");
                  }
                } else {
                  throw new Error("WebGL context unavailable for recovery");
                }
              } catch (recoveryError) {
                Y3KDebug?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "Recovery attempt failed, falling back to CSS:",
                  recoveryError
                );
                this.fallbackToCSSGradient();
              }
            }
          } finally {
            this.textureCreationInProgress = false;
          }
        }
        /**
         * Throttled texture update to prevent rapid-fire texture creation
         */
        async updateGradientTextureThrottled() {
          const now = performance.now();
          if (now - this.lastTextureUpdate < this.textureUpdateThrottleMs) {
            if (!this.textureUpdatePending) {
              this.textureUpdatePending = true;
              const timeToWait = this.textureUpdateThrottleMs - (now - this.lastTextureUpdate);
              setTimeout(() => {
                this.textureUpdatePending = false;
                this.updateGradientTexture().catch((error) => {
                  Y3KDebug?.debug?.error(
                    "WebGLGradientBackgroundSystem",
                    "Throttled texture update failed:",
                    error
                  );
                });
              }, timeToWait);
            }
            return;
          }
          await this.updateGradientTexture();
        }
        /**
         * Debounced texture update to handle rapid event sequences
         */
        debouncedUpdateGradientTexture() {
          if (this.textureUpdateDebounceTimer) {
            clearTimeout(this.textureUpdateDebounceTimer);
          }
          this.textureUpdateDebounceTimer = window.setTimeout(() => {
            this.textureUpdateDebounceTimer = null;
            this.updateGradientTextureThrottled().catch((error) => {
              Y3KDebug?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Debounced texture update failed:",
                error
              );
            });
          }, this.textureUpdateDebounceMs);
        }
        /**
         * Setup WebGL context loss and restore event handlers
         */
        setupContextLossHandlers() {
          if (!this.canvas) return;
          this.canvas.addEventListener(
            "webglcontextlost",
            async (event) => {
              this.contextLossCount++;
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "WebGL context lost - Enhanced Recovery",
                {
                  lossCount: this.contextLossCount,
                  maxRetries: this.maxContextLossRetries
                }
              );
              event.preventDefault();
              this.contextLost = true;
              this.textureCreationInProgress = false;
              if (this.contextLossCount <= this.maxContextLossRetries) {
                const attemptIndex = Math.min(this.contextLossCount - 1, this.contextRecoveryTimeouts.length - 1);
                const backoffDelay = this.contextRecoveryTimeouts[attemptIndex] || 5e3;
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `Preparing for context recovery attempt ${this.contextLossCount}/${this.maxContextLossRetries} with ${backoffDelay}ms backoff`,
                  { shouldPersist: this.shouldPersistWebGL() }
                );
                if (this.gl) {
                  try {
                    const { ShaderLoader: ShaderLoader2 } = await Promise.resolve().then(() => (init_ShaderLoader(), ShaderLoader_exports));
                    ShaderLoader2.clearContextCache(this.gl);
                  } catch (e) {
                  }
                }
                if (this.textureUpdateDebounceTimer) {
                  clearTimeout(this.textureUpdateDebounceTimer);
                  this.textureUpdateDebounceTimer = null;
                }
                this.textureUpdatePending = false;
              } else {
                if (this.shouldPersistWebGL()) {
                  Y3KDebug?.debug?.warn(
                    "WebGLGradientBackgroundSystem",
                    `Context lost ${this.contextLossCount} times but persistence mode enabled - resetting retry count and continuing`
                  );
                  this.contextLossCount = Math.max(1, this.maxContextLossRetries - 3);
                  this.currentRecoveryAttempt = 0;
                } else {
                  Y3KDebug?.debug?.error(
                    "WebGLGradientBackgroundSystem",
                    `Context lost ${this.contextLossCount} times - falling back to CSS gradient`
                  );
                  this.fallbackToCSSGradient();
                }
              }
            },
            false
          );
          const attemptContextRecovery = /* @__PURE__ */ __name(async () => {
            if (!this.contextLost || this.pendingContextRestore) {
              return;
            }
            const attemptIndex = Math.min(this.currentRecoveryAttempt, this.contextRecoveryTimeouts.length - 1);
            const backoffDelay = this.contextRecoveryTimeouts[attemptIndex] || 5e3;
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Attempting context recovery in ${backoffDelay}ms (attempt ${this.currentRecoveryAttempt + 1})`
            );
            setTimeout(async () => {
              if (!this.contextLost) {
                return;
              }
              this.currentRecoveryAttempt++;
              try {
                if (this.gl && this.gl.isContextLost()) {
                  this.gl.getError();
                }
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  "Error during context recovery attempt:",
                  error
                );
              }
              if (this.contextLost && this.currentRecoveryAttempt < this.maxContextLossRetries) {
                attemptContextRecovery();
              }
            }, backoffDelay);
          }, "attemptContextRecovery");
          this.canvas.addEventListener("webglcontextlost", () => {
            this.currentRecoveryAttempt = 0;
            attemptContextRecovery();
          });
          this.canvas.addEventListener(
            "webglcontextrestored",
            async () => {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "WebGL context restored - Enhanced Recovery",
                {
                  lossCount: this.contextLossCount,
                  maxRetries: this.maxContextLossRetries
                }
              );
              this.contextLost = false;
              this.pendingContextRestore = true;
              try {
                if (!this.gl || this.gl.isContextLost()) {
                  throw new Error("Context is still lost after restore event");
                }
                await this.reinitializeWebGLResources();
                if (this.contextLossCount >= 2) {
                  Y3KDebug?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    "Reducing quality after multiple context losses"
                  );
                  this.adjustQualityForTier("low");
                } else if (this.contextLossCount >= 1) {
                  Y3KDebug?.debug?.log(
                    "WebGLGradientBackgroundSystem",
                    "Reducing quality after context loss"
                  );
                  this.adjustQualityForTier("medium");
                }
                this.pendingContextRestore = false;
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  "WebGL context restore completed successfully",
                  {
                    lossCount: this.contextLossCount,
                    qualityReduced: this.contextLossCount > 0
                  }
                );
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "Failed to restore WebGL context:",
                  error
                );
                this.pendingContextRestore = false;
                this.contextLossCount++;
                if (this.contextLossCount > this.maxContextLossRetries) {
                  Y3KDebug?.debug?.error(
                    "WebGLGradientBackgroundSystem",
                    "Context restoration failed too many times - falling back to CSS"
                  );
                  this.fallbackToCSSGradient();
                }
              }
            },
            false
          );
        }
        /**
         * Reinitialize WebGL resources after context restore
         */
        async reinitializeWebGLResources() {
          if (!this.gl) throw new Error("WebGL context not available");
          this.shaderProgram = null;
          this.vertexBuffer = null;
          this.vao = null;
          this.gradientTexture = null;
          const { ShaderLoader: ShaderLoader2 } = await Promise.resolve().then(() => (init_ShaderLoader(), ShaderLoader_exports));
          ShaderLoader2.clearContextCache(this.gl);
          await this.compileShaders();
          this.createGeometry();
          await this.updateGradientTexture();
          this.setupUniforms();
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "WebGL resources reinitialized after context restore"
          );
        }
        /**
         * Check if WebGL context is available and functional
         */
        isContextValid() {
          if (!this.gl) return false;
          if (this.contextLost) return false;
          if (this.gl.isContextLost()) {
            this.contextLost = true;
            return false;
          }
          return true;
        }
        getDefaultGradientStops() {
          return [
            { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 0 },
            // Base
            { r: 0.549, g: 0.408, b: 0.878, a: 1, position: 0.3 },
            // Mauve
            { r: 0.788, g: 0.557, b: 0.902, a: 1, position: 0.6 },
            // Pink
            { r: 0.957, g: 0.761, b: 0.494, a: 1, position: 1 }
            // Peach
          ];
        }
        /**
         * Get gradient color stops from CSS variables that inherit from ColorHarmonyEngine
         * These variables are set by OKLAB processing and represent the actual background gradient colors
         */
        getCSSGradientStops() {
          try {
            const root = document.documentElement;
            const computedStyle = getComputedStyle(root);
            const gradientVariables = [
              "--sn-bg-gradient-primary-rgb",
              "--sn-bg-gradient-secondary-rgb",
              "--sn-bg-gradient-tertiary-rgb"
            ];
            const colorStops = [];
            for (let i = 0; i < gradientVariables.length; i++) {
              const variableName = gradientVariables[i] || "--sn-bg-gradient-primary-rgb";
              const rgbStr = computedStyle.getPropertyValue(variableName).trim();
              if (!rgbStr) {
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  `CSS variable ${variableName} not set, trying without CSS fallback`
                );
                continue;
              }
              const rgbValues = rgbStr.split(",").map((v) => parseInt(v.trim(), 10));
              if (rgbValues.length !== 3 || rgbValues.some((v) => isNaN(v) || v < 0 || v > 255)) {
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  `Invalid RGB values in ${variableName}: ${rgbStr}, skipping this color`
                );
                continue;
              }
              colorStops.push({
                r: (rgbValues[0] ?? 0) / 255,
                g: (rgbValues[1] ?? 0) / 255,
                b: (rgbValues[2] ?? 0) / 255,
                a: 1,
                position: i / (gradientVariables.length - 1)
              });
            }
            if (colorStops.length < 2) {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                `Only ${colorStops.length} valid CSS colors found, need at least 2 for gradient`
              );
              return null;
            }
            const opacityStr = computedStyle.getPropertyValue("--sn-bg-gradient-opacity").trim();
            const opacity = opacityStr ? parseFloat(opacityStr) : 1;
            if (opacity !== 1 && opacity > 0 && opacity <= 1) {
              colorStops.forEach((stop) => {
                stop.a = opacity;
              });
            }
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Successfully parsed ${colorStops.length} CSS background gradient stops from OKLAB inheritance`,
              {
                colors: colorStops.map(
                  (stop) => `rgba(${Math.round(stop.r * 255)},${Math.round(
                    stop.g * 255
                  )},${Math.round(stop.b * 255)},${stop.a})`
                ),
                opacity: opacity !== 1 ? opacity : "default"
              }
            );
            return colorStops;
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "Failed to parse CSS background gradient variables:",
              error
            );
            return null;
          }
        }
        subscribeToEvents() {
          const colorHarmonizedSub = unifiedEventBus.subscribe(
            "colors:harmonized",
            this.handleColorHarmonized.bind(this),
            "WebGLGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(colorHarmonizedSub);
          const colorAppliedSub = unifiedEventBus.subscribe(
            "colors:applied",
            this.handleColorApplied.bind(this),
            "WebGLGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(colorAppliedSub);
          const performanceTierSub = unifiedEventBus.subscribe(
            "performance:tier-changed",
            this.handlePerformanceTierChanged.bind(this),
            "WebGLGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(performanceTierSub);
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Subscribed to unified events",
            {
              subscriptionCount: this.eventSubscriptionIds.length,
              events: ["colors:harmonized", "colors:applied", "performance:tier-changed"]
            }
          );
        }
        handleColorHarmonized(data) {
          const currentTime = performance.now();
          const dataHash = `${data.accentHex}-${data.processingTime}-${data.strategies.join(",")}`;
          if (this.lastColorHarmonizedData === dataHash && currentTime - this.lastColorHarmonizedTime < 100) {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Duplicate color harmonization event detected, skipping"
            );
            return;
          }
          this.lastColorHarmonizedData = dataHash;
          this.lastColorHarmonizedTime = currentTime;
          this.debouncedUpdateGradientTexture();
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Color harmonization processed",
            {
              strategies: data.strategies,
              processingTime: data.processingTime,
              accentHex: data.accentHex,
              deduplicationHash: dataHash.substring(0, 16) + "..."
            }
          );
        }
        handleColorApplied(data) {
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Color application coordinated",
            {
              accentHex: data.accentHex,
              appliedAt: data.appliedAt
            }
          );
        }
        /**
         * Handle performance tier changes for quality scaling (High Priority Fix)
         * Implements progressive quality reduction instead of immediate fallback
         */
        handlePerformanceTierChanged(data) {
          if (!this.isActive || !this.gl) {
            return;
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Performance tier changed",
            {
              previousTier: data.previousTier,
              newTier: data.tier,
              timestamp: data.timestamp
            }
          );
          switch (data.tier) {
            case "excellent":
              this.adjustQualityForTier("high");
              break;
            case "good":
              this.adjustQualityForTier("medium");
              break;
            case "degraded":
              this.adjustQualityForTier("low");
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "Performance degraded - reducing WebGL quality instead of fallback"
              );
              break;
            case "critical":
              if (data.previousTier === "degraded") {
                if (this.shouldPersistWebGL()) {
                  Y3KDebug?.debug?.warn(
                    "WebGLGradientBackgroundSystem",
                    "Critical performance but persistence mode enabled - reducing to absolute minimum WebGL quality"
                  );
                  this.adjustQualityForTier("emergency");
                } else {
                  Y3KDebug?.debug?.warn(
                    "WebGLGradientBackgroundSystem",
                    "Critical performance detected - falling back to CSS gradient"
                  );
                  this.fallbackToCSSGradient();
                }
              } else {
                this.adjustQualityForTier("minimal");
                Y3KDebug?.debug?.warn(
                  "WebGLGradientBackgroundSystem",
                  "Critical performance - using minimal WebGL quality"
                );
              }
              break;
          }
        }
        /**
         * Adjust WebGL quality based on performance tier
         */
        adjustQualityForTier(qualityTier) {
          if (!this.gl || !this.canvas) return;
          switch (qualityTier) {
            case "high":
              this.frameThrottleInterval = 1e3 / 60;
              break;
            case "medium":
              this.frameThrottleInterval = 1e3 / 45;
              break;
            case "low":
              this.frameThrottleInterval = 1e3 / 30;
              break;
            case "minimal":
              this.frameThrottleInterval = 1e3 / 15;
              break;
            case "emergency":
              this.frameThrottleInterval = 1e3 / 10;
              break;
          }
          switch (qualityTier) {
            case "high":
              this.textureUpdateThrottleMs = 100;
              break;
            case "medium":
              this.textureUpdateThrottleMs = 200;
              break;
            case "low":
              this.textureUpdateThrottleMs = 500;
              break;
            case "minimal":
              this.textureUpdateThrottleMs = 1e3;
              break;
            case "emergency":
              this.textureUpdateThrottleMs = 2e3;
              break;
          }
          const container = this.findSpotifyContainer();
          if (container) {
            const containerRect = container.getBoundingClientRect();
            let scaleFactor = 1;
            switch (qualityTier) {
              case "high":
                scaleFactor = 1;
                break;
              case "medium":
                scaleFactor = 0.8;
                break;
              case "low":
                scaleFactor = 0.6;
                break;
              case "minimal":
                scaleFactor = 0.4;
                break;
              case "emergency":
                scaleFactor = 0.1;
                break;
            }
            const newWidth = Math.floor(containerRect.width * scaleFactor);
            const newHeight = Math.floor(containerRect.height * scaleFactor);
            this.canvas.width = newWidth;
            this.canvas.height = newHeight;
            if (this.gl) {
              this.gl.viewport(0, 0, newWidth, newHeight);
            }
          }
          const wasCorridorEnabled = this.settings.corridorEnabled;
          switch (qualityTier) {
            case "high":
              this.settings.intensity = "intense";
              this.settings.flowStrength = Math.max(this.settings.flowStrength, 0.7);
              break;
            case "medium":
              this.settings.intensity = "balanced";
              this.settings.flowStrength = Math.min(this.settings.flowStrength, 0.6);
              break;
            case "low":
              this.settings.corridorEnabled = false;
              this.settings.intensity = "minimal";
              this.settings.flowStrength = Math.min(this.settings.flowStrength, 0.4);
              break;
            case "minimal":
              this.settings.corridorEnabled = false;
              this.settings.intensity = "minimal";
              this.settings.flowStrength = 0.2;
              break;
          }
          if (wasCorridorEnabled !== this.settings.corridorEnabled) {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Corridor shader ${this.settings.corridorEnabled ? "enabled" : "disabled"} for ${qualityTier} quality`
            );
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Quality adjusted for ${qualityTier} performance tier`,
            {
              frameFPS: Math.round(1e3 / this.frameThrottleInterval),
              textureFPS: Math.round(1e3 / this.textureUpdateThrottleMs),
              canvasResolution: `${this.canvas.width}x${this.canvas.height}`,
              corridorEnabled: this.settings.corridorEnabled
            }
          );
        }
        /**
         * ✅ RAF LOOP REMOVED - Managed by EnhancedMasterAnimationCoordinator
         *
         * Benefits:
         * - Single RAF loop for all systems (not 5-8 independent loops)
         * - Shared deltaTime calculation (eliminates redundant performance.now() calls)
         * - Coordinated frame budget management
         * - Priority-based execution order
         * - Increased from 45 FPS to 60 FPS target (coordinator manages this)
         *
         * Old methods removed: startAnimation(), animate()
         * Replacement: updateAnimation(deltaTime) called by coordinator
         */
        render(currentTime) {
          if (!this.gl || !this.vao) return;
          if (!this.gradientTexture) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientBackgroundSystem",
              "No gradient texture during render - creating emergency texture"
            );
            try {
              const emergencyTextures = [
                () => {
                  const cssStops = this.getCSSGradientStops();
                  return cssStops ? createGradientTexture(this.gl, cssStops) : null;
                },
                () => {
                  const defaultStops = this.getDefaultGradientStops();
                  return createGradientTexture(this.gl, defaultStops);
                },
                () => {
                  const solidStops = [
                    { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 0 },
                    // Catppuccin base
                    { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 1 }
                    // Same color
                  ];
                  return createGradientTexture(this.gl, solidStops);
                }
              ];
              for (let i = 0; i < emergencyTextures.length; i++) {
                try {
                  this.gradientTexture = emergencyTextures[i]();
                  if (this.gradientTexture) {
                    Y3KDebug?.debug?.log(
                      "WebGLGradientBackgroundSystem",
                      `Emergency texture created using method ${i + 1}`
                    );
                    break;
                  }
                } catch (error) {
                  Y3KDebug?.debug?.warn(
                    "WebGLGradientBackgroundSystem",
                    `Emergency texture method ${i + 1} failed:`,
                    error
                  );
                }
              }
              if (!this.gradientTexture) {
                Y3KDebug?.debug?.error(
                  "WebGLGradientBackgroundSystem",
                  "All emergency texture creation methods failed - skipping render"
                );
                return;
              }
            } catch (error) {
              Y3KDebug?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Emergency texture creation failed completely:",
                error
              );
              return;
            }
          }
          this.lastSuccessfulRender = currentTime;
          if (this.contextLossCount > 0 && currentTime - this.lastSuccessfulRender > 3e4) {
            const oldCount = this.contextLossCount;
            this.contextLossCount = Math.max(0, this.contextLossCount - 1);
            if (oldCount !== this.contextLossCount) {
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "Context loss count reduced due to successful renders",
                {
                  oldCount,
                  newCount: this.contextLossCount
                }
              );
            }
          }
          const useCorridorShader = this.settings.corridorEnabled && this.corridorShaderProgram && this.currentQualityLevel !== "low";
          const currentShaderProgram = useCorridorShader ? this.corridorShaderProgram : this.shaderProgram;
          const currentUniforms = useCorridorShader ? this.corridorUniforms : this.uniforms;
          if (!currentShaderProgram) return;
          this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
          this.gl.clearColor(0, 0, 0, 0);
          this.gl.clear(this.gl.COLOR_BUFFER_BIT);
          this.gl.useProgram(currentShaderProgram);
          this.gl.bindVertexArray(this.vao);
          if (!this.webglReady) {
            this.webglReady = true;
            const webglReadyVariables = {
              "--sn.bg.webgl.ready": "1",
              "--sn.bg.webgl.enabled": "1",
              "--sn.bg.active-backend": "hybrid",
              "--sn-gradient-crossfade-opacity": "0.5"
              // Balanced hybrid blend
            };
            this.cssController.batchSetVariables(
              "WebGLGradientBackgroundSystem",
              webglReadyVariables,
              "critical",
              // Critical priority for first draw
              "webgl-first-draw"
            );
          }
          const time = this.prefersReducedMotion ? 0 : (currentTime - this.startTime) / 1e3;
          if (currentUniforms.u_time) {
            this.gl.uniform1f(currentUniforms.u_time, time);
          }
          if (currentUniforms.u_resolution) {
            this.gl.uniform2f(
              currentUniforms.u_resolution,
              this.canvas.width,
              this.canvas.height
            );
          }
          if (currentUniforms.u_flowStrength) {
            let flowStrength = this.settings.flowStrength;
            try {
              const computedStyle = getComputedStyle(document.documentElement);
              const flowStrengthValue = computedStyle.getPropertyValue("--sn-flow-strength").trim();
              if (flowStrengthValue) {
                flowStrength = parseFloat(flowStrengthValue);
              }
            } catch (error) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "Failed to read flow strength CSS variable, using settings value"
              );
            }
            this.gl.uniform1f(currentUniforms.u_flowStrength, flowStrength);
          }
          if (currentUniforms.u_noiseScale) {
            this.gl.uniform1f(currentUniforms.u_noiseScale, this.settings.noiseScale);
          }
          if (!useCorridorShader) {
            if (currentUniforms.u_waveY) {
              this.gl.uniform1fv(currentUniforms.u_waveY, this.settings.waveY);
            }
            if (currentUniforms.u_waveHeight) {
              this.gl.uniform1fv(currentUniforms.u_waveHeight, this.settings.waveHeight);
            }
            if (currentUniforms.u_waveOffset) {
              this.gl.uniform1fv(currentUniforms.u_waveOffset, this.settings.waveOffset);
            }
            if (currentUniforms.u_blurExp) {
              this.gl.uniform1f(currentUniforms.u_blurExp, this.settings.blurExp);
            }
            if (currentUniforms.u_blurMax) {
              this.gl.uniform1f(currentUniforms.u_blurMax, this.settings.blurMax);
            }
          }
          if (useCorridorShader) {
            if (currentUniforms.u_corridorIntensity) {
              this.gl.uniform1f(currentUniforms.u_corridorIntensity, this.settings.corridorIntensity);
            }
            if (currentUniforms.u_corridorFlowStrength) {
              this.gl.uniform1f(currentUniforms.u_corridorFlowStrength, this.settings.corridorFlowStrength);
            }
            if (currentUniforms.u_corridorDepthEffect) {
              this.gl.uniform1f(currentUniforms.u_corridorDepthEffect, this.settings.corridorDepthEffect);
            }
            if (currentUniforms.u_corridorBubbleScale) {
              this.gl.uniform1f(currentUniforms.u_corridorBubbleScale, this.settings.corridorBubbleScale);
            }
            this.updateVisualEffectsUniforms(currentUniforms, time);
          }
          this.gl.activeTexture(this.gl.TEXTURE0);
          this.gl.bindTexture(this.gl.TEXTURE_2D, this.gradientTexture);
          if (currentUniforms.u_gradientTex) {
            this.gl.uniform1i(currentUniforms.u_gradientTex, 0);
          }
          this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
          this.gl.bindVertexArray(null);
        }
        fallbackToCSSGradient() {
          const cssFallbackVariables = {
            "--sn.bg.webgl.ready": "0",
            "--sn.bg.webgl.enabled": "0",
            "--sn.bg.active-backend": "css",
            "--sn-gradient-crossfade-opacity": "0"
            // Full CSS opacity
          };
          this.cssController.batchSetVariables(
            "WebGLGradientBackgroundSystem",
            cssFallbackVariables,
            "critical",
            // Critical priority for fallback
            "webgl-css-fallback"
          );
          if (this.cssVisualEffectsController) {
            this.startCSSFallbackAnimation();
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Using CSS gradient fallback"
          );
        }
        startCSSFallbackAnimation() {
          if (!this.cssVisualEffectsController) return;
          const animateCSS = /* @__PURE__ */ __name(() => {
            if (!this.isActive) return;
            const time = performance.now() / 1e3;
            const flowX = Math.sin(time * 0.04) * 20 + Math.sin(time * 0.07) * 8;
            const flowY = Math.cos(time * 0.05) * 20 + Math.cos(time * 0.09) * 6;
            const scale = 1.15 + Math.sin(time * 0.03) * 0.2;
            const fallbackAnimationVariables = {
              "--sn-gradient-flow-x": `${flowX}%`,
              "--sn-gradient-flow-y": `${flowY}%`,
              "--sn-gradient-flow-scale": scale.toString()
            };
            this.cssController.batchSetVariables(
              "WebGLGradientBackgroundSystem",
              fallbackAnimationVariables,
              "normal",
              // Normal priority for animation
              "css-fallback-animation"
            );
            setTimeout(animateCSS, this.frameThrottleInterval);
          }, "animateCSS");
          animateCSS();
        }
        handleSettingsChange(event) {
          super.handleSettingsChange(event);
          const customEvent = event;
          const { key, value } = customEvent.detail;
          if (key === "sn-gradient-intensity") {
            const wasEnabled = this.settings.enabled;
            this.settings.intensity = value;
            this.loadSettings();
            if (value === "disabled" && wasEnabled) {
              this.settings.enabled = false;
              this.destroy();
              this.fallbackToCSSGradient();
            } else if (this.settings.enabled && !wasEnabled && this.isWebGLAvailable) {
              this.initialize();
            }
          }
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.visualEffectsChoreographer) {
            try {
              this.visualEffectsChoreographer.unregisterVisualEffectsParticipant(
                "WebGLGradientBackgroundSystem"
              );
              Y3KDebug?.debug?.log(
                "WebGLGradientBackgroundSystem",
                "Unregistered from visualEffects choreographer"
              );
            } catch (error) {
              Y3KDebug?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Error unregistering from visualEffects choreographer:",
                error
              );
            }
          }
          if (this.textureUpdateDebounceTimer) {
            clearTimeout(this.textureUpdateDebounceTimer);
            this.textureUpdateDebounceTimer = null;
          }
          this.textureUpdatePending = false;
          this.textureCreationInProgress = false;
          this.lastColorHarmonizedData = null;
          if (this.gl) {
            if (this.gradientTexture) {
              this.gl.deleteTexture(this.gradientTexture);
              this.gradientTexture = null;
            }
            if (this.vertexBuffer) {
              this.gl.deleteBuffer(this.vertexBuffer);
              this.vertexBuffer = null;
            }
            if (this.vao) {
              this.gl.deleteVertexArray(this.vao);
              this.vao = null;
            }
            if (this.shaderProgram) {
              this.gl.deleteProgram(this.shaderProgram);
              this.shaderProgram = null;
            }
            ShaderLoader.clearCache(this.gl);
          }
          if (this.wrapper && this.wrapper.parentNode) {
            this.wrapper.parentNode.removeChild(this.wrapper);
            this.wrapper = null;
          }
          this.canvas = null;
          this.eventSubscriptionIds.forEach((subscriptionId) => {
            unifiedEventBus.unsubscribe(subscriptionId);
          });
          this.eventSubscriptionIds = [];
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Unified event subscriptions cleaned up"
          );
          window.removeEventListener("resize", this.resize);
          this.gl = null;
          const cleanupVariables = {
            "--sn.bg.webgl.ready": "0",
            "--sn.bg.webgl.enabled": "0",
            "--sn.bg.active-backend": "css",
            "--sn-gradient-crossfade-opacity": "0"
          };
          this.cssController.batchSetVariables(
            "WebGLGradientBackgroundSystem",
            cleanupVariables,
            "critical",
            // Critical priority for system cleanup
            "webgl-system-cleanup"
          );
        }
        forceRepaint(_reason = "settings-change") {
          if (this.isActive && this.gradientTexture) {
            this.updateGradientTexture().catch((error) => {
              Y3KDebug?.debug?.error(
                "WebGLGradientBackgroundSystem",
                "Failed to repaint gradient:",
                error
              );
            });
          }
        }
        // Public setters for wave parameters
        setWaveY(waveY) {
          this.settings.waveY = waveY;
        }
        setWaveHeight(waveHeight) {
          this.settings.waveHeight = waveHeight;
        }
        setWaveOffset(waveOffset) {
          this.settings.waveOffset = waveOffset;
        }
        setBlurSettings(blurExp, blurMax) {
          this.settings.blurExp = blurExp;
          this.settings.blurMax = blurMax;
        }
        getMetrics() {
          return {
            fps: this.performanceMonitor?.getMedianFPS?.() || 0,
            compileErrors: 0,
            // TODO: Track compilation errors
            isActive: this.isActive,
            settings: { ...this.settings }
          };
        }
        /**
         * ✅ RAF LOOP CONSOLIDATION: Animation loop managed by coordinator
         * No need to stop animation - coordinator handles this
         * Kept for API compatibility with backplane adapters (no-op)
         */
        stopAnimation() {
        }
        /**
         * Animation update method called by the master animation coordinator
         * This is the missing method that was causing the white background issue
         */
        updateAnimation(deltaTime) {
          if (!this.isActive || !this.gl || !this.isWebGLAvailable) {
            return;
          }
          const timestamp = performance.now();
          if (this.shouldSkipFrame(timestamp)) {
            return;
          }
          if (this.shouldUpdateTexture()) {
            if (this.currentQualityLevel !== "low") {
              this.updateGradientTextureThrottled();
            }
          }
          if (this.webglReady) {
            this.render(timestamp);
          } else {
            this.ensureBasicResources();
          }
        }
        /**
         * Check if we should skip this frame based on quality settings
         */
        shouldSkipFrame(timestamp) {
          if (!this.frameThrottleInterval) return false;
          const timeSinceLastFrame = timestamp - (this.lastFrameTime || 0);
          const shouldSkip = timeSinceLastFrame < this.frameThrottleInterval;
          if (!shouldSkip) {
            this.lastFrameTime = timestamp;
          }
          return shouldSkip;
        }
        /**
         * Check if texture should be updated based on throttling settings
         */
        shouldUpdateTexture() {
          const currentTime = performance.now();
          return currentTime - this.lastTextureUpdate >= this.textureUpdateThrottleMs;
        }
        /**
         * Ensure basic WebGL resources exist for rendering
         */
        ensureBasicResources() {
          if (!this.gl || this.contextLost) return;
          if (!this.gradientTexture) {
            try {
              const defaultStops = this.getDefaultGradientStops();
              this.gradientTexture = createGradientTexture(this.gl, defaultStops);
              if (this.gradientTexture) {
                Y3KDebug?.debug?.log(
                  "WebGLGradientBackgroundSystem",
                  "Emergency gradient texture created during animation update"
                );
              }
            } catch (error) {
              Y3KDebug?.debug?.warn(
                "WebGLGradientBackgroundSystem",
                "Failed to create emergency gradient texture:",
                error
              );
            }
          }
        }
        /**
         * IManagedSystem health check - returns health status using standard interface
         */
        async healthCheck() {
          const isHealthy = this.webglReady && this.initialized && this.isActive;
          return {
            system: "WebGLGradientBackgroundSystem",
            healthy: isHealthy,
            metrics: {
              webglReady: this.webglReady,
              initialized: this.initialized,
              active: this.isActive,
              contextLost: this.contextLost,
              canvasExists: !!this.canvas
            },
            issues: isHealthy ? [] : [
              ...this.webglReady ? [] : ["WebGL not ready"],
              ...this.initialized ? [] : ["System not initialized"],
              ...this.isActive ? [] : ["System not active"],
              ...this.contextLost ? ["WebGL context lost"] : []
            ]
          };
        }
        /**
         * Alternative resize helper that allows explicit dimensions while leaving
         * the original `resize` listener (no-arg) intact.
         */
        resizeTo(width, height) {
          if (!this.canvas) return;
          this.canvas.width = width;
          this.canvas.height = height;
          this.resize?.();
        }
        // ===================================================================
        // CONSCIOUSNESS CHOREOGRAPHER INTEGRATION
        // ===================================================================
        /**
         * Register this WebGL system as a visualEffects participant
         */
        registerWithVisualEffectsChoreographer() {
          if (!this.visualEffectsChoreographer) {
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "VisualEffects choreographer not available, skipping registration"
            );
            return;
          }
          try {
            this.visualEffectsChoreographer.registerVisualEffectsParticipant(this);
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Successfully registered with visualEffects choreographer"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Failed to register with visualEffects choreographer:",
              error
            );
          }
        }
        // ===================================================================
        // BACKGROUND SYSTEM PARTICIPANT INTERFACE IMPLEMENTATION
        // ===================================================================
        // SystemName and systemPriority already declared above
        getVisualEffectsContribution() {
          return {
            webglLuminosity: this.settings.flowStrength || 0.5,
            shaderComplexity: this.isWebGLAvailable ? 0.8 : 0,
            gpuUtilization: this.isWebGLAvailable ? 0.6 : 0,
            renderingPipeline: "forward",
            textureResolution: 1
          };
        }
        onVisualEffectsFieldUpdate(field) {
          if (!this.isWebGLAvailable || !this.webglReady) return;
          try {
            this.currentVisualEffectsField = field;
            this.updateShaderFromVisualEffects(field);
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              "Updated from visualEffects field:",
              {
                rhythmicPulse: field.pulseRate,
                webglLuminosity: field.luminosity,
                emotionalTemperature: field.colorTemperature
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Error updating from visualEffects field:",
              error
            );
          }
        }
        onChoreographyEvent(eventType, payload) {
          if (!this.isWebGLAvailable || !this.webglReady) return;
          try {
            switch (eventType) {
              case "choreography:rhythm-shift":
                this.frameThrottleInterval = 1e3 / Math.max(30, Math.min(60, payload.newRhythm?.bpm / 2 || 45));
                break;
              case "choreography:energy-surge":
                const surgeIntensity = payload.intensity || 1;
                this.cssController.setVariable(
                  "WebGLGradientBackgroundSystem",
                  "--sn-webgl-energy-surge",
                  surgeIntensity.toString(),
                  "high",
                  // High priority for energy surges
                  "choreography-energy-surge"
                );
                break;
              case "visualEffects:pulsing-cycle":
                const pulsingPhase = payload.phase || 0;
                this.cssController.setVariable(
                  "WebGLGradientBackgroundSystem",
                  "--sn-webgl-pulsing-sync",
                  pulsingPhase.toString(),
                  "normal",
                  // Normal priority for pulsing sync
                  "visualEffects-pulsing-cycle"
                );
                break;
            }
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Handled choreography event: ${eventType}`,
              payload
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              `Error handling choreography event ${eventType}:`,
              error
            );
          }
        }
        /**
         * Update WebGL shader parameters based on visualEffects field
         */
        updateShaderFromVisualEffects(field) {
          if (!this.gl || !this.shaderProgram) return;
          const consciousFlowStrength = this.settings.flowStrength * (0.5 + field.pulseRate * 0.5);
          const flowStrengthLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_flowStrength"
          );
          if (flowStrengthLocation) {
            this.gl.uniform1f(flowStrengthLocation, consciousFlowStrength);
          }
          const consciousNoiseScale = this.settings.noiseScale * (0.8 + field.flowDirection.x * 0.4);
          const noiseScaleLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_noiseScale"
          );
          if (noiseScaleLocation) {
            this.gl.uniform1f(noiseScaleLocation, consciousNoiseScale);
          }
          const pulsingModulation = Math.sin(Date.now() * 1e-3 * field.pulseRate) * 0.1;
          const waveYLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_waveY"
          );
          if (waveYLocation) {
            const modulatedWaveY = [
              this.settings.waveY[0] + pulsingModulation,
              this.settings.waveY[1] - pulsingModulation
            ];
            this.gl.uniform1fv(waveYLocation, modulatedWaveY);
          }
          const visualEffectsWebglVariables = {
            "--sn-webgl-visualEffects-flow": consciousFlowStrength.toString(),
            "--sn-webgl-visualEffects-noise": consciousNoiseScale.toString(),
            "--sn-webgl-pulsing-phase": pulsingModulation.toString()
          };
          this.cssController.batchSetVariables(
            "WebGLGradientBackgroundSystem",
            visualEffectsWebglVariables,
            "normal",
            // Normal priority for visualEffects coordination
            "visualEffects-shader-update"
          );
        }
        // ========================================================================
        // QUALITY SCALING INTERFACE IMPLEMENTATION
        // ========================================================================
        /**
         * Set quality level for WebGL rendering
         */
        /**
         * Adjust quality level (QualityScalingCapable interface)
         */
        adjustQuality(level) {
          this.setQualityLevel(level);
        }
        setQualityLevel(level) {
          this.currentQualityLevel = level;
          switch (level) {
            case "low":
              this.settings.flowStrength = 0.5;
              this.settings.noiseScale = 1;
              this.settings.waveHeight = [0.3, 0.2];
              this.settings.blurExp = 1;
              this.settings.blurMax = 0.4;
              this.frameThrottleInterval = 1e3 / 30;
              break;
            case "medium":
              this.settings.flowStrength = 0.7;
              this.settings.noiseScale = 1.2;
              this.settings.waveHeight = [0.4, 0.3];
              this.settings.blurExp = 1.2;
              this.settings.blurMax = 0.6;
              this.frameThrottleInterval = 1e3 / 45;
              break;
            case "high":
              this.settings.flowStrength = 0.9;
              this.settings.noiseScale = 1.4;
              this.settings.waveHeight = [0.5, 0.4];
              this.settings.blurExp = 1.3;
              this.settings.blurMax = 0.7;
              this.frameThrottleInterval = 1e3 / 60;
              break;
            default:
              this.settings.flowStrength = 0.7;
              this.settings.noiseScale = 1.2;
              this.settings.waveHeight = [0.4, 0.3];
              this.settings.blurExp = 1.2;
              this.settings.blurMax = 0.6;
              this.frameThrottleInterval = 1e3 / 45;
              break;
          }
          this.updateQualityCapabilities(level);
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Quality level set to: ${level}`,
            {
              flowStrength: this.settings.flowStrength,
              frameRate: 1e3 / this.frameThrottleInterval
            }
          );
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const currentFPS = this.lastFrameTime > 0 ? 1e3 / this.lastFrameTime : 60;
          const memoryUsage = this.estimateMemoryUsage();
          return {
            fps: currentFPS,
            frameTime: this.lastFrameTime,
            memoryUsage,
            cpuUsage: this.estimateCPUUsage()
          };
        }
        /**
         * Reduce quality by specified amount
         */
        reduceQuality(amount) {
          this.qualityAdjustments["flow-reduction"] = (this.qualityAdjustments["flow-reduction"] || 0) + amount;
          this.qualityAdjustments["noise-reduction"] = (this.qualityAdjustments["noise-reduction"] || 0) + amount * 0.8;
          this.qualityAdjustments["wave-reduction"] = (this.qualityAdjustments["wave-reduction"] || 0) + amount * 0.6;
          this.settings.flowStrength = Math.max(
            0.1,
            this.settings.flowStrength * (1 - amount)
          );
          this.settings.noiseScale = Math.max(
            0.5,
            this.settings.noiseScale * (1 - amount * 0.8)
          );
          this.settings.waveHeight = [
            Math.max(0.1, this.settings.waveHeight[0] * (1 - amount * 0.6)),
            Math.max(0.1, this.settings.waveHeight[1] * (1 - amount * 0.6))
          ];
          if (amount > 0.5) {
            this.frameThrottleInterval = Math.min(
              1e3 / 15,
              this.frameThrottleInterval * (1 + amount)
            );
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Quality reduced by ${amount}`,
            this.settings
          );
        }
        /**
         * Increase quality by specified amount
         */
        increaseQuality(amount) {
          Object.keys(this.qualityAdjustments).forEach((key) => {
            this.qualityAdjustments[key] = Math.max(
              0,
              (this.qualityAdjustments[key] || 0) - amount
            );
          });
          if (this.currentQualityLevel) {
            const baseSettings = this.getBaseSettingsForLevel(this.currentQualityLevel) || this.settings;
            this.settings.flowStrength = Math.min(
              baseSettings.flowStrength,
              this.settings.flowStrength * (1 + amount * 0.5)
            );
            this.settings.noiseScale = Math.min(
              baseSettings.noiseScale,
              this.settings.noiseScale * (1 + amount * 0.3)
            );
            const targetFPS = this.currentQualityLevel === "high" ? 60 : this.currentQualityLevel === "medium" ? 45 : 30;
            this.frameThrottleInterval = Math.max(
              1e3 / targetFPS,
              this.frameThrottleInterval * (1 - amount * 0.3)
            );
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Quality increased by ${amount}`,
            this.settings
          );
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          return [...this.qualityCapabilities];
        }
        // ========================================================================
        // QUALITY SCALING HELPER METHODS
        // ========================================================================
        updateQualityCapabilities(level) {
          this.qualityCapabilities.forEach((capability) => {
            switch (capability.name) {
              case "webgl-rendering":
                capability.enabled = true;
                break;
              case "shader-complexity":
                capability.enabled = level === "high" || level === "medium";
                break;
              case "blur-effects":
                capability.enabled = level !== "low";
                break;
              case "corridor-effects":
                capability.enabled = level !== "low";
                if (level === "low" && this.settings.corridorEnabled) {
                  this.settings.corridorEnabled = false;
                }
                break;
              case "corridor-sdf-complexity":
                const sdfAdjustment = level === "high" ? 1 : level === "medium" ? 0.8 : 0.6;
                this.settings.corridorBubbleScale = Math.max(0.5, 1 * sdfAdjustment);
                capability.enabled = level !== "low";
                break;
              case "corridor-bubble-layers":
                const layerAdjustment = level === "high" ? 1 : level === "medium" ? 0.8 : 0.6;
                this.settings.corridorIntensity = Math.max(0.3, 0.8 * layerAdjustment);
                capability.enabled = level === "high" || level === "medium";
                break;
              case "corridor-depth-effects":
                const depthAdjustment = level === "high" ? 1 : level === "medium" ? 0.7 : 0.4;
                this.settings.corridorDepthEffect = Math.max(0.1, 0.6 * depthAdjustment);
                capability.enabled = level !== "low";
                break;
              default:
                capability.enabled = level !== "low";
            }
          });
        }
        getBaseSettingsForLevel(level) {
          const baseSettings = { ...this.settings };
          switch (level) {
            case "minimal":
              return {
                ...baseSettings,
                flowStrength: 0.3,
                noiseScale: 0.8,
                corridorEnabled: false,
                corridorIntensity: 0.3,
                corridorFlowStrength: 0.5,
                corridorDepthEffect: 0.2,
                corridorBubbleScale: 0.5
              };
            case "low":
              return {
                ...baseSettings,
                flowStrength: 0.5,
                noiseScale: 1,
                corridorEnabled: false,
                corridorIntensity: 0.4,
                corridorFlowStrength: 0.8,
                corridorDepthEffect: 0.3,
                corridorBubbleScale: 0.6
              };
            case "medium":
              return {
                ...baseSettings,
                flowStrength: 0.7,
                noiseScale: 1.2,
                corridorEnabled: true,
                corridorIntensity: 0.6,
                corridorFlowStrength: 1,
                corridorDepthEffect: 0.5,
                corridorBubbleScale: 0.8
              };
            case "high":
              return {
                ...baseSettings,
                flowStrength: 0.9,
                noiseScale: 1.4,
                corridorEnabled: true,
                corridorIntensity: 0.8,
                corridorFlowStrength: 1.2,
                corridorDepthEffect: 0.6,
                corridorBubbleScale: 1
              };
            case "ultra":
              return {
                ...baseSettings,
                flowStrength: 1,
                noiseScale: 1.6,
                corridorEnabled: true,
                corridorIntensity: 1,
                corridorFlowStrength: 1.4,
                corridorDepthEffect: 0.8,
                corridorBubbleScale: 1.2
              };
            default:
              return baseSettings;
          }
        }
        // ========================================================================
        // PUBLIC CORRIDOR CONTROL METHODS
        // ========================================================================
        /**
         * Enable or disable corridor bubble effects
         * @param enabled Whether to enable corridor effects
         */
        setCorridorEffectsEnabled(enabled) {
          this.settings.corridorEnabled = enabled && this.corridorShaderProgram !== null;
          this.cssController.setVariable(
            "WebGLGradientBackgroundSystem",
            "--sn-corridor-enabled",
            enabled ? "1" : "0",
            "normal",
            // Normal priority for corridor settings
            "corridor-settings-update"
          );
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            `Corridor effects ${enabled ? "enabled" : "disabled"}`
          );
        }
        /**
         * Update corridor settings for runtime adjustment
         * @param settings Partial corridor settings to update
         */
        updateCorridorSettings(settings2) {
          if (settings2.corridorIntensity !== void 0) {
            this.settings.corridorIntensity = Math.max(0, Math.min(1, settings2.corridorIntensity));
          }
          if (settings2.corridorFlowStrength !== void 0) {
            this.settings.corridorFlowStrength = Math.max(0, Math.min(2, settings2.corridorFlowStrength));
          }
          if (settings2.corridorDepthEffect !== void 0) {
            this.settings.corridorDepthEffect = Math.max(0, Math.min(1, settings2.corridorDepthEffect));
          }
          if (settings2.corridorBubbleScale !== void 0) {
            this.settings.corridorBubbleScale = Math.max(0.1, Math.min(2, settings2.corridorBubbleScale));
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientBackgroundSystem",
            "Corridor settings updated",
            settings2
          );
        }
        estimateMemoryUsage() {
          let usage = 5;
          if (this.canvas && this.gl) {
            const pixels = this.canvas.width * this.canvas.height;
            usage += pixels * 4 / (1024 * 1024);
            if (this.gradientTexture) usage += 1;
            if (this.vertexBuffer) usage += 0.1;
          }
          return usage;
        }
        estimateCPUUsage() {
          const baseUsage = this.isWebGLAvailable ? 5 : 15;
          const qualityMultiplier = this.settings.flowStrength + this.settings.noiseScale / 2;
          return Math.min(50, baseUsage * qualityMultiplier);
        }
        /**
         * Get simplified fragment shader without complex noise functions
         * Falls back to simpler gradient calculations for better compatibility
         */
        getSimplifiedFragmentShader() {
          return `#version 300 es
      precision highp float;

      in vec2 vTextureCoords;
      out vec4 fragColor;

      uniform sampler2D u_gradientTexture;
      uniform float u_time;
      uniform float u_intensity;
      uniform float u_flowStrength;
      uniform vec2 u_resolution;

      // Simplified noise function - uses basic sin/cos instead of complex noise
      float simpleNoise(vec2 st) {
        return sin(st.x * 12.9898 + st.y * 78.233) * 43758.5453;
      }

      void main() {
        vec2 uv = vTextureCoords;
        
        // Simple flow effect without complex noise
        vec2 flow = vec2(
          sin(u_time * 0.5 + uv.y * 3.0) * 0.1,
          cos(u_time * 0.3 + uv.x * 2.0) * 0.1
        ) * u_flowStrength;
        
        // Apply flow offset
        vec2 flowUV = uv + flow;
        
        // Simple gradient lookup with basic distortion
        vec4 gradientColor = texture(u_gradientTexture, flowUV);
        
        // Simple intensity modulation
        float intensity = u_intensity * (0.8 + 0.2 * sin(u_time + uv.x + uv.y));
        
        fragColor = vec4(gradientColor.rgb * intensity, gradientColor.a);
      }`;
        }
        /**
         * Get basic fragment shader with minimal features
         * Fallback for very limited GPU capabilities
         */
        getBasicFragmentShader() {
          return `#version 300 es
      precision mediump float;

      in vec2 vTextureCoords;
      out vec4 fragColor;

      uniform sampler2D u_gradientTexture;
      uniform float u_intensity;

      void main() {
        vec2 uv = vTextureCoords;
        
        // Basic gradient lookup without any effects
        vec4 gradientColor = texture(u_gradientTexture, uv);
        
        // Simple intensity scaling
        fragColor = vec4(gradientColor.rgb * u_intensity, gradientColor.a);
      }`;
        }
        /**
         * Get emergency fragment shader - absolute minimum for hardware compatibility
         * Ultra-basic solid color with minimal gradient interpolation
         */
        getEmergencyFragmentShader() {
          return `#version 300 es
      precision lowp float;

      in vec2 vTextureCoords;
      out vec4 fragColor;

      uniform sampler2D u_gradientTexture;

      void main() {
        // Ultra-simple gradient lookup with minimal processing
        // Use lowp precision for maximum compatibility
        vec2 uv = vTextureCoords;
        
        // Simple gradient sample - no effects, no animations
        vec4 color = texture(u_gradientTexture, uv);
        
        // Emergency mode: ensure we always output something visible
        // Fallback to magenta if texture fails (indicates shader compilation success)
        if (color.a < 0.01) {
          fragColor = vec4(0.2, 0.1, 0.3, 1.0); // Dark purple fallback
        } else {
          fragColor = color;
        }
      }`;
        }
        /**
         * Check if WebGL should persist based on settings and never fallback to CSS
         */
        shouldPersistWebGL() {
          if (this.settings.webglPersistenceMode === "persistent") {
            return true;
          }
          if (this.settings.webglPersistenceMode === "fallback") {
            return false;
          }
          return this.settings.webglPersistenceMode === "adaptive" && this.settings.enabled && this.isWebGLAvailable;
        }
        /**
         * Determine if we should attempt WebGL recovery vs CSS fallback
         */
        shouldAttemptWebGLRecovery() {
          return this.shouldPersistWebGL();
        }
        // ============================================================================
        // CONTINUOUS QUALITY SCALING IMPLEMENTATION
        // ============================================================================
        /**
         * Apply continuous quality level (0-100) to WebGL system
         * Implements ContinuousQualityScalingCapable interface
         */
        applyContinuousQuality(qualityLevel) {
          try {
            const level = qualityLevel;
            Y3KDebug?.debug?.log(
              "WebGLGradientBackgroundSystem",
              `Applying simplified quality level: ${level}`
            );
            this.setQualityLevel(level);
            this.cssController.batchSetVariables(
              "WebGLGradientBackgroundSystem",
              {
                "--sn-webgl-quality-level": level,
                "--sn-webgl-corridor-enabled": this.settings.corridorEnabled ? "1" : "0"
              },
              "high",
              "continuous-quality-update"
            );
            if (this.initialized && this.gl) {
              this.forceRepaint("quality-level-changed");
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientBackgroundSystem",
              "Failed to apply continuous quality:",
              error
            );
          }
        }
        /**
         * Get current performance impact of the WebGL system
         * Implements ContinuousQualityScalingCapable interface
         */
        getCurrentQualityImpact() {
          const isWebGLActive = this.gl !== null && this.isWebGLAvailable;
          const hasCorridorEffects = this.settings.corridorEnabled && this.corridorShaderProgram !== null;
          const baseCPU = isWebGLActive ? 0.15 : 0.05;
          const baseMemory = isWebGLActive ? 0.1 : 0.03;
          const baseGPU = isWebGLActive ? 0.2 : 0;
          const corridorCPU = hasCorridorEffects ? 0.1 : 0;
          const corridorMemory = hasCorridorEffects ? 0.05 : 0;
          const corridorGPU = hasCorridorEffects ? 0.15 : 0;
          const animationMultiplier = Math.max(0.5, this.settings.flowStrength / 2);
          let estimatedFPS = 60;
          if (hasCorridorEffects) estimatedFPS -= 10;
          if (this.settings.intensity === "intense") estimatedFPS -= 5;
          estimatedFPS = Math.max(30, estimatedFPS);
          return {
            cpu: Math.min(1, (baseCPU + corridorCPU) * animationMultiplier),
            memory: Math.min(1, (baseMemory + corridorMemory) * animationMultiplier),
            gpu: Math.min(1, (baseGPU + corridorGPU) * animationMultiplier),
            estimatedFPS
          };
        }
        // =========================================================================
        // BACKGROUND SYSTEM PARTICIPANT INTERFACE
        // =========================================================================
        onVisualStateUpdate(state) {
          this.onVisualEffectsFieldUpdate(state);
        }
        onVisualEffectEvent(eventType, payload) {
          switch (eventType) {
            case "visual:rhythm-shift":
              if (payload.intensity) {
                this.settings.flowStrength = Math.min(5, payload.intensity * 3);
              }
              break;
            case "visual:color-shift":
              this.forceRepaint("color-shift");
              break;
            case "visual:energy-surge":
              if (payload.intensity > 0.7) {
                this.forceRepaint("energy-surge");
              }
              break;
          }
        }
        getVisualContribution() {
          return {
            luminosity: this.settings.intensity === "intense" ? 0.8 : 0.5,
            fluidIntensity: this.settings.flowStrength / 5,
            effectDepth: this.getCurrentQualityImpact().cpu
          };
        }
      };
      __name(_WebGLGradientBackgroundSystem, "WebGLGradientBackgroundSystem");
      WebGLGradientBackgroundSystem = _WebGLGradientBackgroundSystem;
    }
  });

  // src-js/visual/backgrounds/FluidGradientBackgroundSystem.ts
  var liquidVisualEffectsShader, _FluidGradientBackgroundSystem, FluidGradientBackgroundSystem;
  var init_FluidGradientBackgroundSystem = __esm({
    "src-js/visual/backgrounds/FluidGradientBackgroundSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_ShaderLoader();
      init_BaseVisualSystem();
      init_WebGLRenderer();
      liquidVisualEffectsShader = `#version 300 es
precision mediump float;

uniform float u_time;
uniform sampler2D u_gradientTex;
uniform vec2 u_resolution;
uniform float u_flowStrength;
uniform float u_noiseScale;

// Enhanced liquid visual effects uniforms
uniform float u_liquidPhase;
uniform float u_animationIntensity;
uniform float u_auroraFlow;
uniform vec2 u_flowDirection;
uniform float u_liquidTurbulence;
uniform float u_visualEffectsDepth;

// Advanced liquid physics uniforms
uniform float u_surfaceTension;
uniform float u_viscosity;
uniform float u_liquidGravity;
uniform float u_particleDensity;
uniform float u_fluidDynamics;
uniform float u_surfaceElasticity;
uniform vec2 u_liquidVelocity;
uniform float u_visualEffectsTemperature;

// Music sync uniforms
uniform float u_musicEnergy;
uniform float u_musicValence;
uniform float u_beatIntensity;
uniform float u_bassResponse;
uniform float u_genreInfluence;
uniform float u_emotionalTemperature;

// Multi-layer visual effects uniforms
uniform float u_visualEffectsLevel;
uniform float u_activityLevel;
uniform float u_memoryIntensity;
uniform float u_temporalFlowStrength;

// Wave stack uniforms
uniform float u_waveY[3];
uniform float u_waveHeight[3];
uniform float u_waveOffset[3];
uniform float u_blurExp;
uniform float u_blurMax;

out vec4 fragColor;

// Improved simplex noise with liquid visualEffects modifications
vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
  vec2 i = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);
  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod289(i);
  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m;
  m = m*m;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
  vec3 g;
  g.x = a0.x * x0.x + h.x * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// Advanced liquid physics simulation functions
float calculateSurfaceTension(vec2 uv, float baseValue) {
  // Surface tension creates natural droplet boundaries
  float distance = length(uv - 0.5);
  float tensionEffect = smoothstep(0.3, 0.7, distance) * u_surfaceTension;
  return baseValue * (1.0 + tensionEffect * 0.3);
}

vec2 calculateViscosityFlow(vec2 uv, vec2 baseFlow, float timeOffset) {
  // Viscosity affects flow resistance and creates more dynamic movement
  float viscosityResistance = 1.0 - u_viscosity * 0.8;
  vec2 viscousFlow = baseFlow * viscosityResistance;
  
  // Add viscous swirl patterns
  float swirl = sin(u_time * 0.1 + timeOffset + length(uv - 0.5) * 10.0) * u_viscosity * 0.2;
  viscousFlow += vec2(-swirl * (uv.y - 0.5), swirl * (uv.x - 0.5));
  
  return viscousFlow;
}

float simulateGravityEffect(vec2 uv, float baseIntensity) {
  // Gravity creates natural settling patterns
  float gravityInfluence = (1.0 - uv.y) * u_liquidGravity;
  float settlingPattern = sin(u_time * 0.05 + uv.x * 5.0) * gravityInfluence * 0.1;
  return baseIntensity + settlingPattern;
}

// Enhanced liquid visual effects noise with advanced physics
float liquidVisualEffectsNoise(vec2 uv, float timeOffset) {
  vec2 flowUV = uv;
  float adjustedTime = u_time + timeOffset;

  // Enhanced liquid flow with physics simulation
  vec2 musicFlowDirection = normalize(u_flowDirection + vec2(
    sin(adjustedTime * 0.1 + u_musicEnergy * 2.0) * u_musicValence,
    cos(adjustedTime * 0.15 + u_musicEnergy * 1.5) * u_musicValence
  ));
  
  // Apply viscosity to flow
  vec2 viscousFlow = calculateViscosityFlow(uv, musicFlowDirection, timeOffset);
  
  // Add liquid velocity for momentum
  viscousFlow += u_liquidVelocity * 0.5;

  // Enhanced animation effect with visualEffects depth
  float animationPhase = sin(adjustedTime * 0.05 + u_liquidPhase) * u_animationIntensity;
  float visualEffectsWave = sin(adjustedTime * 0.02 + u_visualEffectsDepth) * 0.3;
  
  // VisualEffects memory patterns
  float memoryPattern = sin(adjustedTime * 0.008 + u_memoryIntensity * 5.0) * 0.15;
  
  // Temporal flow effects
  float temporalDistortion = sin(adjustedTime * 0.12 + u_temporalFlowStrength * 3.0) * 0.1;

  // Aurora flow patterns with enhanced physics
  flowUV += viscousFlow * adjustedTime * 0.03 * u_auroraFlow;
  flowUV += vec2(
    sin(adjustedTime * 0.04 + uv.y * 6.28) * (animationPhase + memoryPattern),
    cos(adjustedTime * 0.03 + uv.x * 6.28) * (animationPhase + temporalDistortion)
  ) * 0.02;

  // Enhanced turbulence with particle density
  vec2 turbulenceUV = flowUV * u_liquidTurbulence;
  float particleInfluence = u_particleDensity * 0.3;
  float turbulence1 = snoise(turbulenceUV + adjustedTime * 0.01) * (1.0 + particleInfluence);
  float turbulence2 = snoise(turbulenceUV * 2.0 + adjustedTime * 0.02) * (1.0 + particleInfluence * 0.5);
  
  // Fluid dynamics creates more complex flow patterns
  float fluidDynamicsEffect = snoise(flowUV * 3.0 + adjustedTime * 0.005) * u_fluidDynamics;

  // Multi-octave liquid noise with visualEffects layers
  float noise1 = snoise(flowUV * u_noiseScale + turbulence1 * 0.1) * u_visualEffectsLevel;
  float noise2 = snoise(flowUV * u_noiseScale * 2.0 + turbulence2 * 0.05) * u_activityLevel;
  float noise3 = snoise(flowUV * u_noiseScale * 0.5 + visualEffectsWave) * (1.0 - u_visualEffectsLevel * 0.3);
  float memoryNoise = snoise(flowUV * u_noiseScale * 1.5 + memoryPattern) * u_memoryIntensity * 0.3;

  // Apply surface tension effects
  float surfaceTensionEffect = calculateSurfaceTension(uv, 1.0);
  
  // Apply gravity settling
  float gravityEffect = simulateGravityEffect(uv, 1.0);

  // Blend with enhanced music and visualEffects responsiveness
  float baseNoise = (noise1 * 0.4 + noise2 * 0.3 + noise3 * 0.2 + memoryNoise * 0.1) * surfaceTensionEffect * gravityEffect;
  baseNoise += fluidDynamicsEffect * 0.1;
  
  // Enhanced musical modulation with genre influence
  float musicModulation = u_beatIntensity * 0.2 + u_bassResponse * 0.1 + u_genreInfluence * 0.05;
  
  // Emotional temperature affects liquid characteristics
  float temperatureEffect = mix(0.8, 1.2, u_emotionalTemperature);

  return clamp((baseNoise + musicModulation) * temperatureEffect * 0.5 + 0.5, 0.0, 1.0);
}

// Advanced liquid wave physics with surface elasticity
float liquidWaveAlpha(vec2 uv, int waveIndex) {
  float y = uv.y;
  float waveCenter = u_waveY[waveIndex];
  float waveHeight = u_waveHeight[waveIndex];

  // Enhanced animation modulation with visualEffects memory
  float animationMod = sin(u_time * 0.1 + float(waveIndex) * 2.0) * u_animationIntensity * 0.2;
  float visualEffectsBreathing = sin(u_time * 0.06 + u_visualEffectsLevel * 3.0) * 0.15;
  float memoryBreathing = sin(u_time * 0.04 + u_memoryIntensity * 2.0) * 0.1;
  
  float totalBreathing = animationMod + visualEffectsBreathing + memoryBreathing;
  float adjustedWaveHeight = waveHeight * (1.0 + totalBreathing);

  // Enhanced liquid distortion with surface elasticity
  float surfaceElastic = snoise(vec2(uv.x * 6.0 + u_time * 0.3, uv.y * 4.0)) * u_surfaceElasticity * 0.08;
  float liquidDistortion = snoise(vec2(uv.x * 8.0, u_time * 0.5)) * 0.05 * u_liquidTurbulence;
  float fluidDeformation = sin(uv.x * 10.0 + u_time * 0.7) * u_fluidDynamics * 0.03;
  
  float totalDistortion = liquidDistortion + surfaceElastic + fluidDeformation;
  float adjustedWaveCenter = waveCenter + totalDistortion;

  // Surface tension creates natural wave boundaries
  float distance = abs(y - adjustedWaveCenter);
  float tensionSmoothness = mix(0.3, 0.7, u_surfaceTension);
  float alpha = 1.0 - smoothstep(0.0, adjustedWaveHeight * tensionSmoothness, distance);

  // Enhanced shimmer with visualEffects and emotional temperature
  float baseShimmer = sin(u_time * 2.0 + uv.x * 20.0) * 0.1 + 0.9;
  float visualEffectsShimmer = sin(u_time * 1.5 + uv.y * 15.0 + u_visualEffectsLevel * 5.0) * 0.05 + 0.975;
  float temperatureShimmer = mix(0.95, 1.05, u_emotionalTemperature);
  
  alpha *= baseShimmer * visualEffectsShimmer * temperatureShimmer;

  // Viscosity affects wave edge softness
  alpha = mix(alpha, smoothstep(0.2, 0.8, alpha), u_viscosity);

  return clamp(alpha, 0.0, 1.0);
}

// Dynamic blur with visualEffects depth
float liquidBlur(vec2 uv) {
  vec2 center = vec2(0.5, 0.5);
  float distance = length(uv - center);

  // VisualEffects depth affects blur
  float depthModulation = sin(u_time * 0.08 + u_visualEffectsDepth) * 0.2 + 0.8;
  float adjustedBlurExp = u_blurExp * depthModulation;

  float blur = pow(distance, adjustedBlurExp);
  blur = clamp(blur, 0.0, u_blurMax);

  return blur;
}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;

  // Generate enhanced liquid visualEffects noise fields with physics
  float liquidNoise1 = liquidVisualEffectsNoise(uv, u_waveOffset[0]);
  float liquidNoise2 = liquidVisualEffectsNoise(uv, u_waveOffset[1]);
  float liquidNoise3 = liquidVisualEffectsNoise(uv, u_waveOffset[2]);

  // Calculate advanced liquid wave alphas with physics simulation
  float alpha1 = liquidWaveAlpha(uv, 0);
  float alpha2 = liquidWaveAlpha(uv, 1);
  float alpha3 = liquidWaveAlpha(uv, 2);

  // Enhanced normalization with particle density influence
  float totalAlpha = alpha1 + alpha2 + alpha3;
  float particleWeight = 1.0 + u_particleDensity * 0.3;
  if (totalAlpha > 0.0) {
    alpha1 = (alpha1 / totalAlpha) * particleWeight;
    alpha2 = (alpha2 / totalAlpha) * particleWeight;
    alpha3 = (alpha3 / totalAlpha) * particleWeight;
  }

  // Blend liquid visualEffects noise fields with physics
  float t = liquidNoise1 * alpha1 + liquidNoise2 * alpha2 + liquidNoise3 * alpha3;
  
  // Apply visualEffects temperature modulation
  t = mix(t * 0.8, t * 1.2, u_visualEffectsTemperature);
  t = clamp(t, 0.0, 1.0);

  // Sample gradient texture with enhanced visualEffects modulation
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));

  // Apply dynamic blur with visualEffects awareness
  float blurAmount = liquidBlur(uv);
  float visualEffectsBlur = mix(blurAmount, blurAmount * 0.5, u_visualEffectsLevel);

  // Enhanced vignette with visualEffects memory patterns
  vec2 center = uv - 0.5;
  float animationVignette = sin(u_time * 0.06 + u_liquidPhase) * 0.1 + 0.9;
  float visualEffectsVignette = sin(u_time * 0.04 + u_visualEffectsLevel * 3.0) * 0.05 + 0.975;
  float memoryVignette = sin(u_time * 0.03 + u_memoryIntensity * 2.0) * 0.03 + 0.985;
  
  float combinedVignette = animationVignette * visualEffectsVignette * memoryVignette;
  float vignette = combinedVignette - dot(center, center) * (0.3 + visualEffectsBlur * 0.2);
  color.rgb *= vignette;

  // Enhanced shimmer overlay with visualEffects patterns
  float shimmerPhase = u_time * 3.0 + uv.x * 15.0 + uv.y * 10.0;
  float baseShimmer = sin(shimmerPhase) * 0.03 + 0.97;
  float awarenessShimmer = sin(u_time * 2.5 + uv.x * 12.0 + u_activityLevel * 8.0) * 0.02 + 0.98;
  float temporalShimmer = sin(u_time * 1.8 + u_temporalFlowStrength * 6.0) * 0.015 + 0.985;
  
  color.rgb *= baseShimmer * awarenessShimmer * temporalShimmer;

  // Enhanced music-responsive alpha with visualEffects integration
  float musicAlpha = 0.8 + u_beatIntensity * 0.2 + u_bassResponse * 0.1 + u_genreInfluence * 0.05;
  float visualEffectsAlpha = 0.9 + u_visualEffectsLevel * 0.1 - u_activityLevel * 0.05;
  
  color.a *= musicAlpha * visualEffectsAlpha * (1.0 - visualEffectsBlur * 0.3);

  // Apply emotional temperature to final color
  color.rgb = mix(
    color.rgb * vec3(0.9, 0.95, 1.1),  // Cool temperature
    color.rgb * vec3(1.1, 1.05, 0.9),  // Warm temperature
    u_emotionalTemperature
  );

  fragColor = color;
}`;
      _FluidGradientBackgroundSystem = class _FluidGradientBackgroundSystem extends BaseVisualSystem {
        constructor(config = ADVANCED_SYSTEM_CONFIG, utils, performanceMonitor, musicSyncService = null, settingsManager2 = null, year3000System = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this.shaderProgram = null;
          this.gl = null;
          // Unified event subscriptions
          this.eventSubscriptionIds = [];
          this.animationPhase = 0;
          this.lastMusicUpdate = 0;
          // VisualEffects choreographer integration
          this.visualEffectsChoreographer = null;
          this.currentVisualEffectsField = null;
          // Make systemName publicly accessible for the interface
          this.systemName = "FluidGradientBackgroundSystem";
          this.webglGradientSystem = new WebGLGradientBackgroundSystem(
            config,
            utils,
            performanceMonitor,
            musicSyncService,
            settingsManager2,
            year3000System
          );
          this.visualEffectsChoreographer = year3000System?.backgroundVisualEffectsChoreographer || null;
          this.liquidSettings = {
            enabled: true,
            liquidPhase: 0,
            animationIntensity: 0.8,
            auroraFlow: 0.6,
            flowDirection: [1, 0.5],
            liquidTurbulence: 1.2,
            visualEffectsDepth: 0.7,
            // Enhanced liquid physics properties
            surfaceTension: 0.6,
            // Moderate surface tension for natural boundaries
            viscosity: 0.4,
            // Medium viscosity for smooth flow
            liquidGravity: 0.3,
            // Light gravitational settling
            particleDensity: 0.5,
            // Balanced particle concentration
            smoothDynamics: 0.7,
            // Rich smooth behavior patterns
            surfaceElasticity: 0.5,
            // Flexible surface boundaries
            liquidVelocity: [0, 0],
            // Initial velocity state
            visualEffectsTemperature: 0.5,
            // Neutral visualEffects temperature
            // Enhanced visualEffects properties  
            visualEffectsLevel: 0.7,
            // High visualEffects integration
            awarenessLevel: 0.6,
            // Good awareness depth
            memoryIntensity: 0.4,
            // Moderate visualEffects memory
            temporalFlowStrength: 0.5,
            // Balanced temporal effects
            // Enhanced musical visualEffects
            genreInfluence: 0.3,
            // Moderate genre-specific adaptations
            emotionalTemperature: 0.5,
            // Neutral emotional temperature
            // Quality scaling properties (defaults to medium quality)
            flowIntensity: 0.7,
            turbulenceScale: 0.9,
            colorMixingStrength: 0.8,
            animationSpeed: 1
          };
          this.liquidUniforms = {
            u_time: null,
            u_gradientTex: null,
            u_resolution: null,
            u_flowStrength: null,
            u_noiseScale: null,
            u_liquidPhase: null,
            u_animationIntensity: null,
            u_auroraFlow: null,
            u_flowDirection: null,
            u_liquidTurbulence: null,
            u_visualEffectsDepth: null,
            u_surfaceTension: null,
            u_viscosity: null,
            u_liquidGravity: null,
            u_particleDensity: null,
            u_smoothDynamics: null,
            u_surfaceElasticity: null,
            u_liquidVelocity: null,
            u_visualEffectsTemperature: null,
            u_musicEnergy: null,
            u_musicValence: null,
            u_beatIntensity: null,
            u_bassResponse: null,
            u_genreInfluence: null,
            u_emotionalTemperature: null,
            u_visualEffectsLevel: null,
            u_activityLevel: null,
            u_memoryIntensity: null,
            u_temporalFlowStrength: null,
            u_waveY: null,
            u_waveHeight: null,
            u_waveOffset: null,
            u_blurExp: null,
            u_blurMax: null
          };
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          await this.webglGradientSystem.initialize();
          this.gl = this.webglGradientSystem.gl;
          if (!this.gl) {
            Y3KDebug?.debug?.log(
              "FluidGradientBackgroundSystem",
              "WebGL not available, using base system"
            );
            return;
          }
          try {
            await this.compileLiquidShader();
            this.setupLiquidUniforms();
            this.subscribeToUnifiedEvents();
            this.registerWithVisualEffectsChoreographer();
            Y3KDebug?.debug?.log(
              "FluidGradientBackgroundSystem",
              "Liquid visualEffects system initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "FluidGradientBackgroundSystem",
              "Failed to initialize liquid visualEffects:",
              error
            );
          }
        }
        async compileLiquidShader() {
          if (!this.gl) throw new Error("WebGL context not available");
          const vertexShader = ShaderLoader.loadVertex(
            this.gl,
            `#version 300 es
      in vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `
          );
          const fragmentShader = ShaderLoader.loadFragment(
            this.gl,
            liquidVisualEffectsShader
          );
          if (!vertexShader || !fragmentShader) {
            throw new Error("Failed to compile liquid visualEffects shaders");
          }
          this.shaderProgram = ShaderLoader.createProgram(
            this.gl,
            vertexShader,
            fragmentShader
          );
          if (!this.shaderProgram) {
            throw new Error("Failed to create liquid visualEffects shader program");
          }
        }
        setupLiquidUniforms() {
          if (!this.gl || !this.shaderProgram) return;
          const uniformNames = [
            "u_time",
            "u_gradientTex",
            "u_resolution",
            "u_flowStrength",
            "u_noiseScale",
            "u_liquidPhase",
            "u_animationIntensity",
            "u_auroraFlow",
            "u_flowDirection",
            "u_liquidTurbulence",
            "u_visualEffectsDepth",
            "u_musicEnergy",
            "u_musicValence",
            "u_beatIntensity",
            "u_bassResponse",
            "u_waveY",
            "u_waveHeight",
            "u_waveOffset",
            "u_blurExp",
            "u_blurMax",
            // Advanced liquid physics properties
            "u_surfaceTension",
            "u_viscosity",
            "u_liquidGravity",
            "u_particleDensity",
            "u_surfaceElasticity",
            "u_smoothDynamics",
            "u_visualEffectsLevel",
            "u_visualEffectsTemperature",
            "u_memoryIntensity",
            "u_emotionalTemperature",
            "u_genreInfluence"
          ];
          uniformNames.forEach((name) => {
            this.liquidUniforms[name] = this.gl.getUniformLocation(
              this.shaderProgram,
              name
            );
          });
        }
        subscribeToUnifiedEvents() {
          const beatSubscription = unifiedEventBus.subscribe(
            "music:beat",
            this.handleMusicBeat.bind(this),
            "FluidGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(beatSubscription);
          const energySubscription = unifiedEventBus.subscribe(
            "music:energy",
            this.handleMusicEnergy.bind(this),
            "FluidGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(energySubscription);
          const stateSubscription = unifiedEventBus.subscribe(
            "music:state-changed",
            this.handleMusicStateChange.bind(this),
            "FluidGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(stateSubscription);
          const colorSubscription = unifiedEventBus.subscribe(
            "colors:harmonized",
            this.handleColorHarmonized.bind(this),
            "FluidGradientBackgroundSystem"
          );
          this.eventSubscriptionIds.push(colorSubscription);
          Y3KDebug?.debug?.log(
            "FluidGradientBackgroundSystem",
            "Subscribed to unified events",
            {
              subscriptionCount: this.eventSubscriptionIds.length
            }
          );
        }
        handleMusicBeat(data) {
          const currentTime = performance.now();
          if (currentTime - this.lastMusicUpdate < 33) return;
          this.lastMusicUpdate = currentTime;
          this.animationPhase += 0.1;
          this.updateFlowDirection(data.intensity);
          Y3KDebug?.debug?.log(
            "FluidGradientBackgroundSystem",
            "Music beat processed",
            {
              bpm: data.bpm,
              intensity: data.intensity,
              confidence: data.confidence
            }
          );
        }
        handleMusicEnergy(data) {
          this.liquidSettings.animationIntensity = 0.5 + data.energy * 0.5;
          this.liquidSettings.auroraFlow = 0.4 + data.valence * 0.6;
          Y3KDebug?.debug?.log(
            "FluidGradientBackgroundSystem",
            "Music energy processed",
            {
              energy: data.energy,
              valence: data.valence,
              tempo: data.tempo
            }
          );
        }
        handleMusicStateChange(data) {
          if (data.isPlaying) {
            this.liquidSettings.visualEffectsDepth = Math.max(
              0.7,
              this.liquidSettings.visualEffectsDepth
            );
          } else {
            this.liquidSettings.visualEffectsDepth = Math.min(
              0.3,
              this.liquidSettings.visualEffectsDepth
            );
          }
          Y3KDebug?.debug?.log(
            "FluidGradientBackgroundSystem",
            "Music state change processed",
            {
              isPlaying: data.isPlaying,
              position: data.position,
              duration: data.duration
            }
          );
        }
        handleColorHarmonized(data) {
          const strategyCount = data.strategies.length;
          this.liquidSettings.liquidTurbulence = Math.max(
            0.8,
            Math.min(1.5, strategyCount * 0.3)
          );
          Y3KDebug?.debug?.log(
            "FluidGradientBackgroundSystem",
            "Color harmonization processed",
            {
              strategies: data.strategies,
              processingTime: data.processingTime,
              turbulenceAdjustment: this.liquidSettings.liquidTurbulence
            }
          );
        }
        updateFlowDirection(intensity) {
          const phase = this.animationPhase;
          this.liquidSettings.flowDirection = [
            Math.sin(phase * 0.3) * intensity,
            Math.cos(phase * 0.2) * intensity
          ];
        }
        updateAnimation(deltaTime) {
          this.webglGradientSystem?.updateAnimation?.(deltaTime);
          this.liquidSettings.liquidPhase += deltaTime * 1e-3;
          this.liquidSettings.visualEffectsDepth = 0.5 + Math.sin(this.liquidSettings.liquidPhase * 0.5) * 0.3;
          if (this.gl && this.shaderProgram) {
            this.updateLiquidUniforms();
          }
        }
        updateLiquidUniforms() {
          if (!this.gl || !this.shaderProgram) return;
          this.gl.useProgram(this.shaderProgram);
          if (this.liquidUniforms.u_liquidPhase) {
            this.gl.uniform1f(
              this.liquidUniforms.u_liquidPhase,
              this.liquidSettings.liquidPhase
            );
          }
          if (this.liquidUniforms.u_animationIntensity) {
            this.gl.uniform1f(
              this.liquidUniforms.u_animationIntensity,
              this.liquidSettings.animationIntensity
            );
          }
          if (this.liquidUniforms.u_auroraFlow) {
            this.gl.uniform1f(
              this.liquidUniforms.u_auroraFlow,
              this.liquidSettings.auroraFlow
            );
          }
          if (this.liquidUniforms.u_flowDirection) {
            this.gl.uniform2fv(
              this.liquidUniforms.u_flowDirection,
              this.liquidSettings.flowDirection
            );
          }
          if (this.liquidUniforms.u_liquidTurbulence) {
            this.gl.uniform1f(
              this.liquidUniforms.u_liquidTurbulence,
              this.liquidSettings.liquidTurbulence
            );
          }
          if (this.liquidUniforms.u_visualEffectsDepth) {
            this.gl.uniform1f(
              this.liquidUniforms.u_visualEffectsDepth,
              this.liquidSettings.visualEffectsDepth
            );
          }
          if (this.liquidUniforms.u_surfaceTension) {
            this.gl.uniform1f(
              this.liquidUniforms.u_surfaceTension,
              this.liquidSettings.surfaceTension
            );
          }
          if (this.liquidUniforms.u_viscosity) {
            this.gl.uniform1f(
              this.liquidUniforms.u_viscosity,
              this.liquidSettings.viscosity
            );
          }
          if (this.liquidUniforms.u_liquidGravity) {
            this.gl.uniform1f(
              this.liquidUniforms.u_liquidGravity,
              this.liquidSettings.liquidGravity
            );
          }
          if (this.liquidUniforms.u_particleDensity) {
            this.gl.uniform1f(
              this.liquidUniforms.u_particleDensity,
              this.liquidSettings.particleDensity
            );
          }
          if (this.liquidUniforms.u_surfaceElasticity) {
            this.gl.uniform1f(
              this.liquidUniforms.u_surfaceElasticity,
              this.liquidSettings.surfaceElasticity
            );
          }
          if (this.liquidUniforms.u_smoothDynamics) {
            this.gl.uniform1f(
              this.liquidUniforms.u_smoothDynamics,
              this.liquidSettings.smoothDynamics
            );
          }
          if (this.liquidUniforms.u_visualEffectsLevel) {
            this.gl.uniform1f(
              this.liquidUniforms.u_visualEffectsLevel,
              this.liquidSettings.visualEffectsLevel
            );
          }
          if (this.liquidUniforms.u_visualEffectsTemperature) {
            this.gl.uniform1f(
              this.liquidUniforms.u_visualEffectsTemperature,
              this.liquidSettings.visualEffectsTemperature
            );
          }
          if (this.liquidUniforms.u_memoryIntensity) {
            this.gl.uniform1f(
              this.liquidUniforms.u_memoryIntensity,
              this.liquidSettings.memoryIntensity
            );
          }
          if (this.liquidUniforms.u_emotionalTemperature) {
            this.gl.uniform1f(
              this.liquidUniforms.u_emotionalTemperature,
              this.liquidSettings.emotionalTemperature
            );
          }
          if (this.liquidUniforms.u_genreInfluence) {
            this.gl.uniform1f(
              this.liquidUniforms.u_genreInfluence,
              this.liquidSettings.genreInfluence
            );
          }
          this.updateMusicUniforms();
        }
        updateMusicUniforms() {
          if (!this.gl || !this.musicSyncService) return;
          const latestData = this.musicSyncService.getLatestProcessedData?.() || {};
          const musicEnergy = latestData.energy || 0;
          const musicValence = latestData.valence || 0;
          const beatIntensity = latestData.beatIntensity || 0;
          const bassResponse = latestData.bassResponse || 0;
          if (this.liquidUniforms.u_musicEnergy) {
            this.gl.uniform1f(this.liquidUniforms.u_musicEnergy, musicEnergy);
          }
          if (this.liquidUniforms.u_musicValence) {
            this.gl.uniform1f(this.liquidUniforms.u_musicValence, musicValence);
          }
          if (this.liquidUniforms.u_beatIntensity) {
            this.gl.uniform1f(this.liquidUniforms.u_beatIntensity, beatIntensity);
          }
          if (this.liquidUniforms.u_bassResponse) {
            this.gl.uniform1f(this.liquidUniforms.u_bassResponse, bassResponse);
          }
        }
        async healthCheck() {
          const isHealthy = this.liquidSettings.enabled && this.shaderProgram !== null;
          return {
            system: "FluidGradientBackgroundSystem",
            healthy: isHealthy,
            metrics: {
              enabled: this.liquidSettings.enabled,
              hasShaderProgram: !!this.shaderProgram,
              initialized: this.initialized,
              flowIntensity: this.liquidSettings.flowIntensity
            },
            issues: isHealthy ? [] : [
              ...this.liquidSettings.enabled ? [] : ["System disabled"],
              ...this.shaderProgram ? [] : ["Shader program not initialized"]
            ]
          };
        }
        forceRepaint(reason = "liquid-visualEffects-update") {
          this.webglGradientSystem.forceRepaint(reason);
        }
        // ========================================================================
        // QUALITY SCALING INTERFACE IMPLEMENTATION
        // ========================================================================
        /**
         * Adjust quality level (QualityScalingCapable interface)
         */
        adjustQuality(level) {
          this.setQualityLevel(level);
        }
        setQualityLevel(level) {
          switch (level) {
            case "low":
              this.liquidSettings.flowIntensity = 0.5;
              this.liquidSettings.turbulenceScale = 0.7;
              this.liquidSettings.colorMixingStrength = 0.6;
              this.liquidSettings.animationSpeed = 0.8;
              break;
            case "medium":
              this.liquidSettings.flowIntensity = 0.7;
              this.liquidSettings.turbulenceScale = 0.9;
              this.liquidSettings.colorMixingStrength = 0.8;
              this.liquidSettings.animationSpeed = 1;
              break;
            case "high":
              this.liquidSettings.flowIntensity = 0.9;
              this.liquidSettings.turbulenceScale = 1.1;
              this.liquidSettings.colorMixingStrength = 1;
              this.liquidSettings.animationSpeed = 1.2;
              break;
            default:
              this.liquidSettings.flowIntensity = 0.7;
              this.liquidSettings.turbulenceScale = 0.9;
              this.liquidSettings.colorMixingStrength = 0.8;
              this.liquidSettings.animationSpeed = 1;
              break;
          }
          this.webglGradientSystem.setQualityLevel(level);
          if (ADVANCED_SYSTEM_CONFIG.enableDebug) {
            Y3KDebug?.debug?.log(
              "FluidGradientBackgroundSystem",
              `Quality level set to: ${level}`,
              this.liquidSettings
            );
          }
        }
        getPerformanceImpact() {
          const baseMetrics = this.webglGradientSystem.getPerformanceImpact();
          return {
            fps: baseMetrics.fps,
            frameTime: baseMetrics.frameTime + 1.2,
            // Additional render complexity
            memoryUsage: baseMetrics.memoryUsage + 5,
            // Additional shader complexity (MB)
            cpuUsage: baseMetrics.cpuUsage + 3
            // Additional uniforms processing
          };
        }
        reduceQuality(amount) {
          this.liquidSettings.flowIntensity = Math.max(
            0.1,
            this.liquidSettings.flowIntensity - amount * 0.3
          );
          this.liquidSettings.turbulenceScale = Math.max(
            0.2,
            this.liquidSettings.turbulenceScale - amount * 0.4
          );
          this.liquidSettings.colorMixingStrength = Math.max(
            0.2,
            this.liquidSettings.colorMixingStrength - amount * 0.3
          );
          this.liquidSettings.animationSpeed = Math.max(
            0.3,
            this.liquidSettings.animationSpeed - amount * 0.5
          );
          this.webglGradientSystem.reduceQuality(amount);
        }
        increaseQuality(amount) {
          this.liquidSettings.flowIntensity = Math.min(
            1,
            this.liquidSettings.flowIntensity + amount * 0.2
          );
          this.liquidSettings.turbulenceScale = Math.min(
            1.5,
            this.liquidSettings.turbulenceScale + amount * 0.3
          );
          this.liquidSettings.colorMixingStrength = Math.min(
            1.2,
            this.liquidSettings.colorMixingStrength + amount * 0.2
          );
          this.liquidSettings.animationSpeed = Math.min(
            1.6,
            this.liquidSettings.animationSpeed + amount * 0.3
          );
          this.webglGradientSystem.increaseQuality(amount);
        }
        getQualityCapabilities() {
          return [
            {
              name: "liquid-flow-intensity",
              enabled: this.liquidSettings.flowIntensity > 0.5,
              qualityLevel: "medium"
            },
            {
              name: "turbulence-complexity",
              enabled: this.liquidSettings.turbulenceScale > 0.8,
              qualityLevel: "high"
            },
            {
              name: "color-mixing-quality",
              enabled: this.liquidSettings.colorMixingStrength > 0.7,
              qualityLevel: "low"
            },
            {
              name: "animation-smoothness",
              enabled: this.liquidSettings.animationSpeed > 1,
              qualityLevel: "medium"
            }
          ];
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.visualEffectsChoreographer) {
            try {
              this.visualEffectsChoreographer.unregisterVisualEffectsParticipant(
                "FluidGradientBackgroundSystem"
              );
              Y3KDebug?.debug?.log(
                "FluidGradientBackgroundSystem",
                "Unregistered from visualEffects choreographer"
              );
            } catch (error) {
              Y3KDebug?.debug?.error(
                "FluidGradientBackgroundSystem",
                "Error unregistering from visualEffects choreographer:",
                error
              );
            }
          }
          this.eventSubscriptionIds.forEach((subscriptionId) => {
            unifiedEventBus.unsubscribe(subscriptionId);
          });
          this.eventSubscriptionIds = [];
          Y3KDebug?.debug?.log(
            "FluidGradientBackgroundSystem",
            "Unified event subscriptions cleaned up"
          );
          if (this.gl && this.shaderProgram) {
            this.gl.deleteProgram(this.shaderProgram);
            this.shaderProgram = null;
          }
          this.webglGradientSystem.destroy();
        }
        // Public API for liquid visualEffects control
        setLiquidPhase(phase) {
          this.liquidSettings.liquidPhase = phase;
        }
        setAnimationIntensity(intensity) {
          this.liquidSettings.animationIntensity = Math.max(
            0,
            Math.min(1, intensity)
          );
        }
        setAuroraFlow(flow) {
          this.liquidSettings.auroraFlow = Math.max(0, Math.min(1, flow));
        }
        setFlowDirection(x, y) {
          this.liquidSettings.flowDirection = [x, y];
        }
        setLiquidTurbulence(turbulence) {
          this.liquidSettings.liquidTurbulence = Math.max(0, Math.min(2, turbulence));
        }
        setVisualEffectsDepth(depth) {
          this.liquidSettings.visualEffectsDepth = Math.max(0, Math.min(1, depth));
        }
        // Advanced liquid physics control methods
        setSurfaceTension(tension) {
          this.liquidSettings.surfaceTension = Math.max(0, Math.min(1, tension));
        }
        setViscosity(viscosity) {
          this.liquidSettings.viscosity = Math.max(0, Math.min(1, viscosity));
        }
        setLiquidGravity(gravity) {
          this.liquidSettings.liquidGravity = Math.max(0, Math.min(1, gravity));
        }
        setParticleDensity(density) {
          this.liquidSettings.particleDensity = Math.max(0, Math.min(2, density));
        }
        setSurfaceElasticity(elasticity) {
          this.liquidSettings.surfaceElasticity = Math.max(0, Math.min(1, elasticity));
        }
        setSmoothDynamics(dynamics) {
          this.liquidSettings.smoothDynamics = Math.max(0, Math.min(1, dynamics));
        }
        setVisualEffectsLevel(level) {
          this.liquidSettings.visualEffectsLevel = Math.max(0, Math.min(1, level));
        }
        setVisualEffectsTemperature(temperature) {
          this.liquidSettings.visualEffectsTemperature = Math.max(0, Math.min(1, temperature));
        }
        setMemoryIntensity(intensity) {
          this.liquidSettings.memoryIntensity = Math.max(0, Math.min(1, intensity));
        }
        setEmotionalTemperature(temperature) {
          this.liquidSettings.emotionalTemperature = Math.max(0, Math.min(1, temperature));
        }
        setGenreInfluence(influence) {
          this.liquidSettings.genreInfluence = Math.max(0, Math.min(1, influence));
        }
        getLiquidSettings() {
          return { ...this.liquidSettings };
        }
        // ===================================================================
        // CONSCIOUSNESS CHOREOGRAPHER INTEGRATION
        // ===================================================================
        /**
         * Register this liquid system as a visualEffects participant
         */
        registerWithVisualEffectsChoreographer() {
          if (!this.visualEffectsChoreographer) {
            Y3KDebug?.debug?.log(
              "FluidGradientBackgroundSystem",
              "VisualEffects choreographer not available, skipping registration"
            );
            return;
          }
          try {
            this.visualEffectsChoreographer.registerVisualEffectsParticipant(this);
            Y3KDebug?.debug?.log(
              "FluidGradientBackgroundSystem",
              "Successfully registered with visualEffects choreographer"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "FluidGradientBackgroundSystem",
              "Failed to register with visualEffects choreographer:",
              error
            );
          }
        }
        // ===================================================================
        // BACKGROUND SYSTEM PARTICIPANT INTERFACE IMPLEMENTATION
        // ===================================================================
        get systemPriority() {
          return "high";
        }
        getVisualEffectsContribution() {
          return {
            liquidDensity: this.liquidSettings.liquidTurbulence || 0.5,
            smoothDynamics: this.liquidSettings.auroraFlow || 0.6,
            surfaceFluidityIndex: this.liquidSettings.animationIntensity || 0.8,
            turbulenceLevel: this.liquidSettings.liquidTurbulence || 0.5,
            viscosityIndex: 1,
            flowPatterns: ["aurora", "liquid", "visualEffects"]
          };
        }
        onVisualEffectsFieldUpdate(field) {
          if (!this.gl || !this.shaderProgram) return;
          try {
            this.currentVisualEffectsField = field;
            this.updateLiquidFromVisualEffects(field);
            Y3KDebug?.debug?.log(
              "FluidGradientBackgroundSystem",
              "Updated from visualEffects field:",
              {
                rhythmicPulse: field.pulseRate,
                liquidDensity: field.fluidIntensity,
                surfaceFluidityIndex: field.fluidIntensity
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "FluidGradientBackgroundSystem",
              "Error updating from visualEffects field:",
              error
            );
          }
        }
        onChoreographyEvent(eventType, payload) {
          if (!this.gl || !this.shaderProgram) return;
          try {
            switch (eventType) {
              case "choreography:rhythm-shift":
                const newRhythm = payload.newRhythm?.bpm || 120;
                this.liquidSettings.auroraFlow = Math.max(
                  0.2,
                  Math.min(1, newRhythm / 120)
                );
                break;
              case "choreography:energy-surge":
                const surgeIntensity = payload.intensity || 1;
                this.liquidSettings.liquidTurbulence = Math.min(
                  1,
                  this.liquidSettings.liquidTurbulence * (1 + surgeIntensity * 0.5)
                );
                break;
              case "visualEffects:animation-cycle":
                const animationPhase = payload.phase || 0;
                this.liquidSettings.animationIntensity = 0.5 + Math.sin(animationPhase * Math.PI * 2) * 0.3;
                break;
              case "visualEffects:surface-fluid":
                const fluidityIndex = payload.fluidityIndex || 0.5;
                this.liquidSettings.visualEffectsDepth = fluidityIndex;
                break;
            }
            if (this.currentVisualEffectsField) {
              this.updateLiquidFromVisualEffects(this.currentVisualEffectsField);
            }
            Y3KDebug?.debug?.log(
              "FluidGradientBackgroundSystem",
              `Handled choreography event: ${eventType}`,
              payload
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "FluidGradientBackgroundSystem",
              `Error handling choreography event ${eventType}:`,
              error
            );
          }
        }
        /**
         * Update liquid shader parameters based on visualEffects field
         */
        updateLiquidFromVisualEffects(field) {
          if (!this.gl || !this.shaderProgram) return;
          const consciousLiquidPhase = this.liquidSettings.liquidPhase + field.pulseRate * 0.5;
          const liquidPhaseLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_liquidPhase"
          );
          if (liquidPhaseLocation) {
            this.gl.uniform1f(liquidPhaseLocation, consciousLiquidPhase);
          }
          const smoothAnimation = this.liquidSettings.animationIntensity * (0.7 + field.pulseRate * 0.3);
          const animationLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_animationIntensity"
          );
          if (animationLocation) {
            this.gl.uniform1f(animationLocation, smoothAnimation);
          }
          const auroraFlowLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_auroraFlow"
          );
          if (auroraFlowLocation) {
            this.gl.uniform1f(
              auroraFlowLocation,
              this.liquidSettings.auroraFlow * (0.8 + field.flowDirection.x * 0.4)
            );
          }
          const flowDirectionLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_flowDirection"
          );
          if (flowDirectionLocation) {
            this.gl.uniform2f(
              flowDirectionLocation,
              field.flowDirection.x,
              field.flowDirection.y
            );
          }
          const turbulenceLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_liquidTurbulence"
          );
          if (turbulenceLocation) {
            const consciousTurbulence = this.liquidSettings.liquidTurbulence * (0.5 + field.energyLevel * 0.5);
            this.gl.uniform1f(turbulenceLocation, consciousTurbulence);
          }
          const depthLocation = this.gl.getUniformLocation(
            this.shaderProgram,
            "u_visualEffectsDepth"
          );
          if (depthLocation) {
            this.gl.uniform1f(depthLocation, field.fluidIntensity);
          }
          try {
            const cssController = getGlobalOptimizedCSSController();
            cssController.queueCSSVariableUpdate(
              "--sn-visualEffects-flow-direction",
              consciousLiquidPhase.toString()
            );
            cssController.queueCSSVariableUpdate(
              "--sn-visualEffects-animation-intensity",
              smoothAnimation.toString()
            );
            cssController.queueCSSVariableUpdate(
              "--sn-visualEffects-aurora-flow",
              this.liquidSettings.auroraFlow.toString()
            );
            cssController.queueCSSVariableUpdate(
              "--sn-visualEffects-viscosity",
              this.liquidSettings.liquidTurbulence.toString()
            );
            cssController.queueCSSVariableUpdate(
              "--sn-visualEffects-surface-tension",
              this.liquidSettings.surfaceTension.toString()
            );
            cssController.queueCSSVariableUpdate(
              "--sn-visualEffects-surface-elasticity",
              this.liquidSettings.surfaceElasticity.toString()
            );
            cssController.queueCSSVariableUpdate(
              "--sn-visualEffects-animation-scale",
              this.liquidSettings.particleDensity.toString()
            );
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "FluidGradientBackgroundSystem",
              "Global CSS controller not available:",
              error
            );
          }
        }
        // =========================================================================
        // BACKGROUND SYSTEM PARTICIPANT INTERFACE
        // =========================================================================
        onVisualStateUpdate(state) {
          this.onVisualEffectsFieldUpdate(state);
        }
        onVisualEffectEvent(eventType, payload) {
          switch (eventType) {
            case "visual:rhythm-shift":
              if (payload.intensity) {
                this.liquidSettings.liquidTurbulence = Math.min(1, payload.intensity * 0.8);
              }
              break;
            case "visual:color-shift":
              this.forceRepaint("color-shift");
              break;
            case "visual:energy-surge":
              if (payload.intensity > 0.5) {
                this.liquidSettings.particleDensity = Math.min(1, payload.intensity);
              }
              break;
          }
        }
        getVisualContribution() {
          return {
            fluidIntensity: this.liquidSettings.liquidTurbulence,
            effectDepth: this.liquidSettings.particleDensity,
            systemHarmony: this.liquidSettings.surfaceTension
          };
        }
        // ===================================================================
        // BACKWARD COMPATIBILITY ALIASES
        // ===================================================================
        /** @deprecated Use onVisualEffectsFieldUpdate */
        onConsciousnessFieldUpdate(field) {
          return this.onVisualEffectsFieldUpdate(field);
        }
      };
      __name(_FluidGradientBackgroundSystem, "FluidGradientBackgroundSystem");
      FluidGradientBackgroundSystem = _FluidGradientBackgroundSystem;
    }
  });

  // src-js/visual/ui/IridescentShimmerEffectsSystem.ts
  var _IridescentShimmerEffectsSystem, IridescentShimmerEffectsSystem;
  var init_IridescentShimmerEffectsSystem = __esm({
    "src-js/visual/ui/IridescentShimmerEffectsSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_UnifiedDebugManager();
      init_BaseVisualSystem();
      _IridescentShimmerEffectsSystem = class _IridescentShimmerEffectsSystem extends BaseVisualSystem {
        constructor(config = ADVANCED_SYSTEM_CONFIG, utils, performanceMonitor, settingsManager2 = null) {
          super(config, utils, performanceMonitor, null, settingsManager2);
          this.intersectionObserver = null;
          this.animationFrameId = null;
          this.lastAnimationTime = 0;
          this.styleElement = null;
          this.prefersReducedMotion = false;
          // Quality scaling properties
          this.currentQualityLevel = null;
          this.qualityCapabilities = [
            {
              name: "shimmer-effects",
              enabled: true,
              qualityLevel: "medium"
            },
            {
              name: "oil-slick-intensity",
              enabled: true,
              qualityLevel: "medium"
            },
            {
              name: "chromatic-aberration",
              enabled: true,
              qualityLevel: "low"
            },
            {
              name: "interference-patterns",
              enabled: true,
              qualityLevel: "low"
            },
            {
              name: "gpu-acceleration",
              enabled: true,
              qualityLevel: "medium"
            },
            { name: "element-pooling", enabled: true, qualityLevel: "low" }
          ];
          this.qualityAdjustments = {};
          this.shimmerElements = /* @__PURE__ */ new Map();
          try {
            this.cssController = getGlobalOptimizedCSSController();
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "IridescentShimmerEffectsSystem",
              "OptimizedCSSVariableManager not available:",
              error
            );
            throw error;
          }
          this.shimmerSettings = {
            enabled: true,
            intensity: "balanced",
            targetSelectors: [
              ".main-entityHeader-container",
              ".sn-card",
              // Unified selector (CardDOMWatcher)
              ".main-card-card",
              // Legacy selector (kept for transition)
              ".main-playButton-PlayButton",
              ".main-actionBarRow-ActionBarRow",
              ".main-trackList-trackListRow",
              ".main-nowPlayingWidget-nowPlaying"
            ],
            animationSpeed: 0.5,
            colorShift: 30,
            opacityRange: [0.1, 0.3],
            scaleRange: [0.8, 1.2],
            rotationSpeed: 0.2,
            blurRadius: 8,
            saturationBoost: 1.5,
            // Enhanced oil-on-water effects
            oilSlickIntensity: 0.7,
            chromaticAberration: 2,
            refractionStrength: 1.5,
            interferencePattern: true,
            surfaceTension: 0.8,
            // Performance optimization
            useGPUAcceleration: true,
            maxSimultaneousShimmers: 12,
            adaptiveQuality: true,
            poolingEnabled: true
          };
          this.shimmerKeyframes = {
            shimmer: [
              {
                transform: "translateX(-100%) translateY(-100%) rotate(0deg) scale(0.8)",
                opacity: "0",
                filter: "hue-rotate(0deg) saturate(1)"
              },
              {
                transform: "translateX(0%) translateY(0%) rotate(45deg) scale(1.1)",
                opacity: "0.3",
                filter: "hue-rotate(120deg) saturate(1.8)"
              },
              {
                transform: "translateX(100%) translateY(100%) rotate(90deg) scale(1.2)",
                opacity: "0.1",
                filter: "hue-rotate(240deg) saturate(1.3)"
              },
              {
                transform: "translateX(200%) translateY(200%) rotate(180deg) scale(0.9)",
                opacity: "0",
                filter: "hue-rotate(360deg) saturate(1)"
              }
            ],
            prism: [
              {
                background: "linear-gradient(45deg, rgba(var(--spice-rgb-shimmer-primary, 255, 0, 150), 0.1) 0%, rgba(var(--spice-rgb-shimmer-secondary, 0, 255, 255), 0.1) 50%, rgba(var(--spice-rgb-shimmer-tertiary, 255, 255, 0), 0.1) 100%)",
                transform: "rotate(0deg) scale(1)",
                mixBlendMode: "multiply"
              },
              {
                background: "linear-gradient(135deg, rgba(var(--spice-rgb-shimmer-secondary, 0, 255, 150), 0.12) 0%, rgba(var(--spice-rgb-shimmer-quaternary, 255, 0, 255), 0.12) 50%, rgba(var(--spice-rgb-shimmer-tertiary, 0, 150, 255), 0.12) 100%)",
                transform: "rotate(120deg) scale(1.1)",
                mixBlendMode: "overlay"
                // Changed from 'screen' to prevent white bleeding
              },
              {
                background: "linear-gradient(225deg, rgba(var(--spice-rgb-shimmer-tertiary, 255, 150, 0), 0.12) 0%, rgba(var(--spice-rgb-shimmer-quaternary, 150, 255, 0), 0.12) 50%, rgba(var(--spice-rgb-shimmer-primary, 255, 0, 150), 0.12) 100%)",
                transform: "rotate(240deg) scale(0.9)",
                mixBlendMode: "overlay"
              },
              {
                background: "linear-gradient(315deg, rgba(var(--spice-rgb-shimmer-quaternary, 150, 0, 255), 0.08) 0%, rgba(var(--spice-rgb-shimmer-tertiary, 255, 255, 0), 0.08) 50%, rgba(var(--spice-rgb-shimmer-secondary, 0, 255, 150), 0.08) 100%)",
                transform: "rotate(360deg) scale(1)",
                mixBlendMode: "multiply"
              }
            ],
            oilSlick: [
              {
                backdropFilter: "blur(2px) hue-rotate(0deg) saturate(1.5)",
                transform: "scaleX(1) scaleY(1) rotate(0deg)",
                opacity: "0.8"
              },
              {
                backdropFilter: "blur(4px) hue-rotate(90deg) saturate(2.2)",
                transform: "scaleX(1.05) scaleY(0.95) rotate(2deg)",
                opacity: "0.6"
              },
              {
                backdropFilter: "blur(6px) hue-rotate(180deg) saturate(1.8)",
                transform: "scaleX(0.95) scaleY(1.05) rotate(-2deg)",
                opacity: "0.7"
              },
              {
                backdropFilter: "blur(3px) hue-rotate(270deg) saturate(1.3)",
                transform: "scaleX(1.02) scaleY(0.98) rotate(1deg)",
                opacity: "0.9"
              },
              {
                backdropFilter: "blur(2px) hue-rotate(360deg) saturate(1.5)",
                transform: "scaleX(1) scaleY(1) rotate(0deg)",
                opacity: "0.8"
              }
            ],
            rainbow: [
              { filter: "hue-rotate(0deg) saturate(1.2) brightness(1.1)" },
              { filter: "hue-rotate(60deg) saturate(1.8) brightness(1.2)" },
              { filter: "hue-rotate(120deg) saturate(1.5) brightness(1.1)" },
              { filter: "hue-rotate(180deg) saturate(1.9) brightness(1.3)" },
              { filter: "hue-rotate(240deg) saturate(1.4) brightness(1.1)" },
              { filter: "hue-rotate(300deg) saturate(1.6) brightness(1.2)" },
              { filter: "hue-rotate(360deg) saturate(1.2) brightness(1.1)" }
            ]
          };
          this.prefersReducedMotion = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;
          window.matchMedia("(prefers-reduced-motion: reduce)").addEventListener("change", (e) => {
            this.prefersReducedMotion = e.matches;
            this.updateShimmerElements();
          });
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          this.loadSettings();
          this.createShimmerStyles();
          this.setupIntersectionObserver();
          this.setupShimmerElements();
          Y3KDebug?.debug?.log(
            "IridescentShimmerEffectsSystem",
            "Iridescent shimmer system initialized"
          );
        }
        loadSettings() {
          if (!this.settingsManager) return;
          try {
            const intensitySetting = this.settingsManager.get(
              "sn-shimmer-intensity"
            );
            if (intensitySetting) {
              this.shimmerSettings.intensity = intensitySetting;
              this.applyIntensitySettings();
            }
            const enabledSetting = this.settingsManager.get(
              "sn-shimmer-enabled"
            );
            if (enabledSetting !== void 0) {
              this.shimmerSettings.enabled = enabledSetting;
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "IridescentShimmerEffectsSystem",
              "Failed to load settings:",
              error
            );
          }
        }
        applyIntensitySettings() {
          switch (this.shimmerSettings.intensity) {
            case "minimal":
              this.shimmerSettings.animationSpeed = 0.3;
              this.shimmerSettings.opacityRange = [0.05, 0.15];
              this.shimmerSettings.colorShift = 15;
              this.shimmerSettings.blurRadius = 4;
              this.shimmerSettings.saturationBoost = 1.2;
              break;
            case "balanced":
              this.shimmerSettings.animationSpeed = 0.5;
              this.shimmerSettings.opacityRange = [0.1, 0.3];
              this.shimmerSettings.colorShift = 30;
              this.shimmerSettings.blurRadius = 8;
              this.shimmerSettings.saturationBoost = 1.5;
              break;
            case "intense":
              this.shimmerSettings.animationSpeed = 0.8;
              this.shimmerSettings.opacityRange = [0.15, 0.5];
              this.shimmerSettings.colorShift = 60;
              this.shimmerSettings.blurRadius = 12;
              this.shimmerSettings.saturationBoost = 2;
              break;
          }
        }
        createShimmerStyles() {
          this.styleElement = document.createElement("style");
          this.styleElement.textContent = `
      .sn-shimmer-container {
        position: relative;
        overflow: hidden;
        isolation: isolate;
      }

      .sn-shimmer-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
        opacity: calc(var(--shimmer-intensity, 0.3) * 0.6);
        will-change: transform, filter;
      }

      /* Single unified shimmer effect - replaces 3 separate layers */
      .sn-shimmer-unified {
        background:
          conic-gradient(
            from var(--shimmer-phase, 0deg) at 50% 50%,
            rgba(var(--spice-rgb-shimmer-primary, 255, 0, 150), 0.08) 0%,
            rgba(var(--spice-rgb-shimmer-secondary, 0, 255, 255), 0.12) 25%,
            rgba(var(--spice-rgb-shimmer-tertiary, 255, 255, 0), 0.08) 50%,
            rgba(var(--spice-rgb-shimmer-quaternary, 150, 0, 255), 0.10) 75%,
            rgba(var(--spice-rgb-shimmer-primary, 255, 0, 150), 0.08) 100%
          ),
          linear-gradient(
            45deg,
            rgba(var(--spice-rgb-shimmer-primary, 255, 0, 150), 0.06) 0%,
            rgba(var(--spice-rgb-shimmer-secondary, 0, 255, 255), 0.04) 50%,
            rgba(var(--spice-rgb-shimmer-primary, 255, 0, 150), 0.06) 100%
          );
        backdrop-filter:
          blur(calc(var(--shimmer-intensity, 0.3) * 6px))
          saturate(calc(1 + var(--shimmer-intensity, 0.3) * 0.8));
        mix-blend-mode: overlay;
        animation:
          sn-shimmer-unified var(--shimmer-duration, 10s) ease-in-out infinite,
          sn-shimmer-rotation calc(var(--shimmer-duration, 10s) * 1.5) linear infinite;
        animation-delay: calc(var(--shimmer-phase, 0deg) / 360deg * var(--shimmer-duration, 10s));
      }

      @keyframes sn-shimmer-unified {
        0%, 100% {
          transform: scale(1) translateX(0%) translateY(0%);
          filter: hue-rotate(0deg) brightness(1.05);
        }
        25% {
          transform: scale(1.02) translateX(0.5%) translateY(-0.5%);
          filter: hue-rotate(90deg) brightness(1.15);
        }
        50% {
          transform: scale(0.98) translateX(-0.3%) translateY(0.3%);
          filter: hue-rotate(180deg) brightness(1.1);
        }
        75% {
          transform: scale(1.01) translateX(0.2%) translateY(-0.2%);
          filter: hue-rotate(270deg) brightness(1.08);
        }
      }

      @keyframes sn-shimmer-rotation {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Performance optimization for reduced motion */
      @media (prefers-reduced-motion: reduce) {
        .sn-shimmer-unified {
          animation: none;
          transform: none;
          filter: none;
          opacity: calc(var(--shimmer-intensity, 0.3) * 0.3);
        }
      }

      /* GPU acceleration hints */
      .sn-shimmer-unified {
        transform: translateZ(0);
        backface-visibility: hidden;
        perspective: 1000px;
      }
    `;
          document.head.appendChild(this.styleElement);
        }
        setupIntersectionObserver() {
          this.intersectionObserver = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                const shimmerElement = this.shimmerElements.get(entry.target);
                if (shimmerElement) {
                  shimmerElement.isVisible = entry.isIntersecting;
                  shimmerElement.bounds = entry.boundingClientRect;
                  if (shimmerElement.isVisible) {
                    this.activateShimmer(shimmerElement);
                  } else {
                    this.deactivateShimmer(shimmerElement);
                  }
                }
              });
            },
            {
              root: null,
              rootMargin: "50px",
              threshold: 0.1
            }
          );
        }
        setupShimmerElements() {
          this.shimmerSettings.targetSelectors.forEach((selector) => {
            const elements = document.querySelectorAll(selector);
            elements.forEach((element) => {
              this.addShimmerToElement(element);
            });
          });
          const mutationObserver = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              mutation.addedNodes.forEach((node) => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                  const element = node;
                  this.shimmerSettings.targetSelectors.forEach((selector) => {
                    if (element.matches(selector)) {
                      this.addShimmerToElement(element);
                    }
                    const childElements = element.querySelectorAll(selector);
                    childElements.forEach((child) => {
                      this.addShimmerToElement(child);
                    });
                  });
                }
              });
            });
          });
          mutationObserver.observe(document.body, {
            childList: true,
            subtree: true
          });
        }
        addShimmerToElement(element) {
          if (this.shimmerElements.has(element)) return;
          const shimmerLayer = document.createElement("div");
          shimmerLayer.className = "sn-shimmer-layer sn-shimmer-unified";
          const intensity = this.getIntensityValue();
          const phase = Math.random() * 360;
          shimmerLayer.style.setProperty("--shimmer-intensity", intensity.toString());
          shimmerLayer.style.setProperty("--shimmer-phase", `${phase}deg`);
          shimmerLayer.style.setProperty(
            "--shimmer-duration",
            `${8 + Math.random() * 4}s`
          );
          element.classList.add("sn-shimmer-container");
          element.appendChild(shimmerLayer);
          const shimmerElement = {
            element,
            shimmerLayer,
            animationPhase: phase,
            intensity,
            lastUpdate: 0,
            isVisible: false,
            bounds: element.getBoundingClientRect()
          };
          this.shimmerElements.set(element, shimmerElement);
          if (this.intersectionObserver) {
            this.intersectionObserver.observe(element);
          }
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "IridescentShimmerEffectsSystem",
              `Added optimized shimmer to ${element.tagName}.${element.className.substring(0, 20)}`
            );
          }
        }
        getIntensityValue() {
          const intensityMap = {
            minimal: 0.3,
            balanced: 0.6,
            intense: 1
          };
          return intensityMap[this.shimmerSettings.intensity];
        }
        activateShimmer(shimmerElement) {
          if (this.prefersReducedMotion) {
            shimmerElement.shimmerLayer.style.setProperty(
              "--shimmer-intensity",
              "0.1"
            );
            shimmerElement.shimmerLayer.style.opacity = "0.1";
            return;
          }
          shimmerElement.shimmerLayer.style.setProperty(
            "--shimmer-intensity",
            shimmerElement.intensity.toString()
          );
          shimmerElement.shimmerLayer.style.opacity = "1";
          shimmerElement.shimmerLayer.style.animationPlayState = "running";
        }
        deactivateShimmer(shimmerElement) {
          shimmerElement.shimmerLayer.style.opacity = "0";
          shimmerElement.shimmerLayer.style.animationPlayState = "paused";
        }
        /**
         * Update shimmer settings efficiently using CSS variables only
         */
        updateShimmerElements() {
          if (!this.shimmerSettings.enabled) {
            this.disableAllShimmers();
            return;
          }
          const shimmerGlobalVariables = {
            "--sn-shimmer-global-intensity": this.getIntensityValue().toString(),
            "--sn-shimmer-global-speed": `${this.shimmerSettings.animationSpeed}s`,
            "--sn-shimmer-global-blur": `${this.shimmerSettings.blurRadius}px`
          };
          this.cssController.batchSetVariables(
            "IridescentShimmerEffectsSystem",
            shimmerGlobalVariables,
            "normal",
            // Normal priority for shimmer settings
            "shimmer-global-settings"
          );
          this.shimmerElements.forEach((shimmerElement) => {
            if (shimmerElement.isVisible) {
              this.activateShimmer(shimmerElement);
            } else {
              this.deactivateShimmer(shimmerElement);
            }
          });
        }
        /**
         * Efficiently disable all shimmers
         */
        disableAllShimmers() {
          this.shimmerElements.forEach((shimmerElement) => {
            this.deactivateShimmer(shimmerElement);
          });
        }
        updateAnimation(deltaTime) {
        }
        async healthCheck() {
          const isHealthy = this.shimmerSettings.enabled && this.shimmerElements.size > 0;
          return {
            system: "IridescentShimmerEffectsSystem",
            healthy: isHealthy,
            metrics: {
              enabled: this.shimmerSettings.enabled,
              elementCount: this.shimmerElements.size,
              intensity: this.shimmerSettings.intensity,
              initialized: this.initialized
            },
            issues: isHealthy ? [] : [
              ...this.shimmerSettings.enabled ? [] : ["System disabled"],
              ...this.shimmerElements.size > 0 ? [] : ["No shimmer elements found"]
            ]
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            this.intersectionObserver = null;
          }
          this.shimmerElements.forEach((shimmerElement, element) => {
            element.classList.remove("sn-shimmer-container");
            if (shimmerElement.shimmerLayer.parentNode) {
              shimmerElement.shimmerLayer.parentNode.removeChild(
                shimmerElement.shimmerLayer
              );
            }
          });
          this.shimmerElements.clear();
          if (this.styleElement && this.styleElement.parentNode) {
            this.styleElement.parentNode.removeChild(this.styleElement);
            this.styleElement = null;
          }
        }
        // Public API
        setShimmerIntensity(intensity) {
          this.shimmerSettings.intensity = intensity;
          this.applyIntensitySettings();
          this.updateShimmerElements();
        }
        setShimmerEnabled(enabled) {
          this.shimmerSettings.enabled = enabled;
          this.updateShimmerElements();
        }
        addShimmerTarget(selector) {
          if (!this.shimmerSettings.targetSelectors.includes(selector)) {
            this.shimmerSettings.targetSelectors.push(selector);
            const elements = document.querySelectorAll(selector);
            elements.forEach((element) => {
              this.addShimmerToElement(element);
            });
          }
        }
        removeShimmerTarget(selector) {
          const index = this.shimmerSettings.targetSelectors.indexOf(selector);
          if (index > -1) {
            this.shimmerSettings.targetSelectors.splice(index, 1);
            const elements = document.querySelectorAll(selector);
            elements.forEach((element) => {
              const shimmerElement = this.shimmerElements.get(element);
              if (shimmerElement) {
                this.shimmerElements.delete(element);
                if (this.intersectionObserver) {
                  this.intersectionObserver.unobserve(element);
                }
                element.classList.remove("sn-shimmer-container");
                if (shimmerElement.shimmerLayer.parentNode) {
                  shimmerElement.shimmerLayer.parentNode.removeChild(
                    shimmerElement.shimmerLayer
                  );
                }
              }
            });
          }
        }
        getShimmerSettings() {
          return { ...this.shimmerSettings };
        }
        getShimmerElementCount() {
          return this.shimmerElements.size;
        }
        // ========================================================================
        // QUALITY SCALING INTERFACE IMPLEMENTATION
        // ========================================================================
        /**
         * Set quality level for shimmer effects
         */
        setQualityLevel(level) {
          this.currentQualityLevel = level;
          switch (level) {
            case "low":
              this.shimmerSettings.enabled = true;
              this.shimmerSettings.intensity = "minimal";
              this.shimmerSettings.maxSimultaneousShimmers = 5;
              this.shimmerSettings.animationSpeed = 0.3;
              this.shimmerSettings.oilSlickIntensity = 0.4;
              this.shimmerSettings.chromaticAberration = 1;
              this.shimmerSettings.useGPUAcceleration = false;
              this.shimmerSettings.interferencePattern = false;
              break;
            case "medium":
              this.shimmerSettings.enabled = true;
              this.shimmerSettings.intensity = "balanced";
              this.shimmerSettings.maxSimultaneousShimmers = 8;
              this.shimmerSettings.animationSpeed = 0.5;
              this.shimmerSettings.oilSlickIntensity = 0.7;
              this.shimmerSettings.chromaticAberration = 2;
              this.shimmerSettings.useGPUAcceleration = true;
              this.shimmerSettings.interferencePattern = true;
              break;
            case "high":
              this.shimmerSettings.enabled = true;
              this.shimmerSettings.intensity = "intense";
              this.shimmerSettings.maxSimultaneousShimmers = 12;
              this.shimmerSettings.animationSpeed = 0.7;
              this.shimmerSettings.oilSlickIntensity = 0.9;
              this.shimmerSettings.chromaticAberration = 2.5;
              this.shimmerSettings.useGPUAcceleration = true;
              this.shimmerSettings.interferencePattern = true;
              break;
            case "high":
              this.shimmerSettings.enabled = true;
              this.shimmerSettings.intensity = "intense";
              this.shimmerSettings.maxSimultaneousShimmers = 16;
              this.shimmerSettings.animationSpeed = 1;
              this.shimmerSettings.oilSlickIntensity = 1;
              this.shimmerSettings.chromaticAberration = 3;
              this.shimmerSettings.useGPUAcceleration = true;
              this.shimmerSettings.interferencePattern = true;
              break;
          }
          this.updateQualityCapabilities(level);
          this.applyQualityToExistingElements();
          Y3KDebug?.debug?.log(
            "IridescentShimmerEffectsSystem",
            `Quality level set to: ${level}`,
            {
              maxShimmers: this.shimmerSettings.maxSimultaneousShimmers,
              oilSlickIntensity: this.shimmerSettings.oilSlickIntensity,
              gpuAcceleration: this.shimmerSettings.useGPUAcceleration
            }
          );
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const activeShimmers = Array.from(this.shimmerElements.values()).filter(
            (el) => el.isVisible
          ).length;
          const averageProcessingTime = this.calculateAverageProcessingTime();
          const memoryUsage = this.estimateMemoryUsage();
          return {
            fps: 60,
            // CSS-based animations typically maintain 60fps
            frameTime: averageProcessingTime,
            memoryUsage,
            cpuUsage: this.estimateCPUUsage(activeShimmers)
          };
        }
        /**
         * Reduce quality by specified amount
         */
        reduceQuality(amount) {
          this.qualityAdjustments["shimmer-reduction"] = (this.qualityAdjustments["shimmer-reduction"] || 0) + amount;
          this.qualityAdjustments["animation-reduction"] = (this.qualityAdjustments["animation-reduction"] || 0) + amount * 0.8;
          this.qualityAdjustments["effect-reduction"] = (this.qualityAdjustments["effect-reduction"] || 0) + amount * 0.6;
          this.shimmerSettings.maxSimultaneousShimmers = Math.max(
            2,
            Math.floor(
              this.shimmerSettings.maxSimultaneousShimmers * (1 - amount * 0.5)
            )
          );
          this.shimmerSettings.animationSpeed = Math.max(
            0.1,
            this.shimmerSettings.animationSpeed * (1 - amount * 0.4)
          );
          this.shimmerSettings.oilSlickIntensity = Math.max(
            0.2,
            this.shimmerSettings.oilSlickIntensity * (1 - amount * 0.6)
          );
          this.shimmerSettings.chromaticAberration = Math.max(
            0.5,
            this.shimmerSettings.chromaticAberration * (1 - amount * 0.5)
          );
          if (amount > 0.6) {
            this.shimmerSettings.useGPUAcceleration = false;
          }
          if (amount > 0.4) {
            this.shimmerSettings.interferencePattern = false;
          }
          this.applyQualityToExistingElements();
          Y3KDebug?.debug?.log(
            "IridescentShimmerEffectsSystem",
            `Quality reduced by ${amount}`,
            this.shimmerSettings
          );
        }
        /**
         * Increase quality by specified amount
         */
        increaseQuality(amount) {
          Object.keys(this.qualityAdjustments).forEach((key) => {
            this.qualityAdjustments[key] = Math.max(
              0,
              (this.qualityAdjustments[key] || 0) - amount
            );
          });
          if (this.currentQualityLevel) {
            const baseSettings = this.getBaseSettingsForLevel(
              this.currentQualityLevel
            );
            this.shimmerSettings.maxSimultaneousShimmers = Math.min(
              baseSettings.maxSimultaneousShimmers || this.shimmerSettings.maxSimultaneousShimmers,
              Math.floor(
                this.shimmerSettings.maxSimultaneousShimmers * (1 + amount * 0.3)
              )
            );
            this.shimmerSettings.animationSpeed = Math.min(
              baseSettings.animationSpeed || this.shimmerSettings.animationSpeed,
              this.shimmerSettings.animationSpeed * (1 + amount * 0.2)
            );
            this.shimmerSettings.oilSlickIntensity = Math.min(
              baseSettings.oilSlickIntensity || this.shimmerSettings.oilSlickIntensity,
              this.shimmerSettings.oilSlickIntensity * (1 + amount * 0.3)
            );
            this.shimmerSettings.chromaticAberration = Math.min(
              baseSettings.chromaticAberration || this.shimmerSettings.chromaticAberration,
              this.shimmerSettings.chromaticAberration * (1 + amount * 0.2)
            );
            if (amount > 0.3) {
              this.shimmerSettings.interferencePattern = baseSettings.interferencePattern || false;
            }
            if (amount > 0.5) {
              this.shimmerSettings.useGPUAcceleration = baseSettings.useGPUAcceleration || false;
            }
          }
          this.applyQualityToExistingElements();
          Y3KDebug?.debug?.log(
            "IridescentShimmerEffectsSystem",
            `Quality increased by ${amount}`,
            this.shimmerSettings
          );
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          return [...this.qualityCapabilities];
        }
        // ========================================================================
        // QUALITY SCALING HELPER METHODS
        // ========================================================================
        updateQualityCapabilities(level) {
          this.qualityCapabilities.forEach((capability) => {
            switch (capability.name) {
              case "shimmer-effects":
                capability.enabled = this.shimmerSettings.enabled;
                break;
              case "oil-slick-intensity":
                capability.enabled = this.shimmerSettings.oilSlickIntensity > 0.3;
                break;
              case "chromatic-aberration":
                capability.enabled = this.shimmerSettings.chromaticAberration > 1;
                break;
              case "interference-patterns":
                capability.enabled = this.shimmerSettings.interferencePattern;
                break;
              case "gpu-acceleration":
                capability.enabled = this.shimmerSettings.useGPUAcceleration;
                break;
              case "element-pooling":
                capability.enabled = this.shimmerSettings.poolingEnabled;
                break;
            }
          });
        }
        getBaseSettingsForLevel(level) {
          switch (level) {
            case "low":
              return {
                maxSimultaneousShimmers: 3,
                animationSpeed: 0.2,
                oilSlickIntensity: 0.3,
                chromaticAberration: 0.5,
                useGPUAcceleration: false,
                interferencePattern: false
              };
              break;
            case "low":
              return {
                maxSimultaneousShimmers: 5,
                animationSpeed: 0.3,
                oilSlickIntensity: 0.4,
                chromaticAberration: 1,
                useGPUAcceleration: false,
                interferencePattern: false
              };
            case "medium":
              return {
                maxSimultaneousShimmers: 8,
                animationSpeed: 0.5,
                oilSlickIntensity: 0.7,
                chromaticAberration: 2,
                useGPUAcceleration: true,
                interferencePattern: true
              };
            case "high":
              return {
                maxSimultaneousShimmers: 16,
                animationSpeed: 1,
                oilSlickIntensity: 1,
                chromaticAberration: 3,
                useGPUAcceleration: true,
                interferencePattern: true
              };
            default:
              return {};
          }
        }
        applyQualityToExistingElements() {
          this.shimmerElements.forEach((shimmerElement, element) => {
            if (shimmerElement.animation) {
              shimmerElement.animation.playbackRate = this.shimmerSettings.animationSpeed;
            }
            shimmerElement.intensity = this.shimmerSettings.oilSlickIntensity;
            const qualityVariables = {
              "--sn-shimmer-intensity": this.shimmerSettings.oilSlickIntensity.toString(),
              "--sn-shimmer-chromatic": this.shimmerSettings.chromaticAberration.toString(),
              "--sn-shimmer-speed": this.shimmerSettings.animationSpeed.toString()
            };
            this.cssController.batchSetVariables(
              "IridescentShimmerEffectsSystem",
              qualityVariables,
              "normal",
              // Normal priority for quality adjustments
              "shimmer-quality-update"
            );
          });
        }
        calculateAverageProcessingTime() {
          const activeShimmers = Array.from(this.shimmerElements.values()).filter(
            (el) => el.isVisible
          ).length;
          const baseTime = 2;
          const complexityMultiplier = (this.shimmerSettings.oilSlickIntensity + this.shimmerSettings.chromaticAberration / 3 + this.shimmerSettings.animationSpeed) / 3;
          return baseTime * activeShimmers * complexityMultiplier;
        }
        estimateMemoryUsage() {
          const activeShimmers = Array.from(this.shimmerElements.values()).filter(
            (el) => el.isVisible
          ).length;
          const baseMemoryPerShimmer = 0.5;
          const textureMemory = this.shimmerSettings.useGPUAcceleration ? 2 : 0;
          return baseMemoryPerShimmer * activeShimmers + textureMemory;
        }
        estimateCPUUsage(activeShimmers) {
          const baseUsage = 3;
          const complexityFactor = (this.shimmerSettings.oilSlickIntensity + this.shimmerSettings.chromaticAberration / 3) / 2;
          const gpuOffload = this.shimmerSettings.useGPUAcceleration ? 0.5 : 1;
          return Math.min(
            40,
            baseUsage * activeShimmers * complexityFactor * gpuOffload
          );
        }
        /**
         * Adjust quality level for performance optimization (QualityScalingCapable interface)
         */
        adjustQuality(level) {
          this.currentQualityLevel = level;
          switch (level) {
            case "low":
              this.shimmerSettings.intensity = "minimal";
              this.shimmerSettings.oilSlickIntensity = 0.2;
              this.shimmerSettings.useGPUAcceleration = false;
              break;
            case "medium":
              this.shimmerSettings.intensity = "balanced";
              this.shimmerSettings.oilSlickIntensity = 0.5;
              this.shimmerSettings.useGPUAcceleration = true;
              break;
            case "high":
            default:
              this.shimmerSettings.intensity = "intense";
              this.shimmerSettings.oilSlickIntensity = 0.8;
              this.shimmerSettings.useGPUAcceleration = true;
              break;
          }
        }
      };
      __name(_IridescentShimmerEffectsSystem, "IridescentShimmerEffectsSystem");
      IridescentShimmerEffectsSystem = _IridescentShimmerEffectsSystem;
    }
  });

  // src-js/utils/graphics/NoiseField.ts
  function sample(u, v) {
    const x = Math.max(0, Math.min(0.9999, u)) * (GRID_SIZE - 1);
    const y = Math.max(0, Math.min(0.9999, v)) * (GRID_SIZE - 1);
    const x0 = Math.floor(x);
    const y0 = Math.floor(y);
    const x1 = x0 + 1;
    const y1 = y0 + 1;
    const sx = x - x0;
    const sy = y - y0;
    const v00 = vectors[y0 * GRID_SIZE + x0];
    const v10 = vectors[y0 * GRID_SIZE + x1 % GRID_SIZE];
    const v01 = vectors[y1 % GRID_SIZE * GRID_SIZE + x0];
    const v11 = vectors[y1 % GRID_SIZE * GRID_SIZE + x1 % GRID_SIZE];
    const lerp2 = /* @__PURE__ */ __name((a, b, t) => a + (b - a) * t, "lerp");
    const ix0x = lerp2(v00.x, v10.x, sx);
    const ix0y = lerp2(v00.y, v10.y, sx);
    const ix1x = lerp2(v01.x, v11.x, sx);
    const ix1y = lerp2(v01.y, v11.y, sx);
    return {
      x: lerp2(ix0x, ix1x, sy),
      y: lerp2(ix0y, ix1y, sy)
    };
  }
  var GRID_SIZE, vectors;
  var init_NoiseField = __esm({
    "src-js/utils/graphics/NoiseField.ts"() {
      "use strict";
      GRID_SIZE = 64;
      vectors = new Array(GRID_SIZE * GRID_SIZE);
      (/* @__PURE__ */ __name(function init() {
        for (let i = 0; i < vectors.length; i++) {
          const angle = Math.random() * Math.PI * 2;
          vectors[i] = {
            x: Math.cos(angle),
            y: Math.sin(angle)
          };
        }
      }, "init"))();
      __name(sample, "sample");
    }
  });

  // src-js/visual/ui/SidebarVisualEffectsSystem.ts
  var SidebarVisualEffectsSystem_exports = {};
  __export(SidebarVisualEffectsSystem_exports, {
    SidebarVisualEffectsSystem: () => SidebarVisualEffectsSystem
  });
  var _SidebarVisualEffectsSystem, SidebarVisualEffectsSystem;
  var init_SidebarVisualEffectsSystem = __esm({
    "src-js/visual/ui/SidebarVisualEffectsSystem.ts"() {
      "use strict";
      init_globalConfig();
      init_NoiseField();
      init_BaseVisualSystem();
      _SidebarVisualEffectsSystem = class _SidebarVisualEffectsSystem extends BaseVisualSystem {
        constructor(config, utils, performanceMonitor, musicSyncService, settingsManager2, year3000System = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this.rootNavBar = null;
          this.overlayContainer = null;
          this.resizeObserver = null;
          this.visualEffectsElement = null;
          this.harmonicModeIndicator = null;
          // === Temporal Echo Pool ===
          this.echoPool = [];
          this.currentEchoCount = 0;
          this._elementsWithActiveEcho = /* @__PURE__ */ new WeakSet();
          // Stores nav interaction handler reference for clean removal.
          this._navInteractionHandler = null;
          // Timer counter for unique timer IDs
          this.echoTimerCounter = 0;
          /** Flag used to skip re-applying motion-disabled class when already set */
          this._lastMotionDisabled = false;
          this.interactionPatterns = /* @__PURE__ */ new Map();
          this.proximityObserver = null;
          this.interactionElements = /* @__PURE__ */ new Map();
          this.activeEffects = [];
          // Animation state tracking
          this.animationPhase = 0;
          this.localFrameCount = 0;
          this.musicBeatIntensity = 0;
          this.musicEnergyLevel = 0;
          this.cursorPosition = { x: 0, y: 0 };
          this.cursorVelocity = { x: 0, y: 0 };
          this.lastCursorUpdate = 0;
          // Performance parameters
          this.MAX_EFFECT_POINTS = 50;
          this.EFFECT_DECAY_RATE = 0.05;
          this.PROXIMITY_THRESHOLD = 100;
          // pixels
          this.INTERACTION_COOLDOWN = 16;
          // ms (~60fps)
          this.ANIMATION_LERP = 0.08;
          this.SMOOTHING_LERP = 0.12;
          this.INTENSITY_LERP = 0.15;
          /**
           * ✅ RAF LOOP REMOVED - Managed by EnhancedMasterAnimationCoordinator
           *
           * Benefits:
           * - Single RAF loop for all systems
           * - Shared deltaTime calculation
           * - Priority-based execution order
           * - Automatic registration via VisualSystemCoordinator
           *
           * Old method removed: startVisualEffectsLoop()
           * Replacement: updateAnimation(deltaTime) called by coordinator
           */
          /**
           * Mapping from HARMONIC_MODES keys to SCSS class names in _sn_advanced_visual_effects.scss
           * This ensures TypeScript applies the correct CSS classes that match the SCSS selectors
           */
          this.HARMONIC_MODE_TO_CSS_CLASS = {
            "analogous-flow": "sn-color-harmony-analogous-flow",
            "triadic-trinity": "sn-color-harmony-triadic-scheme",
            "complementary-yin-yang": "sn-color-harmony-complementary-contrast",
            "tetradic-advanced-cross": "sn-color-harmony-tetradic-cross",
            "tetradic-cosmic-cross": "sn-color-harmony-tetradic-cross",
            "split-complementary-spectrum": "sn-color-harmony-split-complementary-spectrum",
            "split-complementary-aurora": "sn-color-harmony-split-complementary-spectrum",
            "monochromatic-calm": "sn-color-harmony-monochromatic-calm",
            "monochromatic-meditation": "sn-color-harmony-monochromatic-calm"
          };
          this.year3000System = year3000System;
          this.masterAnimationRegistered = false;
          this.isUsingMasterAnimation = false;
          this.currentHarmonicModeClass = "";
          this.currentEnergyClass = "";
          this.currentHarmonicModeKey = "artist-vision";
          this.nexusVariables = {};
          this.performanceMetrics = {
            animationFrames: 0,
            maxFrameTime: 0,
            averageFrameTime: 0,
            frameTimeHistory: [],
            cssVariableUpdates: 0,
            elementUpdates: 0
          };
          this.deviceCapabilities = {
            supportsCSSFilter: this._detectCSSFilterSupport(),
            supportsTransforms: this._detectTransformSupport(),
            performanceLevel: this._detectPerformanceLevel(),
            reducedMotion: this._detectReducedMotion()
          };
          this.animationState = {
            lastPulse: 0,
            pulseDirection: 1,
            baseOpacity: 0.7,
            currentScale: 1,
            targetScale: 1,
            smoothingFactor: 0.15
          };
          this.visualState = {
            direction: "radial",
            intensity: 0.3,
            velocity: 50,
            smoothing: 0.7,
            effectPoints: []
          };
          this.userInteractionState = {
            globalIntensity: 0,
            dominantDirection: 0,
            interactionCount: 0,
            lastInteractionTime: 0,
            proximityElements: []
          };
          this.setupEffectPoints();
          this.setupInteractionPatterns();
          if (config.enableDebug) {
            console.log(`[${this.systemName}] Enhanced with visual interaction system`);
          }
        }
        // TODO: Implement abstract onAnimate method for Year 3000 MasterAnimationCoordinator
        onAnimate(deltaMs) {
        }
        _detectCSSFilterSupport() {
          const el = document.createElement("div");
          el.style.filter = "blur(1px)";
          return !!el.style.filter;
        }
        _detectTransformSupport() {
          const el = document.createElement("div");
          el.style.transform = "scale(1.1)";
          return !!el.style.transform;
        }
        _detectPerformanceLevel() {
          const memory = navigator.deviceMemory || 4;
          const cores = navigator.hardwareConcurrency || 4;
          if (memory >= 8 && cores >= 8) return "high";
          if (memory >= 4 && cores >= 4) return "medium";
          return "low";
        }
        _detectReducedMotion() {
          return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        }
        async initialize() {
          await super.initialize();
          this.rootNavBar = document.querySelector(".Root__nav-bar");
          if (!this.rootNavBar) {
            this.initialized = false;
            return;
          }
          this._createOverlayContainer();
          this._createVisualEffectsElement();
          this.createHarmonicModeDisplay();
          this.updateColors();
          if (this.rootNavBar) {
            this._navInteractionHandler = (evt) => {
              const el = evt.target;
              if (!el || !(el instanceof HTMLElement)) return;
              if (el.matches("a, button, [role='link']")) {
                this._spawnNavEcho(el);
              }
            };
            this.rootNavBar.addEventListener(
              "focusin",
              this._navInteractionHandler,
              true
            );
            this.rootNavBar.addEventListener(
              "pointerenter",
              this._navInteractionHandler,
              true
            );
          }
          this._tryRegisterWithMasterAnimation();
          this._setupResizeObserver();
        }
        _createOverlayContainer() {
          this.overlayContainer = document.createElement("div");
          this.overlayContainer.id = "sidebar-visual-effects-overlay";
          this.overlayContainer.style.position = "absolute";
          this.overlayContainer.style.pointerEvents = "none";
          this.overlayContainer.style.zIndex = "1000";
          document.body.appendChild(this.overlayContainer);
        }
        _setupResizeObserver() {
          if (!this.rootNavBar || !this.overlayContainer) return;
          this.resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
              const { left, top, width, height } = entry.contentRect;
              if (this.overlayContainer) {
                this.overlayContainer.style.left = `${left}px`;
                this.overlayContainer.style.top = `${top}px`;
                this.overlayContainer.style.width = `${width}px`;
                this.overlayContainer.style.height = `${height}px`;
              }
            }
          });
          this.resizeObserver.observe(this.rootNavBar);
        }
        _tryRegisterWithMasterAnimation() {
          if (this.year3000System && this.year3000System.registerAnimationSystem) {
            try {
              this.year3000System.registerAnimationSystem(
                "SidebarVisualEffectsSystem",
                this,
                "background",
                this.deviceCapabilities.performanceLevel === "high" ? 30 : 15
              );
              this.masterAnimationRegistered = true;
              this.isUsingMasterAnimation = true;
            } catch (error) {
              this._startFallbackVisualEffectsLoop();
            }
          } else {
            this._startFallbackVisualEffectsLoop();
          }
        }
        /**
         * ✅ RAF LOOP CONSOLIDATION: Fallback removed - now always uses coordinator
         * VisualSystemCoordinator.registerAnimationSystems() handles registration automatically
         */
        _startFallbackVisualEffectsLoop() {
          this.isUsingMasterAnimation = true;
        }
        updateAnimation(deltaTime) {
          if (this.deviceCapabilities.reducedMotion || !this.visualEffectsElement || !this.rootNavBar)
            return;
          const timestamp = performance.now();
          const time = timestamp * 1e-3;
          const pulse = Math.sin(time * 2) * 0.1 + 0.9;
          this.animationState.targetScale = pulse;
          this.animationState.currentScale += (this.animationState.targetScale - this.animationState.currentScale) * this.animationState.smoothingFactor;
          this.visualEffectsElement.style.transform = `translateX(-50%) scale(${this.animationState.currentScale.toFixed(
            3
          )})`;
          if (this.harmonicModeIndicator) {
            const opacity = (Math.sin(time * 1.5) * 0.1 + 0.85).toFixed(2);
            this.harmonicModeIndicator.style.opacity = opacity;
          }
        }
        onPerformanceModeChange(mode) {
          if (mode === "low") {
            this.animationState.smoothingFactor = 0.3;
          } else {
            this.animationState.smoothingFactor = 0.15;
          }
        }
        handleSettingsChange(event) {
          super.handleSettingsChange(event);
          if (event.detail.key === "sn-harmonic-mode") {
            this.updateHarmonicModeDisplay(event.detail.value);
          }
        }
        _createVisualEffectsElement() {
          if (!this.overlayContainer) return;
          this.visualEffectsElement = document.createElement("div");
          this.visualEffectsElement.className = "sidebar-visual-effects-element";
          this.overlayContainer.appendChild(this.visualEffectsElement);
        }
        createHarmonicModeDisplay() {
          if (!this.overlayContainer) return;
          this.harmonicModeIndicator = document.createElement("div");
          this.harmonicModeIndicator.className = "harmonic-mode-indicator";
          this.overlayContainer.appendChild(this.harmonicModeIndicator);
        }
        updateColors() {
          if (!this.visualEffectsElement || !this.harmonicModeIndicator || !this.rootNavBar)
            return;
          const computedStyle = getComputedStyle(this.rootNavBar);
          const bgColor = computedStyle.getPropertyValue("--spice-sidebar");
          const textColor = computedStyle.getPropertyValue("--spice-text");
          this.visualEffectsElement.style.backgroundColor = bgColor;
          this.visualEffectsElement.style.borderColor = textColor;
          this.visualEffectsElement.style.borderWidth = "1px";
          this.visualEffectsElement.style.borderStyle = "solid";
          if (this.harmonicModeIndicator) {
            this.harmonicModeIndicator.style.backgroundColor = `rgba(${this.utils.hexToRgb(textColor)?.r}, ${this.utils.hexToRgb(textColor)?.g}, ${this.utils.hexToRgb(textColor)?.b}, 0.1)`;
            this.harmonicModeIndicator.style.color = textColor;
          }
        }
        updateHarmonicModeDisplay(newModeKey) {
          this.currentHarmonicModeKey = newModeKey;
          if (this.rootNavBar) {
            const classList = this.rootNavBar.classList;
            classList.forEach((className) => {
              if (className.startsWith("sn-color-harmony-")) {
                classList.remove(className);
              }
            });
            const mode = HARMONIC_MODES2[newModeKey];
            const cssClassName = this.HARMONIC_MODE_TO_CSS_CLASS[newModeKey];
            if (mode && cssClassName) {
              this.rootNavBar.classList.add(cssClassName);
            }
          }
        }
        _updateSidebarVariables(processedMusicData = {}) {
          if (!this.rootNavBar) return;
          const {
            visualIntensity = 0.5,
            moodIdentifier = "neutral",
            energyLevel = "low"
          } = processedMusicData;
          this.rootNavBar.classList.remove(
            "sn-music-low-energy",
            "sn-music-mid-energy",
            "sn-music-high-energy"
          );
          this.rootNavBar.classList.add(`sn-music-${energyLevel}-energy`);
          this.rootNavBar.setAttribute("data-mood", moodIdentifier);
          const glow = Math.max(0, Math.min(1, visualIntensity));
          const textOpacity = Math.min(0.5, glow * 0.6);
          const applyCss = /* @__PURE__ */ __name((prop, val) => {
            if (this.year3000System && this.year3000System.queueCSSVariableUpdate) {
              this.year3000System.queueCSSVariableUpdate(
                prop,
                val,
                this.rootNavBar
              );
            } else {
              this.rootNavBar.style.setProperty(prop, val);
            }
          }, "applyCss");
          applyCss("--sn-nav-item-glow-intensity", `${glow}`);
          applyCss("--sn-nav-text-energy-opacity", `${textOpacity}`);
          applyCss("--sidebar-intensity", `${visualIntensity}`);
        }
        updateFromMusicAnalysis(processedMusicData, rawFeatures, trackUri) {
          if (!this.initialized) return;
          super.updateFromMusicAnalysis(processedMusicData);
          this._updateSidebarVariables(processedMusicData);
        }
        updateModeConfiguration(modeConfig) {
          super.updateModeConfiguration(modeConfig);
          this.currentHarmonicModeKey = modeConfig.activeMode || "artist-vision";
          this.updateVisualEffectsForMode();
          this.updateHarmonicModeDisplay(this.currentHarmonicModeKey);
        }
        updateVisualEffectsForMode() {
          if (this.visualEffectsElement) {
            const intensity = this.modeConfig?.intensityMultiplier || 1;
            this.visualEffectsElement.style.opacity = `${0.1 * intensity}`;
          }
        }
        destroy() {
          if (this.year3000System?.timerConsolidationSystem) {
            for (let i = 0; i < this.echoTimerCounter; i++) {
              this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer(
                `SidebarVisualEffectsSystem-echo-${i}`
              );
            }
          }
          if (this.rootNavBar && this._navInteractionHandler) {
            this.rootNavBar.removeEventListener(
              "focusin",
              this._navInteractionHandler,
              true
            );
            this.rootNavBar.removeEventListener(
              "pointerenter",
              this._navInteractionHandler,
              true
            );
            this._navInteractionHandler = null;
          }
          if (this.year3000System && this.year3000System.unregisterAnimationSystem) {
            this.year3000System.unregisterAnimationSystem(
              "SidebarVisualEffectsSystem"
            );
          }
          if (this.resizeObserver && this.rootNavBar) {
            this.resizeObserver.unobserve(this.rootNavBar);
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
          }
          if (this.overlayContainer && this.overlayContainer.parentNode) {
            this.overlayContainer.parentNode.removeChild(this.overlayContainer);
            this.overlayContainer = null;
          }
          if (this.rootNavBar) {
            const classList = this.rootNavBar.classList;
            classList.forEach((className) => {
              if (className.startsWith("sn-")) {
                classList.remove(className);
              }
            });
          }
          super.destroy();
        }
        // -------------------------------------------------------------------------
        // ⚡ TEMPORAL ECHO HELPERS (shared with BeatSync/DataGlyph)
        // -------------------------------------------------------------------------
        get echoIntensitySetting() {
          const val = "2";
          const parsed = parseInt(val, 10);
          return isNaN(parsed) ? 2 : parsed;
        }
        get dynamicMaxEchoes() {
          switch (this.echoIntensitySetting) {
            case 0:
              return 0;
            case 1:
              return Math.ceil(_SidebarVisualEffectsSystem.BASE_MAX_ECHOES / 2);
            case 3:
              return _SidebarVisualEffectsSystem.BASE_MAX_ECHOES * 2;
            default:
              return _SidebarVisualEffectsSystem.BASE_MAX_ECHOES;
          }
        }
        _acquireEchoElement() {
          let el = this.echoPool.pop();
          if (el) {
            el.style.animation = "none";
            void el.offsetWidth;
            el.style.animation = "";
          } else {
            el = document.createElement("div");
            el.className = "sn-temporal-echo";
          }
          return el;
        }
        _releaseEchoElement(el) {
          if (this.echoPool.length < 20) this.echoPool.push(el);
        }
        _spawnNavEcho(element) {
          if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
          if (this.currentEchoCount >= this.dynamicMaxEchoes) return;
          if (this.echoIntensitySetting === 0) return;
          if (this._elementsWithActiveEcho.has(element)) return;
          const musicData = this.musicSyncService?.getLatestProcessedData() ?? {};
          const energy = musicData.energy ?? 0.5;
          const valence = musicData.valence ?? 0.5;
          const radius = Math.min(1.4, 1 + energy * 0.4);
          const hueShift = ((valence - 0.5) * 40).toFixed(1);
          const rect = element.getBoundingClientRect();
          const normX = rect.left / window.innerWidth;
          const normY = rect.top / window.innerHeight;
          const vec = sample(normX, normY);
          const beatVec = this.musicSyncService?.getCurrentBeatVector?.() ?? {
            x: 0,
            y: 0
          };
          const offsetMagnitude = 6 + energy * 6;
          let offsetX = (vec.x + beatVec.x) * offsetMagnitude;
          let offsetY = (vec.y + beatVec.y) * offsetMagnitude;
          const skewDeg = vec.x * 6;
          const baseAngle = (Math.random() * 360).toFixed(1);
          const echo = this._acquireEchoElement();
          echo.style.setProperty("--sn-echo-radius-multiplier", radius.toFixed(2));
          echo.style.setProperty("--sn-echo-hue-shift", `${hueShift}deg`);
          echo.style.setProperty("--sn-echo-offset-x", `${offsetX.toFixed(1)}px`);
          echo.style.setProperty("--sn-echo-offset-y", `${offsetY.toFixed(1)}px`);
          echo.style.setProperty("--sn-echo-skew", `${skewDeg.toFixed(2)}deg`);
          echo.style.setProperty("--sn-echo-rotate", `${baseAngle}deg`);
          element.appendChild(echo);
          this.currentEchoCount++;
          this._elementsWithActiveEcho.add(element);
          const timerId = `SidebarVisualEffectsSystem-echo-${this.echoTimerCounter++}`;
          const cleanup = /* @__PURE__ */ __name(() => {
            if (echo.parentElement) echo.parentElement.removeChild(echo);
            this.currentEchoCount--;
            this._releaseEchoElement(echo);
            this._elementsWithActiveEcho.delete(element);
          }, "cleanup");
          if (this.year3000System?.timerConsolidationSystem) {
            this.year3000System.timerConsolidationSystem.registerConsolidatedTimer(
              timerId,
              cleanup,
              1100,
              "background"
            );
          } else {
            setTimeout(cleanup, 1100);
          }
        }
        // ---------------------------------------------------------------------
        // 🏎️  Performance-Aware Animation Gate
        // ---------------------------------------------------------------------
        /**
         * Overrides the base implementation so we can toggle a lightweight
         * CSS class (`sn-motion-disabled`) on the sidebar element whenever the
         * active PerformanceProfile suggests a "low" tier or when reduced motion
         * should be respected.  This allows the SCSS layer to instantly pause
         * expensive keyframes (vibrations, pulses, hue-shifts) without touching
         * inline styles.
         */
        applyPerformanceSettings(profile) {
          super.applyPerformanceSettings(profile);
          const lowPerf = !profile.enableGPUAcceleration || profile.animationThrottle >= 24;
          const motionDisabled = lowPerf || profile.reducedMotion;
          if (this.rootNavBar) {
            if (motionDisabled !== this._lastMotionDisabled) {
              this.rootNavBar.classList.toggle("sn-motion-disabled", motionDisabled);
              this._lastMotionDisabled = motionDisabled;
            }
          }
        }
        // =========================================================================
        // FLOW PHYSICS SYSTEM (from SidebarInteractiveFlowSystem)
        // =========================================================================
        /**
         * Setup effect points for visual interaction feedback
         */
        setupEffectPoints() {
          this.visualState.effectPoints = [];
          const gridSize = 8;
          const spacing = 20;
          for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
              const effectPoint = {
                x: x * spacing,
                y: y * spacing,
                magnitude: 0.5 + Math.random() * 0.5,
                direction: Math.random() * Math.PI * 2,
                influence: 0.3 + Math.random() * 0.4
              };
              this.visualState.effectPoints.push(effectPoint);
            }
          }
        }
        /**
         * Setup interaction patterns for user feedback responses
         */
        setupInteractionPatterns() {
          this.interactionPatterns.set("hover", {
            id: "hover",
            type: "hover",
            response: {
              intensityChange: 0.2,
              velocityChange: 0.1,
              smoothingChange: -0.1,
              visualEffects: [{
                center: { x: 0, y: 0 },
                radius: 30,
                strength: 0.3,
                decay: 0.05,
                type: "wave"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 300,
            easing: "smooth",
            priority: 3
          });
          this.interactionPatterns.set("click", {
            id: "click",
            type: "click",
            response: {
              intensityChange: 0.5,
              velocityChange: 0.3,
              smoothingChange: -0.2,
              visualEffects: [{
                center: { x: 0, y: 0 },
                radius: 50,
                strength: 0.7,
                decay: 0.08,
                type: "pulse"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 500,
            easing: "smooth",
            priority: 8
          });
          this.interactionPatterns.set("focus", {
            id: "focus",
            type: "focus",
            response: {
              intensityChange: 0.3,
              velocityChange: 0.05,
              smoothingChange: 0.1,
              visualEffects: [{
                center: { x: 0, y: 0 },
                radius: 40,
                strength: 0.4,
                decay: 0.02,
                type: "spiral"
              }],
              rippleEffect: false,
              glowEffect: true
            },
            duration: 1e3,
            easing: "smooth",
            priority: 6
          });
        }
        /**
         * Setup proximity detection using Intersection Observer
         */
        setupProximityDetection() {
          if (typeof IntersectionObserver !== "undefined") {
            this.proximityObserver = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  const element = entry.target;
                  const elementId = element.id || element.className;
                  if (entry.isIntersecting) {
                    this.interactionElements.set(elementId, element);
                    this.handleProximityEnter(element);
                  } else {
                    this.interactionElements.delete(elementId);
                    this.handleProximityExit(element);
                  }
                });
              },
              {
                threshold: [0, 0.1, 0.5, 1],
                rootMargin: `${this.PROXIMITY_THRESHOLD}px`
              }
            );
          }
        }
        /**
         * Handle proximity enter for visual feedback
         */
        handleProximityEnter(element) {
          const rect = element.getBoundingClientRect();
          const center = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          };
          const distance2 = Math.sqrt(
            Math.pow(center.x - this.cursorPosition.x, 2) + Math.pow(center.y - this.cursorPosition.y, 2)
          );
          this.userInteractionState.proximityElements.push({
            element,
            distance: distance2,
            influence: Math.max(0, 1 - distance2 / this.PROXIMITY_THRESHOLD)
          });
        }
        /**
         * Handle proximity exit for liquid visual effects
         */
        handleProximityExit(element) {
          this.userInteractionState.proximityElements = this.userInteractionState.proximityElements.filter((item) => item.element !== element);
        }
        /**
         * Update visual effects processing
         */
        updateVisualEffects() {
          this.activeEffects = this.activeEffects.filter((effect) => {
            effect.strength *= 1 - effect.decay;
            return effect.strength > 0.01;
          });
          this.activeEffects.forEach((effect) => {
            this.visualState.effectPoints.forEach((point) => {
              const distance2 = Math.sqrt(
                Math.pow(point.x - effect.center.x, 2) + Math.pow(point.y - effect.center.y, 2)
              );
              if (distance2 < effect.radius) {
                const influence = effect.strength * (1 - distance2 / effect.radius);
                switch (effect.type) {
                  case "wave":
                    point.magnitude += influence * 0.3;
                    break;
                  case "spiral":
                    point.direction += influence * 0.5;
                    break;
                  case "pulse":
                    point.magnitude += influence * 0.5;
                    point.direction += influence * 0.2;
                    break;
                  case "vortex":
                    const angle = Math.atan2(
                      point.y - effect.center.y,
                      point.x - effect.center.x
                    );
                    point.direction = angle + influence * Math.PI * 0.5;
                    break;
                }
              }
            });
          });
        }
        /**
         * Update music visual effects
         */
        updateMusicVisualEffects() {
          const musicIntensity = this.musicBeatIntensity * 0.3;
          this.visualState.intensity = Math.max(this.visualState.intensity, musicIntensity);
          const musicVelocityBoost = this.musicEnergyLevel * 30;
          this.visualState.velocity = Math.min(200, this.visualState.velocity + musicVelocityBoost);
          const musicSmoothingAdjustment = (1 - this.musicEnergyLevel) * 0.2;
          this.visualState.smoothing = Math.max(0.1, this.visualState.smoothing - musicSmoothingAdjustment);
        }
        /**
         * Get current visual state for external access
         */
        getVisualState() {
          return { ...this.visualState };
        }
        /**
         * Get user interaction state for external access
         */
        getUserInteractionState() {
          return { ...this.userInteractionState };
        }
        /**
         * Get active effects for external access
         */
        getActiveEffects() {
          return [...this.activeEffects];
        }
      };
      __name(_SidebarVisualEffectsSystem, "SidebarVisualEffectsSystem");
      _SidebarVisualEffectsSystem.BASE_MAX_ECHOES = 4;
      SidebarVisualEffectsSystem = _SidebarVisualEffectsSystem;
    }
  });

  // src-js/visual/effects/UIVisualEffectsController.ts
  var _UIEffectsController, UIEffectsController;
  var init_UIVisualEffectsController = __esm({
    "src-js/visual/effects/UIVisualEffectsController.ts"() {
      "use strict";
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_BaseVisualSystem();
      _UIEffectsController = class _UIEffectsController extends BaseVisualSystem {
        constructor(config, utils, performanceAnalyzer2, musicSyncService, settingsManager2) {
          super(
            config,
            utils,
            performanceAnalyzer2,
            musicSyncService,
            settingsManager2
          );
          // BackgroundSystemParticipant implementation
          this.systemName = "UIVisualEffectsController";
          /** @deprecated Use systemName instead */
          this.legacySystemName = "UIVisualEffectsController";
          // Initialized in initializeCSSConsciousness
          this.visualEffectsCoordinator = null;
          this.currentVisualField = null;
          /** @deprecated Use currentVisualField instead */
          this.currentConsciousnessField = null;
          // Element management
          this.shimmerElements = /* @__PURE__ */ new Map();
          this.mutationObserver = null;
          this.intersectionObserver = null;
          // Animation and timing
          // ✅ RAF LOOP CONSOLIDATION: Removed animationFrameId (coordinator manages animation)
          this.lastFrameTime = 0;
          this.frameTimeHistory = [];
          // Event subscriptions
          this.eventUnsubscribeFunctions = [];
          // Performance monitoring (override base performance monitor with custom metrics)
          this.customPerformanceMonitor = {
            frameCount: 0,
            totalFrameTime: 0,
            lastPerformanceCheck: 0,
            adaptiveQualityLevel: 1
          };
          // Diagnostic state
          this.diagnosticTimerId = null;
          this.lastDiagnosticRun = 0;
          this.uiEffectsConfig = {
            enabled: true,
            activityThreshold: 0.3,
            // Shimmer defaults (from IridescentShimmerEffectsSystem)
            shimmerEnabled: true,
            shimmerIntensity: 0.6,
            shimmerType: "mixed",
            shimmerPerformanceLevel: "balanced",
            // Interaction defaults (from InteractionTrackingSystem)
            interactionTrackingEnabled: true,
            digitalMeditationThreshold: 3e4,
            // 30 seconds
            scrollVelocityTracking: true,
            // Diagnostic defaults (from WhiteLayerDiagnosticSystem)
            diagnosticEnabled: true,
            autoFixWhiteLayer: true,
            diagnosticInterval: 5e3,
            // 5 seconds
            // Audio-visual defaults (from AudioVisualController) - connected to user settings
            audioVisualEnabled: true,
            beatSynchronization: true,
            nebulaEffectIntensity: this.getNebulaIntensityFromSettings(),
            // Scroll effects defaults (from PrismaticScrollSheenSystem)
            scrollEffectsEnabled: true,
            prismaticSheenIntensity: 0.5,
            // Performance defaults
            maxFrameTime: 1,
            // <1ms budget
            adaptiveQuality: true,
            debugMode: config.enableDebug || false
          };
          this.activityState = this.createInitialActivityState();
          Y3KDebug?.debug?.log(
            "UIVisualEffectsController",
            "Unified UI effects controller created"
          );
        }
        get systemPriority() {
          return "normal";
        }
        /**
         * Get nebula effect intensity from user settings with layered enhancement
         */
        getNebulaIntensityFromSettings() {
          if (!this.settingsManager) {
            return 0.7;
          }
          const setting = this.settingsManager.get("sn-gradient-intensity");
          switch (setting) {
            case "disabled":
              return 0;
            case "minimal":
              return 0.3;
            case "balanced":
              return 0.7;
            case "intense":
              return 1;
            default:
              return 0.7;
          }
        }
        createInitialActivityState() {
          return {
            activityLevel: "dormant",
            shimmer: {
              intensity: 0,
              effectType: "mixed",
              activeElements: /* @__PURE__ */ new Set(),
              performanceLevel: this.uiEffectsConfig.shimmerPerformanceLevel
            },
            interaction: {
              isActive: false,
              lastInteractionTime: 0,
              digitalMeditationDetected: false,
              scrollVelocity: { x: 0, y: 0, direction: "none" },
              nexusState: "idle"
            },
            diagnostic: {
              whiteLayerIssues: [],
              webglContextHealthy: true,
              lastDiagnosticTime: 0,
              autoFixEnabled: this.uiEffectsConfig.autoFixWhiteLayer,
              criticalIssuesDetected: 0
            },
            audioVisual: {
              beatIntensity: 0,
              genreChangeDetected: false,
              nebulaEffectIntensity: 0,
              lastBeatTime: 0,
              performanceAdaptive: this.uiEffectsConfig.adaptiveQuality
            },
            scroll: {
              sheenIntensity: 0,
              scrollRatio: 0,
              prismaticEffectActive: false,
              lastScrollTime: 0
            },
            performance: {
              frameTime: 0,
              avgFrameTime: 0,
              maxFrameTime: 0,
              healthStatus: "excellent",
              adaptiveQualityEnabled: this.uiEffectsConfig.adaptiveQuality
            }
          };
        }
        // BaseVisualSystem implementation
        async initialize() {
          try {
            Y3KDebug?.debug?.log(
              "UIVisualEffectsController",
              "Starting unified UI effects initialization..."
            );
            await this.initializeVisualCSS();
            await this.initializeVisualCoordination();
            this.subscribeToUnifiedEvents();
            if (this.uiEffectsConfig.shimmerEnabled) {
              await this.initializeShimmerEffects();
            }
            if (this.uiEffectsConfig.interactionTrackingEnabled) {
              await this.initializeInteractionTracking();
            }
            if (this.uiEffectsConfig.diagnosticEnabled) {
              await this.initializeDiagnosticSystem();
            }
            if (this.uiEffectsConfig.audioVisualEnabled) {
              await this.initializeAudioVisualEffects();
            }
            if (this.uiEffectsConfig.scrollEffectsEnabled) {
              await this.initializeScrollEffects();
            }
            this.initialized = true;
            Y3KDebug?.debug?.log(
              "UIVisualEffectsController",
              "Unified UI effects controller initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UIVisualEffectsController",
              "Failed to initialize:",
              error
            );
            throw error;
          }
        }
        async initializeVisualCSS() {
          return this.initializeCSSConsciousness();
        }
        /**
         * @deprecated Use initializeVisualCSS instead
         */
        async initializeCSSConsciousness() {
          try {
            this.cssController = globalThis.unifiedVisualCSSController || globalThis.unifiedCSSConsciousnessController || null;
            this.cssController = getGlobalOptimizedCSSController();
            if (!this.cssController) {
              Y3KDebug?.debug?.warn(
                "UIVisualEffectsController",
                "CSS visual effects not available, using coordinator fallback"
              );
            } else {
              Y3KDebug?.debug?.log(
                "UIVisualEffectsController",
                "Connected to unified CSS visual effects"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "UIVisualEffectsController",
              "CSS visual effects initialization failed:",
              error
            );
          }
        }
        async initializeVisualCoordination() {
          return this.initializeConsciousnessIntegration();
        }
        /**
         * @deprecated Use initializeVisualCoordination instead
         */
        async initializeConsciousnessIntegration() {
          try {
            this.visualEffectsCoordinator = globalThis.backgroundVisualCoordinator || globalThis.backgroundConsciousnessChoreographer || null;
            if (this.visualEffectsCoordinator) {
              if (this.visualEffectsCoordinator.registerVisualEffectsParticipant) {
                this.visualEffectsCoordinator.registerVisualEffectsParticipant(this);
              } else if (this.visualEffectsCoordinator.registerConsciousnessParticipant) {
                this.visualEffectsCoordinator.registerConsciousnessParticipant(this);
              }
              Y3KDebug?.debug?.log(
                "UIVisualEffectsController",
                "Registered with visual effects coordinator"
              );
            } else {
              Y3KDebug?.debug?.log(
                "UIVisualEffectsController",
                "Operating without visual effects coordinator integration"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "UIVisualEffectsController",
              "Visual coordination integration failed:",
              error
            );
          }
        }
        subscribeToUnifiedEvents() {
          const musicBeatUnsubscribe = unifiedEventBus.subscribe(
            "music:beat",
            this.handleMusicBeat.bind(this),
            "UIVisualEffectsController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(musicBeatUnsubscribe)
          );
          const musicEnergyUnsubscribe = unifiedEventBus.subscribe(
            "music:energy",
            this.handleMusicEnergy.bind(this),
            "UIVisualEffectsController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(musicEnergyUnsubscribe)
          );
          const settingsUnsubscribe = unifiedEventBus.subscribe(
            "settings:changed",
            this.handleSettingsChange.bind(this),
            "UIVisualEffectsController"
          );
          this.eventUnsubscribeFunctions.push(
            () => unifiedEventBus.unsubscribe(settingsUnsubscribe)
          );
          Y3KDebug?.debug?.log(
            "UIVisualEffectsController",
            `Subscribed to ${this.eventUnsubscribeFunctions.length} unified events`
          );
        }
        async initializeShimmerEffects() {
          try {
            this.setupElementObservers();
            await this.discoverShimmerElements();
            Y3KDebug?.debug?.log(
              "UIVisualEffectsController",
              `Shimmer effects initialized with ${this.shimmerElements.size} elements`
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UIVisualEffectsController",
              "Shimmer effects initialization failed:",
              error
            );
          }
        }
        async initializeInteractionTracking() {
          try {
            this.setupInteractionListeners();
            Y3KDebug?.debug?.log(
              "UIVisualEffectsController",
              "Interaction tracking initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UIVisualEffectsController",
              "Interaction tracking initialization failed:",
              error
            );
          }
        }
        async initializeDiagnosticSystem() {
          try {
            this.startDiagnosticMonitoring();
            Y3KDebug?.debug?.log(
              "UIVisualEffectsController",
              "Diagnostic system initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UIVisualEffectsController",
              "Diagnostic system initialization failed:",
              error
            );
          }
        }
        async initializeAudioVisualEffects() {
          try {
            Y3KDebug?.debug?.log(
              "UIVisualEffectsController",
              "Audio-visual effects initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UIVisualEffectsController",
              "Audio-visual effects initialization failed:",
              error
            );
          }
        }
        async initializeScrollEffects() {
          try {
            Y3KDebug?.debug?.log(
              "UIVisualEffectsController",
              "Scroll effects initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UIVisualEffectsController",
              "Scroll effects initialization failed:",
              error
            );
          }
        }
        setupElementObservers() {
          if (typeof MutationObserver !== "undefined") {
            this.mutationObserver = new MutationObserver((mutations) => {
              let hasNewElements = false;
              mutations.forEach((mutation) => {
                if (mutation.type === "childList") {
                  mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                      hasNewElements = true;
                    }
                  });
                }
              });
              if (hasNewElements) {
                this.discoverShimmerElements();
              }
            });
            this.mutationObserver.observe(document.body, {
              childList: true,
              subtree: true
            });
          }
          if (typeof IntersectionObserver !== "undefined") {
            this.intersectionObserver = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  const elementId = entry.target.getAttribute("data-shimmer-id");
                  if (elementId) {
                    if (entry.isIntersecting) {
                      this.activityState.shimmer.activeElements.add(elementId);
                    } else {
                      this.activityState.shimmer.activeElements.delete(
                        elementId
                      );
                    }
                  }
                });
              },
              { threshold: [0, 0.1, 0.5, 1] }
            );
          }
        }
        async discoverShimmerElements() {
          const selectors = [
            ".sn-card",
            // Unified selector (CardDOMWatcher)
            ".main-card-card",
            // Legacy selector (kept for transition)
            ".main-trackList-trackListRow",
            ".main-button-primary",
            ".main-playButton-button",
            '[data-testid="card-click-handler"]'
          ];
          let elementCount = 0;
          selectors.forEach((selector) => {
            const elements = document.querySelectorAll(selector);
            elements.forEach((element, index) => {
              const elementId = `shimmer-${selector.replace(/[^\w]/g, "_")}-${index}`;
              const htmlElement = element;
              htmlElement.setAttribute("data-shimmer-id", elementId);
              this.shimmerElements.set(elementId, htmlElement);
              if (this.intersectionObserver) {
                this.intersectionObserver.observe(htmlElement);
              }
              elementCount++;
            });
          });
          if (this.uiEffectsConfig.debugMode && elementCount > 0) {
            Y3KDebug?.debug?.log(
              "UIVisualEffectsController",
              `Discovered ${elementCount} shimmer elements`
            );
          }
        }
        setupInteractionListeners() {
          const interactionEvents = [
            "click",
            "keydown",
            "mousemove",
            "scroll",
            "touchstart"
          ];
          interactionEvents.forEach((eventType) => {
            document.addEventListener(
              eventType,
              () => {
                this.activityState.interaction.isActive = true;
                this.activityState.interaction.lastInteractionTime = Date.now();
                this.activityState.interaction.digitalMeditationDetected = false;
                this.updateNexusState();
              },
              { passive: true }
            );
          });
        }
        startDiagnosticMonitoring() {
          this.diagnosticTimerId = window.setInterval(() => {
            this.runDiagnosticCheck();
          }, this.uiEffectsConfig.diagnosticInterval);
        }
        /**
         * ✅ RAF LOOP REMOVED - Managed by EnhancedMasterAnimationCoordinator
         * Old method removed: startUnifiedAnimationLoop()
         * Replacement: updateAnimation(deltaTime) called by coordinator
         */
        /**
         * ✅ RAF LOOP CONSOLIDATION: Animation update method called by coordinator
         * Consolidates all UI effects updates in single coordinated frame
         */
        updateAnimation(deltaTime) {
          if (!this.initialized) return;
          const currentTime = performance.now();
          this.lastFrameTime = currentTime;
          const frameStartTime = currentTime;
          try {
            this.updateVisualActivityState(deltaTime);
            if (this.uiEffectsConfig.shimmerEnabled) {
              this.updateShimmerEffects(deltaTime);
            }
            if (this.uiEffectsConfig.interactionTrackingEnabled) {
              this.updateInteractionTracking(deltaTime);
            }
            if (this.uiEffectsConfig.audioVisualEnabled) {
              this.updateAudioVisualEffects(deltaTime);
            }
            if (this.uiEffectsConfig.scrollEffectsEnabled) {
              this.updateScrollEffects(deltaTime);
            }
            this.applyCSSUpdates();
            const frameTime = performance.now() - frameStartTime;
            this.updatePerformanceMetrics(frameTime);
            if (frameTime > this.uiEffectsConfig.maxFrameTime) {
              this.handlePerformanceIssue(frameTime);
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UIVisualEffectsController",
              "Animation loop error:",
              error
            );
          }
        }
        updateVisualActivityState(deltaTime) {
          const state = this.activityState;
          const totalActivity = state.shimmer.intensity * 0.2 + (state.interaction.isActive ? 0.3 : 0) + state.audioVisual.beatIntensity * 0.3 + state.scroll.sheenIntensity * 0.2;
          if (totalActivity > 0.8) {
            state.activityLevel = "enhanced";
            state.transcendentLevel = "advanced";
          } else if (totalActivity > 0.5) {
            state.activityLevel = "focused";
          } else if (totalActivity > 0.2) {
            state.activityLevel = "aware";
          } else {
            state.activityLevel = "dormant";
          }
        }
        updateShimmerEffects(deltaTime) {
          const shimmerState = this.activityState.shimmer;
          const musicInfluence = this.activityState.audioVisual.beatIntensity * 0.3;
          const interactionInfluence = this.activityState.interaction.isActive ? 0.2 : 0;
          shimmerState.intensity = Math.min(
            this.uiEffectsConfig.shimmerIntensity + musicInfluence + interactionInfluence,
            1
          );
          if (this.activityState.performance.healthStatus === "degraded") {
            shimmerState.intensity *= 0.7;
          } else if (this.activityState.performance.healthStatus === "critical") {
            shimmerState.intensity *= 0.3;
          }
        }
        updateInteractionTracking(deltaTime) {
          const interactionState = this.activityState.interaction;
          const now = Date.now();
          const inactiveTime = now - interactionState.lastInteractionTime;
          if (inactiveTime > this.uiEffectsConfig.digitalMeditationThreshold) {
            if (!interactionState.digitalMeditationDetected) {
              interactionState.digitalMeditationDetected = true;
              Y3KDebug?.debug?.log(
                "UIVisualEffectsController",
                "Digital meditation detected",
                { inactiveTime }
              );
            }
          }
          this.updateNexusState();
        }
        updateNexusState() {
          const state = this.activityState.interaction;
          const now = Date.now();
          const timeSinceInteraction = now - state.lastInteractionTime;
          if (state.digitalMeditationDetected) {
            state.nexusState = "meditation";
          } else if (timeSinceInteraction < 1e3) {
            state.nexusState = "active";
          } else if (timeSinceInteraction < 1e4) {
            state.nexusState = "flow";
          } else {
            state.nexusState = "idle";
          }
        }
        updateAudioVisualEffects(deltaTime) {
          const audioState = this.activityState.audioVisual;
          const activityBoost = this.activityState.activityLevel === "enhanced" ? 0.2 : 0;
          audioState.nebulaEffectIntensity = Math.min(
            this.uiEffectsConfig.nebulaEffectIntensity + audioState.beatIntensity * 0.3 + activityBoost,
            1
          );
        }
        updateScrollEffects(deltaTime) {
          const scrollState = this.activityState.scroll;
          const timeSinceScroll = Date.now() - scrollState.lastScrollTime;
          if (timeSinceScroll < 1e3) {
            scrollState.prismaticEffectActive = true;
            scrollState.sheenIntensity = Math.min(
              scrollState.scrollRatio * this.uiEffectsConfig.prismaticSheenIntensity,
              1
            );
          } else {
            scrollState.prismaticEffectActive = false;
            scrollState.sheenIntensity *= 0.95;
          }
        }
        applyCSSUpdates() {
          const state = this.activityState;
          const updates = {
            // Core activity state
            "--sn-ui-activity-level": state.activityLevel,
            // Shimmer effects
            "--sn-shimmer-intensity": state.shimmer.intensity.toFixed(3),
            "--sn-shimmer-effect-type": state.shimmer.effectType,
            "--sn-shimmer-performance": state.shimmer.performanceLevel,
            // Interaction tracking
            "--sn-interaction-nexus-state": state.interaction.nexusState,
            "--sn-interaction-meditation": state.interaction.digitalMeditationDetected ? "1" : "0",
            "--sn-scroll-velocity-x": state.interaction.scrollVelocity.x.toFixed(2),
            "--sn-scroll-velocity-y": state.interaction.scrollVelocity.y.toFixed(2),
            // Audio-visual effects
            "--sn-beat-intensity": state.audioVisual.beatIntensity.toFixed(3),
            "--sn-nebula-intensity": state.audioVisual.nebulaEffectIntensity.toFixed(3),
            "--sn-genre-change": state.audioVisual.genreChangeDetected ? "1" : "0",
            // Scroll effects
            "--sn-scroll-sheen-intensity": state.scroll.sheenIntensity.toFixed(3),
            "--sn-scroll-ratio": state.scroll.scrollRatio.toFixed(3),
            "--sn-prismatic-active": state.scroll.prismaticEffectActive ? "1" : "0",
            // Diagnostic status
            "--sn-white-layer-issues": state.diagnostic.whiteLayerIssues.length.toString(),
            "--sn-webgl-healthy": state.diagnostic.webglContextHealthy ? "1" : "0"
          };
          try {
            this.cssController.batchSetVariables(
              "UIVisualEffectsController",
              updates,
              "normal",
              "ui-activity-update"
            );
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "UIVisualEffectsController",
              "CSS coordination error:",
              error
            );
          }
        }
        updatePerformanceMetrics(frameTime) {
          const perf = this.activityState.performance;
          perf.frameTime = frameTime;
          this.frameTimeHistory.push(frameTime);
          if (this.frameTimeHistory.length > 60) {
            this.frameTimeHistory.shift();
          }
          perf.avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
          perf.maxFrameTime = Math.max(...this.frameTimeHistory);
          if (perf.avgFrameTime > 2) {
            perf.healthStatus = "critical";
          } else if (perf.avgFrameTime > 1.5) {
            perf.healthStatus = "degraded";
          } else if (perf.avgFrameTime > 1) {
            perf.healthStatus = "good";
          } else {
            perf.healthStatus = "excellent";
          }
        }
        handlePerformanceIssue(frameTime) {
          if (this.uiEffectsConfig.adaptiveQuality) {
            this.customPerformanceMonitor.adaptiveQualityLevel *= 0.9;
            if (this.customPerformanceMonitor.adaptiveQualityLevel < 0.5) {
              this.activityState.shimmer.performanceLevel = "minimal";
            }
            if (this.uiEffectsConfig.debugMode) {
              Y3KDebug?.debug?.warn(
                "UIVisualEffectsController",
                `Performance issue: ${frameTime.toFixed(
                  2
                )}ms, reduced quality to ${this.customPerformanceMonitor.adaptiveQualityLevel.toFixed(
                  2
                )}`
              );
            }
          }
        }
        runDiagnosticCheck() {
          const diagnosticState = this.activityState.diagnostic;
          const now = Date.now();
          diagnosticState.lastDiagnosticTime = now;
          diagnosticState.whiteLayerIssues = [];
          try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            diagnosticState.webglContextHealthy = !!gl;
            const elements = document.querySelectorAll(
              '[style*="background"], [style*="color"]'
            );
            let whiteLayerCount = 0;
            elements.forEach((element) => {
              const style = window.getComputedStyle(element);
              if (style.backgroundColor === "rgb(255, 255, 255)" || style.color === "rgb(255, 255, 255)") {
                whiteLayerCount++;
              }
            });
            if (whiteLayerCount > 10) {
              diagnosticState.whiteLayerIssues.push(
                `Excessive white layers detected: ${whiteLayerCount}`
              );
              if (diagnosticState.autoFixEnabled) {
                this.autoFixWhiteLayerIssues();
              }
            }
            diagnosticState.criticalIssuesDetected = diagnosticState.whiteLayerIssues.length;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UIVisualEffectsController",
              "Diagnostic check failed:",
              error
            );
          }
        }
        autoFixWhiteLayerIssues() {
          try {
            this.cssController.batchSetVariables(
              "UIVisualEffectsController",
              {
                "--spice-text": "var(--spice-main)",
                "--spice-subtext": "var(--catppuccin-text)"
              },
              "critical",
              "white-layer-autofix"
            );
            if (this.uiEffectsConfig.debugMode) {
              Y3KDebug?.debug?.log(
                "UIVisualEffectsController",
                "Applied white layer auto-fix"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UIVisualEffectsController",
              "Auto-fix failed:",
              error
            );
          }
        }
        // Event handlers (consolidated from all systems)
        handleMusicBeat(event) {
          const audioState = this.activityState.audioVisual;
          audioState.beatIntensity = event.intensity || 0.5;
          audioState.lastBeatTime = Date.now();
          if (this.uiEffectsConfig.shimmerEnabled) {
            const beatBoost = audioState.beatIntensity * 0.2;
            this.activityState.shimmer.intensity = Math.min(
              this.activityState.shimmer.intensity + beatBoost,
              1
            );
          }
        }
        handleMusicEnergy(event) {
          const audioState = this.activityState.audioVisual;
          if (event.energy !== void 0) {
            audioState.beatIntensity = Math.max(
              audioState.beatIntensity,
              event.energy * 0.8
            );
          }
        }
        handleGenreChange(event) {
          const audioState = this.activityState.audioVisual;
          audioState.genreChangeDetected = true;
          setTimeout(() => {
            audioState.genreChangeDetected = false;
          }, 2e3);
        }
        handleUserScroll(event) {
          const scrollState = this.activityState.scroll;
          const interactionState = this.activityState.interaction;
          scrollState.lastScrollTime = Date.now();
          scrollState.scrollRatio = event.scrollRatio || 0;
          if (event.velocity) {
            interactionState.scrollVelocity = {
              x: event.velocity.x || 0,
              y: event.velocity.y || 0,
              direction: event.direction || "none"
            };
          }
          this.handleUserInteraction({ type: "scroll", timestamp: Date.now() });
        }
        handleUserInteraction(event) {
          const interactionState = this.activityState.interaction;
          interactionState.isActive = true;
          interactionState.lastInteractionTime = event.timestamp || Date.now();
          interactionState.digitalMeditationDetected = false;
          this.updateNexusState();
        }
        handleSettingsChange(event) {
          const { key, value } = event;
          if (key.startsWith("sn-ui-effects-")) {
            this.updateConfigFromSettings(key, value);
          } else if (key === "sn-gradient-intensity") {
            this.uiEffectsConfig.nebulaEffectIntensity = this.getNebulaIntensityFromSettings();
            Y3KDebug?.debug?.log(
              "UIVisualEffectsController",
              `Updated nebula intensity to: ${this.uiEffectsConfig.nebulaEffectIntensity} from consolidated gradient setting: ${value}`
            );
          }
        }
        updateConfigFromSettings(key, value) {
          switch (key) {
            case "sn-ui-effects-shimmer-intensity":
              this.uiEffectsConfig.shimmerIntensity = parseFloat(value) || 0.6;
              break;
            case "sn-ui-effects-diagnostic-enabled":
              this.uiEffectsConfig.diagnosticEnabled = value === "true" || value === true;
              break;
            case "sn-ui-effects-adaptive-quality":
              this.uiEffectsConfig.adaptiveQuality = value === "true" || value === true;
              break;
          }
        }
        // BackgroundSystemParticipant interface implementation - defer to main implementation below
        /**
         * @deprecated Use getVisualContribution instead
         */
        getConsciousnessContribution() {
          return {
            systemName: this.systemName,
            activityLevel: this.activityState.activityLevel,
            shimmerIntensity: this.activityState.shimmer.intensity,
            interactionState: this.activityState.interaction.nexusState,
            audioVisualIntensity: this.activityState.audioVisual.nebulaEffectIntensity,
            scrollActivity: this.activityState.scroll.sheenIntensity,
            timestamp: Date.now()
          };
        }
        onVisualFieldUpdate(field) {
          return this.onConsciousnessFieldUpdate(field);
        }
        /**
         * @deprecated Use onVisualFieldUpdate instead
         */
        onConsciousnessFieldUpdate(field) {
          try {
            this.currentVisualField = field;
            this.currentConsciousnessField = field;
            const fieldInfluence = field.pulseRate * 0.2;
            this.activityState.shimmer.intensity = Math.min(
              this.activityState.shimmer.intensity + fieldInfluence,
              1
            );
            this.activityState.audioVisual.nebulaEffectIntensity = Math.min(
              this.activityState.audioVisual.nebulaEffectIntensity + fieldInfluence * 0.3,
              1
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UIVisualEffectsController",
              "Error updating from visual effects state:",
              error
            );
          }
        }
        onVisualCoordinationEvent(eventType, data) {
          return this.onChoreographyEvent(eventType, data);
        }
        /**
         * @deprecated Use onVisualCoordinationEvent instead
         */
        onChoreographyEvent(eventType, data) {
          if (eventType === "transition:start") {
            this.activityState.shimmer.intensity = Math.min(
              this.activityState.shimmer.intensity + 0.2,
              1
            );
            this.activityState.audioVisual.nebulaEffectIntensity = Math.min(
              this.activityState.audioVisual.nebulaEffectIntensity + 0.15,
              1
            );
          }
          if (this.uiEffectsConfig.debugMode) {
            Y3KDebug?.debug?.log(
              "UIVisualEffectsController",
              `Visual coordination event: ${eventType}`,
              data
            );
          }
        }
        // Health check implementation
        async healthCheck() {
          const state = this.activityState;
          const isHealthy = this.initialized && state.performance.healthStatus !== "critical" && state.diagnostic.criticalIssuesDetected === 0;
          return {
            healthy: isHealthy,
            ok: isHealthy,
            details: `UI Effects Activity: ${state.activityLevel}, Shimmer: ${state.shimmer.activeElements.size} elements, Interaction: ${state.interaction.nexusState}, Performance: ${state.performance.healthStatus}, Diagnostics: ${state.diagnostic.criticalIssuesDetected} issues`,
            system: "UIVisualEffectsController"
          };
        }
        // Configuration API
        updateConfiguration(updates) {
          const previousConfig = { ...this.uiEffectsConfig };
          const updatedProperties = [];
          const validationErrors = [];
          try {
            for (const [key, value] of Object.entries(updates)) {
              if (key in this.uiEffectsConfig) {
                updatedProperties.push(key);
              } else {
                validationErrors.push(`Unknown configuration property: ${key}`);
              }
              if (key === "shimmerIntensity" && typeof value === "number" && (value < 0 || value > 1)) {
                validationErrors.push("shimmerIntensity must be between 0 and 1");
              }
              if (key === "digitalMeditationThreshold" && typeof value === "number" && value < 1e3) {
                validationErrors.push("digitalMeditationThreshold must be at least 1000ms");
              }
            }
            if (validationErrors.length === 0) {
              Object.assign(this.uiEffectsConfig, updates);
              if (updates.shimmerEnabled !== void 0) {
                if (updates.shimmerEnabled && !this.activityState.shimmer.activeElements.size) {
                  this.discoverShimmerElements();
                }
              }
              if (updates.diagnosticEnabled !== void 0) {
                if (updates.diagnosticEnabled && !this.diagnosticTimerId) {
                  this.startDiagnosticMonitoring();
                } else if (!updates.diagnosticEnabled && this.diagnosticTimerId) {
                  clearInterval(this.diagnosticTimerId);
                  this.diagnosticTimerId = null;
                }
              }
              Y3KDebug?.debug?.log(
                "UIEffectsController",
                "Configuration updated:",
                updates
              );
            }
            return {
              success: validationErrors.length === 0,
              updatedProperties,
              validationErrors,
              previousConfig,
              newConfig: { ...this.uiEffectsConfig }
            };
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "Unknown error during configuration update";
            return {
              success: false,
              updatedProperties,
              validationErrors: [...validationErrors, errorMessage],
              previousConfig,
              newConfig: previousConfig
            };
          }
        }
        getConfiguration() {
          return { ...this.uiEffectsConfig };
        }
        getVisualState() {
          return this.getConsciousnessState();
        }
        /**
         * @deprecated Use getVisualState instead
         */
        getConsciousnessState() {
          return { ...this.activityState };
        }
        /**
         * Generate comprehensive diagnostic report for UI effects system
         *
         * @returns Detailed diagnostic report with health metrics and recommendations
         *
         * @example
         * ```typescript
         * const report = uiController.generateDiagnosticReport();
         * if (report.systemHealth === 'critical') {
         *   console.warn('UI Effects in critical state:', report.issues);
         *   report.recommendations.forEach(rec => console.log('Recommendation:', rec));
         * }
         * ```
         */
        generateDiagnosticReport() {
          const now = performance.now();
          const memoryInfo = performance.memory;
          let healthScore = 100;
          const issues = {
            whiteLayerProblems: [...this.activityState.diagnostic.whiteLayerIssues],
            webglContextIssues: [],
            performanceWarnings: [],
            configurationErrors: []
          };
          const recommendations = [];
          if (this.activityState.performance.avgFrameTime > 33) {
            healthScore -= 20;
            issues.performanceWarnings.push(`High frame time: ${this.activityState.performance.avgFrameTime.toFixed(1)}ms`);
            recommendations.push("Consider reducing visual effect quality or disabling intensive effects");
          }
          if (!this.activityState.diagnostic.webglContextHealthy) {
            healthScore -= 30;
            issues.webglContextIssues.push("WebGL context is unhealthy or lost");
            recommendations.push("Restart visual effects or check browser WebGL support");
          }
          if (!this.uiEffectsConfig.enabled) {
            issues.configurationErrors.push("UI effects are disabled");
            recommendations.push("Enable UI effects in settings for full experience");
          }
          if (this.activityState.diagnostic.whiteLayerIssues.length > 0) {
            healthScore -= 15 * this.activityState.diagnostic.whiteLayerIssues.length;
            recommendations.push("Enable auto-fix for white layer issues or check CSS customizations");
          }
          let systemHealth;
          if (healthScore >= 90) systemHealth = "excellent";
          else if (healthScore >= 70) systemHealth = "good";
          else if (healthScore >= 50) systemHealth = "degraded";
          else systemHealth = "critical";
          return {
            timestamp: now,
            systemHealth,
            activeEffects: {
              shimmer: this.uiEffectsConfig.shimmerEnabled && this.activityState.shimmer.intensity > 0,
              interaction: this.uiEffectsConfig.interactionTrackingEnabled && this.activityState.interaction.isActive,
              audioVisual: this.uiEffectsConfig.audioVisualEnabled && this.activityState.audioVisual.beatIntensity > 0,
              scroll: this.uiEffectsConfig.scrollEffectsEnabled && this.activityState.scroll.prismaticEffectActive
            },
            performanceMetrics: {
              averageFrameTime: this.activityState.performance.avgFrameTime,
              maxFrameTime: this.activityState.performance.maxFrameTime,
              memoryUsage: memoryInfo?.usedJSHeapSize || 0,
              cpuUsage: this.activityState.performance.frameTime / 16.67
              // Percentage of 60fps budget
            },
            issues,
            recommendations
          };
        }
        // Legacy compatibility methods (for migration)
        getShimmerElements() {
          return new Map(this.shimmerElements);
        }
        getInteractionState() {
          return this.activityState.interaction;
        }
        getDiagnosticState() {
          return this.activityState.diagnostic;
        }
        async destroy() {
          Y3KDebug?.debug?.log(
            "UIVisualEffectsController",
            "Destroying unified UI effects controller..."
          );
          if (this.diagnosticTimerId) {
            clearInterval(this.diagnosticTimerId);
            this.diagnosticTimerId = null;
          }
          if (this.mutationObserver) {
            this.mutationObserver.disconnect();
            this.mutationObserver = null;
          }
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            this.intersectionObserver = null;
          }
          for (const unsubscribe of this.eventUnsubscribeFunctions) {
            unsubscribe();
          }
          this.eventUnsubscribeFunctions = [];
          this.shimmerElements.clear();
          if (this.visualEffectsCoordinator) {
          }
          this.initialized = false;
          Y3KDebug?.debug?.log(
            "UIVisualEffectsController",
            "Unified UI effects controller destroyed"
          );
        }
        // =========================================================================
        // BACKGROUND SYSTEM PARTICIPANT INTERFACE
        // =========================================================================
        onVisualStateUpdate(state) {
          if (state.musicIntensity > 0.6) {
            this.triggerIntensityEffects(state.musicIntensity);
          }
          if (state.colorTemperature) {
            this.updateTemperatureEffects(state.colorTemperature);
          }
        }
        onVisualEffectEvent(eventType, payload) {
          switch (eventType) {
            case "visual:rhythm-shift":
              this.triggerShimmerEffects(payload.intensity || 0.5);
              break;
            case "visual:color-shift":
              this.updateTemperatureEffects(payload.temperature || 6500);
              break;
            case "visual:energy-surge":
              if (payload.intensity > 0.7) {
                this.triggerIntensityEffects(payload.intensity);
              }
              break;
          }
        }
        getVisualContribution() {
          const sources = [];
          let confidence = 0;
          const contribution = {};
          if (this.uiEffectsConfig.shimmerEnabled && this.activityState.shimmer.intensity > 0) {
            contribution.visualCoherence = this.activityState.activityLevel === "enhanced" ? 1 : 0.7;
            contribution.systemHarmony = this.activityState.shimmer.intensity;
            sources.push("shimmer");
            confidence += 0.3;
          }
          if (this.uiEffectsConfig.audioVisualEnabled && this.activityState.audioVisual.nebulaEffectIntensity > 0) {
            contribution.effectDepth = this.activityState.audioVisual.nebulaEffectIntensity;
            contribution.energyLevel = this.activityState.audioVisual.beatIntensity;
            sources.push("audioVisual");
            confidence += 0.4;
          }
          if (this.activityState.interaction.isActive) {
            const flowMagnitude = Math.sqrt(
              this.activityState.interaction.scrollVelocity.x ** 2 + this.activityState.interaction.scrollVelocity.y ** 2
            );
            if (flowMagnitude > 0) {
              contribution.flowDirection = {
                x: this.activityState.interaction.scrollVelocity.x / 100,
                // Normalize
                y: this.activityState.interaction.scrollVelocity.y / 100
              };
              sources.push("interaction");
              confidence += 0.2;
            }
          }
          if (this.activityState.performance.healthStatus !== "critical") {
            sources.push("performance");
            confidence += 0.1;
          }
          return {
            contribution,
            confidence: Math.min(1, confidence),
            // Cap at 1.0
            sources,
            timestamp: performance.now()
          };
        }
        // =========================================================================
        // MISSING METHODS FOR VISUAL EFFECT INTEGRATION
        // =========================================================================
        triggerIntensityEffects(intensity) {
          if (this.uiEffectsConfig.shimmerEnabled) {
            this.activityState.shimmer.intensity = Math.min(
              this.activityState.shimmer.intensity + intensity * 0.3,
              1
            );
          }
          if (this.uiEffectsConfig.audioVisualEnabled) {
            this.activityState.audioVisual.nebulaEffectIntensity = Math.min(
              this.activityState.audioVisual.nebulaEffectIntensity + intensity * 0.2,
              1
            );
          }
          if (this.uiEffectsConfig.scrollEffectsEnabled) {
            this.activityState.scroll.sheenIntensity = Math.min(
              this.activityState.scroll.sheenIntensity + intensity * 0.1,
              1
            );
          }
        }
        updateTemperatureEffects(temperature) {
          const normalizedTemp = Math.max(1e3, Math.min(1e4, temperature));
          if (this.uiEffectsConfig.shimmerEnabled) {
            if (normalizedTemp < 3e3) {
              this.activityState.shimmer.effectType = "prism";
            } else if (normalizedTemp > 7e3) {
              this.activityState.shimmer.effectType = "oil-slick";
            } else {
              this.activityState.shimmer.effectType = "rainbow";
            }
          }
          const tempInfluence = (normalizedTemp - 1e3) / 9e3;
          if (this.uiEffectsConfig.audioVisualEnabled) {
            this.activityState.audioVisual.nebulaEffectIntensity = Math.min(
              this.activityState.audioVisual.nebulaEffectIntensity + tempInfluence * 0.1,
              1
            );
          }
        }
        triggerShimmerEffects(intensity) {
          if (!this.uiEffectsConfig.shimmerEnabled) return;
          this.activityState.shimmer.intensity = Math.min(
            this.activityState.shimmer.intensity + intensity * 0.4,
            1
          );
          const currentType = this.activityState.shimmer.effectType;
          this.activityState.shimmer.effectType = "mixed";
          setTimeout(() => {
            this.activityState.shimmer.effectType = currentType;
          }, 2e3);
        }
      };
      __name(_UIEffectsController, "UIEffectsController");
      UIEffectsController = _UIEffectsController;
    }
  });

  // src-js/core/base/UnifiedSystemBase.ts
  var _UnifiedSystemBase, UnifiedSystemBase;
  var init_UnifiedSystemBase = __esm({
    "src-js/core/base/UnifiedSystemBase.ts"() {
      "use strict";
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_EnhancedMasterAnimationCoordinator();
      init_UnifiedPerformanceCoordinator();
      init_globalConfig();
      _UnifiedSystemBase = class _UnifiedSystemBase {
        constructor(config = ADVANCED_SYSTEM_CONFIG) {
          // Core lifecycle state
          this.initialized = false;
          this.destroyed = false;
          // Event management
          this.eventUnsubscribers = [];
          // Performance tracking
          this.initializationStartTime = null;
          this.frameStartTime = 0;
          this.frameCount = 0;
          this.lastFPSCalculation = 0;
          this.currentFPS = 60;
          this.config = config;
          this.systemName = this.constructor.name;
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] UnifiedSystemBase constructor`);
          }
        }
        // Backward compatibility alias
        get cssConsciousnessController() {
          return this.cssController;
        }
        set cssConsciousnessController(value) {
          this.cssController = value;
        }
        // =========================================================================
        // UNIFIED LIFECYCLE MANAGEMENT
        // =========================================================================
        /**
         * Base initialization - sets up shared utilities and calls system-specific init
         */
        async _baseInitialize() {
          if (this.initialized) {
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Already initialized`);
            }
            return;
          }
          try {
            this.initializationStartTime = performance.now();
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Starting unified initialization`);
            }
            const globalSystem = globalThis.year3000System;
            if (globalSystem) {
              this.performanceAnalyzer = globalSystem.performanceAnalyzer || globalSystem.facadeCoordinator?.getCachedNonVisualSystem?.("SimplePerformanceCoordinator") || globalSystem.facadeCoordinator?.getCachedNonVisualSystem?.("PerformanceAnalyzer");
              this.cssController = globalSystem.cssController || globalSystem.cssConsciousnessController || getGlobalOptimizedCSSController();
              this.eventBus = unifiedEventBus;
              this.performanceCoordinator = globalSystem.performanceCoordinator || (this.performanceAnalyzer ? UnifiedPerformanceCoordinator.getInstance(this.config, this.performanceAnalyzer) : null);
              this.animationCoordinator = globalSystem.enhancedMasterAnimationCoordinator || (this.performanceCoordinator ? EnhancedMasterAnimationCoordinator.getInstance(this.config, this.performanceCoordinator) : null);
              this.unifiedCSSManager = globalSystem.unifiedCSSManager || getGlobalOptimizedCSSController();
            } else {
              this.cssController = getGlobalOptimizedCSSController();
              this.eventBus = unifiedEventBus;
              this.performanceCoordinator = UnifiedPerformanceCoordinator.getInstance(this.config, this.performanceAnalyzer);
              this.animationCoordinator = EnhancedMasterAnimationCoordinator.getInstance(this.config, this.performanceCoordinator);
              this.unifiedCSSManager = getGlobalOptimizedCSSController();
            }
            if (this.unifiedCSSManager && this.performanceAnalyzer && this.cssController) {
            }
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.recordMetric === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_registered`, 1);
            }
            await this.trackPerformanceAsync("initialize", async () => {
              await this._performSystemSpecificInitialization();
            });
            this.initialized = true;
            this.publishEvent("system:initialized", {
              systemName: this.systemName,
              timestamp: Date.now(),
              metadata: {
                initializationTime: this.initializationStartTime ? performance.now() - this.initializationStartTime : 0
              }
            });
            if (this.config.enableDebug) {
              const duration = this.initializationStartTime ? performance.now() - this.initializationStartTime : 0;
              console.log(`[${this.systemName}] Unified initialization complete (${duration.toFixed(2)}ms)`);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Initialization failed:`, error);
            this.publishEvent("system:initialization-failed", {
              systemName: this.systemName,
              error: error instanceof Error ? error.message : String(error),
              timestamp: Date.now()
            });
            throw error;
          }
        }
        /**
         * Base destruction - handles cleanup and calls system-specific destroy
         */
        _baseDestroy() {
          if (this.destroyed) {
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Already destroyed`);
            }
            return;
          }
          try {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Starting unified destruction`);
            }
            this.eventUnsubscribers.forEach((unsubscribe) => {
              try {
                unsubscribe();
              } catch (error) {
                console.warn(`[${this.systemName}] Error during event unsubscription:`, error);
              }
            });
            this.eventUnsubscribers = [];
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.recordMetric === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_unregistered`, 1);
            }
            this.destroy();
            this.destroyed = true;
            this.publishEvent("system:destroyed", {
              systemName: this.systemName,
              timestamp: Date.now()
            });
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Unified destruction complete`);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Destruction failed:`, error);
          }
        }
        // =========================================================================
        // SHARED UTILITY METHODS
        // =========================================================================
        /**
         * Update a single CSS variable with priority support
         */
        updateCSSVariable(property, value, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueUpdate(property, value, priority, this.systemName);
          } else if (this.cssController) {
            this.cssController.queueCSSVariableUpdate(property, value);
          } else {
            console.warn(`[${this.systemName}] CSS variable management not initialized`);
          }
        }
        /**
         * Update multiple CSS variables efficiently with priority support
         */
        updateCSSVariables(updates, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueTransaction(updates, priority, this.systemName);
          } else if (this.cssController) {
            Object.entries(updates).forEach(([property, value]) => {
              this.cssController.queueCSSVariableUpdate(property, value);
            });
          } else {
            console.warn(`[${this.systemName}] CSS variable management not initialized`);
          }
        }
        /**
         * Subscribe to events with automatic cleanup and retry logic
         */
        subscribeToEvent(event, callback) {
          if (!this.eventBus) {
            console.warn(`[${this.systemName}] Event bus not initialized - attempting to initialize`);
            try {
              this.eventBus = unifiedEventBus;
              if (!this.eventBus) {
                console.error(`[${this.systemName}] Failed to get unified event bus - event subscription deferred`);
                return () => {
                };
              }
            } catch (error) {
              console.error(`[${this.systemName}] Error accessing unified event bus:`, error);
              return () => {
              };
            }
          }
          try {
            const subscriptionId = this.eventBus.subscribe(event, callback, this.systemName);
            const unsubscribe = /* @__PURE__ */ __name(() => {
              this.eventBus.unsubscribe(subscriptionId);
            }, "unsubscribe");
            this.eventUnsubscribers.push(unsubscribe);
            return unsubscribe;
          } catch (error) {
            console.error(`[${this.systemName}] Failed to subscribe to event ${event}:`, error);
            return () => {
            };
          }
        }
        /**
         * Publish events to the global event bus
         */
        publishEvent(event, payload) {
          if (!this.eventBus) {
            console.warn(`[${this.systemName}] Event bus not initialized - attempting to initialize`);
            try {
              this.eventBus = unifiedEventBus;
              if (!this.eventBus) {
                console.error(`[${this.systemName}] Failed to get unified event bus - event publication skipped`);
                return;
              }
            } catch (error) {
              console.error(`[${this.systemName}] Error accessing unified event bus:`, error);
              return;
            }
          }
          try {
            this.eventBus.emitSync(event, payload);
          } catch (error) {
            console.error(`[${this.systemName}] Failed to publish event ${event}:`, error);
          }
        }
        /**
         * Track performance of synchronous operations
         */
        trackPerformance(operation, fn) {
          const startTime = performance.now();
          try {
            fn();
          } finally {
            const endTime = performance.now();
            const frameTime = endTime - startTime;
            this.trackSystemPerformance(frameTime);
            if (this.performanceAnalyzer && typeof this.performanceAnalyzer.timeOperation === "function") {
              this.performanceAnalyzer.recordMetric(`${this.systemName}_${operation}`, frameTime);
            }
          }
        }
        /**
         * Track performance of asynchronous operations
         */
        async trackPerformanceAsync(operation, fn) {
          if (!this.performanceAnalyzer || typeof this.performanceAnalyzer.timeOperationAsync !== "function") {
            await fn();
            return;
          }
          await this.performanceAnalyzer.timeOperationAsync(`${this.systemName}_${operation}`, fn);
        }
        /**
         * Track system performance metrics
         */
        trackSystemPerformance(frameTime) {
          if (!this.performanceCoordinator) return;
          this.frameCount++;
          const currentTime = performance.now();
          if (currentTime - this.lastFPSCalculation >= 1e3) {
            this.currentFPS = this.frameCount;
            this.frameCount = 0;
            this.lastFPSCalculation = currentTime;
          }
          const memoryUsage = performance.memory?.usedJSHeapSize || 0;
          this.performanceCoordinator.trackSubsystem(this.systemName, {
            frameTime,
            memoryUsage,
            fps: this.currentFPS,
            cpuUsage: frameTime > 16.67 ? Math.min(100, frameTime / 16.67 * 5) : 0
            // Rough estimate
          });
        }
        /**
         * Register with animation coordinator
         */
        registerAnimation(priority = 60) {
          if (!this.animationCoordinator) {
            console.warn(`[${this.systemName}] Animation coordinator not initialized, attempting lazy initialization`);
            try {
              this.animationCoordinator = EnhancedMasterAnimationCoordinator.getInstance(this.config, this.performanceCoordinator);
            } catch (error) {
              console.error(`[${this.systemName}] Failed to initialize animation coordinator:`, error);
              return;
            }
          }
          try {
            this.animationCoordinator.registerAnimationSystem(
              this.systemName,
              this,
              "normal",
              priority
            );
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Successfully registered with animation coordinator`);
            }
          } catch (error) {
            console.error(`[${this.systemName}] Failed to register with animation coordinator:`, error);
          }
        }
        /**
         * Force a repaint - useful for settings changes
         */
        forceRepaint(reason) {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Force repaint: ${reason || "unknown"}`);
          }
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.forceFlush();
          }
          document.documentElement.style.transform = "translateZ(0)";
          requestAnimationFrame(() => {
            document.documentElement.style.transform = "";
          });
        }
        // =========================================================================
        // UTILITY GETTERS AND STATUS
        // =========================================================================
        /**
         * Check if system is initialized
         */
        get isInitialized() {
          return this.initialized;
        }
        /**
         * Check if system is destroyed
         */
        get isDestroyed() {
          return this.destroyed;
        }
        /**
         * Get system name
         */
        get name() {
          return this.systemName;
        }
        /**
         * Get system configuration
         */
        get systemConfig() {
          return this.config;
        }
        /**
         * Register a CSS variable group for this system
         */
        registerCSSVariableGroup(groupName, priority = "normal") {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.registerVariableGroup(`${this.systemName}-${groupName}`, priority);
          }
        }
        /**
         * Update variables in a CSS variable group
         */
        updateCSSVariableGroup(groupName, variables) {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.updateVariableGroup(`${this.systemName}-${groupName}`, variables, this.systemName);
          } else {
            this.updateCSSVariables(variables);
          }
        }
        // =========================================================================
        // COMPATIBILITY METHODS
        // =========================================================================
        /**
         * Legacy compatibility method for IManagedSystem
         * @deprecated Use onAnimate instead
         */
        updateAnimation(deltaTime) {
          this.onAnimate(deltaTime);
        }
        /**
         * Legacy compatibility method for BaseVisualSystem
         * @deprecated Override initialize() directly
         */
        async _performSystemSpecificInitialization() {
        }
        /**
         * Legacy compatibility method for BaseVisualSystem
         * @deprecated Override destroy() directly
         */
        _performSystemSpecificCleanup() {
          this.destroy();
        }
      };
      __name(_UnifiedSystemBase, "UnifiedSystemBase");
      UnifiedSystemBase = _UnifiedSystemBase;
    }
  });

  // src-js/visual/effects/HeaderVisualEffectsController.ts
  var _HeaderVisualEffectsController, HeaderVisualEffectsController;
  var init_HeaderVisualEffectsController = __esm({
    "src-js/visual/effects/HeaderVisualEffectsController.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      _HeaderVisualEffectsController = class _HeaderVisualEffectsController extends UnifiedSystemBase {
        constructor(config) {
          super(config);
          this.effectsState = {
            energy: 0.5,
            valence: 0.5,
            tempo: 120,
            harmonyHue: 0,
            intensity: 0.8,
            lastUpdateTime: 0,
            animationActive: true,
            preferredMotion: true,
            frameRate: 60,
            lastFrameTime: 0
          };
          // ✅ RAF LOOP CONSOLIDATION: Removed animationFrameId (coordinator manages animation)
          this.updateInterval = 0;
          // Performance optimization
          this.eventDebounceTimers = {
            musicEnergy: 0,
            colorHarmony: 0,
            beatSync: 0,
            cssUpdate: 0
          };
          this.eventDebounceMs = 100;
          // Reduced from 33ms to 100ms for better performance
          this.frameThrottleMs = 16;
          // 60fps target
          this.lastCSSUpdateTime = 0;
          // Change detection for CSS variables
          this.previousCSSValues = {
            energy: 0,
            valence: 0,
            harmonyHue: 0,
            intensity: 0,
            depth: 0
          };
          this.cssChangeThreshold = 0.01;
        }
        // =========================================================================
        // PERFORMANCE OPTIMIZATION HELPERS
        // =========================================================================
        /**
         * Debounced event handler to prevent excessive processing
         */
        debouncedEventHandler(eventType, handler) {
          const now = performance.now();
          if (now - this.eventDebounceTimers[eventType] >= this.eventDebounceMs) {
            handler();
            this.eventDebounceTimers[eventType] = now;
          }
        }
        /**
         * Check if CSS values have changed significantly
         */
        hasSignificantCSSChange() {
          const state = this.effectsState;
          const depthMultiplier = 1 + state.energy * 0.5;
          const currentValues = {
            energy: state.energy,
            valence: state.valence,
            harmonyHue: state.harmonyHue,
            intensity: state.intensity,
            depth: depthMultiplier
          };
          for (const [key, value] of Object.entries(currentValues)) {
            const previous = this.previousCSSValues[key];
            if (Math.abs(value - previous) >= this.cssChangeThreshold) {
              return true;
            }
          }
          return false;
        }
        /**
         * Update previous CSS values for change detection
         */
        updatePreviousCSSValues() {
          const state = this.effectsState;
          const depthMultiplier = 1 + state.energy * 0.5;
          this.previousCSSValues.energy = state.energy;
          this.previousCSSValues.valence = state.valence;
          this.previousCSSValues.harmonyHue = state.harmonyHue;
          this.previousCSSValues.intensity = state.intensity;
          this.previousCSSValues.depth = depthMultiplier;
        }
        /**
         * Batch apply CSS updates using coordination
         */
        batchApplyCSSUpdates(updates, priority = "normal", source = "header-effects") {
          const variables = {};
          for (const [property, value] of updates) {
            variables[property] = value;
          }
          this.cssController.batchSetVariables(
            "HeaderVisualEffectsController",
            variables,
            priority,
            source
          );
        }
        /**
         * Schedule effects variable update with change detection
         */
        scheduleEffectsUpdate() {
          this.debouncedEventHandler("cssUpdate", () => {
            if (this.hasSignificantCSSChange()) {
              this.updateHeaderEffectsVariables();
              this.updatePreviousCSSValues();
            }
          });
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            const year3000System = globalThis.year3000System;
            this.cssController = year3000System?.cssVariableController || getGlobalOptimizedCSSController();
            this.effectsState.preferredMotion = !window.matchMedia(
              "(prefers-reduced-motion: reduce)"
            ).matches;
            this.setupMusicEventListeners();
            this.setupColorHarmonyListeners();
            this.updateHeaderEffectsVariables();
            if (this.effectsState.preferredMotion) {
            }
            this.setupPerformanceMonitoring();
            Y3KDebug?.debug?.log(
              "HeaderVisualEffectsController",
              "Header visual effects initialization complete"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HeaderVisualEffectsController",
              "Initialization failed:",
              error
            );
          }
        }
        setupMusicEventListeners() {
          unifiedEventBus.subscribe(
            "music:energy",
            (data) => {
              this.debouncedEventHandler("musicEnergy", () => {
                if (typeof data.energy === "number") {
                  this.effectsState.energy = Math.max(
                    0,
                    Math.min(1, data.energy)
                  );
                  this.scheduleEffectsUpdate();
                }
                if (typeof data.tempo === "number") {
                  this.effectsState.tempo = Math.max(
                    60,
                    Math.min(200, data.tempo)
                  );
                  this.updateAnimationSpeed();
                }
                if (typeof data.valence === "number") {
                  this.effectsState.valence = Math.max(
                    0,
                    Math.min(1, data.valence)
                  );
                  this.scheduleEffectsUpdate();
                }
              });
            },
            "HeaderVisualEffectsController"
          );
          unifiedEventBus.subscribe(
            "music:beat",
            (data) => {
              this.debouncedEventHandler("beatSync", () => {
                if (this.effectsState.animationActive) {
                  const intensity = data.intensity || 0.8;
                  this.onBeatDetected(intensity);
                }
              });
            },
            "HeaderVisualEffectsController"
          );
          unifiedEventBus.subscribe(
            "music:energy-changed",
            (data) => {
              this.debouncedEventHandler("musicEnergy", () => {
                if (typeof data.energy === "number") {
                  this.effectsState.energy = Math.max(
                    0,
                    Math.min(1, data.energy)
                  );
                  this.scheduleEffectsUpdate();
                }
              });
            },
            "HeaderVisualEffectsController"
          );
        }
        setupColorHarmonyListeners() {
          unifiedEventBus.subscribe(
            "colors:harmonized",
            (data) => {
              this.debouncedEventHandler("colorHarmony", () => {
                if (data.coordinationMetrics?.coordinationStrategy) {
                  this.updateHarmonyHue(
                    data.coordinationMetrics.coordinationStrategy
                  );
                }
              });
            },
            "HeaderVisualEffectsController"
          );
          unifiedEventBus.subscribe(
            "colors:extracted",
            (data) => {
              this.debouncedEventHandler("colorHarmony", () => {
                if (data.musicData && typeof data.musicData.energy === "number") {
                  const hue = data.musicData.energy * 360;
                  this.effectsState.harmonyHue = hue;
                  this.scheduleEffectsUpdate();
                }
              });
            },
            "HeaderVisualEffectsController"
          );
        }
        updateHarmonyHue(harmonicMode) {
          const harmonyHueMap = {
            monochromatic: 0,
            complementary: 180,
            triadic: 120,
            analogous: 30,
            tetradic: 90,
            "split-complementary": 150
          };
          const baseHue = harmonyHueMap[harmonicMode] || 0;
          this.effectsState.harmonyHue = baseHue;
          this.scheduleEffectsUpdate();
        }
        onBeatDetected(intensity) {
          const beatEnergy = Math.min(
            1,
            this.effectsState.energy + intensity * 0.3
          );
          this.batchApplyCSSUpdates([
            ["--header-effects-energy", beatEnergy.toString()]
          ], "high", "beat-sync");
          const resetTime = performance.now() + 150;
          const resetBeatEffect = /* @__PURE__ */ __name(() => {
            if (performance.now() >= resetTime && this.initialized) {
              this.batchApplyCSSUpdates([
                [
                  "--header-effects-energy",
                  this.effectsState.energy.toString()
                ]
              ], "normal", "beat-reset");
            } else if (this.initialized) {
              requestAnimationFrame(resetBeatEffect);
            }
          }, "resetBeatEffect");
          requestAnimationFrame(resetBeatEffect);
        }
        updateAnimationSpeed() {
          const tempoMultiplier = this.effectsState.tempo / 120;
          const baseSpeed = 8;
          const newSpeed = baseSpeed / tempoMultiplier;
          this.batchApplyCSSUpdates([
            [
              "--header-effects-flow-speed",
              `${Math.max(2, Math.min(16, newSpeed))}s`
            ]
          ], "high", "tempo-sync");
        }
        updateHeaderEffectsVariables() {
          if (!this.initialized) return;
          const state = this.effectsState;
          const dynamicIntensity = state.intensity * (0.6 + state.valence * 0.4) * (0.8 + state.energy * 0.2);
          const depthMultiplier = 1 + state.energy * 0.5;
          this.batchApplyCSSUpdates([
            ["--header-effects-energy", state.energy.toString()],
            ["--header-effects-harmony", `${state.harmonyHue}deg`],
            ["--header-effects-intensity", dynamicIntensity.toString()],
            ["--header-effects-depth", depthMultiplier.toString()]
          ], "normal", "effects-update");
          this.effectsState.lastUpdateTime = Date.now();
        }
        /**
         * ✅ RAF LOOP REMOVED - Managed by EnhancedMasterAnimationCoordinator
         * Old method removed: startAnimationLoop()
         * Replacement: updateAnimation(deltaTime) called by coordinator
         */
        /**
         * ✅ RAF LOOP CONSOLIDATION: Animation update method called by coordinator
         * Replaces internal RAF loop with coordinator-managed updates
         */
        updateAnimation(deltaTime) {
          if (!this.initialized || !this.effectsState.animationActive) return;
          if (!this.effectsState.preferredMotion) return;
          const currentTime = performance.now();
          if (currentTime - this.lastCSSUpdateTime < this.frameThrottleMs) {
            return;
          }
          this.effectsState.frameRate = 1e3 / deltaTime;
          this.effectsState.lastFrameTime = currentTime;
          if (currentTime - this.effectsState.lastUpdateTime > 100) {
            if (this.hasSignificantCSSChange()) {
              this.updateHeaderEffectsVariables();
              this.updatePreviousCSSValues();
            }
          }
          this.lastCSSUpdateTime = currentTime;
        }
        setupPerformanceMonitoring() {
          this.updateInterval = window.setInterval(() => {
            if (!this.initialized) return;
            if (this.effectsState.frameRate < 30) {
              Y3KDebug?.debug?.warn(
                "HeaderVisualEffectsController",
                "Performance degradation detected, reducing update frequency"
              );
            }
            this.cssController.setVariable(
              "HeaderVisualEffectsController",
              "--header-effects-performance",
              this.effectsState.frameRate > 50 ? "1" : "0.5",
              "low",
              // Low priority for performance monitoring updates
              "performance-monitor"
            );
          }, 2e3);
        }
        /**
         * Manually update header effects intensity
         */
        setEffectsIntensity(intensity) {
          this.effectsState.intensity = Math.max(0, Math.min(1, intensity));
          this.updateHeaderEffectsVariables();
        }
        /**
         * Enable or disable header effects animations
         */
        setAnimationActive(active) {
          this.effectsState.animationActive = active;
        }
        /**
         * Get current effects state for debugging
         */
        getEffectsState() {
          return { ...this.effectsState };
        }
        async healthCheck() {
          const isHealthy = this.initialized && this.effectsState.frameRate > 20 && Date.now() - this.effectsState.lastUpdateTime < 5e3;
          return {
            healthy: isHealthy,
            issues: isHealthy ? [] : [
              this.effectsState.frameRate <= 20 ? "Low frame rate detected" : "",
              Date.now() - this.effectsState.lastUpdateTime >= 5e3 ? "No recent updates" : ""
            ].filter((issue) => issue),
            metrics: {
              frameRate: this.effectsState.frameRate,
              energy: this.effectsState.energy,
              intensity: this.effectsState.intensity,
              animationActive: this.effectsState.animationActive,
              lastUpdate: this.effectsState.lastUpdateTime
            }
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = 0;
          }
          unifiedEventBus.unsubscribeAll("HeaderVisualEffectsController");
          Y3KDebug?.debug?.log(
            "HeaderVisualEffectsController",
            "Header visual effects system cleaned up"
          );
        }
        // Required abstract method implementations
        async initialize() {
          await this._baseInitialize();
        }
        async destroy() {
          this._performSystemSpecificCleanup();
        }
        onAnimate(deltaTime) {
          if (this.effectsState.animationActive) {
            this.updateHeaderEffectsVariables();
          }
        }
      };
      __name(_HeaderVisualEffectsController, "HeaderVisualEffectsController");
      HeaderVisualEffectsController = _HeaderVisualEffectsController;
    }
  });

  // src-js/visual/effects/VisualEffectsCoordinator.ts
  var CSS_VAR_PREFIXES, VISUAL_EFFECT_CSS_VARS, _VisualEffectsCoordinator, VisualEffectsCoordinator;
  var init_VisualEffectsCoordinator = __esm({
    "src-js/visual/effects/VisualEffectsCoordinator.ts"() {
      "use strict";
      init_EmotionalGradientMapper();
      init_GradientDirectionalFlowSystem();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_DepthLayeredGradientSystem();
      init_FluidGradientBackgroundSystem();
      init_WebGLRenderer();
      init_IridescentShimmerEffectsSystem();
      init_SidebarVisualEffectsSystem();
      init_UIVisualEffectsController();
      init_HeaderVisualEffectsController();
      CSS_VAR_PREFIXES = {
        /** Main visual effects variables: --sn-visual-effects-* */
        VISUAL_EFFECTS: "--sn-visual-effects-",
        /** Visual state variables: --sn-visual-state-* */
        VISUAL_STATE: "--sn-visual-state-",
        /** Visual coordination variables: --sn-visual-coordination-* */
        VISUAL_COORDINATION: "--sn-visual-coordination-",
        /** Visual performance variables: --sn-visual-performance-* */
        VISUAL_PERFORMANCE: "--sn-visual-performance-"
      };
      VISUAL_EFFECT_CSS_VARS = {
        // Core visual effect state
        ENERGY_LEVEL: CSS_VAR_PREFIXES.VISUAL_STATE + "energy-level",
        FLOW_DIRECTION_X: CSS_VAR_PREFIXES.VISUAL_STATE + "flow-direction-x",
        FLOW_DIRECTION_Y: CSS_VAR_PREFIXES.VISUAL_STATE + "flow-direction-y",
        COLOR_TEMPERATURE: CSS_VAR_PREFIXES.VISUAL_STATE + "color-temperature",
        // Performance and coordination
        ADAPTIVE_QUALITY: CSS_VAR_PREFIXES.VISUAL_PERFORMANCE + "adaptive-quality",
        PARTICIPANT_COUNT: CSS_VAR_PREFIXES.VISUAL_COORDINATION + "participant-count",
        UPDATE_RATE: CSS_VAR_PREFIXES.VISUAL_PERFORMANCE + "update-rate",
        // Animation parameters
        PULSE_RATE: CSS_VAR_PREFIXES.VISUAL_EFFECTS + "pulse-rate",
        TRANSITION_FLUIDITY: CSS_VAR_PREFIXES.VISUAL_EFFECTS + "transition-fluidity",
        SYSTEM_HARMONY: CSS_VAR_PREFIXES.VISUAL_EFFECTS + "system-harmony"
      };
      _VisualEffectsCoordinator = class _VisualEffectsCoordinator {
        constructor(config, cssController, performanceCoordinator, musicSyncService, colorHarmonyEngine) {
          this.initialized = false;
          this.cssController = null;
          this.performanceCoordinator = null;
          this.musicSyncService = null;
          this.colorHarmonyEngine = null;
          this.emotionalGradientMapper = null;
          // Visual effect state management
          this.currentVisualState = null;
          this.previousVisualState = null;
          this.fieldUpdateTimer = null;
          this.lastFieldUpdate = 0;
          // System participants
          this.registeredParticipants = /* @__PURE__ */ new Map();
          this.participantContributions = /* @__PURE__ */ new Map();
          // Dynamic transition management
          this.transitionConfig = {
            enabled: true,
            transitionDuration: 1e3,
            easingFunction: "smooth",
            intensityFactor: 1,
            coherenceThreshold: 0.3
          };
          // Performance and monitoring
          this.isActive = false;
          this.updateInterval = 16;
          // 60fps visual state updates
          this.performanceMetrics = {
            stateUpdates: 0,
            coordinationEvents: 0,
            animationTransitions: 0,
            lastUpdate: 0,
            averageUpdateTime: 0
          };
          // ===================================================================
          // 🔧 PHASE 2.2: Consolidated Factory Pattern (from VisualSystemCoordinator)
          // ===================================================================
          // Visual system factory management
          this.systemRegistry = /* @__PURE__ */ new Map();
          this.systemInstances = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.factoryConfig = {
            mode: "progressive",
            enablePerformanceMonitoring: true,
            enableAdaptiveQuality: true,
            enableEventCoordination: true,
            enableGradientTransitions: true,
            performanceThresholds: {
              minFPS: 45,
              maxMemoryMB: 100,
              thermalThreshold: 0.7
            }
          };
          // ===================================================================
          // 🔧 PHASE 2.2: Gradient Effects State (from GradientEffectsCoordinator)
          // ===================================================================
          // Gradient orchestration state
          this.gradientEffectsState = {
            liquidVisualEffects: false,
            directionalFlow: false,
            shimmerEffects: false,
            depthLayers: false,
            performanceOptimization: true
          };
          this.gradientSystems = /* @__PURE__ */ new Map();
          // ===================================================================
          // 🔧 PHASE 2.2: Transition Coordination (from TransitionCoordinator)
          // ===================================================================
          // Transition management state
          this.transitionQueue = [];
          this.currentBackend = "css";
          this.transitionInProgress = false;
          this.backendStabilityCheck = null;
          this.config = config;
          this.eventBus = unifiedEventBus;
          this.cssController = cssController || null;
          this.performanceCoordinator = performanceCoordinator || null;
          this.musicSyncService = musicSyncService || null;
          this.colorHarmonyEngine = colorHarmonyEngine || null;
          if (this.cssController && this.musicSyncService) {
            this.emotionalGradientMapper = new EmotionalGradientMapper(
              this.cssController,
              this.musicSyncService
            );
          }
          this.initializeFactoryRegistry();
          this.initializeGradientSystems();
          this.initializeTransitionManagement();
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              "Enhanced visual effects coordinator created with consolidated functionality"
            );
          }
        }
        /**
         * Get singleton instance
         */
        static getInstance(config, cssController, performanceCoordinator, musicSyncService, colorHarmonyEngine) {
          if (!_VisualEffectsCoordinator.instance) {
            if (!config) {
              throw new Error(
                "VisualEffectsCoordinator requires configuration for first initialization"
              );
            }
            _VisualEffectsCoordinator.instance = new _VisualEffectsCoordinator(
              config,
              cssController,
              performanceCoordinator,
              musicSyncService,
              colorHarmonyEngine
            );
          }
          return _VisualEffectsCoordinator.instance;
        }
        // ===================================================================
        // IMANAGEDYSTEM INTERFACE IMPLEMENTATION
        // ===================================================================
        async initialize() {
          if (this.initialized) return;
          try {
            if (this.emotionalGradientMapper) {
              await this.emotionalGradientMapper.initialize();
            }
            this.currentVisualState = this.createInitialVisualState();
            this.startVisualEffectsUpdates();
            this.subscribeToEvents();
            this.initialized = true;
            this.isActive = true;
            if (this.config.enableDebug) {
              Y3KDebug?.debug?.log(
                "VisualEffectsCoordinator",
                "Visual effects coordinator initialized"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualEffectsCoordinator",
              "Failed to initialize:",
              error
            );
            throw error;
          }
        }
        updateAnimation(deltaTime) {
          this.performanceMetrics.lastUpdate = performance.now();
        }
        async healthCheck() {
          const participantCount = this.registeredParticipants.size;
          const fieldAge = this.currentVisualState ? performance.now() - this.currentVisualState.timestamp : 0;
          const isHealthy = this.isActive && fieldAge < 1e3 && participantCount > 0;
          return {
            system: "VisualEffectsCoordinator",
            healthy: isHealthy,
            ok: isHealthy,
            details: isHealthy ? "Visual effects coordination active" : "Visual effects state inactive or stale",
            metrics: {
              isActive: this.isActive,
              participantCount,
              fieldAge,
              stateUpdates: this.performanceMetrics.stateUpdates,
              coordinationEvents: this.performanceMetrics.coordinationEvents,
              animationTransitions: this.performanceMetrics.animationTransitions,
              averageUpdateTime: this.performanceMetrics.averageUpdateTime
            }
          };
        }
        destroy() {
          if (this.fieldUpdateTimer) {
            clearTimeout(this.fieldUpdateTimer);
            this.fieldUpdateTimer = null;
          }
          this.unsubscribeFromEvents();
          if (this.emotionalGradientMapper) {
            this.emotionalGradientMapper.destroy();
            this.emotionalGradientMapper = null;
          }
          this.registeredParticipants.clear();
          this.participantContributions.clear();
          this.currentVisualState = null;
          this.previousVisualState = null;
          this.isActive = false;
          this.initialized = false;
          if (_VisualEffectsCoordinator.instance === this) {
            _VisualEffectsCoordinator.instance = null;
          }
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              "Visual effects coordinator destroyed"
            );
          }
        }
        // ===================================================================
        // VISUAL EFFECT STATE MANAGEMENT
        // ===================================================================
        /**
         * Create initial visual effect state with default values
         */
        createInitialVisualState() {
          const deviceCapabilities = this.performanceCoordinator?.getDeviceCapabilities() || {
            performanceTier: "medium",
            memoryGB: 4,
            cpuCores: 2,
            gpuAcceleration: false,
            isMobile: false,
            supportsWebGL: false,
            supportsBackdropFilter: false,
            maxTextureSize: 2048,
            devicePixelRatio: 1
          };
          const performanceMode = this.performanceCoordinator?.getCurrentPerformanceMode() || {
            name: "balanced",
            qualityLevel: 0.7,
            animationQuality: 0.7,
            effectQuality: 0.7,
            blurQuality: 0.7,
            shadowQuality: 0.7,
            frameRate: 60,
            optimizationLevel: 1
          };
          return {
            // === MUSIC INTEGRATION ===
            musicIntensity: 0.5,
            flowDirection: { x: 0, y: 0 },
            energyLevel: 0.5,
            colorTemperature: 6500,
            // Neutral white
            tempoModulation: 1,
            harmonicComplexity: 0.5,
            // === VISUAL PARAMETERS ===
            fluidIntensity: 1,
            depthPerception: 0.7,
            luminosity: deviceCapabilities.gpuAcceleration ? 1.2 : 0.8,
            colorHarmony: 0.6,
            visualCoherence: 0.8,
            // === ANIMATION PARAMETERS ===
            pulseRate: 2,
            // 2 second pulse cycle
            transitionFluidity: 0.5,
            scalingFactor: 1,
            effectDepth: 0.6,
            systemHarmony: 0.7,
            // === PERFORMANCE AWARENESS ===
            deviceCapabilities,
            performanceMode,
            adaptiveQuality: performanceMode.qualityLevel,
            thermalState: 0,
            // Cool
            batteryConservation: 0,
            // Not conserving
            // === TEMPORAL TRACKING ===
            timestamp: performance.now(),
            evolutionPhase: 0,
            continuityIndex: 1
            // Perfect continuity at start
          };
        }
        /**
         * Update visual effects state with smooth evolution
         */
        updateVisualEffectsState() {
          const startTime = performance.now();
          if (!this.currentVisualState) {
            this.currentVisualState = this.createInitialVisualState();
            return;
          }
          this.previousVisualState = { ...this.currentVisualState };
          const newState = this.evolveVisualState(
            this.currentVisualState
          );
          if (this.transitionConfig.enabled) {
            this.currentVisualState = this.applyDynamicTransition(
              this.currentVisualState,
              newState
            );
          } else {
            this.currentVisualState = newState;
          }
          this.applyStandardizedVisualVariables().catch((error) => {
            Y3KDebug?.debug?.error("VisualEffectsCoordinator", "Failed to apply CSS variables:", error);
          });
          const updateResult = this.choreographVisualEffectsUpdate();
          if (!updateResult.success && this.config.enableDebug) {
            Y3KDebug?.debug?.warn(
              "VisualEffectsCoordinator",
              `Visual effects update had ${updateResult.errorCount} errors, notified ${updateResult.participantsNotified} participants`
            );
          }
          const updateTime = performance.now() - startTime;
          this.performanceMetrics.stateUpdates++;
          this.performanceMetrics.averageUpdateTime = (this.performanceMetrics.averageUpdateTime + updateTime) / 2;
          if (this.config.enableDebug && this.performanceMetrics.stateUpdates % 60 === 0) {
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              `Visual effects state evolved - Update #${this.performanceMetrics.stateUpdates}, avg time: ${this.performanceMetrics.averageUpdateTime.toFixed(2)}ms`
            );
          }
        }
        /**
         * Evolve visual effect state based on music, participants, and performance
         */
        evolveVisualState(currentState) {
          const evolvedState = { ...currentState };
          evolvedState.timestamp = performance.now();
          evolvedState.evolutionPhase = Math.min(
            1,
            evolvedState.evolutionPhase + 1e-3
          );
          this.updateFromMusicAnalysis(evolvedState);
          this.integrateParticipantContributions(evolvedState);
          this.applyAnimationTransitions(evolvedState);
          this.updatePerformanceAwareness(evolvedState);
          if (this.previousVisualState) {
            evolvedState.continuityIndex = this.calculateContinuityIndex(
              this.previousVisualState,
              evolvedState
            );
          }
          return evolvedState;
        }
        /**
         * Update visual state from music analysis
         */
        updateFromMusicAnalysis(state) {
          if (this.emotionalGradientMapper) {
            const emotionalProfile = this.emotionalGradientMapper.getCurrentEmotionalProfile();
            if (emotionalProfile) {
              state.pulseRate = emotionalProfile.energy;
              state.energyLevel = emotionalProfile.arousal;
              state.colorTemperature = 3e3 + emotionalProfile.valence * 1e4;
              state.harmonicComplexity = emotionalProfile.complexity;
              const moodFlowMap = {
                euphoric: { x: 1, y: 1 },
                aggressive: { x: -1, y: 1 },
                peaceful: { x: 0, y: -0.5 },
                melancholic: { x: -0.5, y: -1 },
                mysterious: { x: 0.7, y: 0 },
                contemplative: { x: 0, y: 0.3 }
              };
              state.flowDirection = moodFlowMap[emotionalProfile.mood] || {
                x: 0,
                y: 0
              };
              state.tempoModulation = 0.5 + emotionalProfile.energy * 1.5;
            }
          }
          if (this.musicSyncService) {
          }
        }
        /**
         * Integrate contributions from registered participants
         */
        integrateParticipantContributions(state) {
          if (this.participantContributions.size === 0) return;
          let totalWeight = 0;
          const contributions = [];
          for (const [participantId, contribution] of this.participantContributions) {
            contributions.push(contribution);
            totalWeight += 1;
          }
          if (totalWeight > 0) {
            for (const contribution of contributions) {
              if (contribution.fluidIntensity !== void 0) {
                state.fluidIntensity = this.dynamicBlend(
                  state.fluidIntensity,
                  contribution.fluidIntensity,
                  0.1
                );
              }
              if (contribution.depthPerception !== void 0) {
                state.depthPerception = this.dynamicBlend(
                  state.depthPerception,
                  contribution.depthPerception,
                  0.1
                );
              }
              if (contribution.luminosity !== void 0) {
                state.luminosity = this.dynamicBlend(
                  state.luminosity,
                  contribution.luminosity,
                  0.1
                );
              }
            }
          }
        }
        /**
         * Apply animation transitions to visual effect state
         */
        applyAnimationTransitions(state) {
          const time = performance.now() / 1e3;
          const pulsePhase = time % state.pulseRate / state.pulseRate;
          const pulseInfluence = Math.sin(pulsePhase * Math.PI * 2) * 0.1;
          state.scalingFactor += pulseInfluence;
          state.transitionFluidity = Math.max(
            0,
            Math.min(1, state.transitionFluidity + pulseInfluence * 0.5)
          );
          state.effectDepth = Math.max(
            0,
            Math.min(1, state.effectDepth + state.evolutionPhase * 1e-3)
          );
          state.systemHarmony = Math.max(
            0,
            Math.min(1, (state.visualCoherence + state.continuityIndex) / 2)
          );
        }
        /**
         * Update performance awareness in visual effect state
         */
        updatePerformanceAwareness(state) {
          if (this.performanceCoordinator) {
            state.deviceCapabilities = this.performanceCoordinator.getDeviceCapabilities();
            state.performanceMode = this.performanceCoordinator.getCurrentPerformanceMode();
            state.adaptiveQuality = state.performanceMode.qualityLevel;
            const thermalState = this.performanceCoordinator.getThermalState();
            const batteryState = this.performanceCoordinator.getBatteryState();
            state.thermalState = thermalState.throttleLevel || 0;
            state.batteryConservation = batteryState && !batteryState.charging ? (1 - batteryState.level) * 0.5 : 0;
          }
        }
        /**
         * Calculate continuity index between visual effect states
         */
        calculateContinuityIndex(previous, current) {
          const metrics = [
            Math.abs(previous.pulseRate - current.pulseRate),
            Math.abs(previous.energyLevel - current.energyLevel),
            Math.abs(previous.fluidIntensity - current.fluidIntensity),
            Math.abs(previous.depthPerception - current.depthPerception),
            Math.abs(previous.luminosity - current.luminosity)
          ];
          const averageDifference = metrics.reduce((sum, diff) => sum + diff, 0) / metrics.length;
          return Math.max(0, Math.min(1, 1 - averageDifference));
        }
        /**
         * Apply dynamic transition between visual effect states
         */
        applyDynamicTransition(current, target) {
          const transitionSpeed = this.calculateDynamicTransitionSpeed(
            current,
            target
          );
          const easedProgress = this.applyDynamicEasing(transitionSpeed);
          return this.blendVisualStates(current, target, easedProgress);
        }
        /**
         * @deprecated Use applyDynamicTransition instead
         * @since v1.0.0
         */
        applySmoothTransition(current, target) {
          return this.applyDynamicTransition(current, target);
        }
        /**
         * Calculate dynamic transition speed based on state characteristics
         */
        calculateDynamicTransitionSpeed(current, target) {
          const baseBeat = 1 / 60;
          const pulseModulation = 1 + Math.sin(
            performance.now() / 1e3 / current.pulseRate * Math.PI * 2
          ) * 0.2;
          const energyModulation = 0.5 + current.energyLevel * 1.5;
          return baseBeat * pulseModulation * energyModulation * this.transitionConfig.intensityFactor;
        }
        /**
         * @deprecated Use calculateDynamicTransitionSpeed instead
         * @since v1.0.0
         */
        calculateSmoothTransitionSpeed(current, target) {
          return this.calculateDynamicTransitionSpeed(current, target);
        }
        /**
         * Apply dynamic easing function for visual transitions
         */
        applyDynamicEasing(progress) {
          switch (this.transitionConfig.easingFunction) {
            case "smooth":
              return progress * progress * (3 - 2 * progress);
            case "harmonic":
              return (Math.sin((progress - 0.5) * Math.PI) + 1) / 2;
            case "exponential":
              return progress * progress;
            case "cubic":
              return progress * progress * progress;
            default:
              return progress;
          }
        }
        /**
         * @deprecated Use applyDynamicEasing instead
         * @since v1.0.0
         */
        applySmoothEasing(progress) {
          return this.applyDynamicEasing(progress);
        }
        /**
         * Blend two visual effect states dynamically
         */
        blendVisualStates(current, target, progress) {
          const blended = { ...current };
          blended.pulseRate = this.dynamicBlend(
            current.pulseRate,
            target.pulseRate,
            progress
          );
          blended.energyLevel = this.dynamicBlend(
            current.energyLevel,
            target.energyLevel,
            progress
          );
          blended.colorTemperature = this.dynamicBlend(
            current.colorTemperature,
            target.colorTemperature,
            progress
          );
          blended.fluidIntensity = this.dynamicBlend(
            current.fluidIntensity,
            target.fluidIntensity,
            progress
          );
          blended.depthPerception = this.dynamicBlend(
            current.depthPerception,
            target.depthPerception,
            progress
          );
          blended.luminosity = this.dynamicBlend(
            current.luminosity,
            target.luminosity,
            progress
          );
          blended.colorHarmony = this.dynamicBlend(
            current.colorHarmony,
            target.colorHarmony,
            progress
          );
          blended.visualCoherence = this.dynamicBlend(
            current.visualCoherence,
            target.visualCoherence,
            progress
          );
          blended.transitionFluidity = this.dynamicBlend(
            current.transitionFluidity,
            target.transitionFluidity,
            progress
          );
          blended.scalingFactor = this.dynamicBlend(
            current.scalingFactor,
            target.scalingFactor,
            progress
          );
          blended.effectDepth = this.dynamicBlend(
            current.effectDepth,
            target.effectDepth,
            progress
          );
          blended.systemHarmony = this.dynamicBlend(
            current.systemHarmony,
            target.systemHarmony,
            progress
          );
          blended.tempoModulation = this.dynamicBlend(
            current.tempoModulation,
            target.tempoModulation,
            progress
          );
          blended.harmonicComplexity = this.dynamicBlend(
            current.harmonicComplexity,
            target.harmonicComplexity,
            progress
          );
          blended.adaptiveQuality = this.dynamicBlend(
            current.adaptiveQuality,
            target.adaptiveQuality,
            progress
          );
          blended.flowDirection = {
            x: this.dynamicBlend(
              current.flowDirection.x,
              target.flowDirection.x,
              progress
            ),
            y: this.dynamicBlend(
              current.flowDirection.y,
              target.flowDirection.y,
              progress
            )
          };
          blended.timestamp = performance.now();
          blended.continuityIndex = current.continuityIndex;
          return blended;
        }
        /**
         * Dynamic blend function for seamless value transitions
         */
        dynamicBlend(current, target, progress) {
          return current + (target - current) * progress;
        }
        /**
         * @deprecated Use dynamicBlend instead
         * @since v1.0.0
         */
        smoothBlend(current, target, progress) {
          return this.dynamicBlend(current, target, progress);
        }
        // ===================================================================
        // PARTICIPANT MANAGEMENT
        // ===================================================================
        /**
         * Register a background system as a visual effects participant
         * 
         * @param participant - The background system to register
         * @returns Registration result with success status and details
         * 
         * @example
         * ```typescript
         * const result = coordinator.registerVisualEffectsParticipant(mySystem);
         * if (result.success) {
         *   console.log(`${result.participantName} registered successfully`);
         * }
         * ```
         */
        registerVisualEffectsParticipant(participant) {
          try {
            if (this.registeredParticipants.has(participant.systemName)) {
              return {
                success: false,
                participantName: participant.systemName,
                contributionReceived: false,
                errorMessage: `Participant '${participant.systemName}' is already registered`
              };
            }
            this.registeredParticipants.set(participant.systemName, participant);
            let contributionReceived = false;
            try {
              const contribution = participant.getVisualContribution();
              this.participantContributions.set(participant.systemName, contribution);
              contributionReceived = true;
            } catch (contributionError) {
              Y3KDebug?.debug?.warn(
                "VisualEffectsCoordinator",
                `Failed to get initial contribution from ${participant.systemName}:`,
                contributionError
              );
            }
            if (this.config.enableDebug) {
              Y3KDebug?.debug?.log(
                "VisualEffectsCoordinator",
                `Registered participant: ${participant.systemName}`
              );
            }
            return {
              success: true,
              participantName: participant.systemName,
              contributionReceived
            };
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "Unknown registration error";
            Y3KDebug?.debug?.error(
              "VisualEffectsCoordinator",
              `Failed to register participant ${participant.systemName}:`,
              error
            );
            return {
              success: false,
              participantName: participant.systemName,
              contributionReceived: false,
              errorMessage
            };
          }
        }
        /**
         * Unregister a visual effects participant
         */
        unregisterVisualEffectsParticipant(systemName) {
          this.registeredParticipants.delete(systemName);
          this.participantContributions.delete(systemName);
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              `Unregistered participant: ${systemName}`
            );
          }
        }
        /**
         * Update participant contribution to visual effects state
         */
        updateParticipantContribution(systemName, contribution) {
          if (this.registeredParticipants.has(systemName)) {
            this.participantContributions.set(systemName, contribution);
          }
        }
        // ===================================================================
        // CHOREOGRAPHY EVENT COORDINATION
        // ===================================================================
        /**
         * Choreograph visual effects state update - broadcast to all participants
         * 
         * @returns Update result with performance metrics and error information
         */
        choreographVisualEffectsUpdate() {
          const updateStartTime = performance.now();
          let participantsNotified = 0;
          let errorCount = 0;
          if (!this.currentVisualState) {
            return {
              success: false,
              participantsNotified: 0,
              updateDuration: 0,
              continuityIndex: 0,
              errorCount: 1
            };
          }
          try {
            this.eventBus.emit(
              "visual-effects:field-updated",
              {
                rhythmicPulse: this.currentVisualState.pulseRate,
                musicalFlow: this.currentVisualState.flowDirection,
                energyResonance: this.currentVisualState.energyLevel,
                depthPerception: this.currentVisualState.depthPerception,
                pulsingCycle: this.currentVisualState.pulseRate
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualEffectsCoordinator",
              "Error broadcasting visual effects state update:",
              error
            );
            errorCount++;
          }
          for (const participant of this.registeredParticipants.values()) {
            try {
              participant.onVisualStateUpdate(this.currentVisualState);
              participantsNotified++;
            } catch (error) {
              Y3KDebug?.debug?.error(
                "VisualEffectsCoordinator",
                `Error updating participant ${participant.systemName}:`,
                error
              );
              errorCount++;
            }
          }
          this.performanceMetrics.coordinationEvents++;
          const updateDuration = performance.now() - updateStartTime;
          return {
            success: errorCount === 0,
            participantsNotified,
            updateDuration,
            continuityIndex: this.currentVisualState.continuityIndex,
            errorCount
          };
        }
        /**
         * Choreograph specific event type with enhanced type safety
         * 
         * @param eventType - The type of visual effect event to choreograph
         * @param payload - Type-safe event payload
         * 
         * @example
         * ```typescript
         * coordinator.choreographEvent('visual:energy-surge', {
         *   intensity: 0.8,
         *   duration: 1000,
         *   affectedSystems: ['gradient-system', 'particle-system']
         * });
         * ```
         */
        choreographEvent(eventType, payload) {
          if (eventType && typeof eventType === "string") {
            try {
              const mappedEvent = this.mapChoreographyEventToUnified(eventType);
              if (mappedEvent) {
                this.eventBus.emit(mappedEvent.eventName, mappedEvent.payload);
              }
            } catch (error) {
              this.eventBus.emit(`visual-effects:${eventType}`, payload);
            }
          }
          for (const participant of this.registeredParticipants.values()) {
            try {
              if (eventType.startsWith("visual:")) {
                participant.onVisualEffectEvent(eventType, payload);
              } else {
                participant.onVisualEffectEvent("visual:coordination", { ...payload, originalEventType: eventType });
              }
            } catch (error) {
              Y3KDebug?.debug?.error(
                "VisualEffectsCoordinator",
                `Error sending choreography event to ${participant.systemName}:`,
                error
              );
            }
          }
          this.performanceMetrics.coordinationEvents++;
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              `Choreographed event: ${eventType}`,
              payload
            );
          }
        }
        // ===================================================================
        // VISUAL EFFECTS STATE LIFECYCLE
        // ===================================================================
        /**
         * Start visual effects state updates
         */
        startVisualEffectsUpdates() {
          if (this.fieldUpdateTimer) return;
          const updateLoop = /* @__PURE__ */ __name(() => {
            if (this.isActive) {
              this.updateVisualEffectsState();
              this.fieldUpdateTimer = setTimeout(updateLoop, this.updateInterval);
            }
          }, "updateLoop");
          updateLoop();
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              `Started visual effects state updates (${this.updateInterval}ms interval)`
            );
          }
        }
        /**
         * Subscribe to relevant events
         */
        subscribeToEvents() {
          if (this.musicSyncService) {
            this.eventBus.subscribe("music:track-changed", (payload) => {
              this.choreographEvent("rhythm-shift", {
                newTrack: payload,
                transitionType: "smooth"
              });
            }, "VisualEffectsCoordinator");
            this.eventBus.subscribe("music:emotion-analyzed", (payload) => {
              this.choreographEvent("intensity-peak", {
                intensity: payload?.energy || 0.5,
                affectedSystems: ["all"],
                surgeType: "full-spectrum",
                duration: 1e3,
                falloffCurve: "smooth"
              });
            }, "VisualEffectsCoordinator");
          }
          if (this.performanceCoordinator) {
            this.eventBus.subscribe("performance:tier-changed", (payload) => {
              this.choreographEvent("genre-transition", {
                newMode: payload || {
                  name: "auto",
                  qualityLevel: 0.8,
                  frameRate: 60,
                  optimizationLevel: 0.5
                },
                adaptationType: "smooth",
                reason: "automatic",
                affectedSystems: ["all"]
              });
            }, "VisualEffectsCoordinator");
          }
          this.eventBus.subscribe("settings:visual-guide-changed", (payload) => {
            if (payload?.key?.includes("visual-effects") || payload?.key?.includes("choreography")) {
              this.updateDynamicTransitionConfig(payload);
            }
          }, "VisualEffectsCoordinator");
        }
        /**
         * Unsubscribe from events
         */
        unsubscribeFromEvents() {
        }
        /**
         * Map choreography events to unified event names
         */
        mapChoreographyEventToUnified(eventType) {
          switch (eventType) {
            case "rhythm-shift":
              return { eventName: "visual-effects:coordination", payload: { source: "choreographer", type: "rhythm-shift" } };
            case "intensity-peak":
              return { eventName: "visual-effects:intensity-changed", payload: { intensity: 0.8, userEngagement: 0.6, timestamp: Date.now() } };
            case "genre-transition":
              return { eventName: "visual-effects:coordination", payload: { source: "choreographer", type: "genre-transition" } };
            case "emotional-shift":
              return { eventName: "visual-effects:coordination", payload: { source: "choreographer", type: "emotional-shift" } };
            default:
              return { eventName: "visual-effects:coordination", payload: { source: "choreographer", type: eventType } };
          }
        }
        /**
         * Update dynamic transition configuration
         */
        updateDynamicTransitionConfig(settingsPayload) {
          const { key, value } = settingsPayload;
          if (key.includes("transition-intensity")) {
            this.transitionConfig.intensityFactor = Math.max(
              0,
              Math.min(2, parseFloat(value) || 1)
            );
          } else if (key.includes("transition-duration")) {
            this.transitionConfig.transitionDuration = Math.max(
              100,
              Math.min(5e3, parseInt(value) || 1e3)
            );
          } else if (key.includes("animation-cycle")) {
            const newCycle = Math.max(0.5, Math.min(4, parseFloat(value) || 2));
            if (this.currentVisualState) {
              this.currentVisualState.pulseRate = newCycle;
            }
          }
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              `Updated dynamic transition config: ${key} = ${value}`
            );
          }
        }
        /**
         * @deprecated Use updateDynamicTransitionConfig instead
         * @since v1.0.0
         */
        updateSmoothTransitionConfig(settingsPayload) {
          return this.updateDynamicTransitionConfig(settingsPayload);
        }
        /**
         * Apply standardized visual effects CSS variables to DOM
         * 
         * @param targetElement - Element to apply variables to (defaults to document.documentElement)
         * 
         * @example
         * ```typescript
         * coordinator.applyStandardizedVisualVariables();
         * // Sets standardized --sn-visual-* CSS variables on :root
         * ```
         */
        async applyStandardizedVisualVariables(targetElement) {
          if (!this.currentVisualState) return;
          const element = targetElement || document.documentElement;
          const state = this.currentVisualState;
          const standardizedVars = {
            [VISUAL_EFFECT_CSS_VARS.ENERGY_LEVEL]: state.energyLevel.toFixed(3),
            [VISUAL_EFFECT_CSS_VARS.FLOW_DIRECTION_X]: state.flowDirection.x.toFixed(3),
            [VISUAL_EFFECT_CSS_VARS.FLOW_DIRECTION_Y]: state.flowDirection.y.toFixed(3),
            [VISUAL_EFFECT_CSS_VARS.COLOR_TEMPERATURE]: state.colorTemperature.toString(),
            [VISUAL_EFFECT_CSS_VARS.ADAPTIVE_QUALITY]: state.adaptiveQuality.toFixed(3),
            [VISUAL_EFFECT_CSS_VARS.PARTICIPANT_COUNT]: this.registeredParticipants.size.toString(),
            [VISUAL_EFFECT_CSS_VARS.UPDATE_RATE]: (1e3 / this.updateInterval).toString(),
            [VISUAL_EFFECT_CSS_VARS.PULSE_RATE]: state.pulseRate.toFixed(3),
            [VISUAL_EFFECT_CSS_VARS.TRANSITION_FLUIDITY]: state.transitionFluidity.toFixed(3),
            [VISUAL_EFFECT_CSS_VARS.SYSTEM_HARMONY]: state.systemHarmony.toFixed(3)
          };
          if (this.cssController) {
            for (const [varName, value] of Object.entries(standardizedVars)) {
              await this.cssController.setVariable("VisualEffectsCoordinator", varName, value, "normal", "standardized-vars");
            }
          } else {
            for (const [varName, value] of Object.entries(standardizedVars)) {
              element.style.setProperty(varName, value);
            }
          }
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              `Applied ${Object.keys(standardizedVars).length} standardized visual effect CSS variables`
            );
          }
        }
        // ===================================================================
        // PUBLIC API
        // ===================================================================
        /**
         * Get current visual effects state (read-only copy)
         */
        getCurrentVisualEffectsState() {
          return this.currentVisualState ? { ...this.currentVisualState } : null;
        }
        /**
         * Get registered participants
         */
        getRegisteredParticipants() {
          return Array.from(this.registeredParticipants.keys());
        }
        /**
         * Update dynamic transition configuration
         */
        updateDynamicTransitionConfiguration(config) {
          this.transitionConfig = { ...this.transitionConfig, ...config };
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "VisualEffectsCoordinator",
              "Updated dynamic transition configuration:",
              config
            );
          }
        }
        /**
         * @deprecated Use updateDynamicTransitionConfiguration instead
         * @since v1.0.0
         */
        updateSmoothTransitionConfiguration(config) {
          return this.updateDynamicTransitionConfiguration(config);
        }
        /**
         * Force visual effects state update (for debugging/testing)
         */
        forceVisualEffectsStateUpdate() {
          this.updateVisualEffectsState();
        }
        /**
         * Get performance metrics
         */
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        // ===================================================================
        // 🔧 PHASE 2.2: CONSOLIDATED COORDINATOR METHODS
        // ===================================================================
        /**
         * Initialize factory registry from VisualSystemCoordinator consolidation
         */
        initializeFactoryRegistry() {
          this.systemRegistry.set("SidebarVisualEffects", SidebarVisualEffectsSystem);
          this.systemDependencies.set("SidebarVisualEffects", ["eventBus", "musicSyncService"]);
          this.systemRegistry.set("UIVisualEffects", UIEffectsController);
          this.systemDependencies.set("UIVisualEffects", ["eventBus", "musicSyncService", "cssVariableController"]);
          this.systemRegistry.set("HeaderVisualEffects", HeaderVisualEffectsController);
          this.systemDependencies.set("HeaderVisualEffects", ["eventBus", "musicSyncService", "colorHarmonyEngine"]);
          this.systemRegistry.set("WebGLBackground", WebGLGradientBackgroundSystem);
          this.systemDependencies.set("WebGLBackground", ["performanceAnalyzer", "eventBus"]);
          this.systemRegistry.set("FluidGradient", FluidGradientBackgroundSystem);
          this.systemDependencies.set("FluidGradient", ["performanceAnalyzer", "musicSyncService", "cssVariableController"]);
          this.systemRegistry.set("DepthLayers", DepthLayeredGradientSystem);
          this.systemDependencies.set("DepthLayers", ["performanceAnalyzer", "musicSyncService", "cssVariableController"]);
          this.systemRegistry.set("IridescentShimmer", IridescentShimmerEffectsSystem);
          this.systemDependencies.set("IridescentShimmer", ["performanceAnalyzer", "musicSyncService", "cssVariableController"]);
          this.systemRegistry.set("DirectionalFlow", GradientDirectionalFlowSystem);
          this.systemDependencies.set("DirectionalFlow", ["performanceAnalyzer", "musicSyncService", "cssVariableController"]);
        }
        /**
         * Initialize gradient systems from GradientEffectsCoordinator consolidation
         */
        initializeGradientSystems() {
          this.gradientEffectsState = {
            liquidVisualEffects: false,
            directionalFlow: false,
            shimmerEffects: false,
            depthLayers: false,
            performanceOptimization: true
          };
        }
        /**
         * Initialize transition management from TransitionCoordinator consolidation
         */
        initializeTransitionManagement() {
          this.currentBackend = "css";
          this.transitionInProgress = false;
          this.transitionQueue = [];
        }
        /**
         * Factory method to create visual systems (from VisualSystemCoordinator)
         */
        async createVisualSystem(systemKey, forceRecreate = false) {
          try {
            const systemName = systemKey;
            if (!forceRecreate && this.systemInstances.has(systemName)) {
              return this.systemInstances.get(systemName) || null;
            }
            const SystemClass = this.systemRegistry.get(systemKey);
            if (!SystemClass) {
              console.warn(`Visual system '${systemKey}' not found in registry`);
              return null;
            }
            const dependencies = this.resolveDependencies(systemName);
            const systemInstance = new SystemClass(...dependencies);
            if (systemInstance.initialize) {
              await systemInstance.initialize();
            }
            this.systemInstances.set(systemName, systemInstance);
            if (this.config.enableDebug) {
              Y3KDebug?.debug?.log("VisualSystemFactory", `Created visual system: ${systemKey}`);
            }
            return systemInstance;
          } catch (error) {
            console.error(`Failed to create visual system '${systemKey}':`, error);
            return null;
          }
        }
        /**
         * Orchestrate gradient effects (from GradientEffectsCoordinator)
         */
        async orchestrateGradientEffects(config) {
          try {
            this.gradientEffectsState = { ...this.gradientEffectsState, ...config };
            if (config.liquidVisualEffects) {
              const fluidSystem = await this.createVisualSystem("FluidGradient");
              if (fluidSystem) this.gradientSystems.set("FluidGradient", fluidSystem);
            }
            if (config.depthLayers) {
              const depthSystem = await this.createVisualSystem("DepthLayers");
              if (depthSystem) this.gradientSystems.set("DepthLayers", depthSystem);
            }
            if (config.shimmerEffects) {
              const shimmerSystem = await this.createVisualSystem("IridescentShimmer");
              if (shimmerSystem) this.gradientSystems.set("IridescentShimmer", shimmerSystem);
            }
            if (config.directionalFlow) {
              const flowSystem = await this.createVisualSystem("DirectionalFlow");
              if (flowSystem) this.gradientSystems.set("DirectionalFlow", flowSystem);
            }
            if (this.config.enableDebug) {
              Y3KDebug?.debug?.log("GradientOrchestration", "Gradient effects orchestrated", this.gradientEffectsState);
            }
          } catch (error) {
            console.error("Failed to orchestrate gradient effects:", error);
          }
        }
        /**
         * Coordinate backend transitions (from TransitionCoordinator)
         */
        async coordinateBackendTransition(to, config = {}) {
          if (this.transitionInProgress || this.currentBackend === to) {
            return;
          }
          try {
            this.transitionInProgress = true;
            const transitionConfig = {
              mode: config.mode || "crossfade",
              duration: config.duration || 1e3,
              easing: config.easing || "ease-in-out",
              preserveState: config.preserveState ?? true,
              fallbackDelay: config.fallbackDelay || 5e3
            };
            this.transitionQueue.push({
              from: this.currentBackend,
              to,
              config: transitionConfig,
              startTime: Date.now()
            });
            if (to === "webgl") {
              await this.transitionToWebGL(transitionConfig);
            } else if (to === "css") {
              await this.transitionToCSS(transitionConfig);
            } else if (to === "hybrid") {
              await this.transitionToHybrid(transitionConfig);
            }
            this.currentBackend = to;
            this.transitionInProgress = false;
            if (this.config.enableDebug) {
              Y3KDebug?.debug?.log("TransitionCoordination", `Transitioned to ${to} backend`);
            }
          } catch (error) {
            console.error("Backend transition failed:", error);
            this.transitionInProgress = false;
          }
        }
        /**
         * Get comprehensive health check including all consolidated systems
         */
        async getConsolidatedHealthCheck() {
          const systemHealthChecks = /* @__PURE__ */ new Map();
          for (const [name, system] of this.systemInstances) {
            try {
              const health = system.healthCheck ? await system.healthCheck() : { healthy: true, details: "No health check method" };
              systemHealthChecks.set(name, { ok: health.healthy, details: health.details || "OK" });
            } catch (error) {
              systemHealthChecks.set(name, { ok: false, details: `Health check failed: ${error}` });
            }
          }
          for (const [name, system] of this.gradientSystems) {
            try {
              const health = system.healthCheck ? await system.healthCheck() : { healthy: true, details: "No health check method" };
              systemHealthChecks.set(`gradient-${name}`, { ok: health.healthy, details: health.details || "OK" });
            } catch (error) {
              systemHealthChecks.set(`gradient-${name}`, { ok: false, details: `Health check failed: ${error}` });
            }
          }
          const failedSystems = Array.from(systemHealthChecks.values()).filter((check) => !check.ok);
          const overallHealth = failedSystems.length === 0 ? "excellent" : failedSystems.length <= 2 ? "good" : failedSystems.length <= 5 ? "degraded" : "critical";
          const recommendations = [];
          if (failedSystems.length > 0) {
            recommendations.push(`${failedSystems.length} systems require attention`);
          }
          if (this.transitionQueue.length > 3) {
            recommendations.push("High transition queue - consider reducing visual complexity");
          }
          return {
            overall: overallHealth,
            systems: systemHealthChecks,
            gradientEffects: this.gradientEffectsState,
            transitions: {
              activeTransitions: this.transitionQueue.length,
              backendStability: !this.transitionInProgress
            },
            recommendations,
            timestamp: Date.now()
          };
        }
        // ===================================================================
        // PRIVATE HELPER METHODS FOR CONSOLIDATED FUNCTIONALITY
        // ===================================================================
        resolveDependencies(systemName) {
          const dependencies = this.systemDependencies.get(systemName) || [];
          const resolved = [];
          for (const dep of dependencies) {
            switch (dep) {
              case "eventBus":
                resolved.push(this.eventBus);
                break;
              case "musicSyncService":
                resolved.push(this.musicSyncService);
                break;
              case "cssVariableController":
                resolved.push(this.cssController);
                break;
              case "colorHarmonyEngine":
                resolved.push(this.colorHarmonyEngine);
                break;
              case "performanceAnalyzer":
                resolved.push(this.performanceCoordinator);
                break;
              default:
                resolved.push(null);
            }
          }
          return resolved;
        }
        async transitionToWebGL(config) {
          const webglSystem = await this.createVisualSystem("WebGLBackground");
          if (webglSystem && webglSystem.initialize) {
            await webglSystem.initialize();
          }
        }
        async transitionToCSS(config) {
          const fluidSystem = await this.createVisualSystem("FluidGradient");
          if (fluidSystem && fluidSystem.initialize) {
            await fluidSystem.initialize();
          }
        }
        async transitionToHybrid(config) {
          await Promise.all([
            this.transitionToCSS(config),
            this.transitionToWebGL(config)
          ]);
        }
        // ===================================================================
        // BACKWARD COMPATIBILITY ALIASES
        // ===================================================================
        // ===================================================================
        // BACKWARD COMPATIBILITY ALIASES
        // ===================================================================
        /** @deprecated Use registerVisualEffectsParticipant instead */
        registerConsciousnessParticipant(participant) {
          return this.registerVisualEffectsParticipant(participant);
        }
        /** @deprecated Use unregisterVisualEffectsParticipant instead */
        unregisterConsciousnessParticipant(systemName) {
          this.unregisterVisualEffectsParticipant(systemName);
        }
        /** @deprecated Use getCurrentVisualEffectsState instead */
        getCurrentConsciousnessField() {
          return this.getCurrentVisualEffectsState();
        }
        /** @deprecated Use forceVisualEffectsStateUpdate instead */
        forceConsciousnessFieldUpdate() {
          this.forceVisualEffectsStateUpdate();
        }
        /** @deprecated Use registerVisualEffectsParticipant instead */
        registerBackgroundSystemParticipant(participant) {
          return this.registerVisualEffectsParticipant(participant);
        }
        /** @deprecated Use unregisterVisualEffectsParticipant instead */
        unregisterBackgroundSystemParticipant(systemName) {
          this.unregisterVisualEffectsParticipant(systemName);
        }
        /** @deprecated Use getCurrentVisualEffectsState instead */
        getCurrentBackgroundState() {
          return this.getCurrentVisualEffectsState();
        }
        /** @deprecated Use choreographEvent instead */
        choreographBackgroundEvent(eventType, payload) {
          return this.choreographEvent(eventType, payload);
        }
      };
      __name(_VisualEffectsCoordinator, "VisualEffectsCoordinator");
      _VisualEffectsCoordinator.instance = null;
      VisualEffectsCoordinator = _VisualEffectsCoordinator;
    }
  });

  // src-js/utils/color/MusicalOKLABCoordinator.ts
  var _MusicalOKLABProcessor, MusicalOKLABProcessor;
  var init_MusicalOKLABCoordinator = __esm({
    "src-js/utils/color/MusicalOKLABCoordinator.ts"() {
      "use strict";
      init_GenreProfileManager();
      init_globalConfig();
      init_UnifiedDebugManager();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      _MusicalOKLABProcessor = class _MusicalOKLABProcessor {
        // 5 minutes
        constructor(enableDebug = ADVANCED_SYSTEM_CONFIG.enableDebug) {
          this.coordinationCache = /* @__PURE__ */ new Map();
          this.cacheMaxSize = 20;
          this.cacheTimeoutMs = 3e5;
          this.enableDebug = enableDebug;
          this.oklabProcessor = new OKLABColorProcessor(enableDebug);
          this.emotionalMapper = new EmotionalTemperatureMapper(enableDebug);
          this.genreManager = new GenreProfileManager({ ADVANCED_SYSTEM_CONFIG });
          if (this.enableDebug) {
            Y3KDebug?.debug?.log(
              "MusicalOKLABProcessor",
              "Unified music-to-OKLAB coordinator initialized"
            );
          }
        }
        /**
         * Main processing method - transforms musical context through complete OKLAB pipeline
         */
        async processMusicalColors(context, options = {}) {
          const startTime = performance.now();
          const cacheKey = this.generateCacheKey(context);
          const cachedResult = this.coordinationCache.get(cacheKey);
          if (cachedResult) {
            if (this.enableDebug) {
              Y3KDebug?.debug?.log(
                "MusicalOKLABProcessor",
                "Using cached processing result",
                { cacheKey }
              );
            }
            return cachedResult;
          }
          try {
            const processingStrategy = this.determineProcessingStrategy(
              context,
              options
            );
            const oklabPreset = await this.getOptimalOKLABPreset(
              context,
              processingStrategy,
              options
            );
            const colorProcessingResult = await this.processColorsWithMusicalContext(
              context.rawColors,
              context.musicData,
              oklabPreset
            );
            const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(context.musicData);
            const detectedGenre = this.genreManager.detectGenre(context.musicData);
            const genreCharacteristics = this.genreManager.getColorCharacteristicsForGenre(detectedGenre);
            const musicInfluenceStrength = this.calculateMusicInfluenceStrength(
              context.musicData,
              emotionalResult
            );
            const cssVariables = this.generateUnifiedCSSVariables(
              colorProcessingResult,
              emotionalResult,
              genreCharacteristics,
              oklabPreset
            );
            const { accentHex, accentRgb } = this.selectOptimalAccentColor(
              colorProcessingResult
            );
            const processingTime = performance.now() - startTime;
            const result = {
              enhancedColors: Object.fromEntries(
                Object.entries(colorProcessingResult).map(([key, oklabResult]) => [
                  key,
                  oklabResult.enhancedHex
                ])
              ),
              accentHex,
              accentRgb,
              oklabPreset,
              oklabResults: colorProcessingResult,
              detectedGenre,
              emotionalResult,
              genreCharacteristics,
              processingTime,
              musicInfluenceStrength,
              processingStrategy,
              cssVariables
            };
            this.cacheResult(cacheKey, result);
            if (this.enableDebug) {
              Y3KDebug?.debug?.log(
                "MusicalOKLABProcessor",
                "Musical OKLAB processing completed",
                {
                  genre: detectedGenre,
                  emotion: emotionalResult.primaryEmotion,
                  strategy: processingStrategy,
                  preset: oklabPreset.name,
                  processingTime,
                  colorCount: Object.keys(colorProcessingResult).length
                }
              );
            }
            return result;
          } catch (error) {
            if (this.enableDebug) {
              Y3KDebug?.debug?.error(
                "MusicalOKLABProcessor",
                "Musical processing failed:",
                error
              );
            }
            return this.createFallbackResult(context, performance.now() - startTime);
          }
        }
        /**
         * Determine the optimal processing strategy based on musical context
         */
        determineProcessingStrategy(context, options) {
          const { musicData } = context;
          if (!musicData || typeof musicData.energy !== "number" || typeof musicData.valence !== "number") {
            return "fallback";
          }
          if (options.preferGenreOverEmotion === true) {
            return "genre-primary";
          } else if (options.preferGenreOverEmotion === false) {
            return "emotion-primary";
          }
          const energyExtremity = Math.abs(musicData.energy - 0.5) * 2;
          const valenceExtremity = Math.abs(musicData.valence - 0.5) * 2;
          const emotionalExtremity = (energyExtremity + valenceExtremity) / 2;
          if (emotionalExtremity > 0.6) {
            return "emotion-primary";
          }
          const detectedGenre = this.genreManager.detectGenre(musicData);
          if (detectedGenre !== "default") {
            return "genre-primary";
          }
          return "balanced";
        }
        /**
         * Get optimal OKLAB preset considering both genre and emotional context
         */
        async getOptimalOKLABPreset(context, strategy, options) {
          const { musicData } = context;
          try {
            let preset;
            switch (strategy) {
              case "genre-primary":
                preset = this.genreManager.getOKLABPresetForTrack(musicData);
                break;
              case "emotion-primary":
                const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
                preset = emotionalResult.oklabPreset;
                break;
              case "balanced":
                const genrePreset = this.genreManager.getOKLABPresetForTrack(musicData);
                const emotionalResult2 = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
                preset = this.processBlendedPresets(
                  genrePreset,
                  emotionalResult2.oklabPreset,
                  options.intensityMultiplier || 1
                );
                break;
              default:
                preset = OKLABColorProcessor.getPreset("STANDARD");
            }
            return preset;
          } catch (error) {
            if (this.enableDebug) {
              Y3KDebug?.debug?.warn(
                "MusicalOKLABProcessor",
                "Failed to get optimal preset, using STANDARD:",
                error
              );
            }
            return OKLABColorProcessor.getPreset("STANDARD");
          }
        }
        /**
         * Process two OKLAB presets for balanced processing strategy
         */
        processBlendedPresets(genrePreset, emotionalPreset, intensityMultiplier) {
          const blendedChromaBoost = (genrePreset.chromaBoost + emotionalPreset.chromaBoost) / 2 * intensityMultiplier;
          const blendedLightnessBoost = (genrePreset.lightnessBoost + emotionalPreset.lightnessBoost) / 2;
          const blendedShadowReduction = (genrePreset.shadowReduction + emotionalPreset.shadowReduction) / 2;
          const blendedVibrantThreshold = (genrePreset.vibrantThreshold + emotionalPreset.vibrantThreshold) / 2;
          return OKLABColorProcessor.createCustomPreset(
            "blended-genre-emotion",
            `Blended ${genrePreset.name} + ${emotionalPreset.name}`,
            blendedLightnessBoost,
            blendedChromaBoost,
            blendedShadowReduction,
            blendedVibrantThreshold
          );
        }
        /**
         * Process all colors through OKLAB with musical context
         */
        async processColorsWithMusicalContext(rawColors, musicData, preset) {
          const results = {};
          for (const [key, color3] of Object.entries(rawColors)) {
            if (!color3 || typeof color3 !== "string" || !color3.startsWith("#")) {
              continue;
            }
            try {
              const oklabResult = this.oklabProcessor.processColor(color3, preset);
              results[key] = oklabResult;
            } catch (error) {
              if (this.enableDebug) {
                Y3KDebug?.debug?.warn(
                  "MusicalOKLABProcessor",
                  `Failed to process color ${key}:`,
                  error
                );
              }
            }
          }
          return results;
        }
        /**
         * Calculate music influence strength for processing
         */
        calculateMusicInfluenceStrength(musicData, emotionalResult) {
          const energyInfluence = musicData.energy || 0.5;
          const valenceExtremity = Math.abs((musicData.valence || 0.5) - 0.5) * 2;
          const emotionalIntensity = emotionalResult.intensity;
          const baseInfluence = (energyInfluence + valenceExtremity + emotionalIntensity) / 3;
          let contextBoost = 1;
          if (musicData.tempo && musicData.tempo > 0) contextBoost += 0.1;
          if (musicData.danceability && musicData.danceability > 0.7)
            contextBoost += 0.1;
          if (musicData.genre && musicData.genre !== "default") contextBoost += 0.1;
          return Math.min(1, baseInfluence * contextBoost);
        }
        /**
         * Generate comprehensive CSS variables for all visual systems
         */
        generateUnifiedCSSVariables(oklabResults, emotionalResult, genreCharacteristics, preset) {
          const variables = {};
          Object.entries(oklabResults).forEach(([key, result]) => {
            variables[`--sn-${key.toLowerCase()}-enhanced`] = result.enhancedHex;
            variables[`--sn-${key.toLowerCase()}-oklab-l`] = result.oklabEnhanced.L.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklab-a`] = result.oklabEnhanced.a.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklab-b`] = result.oklabEnhanced.b.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklch-c`] = result.oklchEnhanced.C.toFixed(3);
            variables[`--sn-${key.toLowerCase()}-oklch-h`] = result.oklchEnhanced.H.toFixed(1);
            variables[`--sn-${key.toLowerCase()}-shadow`] = result.shadowHex;
          });
          Object.entries(emotionalResult.cssVariables).forEach(([key, value]) => {
            variables[key] = value;
          });
          variables["--sn-detected-genre"] = genreCharacteristics ? genreCharacteristics.vibrancyLevel : "standard";
          variables["--sn-color-temperature"] = genreCharacteristics ? genreCharacteristics.colorTemperature : "neutral";
          variables["--sn-emotional-range"] = genreCharacteristics ? genreCharacteristics.emotionalRange : "moderate";
          variables["--sn-oklab-preset-name"] = preset.name;
          variables["--sn-oklab-chroma-boost"] = preset.chromaBoost.toString();
          variables["--sn-oklab-lightness-boost"] = preset.lightnessBoost.toString();
          variables["--sn-musical-oklab-processing"] = "enabled";
          variables["--sn-color-processing-mode"] = "unified-musical-oklab";
          return variables;
        }
        /**
         * Select optimal accent color from enhanced palette
         */
        selectOptimalAccentColor(oklabResults) {
          const priorityKeys = [
            "VIBRANT",
            "PROMINENT",
            "DARK_VIBRANT",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorityKeys) {
            if (oklabResults[key]) {
              const result = oklabResults[key];
              return {
                accentHex: result.enhancedHex,
                accentRgb: `${result.enhancedRgb.r},${result.enhancedRgb.g},${result.enhancedRgb.b}`
              };
            }
          }
          const firstResult = Object.values(oklabResults)[0];
          if (firstResult) {
            return {
              accentHex: firstResult.enhancedHex,
              accentRgb: `${firstResult.enhancedRgb.r},${firstResult.enhancedRgb.g},${firstResult.enhancedRgb.b}`
            };
          }
          return {
            accentHex: "#cba6f7",
            // Catppuccin mauve
            accentRgb: "203,166,247"
          };
        }
        /**
         * Create fallback result when coordination fails
         */
        createFallbackResult(context, processingTime) {
          const fallbackPreset = OKLABColorProcessor.getPreset("STANDARD");
          return {
            enhancedColors: context.rawColors,
            accentHex: "#cba6f7",
            accentRgb: "203,166,247",
            oklabPreset: fallbackPreset,
            oklabResults: {},
            detectedGenre: "default",
            emotionalResult: {
              primaryEmotion: "calm",
              intensity: 0.5,
              temperature: 3500,
              blendRatio: 1,
              cssClass: "smooth-emotion-calm",
              cssVariables: {},
              oklabPreset: fallbackPreset
            },
            genreCharacteristics: {
              vibrancyLevel: "standard",
              emotionalRange: "moderate",
              colorTemperature: "neutral"
            },
            processingTime,
            musicInfluenceStrength: 0.5,
            processingStrategy: "fallback",
            cssVariables: {
              "--sn-musical-oklab-processing": "fallback",
              "--sn-oklab-preset-name": "STANDARD"
            }
          };
        }
        // Utility methods
        generateCacheKey(context) {
          return `${context.trackUri}-${context.timestamp}-${JSON.stringify(
            context.musicData
          )}`;
        }
        cacheResult(cacheKey, result) {
          if (this.coordinationCache.size >= this.cacheMaxSize) {
            const firstKey = this.coordinationCache.keys().next().value;
            if (firstKey) this.coordinationCache.delete(firstKey);
          }
          this.coordinationCache.set(cacheKey, result);
          setTimeout(() => {
            this.coordinationCache.delete(cacheKey);
          }, this.cacheTimeoutMs);
        }
        /**
         * Convert MusicalOKLABResult to ColorResult for integration with existing systems
         */
        convertToColorResult(musicalResult, context) {
          return {
            processedColors: {
              ...musicalResult.enhancedColors,
              ...musicalResult.cssVariables
            },
            accentHex: musicalResult.accentHex,
            accentRgb: musicalResult.accentRgb,
            metadata: {
              strategy: "musical-oklab-processor",
              processingTime: musicalResult.processingTime,
              detectedGenre: musicalResult.detectedGenre,
              emotionalState: musicalResult.emotionalResult.primaryEmotion,
              oklabPreset: musicalResult.oklabPreset.name,
              processingStrategy: musicalResult.processingStrategy,
              musicInfluenceStrength: musicalResult.musicInfluenceStrength
            },
            context: {
              rawColors: context.rawColors,
              trackUri: context.trackUri,
              timestamp: context.timestamp,
              harmonicMode: context.harmonicMode || "musical-oklab-processing",
              musicData: context.musicData
            }
          };
        }
        /**
         * Clear processing cache
         */
        clearProcessingCache() {
          this.coordinationCache.clear();
          if (this.enableDebug) {
            Y3KDebug?.debug?.log(
              "MusicalOKLABProcessor",
              "Processing cache cleared"
            );
          }
        }
        /**
         * Get processing metrics for monitoring
         */
        getProcessingMetrics() {
          return {
            cacheSize: this.coordinationCache.size,
            maxCacheSize: this.cacheMaxSize,
            cacheTimeoutMs: this.cacheTimeoutMs,
            enableDebug: this.enableDebug
          };
        }
      };
      __name(_MusicalOKLABProcessor, "MusicalOKLABProcessor");
      MusicalOKLABProcessor = _MusicalOKLABProcessor;
    }
  });

  // src-js/visual/strategies/BackgroundStrategyRegistry.ts
  var _BackgroundStrategyRegistry, BackgroundStrategyRegistry;
  var init_BackgroundStrategyRegistry = __esm({
    "src-js/visual/strategies/BackgroundStrategyRegistry.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      _BackgroundStrategyRegistry = class _BackgroundStrategyRegistry {
        // 30 seconds
        constructor() {
          this.strategiesMap = /* @__PURE__ */ new Map();
          // Performance monitoring
          this.metrics = {
            totalStrategies: 0,
            healthyStrategies: 0,
            averageResponseTime: 0,
            totalUsageCount: 0,
            cacheHitRate: 0,
            memoryUsage: 0
          };
          // Health monitoring
          this.healthCheckInterval = null;
          this.HEALTH_CHECK_INTERVAL_MS = 3e4;
          this.startHealthMonitoring();
          Y3KDebug?.debug?.log(
            "BackgroundStrategyRegistry",
            "Strategy registry initialized"
          );
        }
        /**
         * Register a color processing strategy
         */
        register(strategy) {
          const strategyName = strategy.getStrategyName();
          if (this.strategiesMap.has(strategyName)) {
            Y3KDebug?.debug?.warn(
              "BackgroundStrategyRegistry",
              `Strategy ${strategyName} is already registered, replacing...`
            );
          }
          try {
            const registration = {
              strategy,
              registrationTime: Date.now(),
              lastUsed: 0,
              usageCount: 0,
              errorCount: 0,
              averageProcessingTime: 0,
              isHealthy: true,
              metadata: this.inferStrategyMetadata(strategy)
            };
            this.strategiesMap.set(strategyName, registration);
            this.updateMetrics();
            Y3KDebug?.debug?.log(
              "BackgroundStrategyRegistry",
              `Registered strategy: ${strategyName}`,
              {
                category: registration.metadata.category,
                priority: registration.metadata.priority,
                memoryImpact: registration.metadata.memoryImpact
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "BackgroundStrategyRegistry",
              `Failed to register strategy ${strategyName}:`,
              error
            );
          }
        }
        /**
         * Select best strategy for given criteria
         */
        selectStrategy(criteria) {
          const availableStrategies = Array.from(this.strategiesMap.values()).filter((reg) => reg.isHealthy).sort(
            (a, b) => this.scoreStrategy(b, criteria) - this.scoreStrategy(a, criteria)
          );
          if (availableStrategies.length === 0) {
            Y3KDebug?.debug?.warn(
              "BackgroundStrategyRegistry",
              "No healthy strategies available"
            );
            return null;
          }
          const selectedStrategy = availableStrategies[0];
          if (!selectedStrategy) {
            Y3KDebug?.debug?.warn(
              "BackgroundStrategyRegistry",
              "No strategies available after filtering"
            );
            return null;
          }
          this.recordStrategyUsage(selectedStrategy.strategy.getStrategyName());
          Y3KDebug?.debug?.log(
            "BackgroundStrategyRegistry",
            `Selected strategy: ${selectedStrategy.strategy.getStrategyName()}`,
            {
              score: this.scoreStrategy(selectedStrategy, criteria),
              totalAvailable: availableStrategies.length
            }
          );
          return selectedStrategy.strategy;
        }
        /**
         * Get all registered strategies
         */
        getStrategies() {
          return Array.from(this.strategiesMap.values()).filter((reg) => reg.isHealthy).map((reg) => reg.strategy);
        }
        /**
         * Get strategy by name
         */
        getStrategy(name) {
          const registration = this.strategiesMap.get(name);
          return registration && registration.isHealthy ? registration.strategy : null;
        }
        /**
         * Get multiple strategies by criteria with intelligent selection
         */
        selectMultipleStrategies(criteria, maxStrategies = 4) {
          const scoredStrategies = Array.from(this.strategiesMap.values()).filter((reg) => reg.isHealthy).map((reg) => ({
            registration: reg,
            score: this.scoreStrategy(reg, criteria)
          })).sort((a, b) => b.score - a.score).slice(0, maxStrategies);
          scoredStrategies.forEach((scored) => {
            this.recordStrategyUsage(scored.registration.strategy.getStrategyName());
          });
          const selectedStrategies = scoredStrategies.map(
            (scored) => scored.registration.strategy
          );
          Y3KDebug?.debug?.log(
            "BackgroundStrategyRegistry",
            `Selected ${selectedStrategies.length} strategies`,
            {
              strategies: selectedStrategies.map((s) => s.getStrategyName()),
              scores: scoredStrategies.map((s) => s.score)
            }
          );
          return selectedStrategies;
        }
        /**
         * Score a strategy based on selection criteria
         */
        scoreStrategy(registration, criteria) {
          let score = 0;
          score += registration.metadata.priority * 10;
          switch (criteria.performance) {
            case "high":
              if (registration.metadata.memoryImpact === "low") score += 20;
              if (registration.averageProcessingTime < 10) score += 15;
              break;
            case "medium":
              if (registration.metadata.memoryImpact !== "high") score += 10;
              if (registration.averageProcessingTime < 20) score += 10;
              break;
            case "low":
              break;
          }
          switch (criteria.quality) {
            case "premium":
              if (registration.metadata.category === "enhancement") score += 15;
              if (registration.metadata.tags.includes("webgl")) score += 10;
              break;
            case "enhanced":
              if (registration.metadata.category !== "effects") score += 10;
              break;
            case "basic":
              if (registration.metadata.category === "foundation") score += 15;
              break;
          }
          if (criteria.deviceCapabilities) {
            if (criteria.deviceCapabilities.hasWebGL && registration.metadata.tags.includes("webgl")) {
              score += 15;
            }
            if (criteria.deviceCapabilities.isMobile && registration.metadata.memoryImpact === "low") {
              score += 10;
            }
            if (criteria.deviceCapabilities.memoryMB && criteria.deviceCapabilities.memoryMB < 4e3) {
              if (registration.metadata.memoryImpact === "high") score -= 20;
            }
          }
          if (criteria.userPreferences) {
            if (criteria.userPreferences.enableAdvancedBlending && registration.metadata.tags.includes("advanced-blending")) {
              score += 12;
            }
            if (criteria.userPreferences.harmonicMode) {
              const mode = criteria.userPreferences.harmonicMode;
              if (registration.metadata.tags.includes(mode)) {
                score += 8;
              }
            }
          }
          const errorRate = registration.usageCount > 0 ? registration.errorCount / registration.usageCount : 0;
          score -= errorRate * 30;
          const timeSinceLastUse = Date.now() - registration.lastUsed;
          if (timeSinceLastUse < 3e5) {
            score += 5;
          }
          return Math.max(0, score);
        }
        /**
         * Infer strategy metadata from strategy instance
         */
        inferStrategyMetadata(strategy) {
          const strategyName = strategy.getStrategyName();
          const tags = [];
          let category = "enhancement";
          let priority = 5;
          let memoryImpact = "medium";
          let deviceRequirements = [];
          switch (strategyName) {
            case "dynamic-catppuccin":
              category = "accent";
              priority = 10;
              memoryImpact = "low";
              tags.push("catppuccin", "dynamic", "accent", "spicetify");
              break;
            case "living-gradient":
              category = "foundation";
              priority = 8;
              memoryImpact = "low";
              tags.push("gradient", "pulsing", "foundation", "css");
              break;
            case "webgl-gradient":
              category = "enhancement";
              priority = 6;
              memoryImpact = "high";
              deviceRequirements.push("webgl");
              tags.push("webgl", "gradient", "performance", "advanced-blending");
              break;
            case "depth-layered":
              category = "effects";
              priority = 7;
              memoryImpact = "medium";
              tags.push(
                "depth",
                "layers",
                "parallax",
                "visual-effects",
                "cosmic",
                "cinematic"
              );
              break;
            default:
              break;
          }
          return {
            category,
            priority,
            memoryImpact,
            deviceRequirements,
            tags
          };
        }
        /**
         * Record strategy usage for metrics
         */
        recordStrategyUsage(strategyName) {
          const registration = this.strategiesMap.get(strategyName);
          if (registration) {
            registration.usageCount++;
            registration.lastUsed = Date.now();
          }
        }
        /**
         * Record strategy error for health monitoring
         */
        recordStrategyError(strategyName, error) {
          const registration = this.strategiesMap.get(strategyName);
          if (registration) {
            registration.errorCount++;
            const errorRate = registration.errorCount / Math.max(1, registration.usageCount);
            if (errorRate > 0.5 && registration.usageCount > 5) {
              registration.isHealthy = false;
              Y3KDebug?.debug?.warn(
                "BackgroundStrategyRegistry",
                `Strategy ${strategyName} marked as unhealthy`,
                {
                  errorRate,
                  errorCount: registration.errorCount,
                  usageCount: registration.usageCount
                }
              );
            }
          }
        }
        /**
         * Record strategy processing time for performance tracking
         */
        recordStrategyProcessingTime(strategyName, processingTime) {
          const registration = this.strategiesMap.get(strategyName);
          if (registration) {
            const totalTime = registration.averageProcessingTime * (registration.usageCount - 1) + processingTime;
            registration.averageProcessingTime = totalTime / registration.usageCount;
          }
        }
        /**
         * Start health monitoring for all registered strategies
         */
        startHealthMonitoring() {
          this.healthCheckInterval = window.setInterval(() => {
            this.performHealthChecks();
          }, this.HEALTH_CHECK_INTERVAL_MS);
        }
        /**
         * Perform health checks on all registered strategies
         */
        async performHealthChecks() {
          try {
            for (const [name, registration] of this.strategiesMap.entries()) {
              try {
                if ("healthCheck" in registration.strategy && typeof registration.strategy.healthCheck === "function") {
                  const healthResult = await registration.strategy.healthCheck();
                  registration.isHealthy = healthResult?.healthy ?? true;
                  if (!registration.isHealthy) {
                    Y3KDebug?.debug?.warn(
                      "BackgroundStrategyRegistry",
                      `Strategy ${name} failed health check:`,
                      healthResult
                    );
                  }
                }
              } catch (error) {
                registration.isHealthy = false;
                Y3KDebug?.debug?.error(
                  "BackgroundStrategyRegistry",
                  `Health check failed for strategy ${name}:`,
                  error
                );
              }
            }
            this.updateMetrics();
          } catch (error) {
            Y3KDebug?.debug?.error(
              "BackgroundStrategyRegistry",
              "Health check monitoring failed:",
              error
            );
          }
        }
        /**
         * Update registry metrics
         */
        updateMetrics() {
          const registrations = Array.from(this.strategiesMap.values());
          this.metrics.totalStrategies = registrations.length;
          this.metrics.healthyStrategies = registrations.filter(
            (r) => r.isHealthy
          ).length;
          this.metrics.totalUsageCount = registrations.reduce(
            (sum, r) => sum + r.usageCount,
            0
          );
          const processingTimes = registrations.filter((r) => r.averageProcessingTime > 0).map((r) => r.averageProcessingTime);
          if (processingTimes.length > 0) {
            this.metrics.averageResponseTime = processingTimes.reduce((a, b) => a + b, 0) / processingTimes.length;
          }
          this.metrics.memoryUsage = registrations.reduce((sum, r) => {
            const impact = r.metadata.memoryImpact === "high" ? 3 : r.metadata.memoryImpact === "medium" ? 2 : 1;
            return sum + impact;
          }, 0);
        }
        /**
         * Get registry metrics for monitoring
         */
        getRegistryMetrics() {
          return { ...this.metrics };
        }
        /**
         * Get detailed strategy information
         */
        getStrategyInfo(strategyName) {
          const registration = this.strategiesMap.get(strategyName);
          return registration ? { ...registration } : null;
        }
        /**
         * Get all strategy information for debugging
         */
        getAllStrategyInfo() {
          return Array.from(this.strategiesMap.entries()).map(
            ([name, registration]) => ({
              name,
              registration: { ...registration }
            })
          );
        }
        /**
         * Unregister a strategy
         */
        unregister(strategyName) {
          const success = this.strategiesMap.delete(strategyName);
          if (success) {
            this.updateMetrics();
            Y3KDebug?.debug?.log(
              "BackgroundStrategyRegistry",
              `Unregistered strategy: ${strategyName}`
            );
          }
          return success;
        }
        /**
         * Clear all strategies
         */
        clear() {
          this.strategiesMap.clear();
          this.updateMetrics();
          Y3KDebug?.debug?.log(
            "BackgroundStrategyRegistry",
            "All strategies cleared from registry"
          );
        }
        /**
         * Cleanup resources
         */
        destroy() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          for (const [name, registration] of this.strategiesMap.entries()) {
            if ("destroy" in registration.strategy && typeof registration.strategy.destroy === "function") {
              try {
                registration.strategy.destroy();
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "BackgroundStrategyRegistry",
                  `Error destroying strategy ${name}:`,
                  error
                );
              }
            }
          }
          this.clear();
          Y3KDebug?.debug?.log(
            "BackgroundStrategyRegistry",
            "Strategy registry destroyed"
          );
        }
      };
      __name(_BackgroundStrategyRegistry, "BackgroundStrategyRegistry");
      BackgroundStrategyRegistry = _BackgroundStrategyRegistry;
    }
  });

  // src-js/visual/strategies/DepthLayeredStrategy.ts
  var _DepthLayeredStrategy, DepthLayeredStrategy;
  var init_DepthLayeredStrategy = __esm({
    "src-js/visual/strategies/DepthLayeredStrategy.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_config();
      init_ThemeUtilities();
      _DepthLayeredStrategy = class _DepthLayeredStrategy {
        constructor() {
          this.utils = ThemeUtilities_exports;
          this.config = ADVANCED_SYSTEM_CONFIG;
          this.cssController = null;
          this.depthState = {
            containerElement: null,
            backgroundContainer: null,
            depthLayers: /* @__PURE__ */ new Map(),
            animationFrameId: null,
            lastAnimationTime: 0,
            scrollY: 0,
            scrollX: 0,
            lastUpdateTime: 0,
            isInitialized: false,
            stylesInjected: false
          };
          // Track animation time for coordinator-driven updates
          this.animationElapsedTime = 0;
          this.depthSettings = {
            enabled: true,
            layerCount: 6,
            maxDepth: 1e3,
            parallaxStrength: 0.5,
            depthFogIntensity: 0.7,
            infiniteScrolling: true,
            qualityLevel: "medium",
            performanceMode: false,
            musicResponsiveness: 1
          };
          this.performanceMetrics = {
            totalLayers: 0,
            visibleLayers: 0,
            averageDepth: 0,
            parallaxRange: 0,
            renderTime: 0,
            memoryUsage: 0
          };
          this.layerTemplates = {
            cosmic: {
              animation: "cosmic-drift",
              duration: "120s",
              baseGradient: "radial-gradient(ellipse at center, {primary} 0%, {secondary} 50%, {base} 100%)"
            },
            nebula: {
              animation: "nebula-flow",
              duration: "180s",
              baseGradient: "conic-gradient(from 45deg, {primary} 0%, {secondary} 25%, {tertiary} 50%, {quaternary} 75%, {primary} 100%)"
            },
            stellar: {
              animation: "stellar-motion",
              duration: "240s",
              baseGradient: "linear-gradient(45deg, {primary} 0%, {secondary} 25%, {tertiary} 50%, {quaternary} 75%, {primary} 100%)"
            },
            quantum: {
              animation: "quantum-field",
              duration: "300s",
              baseGradient: "radial-gradient(circle at 30% 70%, {primary} 0%, transparent 50%), radial-gradient(circle at 70% 30%, {secondary} 0%, transparent 50%)"
            },
            dimensional: {
              animation: "dimensional-shift",
              duration: "360s",
              baseGradient: "linear-gradient(135deg, {primary} 0%, {secondary} 20%, {tertiary} 40%, {quaternary} 60%, {primary} 80%, {secondary} 100%)"
            },
            void: {
              animation: "void-expansion",
              duration: "480s",
              baseGradient: "radial-gradient(ellipse at center, {base} 0%, {secondary} 30%, {primary} 60%, transparent 100%)"
            }
          };
          // Event handlers
          this.boundScrollHandler = null;
          this.boundResizeHandler = null;
          this.deviceDetector = new DeviceCapabilityDetector();
          this.cssController = getGlobalOptimizedCSSController();
          this.loadDepthSettings();
          this.adaptToDeviceCapabilities();
          this.boundScrollHandler = this.handleScroll.bind(this);
          this.boundResizeHandler = this.handleResize.bind(this);
          Y3KDebug?.debug?.log(
            "DepthLayeredStrategy",
            "Depth layered strategy initialized",
            {
              layerCount: this.depthSettings.layerCount,
              qualityLevel: this.depthSettings.qualityLevel,
              deviceCapability: this.deviceDetector.recommendPerformanceQuality()
            }
          );
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "depth-layered";
        }
        /**
         * Check if strategy can handle the given context
         */
        canProcess(context) {
          return this.depthSettings.enabled;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          const baseTime = 15;
          const layerMultiplier = this.depthSettings.layerCount / 6;
          const qualityMultiplier = this.depthSettings.qualityLevel === "high" ? 1.3 : this.depthSettings.qualityLevel === "low" ? 0.7 : 1;
          return Math.round(baseTime * layerMultiplier * qualityMultiplier);
        }
        /**
         * Process colors using Depth Layered strategy
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            if (!this.depthState.isInitialized) {
              await this.initializeDepthSystem();
            }
            const depthColors = this.extractDepthColors(context.rawColors);
            await this.updateDepthLayers(depthColors);
            if (!this.depthState.animationFrameId) {
              this.startDepthAnimation();
            }
            if (context.musicData?.energy !== void 0) {
              this.updateDepthWithMusicEnergy(context.musicData.energy);
            }
            this.depthState.lastUpdateTime = Date.now();
            this.updatePerformanceMetrics();
            const processingTime = performance.now() - startTime;
            const result = {
              processedColors: {
                depthLayers: this.depthState.depthLayers.size.toString(),
                depthEnabled: this.depthSettings.enabled.toString(),
                qualityLevel: this.depthSettings.qualityLevel,
                ...context.rawColors
              },
              accentHex: this.selectPrimaryColor(context.rawColors) || "#cba6f7",
              accentRgb: this.convertToRgbString(
                this.selectPrimaryColor(context.rawColors) || "#cba6f7"
              ),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `depth-layered-${context.trackUri}`,
                harmonicIntensity: this.depthSettings.parallaxStrength,
                layerCount: this.depthState.depthLayers.size
              },
              context
            };
            Y3KDebug?.debug?.log(
              "DepthLayeredStrategy",
              "Depth layered processing completed",
              {
                layerCount: this.depthState.depthLayers.size,
                processingTime,
                trackUri: context.trackUri
              }
            );
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3KDebug?.debug?.error(
              "DepthLayeredStrategy",
              "Depth layered processing failed:",
              error
            );
            return {
              processedColors: context.rawColors,
              accentHex: this.selectPrimaryColor(context.rawColors) || "#cba6f7",
              accentRgb: this.convertToRgbString(
                this.selectPrimaryColor(context.rawColors) || "#cba6f7"
              ),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error"
              },
              context
            };
          }
        }
        /**
         * Load depth settings from settings manager
         */
        loadDepthSettings() {
          try {
            const gradientIntensity = settings.get("sn-gradient-intensity");
            if (gradientIntensity) {
              const qualityLevel = gradientIntensity === "intense" ? "high" : gradientIntensity === "balanced" ? "medium" : gradientIntensity === "minimal" ? "low" : "medium";
              this.depthSettings.qualityLevel = qualityLevel;
              this.adjustQualitySettings();
            }
            const enabledSetting = gradientIntensity !== "disabled";
            if (enabledSetting !== void 0) {
              this.depthSettings.enabled = enabledSetting;
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "DepthLayeredStrategy",
              "Failed to load settings:",
              error
            );
          }
        }
        /**
         * Adapt settings to device capabilities
         */
        adaptToDeviceCapabilities() {
          const recommendation = this.deviceDetector.recommendPerformanceQuality();
          switch (recommendation) {
            case "low":
              this.depthSettings.qualityLevel = "low";
              this.depthSettings.layerCount = 3;
              this.depthSettings.performanceMode = true;
              this.depthSettings.parallaxStrength = 0.3;
              this.depthSettings.depthFogIntensity = 0.5;
              break;
            case "balanced":
              this.depthSettings.qualityLevel = "medium";
              this.depthSettings.layerCount = 6;
              this.depthSettings.performanceMode = false;
              this.depthSettings.parallaxStrength = 0.5;
              this.depthSettings.depthFogIntensity = 0.7;
              break;
            case "high":
              this.depthSettings.qualityLevel = "high";
              this.depthSettings.layerCount = 9;
              this.depthSettings.performanceMode = false;
              this.depthSettings.parallaxStrength = 0.8;
              this.depthSettings.depthFogIntensity = 0.9;
              break;
          }
        }
        /**
         * Adjust quality settings based on selected level
         */
        adjustQualitySettings() {
          switch (this.depthSettings.qualityLevel) {
            case "low":
              this.depthSettings.layerCount = 3;
              this.depthSettings.parallaxStrength = 0.3;
              this.depthSettings.depthFogIntensity = 0.5;
              break;
            case "medium":
              this.depthSettings.layerCount = 6;
              this.depthSettings.parallaxStrength = 0.5;
              this.depthSettings.depthFogIntensity = 0.7;
              break;
            case "high":
              this.depthSettings.layerCount = 9;
              this.depthSettings.parallaxStrength = 0.8;
              this.depthSettings.depthFogIntensity = 0.9;
              break;
          }
        }
        /**
         * Initialize depth system
         */
        async initializeDepthSystem() {
          this.createContainerElements();
          this.injectDepthAnimations();
          this.setupEventListeners();
          this.depthState.isInitialized = true;
          Y3KDebug?.debug?.log(
            "DepthLayeredStrategy",
            "Depth system initialized successfully"
          );
        }
        /**
         * Create container elements for depth layers
         */
        createContainerElements() {
          this.depthState.containerElement = document.querySelector(".Root__main-view") || document.querySelector(".main-view-container") || document.body;
          this.depthState.backgroundContainer = document.createElement("div");
          this.depthState.backgroundContainer.className = "sn-depth-background-container";
          this.depthState.backgroundContainer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -20;
      pointer-events: none;
      overflow: hidden;
      perspective: 1000px;
      transform-style: preserve-3d;
    `;
          this.depthState.containerElement.insertBefore(
            this.depthState.backgroundContainer,
            this.depthState.containerElement.firstChild
          );
        }
        /**
         * Inject CSS animations for depth layers
         */
        injectDepthAnimations() {
          if (this.depthState.stylesInjected) return;
          const styleElement = document.createElement("style");
          styleElement.textContent = `
      .sn-depth-layer {
        position: absolute;
        width: 120%;
        height: 120%;
        top: -10%;
        left: -10%;
        pointer-events: none;
        transform-style: preserve-3d;
        will-change: transform, opacity;
      }

      @keyframes cosmic-drift {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        25% { transform: translate3d(-2%, 1%, 0) rotate(0.5deg) scale(1.02); }
        50% { transform: translate3d(0, -1%, 0) rotate(0deg) scale(0.98); }
        75% { transform: translate3d(2%, 0.5%, 0) rotate(-0.5deg) scale(1.01); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes nebula-flow {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        33% { transform: translate3d(1%, -1%, 0) rotate(1deg) scale(1.03); }
        66% { transform: translate3d(-1%, 1%, 0) rotate(-1deg) scale(0.97); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes stellar-motion {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        20% { transform: translate3d(-1%, 0.5%, 0) rotate(0.3deg) scale(1.01); }
        40% { transform: translate3d(0.5%, -0.5%, 0) rotate(-0.3deg) scale(0.99); }
        60% { transform: translate3d(1%, 0.5%, 0) rotate(0.2deg) scale(1.02); }
        80% { transform: translate3d(-0.5%, 1%, 0) rotate(-0.2deg) scale(0.98); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes quantum-field {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); filter: blur(0px); }
        25% { transform: translate3d(0.5%, -0.5%, 0) rotate(0.1deg) scale(1.01); filter: blur(0.5px); }
        50% { transform: translate3d(-0.5%, 0.5%, 0) rotate(-0.1deg) scale(0.99); filter: blur(1px); }
        75% { transform: translate3d(0.3%, 0.3%, 0) rotate(0.05deg) scale(1.005); filter: blur(0.3px); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); filter: blur(0px); }
      }

      @keyframes dimensional-shift {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
        16% { transform: translate3d(0.2%, -0.2%, 0) rotate(0.1deg) scale(1.005); }
        32% { transform: translate3d(-0.2%, 0.2%, 0) rotate(-0.1deg) scale(0.995); }
        48% { transform: translate3d(0.1%, 0.1%, 0) rotate(0.05deg) scale(1.002); }
        64% { transform: translate3d(-0.1%, -0.1%, 0) rotate(-0.05deg) scale(0.998); }
        80% { transform: translate3d(0.15%, 0%, 0) rotate(0.02deg) scale(1.001); }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); }
      }

      @keyframes void-expansion {
        0% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.9; }
        50% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1.1); opacity: 0.6; }
        100% { transform: translate3d(0, 0, 0) rotate(0deg) scale(1); opacity: 0.9; }
      }

      @media (prefers-reduced-motion: reduce) {
        .sn-depth-layer {
          animation: none !important;
        }
      }
    `;
          document.head.appendChild(styleElement);
          this.depthState.stylesInjected = true;
        }
        /**
         * Setup event listeners for depth system
         */
        setupEventListeners() {
          if (this.boundScrollHandler) {
            window.addEventListener("scroll", this.boundScrollHandler, {
              passive: true
            });
          }
          if (this.boundResizeHandler) {
            window.addEventListener("resize", this.boundResizeHandler, {
              passive: true
            });
          }
        }
        /**
         * Extract depth colors from color context
         */
        extractDepthColors(colors) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "LIGHT_VIBRANT",
            "DARK_VIBRANT",
            "VIBRANT_NON_ALARMING",
            "PROMINENT",
            "SECONDARY",
            "DESATURATED"
          ];
          const depthColors = [];
          const usedColors = /* @__PURE__ */ new Set();
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && !usedColors.has(color3) && this.utils.hexToRgb(color3)) {
              depthColors.push(color3);
              usedColors.add(color3);
              if (depthColors.length >= this.depthSettings.layerCount) break;
            }
          }
          while (depthColors.length < this.depthSettings.layerCount) {
            const baseColor = depthColors[0] || "#cba6f7";
            const variation = this.createColorVariation(
              baseColor,
              depthColors.length
            );
            depthColors.push(variation);
          }
          return depthColors;
        }
        /**
         * Create color variation for depth layers
         */
        createColorVariation(baseColor, index) {
          const rgb = this.utils.hexToRgb(baseColor);
          if (!rgb) return baseColor;
          const factor = 0.8 - index * 0.1;
          const r = Math.round(rgb.r * factor);
          const g = Math.round(rgb.g * factor);
          const b = Math.round(rgb.b * factor);
          return this.utils.rgbToHex(r, g, b);
        }
        /**
         * Update depth layers with new colors
         */
        async updateDepthLayers(depthColors) {
          if (!this.depthState.backgroundContainer) return;
          this.depthState.depthLayers.forEach((layer) => {
            if (layer.element.parentNode) {
              layer.element.parentNode.removeChild(layer.element);
            }
          });
          this.depthState.depthLayers.clear();
          const layerTemplateKeys = Object.keys(this.layerTemplates);
          for (let i = 0; i < this.depthSettings.layerCount; i++) {
            const depth = (i + 1) * (this.depthSettings.maxDepth / this.depthSettings.layerCount);
            const templateKey = layerTemplateKeys[i % layerTemplateKeys.length];
            const template = this.layerTemplates[templateKey];
            const layerElement = document.createElement("div");
            layerElement.className = "sn-depth-layer";
            layerElement.id = `sn-depth-layer-${i}`;
            const depthFactor = depth / this.depthSettings.maxDepth;
            const parallaxFactor = 1 - depthFactor * this.depthSettings.parallaxStrength;
            const opacity = 1 - depthFactor * this.depthSettings.depthFogIntensity;
            const scale = 1 + depthFactor * 0.2;
            const blur = depthFactor * 3;
            const gradient = this.createDepthGradient(
              template.baseGradient,
              depthColors,
              i
            );
            layerElement.style.cssText = `
        background: ${gradient};
        transform: var(--sn-depth-layer-${i}-transform, translate3d(0, 0, ${-depth}px) scale(${scale}));
        opacity: var(--sn-depth-layer-${i}-opacity, ${opacity});
        filter: blur(${blur}px);
        animation: ${template.animation} ${template.duration} ease-in-out infinite;
        animation-delay: ${i * 0.5}s;
      `;
            const depthLayer = {
              id: `depth-layer-${i}`,
              element: layerElement,
              depth,
              parallaxFactor,
              opacityRange: [opacity * 0.5, opacity],
              scaleRange: [scale * 0.95, scale * 1.05],
              rotationSpeed: 0.01 + i * 1e-3,
              colorShift: i * 30,
              blurAmount: blur,
              animationPhase: i * Math.PI / 4,
              enabled: true,
              gradientColors: depthColors.slice(i, i + 4),
              cachedOpacity: opacity,
              cachedTransform: `translate3d(0, 0, ${-depth}px) scale(${scale})`
            };
            this.depthState.depthLayers.set(depthLayer.id, depthLayer);
            this.depthState.backgroundContainer.appendChild(layerElement);
          }
          Y3KDebug?.debug?.log(
            "DepthLayeredStrategy",
            `Updated ${this.depthState.depthLayers.size} depth layers with new colors`
          );
        }
        /**
         * Create depth gradient from template and colors
         */
        createDepthGradient(template, colors, layerIndex) {
          const colorCount = colors.length;
          const primaryIndex = layerIndex % colorCount;
          const secondaryIndex = (layerIndex + 1) % colorCount;
          const tertiaryIndex = (layerIndex + 2) % colorCount;
          const quaternaryIndex = (layerIndex + 3) % colorCount;
          const depthFactor = layerIndex / this.depthSettings.layerCount;
          const baseOpacity = 0.8 - depthFactor * 0.6;
          const primary = this.convertToRgba(
            colors[primaryIndex] || "#cba6f7",
            baseOpacity
          );
          const secondary = this.convertToRgba(
            colors[secondaryIndex] || "#f5c2e7",
            baseOpacity * 0.7
          );
          const tertiary = this.convertToRgba(
            colors[tertiaryIndex] || "#fab387",
            baseOpacity * 0.5
          );
          const quaternary = this.convertToRgba(
            colors[quaternaryIndex] || "#a6e3a1",
            baseOpacity * 0.3
          );
          const base = this.convertToRgba("#1e1e2e", baseOpacity * 0.9);
          return template.replace(/\{primary\}/g, primary).replace(/\{secondary\}/g, secondary).replace(/\{tertiary\}/g, tertiary).replace(/\{quaternary\}/g, quaternary).replace(/\{base\}/g, base);
        }
        /**
         * Convert hex color to RGBA string
         */
        convertToRgba(hex, alpha) {
          const rgb = this.utils.hexToRgb(hex);
          return rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})` : `rgba(203, 166, 247, ${alpha})`;
        }
        /**
         * Start depth animation loop
         * MIGRATION NOTE: This method now no-ops. Animation is driven by EnhancedMasterAnimationCoordinator
         * via updateAnimation() method, which will be called automatically by SystemCoordinator.
         */
        startDepthAnimation() {
          Y3KDebug?.debug?.log("DepthLayeredStrategy", "Animation loop delegated to EnhancedMasterAnimationCoordinator");
        }
        /**
         * Update depth animations
         * PERFORMANCE FIX: Use CSS variables instead of direct style manipulation
         */
        updateDepthAnimations(deltaTime) {
          this.depthState.depthLayers.forEach((layer) => {
            layer.animationPhase += layer.rotationSpeed * deltaTime * 1e-3;
            const pulsingFactor = Math.sin(layer.animationPhase) * 0.05;
            const newOpacity = Math.max(0, Math.min(1, layer.cachedOpacity + pulsingFactor));
            layer.cachedOpacity = newOpacity;
            if (this.cssController) {
              const depthIndex = layer.id.replace("depth-layer-", "");
              this.cssController.queueCSSVariableUpdate(
                `--sn-depth-layer-${depthIndex}-opacity`,
                newOpacity.toString()
              );
            }
          });
        }
        /**
         * Update depth with music energy
         * PERFORMANCE FIX: Use CSS variables instead of direct style manipulation
         */
        updateDepthWithMusicEnergy(energy) {
          const energyModulation = energy * this.depthSettings.musicResponsiveness * 0.3;
          this.depthState.depthLayers.forEach((layer) => {
            const baseOpacity = layer.opacityRange[0];
            const maxOpacity = layer.opacityRange[1];
            const newOpacity = Math.max(
              0,
              Math.min(1, baseOpacity + energyModulation * (maxOpacity - baseOpacity))
            );
            layer.cachedOpacity = newOpacity;
            if (this.cssController) {
              const depthIndex = layer.id.replace("depth-layer-", "");
              this.cssController.queueCSSVariableUpdate(
                `--sn-depth-layer-${depthIndex}-opacity`,
                newOpacity.toString()
              );
            }
          });
        }
        /**
         * Handle scroll events for parallax
         */
        handleScroll(event) {
          if (!this.depthSettings.infiniteScrolling) return;
          this.depthState.scrollY = window.scrollY;
          this.depthState.scrollX = window.scrollX;
          this.updateParallaxEffects();
        }
        /**
         * Handle resize events
         */
        handleResize(event) {
          this.updateLayerDimensions();
        }
        /**
         * Update parallax effects
         * PERFORMANCE FIX: Use CSS variables instead of direct style manipulation
         */
        updateParallaxEffects() {
          this.depthState.depthLayers.forEach((layer) => {
            const parallaxY = this.depthState.scrollY * layer.parallaxFactor;
            const parallaxX = this.depthState.scrollX * layer.parallaxFactor * 0.5;
            const scaleMatch = layer.cachedTransform.match(/scale\(([^)]+)\)/);
            const scale = scaleMatch ? scaleMatch[1] : "1";
            const newTransform = `translate3d(${parallaxX}px, ${parallaxY}px, ${-layer.depth}px) scale(${scale})`;
            layer.cachedTransform = newTransform;
            if (this.cssController) {
              const depthIndex = layer.id.replace("depth-layer-", "");
              this.cssController.queueCSSVariableUpdate(
                `--sn-depth-layer-${depthIndex}-transform`,
                newTransform
              );
            }
          });
        }
        /**
         * Update layer dimensions
         * PERFORMANCE FIX: Use CSS variables instead of direct style manipulation
         */
        updateLayerDimensions() {
          this.depthState.depthLayers.forEach((layer) => {
            const depthFactor = layer.depth / this.depthSettings.maxDepth;
            const scale = 1 + depthFactor * 0.2;
            const translateMatch = layer.cachedTransform.match(/translate3d\([^)]+\)/);
            const translate = translateMatch ? translateMatch[0] : `translate3d(0, 0, ${-layer.depth}px)`;
            const newTransform = `${translate} scale(${scale})`;
            layer.cachedTransform = newTransform;
            if (this.cssController) {
              const depthIndex = layer.id.replace("depth-layer-", "");
              this.cssController.queueCSSVariableUpdate(
                `--sn-depth-layer-${depthIndex}-transform`,
                newTransform
              );
            }
          });
        }
        /**
         * updateAnimation() - Called by EnhancedMasterAnimationCoordinator at 60fps
         * Handles depth layer animations that were previously in standalone RAF loop
         */
        updateAnimation(deltaTime) {
          if (!this.depthState.isInitialized) return;
          this.animationElapsedTime += deltaTime;
          if (this.animationElapsedTime < 33) return;
          this.updateDepthAnimations(this.animationElapsedTime);
          this.updatePerformanceMetrics();
          this.animationElapsedTime = 0;
        }
        /**
         * Update performance metrics
         * PERFORMANCE FIX: Use cached opacity values instead of reading from DOM
         */
        updatePerformanceMetrics() {
          this.performanceMetrics.totalLayers = this.depthState.depthLayers.size;
          this.performanceMetrics.visibleLayers = Array.from(
            this.depthState.depthLayers.values()
          ).filter((layer) => layer.cachedOpacity > 0.01).length;
          this.performanceMetrics.averageDepth = Array.from(this.depthState.depthLayers.values()).reduce(
            (sum, layer) => sum + layer.depth,
            0
          ) / this.depthState.depthLayers.size;
          this.performanceMetrics.parallaxRange = this.depthSettings.parallaxStrength;
          this.performanceMetrics.renderTime = this.animationElapsedTime;
          if (this.cssController) {
            this.cssController.queueCSSVariableUpdate(
              "--sn-depth-layers-total",
              this.performanceMetrics.totalLayers.toString()
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-depth-layers-visible",
              this.performanceMetrics.visibleLayers.toString()
            );
          }
        }
        /**
         * Select primary color from extracted colors
         */
        selectPrimaryColor(colors) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "PROMINENT",
            "VIBRANT_NON_ALARMING",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Convert hex color to RGB string
         */
        convertToRgbString(hex) {
          const rgb = this.utils.hexToRgb(hex);
          return rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "203,166,247";
        }
        /**
         * Update configuration
         */
        updateConfig(newConfig) {
          this.depthSettings = { ...this.depthSettings, ...newConfig };
          if (newConfig.qualityLevel) {
            this.adjustQualitySettings();
          }
          Y3KDebug?.debug?.log(
            "DepthLayeredStrategy",
            "Configuration updated:",
            newConfig
          );
        }
        /**
         * Health check for strategy status
         */
        async healthCheck() {
          const hasRecentUpdate = Date.now() - this.depthState.lastUpdateTime < 3e4;
          return {
            healthy: this.depthState.isInitialized && this.depthSettings.enabled,
            canProcess: this.canProcess({}),
            issues: !this.depthState.isInitialized ? ["Depth system not initialized"] : !this.depthSettings.enabled ? ["Depth layers disabled in settings"] : [],
            metrics: {
              isInitialized: this.depthState.isInitialized,
              depthEnabled: this.depthSettings.enabled,
              layerCount: this.depthState.depthLayers.size,
              qualityLevel: this.depthSettings.qualityLevel,
              parallaxStrength: this.depthSettings.parallaxStrength,
              hasRecentUpdate,
              animationActive: this.depthState.animationFrameId !== null,
              performanceMetrics: this.performanceMetrics
            }
          };
        }
        /**
         * Cleanup depth resources
         */
        destroy() {
          if (this.depthState.animationFrameId) {
            cancelAnimationFrame(this.depthState.animationFrameId);
            this.depthState.animationFrameId = null;
          }
          if (this.boundScrollHandler) {
            window.removeEventListener("scroll", this.boundScrollHandler);
            this.boundScrollHandler = null;
          }
          if (this.boundResizeHandler) {
            window.removeEventListener("resize", this.boundResizeHandler);
            this.boundResizeHandler = null;
          }
          this.depthState.depthLayers.forEach((layer) => {
            if (layer.element.parentNode) {
              layer.element.parentNode.removeChild(layer.element);
            }
          });
          this.depthState.depthLayers.clear();
          if (this.depthState.backgroundContainer && this.depthState.backgroundContainer.parentNode) {
            this.depthState.backgroundContainer.parentNode.removeChild(
              this.depthState.backgroundContainer
            );
            this.depthState.backgroundContainer = null;
          }
          this.depthState.isInitialized = false;
          this.depthState.containerElement = null;
          Y3KDebug?.debug?.log(
            "DepthLayeredStrategy",
            "Depth layered strategy destroyed"
          );
        }
      };
      __name(_DepthLayeredStrategy, "DepthLayeredStrategy");
      DepthLayeredStrategy = _DepthLayeredStrategy;
    }
  });

  // src-js/visual/color/ThemeColorController.ts
  var _DynamicCatppuccinStrategy, DynamicCatppuccinStrategy;
  var init_ThemeColorController = __esm({
    "src-js/visual/color/ThemeColorController.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_UnifiedDebugManager();
      init_config();
      init_OKLABColorProcessor();
      init_PaletteSystemManager();
      init_ThemeUtilities();
      _DynamicCatppuccinStrategy = class _DynamicCatppuccinStrategy {
        constructor(cssController) {
          this.utils = ThemeUtilities_exports;
          this.config = ADVANCED_SYSTEM_CONFIG;
          this.dynamicColorState = this.getInitialColorState();
          this.integrationConfig = {
            accentUpdateEnabled: true,
            baseTransformationEnabled: true,
            visualEffectsIntegrationEnabled: true,
            oklabEnhancementEnabled: true,
            smoothTransitionDuration: 800,
            // 0.8s smooth transitions
            energyResponseMultiplier: 1.2,
            oklabPreset: "VIBRANT"
            // Use vibrant OKLAB enhancement
          };
          // Transition management
          this.transitionTimer = 0;
          this.lastTransitionStartTime = 0;
          this.transitionFromAccent = "";
          this.transitionToAccent = "";
          this.cssController = cssController || getGlobalOptimizedCSSController();
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.initializeCurrentState();
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            "Color strategy initialized with CSS coordinator and OKLAB processing"
          );
        }
        /**
         * Get initial color state using current palette system
         */
        getInitialColorState() {
          try {
            const defaultAccent = paletteSystemManager.getDefaultAccentColor();
            const baseColor = paletteSystemManager.getBrightnessAdjustedBaseColor();
            return {
              currentAccentHex: defaultAccent.hex,
              currentAccentRgb: defaultAccent.rgb,
              baseBackgroundHex: baseColor.hex,
              baseBackgroundRgb: baseColor.rgb,
              lastUpdateTime: 0,
              musicEnergy: 0.5,
              transitionInProgress: false
            };
          } catch (error) {
            console.warn("[DynamicCatppuccinStrategy] Failed to get initial colors, using fallback:", error);
            return {
              currentAccentHex: "#7c3aed",
              // Fallback cosmic purple
              currentAccentRgb: "124,58,237",
              baseBackgroundHex: "#0d1117",
              // Fallback deep space black
              baseBackgroundRgb: "13,17,23",
              lastUpdateTime: 0,
              musicEnergy: 0.5,
              transitionInProgress: false
            };
          }
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "dynamic-catppuccin";
        }
        /**
         * Check if strategy can handle the given context
         */
        canProcess(context) {
          return this.checkDynamicAccentEnabled();
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          return 5;
        }
        /**
         * Process colors using Dynamic Catppuccin strategy with OKLAB enhancement
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const newAccentHex = this.selectBestAccentColor(context.rawColors);
            if (!newAccentHex) {
              throw new Error("No suitable accent color found in extracted colors");
            }
            let processedAccentHex = newAccentHex;
            let processedAccentRgb = this.utils.hexToRgb(newAccentHex);
            let oklabResult = null;
            if (this.integrationConfig.oklabEnhancementEnabled) {
              const preset = OKLABColorProcessor.getPreset(
                this.integrationConfig.oklabPreset
              );
              oklabResult = this.oklabProcessor.processColor(newAccentHex, preset);
              processedAccentHex = oklabResult.enhancedHex;
              processedAccentRgb = oklabResult.enhancedRgb;
              Y3KDebug?.debug?.log(
                "DynamicCatppuccinStrategy",
                "OKLAB color enhancement applied:",
                {
                  original: newAccentHex,
                  enhanced: processedAccentHex,
                  preset: preset.name,
                  processingTime: `${oklabResult.processingTime.toFixed(2)}ms`
                }
              );
            }
            await this.applyColorFacade(
              processedAccentHex,
              context.rawColors,
              oklabResult
            );
            this.dynamicColorState.currentAccentHex = processedAccentHex;
            if (processedAccentRgb) {
              this.dynamicColorState.currentAccentRgb = `${processedAccentRgb.r},${processedAccentRgb.g},${processedAccentRgb.b}`;
            }
            this.dynamicColorState.lastUpdateTime = Date.now();
            if (context.musicData?.energy !== void 0) {
              this.dynamicColorState.musicEnergy = context.musicData.energy;
              await this.updateVisualEffectsWithMusicEnergy(context.musicData.energy);
            }
            const processingTime = performance.now() - startTime;
            const result = {
              processedColors: {
                accent: processedAccentHex,
                primary: processedAccentHex,
                originalAccent: newAccentHex,
                // Keep original for reference
                ...context.rawColors
              },
              accentHex: processedAccentHex,
              accentRgb: this.dynamicColorState.currentAccentRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `dynamic-catppuccin-${context.trackUri}`,
                harmonicIntensity: this.integrationConfig.energyResponseMultiplier,
                oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
                oklabPreset: this.integrationConfig.oklabPreset,
                ...oklabResult && {
                  oklabMetadata: {
                    originalHex: oklabResult.originalHex,
                    enhancedHex: oklabResult.enhancedHex,
                    shadowHex: oklabResult.shadowHex,
                    oklabProcessingTime: oklabResult.processingTime
                  }
                }
              },
              context
            };
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinStrategy",
              "Color processing completed",
              {
                originalAccent: newAccentHex,
                processedAccent: processedAccentHex,
                oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
                processingTime,
                trackUri: context.trackUri
              }
            );
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinStrategy",
              "Color processing failed:",
              error
            );
            return {
              processedColors: context.rawColors,
              accentHex: this.dynamicColorState.currentAccentHex,
              accentRgb: this.dynamicColorState.currentAccentRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error"
              },
              context
            };
          }
        }
        /**
         * Check if dynamic accent is enabled in settings
         */
        checkDynamicAccentEnabled() {
          try {
            const accentSetting = settings.get("catppuccin-accentColor");
            const isDynamic = String(accentSetting) === "dynamic";
            if (this.config.enableDebug) {
              Y3KDebug?.debug?.log(
                "DynamicCatppuccinStrategy",
                `Accent setting: ${accentSetting}, Dynamic: ${isDynamic}`
              );
            }
            return isDynamic;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinStrategy",
              "Error checking dynamic accent setting:",
              error
            );
            return false;
          }
        }
        /**
         * Initialize current state from existing CSS variables
         */
        initializeCurrentState() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentAccent = computedStyle.getPropertyValue("--spice-accent").trim() || computedStyle.getPropertyValue("--sn-color-accent-hex").trim();
          if (currentAccent) {
            this.dynamicColorState.currentAccentHex = currentAccent;
            const rgb = this.utils.hexToRgb(currentAccent);
            if (rgb) {
              this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
            }
          }
          const currentBase = computedStyle.getPropertyValue("--spice-base").trim() || "#1e1e2e";
          this.dynamicColorState.baseBackgroundHex = currentBase;
          const baseRgb = this.utils.hexToRgb(currentBase);
          if (baseRgb) {
            this.dynamicColorState.baseBackgroundRgb = `${baseRgb.r},${baseRgb.g},${baseRgb.b}`;
          }
          this.dynamicColorState.lastUpdateTime = Date.now();
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            "Current state initialized:",
            {
              accent: this.dynamicColorState.currentAccentHex,
              base: this.dynamicColorState.baseBackgroundHex
            }
          );
        }
        /**
         * Select best accent color from extracted colors
         */
        selectBestAccentColor(colors) {
          const priorities = [
            "VIBRANT_NON_ALARMING",
            // Best for UI - vibrant but not overwhelming
            "VIBRANT",
            // Strong and lively
            "LIGHT_VIBRANT",
            // Lighter variant
            "PROMINENT",
            // Most noticeable color
            "PRIMARY",
            // Primary extracted color
            "DARK_VIBRANT"
            // Darker variant as fallback
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Apply colors using Color Extension Facade pattern with coordinated updates
         * Updates both core Spicetify variables AND visual-effects extensions with OKLAB enhancement
         */
        async applyColorFacade(accentHex, rawColors, oklabResult) {
          const rgb = this.utils.hexToRgb(accentHex);
          if (!rgb) return;
          const rgbString = `${rgb.r},${rgb.g},${rgb.b}`;
          const variablesToUpdate = {
            // Dynamic color variables (highest priority) - updated by music systems
            "--sn-dynamic-accent-hex": accentHex,
            "--sn-dynamic-accent-rgb": rgbString,
            "--sn-dynamic-primary-hex": accentHex,
            "--sn-dynamic-primary-rgb": rgbString,
            // Core Spicetify variables for compatibility
            "--spice-accent": accentHex,
            "--spice-button": accentHex,
            "--spice-button-active": accentHex,
            "--spice-rgb-accent": rgbString,
            "--spice-rgb-button": rgbString,
            // Extracted color variables for ColorHarmonyEngine
            "--sn-color-extracted-primary-rgb": rgbString,
            "--sn-color-extracted-vibrant-rgb": rgbString,
            "--sn-color-extracted-dominant-rgb": rgbString
          };
          if (oklabResult && this.integrationConfig.oklabEnhancementEnabled) {
            const oklabCSSVars = this.oklabProcessor.generateCSSVariables(
              oklabResult,
              "sn-oklab-accent"
            );
            Object.assign(variablesToUpdate, {
              ...oklabCSSVars,
              // Enhanced shadow variables for depth effects
              "--sn-dynamic-shadow-hex": oklabResult.shadowHex,
              "--sn-dynamic-shadow-rgb": `${oklabResult.shadowRgb.r},${oklabResult.shadowRgb.g},${oklabResult.shadowRgb.b}`,
              // OKLCH variables for advanced CSS features
              "--sn-accent-oklch-l": oklabResult.oklchEnhanced.L.toFixed(3),
              "--sn-accent-oklch-c": oklabResult.oklchEnhanced.C.toFixed(3),
              "--sn-accent-oklch-h": oklabResult.oklchEnhanced.H.toFixed(1)
            });
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinStrategy",
              "Added OKLAB-enhanced CSS variables:",
              {
                oklabVarsCount: Object.keys(oklabCSSVars).length,
                enhancedHex: oklabResult.enhancedHex,
                shadowHex: oklabResult.shadowHex
              }
            );
          }
          if (this.cssController) {
            this.cssController.updateVariables(
              variablesToUpdate,
              "high",
              "core-spicetify-facade"
            );
          }
          const primaryColor = rawColors["PRIMARY"] || rawColors["VIBRANT"];
          if (primaryColor) {
            await this.updateLivingBaseBackground(primaryColor);
          }
          if (this.integrationConfig.visualEffectsIntegrationEnabled) {
            await this.updateVisualEffectsWithAccent(accentHex, rgbString);
          }
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            `Applied coordinated color facade - Spicetify: ${accentHex}, Visual-effects extensions updated`,
            {
              oklabProcessing: !!oklabResult,
              variableCount: Object.keys(variablesToUpdate).length
            }
          );
        }
        /**
         * Update living base background using coordinated variable updates
         * Preserves Spicetify base while adding visual-effects layers
         */
        async updateLivingBaseBackground(primaryHex) {
          const primaryRgb = this.utils.hexToRgb(primaryHex);
          if (!primaryRgb) return;
          const primaryRgbString = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          const visualEffectsGradient = `
      linear-gradient(135deg,
        var(--spice-base) 0%,
        rgba(${primaryRgbString}, 0.08) 30%,
        var(--spice-base) 70%
      ),
      var(--spice-base)
    `;
          const livingBaseVariables = {
            // Dynamic secondary colors
            "--sn-dynamic-secondary-hex": primaryHex,
            "--sn-dynamic-secondary-rgb": primaryRgbString,
            // Extracted color system for visual-effects
            "--sn-color-extracted-secondary-rgb": primaryRgbString,
            "--sn-color-harmony-complementary-rgb": primaryRgbString,
            // Living gradient enhancements
            "--living-base-gradient": visualEffectsGradient,
            "--visual-effects-base-gradient": visualEffectsGradient
          };
          if (this.cssController) {
            this.cssController.updateVariables(
              livingBaseVariables,
              "normal",
              "living-base-background"
            );
          }
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            `Coordinated living base facade updated - Primary: ${primaryHex}, preserving --spice-base`
          );
        }
        /**
         * Update visual-effects system with new accent awareness using coordinated updates
         */
        async updateVisualEffectsWithAccent(accentHex, accentRgb) {
          const visualEffectsVariables = {
            // Holographic visual-effects variables
            "--sn-holographic-rgb": accentRgb,
            "--holographic-scanline-rgb": accentRgb,
            // Depth visual-effects variables
            "--visual-effects-intensity": `calc(0.5 + var(--musical-sync-intensity) * ${this.integrationConfig.energyResponseMultiplier})`
          };
          if (this.cssController) {
            this.cssController.updateVariables(
              visualEffectsVariables,
              "normal",
              "visual-effects-accent-integration"
            );
          }
        }
        /**
         * Update visual-effects with music energy using coordinated updates
         */
        async updateVisualEffectsWithMusicEnergy(energy) {
          const adjustedEnergy = energy * this.integrationConfig.energyResponseMultiplier;
          const baseIntensity = 0.5;
          const visualEffectsIntensity = Math.max(
            0.1,
            Math.min(1, baseIntensity + adjustedEnergy * 0.3)
          );
          const musicEnergyVariables = {
            "--musical-sync-intensity": adjustedEnergy.toString(),
            "--holographic-music-flicker-intensity": adjustedEnergy.toString(),
            "--visual-effects-intensity": visualEffectsIntensity.toString()
          };
          if (this.cssController) {
            this.cssController.updateVariables(
              musicEnergyVariables,
              "high",
              "visual-effects-music-energy"
            );
            this.cssController.updateVisualEffectsIntensity(
              parseFloat(visualEffectsIntensity.toString()),
              "DynamicCatppuccinStrategy",
              adjustedEnergy
            );
          }
        }
        /**
         * Get current dynamic color state for debugging
         */
        getDynamicColorState() {
          return { ...this.dynamicColorState };
        }
        /**
         * Update integration configuration
         */
        updateConfig(newConfig) {
          this.integrationConfig = { ...this.integrationConfig, ...newConfig };
          if ("oklabEnhancementEnabled" in newConfig || "oklabPreset" in newConfig) {
            this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          }
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            "Configuration updated:",
            {
              ...newConfig,
              oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
              oklabPreset: this.integrationConfig.oklabPreset
            }
          );
        }
        /**
         * Health check for strategy status
         */
        async healthCheck() {
          const isDynamicEnabled = this.checkDynamicAccentEnabled();
          const hasRecentUpdate = Date.now() - this.dynamicColorState.lastUpdateTime < 3e4;
          return {
            healthy: isDynamicEnabled,
            canProcess: isDynamicEnabled,
            issues: !isDynamicEnabled ? ["Dynamic accent not enabled in settings"] : [],
            metrics: {
              dynamicAccentEnabled: isDynamicEnabled,
              currentAccent: this.dynamicColorState.currentAccentHex,
              lastUpdateAge: Date.now() - this.dynamicColorState.lastUpdateTime,
              hasRecentUpdate,
              transitionInProgress: this.dynamicColorState.transitionInProgress,
              musicEnergy: this.dynamicColorState.musicEnergy,
              oklabProcessing: this.integrationConfig.oklabEnhancementEnabled,
              oklabPreset: this.integrationConfig.oklabPreset,
              visualEffectsIntegration: this.integrationConfig.visualEffectsIntegrationEnabled
            }
          };
        }
        /**
         * Cleanup resources
         */
        destroy() {
          if (this.transitionTimer) {
            clearTimeout(this.transitionTimer);
            this.transitionTimer = 0;
          }
          this.dynamicColorState.transitionInProgress = false;
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinStrategy",
            "Dynamic Catppuccin strategy destroyed"
          );
        }
      };
      __name(_DynamicCatppuccinStrategy, "DynamicCatppuccinStrategy");
      DynamicCatppuccinStrategy = _DynamicCatppuccinStrategy;
    }
  });

  // src-js/visual/strategies/DynamicGradientStrategy.ts
  var DynamicGradientStrategy_exports = {};
  __export(DynamicGradientStrategy_exports, {
    DynamicGradientStrategy: () => DynamicGradientStrategy
  });
  var _DynamicGradientStrategy, DynamicGradientStrategy;
  var init_DynamicGradientStrategy = __esm({
    "src-js/visual/strategies/DynamicGradientStrategy.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_UnifiedEventBus();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_OKLABColorProcessor();
      init_ThemeUtilities();
      init_BaseVisualSystem();
      _DynamicGradientStrategy = class _DynamicGradientStrategy extends BaseVisualSystem {
        constructor(config = ADVANCED_SYSTEM_CONFIG, utils = ThemeUtilities_exports, performanceMonitor = null, musicSyncService = null, cssController, cssAnimationManager) {
          super(
            config,
            utils,
            performanceMonitor,
            musicSyncService,
            null
          );
          this.utils = ThemeUtilities_exports;
          this.config = ADVANCED_SYSTEM_CONFIG;
          this.livingBaseState = {
            currentBaseHex: "#1e1e2e",
            // Catppuccin base
            currentBaseRgb: "30,30,46",
            currentPrimaryHex: "var(--sn-brightness-adjusted-accent-hex, #cba6f7)",
            // Brightness-adjusted default
            currentPrimaryRgb: "var(--sn-brightness-adjusted-accent-rgb, 203, 166, 247)",
            // Brightness-adjusted default
            visualEffectsIntensity: 0.5,
            musicEnergy: 0.5,
            lastUpdateTime: 0,
            webglIntegrationActive: false,
            oklabGradientStops: []
          };
          this.gradientConfig = {
            baseTransformationEnabled: true,
            webglIntegrationEnabled: true,
            responsiveAnimationEnabled: true,
            visualEffectsLayerOpacity: 0.08,
            // Subtle but visible
            dynamicFlowIntensity: 1.2,
            musicResponsiveness: 1,
            oklabInterpolationEnabled: true,
            oklabPreset: "STANDARD",
            // Use standard OKLAB enhancement for gradients
            gradientSmoothness: 0.8,
            // High smoothness for natural transitions
            animationThrottleFps: 30,
            // 30fps for smooth animation while conserving performance
            enablePerformanceBudget: true,
            // Enable frame budget enforcement
            maxFrameTimeMs: 16
            // 16ms budget for 60fps main thread responsiveness
          };
          // CSS Animation Manager integration for Year 3000 performance revolution  
          this.cssAnimationManager = null;
          // Will be injected (EnhancedMasterAnimationCoordinator or interface)
          // OKLAB calculation caching
          this.oklabCache = /* @__PURE__ */ new Map();
          this.gradientCache = /* @__PURE__ */ new Map();
          this.cacheValidityMs = 5e3;
          // Cache valid for 5 seconds
          this.lastCacheCleanup = 0;
          /**
           * Debounced event handler to prevent excessive processing of high-frequency events
           */
          this.musicEventDebounceTimers = {
            musicState: 0,
            harmonizedColors: 0,
            webglState: 0,
            visualEffectsIntensity: 0
          };
          this.eventDebounceMs = 100;
          this.cssController = cssController || getGlobalOptimizedCSSController();
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.deviceDetector = new DeviceCapabilityDetector();
          this.cssAnimationManager = cssAnimationManager;
          this.initializeBaseState();
          this.applyDeviceAwareSettings().catch((error) => {
            Y3KDebug?.debug?.warn(
              "DynamicGradientStrategy",
              "Failed to apply device-aware settings:",
              error
            );
          });
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            "Living gradient strategy initialized with OKLAB interpolation and device-aware performance"
          );
        }
        /**
         * BaseVisualSystem lifecycle implementation
         */
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            this.setupConsciousnessListeners();
            this.setupWebGLIntegrationListeners();
            this.initializeBaseState();
            this.initializeConsciousnessBreathing();
            await this.applyLivingConsciousnessBase();
            Y3KDebug?.debug?.log(
              "DynamicGradientStrategy",
              "Living gradient system awakened with visual system lifecycle"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicGradientStrategy",
              "Failed to initialize living gradient system:",
              error
            );
          }
        }
        /**
         * Setup listeners for visualEffects and dynamic color changes
         * Phase 2: Migrated from DOM events to UnifiedEventBus for proper facade coordination
         */
        setupConsciousnessListeners() {
          if (typeof unifiedEventBus !== "undefined") {
            unifiedEventBus.subscribe(
              "colors:harmonized",
              (data) => {
                if (data && data.processedColors) {
                  this.handleHarmonizedColorUpdate(data.processedColors);
                }
              },
              "LivingGradientStrategy"
            );
          }
          document.addEventListener("music-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.handleMusicStateChange(customEvent.detail);
            }
          });
          document.addEventListener(
            "visualEffects-intensity-change",
            (event) => {
              const customEvent = event;
              if (customEvent.detail && typeof customEvent.detail.intensity === "number") {
                this.updateConsciousnessIntensity(customEvent.detail.intensity);
              }
            }
          );
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            "Consciousness listeners established"
          );
        }
        /**
         * Setup WebGL integration listeners
         */
        setupWebGLIntegrationListeners() {
          document.addEventListener("webgl-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.handleWebGLStateChange(customEvent.detail);
            }
          });
          document.addEventListener("webgl-gradient-update", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.coordinateWithWebGLGradient(customEvent.detail);
            }
          });
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            "WebGL integration listeners established"
          );
        }
        /**
         * Handle harmonized color updates from Dynamic Catppuccin Bridge
         */
        handleHarmonizedColorUpdate(harmonizedColors) {
          this.debouncedEventHandler("harmonizedColors", () => {
            const primaryColor = harmonizedColors.VIBRANT || harmonizedColors.PRIMARY || harmonizedColors.PROMINENT;
            if (primaryColor && primaryColor !== this.livingBaseState.currentPrimaryHex) {
              this.livingBaseState.currentPrimaryHex = primaryColor;
              const primaryRgb = this.utils.hexToRgb(primaryColor);
              if (primaryRgb) {
                this.livingBaseState.currentPrimaryRgb = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
              }
              this.updateLivingConsciousnessBase();
              this.triggerConsciousnessBreathing();
              Y3KDebug?.debug?.log(
                "DynamicGradientStrategy",
                "Living base updated with harmonized colors:",
                primaryColor
              );
            }
          });
        }
        /**
         * Handle music state changes for energy-responsive base
         */
        handleMusicStateChange(musicState) {
          this.debouncedEventHandler("musicState", () => {
            if (musicState.energy !== void 0) {
              this.livingBaseState.musicEnergy = musicState.energy;
              const baseIntensity = 0.5;
              const energyBoost = musicState.energy * this.gradientConfig.musicResponsiveness;
              this.livingBaseState.visualEffectsIntensity = Math.max(
                0.1,
                Math.min(1, baseIntensity + energyBoost * 0.3)
              );
              this.updateMusicResponsiveVariables();
            }
          });
        }
        /**
         * Handle WebGL system state changes
         */
        handleWebGLStateChange(webglState) {
          this.debouncedEventHandler("webglState", () => {
            if (webglState.enabled !== void 0) {
              this.livingBaseState.webglIntegrationActive = webglState.enabled;
              this.coordinateWithWebGLSystem(webglState.enabled);
              Y3KDebug?.debug?.log(
                "DynamicGradientStrategy",
                `WebGL integration ${webglState.enabled ? "activated" : "deactivated"}`
              );
            }
          });
        }
        /**
         * Update visualEffects intensity
         */
        updateConsciousnessIntensity(intensity) {
          this.debouncedEventHandler("visualEffectsIntensity", () => {
            this.livingBaseState.visualEffectsIntensity = Math.max(
              0,
              Math.min(1, intensity)
            );
            this.updateConsciousnessVariables();
          });
        }
        debouncedEventHandler(eventType, handler) {
          const now = performance.now();
          if (now - this.musicEventDebounceTimers[eventType] >= this.eventDebounceMs) {
            handler();
            this.musicEventDebounceTimers[eventType] = now;
          }
        }
        /**
         * Initialize CSS-first visualEffects animation (Year 3000 performance revolution)
         */
        initializeConsciousnessBreathing() {
          if (!this.gradientConfig.responsiveAnimationEnabled) return;
          if (!this.cssAnimationManager) {
            Y3KDebug?.debug?.warn(
              "DynamicGradientStrategy",
              "CSSAnimationManager not available, falling back to basic visualEffects"
            );
            return;
          }
          this.triggerConsciousnessBreathing();
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            "CSS-first visualEffects animation initialized"
          );
        }
        /**
         * Trigger visualEffects animation using CSSAnimationManager (Year 3000 CSS-first)
         */
        triggerConsciousnessBreathing() {
          if (!this.cssAnimationManager || !this.gradientConfig.responsiveAnimationEnabled) return;
          const visualEffectsElements = document.querySelectorAll(
            ".Root__main-view::before, .Root__main-view, [data-visualEffects-animation]"
          );
          if (visualEffectsElements.length === 0) {
            const mainView = document.querySelector(".Root__main-view") || document.body;
            if (mainView) {
              mainView.setAttribute("data-visualEffects-animation", "true");
              this.cssAnimationManager.triggerConsciousnessBreathing(
                [mainView],
                this.livingBaseState.musicEnergy,
                120
                // Default tempo
              );
            }
          } else {
            this.cssAnimationManager.triggerConsciousnessBreathing(
              visualEffectsElements,
              this.livingBaseState.musicEnergy,
              120
              // Will be updated by music events
            );
          }
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            `CSS-first visualEffects animation triggered for ${visualEffectsElements.length} elements`
          );
        }
        /**
         * Apply device-aware performance settings based on device capabilities
         */
        async applyDeviceAwareSettings() {
          if (!this.deviceDetector.isInitialized) {
            try {
              await this.deviceDetector.initialize();
            } catch (error) {
              Y3KDebug?.debug?.warn(
                "DynamicGradientStrategy",
                "Device detection failed, using default settings:",
                error
              );
              return;
            }
          }
          const capabilities = this.deviceDetector.getCapabilities();
          if (!capabilities) {
            Y3KDebug?.debug?.warn(
              "DynamicGradientStrategy",
              "No device capabilities available, using default settings"
            );
            return;
          }
          const overallTier = capabilities.overall;
          switch (overallTier) {
            case "high":
              this.gradientConfig.animationThrottleFps = 30;
              this.gradientConfig.maxFrameTimeMs = 16;
              this.gradientConfig.enablePerformanceBudget = true;
              break;
            case "medium":
              this.gradientConfig.animationThrottleFps = 20;
              this.gradientConfig.maxFrameTimeMs = 20;
              this.gradientConfig.enablePerformanceBudget = true;
              break;
            case "low":
              this.gradientConfig.animationThrottleFps = 15;
              this.gradientConfig.maxFrameTimeMs = 33;
              this.gradientConfig.enablePerformanceBudget = true;
              this.gradientConfig.visualEffectsLayerOpacity *= 0.7;
              this.gradientConfig.dynamicFlowIntensity *= 0.8;
              this.gradientConfig.oklabInterpolationEnabled = false;
              break;
            default:
              this.gradientConfig.animationThrottleFps = 20;
              this.gradientConfig.maxFrameTimeMs = 20;
              break;
          }
          if (!capabilities.gpu.supportsWebGL) {
            this.gradientConfig.webglIntegrationEnabled = false;
          }
          if (capabilities.memory.level === "low") {
            this.cacheValidityMs = 2e3;
          }
          if (capabilities.cpu.cores <= 2) {
            this.gradientConfig.animationThrottleFps = Math.min(
              this.gradientConfig.animationThrottleFps,
              15
            );
          }
          if (capabilities.display.reducedMotion) {
            this.gradientConfig.responsiveAnimationEnabled = false;
            Y3KDebug?.debug?.log(
              "DynamicGradientStrategy",
              "Breathing animation disabled due to reduced motion preference"
            );
          }
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            `Device-aware settings applied for ${overallTier}: ${this.gradientConfig.animationThrottleFps}fps, CSS-first animation coordination`
          );
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "living-gradient";
        }
        /**
         * Check if strategy can handle the given context
         */
        canProcess(context) {
          return this.gradientConfig.baseTransformationEnabled;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          return 8;
        }
        /**
         * Process colors using Living Gradient strategy with OKLAB interpolation
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const primaryColor = this.selectPrimaryColor(context.rawColors);
            const secondaryColor = this.selectSecondaryColor(context.rawColors);
            if (!primaryColor) {
              throw new Error("No suitable primary color found for living gradient");
            }
            let processedPrimary = primaryColor;
            let processedSecondary = secondaryColor;
            let oklabGradientStops = [];
            if (this.gradientConfig.oklabInterpolationEnabled && primaryColor) {
              const preset = OKLABColorProcessor.getPreset(
                this.gradientConfig.oklabPreset
              );
              const primaryResult = this.oklabProcessor.processColor(
                primaryColor,
                preset
              );
              processedPrimary = primaryResult.enhancedHex;
              if (secondaryColor) {
                const secondaryResult = this.oklabProcessor.processColor(
                  secondaryColor,
                  preset
                );
                processedSecondary = secondaryResult.enhancedHex;
                const stopCount = Math.ceil(5 * this.gradientConfig.gradientSmoothness) + 3;
                oklabGradientStops = this.oklabProcessor.generateOKLABGradient(
                  processedPrimary,
                  processedSecondary,
                  stopCount,
                  preset
                );
              } else {
                const baseColor = this.livingBaseState.currentBaseHex;
                oklabGradientStops = this.oklabProcessor.generateOKLABGradient(
                  processedPrimary,
                  baseColor,
                  5,
                  preset
                );
                processedSecondary = oklabGradientStops[oklabGradientStops.length - 1]?.enhancedHex || processedPrimary;
              }
              Y3KDebug?.debug?.log(
                "DynamicGradientStrategy",
                "OKLAB gradient processing applied:",
                {
                  originalPrimary: primaryColor,
                  processedPrimary,
                  originalSecondary: secondaryColor,
                  processedSecondary,
                  gradientStops: oklabGradientStops.length,
                  preset: preset.name
                }
              );
            }
            await this.updateDynamicGradientState(
              processedPrimary,
              processedSecondary,
              context,
              oklabGradientStops
            );
            await this.applyLivingConsciousnessBase();
            this.triggerConsciousnessBreathing();
            await this.updateWebGLIntegration();
            const processingTime = performance.now() - startTime;
            const result = {
              processedColors: {
                primary: processedPrimary,
                secondary: processedSecondary || processedPrimary,
                originalPrimary: primaryColor,
                // Keep original for reference
                ...secondaryColor && { originalSecondary: secondaryColor },
                livingBase: this.livingBaseState.currentBaseHex,
                ...context.rawColors
              },
              accentHex: processedPrimary,
              accentRgb: this.livingBaseState.currentPrimaryRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `living-gradient-${context.trackUri}`,
                harmonicIntensity: this.gradientConfig.dynamicFlowIntensity,
                oklabInterpolation: this.gradientConfig.oklabInterpolationEnabled,
                oklabPreset: this.gradientConfig.oklabPreset,
                gradientStopCount: oklabGradientStops.length,
                gradientSmoothness: this.gradientConfig.gradientSmoothness
              },
              context
            };
            Y3KDebug?.debug?.log(
              "DynamicGradientStrategy",
              "Living gradient processing completed",
              {
                originalPrimary: primaryColor,
                processedPrimary,
                originalSecondary: secondaryColor,
                processedSecondary,
                oklabProcessing: this.gradientConfig.oklabInterpolationEnabled,
                gradientStops: oklabGradientStops.length,
                processingTime,
                trackUri: context.trackUri
              }
            );
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3KDebug?.debug?.error(
              "DynamicGradientStrategy",
              "Living gradient processing failed:",
              error
            );
            return {
              processedColors: context.rawColors,
              accentHex: this.livingBaseState.currentPrimaryHex,
              accentRgb: this.livingBaseState.currentPrimaryRgb,
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error"
              },
              context
            };
          }
        }
        /**
         * Initialize base state from existing CSS variables
         */
        initializeBaseState() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentBase = computedStyle.getPropertyValue("--spice-base").trim() || "#1e1e2e";
          this.livingBaseState.currentBaseHex = currentBase;
          const baseRgb = this.utils.hexToRgb(currentBase);
          if (baseRgb) {
            this.livingBaseState.currentBaseRgb = `${baseRgb.r},${baseRgb.g},${baseRgb.b}`;
          }
          const currentPrimary = computedStyle.getPropertyValue("--sn-bg-gradient-primary-rgb").trim();
          if (currentPrimary) {
            const rgbValues = currentPrimary.split(",").map((v) => parseInt(v.trim()));
            if (rgbValues.length === 3) {
              this.livingBaseState.currentPrimaryRgb = currentPrimary;
              this.livingBaseState.currentPrimaryHex = this.utils.rgbToHex(
                rgbValues[0],
                rgbValues[1],
                rgbValues[2]
              );
            }
          }
          this.livingBaseState.lastUpdateTime = Date.now();
          Y3KDebug?.debug?.log("DynamicGradientStrategy", "Base state initialized:", {
            base: this.livingBaseState.currentBaseHex,
            primary: this.livingBaseState.currentPrimaryHex
          });
        }
        /**
         * Select primary color for living gradient
         */
        selectPrimaryColor(colors) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "PROMINENT",
            "VIBRANT_NON_ALARMING",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Select secondary color for gradient complexity
         */
        selectSecondaryColor(colors) {
          const priorities = [
            "SECONDARY",
            "DARK_VIBRANT",
            "DESATURATED",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Update living base state with new colors and context including OKLAB data
         */
        async updateDynamicGradientState(primaryColor, secondaryColor, context, oklabGradientStops = []) {
          const primaryRgb = this.utils.hexToRgb(primaryColor);
          if (!primaryRgb) return;
          this.livingBaseState.currentPrimaryHex = primaryColor;
          this.livingBaseState.currentPrimaryRgb = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          this.livingBaseState.oklabGradientStops = oklabGradientStops;
          if (context.musicData?.energy !== void 0) {
            this.livingBaseState.musicEnergy = context.musicData.energy;
            const baseIntensity = this.gradientConfig.visualEffectsLayerOpacity;
            const musicMultiplier = 1 + context.musicData.energy * this.gradientConfig.musicResponsiveness;
            this.livingBaseState.visualEffectsIntensity = Math.max(
              0.05,
              Math.min(1, baseIntensity * musicMultiplier)
            );
          }
          this.livingBaseState.lastUpdateTime = Date.now();
        }
        /**
         * Apply living visualEffects base gradient using coordinated updates
         */
        async applyLivingConsciousnessBase() {
          const visualEffectsGradient = this.createLivingGradient(
            this.livingBaseState.oklabGradientStops
          );
          const currentTime = performance.now();
          const animationPhase = currentTime / 4e3 * Math.PI * 2;
          const animationMultiplier = 1 + Math.sin(animationPhase) * 0.2;
          const finalOpacity = this.livingBaseState.visualEffectsIntensity * animationMultiplier;
          const flowX = Math.sin(animationPhase * 0.7) * this.gradientConfig.dynamicFlowIntensity;
          const flowY = Math.cos(animationPhase * 0.5) * this.gradientConfig.dynamicFlowIntensity;
          const baseDuration = 4e3;
          const energyMultiplier = 0.5 + this.livingBaseState.musicEnergy * 1.5;
          const animationDuration = baseDuration / energyMultiplier;
          const visualEffectsBaseVariables = {
            "--living-base-gradient": visualEffectsGradient,
            "--visualEffects-base-gradient": visualEffectsGradient,
            "--visualEffects-layer-opacity": finalOpacity.toString(),
            "--visualEffects-flow-x": `${flowX}%`,
            "--visualEffects-flow-y": `${flowY}%`,
            "--visualEffects-animation-duration": `${animationDuration}ms`
          };
          await this.cssController.batchSetVariables(
            "DynamicGradientStrategy",
            visualEffectsBaseVariables,
            "high",
            // High priority for visualEffects animations
            "living-visualEffects-base"
          );
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            "Applied coordinated living visualEffects base gradient"
          );
        }
        /**
         * Create cached gradient key for OKLAB gradient generation
         */
        createGradientCacheKey(primaryRgb, baseRgb, oklabGradientStops, animationPhase) {
          const stopKey = oklabGradientStops.map((stop, index) => `${stop.enhancedHex}-${index}`).join("|");
          return `${primaryRgb}-${baseRgb}-${stopKey}-${Math.floor(
            animationPhase * 10
          )}`;
        }
        /**
         * Clean up expired cache entries
         */
        cleanupCache() {
          const now = Date.now();
          if (now - this.lastCacheCleanup < 1e4) return;
          this.lastCacheCleanup = now;
          this.gradientCache.clear();
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log("DynamicGradientStrategy", "Cache cleanup completed");
          }
        }
        /**
         * Create living gradient based on current state with OKLAB enhancement and caching
         */
        createLivingGradient(oklabGradientStops = []) {
          const primaryRgb = this.livingBaseState.currentPrimaryRgb;
          const baseRgb = this.livingBaseState.currentBaseRgb;
          const currentTime = performance.now();
          const animationPhase = currentTime / 4e3 * Math.PI * 2;
          const cacheKey = this.createGradientCacheKey(
            primaryRgb,
            baseRgb,
            oklabGradientStops,
            animationPhase
          );
          const cachedGradient = this.gradientCache.get(cacheKey);
          if (cachedGradient) {
            this.cleanupCache();
            return cachedGradient;
          }
          const gradient = this.generateLivingGradient(
            primaryRgb,
            baseRgb,
            oklabGradientStops
          );
          this.gradientCache.set(cacheKey, gradient);
          return gradient;
        }
        /**
         * Generate the actual gradient (extracted for caching)
         */
        generateLivingGradient(primaryRgb, baseRgb, oklabGradientStops) {
          if (this.gradientConfig.oklabInterpolationEnabled && oklabGradientStops.length > 0) {
            const gradientStops = oklabGradientStops.map((stop, index) => {
              const percentage = index / (oklabGradientStops.length - 1) * 100;
              const rgb = `${stop.enhancedRgb.r},${stop.enhancedRgb.g},${stop.enhancedRgb.b}`;
              const opacity = 0.6 * (1 - index / oklabGradientStops.length) + 0.1;
              return `rgba(${rgb}, calc(var(--visualEffects-layer-opacity) * ${opacity})) ${percentage}%`;
            }).join(", ");
            return `
        radial-gradient(
          ellipse at calc(50% + var(--visualEffects-flow-x)) calc(50% + var(--visualEffects-flow-y)),
          ${gradientStops}
        ),
        linear-gradient(
          135deg,
          rgba(${oklabGradientStops[0]?.enhancedRgb.r || primaryRgb.split(",")[0]},${oklabGradientStops[0]?.enhancedRgb.g || primaryRgb.split(",")[1]},${oklabGradientStops[0]?.enhancedRgb.b || primaryRgb.split(",")[2]}, calc(var(--visualEffects-layer-opacity) * 0.4)) 0%,
          var(--spice-base) 50%,
          rgba(${oklabGradientStops[oklabGradientStops.length - 1]?.enhancedRgb.r || primaryRgb.split(",")[0]},${oklabGradientStops[oklabGradientStops.length - 1]?.enhancedRgb.g || primaryRgb.split(",")[1]},${oklabGradientStops[oklabGradientStops.length - 1]?.enhancedRgb.b || primaryRgb.split(",")[2]}, calc(var(--visualEffects-layer-opacity) * 0.2)) 100%
        ),
        var(--spice-base)
      `;
          }
          return `
      radial-gradient(
        ellipse at calc(50% + var(--visualEffects-flow-x)) calc(50% + var(--visualEffects-flow-y)),
        rgba(${primaryRgb}, calc(var(--visualEffects-layer-opacity) * 0.6)) 0%,
        rgba(${primaryRgb}, calc(var(--visualEffects-layer-opacity) * 0.3)) 30%,
        rgba(${baseRgb}, calc(var(--visualEffects-layer-opacity) * 0.1)) 60%,
        var(--spice-base) 100%
      ),
      linear-gradient(
        135deg,
        rgba(${primaryRgb}, calc(var(--visualEffects-layer-opacity) * 0.4)) 0%,
        var(--spice-base) 50%,
        rgba(${primaryRgb}, calc(var(--visualEffects-layer-opacity) * 0.2)) 100%
      ),
      var(--spice-base)
    `;
        }
        /**
         * Update animation animation (Year 3000 CSS-first approach)
         */
        updateBreathingAnimation() {
          this.triggerConsciousnessBreathing();
        }
        /**
         * Start animation animation (Year 3000 CSS-first approach)
         */
        startBreathingAnimation() {
          this.triggerConsciousnessBreathing();
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            "CSS-first visualEffects animation started - 90%+ JavaScript overhead eliminated"
          );
        }
        /**
         * Schedule debounced CSS updates (Year 3000 - No longer needed with CSS-first approach)
         */
        scheduleDebouncedCssUpdate() {
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            "Debounced CSS updates eliminated - using CSS-first animation"
          );
        }
        /**
         * Update WebGL integration variables using coordinated updates
         */
        async updateWebGLIntegration() {
          if (!this.gradientConfig.webglIntegrationEnabled) return;
          const webglIntegrationVariables = {
            "--sn-bg-gradient-primary-rgb": this.livingBaseState.currentPrimaryRgb,
            "--sn-webgl-living-gradient-sync": "1",
            "--sn-gradient-visualEffects-level": this.livingBaseState.visualEffectsIntensity.toString()
          };
          await this.cssController.batchSetVariables(
            "DynamicGradientStrategy",
            webglIntegrationVariables,
            "high",
            // High priority for WebGL coordination
            "webgl-living-gradient-integration"
          );
          this.livingBaseState.webglIntegrationActive = true;
          Y3KDebug?.debug?.log("DynamicGradientStrategy", "WebGL integration updated");
        }
        /**
         * Get current living base state for debugging
         */
        getDynamicGradientState() {
          return { ...this.livingBaseState };
        }
        /**
         * Update living visualEffects base when colors change
         */
        updateLivingConsciousnessBase() {
          this.applyLivingConsciousnessBase().catch((error) => {
            Y3KDebug?.debug?.error(
              "DynamicGradientStrategy",
              "Failed to update living visualEffects base:",
              error
            );
          });
          const updateEvent = new CustomEvent("living-base-update", {
            detail: {
              baseHex: this.livingBaseState.currentBaseHex,
              primaryHex: this.livingBaseState.currentPrimaryHex,
              visualEffectsIntensity: this.livingBaseState.visualEffectsIntensity,
              timestamp: Date.now()
            }
          });
          document.dispatchEvent(updateEvent);
        }
        /**
         * Update music-responsive variables
         */
        updateMusicResponsiveVariables() {
          const musicResponsiveVariables = {
            "--visualEffects-music-energy": this.livingBaseState.musicEnergy.toString(),
            "--visualEffects-music-intensity": this.livingBaseState.visualEffectsIntensity.toString()
          };
          try {
            this.cssController.batchSetVariables(
              "DynamicGradientStrategy",
              musicResponsiveVariables,
              3,
              // medium priority
              "music-responsive"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicGradientStrategy",
              "Failed to update music responsive variables:",
              error
            );
          }
        }
        /**
         * Update visualEffects variables
         */
        updateConsciousnessVariables() {
          const visualEffectsVariables = {
            "--visualEffects-intensity-global": this.livingBaseState.visualEffectsIntensity.toString(),
            "--visualEffects-layer-opacity": (this.gradientConfig.visualEffectsLayerOpacity * this.livingBaseState.visualEffectsIntensity).toString()
          };
          try {
            this.cssController.batchSetVariables(
              "DynamicGradientStrategy",
              visualEffectsVariables,
              3,
              // medium priority
              "visualEffects-vars"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicGradientStrategy",
              "Failed to update visualEffects variables:",
              error
            );
          }
        }
        /**
         * Coordinate with WebGL gradient system
         */
        coordinateWithWebGLSystem(webglEnabled) {
          const webglCoordinationVariables = webglEnabled ? {
            // Reduce CSS layer opacity to allow WebGL to dominate
            "--visualEffects-webgl-coordination": "0.7",
            "--visualEffects-css-fallback": "0.3"
          } : {
            // Full CSS visualEffects when WebGL is disabled
            "--visualEffects-webgl-coordination": "0",
            "--visualEffects-css-fallback": "1.0"
          };
          try {
            this.cssController.batchSetVariables(
              "DynamicGradientStrategy",
              webglCoordinationVariables,
              "high",
              "webgl-coordination"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicGradientStrategy",
              "Failed to coordinate with WebGL system:",
              error
            );
          }
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            `WebGL coordination ${webglEnabled ? "enabled" : "disabled"}`
          );
        }
        /**
         * Coordinate with WebGL gradient updates
         */
        coordinateWithWebGLGradient(webglData) {
          if (!this.gradientConfig.webglIntegrationEnabled) return;
          if (webglData.flowState) {
            this.updateFlowStateFromWebGL(webglData.flowState);
          }
          if (webglData.colorState) {
            this.updateColorStateFromWebGL(webglData.colorState);
          }
        }
        /**
         * Update flow state from WebGL system
         */
        updateFlowStateFromWebGL(flowState) {
          const flowVariables = {};
          if (flowState.flowX !== void 0) {
            flowVariables["--visualEffects-webgl-flow-x"] = `${flowState.flowX}%`;
          }
          if (flowState.flowY !== void 0) {
            flowVariables["--visualEffects-webgl-flow-y"] = `${flowState.flowY}%`;
          }
          if (flowState.flowScale !== void 0) {
            flowVariables["--visualEffects-webgl-scale"] = flowState.flowScale.toString();
          }
          if (Object.keys(flowVariables).length > 0) {
            try {
              this.cssController.batchSetVariables(
                "DynamicGradientStrategy",
                flowVariables,
                3,
                // medium priority
                "webgl-flow"
              );
            } catch (error) {
              Y3KDebug?.debug?.error(
                "DynamicGradientStrategy",
                "Failed to update WebGL flow state:",
                error
              );
            }
          }
        }
        /**
         * Update color state from WebGL system
         */
        updateColorStateFromWebGL(colorState) {
          if (colorState.primaryColor) {
            this.livingBaseState.currentPrimaryRgb = colorState.primaryColor;
            this.updateLivingConsciousnessBase();
          }
        }
        /**
         * Health check to include both strategy and visual system status
         */
        async healthCheck() {
          const strategyHealth = await this.getStrategyHealthCheck();
          return {
            healthy: strategyHealth.healthy && this.isActive,
            canProcess: strategyHealth.canProcess,
            issues: strategyHealth.issues || [],
            metrics: {
              ...strategyHealth.metrics,
              systemType: "consolidated-living-gradient",
              isVisualSystem: true,
              isColorProcessor: true,
              isActive: this.isActive,
              initialized: this.initialized
            }
          };
        }
        /**
         * Get strategy-specific health check data
         */
        async getStrategyHealthCheck() {
          const hasRecentUpdate = Date.now() - this.livingBaseState.lastUpdateTime < 3e4;
          return {
            healthy: this.gradientConfig.baseTransformationEnabled,
            canProcess: this.gradientConfig.baseTransformationEnabled,
            issues: !this.gradientConfig.baseTransformationEnabled ? ["Base transformation disabled in configuration"] : [],
            metrics: {
              baseTransformationEnabled: this.gradientConfig.baseTransformationEnabled,
              responsiveAnimationEnabled: this.gradientConfig.responsiveAnimationEnabled,
              webglIntegrationActive: this.livingBaseState.webglIntegrationActive,
              visualEffectsIntensity: this.livingBaseState.visualEffectsIntensity,
              musicEnergy: this.livingBaseState.musicEnergy,
              hasRecentUpdate,
              cssFirstBreathing: true,
              // CSS-first animation replaces JavaScript animation
              oklabInterpolation: this.gradientConfig.oklabInterpolationEnabled,
              oklabPreset: this.gradientConfig.oklabPreset,
              gradientSmoothness: this.gradientConfig.gradientSmoothness,
              oklabGradientStops: this.livingBaseState.oklabGradientStops.length
            }
          };
        }
        /**
         * Override destroy method to include both strategy and visual system cleanup
         */
        destroy() {
          if (this.cssAnimationManager) {
            this.cssAnimationManager.stopConsciousnessBreathing();
          }
          this.oklabCache.clear();
          this.gradientCache.clear();
          super.destroy();
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            "Consolidated living gradient system destroyed with complete cleanup"
          );
        }
        /**
         * Override BaseVisualSystem cleanup method
         */
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            "Living gradient system cleaned up"
          );
        }
        /**
         * Update configuration
         */
        updateConfig(newConfig) {
          this.gradientConfig = { ...this.gradientConfig, ...newConfig };
          if ("oklabInterpolationEnabled" in newConfig || "oklabPreset" in newConfig) {
            this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          }
          Y3KDebug?.debug?.log("DynamicGradientStrategy", "Configuration updated:", {
            ...newConfig,
            oklabInterpolation: this.gradientConfig.oklabInterpolationEnabled,
            oklabPreset: this.gradientConfig.oklabPreset,
            gradientSmoothness: this.gradientConfig.gradientSmoothness
          });
        }
        /**
         * Stop animation animation (Year 3000 CSS-first approach)
         */
        stopBreathingAnimation() {
          if (this.cssAnimationManager) {
            this.cssAnimationManager.stopConsciousnessBreathing();
          }
          Y3KDebug?.debug?.log(
            "DynamicGradientStrategy",
            "CSS-first visualEffects animation stopped"
          );
        }
      };
      __name(_DynamicGradientStrategy, "DynamicGradientStrategy");
      DynamicGradientStrategy = _DynamicGradientStrategy;
    }
  });

  // src-js/visual/strategies/WebGLGradientStrategy.ts
  var FLOW_GRADIENT_SHADER, _WebGLGradientStrategy, WebGLGradientStrategy;
  var init_WebGLGradientStrategy = __esm({
    "src-js/visual/strategies/WebGLGradientStrategy.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_config();
      init_OKLABColorProcessor();
      init_PaletteSystemManager();
      init_ThemeUtilities();
      init_ShaderLoader();
      FLOW_GRADIENT_SHADER = `#version 300 es
precision mediump float;

uniform float u_time;
uniform sampler2D u_gradientTex;
uniform vec2 u_resolution;
uniform float u_flowStrength;
uniform float u_noiseScale;

// Wave stack uniforms
uniform float u_waveY[2];
uniform float u_waveHeight[2];
uniform float u_waveOffset[2];
uniform float u_blurExp;
uniform float u_blurMax;

out vec4 fragColor;

// Simplex noise implementation
vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

  i = mod289(i);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// Octave noise for richer detail
float octaveNoise(vec2 uv, float octaves, float persistence, float scale) {
  float value = 0.0;
  float amplitude = 1.0;
  float frequency = scale;
  float maxValue = 0.0;

  for(float i = 0.0; i < octaves; i++) {
    value += snoise(uv * frequency) * amplitude;
    maxValue += amplitude;
    amplitude *= persistence;
    frequency *= 2.0;
  }

  return value / maxValue;
}

// Wave alpha calculation with smooth transitions
float wave_alpha(vec2 uv, int waveIndex) {
  float y = uv.y;
  float waveCenter = u_waveY[waveIndex];
  float waveHeight = u_waveHeight[waveIndex];

  float distance = abs(y - waveCenter);
  float alpha = 1.0 - smoothstep(0.0, waveHeight * 0.5, distance);

  return alpha;
}

// Dynamic blur calculation using power function
float calc_blur(vec2 uv) {
  vec2 center = vec2(0.5, 0.5);
  float distance = length(uv - center);

  float blur = pow(distance, u_blurExp);
  blur = clamp(blur, 0.0, u_blurMax);

  return blur;
}

// Background noise generator with time offset
float background_noise(vec2 uv, float timeOffset) {
  vec2 flowUV = uv;
  float adjustedTime = u_time + timeOffset;

  flowUV.x += adjustedTime * 0.02 * u_flowStrength;
  flowUV.y += sin(adjustedTime * 0.03 + uv.x * 3.14159) * 0.01 * u_flowStrength;

  float noise1 = octaveNoise(flowUV * u_noiseScale, 4.0, 0.5, 1.0);
  float noise2 = octaveNoise(flowUV * u_noiseScale * 2.0 + vec2(100.0), 3.0, 0.4, 1.0);

  return (noise1 + noise2 * 0.3) * 0.5 + 0.5;
}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;

  // Generate three distinct background noise fields with time offsets
  float noise1 = background_noise(uv, u_waveOffset[0]);
  float noise2 = background_noise(uv, u_waveOffset[1]);
  float noise3 = background_noise(uv, 0.0); // Base noise without offset

  // Calculate wave alphas for blending
  float alpha1 = wave_alpha(uv, 0);
  float alpha2 = wave_alpha(uv, 1);
  float alpha3 = 1.0 - alpha1 - alpha2; // Remaining area
  alpha3 = max(alpha3, 0.0); // Ensure non-negative

  // Normalize alphas to ensure they sum to 1.0
  float totalAlpha = alpha1 + alpha2 + alpha3;
  if (totalAlpha > 0.0) {
    alpha1 /= totalAlpha;
    alpha2 /= totalAlpha;
    alpha3 /= totalAlpha;
  }

  // Blend the three noise fields based on wave alphas
  float t = noise1 * alpha1 + noise2 * alpha2 + noise3 * alpha3;
  t = clamp(t, 0.0, 1.0);

  // Sample gradient texture
  vec4 color = texture(u_gradientTex, vec2(t, 0.5));

  // Apply dynamic blur based on position
  float blurAmount = calc_blur(uv);

  // Apply subtle vignette with blur modulation
  vec2 center = uv - 0.5;
  float vignette = 1.0 - dot(center, center) * (0.3 + blurAmount * 0.2);
  color.rgb *= vignette;

  // Apply blur effect to alpha channel for depth
  color.a *= (1.0 - blurAmount * 0.3);

  fragColor = color;
}`;
      _WebGLGradientStrategy = class _WebGLGradientStrategy {
        constructor(cssController) {
          this.utils = ThemeUtilities_exports;
          this.config = ADVANCED_SYSTEM_CONFIG;
          this.webglState = {
            canvas: null,
            wrapper: null,
            gl: null,
            shaderProgram: null,
            gradientTexture: null,
            vertexBuffer: null,
            vao: null,
            isWebGLAvailable: false,
            webglReady: false,
            animationId: null,
            startTime: 0,
            lastFrameTime: 0,
            lastUpdateTime: 0,
            // Initialize LERP smoothing properties (current = target initially)
            currentFlowStrength: 0.3,
            targetFlowStrength: 0.3,
            currentNoiseScale: 1,
            targetNoiseScale: 1,
            currentBlurExp: 1.2,
            targetBlurExp: 1.2,
            currentBlurMax: 0.5,
            targetBlurMax: 0.5,
            currentWaveY: [0.3, 0.7],
            targetWaveY: [0.3, 0.7],
            currentWaveHeight: [0.4, 0.3],
            targetWaveHeight: [0.4, 0.3],
            currentWaveOffset: [0.1, 0.6],
            targetWaveOffset: [0.1, 0.6]
          };
          this.uniforms = {
            u_time: null,
            u_gradientTex: null,
            u_resolution: null,
            u_flowStrength: null,
            u_noiseScale: null,
            u_waveY: null,
            u_waveHeight: null,
            u_waveOffset: null,
            u_blurExp: null,
            u_blurMax: null
          };
          this.flowSettings = {
            enabled: true,
            intensity: "balanced",
            flowStrength: 0.7,
            noiseScale: 1.2,
            waveY: [0.25, 0.75],
            waveHeight: [0.4, 0.3],
            waveOffset: [2.5, -1.8],
            blurExp: 1.2,
            blurMax: 0.6,
            frameThrottleInterval: 1e3 / 45,
            // 45 FPS target
            oklabProcessingEnabled: true,
            oklabPreset: "VIBRANT",
            // Use vibrant preset for WebGL gradients
            gradientTextureSize: 512
            // High precision for OKLAB gradients
          };
          this.prefersReducedMotion = false;
          /**
           * WebGL animation loop
           */
          this.animateWebGL = /* @__PURE__ */ __name(() => {
            if (!this.webglState.webglReady || !this.webglState.gl || !this.webglState.canvas)
              return;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.webglState.lastFrameTime;
            if (deltaTime < this.flowSettings.frameThrottleInterval) {
              this.webglState.animationId = requestAnimationFrame(this.animateWebGL);
              return;
            }
            this.webglState.lastFrameTime = currentTime;
            this.renderWebGLFrame(currentTime);
            this.webglState.animationId = requestAnimationFrame(this.animateWebGL);
          }, "animateWebGL");
          // LERP smoothing half-life values (in seconds) for WebGL uniform transitions
          this.lerpHalfLifeValues = {
            flowStrength: 0.25,
            // Fast flow response
            noiseScale: 0.3,
            // Moderate noise transitions
            blur: 0.2,
            // Quick blur transitions
            wave: 0.35
            // Gentle wave movements
          };
          /**
           * Resize WebGL canvas
           */
          this.resizeWebGLCanvas = /* @__PURE__ */ __name(() => {
            if (!this.webglState.canvas) return;
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            this.webglState.canvas.width = displayWidth * dpr;
            this.webglState.canvas.height = displayHeight * dpr;
            this.webglState.canvas.style.width = displayWidth + "px";
            this.webglState.canvas.style.height = displayHeight + "px";
          }, "resizeWebGLCanvas");
          this.deviceDetector = new DeviceCapabilityDetector();
          this.cssController = cssController || getGlobalOptimizedCSSController();
          this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          this.cssController = getGlobalOptimizedCSSController();
          this.prefersReducedMotion = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;
          this.webglState.isWebGLAvailable = this.checkWebGL2Support();
          this.loadFlowSettings();
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u{1F30A} WebGL gradient strategy initialized - Flow Gradient Recovery Debug",
            {
              webglAvailable: this.webglState.isWebGLAvailable,
              deviceCapability: this.deviceDetector.recommendPerformanceQuality(),
              oklabProcessing: this.flowSettings.oklabProcessingEnabled,
              flowSettings: {
                enabled: this.flowSettings.enabled,
                intensity: this.flowSettings.intensity,
                flowStrength: this.flowSettings.flowStrength,
                noiseScale: this.flowSettings.noiseScale
              },
              prefersReducedMotion: this.prefersReducedMotion,
              webgl2ContextTest: this.checkWebGL2Support()
            }
          );
        }
        /**
         * IColorProcessor interface implementation
         */
        getStrategyName() {
          return "webgl-gradient";
        }
        /**
         * Check if strategy can handle the given context
         * Updated to respect force WebGL settings and remove hard-coded device restrictions
         */
        canProcess(context) {
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u{1F50D} canProcess() - WebGL Gradient Capability Check",
            {
              isWebGLAvailable: this.webglState.isWebGLAvailable,
              flowSettingsEnabled: this.flowSettings.enabled,
              webglReady: this.webglState.webglReady,
              contextTrackUri: context.trackUri,
              contextColorCount: Object.keys(context.rawColors).length
            }
          );
          if (!this.webglState.isWebGLAvailable) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientStrategy",
              "\u274C canProcess: WebGL not available - failed WebGL2 context check"
            );
            return false;
          }
          if (!this.flowSettings.enabled) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientStrategy",
              "\u274C canProcess: WebGL strategy disabled in settings"
            );
            return false;
          }
          const webglEnabled = settings.get("sn-webgl-enabled");
          if (webglEnabled) {
            Y3KDebug?.debug?.log(
              "WebGLGradientStrategy",
              "canProcess: WebGL force enabled - bypassing device restrictions"
            );
            return true;
          }
          const performanceLevel = this.deviceDetector.recommendPerformanceQuality();
          if (performanceLevel === "low") {
            Y3KDebug?.debug?.log(
              "WebGLGradientStrategy",
              `canProcess: Low performance device detected, allowing based on strategy selection (not force mode)`
            );
            return true;
          }
          return true;
        }
        /**
         * Get estimated processing time for performance planning
         */
        getEstimatedProcessingTime(context) {
          const baseTime = 12;
          const shaderComplexity = this.flowSettings.intensity === "intense" ? 1.3 : 1;
          return Math.round(baseTime * shaderComplexity);
        }
        /**
         * Process colors using WebGL Gradient strategy with OKLAB enhancement
         */
        async processColors(context) {
          const startTime = performance.now();
          let oklabResults = {};
          try {
            if (!this.webglState.webglReady) {
              await this.initializeWebGLGradient();
            }
            let processedColors = context.rawColors;
            if (this.flowSettings.oklabProcessingEnabled) {
              const preset = OKLABColorProcessor.getPreset(
                this.flowSettings.oklabPreset
              );
              oklabResults = this.oklabProcessor.processColorPalette(
                context.rawColors,
                preset
              );
              processedColors = Object.fromEntries(
                Object.entries(oklabResults).map(([key, result2]) => [
                  key,
                  result2.enhancedHex
                ])
              );
              Y3KDebug?.debug?.log(
                "WebGLGradientStrategy",
                "OKLAB color enhancement applied:",
                {
                  originalColors: Object.keys(context.rawColors).length,
                  processedColors: Object.keys(processedColors).length,
                  preset: preset.name
                }
              );
            }
            const gradientStops = this.createGradientStops(
              processedColors,
              oklabResults
            );
            await this.updateGradientTexture(gradientStops);
            await this.enableHybridCoordination();
            if (!this.webglState.animationId) {
              this.startWebGLAnimation();
            }
            if (context.musicData?.energy !== void 0) {
              await this.updateFlowWithMusicEnergy(context.musicData.energy);
            }
            this.webglState.lastUpdateTime = Date.now();
            const processingTime = performance.now() - startTime;
            const primaryColor = this.selectPrimaryColor(processedColors) || paletteSystemManager.getDefaultAccentColor().hex;
            const result = {
              processedColors: {
                webgl: "active",
                gradientStops: gradientStops.length.toString(),
                ...processedColors,
                ...Object.keys(context.rawColors).length > 0 && {
                  originalColors: JSON.stringify(context.rawColors)
                }
              },
              accentHex: primaryColor,
              accentRgb: this.convertToRgbString(primaryColor),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime,
                cacheKey: `webgl-gradient-${context.trackUri}`,
                harmonicIntensity: this.flowSettings.flowStrength,
                webglReady: this.webglState.webglReady,
                oklabProcessing: this.flowSettings.oklabProcessingEnabled,
                oklabPreset: this.flowSettings.oklabPreset,
                gradientTextureSize: this.flowSettings.gradientTextureSize,
                oklabResultsCount: Object.keys(oklabResults).length
              },
              context
            };
            Y3KDebug?.debug?.log(
              "WebGLGradientStrategy",
              "WebGL gradient processing completed",
              {
                gradientStops: gradientStops.length,
                processingTime,
                trackUri: context.trackUri
              }
            );
            return result;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            Y3KDebug?.debug?.error(
              "WebGLGradientStrategy",
              "WebGL gradient processing failed:",
              error
            );
            const fallbackResult = await this.executeProgressiveFallback(context, error);
            return {
              ...fallbackResult,
              metadata: {
                ...fallbackResult.metadata,
                strategy: this.getStrategyName(),
                processingTime,
                error: error instanceof Error ? error.message : "Unknown error"
              },
              context
            };
          }
        }
        /**
         * Check WebGL2 support
         */
        checkWebGL2Support() {
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2");
          return gl !== null;
        }
        /**
         * Load flow settings from settings manager
         */
        loadFlowSettings() {
          try {
            const intensitySetting = settings.get(
              "sn-gradient-intensity"
            );
            if (intensitySetting === "disabled") {
              this.flowSettings.enabled = false;
              return;
            }
            this.flowSettings.intensity = intensitySetting || "balanced";
            switch (this.flowSettings.intensity) {
              case "minimal":
                this.flowSettings.flowStrength = 0.4;
                this.flowSettings.noiseScale = 0.8;
                this.flowSettings.waveHeight = [0.3, 0.2];
                this.flowSettings.waveOffset = [1.5, -1];
                this.flowSettings.blurExp = 1;
                this.flowSettings.blurMax = 0.4;
                break;
              case "balanced":
                this.flowSettings.flowStrength = 0.7;
                this.flowSettings.noiseScale = 1.2;
                this.flowSettings.waveHeight = [0.4, 0.3];
                this.flowSettings.waveOffset = [2.5, -1.8];
                this.flowSettings.blurExp = 1.2;
                this.flowSettings.blurMax = 0.6;
                break;
              case "intense":
                this.flowSettings.flowStrength = 1;
                this.flowSettings.noiseScale = 1.6;
                this.flowSettings.waveHeight = [0.5, 0.4];
                this.flowSettings.waveOffset = [3.5, -2.5];
                this.flowSettings.blurExp = 1.4;
                this.flowSettings.blurMax = 0.8;
                break;
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientStrategy",
              "Failed to load settings, using defaults:",
              error
            );
          }
        }
        /**
         * Initialize WebGL gradient system
         */
        async initializeWebGLGradient() {
          if (!this.webglState.isWebGLAvailable) {
            throw new Error("WebGL2 not available");
          }
          await this.createWebGLCanvas();
          await this.initializeWebGLContext();
          await this.compileWebGLShaders();
          this.createWebGLGeometry();
          this.setupWebGLUniforms();
          this.resizeWebGLCanvas();
          this.attachWebGLToDom();
          window.addEventListener("resize", this.resizeWebGLCanvas.bind(this));
          this.webglState.webglReady = true;
          try {
            const cssController = getGlobalOptimizedCSSController();
            cssController.setPerformanceTokens({
              webglReady: true,
              activeBackend: "webgl-strategy",
              qualityLevel: "high",
              gpuAcceleration: true
            });
            Y3KDebug?.debug?.log(
              "WebGLGradientStrategy",
              "\u{1F3A8} WebGL readiness announced to CSS visual effects system - CSS Variables Set",
              {
                webglReady: true,
                activeBackend: "webgl-strategy",
                qualityLevel: "high",
                gpuAcceleration: true,
                cssControllerReady: !!cssController
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "WebGLGradientStrategy",
              "\u274C Failed to announce WebGL readiness - CSS Variables NOT Set:",
              error
            );
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "WebGL gradient system initialized successfully"
          );
        }
        /**
         * Create WebGL canvas and wrapper
         */
        async createWebGLCanvas() {
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u{1F3A8} Creating WebGL canvas and wrapper elements"
          );
          this.webglState.wrapper = document.createElement("div");
          this.webglState.wrapper.className = "sn-webgl-gradient-wrapper";
          this.webglState.wrapper.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -11;
      pointer-events: none;
      overflow: hidden;
    `;
          this.webglState.canvas = document.createElement("canvas");
          this.webglState.canvas.id = "sn-webgl-gradient-strategy";
          this.webglState.canvas.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    `;
          this.webglState.wrapper.appendChild(this.webglState.canvas);
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u2705 WebGL canvas and wrapper created successfully",
            {
              wrapperId: this.webglState.wrapper.className,
              canvasId: this.webglState.canvas.id,
              wrapperStyle: this.webglState.wrapper.style.cssText.replace(/\s+/g, " ").trim()
            }
          );
        }
        /**
         * Initialize WebGL context
         */
        async initializeWebGLContext() {
          if (!this.webglState.canvas) {
            throw new Error("Canvas not created");
          }
          this.webglState.gl = this.webglState.canvas.getContext("webgl2", {
            alpha: true,
            antialias: false,
            depth: false,
            stencil: false,
            powerPreference: "default"
          });
          if (!this.webglState.gl) {
            throw new Error("Failed to get WebGL2 context");
          }
        }
        /**
         * Compile WebGL shaders
         */
        async compileWebGLShaders() {
          if (!this.webglState.gl) {
            throw new Error("WebGL context not available");
          }
          const vertexShader = ShaderLoader.loadVertex(
            this.webglState.gl,
            DEFAULT_VERTEX_SHADER
          );
          const fragmentShader = ShaderLoader.loadFragment(
            this.webglState.gl,
            FLOW_GRADIENT_SHADER
          );
          if (!vertexShader || !fragmentShader) {
            throw new Error("Failed to compile shaders");
          }
          this.webglState.shaderProgram = ShaderLoader.createProgram(
            this.webglState.gl,
            vertexShader,
            fragmentShader
          );
          if (!this.webglState.shaderProgram) {
            throw new Error("Failed to create shader program");
          }
        }
        /**
         * Create WebGL geometry
         */
        createWebGLGeometry() {
          if (!this.webglState.gl || !this.webglState.shaderProgram) return;
          const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
          this.webglState.vertexBuffer = this.webglState.gl.createBuffer();
          this.webglState.gl.bindBuffer(
            this.webglState.gl.ARRAY_BUFFER,
            this.webglState.vertexBuffer
          );
          this.webglState.gl.bufferData(
            this.webglState.gl.ARRAY_BUFFER,
            vertices,
            this.webglState.gl.STATIC_DRAW
          );
          this.webglState.vao = this.webglState.gl.createVertexArray();
          this.webglState.gl.bindVertexArray(this.webglState.vao);
          const positionLocation = this.webglState.gl.getAttribLocation(
            this.webglState.shaderProgram,
            "a_position"
          );
          this.webglState.gl.enableVertexAttribArray(positionLocation);
          this.webglState.gl.vertexAttribPointer(
            positionLocation,
            2,
            this.webglState.gl.FLOAT,
            false,
            0,
            0
          );
          this.webglState.gl.bindVertexArray(null);
        }
        /**
         * Setup WebGL uniforms
         */
        setupWebGLUniforms() {
          if (!this.webglState.gl || !this.webglState.shaderProgram) return;
          this.uniforms.u_time = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_time"
          );
          this.uniforms.u_gradientTex = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_gradientTex"
          );
          this.uniforms.u_resolution = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_resolution"
          );
          this.uniforms.u_flowStrength = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_flowStrength"
          );
          this.uniforms.u_noiseScale = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_noiseScale"
          );
          this.uniforms.u_waveY = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_waveY"
          );
          this.uniforms.u_waveHeight = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_waveHeight"
          );
          this.uniforms.u_waveOffset = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_waveOffset"
          );
          this.uniforms.u_blurExp = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_blurExp"
          );
          this.uniforms.u_blurMax = this.webglState.gl.getUniformLocation(
            this.webglState.shaderProgram,
            "u_blurMax"
          );
        }
        /**
         * Create gradient stops from extracted colors with OKLAB enhancement
         */
        createGradientStops(colors, oklabResults = {}) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "VIBRANT_NON_ALARMING",
            "LIGHT_VIBRANT",
            "DARK_VIBRANT",
            "PROMINENT"
          ];
          const stops = [];
          const usedColors = /* @__PURE__ */ new Set();
          let position = 0;
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && !usedColors.has(color3)) {
              const oklabResult = oklabResults[key];
              const finalColor = oklabResult ? oklabResult.enhancedHex : color3;
              const rgb = this.utils.hexToRgb(finalColor);
              if (rgb) {
                stops.push({
                  r: rgb.r / 255,
                  g: rgb.g / 255,
                  b: rgb.b / 255,
                  a: 1,
                  position: position / (Math.min(priorities.length, 4) - 1),
                  // Include OKLAB metadata for debugging
                  ...oklabResult && {
                    oklabOriginal: oklabResult.originalHex,
                    oklabEnhanced: oklabResult.enhancedHex
                  }
                });
                usedColors.add(color3);
                position++;
                if (stops.length >= 4) break;
              }
            }
          }
          if (stops.length === 0) {
            return this.getDefaultGradientStops();
          }
          return stops;
        }
        /**
         * Get default gradient stops
         */
        getDefaultGradientStops() {
          return [
            { r: 0.196, g: 0.165, b: 0.282, a: 1, position: 0 },
            // Base
            { r: 0.549, g: 0.408, b: 0.878, a: 1, position: 0.3 },
            // Mauve
            { r: 0.788, g: 0.557, b: 0.902, a: 1, position: 0.6 },
            // Pink
            { r: 0.957, g: 0.761, b: 0.494, a: 1, position: 1 }
            // Peach
          ];
        }
        /**
         * Update gradient texture with new color stops
         */
        async updateGradientTexture(colorStops) {
          if (!this.webglState.gl) return;
          if (this.webglState.gradientTexture) {
            this.webglState.gl.deleteTexture(this.webglState.gradientTexture);
          }
          this.webglState.gradientTexture = createGradientTexture(
            this.webglState.gl,
            colorStops
          );
          if (!this.webglState.gradientTexture) {
            throw new Error("Failed to create gradient texture");
          }
          await this.updateCSSFallbackVariables(colorStops);
        }
        /**
         * Update CSS fallback variables for hybrid coordination using coordinated updates
         */
        async updateCSSFallbackVariables(colorStops) {
          const maxStops = Math.min(8, colorStops.length);
          const gradientStopVariables = {
            "--sn-grad-stop-count": String(maxStops)
          };
          for (let i = 0; i < maxStops; i++) {
            const c = colorStops[i];
            if (c) {
              gradientStopVariables[`--sn-grad-stop-${i}-rgb`] = `${Math.round(
                c.r * 255
              )},${Math.round(c.g * 255)},${Math.round(c.b * 255)}`;
            }
          }
          await this.cssController.batchSetVariables(
            "WebGLGradientStrategy",
            gradientStopVariables,
            "normal",
            // Normal priority for gradient configuration
            "gradient-stops-configuration"
          );
        }
        /**
         * Enable hybrid coordination between WebGL and CSS using coordinated updates
         */
        async enableHybridCoordination() {
          const hybridCoordinationVariables = {
            "--sn-webgl-ready": "1",
            "--sn-webgl-enabled": "1",
            "--sn-current-backend": "hybrid",
            "--sn-gradient-crossfade-opacity": "0.5"
            // 50% blend
          };
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u{1F517} Setting hybrid coordination CSS variables - WebGL Gradient Activation",
            {
              variables: hybridCoordinationVariables,
              cssControllerReady: !!this.cssController
            }
          );
          await this.cssController.batchSetVariables(
            "WebGLGradientStrategy",
            hybridCoordinationVariables,
            "high",
            // High priority for WebGL coordination
            "hybrid-coordination-enable"
          );
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u2705 Hybrid coordination CSS variables set successfully"
          );
        }
        /**
         * Start WebGL animation loop
         */
        startWebGLAnimation() {
          this.webglState.startTime = performance.now();
          this.webglState.lastFrameTime = this.webglState.startTime;
          this.animateWebGL();
        }
        /**
         * Update WebGL uniform values with LERP smoothing for framerate-independent transitions
         */
        updateUniformsWithLERP(deltaTimeSeconds) {
          this.webglState.targetFlowStrength = this.flowSettings.flowStrength;
          this.webglState.targetNoiseScale = this.flowSettings.noiseScale;
          this.webglState.targetBlurExp = this.flowSettings.blurExp;
          this.webglState.targetBlurMax = this.flowSettings.blurMax;
          this.webglState.targetWaveY = [
            this.flowSettings.waveY[0],
            this.flowSettings.waveY[1]
          ];
          this.webglState.targetWaveHeight = [
            this.flowSettings.waveHeight[0],
            this.flowSettings.waveHeight[1]
          ];
          this.webglState.targetWaveOffset = [
            this.flowSettings.waveOffset[0],
            this.flowSettings.waveOffset[1]
          ];
          this.webglState.currentFlowStrength = lerpSmooth(
            this.webglState.currentFlowStrength,
            this.webglState.targetFlowStrength,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.flowStrength
          );
          this.webglState.currentNoiseScale = lerpSmooth(
            this.webglState.currentNoiseScale,
            this.webglState.targetNoiseScale,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.noiseScale
          );
          this.webglState.currentBlurExp = lerpSmooth(
            this.webglState.currentBlurExp,
            this.webglState.targetBlurExp,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.blur
          );
          this.webglState.currentBlurMax = lerpSmooth(
            this.webglState.currentBlurMax,
            this.webglState.targetBlurMax,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.blur
          );
          const waveIndex0 = 0;
          const waveIndex1 = 1;
          this.webglState.currentWaveY[waveIndex0] = lerpSmooth(
            this.webglState.currentWaveY[waveIndex0],
            this.webglState.targetWaveY[waveIndex0],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveY[waveIndex1] = lerpSmooth(
            this.webglState.currentWaveY[waveIndex1],
            this.webglState.targetWaveY[waveIndex1],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveHeight[waveIndex0] = lerpSmooth(
            this.webglState.currentWaveHeight[waveIndex0],
            this.webglState.targetWaveHeight[waveIndex0],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveHeight[waveIndex1] = lerpSmooth(
            this.webglState.currentWaveHeight[waveIndex1],
            this.webglState.targetWaveHeight[waveIndex1],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveOffset[waveIndex0] = lerpSmooth(
            this.webglState.currentWaveOffset[waveIndex0],
            this.webglState.targetWaveOffset[waveIndex0],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
          this.webglState.currentWaveOffset[waveIndex1] = lerpSmooth(
            this.webglState.currentWaveOffset[waveIndex1],
            this.webglState.targetWaveOffset[waveIndex1],
            deltaTimeSeconds,
            this.lerpHalfLifeValues.wave
          );
        }
        /**
         * Render WebGL frame
         */
        renderWebGLFrame(currentTime) {
          if (!this.webglState.gl || !this.webglState.shaderProgram || !this.webglState.vao || !this.webglState.gradientTexture) {
            return;
          }
          const deltaTimeSeconds = (currentTime - this.webglState.lastFrameTime) / 1e3;
          this.updateUniformsWithLERP(deltaTimeSeconds);
          this.webglState.gl.viewport(
            0,
            0,
            this.webglState.canvas.width,
            this.webglState.canvas.height
          );
          this.webglState.gl.clearColor(0, 0, 0, 0);
          this.webglState.gl.clear(this.webglState.gl.COLOR_BUFFER_BIT);
          this.webglState.gl.useProgram(this.webglState.shaderProgram);
          this.webglState.gl.bindVertexArray(this.webglState.vao);
          const time = this.prefersReducedMotion ? 0 : (currentTime - this.webglState.startTime) / 1e3;
          if (this.uniforms.u_time) {
            this.webglState.gl.uniform1f(this.uniforms.u_time, time);
          }
          if (this.uniforms.u_resolution) {
            this.webglState.gl.uniform2f(
              this.uniforms.u_resolution,
              this.webglState.canvas.width,
              this.webglState.canvas.height
            );
          }
          if (this.uniforms.u_flowStrength) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_flowStrength,
              this.webglState.currentFlowStrength
              // Use smoothed value
            );
          }
          if (this.uniforms.u_noiseScale) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_noiseScale,
              this.webglState.currentNoiseScale
              // Use smoothed value
            );
          }
          if (this.uniforms.u_waveY) {
            this.webglState.gl.uniform1fv(
              this.uniforms.u_waveY,
              this.webglState.currentWaveY
              // Use smoothed values
            );
          }
          if (this.uniforms.u_waveHeight) {
            this.webglState.gl.uniform1fv(
              this.uniforms.u_waveHeight,
              this.webglState.currentWaveHeight
              // Use smoothed values
            );
          }
          if (this.uniforms.u_waveOffset) {
            this.webglState.gl.uniform1fv(
              this.uniforms.u_waveOffset,
              this.webglState.currentWaveOffset
              // Use smoothed values
            );
          }
          if (this.uniforms.u_blurExp) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_blurExp,
              this.webglState.currentBlurExp
              // Use smoothed value
            );
          }
          if (this.uniforms.u_blurMax) {
            this.webglState.gl.uniform1f(
              this.uniforms.u_blurMax,
              this.webglState.currentBlurMax
              // Use smoothed value
            );
          }
          this.webglState.gl.activeTexture(this.webglState.gl.TEXTURE0);
          this.webglState.gl.bindTexture(
            this.webglState.gl.TEXTURE_2D,
            this.webglState.gradientTexture
          );
          if (this.uniforms.u_gradientTex) {
            this.webglState.gl.uniform1i(this.uniforms.u_gradientTex, 0);
          }
          this.webglState.gl.drawArrays(this.webglState.gl.TRIANGLES, 0, 3);
          this.webglState.gl.bindVertexArray(null);
        }
        /**
         * Update flow with music energy using coordinated updates
         */
        async updateFlowWithMusicEnergy(energy) {
          const baseStrength = this.flowSettings.flowStrength;
          const energyMultiplier = 1 + energy * 0.5;
          const adjustedStrength = baseStrength * energyMultiplier;
          await this.cssController.setVariable(
            "WebGLGradientStrategy",
            "--sn-flow-strength",
            adjustedStrength.toString(),
            "high",
            // High priority for real-time music responsiveness
            "music-energy-flow-strength"
          );
        }
        /**
         * Attach WebGL canvas to DOM
         */
        attachWebGLToDom() {
          if (!this.webglState.wrapper) {
            Y3KDebug?.debug?.error(
              "WebGLGradientStrategy",
              "\u274C Cannot attach to DOM - wrapper element not created"
            );
            return;
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u{1F517} Attaching WebGL canvas to DOM - Searching for container"
          );
          const containers = [
            ".Root__main-view",
            ".main-view-container",
            ".main-gridContainer-gridContainer",
            ".Root__top-container",
            "body"
          ];
          let targetContainer = null;
          const containerResults = [];
          for (const selector of containers) {
            targetContainer = document.querySelector(selector);
            containerResults.push({ selector, found: !!targetContainer });
            if (targetContainer) break;
          }
          if (!targetContainer) {
            targetContainer = document.body;
          }
          targetContainer.appendChild(this.webglState.wrapper);
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "\u2705 WebGL canvas attached to DOM successfully",
            {
              containerSearch: containerResults,
              selectedContainer: targetContainer?.tagName || "unknown",
              containerClass: targetContainer?.className || "none",
              wrapperId: this.webglState.wrapper.className,
              canvasId: this.webglState.canvas?.id || "not-created"
            }
          );
        }
        /**
         * Execute progressive fallback chain: WebGL → CSS Gradients → Solid Color
         */
        async executeProgressiveFallback(context, originalError) {
          const primaryColor = this.selectPrimaryColor(context.rawColors) || paletteSystemManager.getDefaultAccentColor().hex;
          try {
            Y3KDebug?.debug?.warn(
              "WebGLGradientStrategy",
              "Attempting CSS gradient fallback"
            );
            await this.fallbackToCSSGradient();
            return {
              processedColors: {
                ...context.rawColors,
                fallbackMethod: "css-gradient"
              },
              accentHex: primaryColor,
              accentRgb: this.convertToRgbString(primaryColor),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime: 0,
                // Will be updated in processColors
                fallbackMode: "css-gradient",
                fallbackReason: "webgl-failed",
                gradientStops: Object.keys(context.rawColors).length
              },
              context
            };
          } catch (cssError) {
            Y3KDebug?.debug?.error(
              "WebGLGradientStrategy",
              "CSS gradient fallback failed, using solid color:",
              cssError
            );
            return await this.fallbackToSolidColor(context, primaryColor, originalError, cssError);
          }
        }
        /**
         * Final fallback to solid color when all gradient methods fail
         */
        async fallbackToSolidColor(context, primaryColor, webglError, cssError) {
          try {
            await this.cssController?.queueUpdate(
              "--sn-accent-color",
              primaryColor,
              "critical",
              "solid-color-fallback"
            );
            return {
              processedColors: {
                accentColor: primaryColor,
                fallbackMethod: "solid-color",
                originalColors: JSON.stringify(context.rawColors)
              },
              accentHex: primaryColor,
              accentRgb: this.convertToRgbString(primaryColor),
              metadata: {
                strategy: this.getStrategyName(),
                processingTime: 0,
                // Will be updated in processColors
                fallbackMode: "solid-color",
                fallbackReason: "all-gradients-failed",
                webglError: webglError instanceof Error ? webglError.message : "Unknown WebGL error",
                cssError: cssError instanceof Error ? cssError.message : "Unknown CSS error",
                emergencyMode: true
              },
              context
            };
          } catch (solidColorError) {
            Y3KDebug?.debug?.error(
              "WebGLGradientStrategy",
              "All fallback methods failed, using emergency mode:",
              solidColorError
            );
            return {
              processedColors: { emergencyMode: "true" },
              accentHex: "#ff6b9d",
              // Catppuccin pink fallback
              accentRgb: "rgb(255, 107, 157)",
              metadata: {
                strategy: this.getStrategyName(),
                processingTime: 0,
                // Will be updated in processColors
                fallbackMode: "emergency",
                fallbackReason: "complete-system-failure",
                criticalError: true
              },
              context
            };
          }
        }
        /**
         * Fallback to CSS gradient rendering when WebGL fails
         */
        async fallbackToCSSGradient() {
          const cssGradientFallbackVariables = {
            "--sn-webgl-ready": "0",
            "--sn-webgl-enabled": "0",
            "--sn-current-backend": "css",
            "--sn-gradient-crossfade-opacity": "0"
          };
          await this.cssController.batchSetVariables(
            "WebGLGradientStrategy",
            cssGradientFallbackVariables,
            "critical",
            // Critical priority for fallback scenarios
            "css-gradient-fallback"
          );
          if (this.cssController) {
            this.startCSSFallbackAnimation();
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "Using CSS gradient fallback"
          );
        }
        /**
         * Start CSS fallback animation
         */
        startCSSFallbackAnimation() {
          if (!this.cssController) return;
          const animateCSS = /* @__PURE__ */ __name(() => {
            if (!this.webglState.webglReady) return;
            const time = performance.now() / 1e3;
            const flowX = Math.sin(time * 0.04) * 20 + Math.sin(time * 0.07) * 8;
            const flowY = Math.cos(time * 0.05) * 20 + Math.cos(time * 0.09) * 6;
            const scale = 1.15 + Math.sin(time * 0.03) * 0.2;
            this.cssController.queueCSSVariableUpdate(
              "--sn-gradient-flow-x",
              `${flowX}%`
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-gradient-flow-y",
              `${flowY}%`
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-gradient-flow-scale",
              scale.toString()
            );
            setTimeout(animateCSS, this.flowSettings.frameThrottleInterval);
          }, "animateCSS");
          animateCSS();
        }
        /**
         * Select primary color from extracted colors
         */
        selectPrimaryColor(colors) {
          const priorities = [
            "PRIMARY",
            "VIBRANT",
            "PROMINENT",
            "VIBRANT_NON_ALARMING",
            "LIGHT_VIBRANT"
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Convert hex color to RGB string
         */
        convertToRgbString(hex) {
          const rgb = this.utils.hexToRgb(hex);
          return rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "203,166,247";
        }
        /**
         * Update configuration
         */
        updateConfig(newConfig) {
          this.flowSettings = { ...this.flowSettings, ...newConfig };
          if ("oklabProcessingEnabled" in newConfig || "oklabPreset" in newConfig) {
            this.oklabProcessor = new OKLABColorProcessor(this.config.enableDebug);
          }
          Y3KDebug?.debug?.log("WebGLGradientStrategy", "Configuration updated:", {
            ...newConfig,
            oklabProcessing: this.flowSettings.oklabProcessingEnabled,
            oklabPreset: this.flowSettings.oklabPreset,
            gradientTextureSize: this.flowSettings.gradientTextureSize
          });
        }
        /**
         * Health check for strategy status
         */
        async healthCheck() {
          const hasRecentUpdate = Date.now() - this.webglState.lastUpdateTime < 3e4;
          return {
            healthy: this.webglState.webglReady && this.flowSettings.enabled,
            canProcess: this.canProcess({}),
            issues: !this.webglState.webglReady ? ["WebGL system not ready"] : !this.flowSettings.enabled ? ["WebGL gradient disabled in settings"] : [],
            metrics: {
              webglAvailable: this.webglState.isWebGLAvailable,
              webglReady: this.webglState.webglReady,
              flowEnabled: this.flowSettings.enabled,
              intensity: this.flowSettings.intensity,
              deviceCapability: this.deviceDetector.recommendPerformanceQuality(),
              hasRecentUpdate,
              animationActive: this.webglState.animationId !== null,
              oklabProcessing: this.flowSettings.oklabProcessingEnabled,
              oklabPreset: this.flowSettings.oklabPreset,
              gradientTextureSize: this.flowSettings.gradientTextureSize,
              canvasSize: this.webglState.canvas ? {
                width: this.webglState.canvas.width,
                height: this.webglState.canvas.height
              } : null
            }
          };
        }
        /**
         * Cleanup WebGL resources
         */
        destroy() {
          if (this.webglState.animationId) {
            cancelAnimationFrame(this.webglState.animationId);
            this.webglState.animationId = null;
          }
          if (this.webglState.gl) {
            if (this.webglState.gradientTexture) {
              this.webglState.gl.deleteTexture(this.webglState.gradientTexture);
              this.webglState.gradientTexture = null;
            }
            if (this.webglState.vertexBuffer) {
              this.webglState.gl.deleteBuffer(this.webglState.vertexBuffer);
              this.webglState.vertexBuffer = null;
            }
            if (this.webglState.vao) {
              this.webglState.gl.deleteVertexArray(this.webglState.vao);
              this.webglState.vao = null;
            }
            if (this.webglState.shaderProgram) {
              this.webglState.gl.deleteProgram(this.webglState.shaderProgram);
              this.webglState.shaderProgram = null;
            }
            ShaderLoader.clearCache(this.webglState.gl);
          }
          if (this.webglState.wrapper && this.webglState.wrapper.parentNode) {
            this.webglState.wrapper.parentNode.removeChild(this.webglState.wrapper);
            this.webglState.wrapper = null;
          }
          this.webglState.canvas = null;
          this.webglState.gl = null;
          this.webglState.webglReady = false;
          window.removeEventListener("resize", this.resizeWebGLCanvas);
          const resetVariables = {
            "--sn-webgl-ready": "0",
            "--sn-webgl-enabled": "0",
            "--sn-current-backend": "css",
            "--sn-gradient-crossfade-opacity": "0"
          };
          try {
            this.cssController.batchSetVariables(
              "WebGLGradientStrategy",
              resetVariables,
              "critical",
              // Critical priority for cleanup
              "strategy-destroy-cleanup"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "WebGLGradientStrategy",
              "Error during destroy cleanup:",
              error
            );
          }
          Y3KDebug?.debug?.log(
            "WebGLGradientStrategy",
            "WebGL gradient strategy destroyed"
          );
        }
      };
      __name(_WebGLGradientStrategy, "WebGLGradientStrategy");
      WebGLGradientStrategy = _WebGLGradientStrategy;
    }
  });

  // src-js/visual/strategies/BackgroundStrategySelector.ts
  var _BackgroundStrategySelector, BackgroundStrategySelector;
  var init_BackgroundStrategySelector = __esm({
    "src-js/visual/strategies/BackgroundStrategySelector.ts"() {
      "use strict";
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_config();
      init_DepthLayeredStrategy();
      init_ThemeColorController();
      init_DynamicGradientStrategy();
      init_WebGLGradientStrategy();
      _BackgroundStrategySelector = class _BackgroundStrategySelector {
        constructor() {
          // Strategy instances (lazy-loaded)
          this.strategyInstances = /* @__PURE__ */ new Map();
          // Strategy metadata for selection decisions
          this.strategyMetadata = /* @__PURE__ */ new Map();
          this.deviceDetector = new DeviceCapabilityDetector();
          this.initializeStrategyMetadata();
          Y3KDebug?.debug?.log(
            "BackgroundStrategySelector",
            "Strategy selector initialized"
          );
        }
        /**
         * Initialize metadata for all available strategies
         */
        initializeStrategyMetadata() {
          this.strategyMetadata.set("dynamic-catppuccin", {
            name: "dynamic-catppuccin",
            priority: 10,
            // Highest priority - core accent system
            estimatedProcessingTime: 5,
            memoryImpact: 2,
            qualityScore: 9,
            compatibilityScore: 10
            // Always compatible
          });
          this.strategyMetadata.set("living-gradient", {
            name: "living-gradient",
            priority: 8,
            // High priority - foundation layer
            estimatedProcessingTime: 8,
            memoryImpact: 3,
            qualityScore: 8,
            compatibilityScore: 9
            // Compatible with most devices
          });
          this.strategyMetadata.set("webgl-gradient", {
            name: "webgl-gradient",
            priority: 6,
            // Medium-high priority - performance dependent
            estimatedProcessingTime: 12,
            memoryImpact: 7,
            qualityScore: 10,
            compatibilityScore: 6
            // Requires WebGL support
          });
          this.strategyMetadata.set("webgl-gradient-degraded", {
            name: "webgl-gradient-degraded",
            priority: 5,
            // Medium priority - for low-end devices
            estimatedProcessingTime: 8,
            memoryImpact: 4,
            qualityScore: 6,
            compatibilityScore: 8
            // Better compatibility for low-end devices
          });
          this.strategyMetadata.set("depth-layered", {
            name: "depth-layered",
            priority: 7,
            // Medium-high priority - visual effects enhancement
            estimatedProcessingTime: 15,
            memoryImpact: 5,
            qualityScore: 9,
            compatibilityScore: 7
            // Requires moderate device capabilities
          });
        }
        /**
         * Select optimal strategies based on comprehensive criteria analysis
         */
        selectStrategies(context, criteria) {
          const startTime = performance.now();
          const selectedStrategies = [];
          try {
            const deviceContext = criteria.deviceContext || this.buildDeviceContext();
            const settingsContext = criteria.settingsContext || this.buildSettingsContext();
            Y3KDebug?.debug?.log(
              "BackgroundStrategySelector",
              "\u{1F3AF} Strategy Selection Debug - WebGL Gradient Analysis",
              {
                trackUri: context.trackUri,
                colorCount: Object.keys(context.rawColors).length,
                deviceContext: {
                  supportsWebGL: deviceContext.supportsWebGL,
                  performanceLevel: deviceContext.performanceLevel,
                  memoryCapacity: deviceContext.memoryCapacity,
                  isMobile: deviceContext.isMobile
                },
                settingsContext: {
                  webglEnabled: settingsContext.webglEnabled,
                  webglForceEnabled: settingsContext.webglForceEnabled,
                  gradientIntensity: settingsContext.gradientIntensity,
                  visualEffectsLevel: settingsContext.visualEffectsLevel
                }
              }
            );
            const strategyDecisions = this.analyzeStrategyCompatibility(context, {
              ...criteria,
              deviceContext,
              settingsContext
            });
            for (const decision of strategyDecisions) {
              Y3KDebug?.debug?.log(
                "BackgroundStrategySelector",
                `Strategy decision: ${decision.strategyName}`,
                {
                  shouldInclude: decision.shouldInclude,
                  reason: decision.reason,
                  score: decision.score
                }
              );
              if (decision.shouldInclude) {
                const strategy = this.getOrCreateStrategy(decision.strategyName);
                if (strategy) {
                  const canProcess = strategy.canProcess(context);
                  Y3KDebug?.debug?.log(
                    "BackgroundStrategySelector",
                    `Strategy ${decision.strategyName} canProcess check`,
                    {
                      canProcess,
                      strategyName: decision.strategyName,
                      contextColors: Object.keys(context.rawColors).length
                    }
                  );
                  if (canProcess) {
                    selectedStrategies.push(strategy);
                    Y3KDebug?.debug?.log(
                      "BackgroundStrategySelector",
                      `\u2705 Selected strategy: ${decision.strategyName}`
                    );
                  } else {
                    Y3KDebug?.debug?.warn(
                      "BackgroundStrategySelector",
                      `\u274C Strategy rejected by canProcess(): ${decision.strategyName}`
                    );
                  }
                } else {
                  Y3KDebug?.debug?.error(
                    "BackgroundStrategySelector",
                    `Failed to create strategy: ${decision.strategyName}`
                  );
                }
              }
            }
            if (selectedStrategies.length === 0) {
              const fallbackStrategy = this.getOrCreateStrategy("living-gradient");
              if (fallbackStrategy?.canProcess(context)) {
                selectedStrategies.push(fallbackStrategy);
              }
            }
            const processingTime = performance.now() - startTime;
            Y3KDebug?.debug?.log(
              "BackgroundStrategySelector",
              "\u{1F3AF} Strategy selection completed",
              {
                selectedCount: selectedStrategies.length,
                strategies: selectedStrategies.map((s) => s.getStrategyName()),
                processingTime,
                deviceLevel: deviceContext.performanceLevel,
                visualGuideMode: settingsContext.visualGuideMode,
                webglEnabled: settingsContext.webglEnabled,
                webglForceEnabled: settingsContext.webglForceEnabled,
                supportsWebGL: deviceContext.supportsWebGL,
                totalDecisions: strategyDecisions.length,
                includedDecisions: strategyDecisions.filter((d) => d.shouldInclude).length
              }
            );
            return selectedStrategies;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "BackgroundStrategySelector",
              "Strategy selection failed:",
              error
            );
            const fallbackStrategy = this.getOrCreateStrategy("living-gradient");
            return fallbackStrategy ? [fallbackStrategy] : [];
          }
        }
        /**
         * Analyze strategy compatibility and selection logic
         */
        analyzeStrategyCompatibility(context, criteria) {
          const decisions = [];
          const dynamicScore = this.scoreDynamicCatppuccinStrategy(criteria);
          decisions.push({
            strategyName: "dynamic-catppuccin",
            shouldInclude: criteria.settingsContext.dynamicAccentEnabled && dynamicScore > 0.5,
            reason: criteria.settingsContext.dynamicAccentEnabled ? `Dynamic accent enabled (score: ${dynamicScore.toFixed(2)})` : "Dynamic accent disabled in settings",
            score: dynamicScore
          });
          const livingScore = this.scoreDynamicGradientStrategy(criteria);
          decisions.push({
            strategyName: "living-gradient",
            shouldInclude: livingScore > 0.3,
            // Almost always include as foundation
            reason: `Living gradient foundation (score: ${livingScore.toFixed(2)})`,
            score: livingScore
          });
          const webglScore = this.scoreWebGLGradientStrategy(criteria);
          const webglDegradedScore = this.scoreWebGLDegradedStrategy(criteria);
          const canUseFullWebGL = criteria.settingsContext.webglEnabled && criteria.deviceContext.supportsWebGL && (criteria.deviceContext.performanceLevel !== "low" || criteria.settingsContext.webglForceEnabled) && webglScore > 0.6;
          decisions.push({
            strategyName: "webgl-gradient",
            shouldInclude: canUseFullWebGL,
            reason: `WebGL full quality (score: ${webglScore.toFixed(2)}, device: ${criteria.deviceContext.performanceLevel}${criteria.settingsContext.webglForceEnabled ? ", FORCED" : ""})`,
            score: webglScore
          });
          decisions.push({
            strategyName: "webgl-gradient-degraded",
            shouldInclude: criteria.settingsContext.webglEnabled && criteria.deviceContext.supportsWebGL && criteria.deviceContext.performanceLevel === "low" && !criteria.settingsContext.webglForceEnabled && // Don't use degraded if forcing full WebGL
            webglDegradedScore > 0.4,
            reason: `WebGL degraded mode (score: ${webglDegradedScore.toFixed(2)}, device: low${criteria.settingsContext.webglForceEnabled ? ", skipped due to force" : ""})`,
            score: webglDegradedScore
          });
          const depthScore = this.scoreDepthLayeredStrategy(criteria);
          decisions.push({
            strategyName: "depth-layered",
            shouldInclude: criteria.settingsContext.depthLayersEnabled && criteria.settingsContext.visualEffectsLevel > 0.4 && criteria.deviceContext.performanceLevel !== "low" && depthScore > 0.5,
            reason: `Depth visual effects (score: ${depthScore.toFixed(
              2
            )}, visual-effects: ${criteria.settingsContext.visualEffectsLevel})`,
            score: depthScore
          });
          return decisions;
        }
        /**
         * Score Dynamic Catppuccin Strategy compatibility
         */
        scoreDynamicCatppuccinStrategy(criteria) {
          let score = 0.8;
          if (criteria.settingsContext.dynamicAccentEnabled) score += 0.2;
          if (criteria.musicContext?.energy && criteria.musicContext.energy > 0.7) {
            score += 0.1;
          }
          const visualModes = ["cosmic", "cinematic", "ethereal", "natural"];
          if (visualModes.includes(criteria.settingsContext.visualGuideMode)) {
            score += 0.1;
          }
          score += 0.1;
          return Math.min(1, score);
        }
        /**
         * Score Living Gradient Strategy compatibility
         */
        scoreDynamicGradientStrategy(criteria) {
          let score = 0.9;
          if (criteria.settingsContext.pulsingAnimationEnabled) score += 0.1;
          score += criteria.settingsContext.visualEffectsLevel * 0.2;
          if (criteria.musicContext?.valence !== void 0) {
            score += 0.05;
          }
          if (criteria.deviceContext.performanceLevel === "high") score += 0.05;
          return Math.min(1, score);
        }
        /**
         * Score WebGL Gradient Strategy compatibility (full quality)
         */
        scoreWebGLGradientStrategy(criteria) {
          let score = 0;
          if (!criteria.deviceContext.supportsWebGL) return 0;
          if (!criteria.settingsContext.webglEnabled) return 0;
          score = 0.6;
          if (criteria.settingsContext.webglForceEnabled) {
            score += 0.4;
            Y3KDebug?.debug?.log(
              "BackgroundStrategySelector",
              "WebGL force enabled - boosting score by 0.4"
            );
          }
          switch (criteria.deviceContext.performanceLevel) {
            case "high":
              score += 0.3;
              break;
            case "medium":
              score += 0.2;
              break;
            case "low":
              if (!criteria.settingsContext.webglForceEnabled) {
                return 0;
              }
              score += 0.1;
              break;
          }
          if (criteria.deviceContext.memoryCapacity > 4e3) score += 0.1;
          if (criteria.deviceContext.memoryCapacity > 8e3) score += 0.1;
          if (criteria.settingsContext.visualEffectsLevel > 0.7) score += 0.1;
          if (criteria.musicContext?.energy && criteria.musicContext.energy > 0.8) {
            score += 0.1;
          }
          if (criteria.deviceContext.isMobile) score -= 0.2;
          return Math.min(1, Math.max(0, score));
        }
        /**
         * Score Degraded WebGL Strategy compatibility (for low-end devices)
         */
        scoreWebGLDegradedStrategy(criteria) {
          let score = 0;
          if (!criteria.deviceContext.supportsWebGL) return 0;
          if (!criteria.settingsContext.webglEnabled) return 0;
          if (criteria.deviceContext.performanceLevel !== "low") return 0;
          score = 0.5;
          score += 0.3;
          if (criteria.settingsContext.visualEffectsLevel > 0.5) score += 0.1;
          if (criteria.musicContext?.energy && criteria.musicContext.energy > 0.6) {
            score += 0.05;
          }
          if (criteria.deviceContext.isMobile) score -= 0.1;
          if (criteria.deviceContext.memoryCapacity > 2e3) score += 0.05;
          return Math.min(1, Math.max(0, score));
        }
        /**
         * Score Depth Layered Strategy compatibility
         */
        scoreDepthLayeredStrategy(criteria) {
          let score = 0;
          if (!criteria.settingsContext.depthLayersEnabled) return 0;
          score = 0.5;
          score += criteria.settingsContext.visualEffectsLevel * 0.4;
          switch (criteria.deviceContext.performanceLevel) {
            case "high":
              score += 0.2;
              break;
            case "medium":
              score += 0.1;
              break;
            case "low":
              score = 0;
              return 0;
          }
          if (["cosmic", "cinematic"].includes(criteria.settingsContext.visualGuideMode)) {
            score += 0.2;
          }
          if (criteria.musicContext?.tempo && criteria.musicContext.tempo < 100) {
            score += 0.1;
          }
          if (criteria.deviceContext.memoryCapacity > 6e3) score += 0.1;
          if (criteria.deviceContext.isMobile) score -= 0.15;
          return Math.min(1, Math.max(0, score));
        }
        /**
         * Build device context from current device capabilities
         */
        buildDeviceContext() {
          const memoryMB = window.navigator.deviceMemory ? window.navigator.deviceMemory * 1024 : 4096;
          const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
          return {
            supportsWebGL: this.deviceDetector.hasWebGLSupport(),
            performanceLevel: this.deviceDetector.recommendPerformanceQuality(),
            memoryCapacity: memoryMB,
            isMobile
          };
        }
        /**
         * Build settings context from settings manager
         */
        buildSettingsContext() {
          try {
            return {
              dynamicAccentEnabled: true,
              // Always enabled for dynamic accent
              gradientIntensity: settings.get("sn-gradient-intensity"),
              webglEnabled: settings.get("sn-webgl-enabled"),
              webglForceEnabled: settings.get("sn-webgl-enabled"),
              // Use same setting
              visualGuideMode: settings.get("sn-artistic-mode"),
              // Use artistic mode as visual guide
              depthLayersEnabled: settings.get("sn-gradient-intensity") !== "disabled",
              visualEffectsLevel: 0.8,
              // Fixed value for visual effects level
              pulsingAnimationEnabled: true
              // Always enabled
            };
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "BackgroundStrategySelector",
              "Failed to load settings, using defaults:",
              error
            );
            return {
              dynamicAccentEnabled: true,
              gradientIntensity: "balanced",
              webglEnabled: true,
              webglForceEnabled: false,
              visualGuideMode: "cosmic",
              depthLayersEnabled: true,
              visualEffectsLevel: 0.8,
              pulsingAnimationEnabled: true
            };
          }
        }
        /**
         * Get or create strategy instance (lazy loading)
         */
        getOrCreateStrategy(strategyName) {
          if (this.strategyInstances.has(strategyName)) {
            return this.strategyInstances.get(strategyName);
          }
          let strategy = null;
          try {
            switch (strategyName) {
              case "dynamic-catppuccin":
                strategy = new DynamicCatppuccinStrategy();
                break;
              case "living-gradient":
                strategy = new DynamicGradientStrategy();
                break;
              case "webgl-gradient":
                strategy = new WebGLGradientStrategy();
                break;
              case "webgl-gradient-degraded":
                strategy = new WebGLGradientStrategy();
                break;
              case "depth-layered":
                strategy = new DepthLayeredStrategy();
                break;
              default:
                Y3KDebug?.debug?.warn(
                  "BackgroundStrategySelector",
                  `Unknown strategy: ${strategyName}`
                );
                return null;
            }
            if (strategy) {
              this.strategyInstances.set(strategyName, strategy);
              Y3KDebug?.debug?.log(
                "BackgroundStrategySelector",
                `Created strategy instance: ${strategyName}`
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "BackgroundStrategySelector",
              `Failed to create strategy ${strategyName}:`,
              error
            );
            return null;
          }
          return strategy;
        }
        /**
         * Get estimated total processing time for selected strategies
         */
        getEstimatedProcessingTime(strategies, context) {
          return strategies.reduce((total, strategy) => {
            return total + strategy.getEstimatedProcessingTime(context);
          }, 0);
        }
        /**
         * Get strategy metadata for debugging
         */
        getStrategyMetadata(strategyName) {
          return this.strategyMetadata.get(strategyName) || null;
        }
        /**
         * Get all available strategy names
         */
        getAvailableStrategyNames() {
          return Array.from(this.strategyMetadata.keys());
        }
        /**
         * Update strategy selection criteria (for runtime adjustments)
         */
        updateSelectionCriteria(updates) {
          Y3KDebug?.debug?.log(
            "BackgroundStrategySelector",
            "Strategy selection criteria updated:",
            updates
          );
        }
        /**
         * Cleanup strategy instances
         */
        destroy() {
          this.strategyInstances.forEach((strategy, name) => {
            if ("destroy" in strategy && typeof strategy.destroy === "function") {
              try {
                strategy.destroy();
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "BackgroundStrategySelector",
                  `Error destroying strategy ${name}:`,
                  error
                );
              }
            }
          });
          this.strategyInstances.clear();
          this.strategyMetadata.clear();
          Y3KDebug?.debug?.log(
            "BackgroundStrategySelector",
            "Strategy selector destroyed"
          );
        }
      };
      __name(_BackgroundStrategySelector, "BackgroundStrategySelector");
      BackgroundStrategySelector = _BackgroundStrategySelector;
    }
  });

  // src-js/core/color/UnifiedColorProcessingEngine.ts
  var _UnifiedColorProcessingEngine, UnifiedColorProcessingEngine, getSharedDependencies, settingsManager, performanceAnalyzer, globalUnifiedColorProcessingEngine;
  var init_UnifiedColorProcessingEngine = __esm({
    "src-js/core/color/UnifiedColorProcessingEngine.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_MusicalOKLABCoordinator();
      init_OKLABColorProcessor();
      init_BackgroundStrategyRegistry();
      init_BackgroundStrategySelector();
      _UnifiedColorProcessingEngine = class _UnifiedColorProcessingEngine {
        // 30 seconds
        constructor(settingsManager2, performanceAnalyzer2) {
          this.initialized = false;
          // === STATE MANAGEMENT ===
          this.processingState = {
            isProcessing: false,
            currentTrackUri: null,
            lastExtractedColors: null,
            lastProcessedResult: null,
            lastProcessingTime: 0,
            processingQueue: [],
            queueSize: 0
          };
          this.metrics = {
            totalExtractions: 0,
            totalProcessed: 0,
            totalApplied: 0,
            averageProcessingTime: 0,
            successRate: 0,
            errorCount: 0,
            lastProcessingTime: 0,
            oklabCoordinations: 0,
            strategySelections: 0,
            cacheHits: 0
          };
          // Enhanced orchestration metrics from ColorCoordinator
          this.orchestrationMetrics = {
            totalProcessingTime: 0,
            strategiesProcessed: 0,
            strategiesSucceeded: 0,
            strategiesFailed: 0,
            cacheHits: 0,
            averageStrategyTime: 0,
            memoryUsage: 0,
            oklabCoordinations: 0,
            oklabProcessingTime: 0
          };
          // Advanced processing features from ColorCoordinator
          this.oklabCoordinationEnabled = true;
          this.multiStrategyProcessingEnabled = true;
          this.resultCache = /* @__PURE__ */ new Map();
          this.cacheMaxSize = 50;
          this.cacheTimeoutMs = 3e5;
          // 5 minutes
          // Context deduplication (from ColorCoordinator)
          this.processedContexts = /* @__PURE__ */ new Map();
          // trackUri -> timestamp
          this.CONTEXT_CACHE_TTL = 2e3;
          // 2 seconds
          // === PERFORMANCE OPTIMIZATION ===
          this.processingTimeout = null;
          this.PROCESSING_TIMEOUT_MS = 1e4;
          // 10 seconds
          this.MAX_QUEUE_SIZE = 10;
          this.processingCache = /* @__PURE__ */ new Map();
          this.CACHE_TTL_MS = 3e4;
          this.settingsManager = settingsManager2 || new SettingsManager();
          this.performanceAnalyzer = performanceAnalyzer2 || null;
          this.deviceCapabilityDetector = new DeviceCapabilityDetector();
          this.strategyRegistry = new BackgroundStrategyRegistry();
          this.strategySelector = new BackgroundStrategySelector();
          this.oklabProcessor = new OKLABColorProcessor();
          this.musicalOKLABProcessor = new MusicalOKLABProcessor(true);
        }
        async initialize() {
          if (this.initialized) return;
          try {
            await this.deviceCapabilityDetector.initialize();
            this.setupEventSubscriptions();
            this.registerDefaultStrategies();
            this.initialized = true;
            Y3KDebug?.debug?.log(
              "UnifiedColorProcessingEngine",
              "\u{1F3A8} Unified color processing engine initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedColorProcessingEngine",
              "Failed to initialize:",
              error
            );
            throw error;
          }
        }
        async healthCheck() {
          const issues = [];
          if (!this.initialized) {
            issues.push("Engine not initialized");
          }
          if (this.processingState.isProcessing && Date.now() - this.processingState.lastProcessingTime > this.PROCESSING_TIMEOUT_MS) {
            issues.push("Processing appears stuck");
          }
          if (this.metrics.errorCount > 0 && this.metrics.successRate < 0.8) {
            issues.push(
              `Low success rate: ${(this.metrics.successRate * 100).toFixed(1)}%`
            );
          }
          if (this.processingState.queueSize > this.MAX_QUEUE_SIZE) {
            issues.push(`Queue overflow: ${this.processingState.queueSize} items`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Unified color processing - ${this.metrics.totalProcessed} processed, ${this.metrics.successRate.toFixed(2)} success rate`,
            issues,
            system: "UnifiedColorProcessingEngine"
          };
        }
        updateAnimation(deltaTime) {
          if (this.processingCache.size > 50) {
            this.cleanupCache();
          }
        }
        destroy() {
          if (this.processingTimeout) {
            clearTimeout(this.processingTimeout);
            this.processingTimeout = null;
          }
          this.processingState.processingQueue = [];
          this.processingCache.clear();
          unifiedEventBus.unsubscribeAll("UnifiedColorProcessingEngine");
          this.initialized = false;
        }
        // ============================================================================
        // Event Subscription Setup
        // ============================================================================
        setupEventSubscriptions() {
          unifiedEventBus.subscribe(
            "colors:extracted",
            (data) => {
              this.handleColorExtraction(data);
            },
            "UnifiedColorProcessingEngine"
          );
          unifiedEventBus.subscribe(
            "settings:changed",
            (data) => {
              this.handleSettingsChange(data);
            },
            "UnifiedColorProcessingEngine"
          );
        }
        // ============================================================================
        // Main Processing Pipeline
        // ============================================================================
        /**
         * 🔧 PHASE 2.1: Main color processing entry point
         * Consolidates processing logic from all orchestrators with multi-strategy support
         */
        async processColors(context) {
          const startTime = performance.now();
          try {
            const cacheKey = this.generateCacheKey(context);
            const cached = this.getCachedResult(cacheKey);
            if (cached) {
              this.metrics.cacheHits++;
              this.orchestrationMetrics.cacheHits++;
              return cached;
            }
            if (this.isDuplicateContext(context)) {
              Y3KDebug?.debug?.log(
                "UnifiedColorProcessingEngine",
                "Skipping duplicate context within TTL"
              );
              return this.getLastProcessedResult() || this.createFallbackResult(context, new Error("No previous result"));
            }
            let result;
            if (this.multiStrategyProcessingEnabled) {
              result = await this.processMultipleStrategies(context);
            } else {
              const strategy = await this.selectOptimalStrategy(context);
              this.metrics.strategySelections++;
              result = await this.processWithOKLAB(context, strategy);
            }
            const processingTime = performance.now() - startTime;
            this.updateMetrics(processingTime, true);
            this.updateOrchestrationMetrics(processingTime, true);
            const unifiedResult = {
              ...result,
              processingTime,
              strategy: result.metadata?.strategy ? { getStrategyName: /* @__PURE__ */ __name(() => result.metadata.strategy, "getStrategyName") } : await this.selectOptimalStrategy(context),
              success: true,
              timestamp: Date.now(),
              coordinationMetrics: {
                detectedGenre: context.musicData?.genre || "unknown",
                emotionalState: context.musicData?.energy ? this.classifyEmotionalState(context.musicData.energy) : "neutral",
                oklabPreset: this.determineOKLABPreset(context),
                coordinationStrategy: result.metadata?.strategy || "unified",
                musicInfluenceStrength: context.musicData?.energy || 0.5
              }
            };
            this.cacheResult(cacheKey, unifiedResult);
            this.cacheContext(context);
            this.processingState.lastProcessedResult = unifiedResult;
            unifiedEventBus.emit("colors:harmonized", {
              processedColors: result.processedColors,
              accentHex: result.accentHex || "var(--sn-brightness-adjusted-accent-hex, #cba6f7)",
              accentRgb: result.accentRgb || "var(--sn-brightness-adjusted-accent-rgb, 203, 166, 247)",
              strategies: [unifiedResult.coordinationMetrics.coordinationStrategy],
              coordinationMetrics: unifiedResult.coordinationMetrics,
              oklabData: unifiedResult.oklabData,
              processingTime,
              timestamp: Date.now()
            });
            return unifiedResult;
          } catch (error) {
            const processingTime = performance.now() - startTime;
            this.updateMetrics(processingTime, false);
            this.updateOrchestrationMetrics(processingTime, false);
            Y3KDebug?.debug?.error(
              "UnifiedColorProcessingEngine",
              "Processing failed:",
              error
            );
            return this.createFallbackResult(context, error);
          }
        }
        /**
         * 🔧 PHASE 2.1: Multi-strategy parallel processing from ColorCoordinator
         * Processes multiple strategies and intelligently merges results
         */
        async processMultipleStrategies(context) {
          const startTime = performance.now();
          try {
            const strategies = await this.selectMultipleStrategies(context);
            if (strategies.length === 0) {
              throw new Error("No strategies available for processing");
            }
            const strategyPromises = strategies.map(async (strategy) => {
              const strategyStartTime = performance.now();
              try {
                const result = await strategy.processColors(context);
                const processingTime = performance.now() - strategyStartTime;
                return {
                  strategy,
                  result,
                  processingTime,
                  success: true,
                  oklabData: result.metadata?.oklabData
                };
              } catch (error) {
                const processingTime = performance.now() - strategyStartTime;
                Y3KDebug?.debug?.warn(
                  "UnifiedColorProcessingEngine",
                  `Strategy ${strategy.getStrategyName()} failed:`,
                  error
                );
                return {
                  strategy,
                  result: this.createFallbackResult(context, error),
                  processingTime,
                  success: false,
                  error: error.message
                };
              }
            });
            const strategyResults = await Promise.all(strategyPromises);
            this.orchestrationMetrics.strategiesProcessed += strategyResults.length;
            this.orchestrationMetrics.strategiesSucceeded += strategyResults.filter((r) => r.success).length;
            this.orchestrationMetrics.strategiesFailed += strategyResults.filter((r) => !r.success).length;
            this.orchestrationMetrics.totalProcessingTime += performance.now() - startTime;
            this.orchestrationMetrics.averageStrategyTime = strategyResults.reduce((sum, r) => sum + r.processingTime, 0) / strategyResults.length;
            let mergedResult;
            if (this.oklabCoordinationEnabled && strategyResults.some((r) => r.success)) {
              mergedResult = await this.coordinateOKLABProcessing(context, strategyResults);
              this.orchestrationMetrics.oklabCoordinations++;
            } else {
              mergedResult = this.mergeStrategyResults(strategyResults, context);
            }
            return mergedResult;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedColorProcessingEngine",
              "Multi-strategy processing failed:",
              error
            );
            const fallbackStrategy = await this.selectOptimalStrategy(context);
            return await this.processWithOKLAB(context, fallbackStrategy);
          }
        }
        /**
         * 🔧 PHASE 2.1: Advanced OKLAB coordination from ColorCoordinator
         * Coordinates OKLAB processing across multiple strategy results
         */
        async coordinateOKLABProcessing(context, strategyResults) {
          const oklabStartTime = performance.now();
          try {
            const successfulResults = strategyResults.filter((r) => r.success);
            if (successfulResults.length === 0) {
              throw new Error("No successful strategy results for OKLAB coordination");
            }
            const allColors = {};
            successfulResults.forEach((result) => {
              Object.entries(result.result.processedColors).forEach(([key, value]) => {
                if (!allColors[key]) allColors[key] = [];
                allColors[key].push(value);
              });
            });
            const musicalContext = {
              rawColors: context.rawColors,
              musicData: context.musicData,
              trackUri: context.trackUri,
              timestamp: context.timestamp
            };
            const oklabResult = await this.musicalOKLABProcessor.processMusicalColors(musicalContext);
            const coordinatedColors = this.blendOKLABWithStrategies(allColors, oklabResult);
            const primaryResult = this.selectPrimaryResult(successfulResults);
            const coordinated = {
              ...primaryResult.result,
              processedColors: coordinatedColors,
              metadata: {
                ...primaryResult.result.metadata,
                oklabCoordination: oklabResult,
                coordinationStrategy: "multi-strategy-oklab",
                strategiesUsed: successfulResults.map((r) => r.strategy.getStrategyName()),
                oklabProcessingTime: performance.now() - oklabStartTime
              }
            };
            this.orchestrationMetrics.oklabProcessingTime += performance.now() - oklabStartTime;
            return coordinated;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "UnifiedColorProcessingEngine",
              "OKLAB coordination failed, falling back to merge:",
              error
            );
            return this.mergeStrategyResults(strategyResults, context);
          }
        }
        /**
         * 🔧 PHASE 2.1: Intelligent result merging from ColorCoordinator
         * Merges multiple strategy results with conflict resolution
         */
        mergeStrategyResults(strategyResults, context, options = {
          priorityWeighting: true,
          conflictResolution: "merge",
          preserveMetadata: true,
          visualEffectsBlending: true,
          oklabCoordination: false
        }) {
          const successfulResults = strategyResults.filter((r) => r.success);
          if (successfulResults.length === 0) {
            return this.createFallbackResult(context, new Error("No successful strategies"));
          }
          if (successfulResults.length === 1) {
            const singleResult = successfulResults[0];
            if (!singleResult) {
              return this.createFallbackResult(context, new Error("Single result is undefined"));
            }
            return singleResult.result;
          }
          const prioritizedResults = options.priorityWeighting ? this.prioritizeResults(successfulResults) : successfulResults;
          if (prioritizedResults.length === 0) {
            return this.createFallbackResult(context, new Error("No prioritized results"));
          }
          const primaryResult = prioritizedResults[0];
          if (!primaryResult) {
            return this.createFallbackResult(context, new Error("Primary result is undefined"));
          }
          const mergedColors = { ...primaryResult.result.processedColors };
          prioritizedResults.slice(1).forEach((strategyResult) => {
            Object.entries(strategyResult.result.processedColors).forEach(([key, value]) => {
              if (mergedColors[key]) {
                switch (options.conflictResolution) {
                  case "override":
                    break;
                  case "merge":
                    mergedColors[`${key}-${strategyResult.strategy.getStrategyName()}`] = value;
                    break;
                  case "average":
                    if (this.isValidHexColor(mergedColors[key]) && this.isValidHexColor(value)) {
                      mergedColors[key] = this.averageColors(mergedColors[key], value);
                    }
                    break;
                }
              } else {
                mergedColors[key] = value;
              }
            });
          });
          const mergedMetadata = options.preserveMetadata ? this.mergeMetadata(prioritizedResults.map((r) => r.result.metadata)) : primaryResult.result.metadata;
          return {
            ...primaryResult.result,
            processedColors: mergedColors,
            metadata: {
              ...mergedMetadata,
              mergeStrategy: options.conflictResolution,
              strategiesUsed: successfulResults.map((r) => r.strategy.getStrategyName()),
              mergeTimestamp: Date.now()
            }
          };
        }
        /**
         * 🔧 PHASE 3: Handle color extraction events - IColorOrchestrator interface
         * Accepts both ColorContext and UnifiedEventBus data formats
         */
        async handleColorExtraction(contextOrData) {
          if ("rawColors" in contextOrData && "trackUri" in contextOrData) {
            return this.processColorContext(contextOrData);
          }
          return this.handleColorExtractionEvent(contextOrData);
        }
        /**
         * Process ColorContext directly (IColorOrchestrator interface)
         */
        async processColorContext(context) {
          this.metrics.totalExtractions++;
          try {
            if (this.processingState.isProcessing) {
              this.addToQueue(context);
              return;
            }
            await this.processWithTimeout(context);
          } catch (error) {
            this.metrics.errorCount++;
            Y3KDebug?.debug?.error(
              "UnifiedColorProcessingEngine",
              "Color context processing failed:",
              error
            );
          }
        }
        /**
         * Handle UnifiedEventBus format events
         */
        async handleColorExtractionEvent(data) {
          this.metrics.totalExtractions++;
          try {
            const context = {
              rawColors: data.rawColors,
              trackUri: data.trackUri,
              musicData: data.musicData,
              timestamp: data.timestamp || Date.now()
            };
            if (this.processingState.isProcessing) {
              this.addToQueue(context);
              return;
            }
            await this.processWithTimeout(context);
          } catch (error) {
            this.metrics.errorCount++;
            Y3KDebug?.debug?.error(
              "UnifiedColorProcessingEngine",
              "Color extraction handling failed:",
              error
            );
          }
        }
        /**
         * 🔧 PHASE 3: Process context with OKLAB coordination
         * Consolidates OKLAB processing from ColorHarmonyEngine
         */
        async processWithOKLAB(context, strategy) {
          const musicalContext = {
            rawColors: context.rawColors,
            musicData: context.musicData,
            // Type compatibility
            trackUri: context.trackUri,
            timestamp: context.timestamp
          };
          const oklabResult = await this.musicalOKLABProcessor.processMusicalColors(
            musicalContext
          );
          this.metrics.oklabCoordinations++;
          const strategyResult = await strategy.processColors(context);
          const enhancedColors = await this.enhanceWithOKLAB(
            strategyResult.processedColors,
            oklabResult
          );
          return {
            ...strategyResult,
            processedColors: enhancedColors,
            metadata: {
              ...strategyResult.metadata,
              oklabPreset: this.determineOKLABPreset(context),
              oklabCoordination: oklabResult
            }
          };
        }
        /**
         * 🔧 PHASE 3: Strategy selection consolidating all orchestrator logic
         */
        async selectOptimalStrategy(context) {
          try {
            const capabilities = this.deviceCapabilityDetector.getCapabilities();
            const backgroundCriteria = {
              performance: "medium",
              quality: "enhanced",
              deviceCapabilities: {
                hasWebGL: capabilities?.gpu?.supportsWebGL || true,
                memoryMB: capabilities?.memory?.total || 4096,
                isMobile: false
              },
              userPreferences: {
                harmonicMode: "cosmic",
                intensity: 0.8,
                enableAdvancedBlending: true
              },
              // BackgroundStrategySelector-specific properties
              settingsContext: {
                dynamicAccentEnabled: true,
                gradientIntensity: "medium",
                webglEnabled: capabilities?.gpu?.supportsWebGL || true,
                webglForceEnabled: false,
                // Default to false in unified engine
                visualGuideMode: "enhanced",
                depthLayersEnabled: true,
                visualEffectsLevel: 0.8,
                pulsingAnimationEnabled: true
              },
              deviceContext: {
                supportsWebGL: capabilities?.gpu?.supportsWebGL || true,
                performanceLevel: "medium",
                memoryCapacity: capabilities?.memory?.total || 4096,
                isMobile: false
              }
            };
            const strategies = this.strategySelector.selectStrategies(
              context,
              backgroundCriteria
            );
            if (strategies && strategies.length > 0 && strategies[0]) {
              return strategies[0];
            }
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "UnifiedColorProcessingEngine",
              "Strategy selection failed, using fallback:",
              error
            );
          }
          const fallbackStrategy = {
            getStrategyName: /* @__PURE__ */ __name(() => "fallback", "getStrategyName"),
            canProcess: /* @__PURE__ */ __name((ctx) => true, "canProcess"),
            getEstimatedProcessingTime: /* @__PURE__ */ __name((ctx) => 50, "getEstimatedProcessingTime"),
            // 50ms estimate
            processColors: /* @__PURE__ */ __name(async (ctx) => ({
              processedColors: ctx.rawColors,
              accentHex: "var(--sn-brightness-adjusted-accent-hex, #cba6f7)",
              accentRgb: "var(--sn-brightness-adjusted-accent-rgb, 203, 166, 247)",
              context: ctx,
              metadata: {
                strategy: "fallback",
                timestamp: Date.now(),
                processingTime: 0
              }
            }), "processColors")
          };
          return fallbackStrategy;
        }
        // ============================================================================
        // Queue Management (from orchestrators)
        // ============================================================================
        addToQueue(context) {
          if (this.processingState.queueSize >= this.MAX_QUEUE_SIZE) {
            this.processingState.processingQueue.shift();
          }
          this.processingState.processingQueue.push(context);
          this.processingState.queueSize = this.processingState.processingQueue.length;
        }
        async processQueue() {
          while (this.processingState.processingQueue.length > 0 && !this.processingState.isProcessing) {
            const context = this.processingState.processingQueue.shift();
            this.processingState.queueSize = this.processingState.processingQueue.length;
            await this.processWithTimeout(context);
          }
        }
        async processWithTimeout(context) {
          this.processingState.isProcessing = true;
          this.processingState.lastProcessingTime = Date.now();
          this.processingTimeout = window.setTimeout(() => {
            Y3KDebug?.debug?.warn(
              "UnifiedColorProcessingEngine",
              "Processing timeout - forcing reset"
            );
            this.processingState.isProcessing = false;
            this.metrics.errorCount++;
          }, this.PROCESSING_TIMEOUT_MS);
          try {
            await this.processColors(context);
            this.metrics.totalProcessed++;
          } finally {
            if (this.processingTimeout) {
              clearTimeout(this.processingTimeout);
              this.processingTimeout = null;
            }
            this.processingState.isProcessing = false;
            if (this.processingState.processingQueue.length > 0) {
              setTimeout(() => this.processQueue(), 0);
            }
          }
        }
        // ============================================================================
        // Performance Optimization
        // ============================================================================
        generateCacheKey(context) {
          const keyData = {
            colors: Object.keys(context.rawColors).sort().join(","),
            music: context.musicData?.energy || 0
          };
          return JSON.stringify(keyData);
        }
        getCachedResult(key) {
          const cached = this.processingCache.get(key);
          if (cached && Date.now() - cached.timestamp < this.CACHE_TTL_MS) {
            return cached;
          }
          return null;
        }
        cacheResult(key, result) {
          this.processingCache.set(key, { ...result, timestamp: Date.now() });
          this.resultCache.set(key, result);
          if (this.resultCache.size > this.cacheMaxSize) {
            const entries = Array.from(this.resultCache.entries());
            const toRemove = entries.slice(0, entries.length - this.cacheMaxSize);
            toRemove.forEach(([cacheKey]) => this.resultCache.delete(cacheKey));
          }
        }
        cleanupCache() {
          const now = Date.now();
          for (const [key, result] of this.processingCache.entries()) {
            if (now - result.timestamp > this.CACHE_TTL_MS) {
              this.processingCache.delete(key);
            }
          }
        }
        updateMetrics(processingTime, success) {
          this.metrics.averageProcessingTime = (this.metrics.averageProcessingTime * this.metrics.totalProcessed + processingTime) / (this.metrics.totalProcessed + 1);
          if (success) {
            this.metrics.successRate = (this.metrics.successRate * this.metrics.totalProcessed + 1) / (this.metrics.totalProcessed + 1);
          } else {
            this.metrics.successRate = this.metrics.successRate * this.metrics.totalProcessed / (this.metrics.totalProcessed + 1);
          }
          this.metrics.lastProcessingTime = Date.now();
        }
        // ============================================================================
        // Multi-Strategy Processing Support Methods
        // ============================================================================
        /**
         * 🔧 PHASE 2.1: Select multiple strategies for parallel processing
         */
        async selectMultipleStrategies(context) {
          try {
            const capabilities = this.deviceCapabilityDetector.getCapabilities();
            const criteria = this.buildSelectionCriteria(capabilities);
            const strategies = this.strategySelector.selectStrategies(context, criteria);
            return strategies?.slice(0, 3) || [];
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "UnifiedColorProcessingEngine",
              "Multi-strategy selection failed, using single strategy:",
              error
            );
            const singleStrategy = await this.selectOptimalStrategy(context);
            return [singleStrategy];
          }
        }
        /**
         * 🔧 PHASE 2.1: Context deduplication checking
         */
        isDuplicateContext(context) {
          if (!context.trackUri) return false;
          const lastProcessed = this.processedContexts.get(context.trackUri);
          if (!lastProcessed) return false;
          const timeSinceProcessed = Date.now() - lastProcessed;
          return timeSinceProcessed < this.CONTEXT_CACHE_TTL;
        }
        /**
         * 🔧 PHASE 2.1: Cache context for deduplication
         */
        cacheContext(context) {
          if (context.trackUri) {
            this.processedContexts.set(context.trackUri, Date.now());
            if (this.processedContexts.size > 100) {
              const cutoff = Date.now() - this.CONTEXT_CACHE_TTL * 2;
              for (const [uri, timestamp] of this.processedContexts.entries()) {
                if (timestamp < cutoff) {
                  this.processedContexts.delete(uri);
                }
              }
            }
          }
        }
        /**
         * 🔧 PHASE 2.1: Get last processed result for duplicate handling
         */
        getLastProcessedResult() {
          return this.processingState.lastProcessedResult;
        }
        /**
         * 🔧 PHASE 2.1: Update orchestration metrics
         */
        updateOrchestrationMetrics(processingTime, success) {
          this.orchestrationMetrics.totalProcessingTime += processingTime;
          if (success) {
          } else {
            this.orchestrationMetrics.strategiesFailed++;
          }
          this.orchestrationMetrics.memoryUsage = Math.round(
            (this.resultCache.size * 1024 + this.processedContexts.size * 256) / 1024
            // KB estimate
          );
        }
        /**
         * 🔧 PHASE 2.1: Blend OKLAB results with strategy colors
         */
        blendOKLABWithStrategies(strategyColors, oklabResult) {
          const blended = {};
          if (oklabResult.enhancedColors) {
            Object.entries(oklabResult.enhancedColors).forEach(([key, value]) => {
              blended[`oklab-${key}`] = value;
            });
          }
          Object.entries(strategyColors).forEach(([key, colors]) => {
            if (colors.length === 1 && colors[0]) {
              blended[key] = colors[0];
            } else if (colors.length > 1 && colors[0]) {
              blended[key] = colors[0];
              colors.slice(1).forEach((color3, index) => {
                if (color3) {
                  blended[`${key}-variant-${index + 1}`] = color3;
                }
              });
            }
          });
          return blended;
        }
        /**
         * 🔧 PHASE 2.1: Select primary result from strategy results
         */
        selectPrimaryResult(results) {
          if (results.length === 0) {
            throw new Error("Cannot select primary result from empty results array");
          }
          const sorted = results.sort((a, b) => {
            if (a.success && !b.success) return -1;
            if (!a.success && b.success) return 1;
            return a.processingTime - b.processingTime;
          });
          const primary = sorted[0];
          if (!primary) {
            throw new Error("Primary result is undefined after sorting");
          }
          return primary;
        }
        /**
         * 🔧 PHASE 2.1: Prioritize strategy results for merging
         */
        prioritizeResults(results) {
          if (results.length === 0) return [];
          return results.sort((a, b) => {
            if (a.success && !b.success) return -1;
            if (!a.success && b.success) return 1;
            if (a.success && b.success) {
              return a.processingTime - b.processingTime;
            }
            return 0;
          });
        }
        /**
         * 🔧 PHASE 2.1: Merge metadata from multiple results
         */
        mergeMetadata(metadataArray) {
          if (metadataArray.length === 0) return {};
          if (metadataArray.length === 1) return metadataArray[0] || {};
          const merged = { ...metadataArray[0] };
          const allStrategies = [];
          metadataArray.forEach((meta) => {
            if (meta?.strategy) allStrategies.push(meta.strategy);
            if (meta?.strategiesUsed) allStrategies.push(...meta.strategiesUsed);
          });
          merged.strategiesUsed = [...new Set(allStrategies)];
          merged.mergeTimestamp = Date.now();
          return merged;
        }
        /**
         * 🔧 PHASE 2.1: Check if string is valid hex color
         */
        isValidHexColor(color3) {
          return /^#[0-9A-F]{6}$/i.test(color3);
        }
        /**
         * 🔧 PHASE 2.1: Average two hex colors
         */
        averageColors(color1, color22) {
          try {
            const r1 = parseInt(color1.substring(1, 3), 16);
            const g1 = parseInt(color1.substring(3, 5), 16);
            const b1 = parseInt(color1.substring(5, 7), 16);
            const r2 = parseInt(color22.substring(1, 3), 16);
            const g2 = parseInt(color22.substring(3, 5), 16);
            const b2 = parseInt(color22.substring(5, 7), 16);
            const r = Math.round((r1 + r2) / 2);
            const g = Math.round((g1 + g2) / 2);
            const b = Math.round((b1 + b2) / 2);
            return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
          } catch (error) {
            return color1;
          }
        }
        /**
         * 🔧 PHASE 2.1: Build selection criteria for strategies
         */
        buildSelectionCriteria(capabilities) {
          return {
            performance: "medium",
            quality: "enhanced",
            deviceCapabilities: {
              hasWebGL: capabilities?.gpu?.supportsWebGL || true,
              memoryMB: capabilities?.memory?.total || 4096,
              isMobile: false
            },
            userPreferences: {
              harmonicMode: "cosmic",
              intensity: 0.8,
              enableAdvancedBlending: true
            },
            settingsContext: {
              dynamicAccentEnabled: true,
              gradientIntensity: "medium",
              webglEnabled: capabilities?.gpu?.supportsWebGL || true,
              webglForceEnabled: false,
              visualGuideMode: "enhanced",
              depthLayersEnabled: true,
              visualEffectsLevel: 0.8,
              pulsingAnimationEnabled: true
            },
            deviceContext: {
              supportsWebGL: capabilities?.gpu?.supportsWebGL || true,
              performanceLevel: "medium",
              memoryCapacity: capabilities?.memory?.total || 4096,
              isMobile: false
            }
          };
        }
        // ============================================================================
        // Utility Methods
        // ============================================================================
        async enhanceWithOKLAB(colors, oklabResult) {
          const enhanced = { ...colors };
          if (oklabResult.enhancedColors) {
            Object.entries(oklabResult.enhancedColors).forEach(([key, value]) => {
              enhanced[`oklab-${key}`] = value;
            });
          }
          return enhanced;
        }
        classifyEmotionalState(energy) {
          if (energy > 0.8) return "energetic";
          if (energy > 0.6) return "upbeat";
          if (energy > 0.4) return "moderate";
          if (energy > 0.2) return "calm";
          return "peaceful";
        }
        determineOKLABPreset(context) {
          const energy = context.musicData?.energy || 0.5;
          if (energy > 0.8) return "high-energy";
          if (energy > 0.6) return "dynamic";
          if (energy > 0.4) return "balanced";
          return "ambient";
        }
        createFallbackResult(context, error) {
          return {
            processedColors: {
              fallback: "var(--sn-brightness-adjusted-accent-hex, #cba6f7)"
              // Brightness-adjusted default
            },
            accentHex: "var(--sn-brightness-adjusted-accent-hex, #cba6f7)",
            accentRgb: "var(--sn-brightness-adjusted-accent-rgb, 203, 166, 247)",
            context,
            // Required by ColorResult interface
            metadata: {
              strategy: "fallback",
              error: error.message,
              timestamp: Date.now(),
              processingTime: 0
            }
          };
        }
        registerDefaultStrategies() {
        }
        async handleSettingsChange(data) {
          if ([
            "catppuccin-flavor",
            "catppuccin-accentColor",
            "sn-dynamic-color-intensity"
          ].includes(data.settingKey)) {
            this.processingCache.clear();
            Y3KDebug?.debug?.log(
              "UnifiedColorProcessingEngine",
              "Cache cleared due to settings change:",
              data.settingKey
            );
          }
        }
        async handlePerformanceWarning(data) {
          if (data.memoryUsage > 50) {
            this.processingCache.clear();
            Y3KDebug?.debug?.log(
              "UnifiedColorProcessingEngine",
              "Cache cleared due to memory pressure"
            );
          }
        }
        // ============================================================================
        // Public API (Backward Compatibility)
        // ============================================================================
        /**
         * Get processing metrics for debugging and monitoring
         */
        getMetrics() {
          return { ...this.metrics };
        }
        /**
         * Force reprocess current colors (compatibility method)
         */
        async forceReprocessColors() {
          this.processingCache.clear();
          if (this.processingState.lastExtractedColors) {
            const context = {
              rawColors: this.processingState.lastExtractedColors,
              trackUri: this.processingState.currentTrackUri || "",
              timestamp: Date.now()
            };
            await this.processColors(context);
          }
        }
        /**
         * Get current processing state (debugging)
         */
        getProcessingState() {
          return { ...this.processingState };
        }
        // ============================================================================
        // IColorOrchestrator Interface Implementation
        // ============================================================================
        /**
         * Get current processing status (IColorOrchestrator interface)
         */
        getStatus() {
          return {
            isProcessing: this.processingState.isProcessing,
            queueSize: this.processingState.queueSize
          };
        }
        /**
         * Set strategy selection criteria (IColorOrchestrator interface)
         */
        setSelectionCriteria(criteria) {
          Y3KDebug?.debug?.log(
            "UnifiedColorProcessingEngine",
            "Strategy selection criteria updated:",
            criteria
          );
        }
      };
      __name(_UnifiedColorProcessingEngine, "UnifiedColorProcessingEngine");
      UnifiedColorProcessingEngine = _UnifiedColorProcessingEngine;
      getSharedDependencies = /* @__PURE__ */ __name(() => {
        const globalSystem = globalThis.year3000System;
        return {
          settingsManager: globalSystem?.settingsManager,
          performanceAnalyzer: globalSystem?.performanceAnalyzer || globalSystem?.facadeCoordinator?.getCachedNonVisualSystem?.("PerformanceAnalyzer")
        };
      }, "getSharedDependencies");
      ({ settingsManager, performanceAnalyzer } = getSharedDependencies());
      globalUnifiedColorProcessingEngine = new UnifiedColorProcessingEngine(settingsManager, performanceAnalyzer);
    }
  });

  // src-js/ui/managers/Card3DManager.ts
  var _Card3DManager, Card3DManager;
  var init_Card3DManager = __esm({
    "src-js/ui/managers/Card3DManager.ts"() {
      "use strict";
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      init_UnifiedEventBus();
      _Card3DManager = class _Card3DManager {
        constructor(performanceMonitor, settingsManager2, utils) {
          this.initialized = false;
          this.cardQuerySelector = ".sn-card, .main-card-card, .main-card-cardContainer, .main-gridContainer-gridContainer.main-gridContainer-fixedWidth";
          this.cardEventHandlers = /* @__PURE__ */ new WeakMap();
          // Year 3000 music integration
          this.musicSyncService = null;
          // Quality scaling state
          this.currentQualityLevel = null;
          this.qualityCapabilities = [];
          // Cross-system effect coordination
          this.effectCoordinationCallbacks = /* @__PURE__ */ new Set();
          this.config = {
            perspective: 1e3,
            maxRotation: 5,
            scale: 1.02,
            transitionSpeed: "200ms",
            glowOpacity: 0.8,
            selector: ".main-card-card, .main-card-cardContainer, .main-grid-grid > *, .main-shelf-shelf > * > *",
            // Year 3000 music enhancement parameters
            depthMultiplier: 1.5,
            musicResponseStrength: 0.8,
            beatSyncIntensity: 0.6,
            effectIntensityMultiplier: 1.2
          };
          this.performanceMonitor = performanceMonitor;
          this.settingsManager = settingsManager2;
          this.utils = utils;
          this.cards = document.querySelectorAll(this.config.selector);
          this.musicTemperatureMapper = new EmotionalTemperatureMapper(true);
          this.oklabProcessor = new OKLABColorProcessor(true);
          this.effectPreset = OKLABColorProcessor.getPreset("VIBRANT");
          this.effectState = {
            currentMusicMood: "neutral",
            musicIntensity: 0.5,
            beatPhase: 0,
            lastBeatTime: 0,
            effectIntensityLevel: 0,
            dynamicAccentHex: "#cba6f7",
            // Catppuccin mauve fallback
            dynamicAccentRgb: "203,166,247",
            overallIntensityLevel: 0.5
          };
          this.boundHandleSettingsChange = this.handleSettingsChange.bind(this);
        }
        static getInstance(performanceMonitor, settingsManager2, utils) {
          if (!_Card3DManager.instance) {
            _Card3DManager.instance = new _Card3DManager(
              performanceMonitor,
              settingsManager2,
              utils
            );
          }
          return _Card3DManager.instance;
        }
        async initialize() {
          if (this.initialized) return;
          const quality = this.performanceMonitor.shouldReduceQuality();
          if (quality) {
            if (false) {
              console.log(
                `[Card3DManager] Performance is low. 3D effects disabled. Current quality: ${quality}`
              );
              return;
            }
          }
          this.cards = document.querySelectorAll(this.config.selector);
          await this.applyEventListeners();
          await this.initializeMusicIntegration();
          this.initializeCrossSystemCoordination();
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this.boundHandleSettingsChange
          );
          this.initialized = true;
        }
        async healthCheck() {
          const elements = document.querySelectorAll(this.cardQuerySelector);
          if (elements.length > 0) {
            return {
              healthy: true,
              ok: true,
              details: `Found ${elements.length} cards to manage.`,
              issues: [],
              system: "Card3DManager"
            };
          }
          return {
            healthy: false,
            ok: false,
            details: "No card elements found with the configured selector.",
            issues: ["No card elements found with the configured selector."],
            system: "Card3DManager"
          };
        }
        updateAnimation(deltaTime) {
        }
        apply3DMode(mode) {
          console.log(`[Card3DManager] Applying 3D mode: ${mode}`);
          if (mode === "disabled") {
            this.destroy();
          } else {
            this.initialize();
          }
        }
        get shouldEnable3DEffects() {
          const quality = this.performanceMonitor.shouldReduceQuality();
          const setting = this.settingsManager.get("sn-enable3dCards");
          return !quality && setting !== "disabled";
        }
        async applyEventListeners() {
          this.cards.forEach((card) => {
            if (this.cardEventHandlers.has(card)) return;
            const moveHandler = /* @__PURE__ */ __name((e) => this.handleMouseMove(card, e), "moveHandler");
            const leaveHandler = /* @__PURE__ */ __name(() => this.handleMouseLeave(card), "leaveHandler");
            this.cardEventHandlers.set(card, {
              move: moveHandler,
              leave: leaveHandler
            });
            card.addEventListener("mousemove", moveHandler);
            card.addEventListener("mouseleave", leaveHandler);
          });
        }
        handleMouseMove(card, e) {
          if (!this.shouldEnable3DEffects) return;
          const { clientX, clientY } = e;
          const { top, left, width, height } = card.getBoundingClientRect();
          const x = clientX - left;
          const y = clientY - top;
          const rotateX = this.config.maxRotation * (y - height / 2) / (height / 2);
          const rotateY = -this.config.maxRotation * (x - width / 2) / (width / 2);
          card.style.transform = `perspective(${this.config.perspective}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale3d(${this.config.scale}, ${this.config.scale}, ${this.config.scale})`;
          card.style.transition = `transform ${this.config.transitionSpeed} ease-out`;
          this.applyGlow(card, x, y, width, height);
        }
        handleMouseLeave(card) {
          card.style.transform = "perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)";
          card.style.transition = "transform 600ms ease-in-out";
          this.removeGlow(card);
        }
        applyGlow(card, x, y, width, height) {
          let glowElement = card.querySelector(".card-glow");
          if (!glowElement) {
            glowElement = document.createElement("div");
            glowElement.className = "card-glow";
            card.appendChild(glowElement);
          }
          const { dynamicAccentRgb, musicIntensity, beatPhase, effectIntensityLevel } = this.effectState;
          const baseOpacity = this.config.glowOpacity;
          const musicModulation = 1 + (musicIntensity - 0.5) * this.config.musicResponseStrength;
          const beatModulation = 1 + Math.sin(beatPhase) * this.config.beatSyncIntensity * 0.3;
          const effectModulation = 1 + effectIntensityLevel * this.config.effectIntensityMultiplier * 0.4;
          const enhancedOpacity = baseOpacity * musicModulation * beatModulation * effectModulation;
          const finalOpacity = Math.max(0.1, Math.min(1, enhancedOpacity));
          const baseRadius = 40;
          const animationRadius = baseRadius + Math.sin(beatPhase * 0.5) * 8 * this.config.beatSyncIntensity;
          glowElement.style.background = `radial-gradient(circle at ${x}px ${y}px, 
      rgba(${dynamicAccentRgb}, ${finalOpacity}) 0%, 
      rgba(${dynamicAccentRgb}, ${finalOpacity * 0.6}) 20%, 
      transparent ${animationRadius}%)`;
        }
        removeGlow(card) {
          const glowElement = card.querySelector(".card-glow");
          if (glowElement) {
            glowElement.style.background = "transparent";
          }
        }
        destroy() {
          this.cards.forEach((card) => {
            const handlers = this.cardEventHandlers.get(card);
            if (handlers) {
              card.removeEventListener("mousemove", handlers.move);
              card.removeEventListener("mouseleave", handlers.leave);
              this.cardEventHandlers.delete(card);
            }
            this.removeGlow(card);
            card.style.transform = "";
            card.style.transition = "";
          });
          this.initialized = false;
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this.boundHandleSettingsChange
          );
        }
        handleSettingsChange(event) {
          const { key, value } = event.detail || {};
          if (false) {
            this.apply3DMode(value);
          }
        }
        // ===================================================================
        // Year 3000 Music Integration Methods
        // ===================================================================
        /**
         * Initialize music integration with sync and mood analysis systems
         */
        async initializeMusicIntegration() {
          try {
            unifiedEventBus.subscribe("colors:extracted", (event) => {
              this.onColorsExtracted(event);
            }, "Card3DManager");
            unifiedEventBus.subscribe("colors:harmonized", (event) => {
              this.onColorsHarmonized(event);
            }, "Card3DManager");
            unifiedEventBus.subscribe("music:beat", (event) => {
              this.onMusicBeat(event);
            }, "Card3DManager");
            unifiedEventBus.subscribe("music:dramatic-peak-detected", (event) => {
              this.onIntensityEvent(event);
            }, "Card3DManager");
            this.updateDynamicAccentColor();
            console.log("[Card3DManager] \u2705 Year 3000 music integration initialized");
          } catch (error) {
            console.error("[Card3DManager] Failed to initialize music integration:", error);
          }
        }
        /**
         * Handle color extraction events
         */
        onColorsExtracted(event) {
          const { rawColors, musicData } = event;
          if (musicData) {
            const musicResult = this.musicTemperatureMapper.mapMusicToEmotionalTemperature(musicData);
            this.updateMusicState(musicResult);
          }
        }
        /**
         * Handle color harmonization events
         */
        onColorsHarmonized(event) {
          const { processedColors, coordinationMetrics } = event;
          if (processedColors.VIBRANT) {
            const oklabResult = this.oklabProcessor.processColor(processedColors.VIBRANT, this.effectPreset);
            this.effectState.dynamicAccentHex = oklabResult.enhancedHex;
            this.effectState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
          }
          if (coordinationMetrics?.overallIntensityLevel !== void 0) {
            this.effectState.overallIntensityLevel = coordinationMetrics.overallIntensityLevel;
          }
        }
        /**
         * Handle music beat events for rhythm-responsive 3D effects
         */
        onMusicBeat(event) {
          const { beat, intensity, timestamp } = event;
          this.effectState.beatPhase += Math.PI * 2 * this.config.beatSyncIntensity;
          this.effectState.lastBeatTime = timestamp || Date.now();
          if (intensity > 0.7) {
            this.applyBeatSyncDepthPulse(intensity);
          }
        }
        /**
         * Handle intensity events for enhanced 3D effects
         */
        onIntensityEvent(event) {
          const { intensity, type } = event;
          this.effectState.effectIntensityLevel = intensity;
          if (intensity > 0.8) {
            this.applyEnhancedDepthDistortion(intensity);
          }
        }
        /**
         * Update music state from audio analysis
         */
        updateMusicState(musicResult) {
          this.effectState.currentMusicMood = musicResult.primaryEmotion;
          this.effectState.musicIntensity = musicResult.intensity;
          switch (musicResult.primaryEmotion) {
            case "energetic":
            case "aggressive":
              this.effectPreset = OKLABColorProcessor.getPreset("COSMIC");
              break;
            case "calm":
            case "ambient":
              this.effectPreset = OKLABColorProcessor.getPreset("SUBTLE");
              break;
            default:
              this.effectPreset = OKLABColorProcessor.getPreset("VIBRANT");
          }
        }
        /**
         * Apply beat-synchronized depth pulse to all cards
         */
        applyBeatSyncDepthPulse(intensity) {
          const pulseScale = 1 + intensity * 0.15 * this.config.beatSyncIntensity;
          this.cards.forEach((card) => {
            if (card instanceof HTMLElement) {
              const currentTransform = card.style.transform || "";
              const scaledTransform = currentTransform.replace(/scale3d\([^)]*\)/, `scale3d(${pulseScale}, ${pulseScale}, ${pulseScale})`);
              card.style.transform = scaledTransform || `scale3d(${pulseScale}, ${pulseScale}, ${pulseScale})`;
              card.style.transition = "transform 100ms ease-out";
              setTimeout(() => {
                if (card.style.transform.includes(`scale3d(${pulseScale}`)) {
                  card.style.transform = card.style.transform.replace(/scale3d\([^)]*\)/, "scale3d(1, 1, 1)");
                }
              }, 200);
            }
          });
        }
        /**
         * Apply enhanced depth distortion for intense moments
         */
        applyEnhancedDepthDistortion(intensity) {
          const enhancedPerspective = this.config.perspective * (1 + intensity * this.config.effectIntensityMultiplier);
          const enhancedRotation = this.config.maxRotation * (1 + intensity * 0.8);
          this.cards.forEach((card) => {
            if (card instanceof HTMLElement) {
              const enhancedTransform = `perspective(${enhancedPerspective}px) rotateX(${enhancedRotation * 0.3}deg) rotateY(${enhancedRotation * 0.2}deg)`;
              card.style.transform = enhancedTransform;
              card.style.transition = "transform 800ms ease-out";
              setTimeout(() => {
                card.style.transform = "perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)";
                card.style.transition = "transform 1200ms ease-in-out";
              }, 1500);
            }
          });
        }
        /**
         * Update dynamic accent color from CSS variables
         */
        updateDynamicAccentColor() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const dynamicAccentHex = computedStyle.getPropertyValue("--sn-dynamic-accent-hex").trim() || computedStyle.getPropertyValue("--sn-color-accent-hex").trim() || computedStyle.getPropertyValue("--spice-accent").trim();
          const dynamicAccentRgb = computedStyle.getPropertyValue("--sn-dynamic-accent-rgb").trim() || computedStyle.getPropertyValue("--sn-color-accent-rgb").trim() || computedStyle.getPropertyValue("--spice-rgb-accent").trim();
          if (dynamicAccentHex && dynamicAccentHex !== "") {
            this.effectState.dynamicAccentHex = dynamicAccentHex;
          }
          if (dynamicAccentRgb && dynamicAccentRgb !== "") {
            this.effectState.dynamicAccentRgb = dynamicAccentRgb;
          }
        }
        /**
         * Set music sync service for music integration
         */
        setMusicSyncService(musicSyncService) {
          this.musicSyncService = musicSyncService;
        }
        /**
         * Get current effect state for debugging
         */
        getEffectState() {
          return { ...this.effectState };
        }
        // ===================================================================
        // Quality Scaling Implementation (QualityScalingCapable)
        // ===================================================================
        /**
         * Set quality level for 3D effects
         */
        setQualityLevel(level) {
          this.currentQualityLevel = level;
          switch (level) {
            case "low":
              this.config.perspective = 900;
              this.config.maxRotation = 3;
              this.config.depthMultiplier = 1.2;
              this.config.musicResponseStrength = 0.5;
              this.config.beatSyncIntensity = 0.4;
              this.config.effectIntensityMultiplier = 0.8;
              break;
            case "medium":
              this.config.perspective = 1e3;
              this.config.maxRotation = 5;
              this.config.depthMultiplier = 1.5;
              this.config.musicResponseStrength = 0.8;
              this.config.beatSyncIntensity = 0.6;
              this.config.effectIntensityMultiplier = 1.2;
              break;
            case "high":
              this.config.perspective = 1200;
              this.config.maxRotation = 7;
              this.config.depthMultiplier = 1.8;
              this.config.musicResponseStrength = 1;
              this.config.beatSyncIntensity = 0.8;
              this.config.effectIntensityMultiplier = 1.5;
              break;
            default:
              this.config.perspective = 1e3;
              this.config.maxRotation = 5;
              this.config.depthMultiplier = 1.5;
              this.config.musicResponseStrength = 0.8;
              this.config.beatSyncIntensity = 0.6;
              this.config.effectIntensityMultiplier = 1.2;
              break;
          }
          console.log(`[Card3DManager] Quality level set to: ${level}`);
        }
        /**
         * Adjust quality level (QualityScalingCapable interface)
         */
        adjustQuality(level) {
          this.setQualityLevel(level);
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const cardCount = this.cards.length;
          const baseImpact = cardCount * 0.1;
          const depthImpact = this.config.depthMultiplier * 0.2;
          const musicImpact = this.config.musicResponseStrength * 0.15;
          const effectImpact = this.config.effectIntensityMultiplier * 0.1;
          return {
            fps: 60,
            frameTime: baseImpact + depthImpact + musicImpact + effectImpact,
            memoryUsage: cardCount * 0.05,
            // Minimal memory impact
            cpuUsage: (baseImpact + depthImpact) * 100
          };
        }
        /**
         * Reduce quality level
         */
        reduceQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.config.depthMultiplier = Math.max(0.5, this.config.depthMultiplier - amount);
          this.config.musicResponseStrength = Math.max(0.1, this.config.musicResponseStrength - amount);
          this.config.beatSyncIntensity = Math.max(0.1, this.config.beatSyncIntensity - amount);
          this.config.effectIntensityMultiplier = Math.max(0.5, this.config.effectIntensityMultiplier - amount);
          console.log(`[Card3DManager] Quality reduced by ${amount}`);
        }
        /**
         * Increase quality level
         */
        increaseQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.config.depthMultiplier = Math.min(2, this.config.depthMultiplier + amount);
          this.config.musicResponseStrength = Math.min(1.5, this.config.musicResponseStrength + amount);
          this.config.beatSyncIntensity = Math.min(1, this.config.beatSyncIntensity + amount);
          this.config.effectIntensityMultiplier = Math.min(2, this.config.effectIntensityMultiplier + amount);
          console.log(`[Card3DManager] Quality increased by ${amount}`);
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          if (this.qualityCapabilities.length === 0) {
            this.qualityCapabilities = [
              {
                name: "3D Perspective",
                enabled: true,
                qualityLevel: "medium"
              },
              {
                name: "Music-Reactive Glow",
                enabled: true,
                qualityLevel: "low"
              },
              {
                name: "Beat Sync Effects",
                enabled: true,
                qualityLevel: "low"
              },
              {
                name: "Intensity Distortion",
                enabled: true,
                qualityLevel: "medium"
              },
              {
                name: "Music Modulation",
                enabled: true,
                qualityLevel: "low"
              }
            ];
          }
          return this.qualityCapabilities;
        }
        /**
         * Refresh color state for efficient color system updates
         */
        async refreshColorState(trigger) {
          try {
            this.updateDynamicAccentColor();
            if (this.effectState.dynamicAccentHex) {
              const oklabResult = this.oklabProcessor.processColor(
                this.effectState.dynamicAccentHex,
                this.effectPreset
              );
              this.effectState.dynamicAccentHex = oklabResult.enhancedHex;
              this.effectState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            }
            console.log(`[Card3DManager] Color state refreshed for trigger: ${trigger}`);
          } catch (error) {
            console.error("[Card3DManager] Error refreshing color state:", error);
          }
        }
        // ===================================================================
        // Cross-System Effect Coordination
        // ===================================================================
        /**
         * Register for effect coordination updates
         */
        onEffectCoordination(callback) {
          this.effectCoordinationCallbacks.add(callback);
          return () => {
            this.effectCoordinationCallbacks.delete(callback);
          };
        }
        /**
         * Synchronize effect state with other systems
         */
        synchronizeEffectState(sharedState) {
          if (sharedState.currentMusicMood) {
            this.effectState.currentMusicMood = sharedState.currentMusicMood;
          }
          if (sharedState.musicIntensity !== void 0) {
            this.effectState.musicIntensity = sharedState.musicIntensity;
          }
          if (sharedState.beatPhase !== void 0) {
            this.effectState.beatPhase = sharedState.beatPhase;
          }
          if (sharedState.effectIntensityLevel !== void 0) {
            this.effectState.effectIntensityLevel = sharedState.effectIntensityLevel;
          }
          if (sharedState.overallIntensityLevel !== void 0) {
            this.effectState.overallIntensityLevel = sharedState.overallIntensityLevel;
          }
          if (sharedState.dynamicAccentHex) {
            this.effectState.dynamicAccentHex = sharedState.dynamicAccentHex;
          }
          if (sharedState.dynamicAccentRgb) {
            this.effectState.dynamicAccentRgb = sharedState.dynamicAccentRgb;
          }
          this.broadcastEffectState();
        }
        /**
         * Broadcast effect state to coordinated systems
         */
        broadcastEffectState() {
          this.effectCoordinationCallbacks.forEach((callback) => {
            try {
              callback(this.effectState);
            } catch (error) {
              console.error("[Card3DManager] Error in effect coordination callback:", error);
            }
          });
        }
        /**
         * Enhanced music state update with coordination
         */
        updateMusicStateWithCoordination(musicResult) {
          this.updateMusicState(musicResult);
          this.broadcastEffectState();
          unifiedEventBus.emit("visual-effects:coordination", {
            source: "Card3DManager",
            state: this.convertToVisualEffectsState(this.effectState),
            timestamp: Date.now()
          });
        }
        /**
         * Enhanced beat event with coordination
         */
        onMusicBeatWithCoordination(event) {
          this.onMusicBeat(event);
          this.broadcastEffectState();
          unifiedEventBus.emit("music:beat-sync", {
            source: "Card3DManager",
            beatPhase: this.effectState.beatPhase,
            lastBeatTime: this.effectState.lastBeatTime,
            timestamp: Date.now()
          });
        }
        /**
         * Enhanced intensity event with coordination
         */
        onIntensityEventWithCoordination(event) {
          this.onIntensityEvent(event);
          this.broadcastEffectState();
          unifiedEventBus.emit("music:dramatic-sync", {
            source: "Card3DManager",
            dramaticLevel: this.effectState.effectIntensityLevel,
            type: event.type,
            timestamp: Date.now()
          });
        }
        /**
         * Initialize cross-system effect coordination
         */
        initializeCrossSystemCoordination() {
          try {
            unifiedEventBus.subscribe("visual-effects:coordination", (event) => {
              if (event.source !== "Card3DManager") {
                this.synchronizeEffectState(this.convertFromVisualEffectsState(event.state));
              }
            }, "Card3DManager");
            unifiedEventBus.subscribe("music:beat-sync", (event) => {
              if (event.source !== "Card3DManager") {
                this.effectState.beatPhase = event.beatPhase;
                this.effectState.lastBeatTime = event.lastBeatTime;
              }
            }, "Card3DManager");
            unifiedEventBus.subscribe("music:dramatic-sync", (event) => {
              if (event.source !== "Card3DManager") {
                this.effectState.effectIntensityLevel = event.dramaticLevel;
              }
            }, "Card3DManager");
            console.log("[Card3DManager] \u2705 Cross-system effect coordination initialized");
          } catch (error) {
            console.error("[Card3DManager] Failed to initialize cross-system coordination:", error);
          }
        }
        /**
         * Convert Card3DEffectState to VisualEffectsState for event system compatibility
         */
        convertToVisualEffectsState(state) {
          return {
            intensity: state.effectIntensityLevel,
            colorTemperature: 6500,
            // Default value
            animationScale: state.musicIntensity,
            dominantEmotion: state.currentMusicMood,
            resonance: state.musicIntensity,
            // Legacy compatibility properties
            symbioticResonance: state.musicIntensity,
            surfaceFluidityIndex: state.musicIntensity,
            animationScaleRate: state.effectIntensityLevel,
            emotionalTemperature: 6500,
            pulsingCycle: state.beatPhase,
            cinematicIntensity: state.effectIntensityLevel
          };
        }
        /**
         * Convert VisualEffectsState to Card3DEffectState for internal compatibility
         */
        convertFromVisualEffectsState(state) {
          return {
            currentMusicMood: state.dominantEmotion,
            musicIntensity: state.intensity,
            effectIntensityLevel: state.intensity,
            overallIntensityLevel: state.intensity
          };
        }
      };
      __name(_Card3DManager, "Card3DManager");
      Card3DManager = _Card3DManager;
    }
  });

  // src-js/utils/performance/ViewportAwarenessManager.ts
  var _ViewportController, ViewportController, ViewportManager;
  var init_ViewportAwarenessManager = __esm({
    "src-js/utils/performance/ViewportAwarenessManager.ts"() {
      "use strict";
      _ViewportController = class _ViewportController {
        constructor() {
          this.observers = /* @__PURE__ */ new Map();
          this.trackedElements = /* @__PURE__ */ new Map();
          this.isSupported = typeof IntersectionObserver !== "undefined";
          if (!this.isSupported) {
            console.warn("[ViewportController] IntersectionObserver not supported, falling back to always-visible behavior");
          }
        }
        static getInstance() {
          if (!_ViewportController.instance) {
            _ViewportController.instance = new _ViewportController();
          }
          return _ViewportController.instance;
        }
        /**
         * Track an element's visibility with callback
         */
        trackElement(element, callback, options = {}) {
          if (!this.isSupported) {
            const fallbackState = {
              isVisible: true,
              intersectionRatio: 1,
              lastVisibilityChange: Date.now(),
              element
            };
            callback(fallbackState);
            return () => {
            };
          }
          const opts = {
            visibilityThreshold: 0.1,
            rootMargin: "50px",
            trackRootElement: false,
            ...options
          };
          const observerKey = this.getObserverKey(opts);
          let observer = this.observers.get(observerKey);
          if (!observer) {
            observer = new IntersectionObserver(
              (entries) => this.handleIntersectionChanges(entries),
              {
                threshold: opts.visibilityThreshold,
                rootMargin: opts.rootMargin,
                root: opts.rootSelector ? document.querySelector(opts.rootSelector) : null
              }
            );
            this.observers.set(observerKey, observer);
          }
          const initialState = {
            isVisible: false,
            // Will be updated by intersection callback
            intersectionRatio: 0,
            lastVisibilityChange: Date.now(),
            element
          };
          this.trackedElements.set(element, {
            callback,
            options: opts,
            state: initialState
          });
          observer.observe(element);
          return () => this.untrackElement(element);
        }
        /**
         * Check if an element is currently visible
         */
        isElementVisible(element) {
          const tracked = this.trackedElements.get(element);
          return tracked?.state.isVisible ?? true;
        }
        /**
         * Get current visibility state for an element
         */
        getVisibilityState(element) {
          return this.trackedElements.get(element)?.state ?? null;
        }
        /**
         * Stop tracking an element
         */
        untrackElement(element) {
          const tracked = this.trackedElements.get(element);
          if (!tracked) return;
          const observerKey = this.getObserverKey(tracked.options);
          const observer = this.observers.get(observerKey);
          if (observer) {
            observer.unobserve(element);
          }
          this.trackedElements.delete(element);
        }
        /**
         * Track viewport visibility of the main Spotify container
         */
        trackSpotifyContainer(callback) {
          const spotifySelectors = [
            ".Root__main-view",
            '[data-testid="topbar"]',
            ".main-view-container",
            "#main"
          ];
          let element = null;
          for (const selector of spotifySelectors) {
            element = document.querySelector(selector);
            if (element) break;
          }
          if (!element) {
            console.warn("[ViewportController] Could not find Spotify main container, using document.body");
            element = document.body;
          }
          return this.trackElement(element, callback, {
            visibilityThreshold: 0.1,
            rootMargin: "0px",
            trackRootElement: true
          });
        }
        /**
         * Bulk check visibility of multiple elements
         */
        checkBulkVisibility(elements) {
          const results = /* @__PURE__ */ new Map();
          for (const element of elements) {
            results.set(element, this.isElementVisible(element));
          }
          return results;
        }
        /**
         * Cleanup all observers and tracked elements
         */
        destroy() {
          for (const observer of this.observers.values()) {
            observer.disconnect();
          }
          this.observers.clear();
          this.trackedElements.clear();
        }
        handleIntersectionChanges(entries) {
          for (const entry of entries) {
            const tracked = this.trackedElements.get(entry.target);
            if (!tracked) continue;
            const wasVisible = tracked.state.isVisible;
            const isNowVisible = entry.isIntersecting;
            tracked.state = {
              isVisible: isNowVisible,
              intersectionRatio: entry.intersectionRatio,
              lastVisibilityChange: wasVisible !== isNowVisible ? Date.now() : tracked.state.lastVisibilityChange,
              element: entry.target
            };
            if (wasVisible !== isNowVisible) {
              try {
                tracked.callback(tracked.state);
              } catch (error) {
                console.error("[ViewportController] Error in visibility callback:", error);
              }
            }
          }
        }
        getObserverKey(options) {
          return `${options.visibilityThreshold}-${options.rootMargin}-${options.rootSelector || "viewport"}`;
        }
      };
      __name(_ViewportController, "ViewportController");
      ViewportController = _ViewportController;
      ViewportManager = ViewportController.getInstance();
    }
  });

  // src-js/visual/base/ViewportAwareSystem.ts
  var _ViewportAwareSystem, ViewportAwareSystem;
  var init_ViewportAwareSystem = __esm({
    "src-js/visual/base/ViewportAwareSystem.ts"() {
      "use strict";
      init_ViewportAwarenessManager();
      init_UnifiedEventBus();
      _ViewportAwareSystem = class _ViewportAwareSystem {
        constructor(options = {}) {
          this.initialized = false;
          this.isVisible = true;
          // Default to visible until we know otherwise
          this.visibilityState = null;
          this.animationsPaused = false;
          this.settingsUpdatesPaused = false;
          this.viewportOptions = {
            visibilityThreshold: 0.1,
            rootMargin: "50px",
            pauseAnimationsWhenHidden: true,
            pauseSettingsUpdatesWhenHidden: true,
            resumeDelay: 100,
            ...options
          };
        }
        async initialize() {
          await this.initializeViewportTracking();
          await this.initializeEventSubscriptions();
          await this.initializeSystem();
          this.initialized = true;
        }
        async healthCheck() {
          const systemHealth = await this.performHealthCheck();
          return {
            ...systemHealth,
            details: `${systemHealth.details} | Viewport: ${this.isVisible ? "visible" : "hidden"}`
          };
        }
        updateAnimation(deltaTime) {
          if (this.shouldSkipAnimationUpdate()) {
            return;
          }
          this.performAnimationUpdate(deltaTime);
        }
        destroy() {
          this.cleanupViewportTracking();
          this.cleanupEventSubscriptions();
          this.performDestroy();
        }
        /**
         * Handle settings changes with viewport awareness
         */
        handleSettingsChange(event) {
          if (this.shouldSkipSettingsUpdate()) {
            return;
          }
          this.performSettingsUpdate(event);
        }
        /**
         * Force a repaint/update regardless of visibility
         */
        forceRepaint(reason) {
          this.performForceRepaint?.(reason);
        }
        // Optional hooks for viewport awareness
        onVisibilityChanged(state) {
        }
        onBecomingVisible() {
        }
        onBecomingHidden() {
        }
        async initializeViewportTracking() {
          let targetElement = null;
          if (this.viewportOptions.trackingSelector) {
            targetElement = document.querySelector(this.viewportOptions.trackingSelector);
          }
          if (!targetElement) {
            this.untrackViewport = ViewportManager.trackSpotifyContainer(
              (state) => this.handleVisibilityChange(state)
            );
          } else {
            this.untrackViewport = ViewportManager.trackElement(
              targetElement,
              (state) => this.handleVisibilityChange(state),
              this.viewportOptions
            );
          }
        }
        async initializeEventSubscriptions() {
          this.settingsSubscriptionId = unifiedEventBus.subscribe(
            "settings:changed",
            (data) => this.handleUnifiedSettingsChange(data),
            `ViewportAwareSystem-${this.constructor.name}`
          );
        }
        cleanupEventSubscriptions() {
          if (this.settingsSubscriptionId) {
            unifiedEventBus.unsubscribe(this.settingsSubscriptionId);
            delete this.settingsSubscriptionId;
          }
        }
        handleUnifiedSettingsChange(data) {
          if (this.shouldSkipSettingsUpdate()) {
            return;
          }
          const legacyEvent = new CustomEvent("year3000SystemSettingsChanged", {
            detail: { key: data.settingKey, value: data.newValue }
          });
          this.performSettingsUpdate(legacyEvent);
        }
        handleVisibilityChange(state) {
          const wasVisible = this.isVisible;
          this.isVisible = state.isVisible;
          this.visibilityState = state;
          if (!wasVisible && this.isVisible) {
            this.handleBecomingVisible();
          } else if (wasVisible && !this.isVisible) {
            this.handleBecomingHidden();
          }
          this.onVisibilityChanged(state);
        }
        handleBecomingVisible() {
          if (this.resumeTimeoutId) {
            clearTimeout(this.resumeTimeoutId);
          }
          this.resumeTimeoutId = window.setTimeout(() => {
            this.animationsPaused = false;
            this.settingsUpdatesPaused = false;
            this.onBecomingVisible();
          }, this.viewportOptions.resumeDelay || 100);
        }
        handleBecomingHidden() {
          if (this.viewportOptions.pauseAnimationsWhenHidden) {
            this.animationsPaused = true;
          }
          if (this.viewportOptions.pauseSettingsUpdatesWhenHidden) {
            this.settingsUpdatesPaused = true;
          }
          this.onBecomingHidden();
        }
        shouldSkipAnimationUpdate() {
          return this.animationsPaused || !this.isVisible && (this.viewportOptions.pauseAnimationsWhenHidden ?? true);
        }
        shouldSkipSettingsUpdate() {
          return this.settingsUpdatesPaused || !this.isVisible && (this.viewportOptions.pauseSettingsUpdatesWhenHidden ?? true);
        }
        cleanupViewportTracking() {
          if (this.untrackViewport) {
            this.untrackViewport();
            delete this.untrackViewport;
          }
          if (this.resumeTimeoutId) {
            clearTimeout(this.resumeTimeoutId);
            delete this.resumeTimeoutId;
          }
        }
        /**
         * Get current visibility information for debugging
         */
        getVisibilityInfo() {
          return {
            isVisible: this.isVisible,
            animationsPaused: this.animationsPaused,
            settingsUpdatesPaused: this.settingsUpdatesPaused,
            ...this.visibilityState?.intersectionRatio !== void 0 && {
              intersectionRatio: this.visibilityState.intersectionRatio
            }
          };
        }
      };
      __name(_ViewportAwareSystem, "ViewportAwareSystem");
      ViewportAwareSystem = _ViewportAwareSystem;
    }
  });

  // src-js/ui/managers/GlassmorphismManager.ts
  var _GlassmorphismManager, GlassmorphismManager;
  var init_GlassmorphismManager = __esm({
    "src-js/ui/managers/GlassmorphismManager.ts"() {
      "use strict";
      init_globalConfig();
      init_settingKeys();
      init_OptimizedCSSVariableManager();
      init_ViewportAwareSystem();
      init_ThemeUtilities();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      init_UnifiedEventBus();
      _GlassmorphismManager = class _GlassmorphismManager extends ViewportAwareSystem {
        constructor(config = ADVANCED_SYSTEM_CONFIG, utils = ThemeUtilities_exports, cssBatcher = null, performanceAnalyzer2 = null, settingsManager2, viewportOptions = {}) {
          super({
            visibilityThreshold: 0.2,
            // More generous threshold since glass effects are subtle
            pauseAnimationsWhenHidden: false,
            // Glass effects are mostly static
            pauseSettingsUpdatesWhenHidden: true,
            // Skip expensive glass calculations when hidden
            resumeDelay: 50,
            // Quick resume for UI effects
            ...viewportOptions
          });
          this.cssBatcher = null;
          this.performanceAnalyzer = null;
          this.observers = [];
          // Year 3000 music integration
          this.musicSyncService = null;
          // Quality scaling state
          this.currentQualityLevel = null;
          this.qualityCapabilities = [];
          // Cross-system effect coordination
          this.effectCoordinationCallbacks = /* @__PURE__ */ new Set();
          this.config = config;
          this.utils = utils;
          this.cssBatcher = cssBatcher;
          this.performanceAnalyzer = performanceAnalyzer2;
          this.settingsManager = settingsManager2;
          this.isSupported = this.detectBackdropFilterSupport();
          this.currentIntensity = "balanced";
          this.musicTemperatureMapper = new EmotionalTemperatureMapper(true);
          this.oklabProcessor = new OKLABColorProcessor(true);
          this.effectPreset = OKLABColorProcessor.getPreset("STANDARD");
          this.effectState = {
            currentMusicMood: "neutral",
            musicIntensity: 0.5,
            beatPhase: 0,
            lastBeatTime: 0,
            effectIntensityLevel: 0,
            dynamicAccentHex: "#cba6f7",
            // Catppuccin mauve fallback
            dynamicAccentRgb: "203,166,247",
            overallIntensityLevel: 0.5,
            genreStyle: "standard",
            animationRate: 1
          };
        }
        static getInstance() {
          if (!_GlassmorphismManager.instance) {
            throw new Error("GlassmorphismManager instance not initialized");
          }
          return _GlassmorphismManager.instance;
        }
        // Implement abstract methods from ViewportAwareSystem
        async initializeSystem() {
          const year3000System = globalThis.year3000System;
          this.cssController = year3000System?.cssController || getGlobalOptimizedCSSController();
          const initialIntensity = this.settingsManager.get("sn-glassmorphism-level");
          this.applyGlassmorphismSettings(initialIntensity);
          await this.initializeMusicIntegration();
        }
        async performHealthCheck() {
          return {
            healthy: true,
            ok: true,
            details: "GlassmorphismManager is operational.",
            issues: [],
            system: "GlassmorphismManager"
          };
        }
        performAnimationUpdate(deltaTime) {
        }
        performDestroy() {
          this.observers.forEach((observer) => observer.disconnect());
          this.observers = [];
        }
        performSettingsUpdate(event) {
          const customEvent = event;
          const { key, value } = customEvent.detail || {};
          if (key === GLASS_LEVEL_KEY) {
            this.applyGlassmorphismSettings(value);
            this.updateGlassVariables(this.currentIntensity);
          }
        }
        // Override viewport integration hooks for glassmorphism-specific behavior
        onBecomingVisible() {
          if (this.currentIntensity !== "disabled") {
            const root = document.documentElement;
            const computedStyle = getComputedStyle(root);
            const accentRgb = computedStyle.getPropertyValue("--spice-rgb-accent").trim();
            if (accentRgb && accentRgb !== "") {
              this.updateGlassColors(`rgb(${accentRgb})`, `rgb(${accentRgb})`);
            }
          }
        }
        onBecomingHidden() {
        }
        // Settings change handling is now managed by ViewportAwareSystem base class
        detectBackdropFilterSupport() {
          try {
            return CSS.supports("backdrop-filter", "blur(1px)") || CSS.supports("-webkit-backdrop-filter", "blur(1px)");
          } catch (error) {
            console.warn(
              "StarryNight: CSS.supports not available, assuming no backdrop-filter support",
              error
            );
            return false;
          }
        }
        applyGlassmorphismSettings(intensity) {
          const body = document.body;
          body.classList.remove(
            "sn-glass-disabled",
            "sn-glass-minimal",
            "sn-glass-balanced",
            "sn-glass-intense"
          );
          body.classList.add(`sn-glass-${intensity}`);
          this.currentIntensity = intensity;
          this.updateGlassVariables(intensity);
        }
        updateGlassVariables(intensity) {
          const root = document.documentElement;
          const shouldReduceQuality = this.performanceAnalyzer?.shouldReduceQuality() || false;
          let blurValue, opacityValue, saturationValue;
          switch (intensity) {
            case "disabled":
              root.style.removeProperty("--glass-blur");
              root.style.removeProperty("--glass-opacity");
              root.style.removeProperty("--glass-saturation");
              return;
            case "minimal":
              blurValue = shouldReduceQuality ? "2px" : "3px";
              opacityValue = "0.05";
              saturationValue = "1.05";
              break;
            case "moderate":
              blurValue = shouldReduceQuality ? "3px" : "5px";
              opacityValue = "0.08";
              saturationValue = "1.15";
              break;
            case "intense":
              blurValue = shouldReduceQuality ? "6px" : "8px";
              opacityValue = "0.15";
              saturationValue = "1.4";
              break;
            case "balanced":
            default:
              blurValue = shouldReduceQuality ? "4px" : "6px";
              opacityValue = "0.1";
              saturationValue = "1.2";
              break;
          }
          const musicModulations = this.calculateMusicModulations();
          const finalBlur = this.modulateBlurValue(blurValue, musicModulations);
          const finalOpacity = this.modulateOpacityValue(opacityValue, musicModulations);
          const finalSaturation = this.modulateSaturationValue(saturationValue, musicModulations);
          const glassPropertiesVariables = {
            "--glass-blur": finalBlur,
            "--glass-opacity": finalOpacity,
            "--glass-saturation": finalSaturation,
            "--glass-animation-rate": `${this.effectState.animationRate}s`,
            "--glass-visual-effects-level": this.effectState.overallIntensityLevel.toString()
          };
          this.cssController.batchSetVariables(
            "GlassmorphismManager",
            glassPropertiesVariables,
            "high",
            // High priority for glass effect properties - affects visual perception
            "glass-properties-update"
          );
        }
        updateGlassColors(primaryColor, secondaryColor) {
          if (this.currentIntensity === "disabled") return;
          const glassPrimary = this.convertToGlassColor(primaryColor, 0.1);
          const glassSecondary = this.convertToGlassColor(secondaryColor, 0.08);
          const glassColorVariables = {
            "--glass-background": glassPrimary,
            "--glass-border": glassSecondary
          };
          this.cssController.batchSetVariables(
            "GlassmorphismManager",
            glassColorVariables,
            "high",
            // High priority for glass color updates - affects visual aesthetics
            "glass-color-update"
          );
        }
        convertToGlassColor(color3, opacity) {
          try {
            if (typeof color3 !== "string") {
              return this.getThemeAwareFallback(opacity);
            }
            if (color3.startsWith("rgb")) {
              const values = color3.match(/\d+/g);
              if (values && values.length >= 3) {
                return `rgba(${values[0]}, ${values[1]}, ${values[2]}, ${opacity})`;
              }
            }
            if (color3.startsWith("#")) {
              const hex = color3.slice(1);
              const r = parseInt(hex.substring(0, 2), 16);
              const g = parseInt(hex.substring(2, 4), 16);
              const b = parseInt(hex.substring(4, 6), 16);
              if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                return `rgba(${r}, ${g}, ${b}, ${opacity})`;
              }
            }
            return this.getThemeAwareFallback(opacity);
          } catch (error) {
            return this.getThemeAwareFallback(opacity);
          }
        }
        /**
         * Get theme-aware fallback color using Year 3000 dynamic accent cascade
         * Falls back through: --sn-dynamic-accent-rgb → --sn-color-accent-rgb → --spice-rgb-accent → Catppuccin mauve
         */
        getThemeAwareFallback(opacity) {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          if (this.effectState.dynamicAccentRgb && this.effectState.dynamicAccentRgb !== "203,166,247") {
            return `rgba(${this.effectState.dynamicAccentRgb}, ${opacity})`;
          }
          const dynamicAccentRgb = computedStyle.getPropertyValue("--sn-dynamic-accent-rgb").trim() || computedStyle.getPropertyValue("--sn-color-accent-rgb").trim() || computedStyle.getPropertyValue("--spice-rgb-accent").trim();
          if (dynamicAccentRgb && dynamicAccentRgb !== "" && !dynamicAccentRgb.includes("undefined")) {
            return `rgba(${dynamicAccentRgb}, ${opacity})`;
          }
          const textRgb = computedStyle.getPropertyValue("--spice-rgb-text").trim();
          if (textRgb && textRgb !== "" && !textRgb.includes("undefined")) {
            return `rgba(${textRgb}, ${opacity})`;
          }
          return `rgba(203, 166, 247, ${opacity})`;
        }
        // ===================================================================
        // Year 3000 Consciousness Integration Methods
        // ===================================================================
        /**
         * Initialize visual-effects integration with music sync and emotional systems
         */
        async initializeMusicIntegration() {
          try {
            unifiedEventBus.subscribe("colors:extracted", (event) => {
              this.onColorsExtracted(event);
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("colors:harmonized", (event) => {
              this.onColorsHarmonized(event);
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("music:beat", (event) => {
              this.onMusicBeat(event);
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("music:dramatic-peak-detected", (event) => {
              this.onCinematicDramaEvent(event);
            }, "GlassmorphismManager");
            this.updateDynamicAccentColor();
            this.initializeCrossSystemCoordination();
            console.log("[GlassmorphismManager] \u2705 Year 3000 visual-effects integration initialized");
          } catch (error) {
            console.error("[GlassmorphismManager] Failed to initialize visual-effects integration:", error);
          }
        }
        /**
         * Calculate visual-effects modulations for glass properties
         */
        calculateMusicModulations() {
          const { musicIntensity, beatPhase, effectIntensityLevel, overallIntensityLevel } = this.effectState;
          const musicModulation = 1 + (musicIntensity - 0.5) * 0.4;
          const beatModulation = 1 + Math.sin(beatPhase) * overallIntensityLevel * 0.15;
          const cinematicModulation = 1 + effectIntensityLevel * 0.3;
          const animationModulation = 1 + Math.sin(Date.now() * this.effectState.animationRate * 1e-3) * 0.08;
          return {
            musicModulation,
            beatModulation,
            cinematicModulation,
            animationModulation
          };
        }
        /**
         * Modulate blur value with visual-effects integration
         */
        modulateBlurValue(baseBlur, modulations) {
          const blurValue = parseFloat(baseBlur.replace("px", ""));
          const { musicModulation, beatModulation, animationModulation } = modulations;
          const finalBlur = blurValue * musicModulation * beatModulation * animationModulation;
          return `${Math.max(1, Math.round(finalBlur))}px`;
        }
        /**
         * Modulate opacity value with visual-effects integration
         */
        modulateOpacityValue(baseOpacity, modulations) {
          const opacityValue = parseFloat(baseOpacity);
          const { musicModulation, cinematicModulation, animationModulation } = modulations;
          const finalOpacity = opacityValue * (1 + (musicModulation - 1) * 0.5) * cinematicModulation * animationModulation;
          return Math.max(0.01, Math.min(1, finalOpacity)).toFixed(3);
        }
        /**
         * Modulate saturation value with visual-effects integration
         */
        modulateSaturationValue(baseSaturation, modulations) {
          const saturationValue = parseFloat(baseSaturation);
          const { musicModulation, beatModulation, cinematicModulation } = modulations;
          const finalSaturation = saturationValue * musicModulation * beatModulation * cinematicModulation;
          return Math.max(1, Math.min(3, finalSaturation)).toFixed(2);
        }
        /**
         * Handle color extraction events
         */
        onColorsExtracted(event) {
          const { rawColors, musicData } = event;
          if (musicData) {
            const musicResult = this.musicTemperatureMapper.mapMusicToEmotionalTemperature(musicData);
            this.updateMusicState(musicResult);
          }
        }
        /**
         * Handle color harmonization events
         */
        onColorsHarmonized(event) {
          const { processedColors, coordinationMetrics } = event;
          if (processedColors.VIBRANT) {
            const oklabResult = this.oklabProcessor.processColor(processedColors.VIBRANT, this.effectPreset);
            this.effectState.dynamicAccentHex = oklabResult.enhancedHex;
            this.effectState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
            this.updateGlassColors(oklabResult.enhancedHex, oklabResult.enhancedHex);
          }
          if (coordinationMetrics?.overallIntensityLevel !== void 0) {
            this.effectState.overallIntensityLevel = coordinationMetrics.overallIntensityLevel;
          }
        }
        /**
         * Handle music beat events for rhythm-responsive glass effects
         */
        onMusicBeat(event) {
          const { beat, intensity, timestamp } = event;
          this.effectState.beatPhase += Math.PI * 2 * 0.5;
          this.effectState.lastBeatTime = timestamp || Date.now();
          if (intensity > 0.8 && this.currentIntensity !== "disabled") {
            this.applyBeatSyncGlassPulse(intensity);
          }
        }
        /**
         * Handle cinematic drama events for intense glass effects
         */
        onCinematicDramaEvent(event) {
          const { intensity, type } = event;
          this.effectState.effectIntensityLevel = intensity;
          if (intensity > 0.7 && this.currentIntensity !== "disabled") {
            this.applyDramaticGlassDistortion(intensity);
          }
        }
        /**
         * Update emotional state from music analysis
         */
        updateMusicState(musicResult) {
          this.effectState.currentMusicMood = musicResult.primaryEmotion;
          this.effectState.musicIntensity = musicResult.intensity;
          switch (musicResult.primaryEmotion) {
            case "energetic":
            case "aggressive":
              this.effectState.animationRate = 1.5;
              this.effectPreset = OKLABColorProcessor.getPreset("COSMIC");
              break;
            case "calm":
            case "ambient":
              this.effectState.animationRate = 0.7;
              this.effectPreset = OKLABColorProcessor.getPreset("SUBTLE");
              break;
            default:
              this.effectState.animationRate = 1;
              this.effectPreset = OKLABColorProcessor.getPreset("STANDARD");
          }
        }
        /**
         * Apply beat-synchronized glass pulse effect (respects user setting)
         */
        applyBeatSyncGlassPulse(intensity) {
          if (!this.cssBatcher) return;
          const beatPulseEnabled = false;
          if (!beatPulseEnabled) {
            return;
          }
          const currentIntensityValue = this.getIntensityValue(this.currentIntensity);
          const pulseBlur = intensity * 2 * (currentIntensityValue.opacity * 10);
          const pulseOpacity = intensity * 0.05 * currentIntensityValue.opacity;
          this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-blur", `${pulseBlur}px`);
          this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-opacity", pulseOpacity.toString());
          setTimeout(() => {
            if (this.cssBatcher) {
              this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-blur", "0px");
              this.cssBatcher.queueCSSVariableUpdate("--glass-beat-pulse-opacity", "0");
            }
          }, 150);
        }
        /**
         * Apply dramatic glass distortion for cinematic moments
         */
        applyDramaticGlassDistortion(intensity) {
          if (!this.cssBatcher) return;
          const dramaticBlur = intensity * 4;
          const dramaticSaturation = 1 + intensity * 0.5;
          this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-blur", `${dramaticBlur}px`);
          this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-saturation", dramaticSaturation.toString());
          setTimeout(() => {
            if (this.cssBatcher) {
              this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-blur", "0px");
              this.cssBatcher.queueCSSVariableUpdate("--glass-dramatic-saturation", "1");
            }
          }, 1200);
        }
        /**
         * Update dynamic accent color from CSS variables
         */
        updateDynamicAccentColor() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const dynamicAccentHex = computedStyle.getPropertyValue("--sn-dynamic-accent-hex").trim() || computedStyle.getPropertyValue("--sn-color-accent-hex").trim() || computedStyle.getPropertyValue("--spice-accent").trim();
          const dynamicAccentRgb = computedStyle.getPropertyValue("--sn-dynamic-accent-rgb").trim() || computedStyle.getPropertyValue("--sn-color-accent-rgb").trim() || computedStyle.getPropertyValue("--spice-rgb-accent").trim();
          if (dynamicAccentHex && dynamicAccentHex !== "") {
            this.effectState.dynamicAccentHex = dynamicAccentHex;
          }
          if (dynamicAccentRgb && dynamicAccentRgb !== "") {
            this.effectState.dynamicAccentRgb = dynamicAccentRgb;
          }
        }
        /**
         * Get current visual-effects state for debugging
         */
        getConsciousnessState() {
          return { ...this.effectState };
        }
        // ===================================================================
        // Quality Scaling Implementation (QualityScalingCapable)
        // ===================================================================
        /**
         * Set quality level for glass effects
         */
        setQualityLevel(level) {
          this.adjustQuality(level);
        }
        /**
         * Adjust quality level (QualityScalingCapable interface)
         */
        adjustQuality(level) {
          this.currentQualityLevel = level;
          let adjustedIntensity;
          switch (level) {
            case "low":
              adjustedIntensity = "minimal";
              break;
            case "medium":
              adjustedIntensity = "balanced";
              break;
            case "high":
              adjustedIntensity = "intense";
              break;
            default:
              adjustedIntensity = "balanced";
              break;
          }
          this.applyGlassmorphismSettings(adjustedIntensity);
          console.log(`[GlassmorphismManager] Quality level set to: ${level} (intensity: ${adjustedIntensity})`);
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const intensityImpact = this.currentIntensity === "disabled" ? 0 : this.currentIntensity === "minimal" ? 0.1 : this.currentIntensity === "balanced" ? 0.3 : this.currentIntensity === "intense" ? 0.5 : 0.2;
          const visualEffectsImpact = this.effectState.overallIntensityLevel * 0.1;
          const animationImpact = this.effectState.animationRate > 1 ? 0.05 : 0;
          return {
            fps: 60,
            frameTime: intensityImpact + visualEffectsImpact + animationImpact,
            memoryUsage: intensityImpact * 2,
            // Minimal memory impact
            cpuUsage: (intensityImpact + visualEffectsImpact) * 50
          };
        }
        /**
         * Reduce quality level
         */
        reduceQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.effectState.overallIntensityLevel = Math.max(0.1, this.effectState.overallIntensityLevel - amount);
          this.effectState.animationRate = Math.max(0.5, this.effectState.animationRate - amount * 0.5);
          if (amount > 0.5) {
            switch (this.currentIntensity) {
              case "intense":
                this.applyGlassmorphismSettings("balanced");
                break;
              case "balanced":
                this.applyGlassmorphismSettings("minimal");
                break;
              case "minimal":
                this.applyGlassmorphismSettings("disabled");
                break;
            }
          }
          console.log(`[GlassmorphismManager] Quality reduced by ${amount}`);
        }
        /**
         * Increase quality level
         */
        increaseQuality(amount) {
          if (!this.currentQualityLevel) return;
          this.effectState.overallIntensityLevel = Math.min(1, this.effectState.overallIntensityLevel + amount);
          this.effectState.animationRate = Math.min(2, this.effectState.animationRate + amount * 0.5);
          if (amount > 0.5) {
            switch (this.currentIntensity) {
              case "disabled":
                this.applyGlassmorphismSettings("minimal");
                break;
              case "minimal":
                this.applyGlassmorphismSettings("balanced");
                break;
              case "balanced":
                this.applyGlassmorphismSettings("intense");
                break;
            }
          }
          console.log(`[GlassmorphismManager] Quality increased by ${amount}`);
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          if (this.qualityCapabilities.length === 0) {
            this.qualityCapabilities = [
              {
                name: "Backdrop Filter Blur",
                enabled: this.isSupported && this.currentIntensity !== "disabled",
                qualityLevel: "high"
              },
              {
                name: "Glass Saturation",
                enabled: this.currentIntensity !== "disabled",
                qualityLevel: "low"
              },
              {
                name: "Consciousness Breathing",
                enabled: true,
                qualityLevel: "low"
              },
              {
                name: "Beat Sync Pulse",
                enabled: true,
                qualityLevel: "low"
              },
              {
                name: "Dramatic Distortion",
                enabled: true,
                qualityLevel: "medium"
              }
            ];
          }
          return this.qualityCapabilities;
        }
        /**
         * Refresh color state for efficient color system updates
         */
        async refreshColorState(trigger) {
          try {
            this.updateDynamicAccentColor();
            if (this.effectState.dynamicAccentHex) {
              const oklabResult = this.oklabProcessor.processColor(
                this.effectState.dynamicAccentHex,
                this.effectPreset
              );
              this.effectState.dynamicAccentHex = oklabResult.enhancedHex;
              this.effectState.dynamicAccentRgb = `${oklabResult.enhancedRgb.r},${oklabResult.enhancedRgb.g},${oklabResult.enhancedRgb.b}`;
              this.updateGlassColors(oklabResult.enhancedHex, oklabResult.enhancedHex);
            }
            console.log(`[GlassmorphismManager] Color state refreshed for trigger: ${trigger}`);
          } catch (error) {
            console.error("[GlassmorphismManager] Error refreshing color state:", error);
          }
        }
        // ===================================================================
        // Cross-System Consciousness Coordination
        // ===================================================================
        /**
         * Register for visual-effects coordination updates
         */
        onConsciousnessCoordination(callback) {
          this.effectCoordinationCallbacks.add(callback);
          return () => {
            this.effectCoordinationCallbacks.delete(callback);
          };
        }
        /**
         * Synchronize visual-effects state with other systems
         */
        synchronizeConsciousnessState(sharedState) {
          if (sharedState.currentMusicMood) {
            this.effectState.currentMusicMood = sharedState.currentMusicMood;
          }
          if (sharedState.musicIntensity !== void 0) {
            this.effectState.musicIntensity = sharedState.musicIntensity;
          }
          if (sharedState.beatPhase !== void 0) {
            this.effectState.beatPhase = sharedState.beatPhase;
          }
          if (sharedState.effectIntensityLevel !== void 0) {
            this.effectState.effectIntensityLevel = sharedState.effectIntensityLevel;
          }
          if (sharedState.overallIntensityLevel !== void 0) {
            this.effectState.overallIntensityLevel = sharedState.overallIntensityLevel;
          }
          if (sharedState.dynamicAccentHex) {
            this.effectState.dynamicAccentHex = sharedState.dynamicAccentHex;
          }
          if (sharedState.dynamicAccentRgb) {
            this.effectState.dynamicAccentRgb = sharedState.dynamicAccentRgb;
          }
          if (sharedState.genreStyle) {
            this.effectState.genreStyle = sharedState.genreStyle;
          }
          if (sharedState.animationRate !== void 0) {
            this.effectState.animationRate = sharedState.animationRate;
          }
          this.updateGlassVariables(this.currentIntensity);
          this.broadcastConsciousnessState();
        }
        /**
         * Broadcast visual-effects state to coordinated systems
         */
        broadcastConsciousnessState() {
          this.effectCoordinationCallbacks.forEach((callback) => {
            try {
              callback(this.effectState);
            } catch (error) {
              console.error("[GlassmorphismManager] Error in visual-effects coordination callback:", error);
            }
          });
        }
        /**
         * Enhanced emotional state update with coordination
         */
        updateMusicStateWithCoordination(musicResult) {
          this.updateMusicState(musicResult);
          this.broadcastConsciousnessState();
          unifiedEventBus.emit("visual-effects:coordination", {
            source: "GlassmorphismManager",
            state: this.convertToVisualEffectsState(this.effectState),
            timestamp: Date.now()
          });
        }
        /**
         * Enhanced beat event with coordination
         */
        onMusicBeatWithCoordination(event) {
          this.onMusicBeat(event);
          this.broadcastConsciousnessState();
          unifiedEventBus.subscribe("music:beat-sync", (syncEvent) => {
            if (syncEvent.source !== "GlassmorphismManager") {
              this.effectState.beatPhase = syncEvent.beatPhase;
              this.effectState.lastBeatTime = syncEvent.lastBeatTime;
            }
          }, "GlassmorphismManager");
        }
        /**
         * Enhanced dramatic event with coordination
         */
        onCinematicDramaEventWithCoordination(event) {
          this.onCinematicDramaEvent(event);
          this.broadcastConsciousnessState();
          unifiedEventBus.subscribe("music:dramatic-sync", (syncEvent) => {
            if (syncEvent.source !== "GlassmorphismManager") {
              this.effectState.effectIntensityLevel = syncEvent.dramaticLevel;
              if (syncEvent.dramaticLevel > 0.7) {
                this.applyDramaticGlassDistortion(syncEvent.dramaticLevel);
              }
            }
          }, "GlassmorphismManager");
        }
        /**
         * Initialize cross-system visual-effects coordination
         */
        initializeCrossSystemCoordination() {
          try {
            unifiedEventBus.subscribe("visual-effects:coordination", (event) => {
              if (event.source !== "GlassmorphismManager") {
                this.synchronizeConsciousnessState(this.convertFromVisualEffectsState(event.state));
              }
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("music:beat-sync", (event) => {
              if (event.source !== "GlassmorphismManager") {
                this.effectState.beatPhase = event.beatPhase;
                this.effectState.lastBeatTime = event.lastBeatTime;
                this.applyCoordinatedBeatPulse(event.beatPhase);
              }
            }, "GlassmorphismManager");
            unifiedEventBus.subscribe("music:dramatic-sync", (event) => {
              if (event.source !== "GlassmorphismManager") {
                this.effectState.effectIntensityLevel = event.dramaticLevel;
                this.applyCoordinatedDramaticEffects(event.dramaticLevel, event.type || "unknown");
              }
            }, "GlassmorphismManager");
            console.log("[GlassmorphismManager] \u2705 Cross-system visual-effects coordination initialized");
          } catch (error) {
            console.error("[GlassmorphismManager] Failed to initialize cross-system coordination:", error);
          }
        }
        checkPerformanceAndAdjust() {
          if (this.performanceAnalyzer?.shouldReduceQuality() || false) {
            if (this.currentIntensity === "intense") {
              this.applyGlassmorphismSettings("balanced");
            } else if (this.currentIntensity === "balanced" || this.currentIntensity === "moderate") {
              this.applyGlassmorphismSettings("minimal");
            }
          }
        }
        applyGlassmorphism(level) {
          const glassConfig = this.config.glassmorphism[level];
          if (!this.cssBatcher) return;
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-display",
            level === "disabled" ? "none" : "block"
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-blur",
            `${glassConfig.blur}px`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-saturation",
            `${glassConfig.saturation}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-brightness",
            `${glassConfig.brightness}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-noise-opacity",
            `${glassConfig.noiseOpacity}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-border-opacity",
            `${glassConfig.borderOpacity}`
          );
          this.cssBatcher.queueCSSVariableUpdate(
            "--sn-glass-shadow-opacity",
            `${glassConfig.shadowOpacity}`
          );
          this.cssBatcher.flushCSSVariableBatch();
          if (this.config.enableDebug) {
            console.log(`\u{1F48E} [GlassmorphismManager] Applied level: ${level}`);
          }
        }
        // --------------------------------------------------------------------
        // Year3000System central settings broadcast hook
        // --------------------------------------------------------------------
        applyUpdatedSettings(key, value) {
          if (key === "sn-glassmorphism-level") {
            this.applyGlassmorphismSettings(value);
            this.updateGlassVariables(this.currentIntensity);
          }
        }
        // ===================================================================
        // Cross-System Consciousness Coordination Methods
        // ===================================================================
        /**
         * Apply coordinated beat pulse to glass effects
         */
        applyCoordinatedBeatPulse(beatPhase) {
          const modulations = this.calculateMusicModulations();
          const baseIntensity = this.getIntensityValue(this.currentIntensity);
          const beatPulse = 1 + Math.sin(beatPhase) * 0.15 * modulations.beatModulation;
          const pulseOpacity = baseIntensity.opacity * beatPulse;
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-opacity", pulseOpacity.toString());
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-accent-opacity", (pulseOpacity * 0.8).toString());
          this.cssBatcher?.flushCSSVariableBatch();
        }
        /**
         * Apply coordinated dramatic effects to glass systems
         */
        applyCoordinatedDramaticEffects(dramaticLevel, type) {
          const modulations = this.calculateMusicModulations();
          const baseIntensity = this.getIntensityValue(this.currentIntensity);
          const dramaticMultiplier = 1 + dramaticLevel * 0.4;
          const dramaticOpacity = Math.min(1, baseIntensity.opacity * dramaticMultiplier);
          const dramaticBlur = Math.min(20, baseIntensity.blur * (1 + dramaticLevel * 0.3));
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-opacity", dramaticOpacity.toString());
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-blur", `${dramaticBlur}px`);
          this.cssBatcher?.queueCSSVariableUpdate("--sn-glass-accent-opacity", (dramaticOpacity * 0.9).toString());
          this.cssBatcher?.flushCSSVariableBatch();
          setTimeout(() => {
            this.updateGlassVariables(this.currentIntensity);
          }, 1500);
        }
        /**
         * Get intensity values for glass effects
         */
        getIntensityValue(intensity) {
          switch (intensity) {
            case "disabled":
              return { opacity: 0, blur: 0, saturation: 1 };
            case "minimal":
              return { opacity: 0.05, blur: 3, saturation: 1.05 };
            case "balanced":
              return { opacity: 0.1, blur: 6, saturation: 1.2 };
            case "intense":
              return { opacity: 0.15, blur: 8, saturation: 1.4 };
            case "moderate":
              return { opacity: 0.08, blur: 5, saturation: 1.15 };
            default:
              return { opacity: 0.1, blur: 6, saturation: 1.2 };
          }
        }
        /**
         * Convert GlassEffectState to VisualEffectsState for event system compatibility
         */
        convertToVisualEffectsState(state) {
          return {
            intensity: state.effectIntensityLevel,
            colorTemperature: 6500,
            // Default value
            animationScale: state.musicIntensity,
            dominantEmotion: state.currentMusicMood,
            resonance: state.musicIntensity,
            // Legacy compatibility properties
            symbioticResonance: state.musicIntensity,
            surfaceFluidityIndex: state.musicIntensity,
            animationScaleRate: state.effectIntensityLevel,
            emotionalTemperature: 6500,
            pulsingCycle: state.beatPhase,
            cinematicIntensity: state.effectIntensityLevel
          };
        }
        /**
         * Convert VisualEffectsState to GlassEffectState for internal compatibility
         */
        convertFromVisualEffectsState(state) {
          return {
            currentMusicMood: state.dominantEmotion,
            musicIntensity: state.intensity,
            effectIntensityLevel: state.intensity,
            overallIntensityLevel: state.intensity
          };
        }
      };
      __name(_GlassmorphismManager, "GlassmorphismManager");
      GlassmorphismManager = _GlassmorphismManager;
    }
  });

  // src-js/visual/ui/GenreUIBridge.ts
  var _GenreUIBridge, GenreUIBridge;
  var init_GenreUIBridge = __esm({
    "src-js/visual/ui/GenreUIBridge.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_globalConfig();
      _GenreUIBridge = class _GenreUIBridge {
        constructor(genreProfileManager, musicSyncService, config) {
          this.initialized = false;
          this.musicSyncService = null;
          this.currentGenre = null;
          this.lastUpdateTime = 0;
          this.throttleMs = 300;
          // Throttle DOM updates to 300ms
          // DOM selectors that should receive genre attributes
          this.genreAwareSelectors = [
            ".Root__main-view",
            ".Root__now-playing-bar",
            ".Root__nav-bar",
            ".main-playButton-PlayButton",
            ".player-controls",
            ".main-card",
            ".card",
            ".artist-card",
            ".playlist-card"
          ];
          this.genreProfileManager = genreProfileManager;
          this.musicSyncService = musicSyncService || null;
          this.config = config || ADVANCED_SYSTEM_CONFIG;
        }
        async initialize() {
          if (this.initialized) return;
          try {
            unifiedEventBus.subscribe("music:track-changed", this.handleTrackChange.bind(this), "GenreUIBridge");
            this.initialized = true;
            if (this.config.enableDebug) {
              console.log("\u{1F3A8} [GenreUIBridge] Initialized - bridging genre detection to UI");
            }
          } catch (error) {
            console.error("[GenreUIBridge] Initialization failed:", error);
            throw error;
          }
        }
        updateAnimation(_deltaTime) {
        }
        async healthCheck() {
          return {
            healthy: this.initialized && this.genreProfileManager !== null,
            metrics: {
              lastCheck: Date.now(),
              initialized: this.initialized,
              hasGenreManager: this.genreProfileManager !== null,
              currentGenre: this.currentGenre || "none"
            }
          };
        }
        destroy() {
          this.removeGenreAttributes();
          unifiedEventBus.unsubscribeAll("GenreUIBridge");
          this.initialized = false;
          if (this.config.enableDebug) {
            console.log("\u{1F3A8} [GenreUIBridge] Destroyed");
          }
        }
        handleTrackChange(data) {
          const audioFeatures = data.audioFeatures;
          if (audioFeatures) {
            const detectedGenre = this.genreProfileManager.detectGenre(audioFeatures);
            this.updateGenreUI(detectedGenre);
          }
        }
        updateGenreUI(genre) {
          const now = Date.now();
          if (now - this.lastUpdateTime < this.throttleMs) {
            return;
          }
          this.lastUpdateTime = now;
          if (genre === this.currentGenre) {
            return;
          }
          this.currentGenre = genre;
          this.applyGenreAttributes(genre);
          this.updateGenreVisualVariables(genre);
          if (this.config.enableDebug) {
            const confidence = this.genreProfileManager.getGenreConfidence();
            console.log(`\u{1F3A8} [GenreUIBridge] Applied genre '${genre}' to UI (confidence: ${(confidence * 100).toFixed(0)}%)`);
          }
        }
        applyGenreAttributes(genre) {
          this.genreAwareSelectors.forEach((selector) => {
            const elements = document.querySelectorAll(selector);
            elements.forEach((element) => {
              element.setAttribute("data-genre-active", genre);
            });
          });
          document.body.classList.add("genre-switching");
          setTimeout(() => {
            document.body.classList.remove("genre-switching");
          }, 600);
        }
        removeGenreAttributes() {
          this.genreAwareSelectors.forEach((selector) => {
            const elements = document.querySelectorAll(selector);
            elements.forEach((element) => {
              element.removeAttribute("data-genre-active");
            });
          });
        }
        updateGenreVisualVariables(genre) {
          const visualStyle = this.genreProfileManager.getVisualStyle(genre);
          const characteristics = this.genreProfileManager.getCharacteristics(genre);
          const root = document.documentElement;
          root.style.setProperty("--genre-primary-hue-min", `${visualStyle.primaryHueRange[0]}`);
          root.style.setProperty("--genre-primary-hue-max", `${visualStyle.primaryHueRange[1]}`);
          root.style.setProperty("--genre-saturation-base", `${visualStyle.saturationProfile[0]}`);
          root.style.setProperty("--genre-saturation-variation", `${visualStyle.saturationProfile[1]}`);
          root.style.setProperty("--genre-brightness-base", `${visualStyle.brightnessProfile[0]}`);
          root.style.setProperty("--genre-brightness-variation", `${visualStyle.brightnessProfile[1]}`);
          root.style.setProperty("--genre-contrast-level", `${visualStyle.contrastLevel}`);
          root.style.setProperty("--genre-gradient-complexity", `${visualStyle.gradientComplexity}`);
          root.style.setProperty("--genre-animation-style", visualStyle.animationStyle);
          root.style.setProperty("--genre-pulse-behavior", visualStyle.pulseBehavior);
          root.style.setProperty("--genre-bass-emphasis", `${characteristics.bassEmphasis}`);
          root.style.setProperty("--genre-energy-level", `${characteristics.dynamicRange}`);
        }
        /**
         * Manually trigger genre UI update (for testing or manual control)
         */
        forceGenreUpdate(genre) {
          this.updateGenreUI(genre);
        }
        /**
         * Get current genre applied to UI
         */
        getCurrentGenre() {
          return this.currentGenre;
        }
      };
      __name(_GenreUIBridge, "GenreUIBridge");
      GenreUIBridge = _GenreUIBridge;
    }
  });

  // src-js/utils/dom/domCache.ts
  function $$(selector, options = {}) {
    if (!SUPPORTS_WEAKREF) {
      return Array.from(document.querySelectorAll(selector));
    }
    let entry = CACHE.get(selector);
    let elements = entry?.ref?.deref();
    if (options.force || !elements) {
      elements = Array.from(document.querySelectorAll(selector));
      const ref = new WeakRef(elements);
      entry = { ref, lastUpdate: Date.now() };
      CACHE.set(selector, entry);
      registry?.register(elements, selector);
    }
    return elements;
  }
  var CACHE, SUPPORTS_WEAKREF, SUPPORTS_REGISTRY, registry;
  var init_domCache = __esm({
    "src-js/utils/dom/domCache.ts"() {
      "use strict";
      CACHE = /* @__PURE__ */ new Map();
      SUPPORTS_WEAKREF = typeof WeakRef !== "undefined";
      SUPPORTS_REGISTRY = typeof FinalizationRegistry !== "undefined";
      registry = SUPPORTS_REGISTRY ? (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore – lib dom may not include FinalizationRegistry in older TS bundlers
        new FinalizationRegistry((selector) => {
          CACHE.delete(selector);
        })
      ) : null;
      __name($$, "$$");
    }
  });

  // src-js/debug/SpotifyDOMSelectors.ts
  function elementExists(selector) {
    return $$(selector).length > 0;
  }
  function findElementsWithFallback(modernSelector, legacySelector, options) {
    let elements = $$(modernSelector, options);
    if (elements.length === 0 && legacySelector) {
      elements = $$(legacySelector, options);
      if (elements.length > 0) {
        console.warn(
          `\u{1F30C} [SpotifyDOMSelectors] Using legacy selector: ${legacySelector}. Consider updating to: ${modernSelector}`
        );
      }
    }
    return elements;
  }
  function validateSpotifyDOM() {
    console.group("\u{1F30C} [SpotifyDOMSelectors] DOM Validation");
    const results = {
      found: 0,
      missing: 0,
      details: {}
    };
    Object.entries(MODERN_SELECTORS).forEach(([key, selector]) => {
      const exists = elementExists(selector);
      results.details[key] = {
        selector,
        exists,
        element: exists ? $$(selector)[0] || null : null
      };
      if (exists) {
        results.found++;
        console.log(`\u2705 ${key}: ${selector}`);
      } else {
        results.missing++;
        console.warn(`\u274C ${key}: ${selector}`);
      }
    });
    console.log(`\u{1F4CA} Summary: ${results.found} found, ${results.missing} missing`);
    console.groupEnd();
    return results;
  }
  function testGravitySystemSelectors() {
    console.group("\u{1F30C} [Phase 1] Testing Gravity System Selectors");
    console.log("\u{1F3AF} Primary gravity well targets:");
    if (GRAVITY_WELL_TARGETS["primary"]) {
      GRAVITY_WELL_TARGETS["primary"].forEach((selector) => {
        const element = $$(selector)[0] || null;
        console.log(`${element ? "\u2705" : "\u274C"} ${selector}`, element);
      });
    }
    console.log("\u{1F3AF} Secondary gravity well targets:");
    if (GRAVITY_WELL_TARGETS["secondary"]) {
      GRAVITY_WELL_TARGETS["secondary"].forEach((selector) => {
        const element = $$(selector)[0] || null;
        console.log(`${element ? "\u2705" : "\u274C"} ${selector}`, element);
      });
    }
    console.log("\u{1F6F8} Orbital elements:");
    Object.entries(ORBITAL_ELEMENTS).forEach(([key, selector]) => {
      const elements = $$(selector);
      console.log(
        `${elements.length > 0 ? "\u2705" : "\u274C"} ${key} (${selector}): ${elements.length} found`
      );
    });
    console.groupEnd();
  }
  function validatePredictionTargets() {
    console.group(
      "\u{1F52E} [SpotifyDOMSelectors] Phase 2 - Prediction Target Validation"
    );
    const testSelectors = [
      { name: "Track Rows", selector: ORBITAL_ELEMENTS["trackRows"] },
      { name: "Progress Bar", selector: MODERN_SELECTORS["progressBar"] },
      { name: "Play Button", selector: MODERN_SELECTORS["playButton"] },
      { name: "Heart Button", selector: MODERN_SELECTORS["heartButton"] },
      { name: "Album Cover", selector: MODERN_SELECTORS["albumCover"] },
      {
        name: "Now Playing Widget",
        selector: MODERN_SELECTORS["nowPlayingWidget"]
      },
      { name: "Now Playing Left", selector: MODERN_SELECTORS["nowPlayingLeft"] },
      { name: "Left Sidebar", selector: MODERN_SELECTORS["leftSidebar"] },
      { name: "Library Items", selector: ORBITAL_ELEMENTS["libraryItems"] }
    ];
    const results = {
      found: 0,
      missing: 0,
      details: {}
    };
    testSelectors.forEach(({ name, selector }) => {
      if (!selector) return;
      const elements = findElementsWithFallback(selector);
      const count = elements.length;
      results.details[name] = {
        selector,
        count,
        exists: count > 0
      };
      if (count > 0) {
        results.found++;
        console.log(`\u2705 ${name}: ${count} elements found (${selector})`);
      } else {
        results.missing++;
        console.warn(`\u274C ${name}: No elements found (${selector})`);
      }
    });
    console.log(
      `\u{1F4CA} Prediction Targets Summary: ${results.found} types found, ${results.missing} missing`
    );
    console.groupEnd();
    return results;
  }
  function testPhase2Systems() {
    console.group("\u{1F30C} [SpotifyDOMSelectors] Phase 2 - System Integration Test");
    const systemTests = {
      behavioralPrediction: validatePredictionTargets(),
      dimensionalNexus: {
        sidebarElement: MODERN_SELECTORS["leftSidebar"] ? elementExists(MODERN_SELECTORS["leftSidebar"]) : false
      },
      dataGlyph: {
        navLinks: MODERN_SELECTORS["navBarLink"] ? elementExists(MODERN_SELECTORS["navBarLink"]) : false,
        trackRows: ORBITAL_ELEMENTS["trackRows"] ? elementExists(ORBITAL_ELEMENTS["trackRows"]) : false,
        cards: ORBITAL_ELEMENTS["cards"] ? elementExists(ORBITAL_ELEMENTS["cards"]) : false
      }
    };
    let totalIssues = 0;
    Object.values(systemTests).forEach((tests) => {
      if (typeof tests === "object" && tests.missing) {
        totalIssues += tests.missing;
      }
    });
    console.log(
      `\u{1F3AF} Phase 2 Integration Health: ${totalIssues === 0 ? "\u2705 All systems operational" : `\u26A0\uFE0F ${totalIssues} issues detected`}`
    );
    console.groupEnd();
    return systemTests;
  }
  var MODERN_SELECTORS, SELECTOR_MAPPINGS, ORBITAL_ELEMENTS, GRAVITY_WELL_TARGETS, ANTI_GRAVITY_ZONES;
  var init_SpotifyDOMSelectors = __esm({
    "src-js/debug/SpotifyDOMSelectors.ts"() {
      "use strict";
      init_domCache();
      MODERN_SELECTORS = {
        // Main Layout Structure
        nowPlayingBar: ".Root__now-playing-bar",
        leftSidebar: ".Root__nav-bar",
        mainView: ".Root__main-view",
        rightSidebar: ".Root__right-sidebar",
        // Now Playing Components
        nowPlayingWidget: "[data-testid='now-playing-widget']",
        nowPlayingLeft: ".main-nowPlayingBar-left",
        nowPlayingCenter: ".main-nowPlayingBar-center",
        nowPlayingRight: ".main-nowPlayingBar-right",
        coverArt: ".main-coverSlotCollapsed-container",
        trackInfo: ".main-trackInfo-container",
        // Navigation & Library
        navMain: "nav[aria-label='Main']",
        yourLibrary: ".main-yourLibraryX-libraryContainer",
        libraryItems: ".main-yourLibraryX-listItem",
        libraryHeader: ".main-yourLibraryX-header",
        playlistList: ".main-rootlist-wrapper",
        // Track Lists & Content
        trackListContainer: "[role='grid'][aria-label*='tracks']",
        trackRow: ".main-trackList-trackListRow",
        trackListHeader: ".main-trackList-trackListHeaderRow",
        trackNumber: ".main-trackList-rowSectionIndex",
        trackTitle: ".main-trackList-rowTitle",
        trackArtist: ".main-trackList-rowSubTitle",
        // Entity Headers (Playlist/Album/Artist Pages)
        entityHeader: ".main-entityHeader-container",
        entityTitle: ".main-entityHeader-title",
        entityMetadata: ".main-entityHeader-metaData",
        entityImage: ".main-entityHeader-imageContainer",
        // Action Bar & Controls
        actionBar: ".main-actionBar-ActionBarRow",
        actionBarInner: ".main-actionBar-ActionBar",
        playButton: "[data-testid='play-button']",
        pauseButton: "[data-testid='pause-button']",
        shuffleButton: "[data-testid='shuffle-button']",
        likeButton: ".control-button-heart",
        // Queue & Right Sidebar
        queue: ".main-queue-trackList",
        queueContainer: "[aria-label='Next in queue']",
        aboutArtist: "[aria-label='About the artist']",
        credits: "[aria-label='Credits']",
        // Search & Filtering
        searchInput: "[data-testid='search-input']",
        searchPage: "[data-testid='search-container']",
        filterPills: ".main-genre-chip",
        sortButton: "[data-testid='sort-button']",
        // Cards & Media
        // Phase 2.2: Unified .sn-card selector (CardDOMWatcher) + legacy
        card: ".sn-card, .main-card-card",
        cardImage: ".main-cardImage-image",
        albumArt: ".main-trackList-albumArt",
        // Modal & Overlay
        modal: ".main-modal-container",
        overlay: ".main-overlay-container"
      };
      SELECTOR_MAPPINGS = Object.entries({
        // Migration mapping: legacy → modern
        ".main-nowPlayingWidget-nowPlaying": MODERN_SELECTORS["nowPlayingBar"],
        ".main-navBar-navBar": MODERN_SELECTORS["leftSidebar"],
        ".main-search-searchBar": MODERN_SELECTORS["searchInput"],
        ".main-topBar-topBar": MODERN_SELECTORS["actionBar"],
        ".main-queue-queue": MODERN_SELECTORS["queue"],
        ".main-trackList-trackList": MODERN_SELECTORS["trackListContainer"]
      }).reduce((acc, [key, value]) => {
        if (typeof value === "string") {
          acc[key] = value;
        }
        return acc;
      }, {});
      ORBITAL_ELEMENTS = {
        // Elements that can have orbital gravity effects
        trackRows: MODERN_SELECTORS["trackRow"] ?? "",
        libraryItems: MODERN_SELECTORS["libraryItems"] ?? "",
        cards: MODERN_SELECTORS["card"] ?? "",
        navLinks: ".main-navBar-navBarLink"
        // This one still works
      };
      GRAVITY_WELL_TARGETS = {
        // Major UI elements that should have gravity wells
        primary: [
          MODERN_SELECTORS["nowPlayingBar"],
          MODERN_SELECTORS["leftSidebar"],
          MODERN_SELECTORS["entityHeader"]
        ].filter((s) => !!s),
        secondary: [
          MODERN_SELECTORS["actionBar"],
          MODERN_SELECTORS["queue"],
          MODERN_SELECTORS["searchInput"]
        ].filter((s) => !!s),
        tertiary: [
          MODERN_SELECTORS["playButton"],
          MODERN_SELECTORS["trackListHeader"]
        ].filter((s) => !!s)
      };
      ANTI_GRAVITY_ZONES = {
        // Areas where anti-gravity effects should be applied
        searchAreas: [
          MODERN_SELECTORS["searchInput"],
          MODERN_SELECTORS["searchPage"]
        ].filter((s) => !!s),
        notifications: [
          "[data-testid='notification-bar']",
          ".main-topBar-notifications"
        ],
        dropdowns: [".main-dropdown-menu", "[role='menu']", "[role='listbox']"]
      };
      __name(elementExists, "elementExists");
      __name(findElementsWithFallback, "findElementsWithFallback");
      __name(validateSpotifyDOM, "validateSpotifyDOM");
      __name(testGravitySystemSelectors, "testGravitySystemSelectors");
      __name(validatePredictionTargets, "validatePredictionTargets");
      __name(testPhase2Systems, "testPhase2Systems");
      if (typeof window !== "undefined") {
        window.SpotifyDOMSelectors = {
          validate: validateSpotifyDOM,
          testGravity: testGravitySystemSelectors,
          validatePredictionTargets,
          testPhase2Systems,
          selectors: MODERN_SELECTORS,
          targets: GRAVITY_WELL_TARGETS,
          orbital: ORBITAL_ELEMENTS,
          antiGravity: ANTI_GRAVITY_ZONES
        };
        console.log("\u{1F3AF} [SpotifyDOMSelectors] Debug functions available:");
        console.log("  window.SpotifyDOMSelectors.validate() - Test all selectors");
        console.log(
          "  window.SpotifyDOMSelectors.testGravity() - Test gravity selectors"
        );
      }
    }
  });

  // src-js/visual/ui/SidebarPerformanceCoordinator.ts
  var SidebarPerformanceCoordinator_exports = {};
  __export(SidebarPerformanceCoordinator_exports, {
    SidebarPerformanceCoordinator: () => SidebarPerformanceCoordinator,
    SidebarPerformanceManager: () => SidebarPerformanceManager,
    getSidebarPerformanceCoordinator: () => getSidebarPerformanceCoordinator,
    getSidebarPerformanceManager: () => getSidebarPerformanceManager
  });
  function getSidebarPerformanceManager(config) {
    return SidebarPerformanceManager.getInstance(config);
  }
  function getSidebarPerformanceCoordinator(config) {
    return SidebarPerformanceManager.getInstance(config);
  }
  var _SidebarPerformanceManager, SidebarPerformanceManager, SidebarPerformanceCoordinator;
  var init_SidebarPerformanceCoordinator = __esm({
    "src-js/visual/ui/SidebarPerformanceCoordinator.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_OptimizedCSSVariableManager();
      init_PerformanceBudgetManager();
      init_SpotifyDOMSelectors();
      _SidebarPerformanceManager = class _SidebarPerformanceManager {
        constructor(config = {}) {
          this.pendingUpdates = /* @__PURE__ */ new Map();
          this.isFlushScheduled = false;
          this.rafId = null;
          this.performanceAnalyzer = null;
          // Harmonic variable mapping for Year 3000 convergence
          this.harmonicVariableMap = /* @__PURE__ */ new Map([
            ["--sn-rs-beat-intensity", "--sn-beat-pulse-intensity"],
            ["--sn-rs-glow-alpha", "--sn-rhythm-phase"],
            ["--sn-rs-hue-shift", "--sn-spectrum-phase"]
          ]);
          // Performance tracking
          this.flushCount = 0;
          this.totalFlushTime = 0;
          this.lastFlushTimestamp = 0;
          this.budgetManager = null;
          // DOM observation for reactive refresh and temporal play
          this.domObserver = null;
          this.sidebarElement = null;
          this.visibilityObserver = null;
          this.observationThrottleTimer = null;
          this.lastObservationTime = 0;
          this.OBSERVATION_THROTTLE_MS = 200;
          // Throttle observations to 5 Hz for better performance
          this.isFirstOpen = true;
          this.lastScrollUpdate = 0;
          // Timeout tracking for proper cleanup
          this.activeTimeouts = /* @__PURE__ */ new Set();
          this.domObservationRetryTimeout = null;
          // Event-driven coordination for music changes
          this.musicChangeUnsubscribe = null;
          this.config = {
            enableDebug: config.enableDebug ?? false,
            maxBatchSize: config.maxBatchSize ?? 50,
            ...config
          };
          this.performanceAnalyzer = config.performanceAnalyzer || null;
          const year3000System = globalThis.year3000System;
          this.cssController = year3000System.getGlobalOptimizedCSSController();
          if (this.performanceAnalyzer) {
            this.budgetManager = PerformanceBudgetManager.getInstance(
              void 0,
              this.performanceAnalyzer
            );
          }
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceManager] Initialized with RAF-based batching"
            );
          }
        }
        /**
         * Singleton accessor for global coordination
         */
        static getInstance(config) {
          if (!_SidebarPerformanceManager.instance) {
            _SidebarPerformanceManager.instance = new _SidebarPerformanceManager(config);
          }
          return _SidebarPerformanceManager.instance;
        }
        /**
         * Queue a CSS variable update for atomic application at next animation frame
         */
        queueUpdate(property, value) {
          const criticalVars = [
            "--sn-rs-glow-alpha",
            "--sn-rs-beat-intensity",
            "--sn-rs-hue-shift"
          ];
          if (criticalVars.includes(property)) {
            this.applyCriticalUpdate(property, value);
            return;
          }
          try {
            const cssController = getGlobalOptimizedCSSController();
            cssController.queueCSSVariableUpdate(
              property,
              value,
              this.getSidebarElement()
            );
          } catch (error) {
            this.pendingUpdates.set(property, {
              property,
              value,
              timestamp: performance.now()
            });
            if (this.config.enableDebug && this.pendingUpdates.size === 1) {
              console.log(
                `\u{1F30C} [SidebarPerformanceManager] Queuing first update (fallback): ${property}`
              );
            }
            this.scheduleFlush();
          }
        }
        /**
         * Apply critical updates immediately to the sidebar element
         */
        applyCriticalUpdate(property, value) {
          try {
            this.cssController.queueCSSVariableUpdate(
              property,
              value,
              null,
              // element (not needed for global variables)
              "critical",
              // Critical priority for performance-critical sidebar updates
              "sidebar-critical-update"
            );
          } catch (error) {
            console.error(
              `\u{1F30C} [SidebarPerformanceManager] Failed to apply critical ${property}:`,
              error
            );
          }
        }
        /**
         * Get the sidebar element with fallback to document root
         * Extensible to support multiple sidebar locations in the future
         */
        getSidebarElement() {
          if (!this.sidebarElement) {
            this.sidebarElement = document.querySelector(
              MODERN_SELECTORS.rightSidebar
            );
          }
          return this.sidebarElement || document.documentElement;
        }
        /**
         * Schedule atomic flush at next animation frame
         */
        scheduleFlush() {
          if (this.isFlushScheduled) {
            return;
          }
          this.isFlushScheduled = true;
          this.rafId = requestAnimationFrame(() => {
            this.flushUpdates();
          });
        }
        /**
         * Atomically apply all pending updates
         */
        flushUpdates() {
          if (this.pendingUpdates.size === 0) {
            this.isFlushScheduled = false;
            return;
          }
          const startTime = performance.now();
          const targetElement = this.getSidebarElement();
          const updateCount = this.pendingUpdates.size;
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [SidebarPerformanceManager] Flushing ${updateCount} updates atomically`
            );
          }
          if (updateCount > (this.config.maxBatchSize || 50)) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceManager] Large batch detected (${updateCount} updates), may impact performance`
            );
          }
          try {
            const sidebarVariables = {};
            const globalHarmonicVariables = {};
            for (const update of this.pendingUpdates.values()) {
              sidebarVariables[update.property] = update.value;
              const harmonicVar = this.harmonicVariableMap.get(update.property);
              if (harmonicVar) {
                globalHarmonicVariables[harmonicVar] = update.value;
                if (this.config.enableDebug) {
                  console.log(
                    `\u{1F30C} [SidebarPerformanceManager] Mapped ${update.property} \u2192 ${harmonicVar} = ${update.value}`
                  );
                }
              }
            }
            if (Object.keys(sidebarVariables).length > 0) {
              const sidebarElement = targetElement;
              for (const [property, value] of Object.entries(sidebarVariables)) {
                sidebarElement.style.setProperty(property, value);
              }
            }
            if (Object.keys(globalHarmonicVariables).length > 0) {
              this.cssController.batchSetVariables(
                "SidebarPerformanceManager",
                globalHarmonicVariables,
                "high",
                // High priority for harmonic variable mapping
                "harmonic-variable-mapping"
              );
            }
          } catch (error) {
            console.error(
              `\u{1F30C} [SidebarPerformanceManager] Failed to apply batched updates:`,
              error
            );
          }
          this.pendingUpdates.clear();
          this.isFlushScheduled = false;
          this.rafId = null;
          if (this.config.onFlushComplete) {
            try {
              this.config.onFlushComplete();
            } catch (error) {
              console.error(
                "\u{1F30C} [SidebarPerformanceManager] Error in flush completion callback:",
                error
              );
            }
          }
          const endTime = performance.now();
          const flushTime = endTime - startTime;
          this.flushCount++;
          this.totalFlushTime += flushTime;
          this.lastFlushTimestamp = endTime;
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.emitTrace?.(
              `[SidebarPerformanceManager] Flushed ${updateCount} updates in ${flushTime.toFixed(
                2
              )}ms`
            );
          }
          const avgFlushTime = this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0;
          if (avgFlushTime > 3) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceManager] Performance threshold exceeded: average ${avgFlushTime.toFixed(
                2
              )}ms per flush (target: <3ms)`
            );
          }
          if (this.config.enableDebug && flushTime > 4) {
            console.warn(
              `\u{1F30C} [SidebarPerformanceManager] Slow flush detected: ${flushTime.toFixed(
                2
              )}ms for ${updateCount} updates`
            );
          }
        }
        /**
         * Setup event-driven music change coordination
         * This replaces pure DOM watching to prevent cascade loops
         */
        setupMusicChangeCoordination() {
          if (this.musicChangeUnsubscribe) {
            return;
          }
          this.musicChangeUnsubscribe = () => {
            unifiedEventBus.unsubscribeAll("SidebarPerformanceManager");
          };
          unifiedEventBus.subscribe(
            "music:track-changed",
            (data) => {
              this.handleMusicChange({
                timestamp: data.timestamp,
                source: "track-changed",
                reason: "music:track-changed event"
              });
            },
            "SidebarPerformanceManager"
          );
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceManager] Event-driven music coordination active"
            );
          }
        }
        /**
         * Handle music change events from the global event bus
         */
        handleMusicChange(eventData) {
          if (this.sidebarElement) {
            this.handleVisibilityChange();
            if (this.config.enableDebug) {
              console.log(
                "\u{1F30C} [SidebarPerformanceManager] Music change coordinated via event",
                {
                  source: eventData.source,
                  reason: eventData.reason,
                  timestamp: eventData.timestamp
                }
              );
            }
          }
        }
        /**
         * Setup DOM observation for reactive refresh and temporal play
         */
        setupDOMObservation() {
          if (this.domObserver) {
            return;
          }
          this.setupMusicChangeCoordination();
          this.sidebarElement = document.querySelector(
            MODERN_SELECTORS.rightSidebar
          );
          if (!this.sidebarElement) {
            if (this.config.enableDebug) {
              console.warn(
                "\u{1F30C} [SidebarPerformanceManager] Sidebar not found, deferring DOM observation"
              );
            }
            if (this.domObservationRetryTimeout) {
              clearTimeout(this.domObservationRetryTimeout);
              this.activeTimeouts.delete(this.domObservationRetryTimeout);
            }
            this.domObservationRetryTimeout = setTimeout(() => {
              this.setupDOMObservation();
              this.domObservationRetryTimeout = null;
            }, 1e3);
            this.activeTimeouts.add(this.domObservationRetryTimeout);
            return;
          }
          this.domObserver = new MutationObserver((mutations) => {
            const relevantMutations = mutations.filter(
              (mutation) => this.isRelevantMutation(mutation)
            );
            if (relevantMutations.length === 0) {
              return;
            }
            this.throttleObservationUpdate(() => {
              for (const mutation of relevantMutations) {
                if (mutation.type === "attributes" && (mutation.attributeName === "aria-hidden" || mutation.attributeName === "style")) {
                  this.handleVisibilityChange();
                }
              }
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F30C} [SidebarPerformanceManager] Relevant DOM change detected - visibility/structure only",
                  {
                    mutationCount: relevantMutations.length,
                    types: relevantMutations.map((m) => m.type)
                  }
                );
              }
            });
          });
          this.domObserver.observe(this.sidebarElement, {
            childList: true,
            subtree: false,
            // Optimize: Only observe direct children to reduce mutation volume
            attributes: true,
            // Watch for visibility and style changes
            attributeFilter: ["aria-hidden", "style", "class"],
            // Only observe attributes we care about
            attributeOldValue: false,
            // Optimize: Don't observe attribute old values
            characterData: false
            // Don't observe text changes
          });
          this.setupVisibilityObserver();
          this.setupScrollObservation();
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceManager] DOM observation active on sidebar"
            );
          }
        }
        /**
         * Setup visibility observer for temporal echo effects
         */
        setupVisibilityObserver() {
          if (!this.sidebarElement || this.visibilityObserver) return;
          this.visibilityObserver = new IntersectionObserver(
            (entries) => {
              const entry = entries[0];
              if (entry && entry.isIntersecting && this.isFirstOpen) {
                if (window.requestIdleCallback) {
                  window.requestIdleCallback(() => {
                    this.triggerTemporalEcho();
                    this.isFirstOpen = false;
                  });
                } else {
                  setTimeout(() => {
                    this.triggerTemporalEcho();
                    this.isFirstOpen = false;
                  }, 0);
                }
              }
            },
            { threshold: 0.1 }
          );
          this.visibilityObserver.observe(this.sidebarElement);
        }
        /**
         * Setup scroll observation with throttling for performance
         */
        setupScrollObservation() {
          if (!this.sidebarElement) return;
          const queueElement = this.sidebarElement.querySelector(
            ".main-nowPlayingView-queue"
          );
          if (!queueElement) return;
          queueElement.addEventListener(
            "scroll",
            this.throttledScrollHandler.bind(this),
            {
              passive: true
            }
          );
        }
        /**
         * Throttled scroll handler (≤30 Hz as specified)
         */
        throttledScrollHandler() {
          const now = performance.now();
          if (now - this.lastScrollUpdate < 33) return;
          this.lastScrollUpdate = now;
          if (window.requestIdleCallback) {
            window.requestIdleCallback(
              () => {
                this.queueUpdate("--sn-rs-scroll-ratio", Math.random().toString());
              },
              { timeout: 100 }
            );
          } else {
            this.queueUpdate("--sn-rs-scroll-ratio", Math.random().toString());
          }
        }
        /**
         * Filter mutations to only process changes that actually affect UI structure or visibility
         * Prevents cascade loops from CSS variable updates and other non-visual changes
         */
        isRelevantMutation(mutation) {
          if (mutation.type === "attributes") {
            const attrName = mutation.attributeName;
            if (attrName === "aria-hidden" || attrName === "style") {
              return true;
            }
            if (attrName === "class") {
              return true;
            }
            if (attrName?.startsWith("--") || attrName === "data-style") {
              return false;
            }
            return false;
          }
          if (mutation.type === "childList") {
            const hasElementChanges = mutation.addedNodes && Array.from(mutation.addedNodes).some(
              (node) => node.nodeType === Node.ELEMENT_NODE
            ) || mutation.removedNodes && Array.from(mutation.removedNodes).some(
              (node) => node.nodeType === Node.ELEMENT_NODE
            );
            return hasElementChanges;
          }
          return false;
        }
        /**
         * Throttle DOM observation updates to reduce CPU overhead
         */
        throttleObservationUpdate(callback) {
          const now = performance.now();
          if (now - this.lastObservationTime < this.OBSERVATION_THROTTLE_MS) {
            if (this.observationThrottleTimer) {
              clearTimeout(this.observationThrottleTimer);
            }
            this.observationThrottleTimer = window.setTimeout(() => {
              callback();
              this.lastObservationTime = performance.now();
              this.observationThrottleTimer = null;
            }, this.OBSERVATION_THROTTLE_MS);
          } else {
            callback();
            this.lastObservationTime = now;
          }
        }
        /**
         * Handle visibility changes for temporal effects
         */
        handleVisibilityChange() {
          if (!this.sidebarElement) return;
          const isVisible = !this.sidebarElement.hasAttribute("aria-hidden") && !this.sidebarElement.style.display?.includes("none");
          if (isVisible && this.isFirstOpen) {
            this.triggerTemporalEcho();
            this.isFirstOpen = false;
          }
          if (this.config.enableDebug) {
            console.log(
              `\u{1F30C} [SidebarPerformanceManager] Visibility changed: ${isVisible ? "visible" : "hidden"}`
            );
          }
        }
        /**
         * Trigger one-time temporal echo effect
         */
        triggerTemporalEcho() {
          if (!this.sidebarElement) return;
          this.sidebarElement.classList.add("sn-future-preview");
          this.queueUpdate("--sn-kinetic-intensity", "1");
          this.queueUpdate("--sn-echo-hue-shift", "15deg");
          this.queueUpdate("--sn-echo-radius-multiplier", "1.2");
          if (this.config.enableDebug) {
            console.log(
              "\u{1F30C} [SidebarPerformanceManager] Triggering temporal echo effect"
            );
          }
          const cleanupTimeout = setTimeout(() => {
            this.sidebarElement?.classList.remove("sn-future-preview");
            this.queueUpdate("--sn-kinetic-intensity", "0");
            this.activeTimeouts.delete(cleanupTimeout);
          }, 2e3);
          this.activeTimeouts.add(cleanupTimeout);
        }
        /**
         * Get performance metrics for monitoring
         */
        getPerformanceMetrics() {
          return {
            flushCount: this.flushCount,
            averageFlushTime: this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0,
            lastFlushTimestamp: this.lastFlushTimestamp,
            pendingUpdates: this.pendingUpdates.size
          };
        }
        /**
         * Force immediate flush for critical scenarios
         */
        forceFlush() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
          this.flushUpdates();
        }
        /**
         * Cleanup and destroy coordinator
         */
        destroy() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
          this.activeTimeouts.forEach((timeout) => {
            clearTimeout(timeout);
          });
          this.activeTimeouts.clear();
          if (this.domObservationRetryTimeout) {
            clearTimeout(this.domObservationRetryTimeout);
            this.domObservationRetryTimeout = null;
          }
          if (this.observationThrottleTimer) {
            clearTimeout(this.observationThrottleTimer);
            this.observationThrottleTimer = null;
          }
          if (this.domObserver) {
            this.domObserver.disconnect();
            this.domObserver = null;
          }
          if (this.visibilityObserver) {
            this.visibilityObserver.disconnect();
            this.visibilityObserver = null;
          }
          if (this.musicChangeUnsubscribe) {
            this.musicChangeUnsubscribe();
            this.musicChangeUnsubscribe = null;
          }
          this.pendingUpdates.clear();
          this.isFlushScheduled = false;
          this.sidebarElement = null;
          if (_SidebarPerformanceManager.instance === this) {
            _SidebarPerformanceManager.instance = null;
          }
          if (this.config.enableDebug) {
            const avgFlushTime = this.flushCount > 0 ? this.totalFlushTime / this.flushCount : 0;
            console.log(
              `\u{1F30C} [SidebarPerformanceManager] Destroyed. Performance: ${this.flushCount} flushes, ${avgFlushTime.toFixed(2)}ms avg`
            );
          }
        }
      };
      __name(_SidebarPerformanceManager, "SidebarPerformanceManager");
      _SidebarPerformanceManager.instance = null;
      SidebarPerformanceManager = _SidebarPerformanceManager;
      __name(getSidebarPerformanceManager, "getSidebarPerformanceManager");
      __name(getSidebarPerformanceCoordinator, "getSidebarPerformanceCoordinator");
      SidebarPerformanceCoordinator = SidebarPerformanceManager;
    }
  });

  // src-js/core/integration/SidebarSystemsIntegration.ts
  var _SidebarSystemsIntegration, SidebarSystemsIntegration;
  var init_SidebarSystemsIntegration = __esm({
    "src-js/core/integration/SidebarSystemsIntegration.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_SidebarPerformanceCoordinator();
      init_globalConfig();
      _SidebarSystemsIntegration = class _SidebarSystemsIntegration extends UnifiedSystemBase {
        constructor(config = ADVANCED_SYSTEM_CONFIG) {
          super(config);
          // System registry
          this.sidebarSystems = /* @__PURE__ */ new Map();
          // Integration state
          this.integrationEnabled = false;
          // Animation frame tracking
          this.lastFrameTime = 0;
          this.sharedCoordinator = SidebarPerformanceManager.getInstance({
            enableDebug: config.enableDebug,
            performanceAnalyzer: this.performanceAnalyzer,
            onFlushComplete: /* @__PURE__ */ __name(() => this.handlePerformanceFlush(), "onFlushComplete")
          });
          this.performanceMetrics = {
            totalSystems: 4,
            activeSystems: 0,
            bilateralSyncEnabled: false,
            averageFrameTime: 0,
            totalMemoryUsage: 0,
            healthStatus: "healthy"
          };
          if (config.enableDebug) {
            console.log(`[${this.systemName}] Initialized sidebar systems integration`);
          }
        }
        /**
         * Initialize all sidebar systems in proper order
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Initializing sidebar systems integration`);
          }
          try {
            this.registerSidebarSystems();
            await this.registerWithUnifiedRegistry();
            await this.initializeSystemsInOrder();
            this.setupBilateralCoordination();
            this.connectToEventBus();
            this.integrateWithPerformanceSystems();
            this.registerAnimation(70);
            this.integrationEnabled = true;
            this.updatePerformanceMetrics();
            this.publishEvent("sidebar:integration-ready", {
              systemName: this.systemName,
              totalSystems: this.sidebarSystems.size,
              activeSystems: this.performanceMetrics.activeSystems,
              bilateralSync: this.performanceMetrics.bilateralSyncEnabled,
              timestamp: Date.now()
            });
          } catch (error) {
            console.error(`[${this.systemName}] Integration initialization failed:`, error);
            throw error;
          }
        }
        /**
         * Register all sidebar system definitions
         */
        registerSidebarSystems() {
          if (this.consolidatedSidebarSystem) {
            this.sidebarSystems.set("consolidatedSidebarSystem", {
              name: "consolidatedSidebarSystem",
              system: this.consolidatedSidebarSystem,
              priority: "critical",
              enabled: true,
              dependencies: []
            });
          }
        }
        /**
         * Initialize systems in dependency order
         */
        async initializeSystemsInOrder() {
          const initializationOrder = this.calculateInitializationOrder();
          for (const systemName of initializationOrder) {
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.enabled) {
              try {
                await systemDef.system._baseInitialize();
                this.performanceMetrics.activeSystems++;
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Initialized ${systemName}`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to initialize ${systemName}:`, error);
              }
            }
          }
        }
        /**
         * Calculate system initialization order based on dependencies
         */
        calculateInitializationOrder() {
          const visited = /* @__PURE__ */ new Set();
          const visiting = /* @__PURE__ */ new Set();
          const order = [];
          const visit = /* @__PURE__ */ __name((systemName) => {
            if (visiting.has(systemName)) {
              throw new Error(`Circular dependency detected: ${systemName}`);
            }
            if (visited.has(systemName)) return;
            visiting.add(systemName);
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.dependencies) {
              for (const dep of systemDef.dependencies) {
                visit(dep);
              }
            }
            visiting.delete(systemName);
            visited.add(systemName);
            order.push(systemName);
          }, "visit");
          for (const systemName of this.sidebarSystems.keys()) {
            visit(systemName);
          }
          return order;
        }
        /**
         * Set up bilateral visual-effects coordination
         */
        setupBilateralCoordination() {
          this.performanceMetrics.bilateralSyncEnabled = true;
          this.subscribeToEvent("sidebar:bilateral-sync", (payload) => {
            this.handleBilateralSync(payload);
          });
          this.subscribeToEvent("sidebar:visual-level-changed", (payload) => {
            this.handleVisualLevelChange(payload);
          });
        }
        /**
         * Handle bilateral synchronization events
         */
        handleBilateralSync(payload) {
          if (payload.source === "orchestrator") {
            this.updatePerformanceMetrics();
          }
        }
        /**
         * Handle visual level changes
         */
        handleVisualLevelChange(payload) {
          const visualIntensityLevels = {
            dormant: 0.5,
            aware: 0.7,
            focused: 0.9,
            advanced: 1
          };
          const performanceLevel = visualIntensityLevels[payload.newLevel] || 0.7;
          this.adjustPerformanceBudgets(performanceLevel);
        }
        /**
         * Adjust performance budgets based on visual intensity level
         */
        adjustPerformanceBudgets(level) {
          const baseBudget = 16;
          const adjustedBudget = Math.floor(baseBudget * level);
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Adjusted performance budget to ${adjustedBudget} based on visual intensity level`);
          }
        }
        /**
         * Handle performance flush completion
         */
        handlePerformanceFlush() {
          const currentTime = performance.now();
          if (this.lastFrameTime > 0) {
            const frameTime = currentTime - this.lastFrameTime;
            this.performanceMetrics.averageFrameTime = (this.performanceMetrics.averageFrameTime + frameTime) / 2;
          }
          this.lastFrameTime = currentTime;
          this.updateHealthStatus();
        }
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics() {
          this.performanceMetrics.totalSystems = this.sidebarSystems.size;
          let activeSystems = 0;
          for (const [, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              activeSystems++;
            }
          }
          this.performanceMetrics.activeSystems = activeSystems;
        }
        /**
         * Update health status based on performance metrics
         */
        updateHealthStatus() {
          if (this.performanceMetrics.averageFrameTime > 20) {
            this.performanceMetrics.healthStatus = "critical";
          } else if (this.performanceMetrics.averageFrameTime > 16.67) {
            this.performanceMetrics.healthStatus = "degraded";
          } else {
            this.performanceMetrics.healthStatus = "healthy";
          }
        }
        /**
         * Animation frame callback
         */
        onAnimate(deltaTime) {
          if (!this.integrationEnabled) return;
          this.updatePerformanceMetrics();
          this.updateHealthStatus();
          const currentTime = performance.now();
          if (currentTime - this.lastFrameTime > 1e3) {
            this.publishEvent("sidebar:integration-metrics", {
              metrics: this.performanceMetrics,
              timestamp: Date.now()
            });
          }
        }
        /**
         * Register all sidebar systems with Year3000System animation coordinator
         */
        registerWithAnimationCoordinator(animationCoordinator) {
          if (!animationCoordinator) {
            console.warn(`[${this.systemName}] Animation coordinator not available`);
            return;
          }
          for (const [systemName, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              try {
                animationCoordinator.registerAnimationSystem(
                  systemName,
                  systemDef.system,
                  systemDef.priority,
                  60
                  // Default FPS
                );
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Registered ${systemName} with animation coordinator`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to register ${systemName}:`, error);
              }
            }
          }
        }
        /**
         * Get all sidebar systems for external access
         */
        getSidebarSystems() {
          return new Map(this.sidebarSystems);
        }
        /**
         * Get performance metrics
         */
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Enable/disable specific sidebar system
         */
        setSidebarSystemEnabled(systemName, enabled) {
          const systemDef = this.sidebarSystems.get(systemName);
          if (systemDef) {
            systemDef.enabled = enabled;
            if (!enabled && systemDef.system.isInitialized) {
              systemDef.system._baseDestroy();
              this.performanceMetrics.activeSystems--;
            } else if (enabled && !systemDef.system.isInitialized) {
              systemDef.system._baseInitialize().catch((error) => {
                console.error(`[${this.systemName}] Failed to re-enable ${systemName}:`, error);
              });
            }
            this.publishEvent("sidebar:system-toggled", {
              systemName,
              enabled,
              timestamp: Date.now()
            });
          }
        }
        /**
         * System health check
         */
        async healthCheck() {
          const systemHealthChecks = {};
          for (const [systemName, systemDef] of this.sidebarSystems) {
            if (systemDef.enabled && systemDef.system.isInitialized) {
              try {
                systemHealthChecks[systemName] = await systemDef.system.healthCheck();
              } catch (error) {
                systemHealthChecks[systemName] = {
                  healthy: false,
                  ok: false,
                  details: `Health check failed: ${error.message}`,
                  issues: [`Health check failed: ${error.message}`],
                  system: systemName
                };
              }
            }
          }
          const unhealthySystems = Object.values(systemHealthChecks).filter((check) => !check.ok);
          const isHealthy = unhealthySystems.length === 0;
          return {
            healthy: isHealthy,
            ok: isHealthy,
            details: `Sidebar integration ${isHealthy ? "healthy" : "degraded"} - ${this.performanceMetrics.activeSystems}/${this.performanceMetrics.totalSystems} systems active, bilateral sync: ${this.performanceMetrics.bilateralSyncEnabled}`,
            issues: unhealthySystems.map((check) => check.details || "Unknown issue"),
            system: "SidebarSystemsIntegration"
          };
        }
        /**
         * Phase 3: Register sidebar systems with facade (UnifiedSystemRegistry is deprecated)
         */
        async registerWithUnifiedRegistry() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Sidebar systems are now managed by VisualSystemFacade`);
          }
        }
        /**
         * Phase 3: Connect to EventBus for system-wide communication
         */
        connectToEventBus() {
          this.subscribeToEvent("music:beat", (payload) => {
            this.handleMusicBeat(payload);
          });
          this.subscribeToEvent("music:energy", (payload) => {
            this.handleMusicEnergy(payload);
          });
          this.subscribeToEvent("performance:threshold-exceeded", (payload) => {
            this.handlePerformanceThreshold(payload);
          });
          this.subscribeToEvent("user:navigation", (payload) => {
            this.handleUserNavigation(payload);
          });
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Connected to EventBus for system-wide communication`);
          }
        }
        /**
         * Phase 3: Integrate with TimerConsolidationSystem and MasterAnimationCoordinator
         */
        integrateWithPerformanceSystems() {
          const year3000System = globalThis.year3000System;
          if (!year3000System) {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Year3000System not available, skipping performance integration`);
            }
            return;
          }
          try {
            const timerSystem = year3000System.timerConsolidationSystem;
            if (timerSystem) {
              timerSystem.registerTimer("sidebar-performance-monitor", 1e3, () => {
                this.updatePerformanceMetrics();
              });
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Integrated with TimerConsolidationSystem`);
              }
            }
            const animationCoordinator = year3000System.enhancedMasterAnimationCoordinator;
            if (animationCoordinator) {
              animationCoordinator.registerFrameCallback(
                (deltaTime, timestamp) => {
                  this.bilateralVisualEffectsFrameUpdate(deltaTime, timestamp);
                },
                "critical",
                "sidebar-bilateral-visual-effects"
              );
              if (this.config.enableDebug) {
                console.log(`[${this.systemName}] Integrated with EnhancedMasterAnimationCoordinator`);
              }
            }
          } catch (error) {
            console.error(`[${this.systemName}] Failed to integrate with performance systems:`, error);
          }
        }
        /**
         * Handle music beat events for visual-effects synchronization
         */
        handleMusicBeat(payload) {
          if (!this.integrationEnabled) return;
          const beatData = {
            intensity: payload.intensity || 0.5,
            timestamp: payload.timestamp || Date.now(),
            bpm: payload.bpm || 120
          };
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Processed music beat:`, beatData);
          }
        }
        /**
         * Handle music energy changes for adaptive visual effects
         */
        handleMusicEnergy(payload) {
          if (!this.integrationEnabled) return;
          const energyLevel = payload.energy || 0.5;
          this.adjustPerformanceBudgets(0.5 + energyLevel * 0.5);
          if (this.consolidatedSidebarSystem?.initialized) {
            if (this.config.enableDebug) {
              console.log(`[${this.systemName}] Adapted visual effects to energy level: ${energyLevel}`);
            }
          }
        }
        /**
         * Handle performance threshold events
         */
        handlePerformanceThreshold(payload) {
          if (!this.integrationEnabled) return;
          if (payload.severity === "critical") {
            this.performanceMetrics.healthStatus = "critical";
            if (this.config.enableDebug) {
              console.warn(`[${this.systemName}] Activated emergency performance mode`);
            }
          } else if (payload.severity === "warning" && this.performanceMetrics.healthStatus === "critical") {
            this.performanceMetrics.healthStatus = "degraded";
          }
        }
        /**
         * Handle user navigation events for predictive visual effects
         */
        handleUserNavigation(payload) {
          if (!this.integrationEnabled) return;
          const navigationContext = {
            action: payload.action || "navigate",
            target: payload.target || "unknown",
            timestamp: payload.timestamp || Date.now()
          };
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Processing navigation context:`, navigationContext);
          }
        }
        /**
         * Bilateral visual-effects frame update callback
         */
        bilateralVisualEffectsFrameUpdate(deltaTime, timestamp) {
          if (!this.integrationEnabled) return;
          const syncMetrics = {
            frameTime: deltaTime,
            timestamp
          };
          if (deltaTime > 16.67) {
            this.publishEvent("sidebar:frame-time-warning", {
              frameTime: deltaTime,
              timestamp
            });
          }
        }
        /**
         * Clean up all sidebar systems
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log(`[${this.systemName}] Destroying sidebar systems integration`);
          }
          this.integrationEnabled = false;
          const year3000System = globalThis.year3000System;
          if (year3000System?.timerConsolidationSystem) {
            year3000System.timerConsolidationSystem.unregisterTimer("sidebar-performance-monitor");
          }
          const destructionOrder = this.calculateInitializationOrder().reverse();
          for (const systemName of destructionOrder) {
            const systemDef = this.sidebarSystems.get(systemName);
            if (systemDef && systemDef.system.isInitialized) {
              try {
                systemDef.system._baseDestroy();
                if (this.config.enableDebug) {
                  console.log(`[${this.systemName}] Destroyed ${systemName}`);
                }
              } catch (error) {
                console.error(`[${this.systemName}] Failed to destroy ${systemName}:`, error);
              }
            }
          }
          this.sidebarSystems.clear();
          this.performanceMetrics = {
            totalSystems: 0,
            activeSystems: 0,
            bilateralSyncEnabled: false,
            averageFrameTime: 0,
            totalMemoryUsage: 0,
            healthStatus: "healthy"
          };
          this.publishEvent("sidebar:integration-destroyed", {
            timestamp: Date.now()
          });
        }
      };
      __name(_SidebarSystemsIntegration, "SidebarSystemsIntegration");
      SidebarSystemsIntegration = _SidebarSystemsIntegration;
    }
  });

  // src-js/types/systemCreationStrategy.ts
  var _SystemCreationError, SystemCreationError, _DependencyValidationError, DependencyValidationError, _StrategySelectionError, StrategySelectionError;
  var init_systemCreationStrategy = __esm({
    "src-js/types/systemCreationStrategy.ts"() {
      "use strict";
      _SystemCreationError = class _SystemCreationError extends Error {
        constructor(message, systemKey, strategy, context, cause) {
          super(message);
          this.systemKey = systemKey;
          this.strategy = strategy;
          this.context = context;
          this.cause = cause;
          this.name = "SystemCreationError";
        }
      };
      __name(_SystemCreationError, "SystemCreationError");
      SystemCreationError = _SystemCreationError;
      _DependencyValidationError = class _DependencyValidationError extends SystemCreationError {
        constructor(systemKey, strategy, missingDependencies, context) {
          super(
            `Missing required dependencies for ${systemKey}: ${missingDependencies.join(", ")}`,
            systemKey,
            strategy,
            context
          );
          this.missingDependencies = missingDependencies;
          this.name = "DependencyValidationError";
        }
      };
      __name(_DependencyValidationError, "DependencyValidationError");
      DependencyValidationError = _DependencyValidationError;
      _StrategySelectionError = class _StrategySelectionError extends Error {
        constructor(systemKey, criteria, message = `No suitable creation strategy found for system: ${systemKey}`) {
          super(message);
          this.systemKey = systemKey;
          this.criteria = criteria;
          this.name = "StrategySelectionError";
        }
      };
      __name(_StrategySelectionError, "StrategySelectionError");
      StrategySelectionError = _StrategySelectionError;
    }
  });

  // src-js/core/creation/SystemCreationStrategies.ts
  var _BaseCreationStrategy, BaseCreationStrategy, _StandardConstructorStrategy, StandardConstructorStrategy, _EventDrivenCreationStrategy, EventDrivenCreationStrategy, _ObjectDependenciesStrategy, ObjectDependenciesStrategy, _SystemCreationStrategyRegistry, SystemCreationStrategyRegistry, globalSystemCreationRegistry;
  var init_SystemCreationStrategies = __esm({
    "src-js/core/creation/SystemCreationStrategies.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_systemCreationStrategy();
      _BaseCreationStrategy = class _BaseCreationStrategy {
        constructor() {
          this.systemConfigs = /* @__PURE__ */ new Map();
        }
        /**
         * Validate dependencies before creation
         */
        validateDependencies(context) {
          const required = this.getRequiredDependencies(context.systemKey);
          const optional = this.getOptionalDependencies(context.systemKey);
          const missing = [];
          const warnings = [];
          for (const dep of required) {
            if (!(dep in context.dependencies) || !context.dependencies[dep]) {
              missing.push(dep);
            }
          }
          for (const dep of optional) {
            if (!(dep in context.dependencies) || !context.dependencies[dep]) {
              warnings.push(`Optional dependency missing: ${dep}`);
            }
          }
          return {
            valid: missing.length === 0,
            missing,
            warnings
          };
        }
        /**
         * Get required dependencies for system
         */
        getRequiredDependencies(systemKey) {
          const config = this.systemConfigs.get(systemKey);
          return config?.requiredDependencies || [];
        }
        /**
         * Get optional dependencies for system
         */
        getOptionalDependencies(systemKey) {
          const config = this.systemConfigs.get(systemKey);
          return config?.optionalDependencies || [];
        }
        /**
         * Register system configuration
         */
        registerSystemConfig(config) {
          this.systemConfigs.set(config.systemKey, config);
        }
        /**
         * Create base result structure
         */
        createBaseResult(system, context, startTime, error) {
          const endTime = performance.now();
          const creationTime = endTime - startTime;
          return {
            system,
            success: !error && system !== null,
            creationTime,
            strategy: this.getStrategyName(),
            injectedDependencies: Object.keys(context.dependencies),
            warnings: [],
            error: error || void 0,
            metadata: {
              requiresInitialization: true,
              pendingDependencies: [],
              context
            }
          };
        }
      };
      __name(_BaseCreationStrategy, "BaseCreationStrategy");
      BaseCreationStrategy = _BaseCreationStrategy;
      _StandardConstructorStrategy = class _StandardConstructorStrategy extends BaseCreationStrategy {
        constructor() {
          super();
          this.registerKnownSystems();
        }
        getStrategyName() {
          return "StandardConstructor";
        }
        canCreate(context) {
          const config = this.systemConfigs.get(context.systemKey);
          return config !== void 0 && !config.creationPreferences.eventDriven;
        }
        getEstimatedCreationTime(context) {
          return 10;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const validation = this.validateDependencies(context);
            if (!validation.valid && context.preferences.validateDependencies !== false) {
              throw new DependencyValidationError(
                context.systemKey,
                this.getStrategyName(),
                validation.missing,
                context
              );
            }
            const params = this.getConstructorParameters(context);
            const system = new SystemClass(...params);
            const result = this.createBaseResult(system, context, startTime);
            result.warnings = validation.warnings;
            Y3KDebug?.debug?.log(
              "StandardConstructorStrategy",
              `Created ${context.systemKey}`,
              {
                creationTime: result.creationTime,
                parametersUsed: params.length
              }
            );
            return result;
          } catch (error) {
            const result = this.createBaseResult(
              null,
              context,
              startTime,
              error
            );
            Y3KDebug?.debug?.error(
              "StandardConstructorStrategy",
              `Failed to create ${context.systemKey}:`,
              error
            );
            return result;
          }
        }
        /**
         * Get constructor parameters based on system configuration
         */
        getConstructorParameters(context) {
          const config = this.systemConfigs.get(context.systemKey);
          if (!config?.constructorMapping) {
            return this.getStandardParameters(context);
          }
          const params = [];
          const { parameterNames, dependencyMapping } = config.constructorMapping;
          for (const paramName of parameterNames) {
            const depKey = dependencyMapping[paramName] || paramName;
            switch (depKey) {
              case "config":
                params.push(context.config);
                break;
              case "utils":
                params.push(context.utils);
                break;
              case "performanceAnalyzer":
              case "simplePerformanceCoordinator":
                params.push(context.dependencies.simplePerformanceCoordinator || context.dependencies.performanceAnalyzer);
                break;
              case "settingsManager":
                params.push(context.dependencies.settingsManager);
                break;
              case "musicSyncService":
                params.push(context.dependencies.musicSyncService);
                break;
              case "year3000System":
                params.push(context.dependencies.year3000System);
                break;
              case "cssController":
              case "cssConsciousnessController":
                params.push(context.dependencies.cssController || context.dependencies.cssConsciousnessController);
                break;
              case "performanceCoordinator":
                params.push(context.dependencies.performanceCoordinator);
                break;
              case "enhancedDeviceTierDetector":
                params.push(context.dependencies.enhancedDeviceTierDetector);
                break;
              case "webglSystemsIntegration":
                params.push(context.dependencies.webglSystemsIntegration);
                break;
              case "deviceCapabilityDetector":
                params.push(context.dependencies.deviceCapabilityDetector);
                break;
              default:
                params.push(void 0);
            }
          }
          return params;
        }
        /**
         * Get standard parameters for systems without explicit configuration
         */
        getStandardParameters(context) {
          return [
            context.config,
            context.utils,
            context.dependencies.simplePerformanceCoordinator || context.dependencies.performanceAnalyzer,
            context.dependencies.musicSyncService,
            context.dependencies.settingsManager,
            context.dependencies.year3000System
          ];
        }
        /**
         * Register known system configurations
         */
        registerKnownSystems() {
          this.registerSystemConfig({
            systemKey: "ColorHarmonyEngine",
            requiredDependencies: [
              "config",
              "utils",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "EnhancedMasterAnimationCoordinator",
            requiredDependencies: ["config", "performanceCoordinator"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "performanceCoordinator"],
              dependencyMapping: {
                config: "config",
                performanceCoordinator: "performanceCoordinator"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedPerformanceCoordinator",
            requiredDependencies: ["config"],
            optionalDependencies: ["simplePerformanceCoordinator"],
            constructorMapping: {
              parameterNames: ["config", "simplePerformanceCoordinator"],
              dependencyMapping: {
                config: "config",
                simplePerformanceCoordinator: "simplePerformanceCoordinator"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          const simpleSystemKeys = [
            "DeviceCapabilityDetector",
            "SettingsManager"
            // NOTE: SimplePerformanceCoordinator removed - replaced with SimplePerformanceCoordinator (see below)
          ];
          for (const systemKey of simpleSystemKeys) {
            this.registerSystemConfig({
              systemKey,
              requiredDependencies: [],
              optionalDependencies: [],
              constructorMapping: {
                parameterNames: [],
                dependencyMapping: {}
              },
              creationPreferences: {
                useSingleton: false,
                lazyInit: false,
                eventDriven: false,
                builderPattern: false
              }
            });
          }
          this.registerSystemConfig({
            systemKey: "TimerConsolidationSystem",
            requiredDependencies: [],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [],
              dependencyMapping: {}
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "GlassmorphismManager",
            requiredDependencies: [
              "config",
              "utils",
              "cssController",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "cssController",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                cssController: "cssController",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "Card3DManager",
            requiredDependencies: ["simplePerformanceCoordinator", "settingsManager", "utils"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["simplePerformanceCoordinator", "settingsManager", "utils"],
              dependencyMapping: {
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager",
                utils: "utils"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedCSSVariableManager",
            requiredDependencies: ["config", "performanceCoordinator"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["config", "performanceCoordinator"],
              dependencyMapping: {
                config: "config",
                performanceCoordinator: "performanceCoordinator"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "SidebarSystemsIntegration",
            requiredDependencies: ["cssController"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["cssController"],
              dependencyMapping: {
                cssController: "cssController"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "UnifiedSystemIntegration",
            requiredDependencies: ["year3000System"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["year3000System"],
              dependencyMapping: {
                year3000System: "year3000System"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "MusicEmotionAnalyzer",
            requiredDependencies: [
              "config",
              "utils",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
          this.registerNewSimplifiedSystems();
        }
        /**
         * Register new simplified performance system configurations
         */
        registerNewSimplifiedSystems() {
          this.registerSystemConfig({
            systemKey: "SimplePerformanceCoordinator",
            requiredDependencies: ["enhancedDeviceTierDetector", "webglSystemsIntegration"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["enhancedDeviceTierDetector", "webglSystemsIntegration"],
              dependencyMapping: {
                enhancedDeviceTierDetector: "enhancedDeviceTierDetector",
                webglSystemsIntegration: "webglSystemsIntegration"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "SimpleTierBasedPerformanceSystem",
            requiredDependencies: ["enhancedDeviceTierDetector"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["enhancedDeviceTierDetector"],
              dependencyMapping: {
                enhancedDeviceTierDetector: "enhancedDeviceTierDetector"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "EnhancedDeviceTierDetector",
            requiredDependencies: [],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [],
              dependencyMapping: {}
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "WebGLSystemsIntegration",
            requiredDependencies: ["deviceCapabilityDetector"],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: ["deviceCapabilityDetector"],
              dependencyMapping: {
                deviceCapabilityDetector: "deviceCapabilityDetector"
              }
            },
            creationPreferences: {
              useSingleton: true,
              lazyInit: false,
              eventDriven: false,
              builderPattern: false
            }
          });
        }
      };
      __name(_StandardConstructorStrategy, "StandardConstructorStrategy");
      StandardConstructorStrategy = _StandardConstructorStrategy;
      _EventDrivenCreationStrategy = class _EventDrivenCreationStrategy extends BaseCreationStrategy {
        constructor() {
          super();
          this.registerEventDrivenSystems();
        }
        getStrategyName() {
          return "EventDriven";
        }
        canCreate(context) {
          const config = this.systemConfigs.get(context.systemKey);
          return config?.creationPreferences.eventDriven === true;
        }
        getEstimatedCreationTime(context) {
          return 50;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const standardStrategy = new StandardConstructorStrategy();
            const standardResult = await standardStrategy.createSystem(
              SystemClass,
              context
            );
            if (!standardResult.success) {
              return standardResult;
            }
            this.setupEventSubscriptions(standardResult.system, context);
            const result = this.createBaseResult(
              standardResult.system,
              context,
              startTime
            );
            result.warnings = standardResult.warnings;
            Y3KDebug?.debug?.log(
              "EventDrivenCreationStrategy",
              `Created ${context.systemKey} with event subscriptions`
            );
            return result;
          } catch (error) {
            const result = this.createBaseResult(
              null,
              context,
              startTime,
              error
            );
            Y3KDebug?.debug?.error(
              "EventDrivenCreationStrategy",
              `Failed to create ${context.systemKey}:`,
              error
            );
            return result;
          }
        }
        /**
         * Setup event subscriptions during creation
         */
        setupEventSubscriptions(system, context) {
          const eventSubscriptions = this.getEventSubscriptions(context.systemKey);
          for (const eventType of eventSubscriptions) {
            const mappedEventType = this.mapEventType(eventType);
            if (typeof system.handleEvent === "function") {
              unifiedEventBus.subscribe(mappedEventType, (event) => {
                system.handleEvent(event);
              }, `SystemCreation-${context.systemKey}`);
            } else if (typeof system.handleColorExtraction === "function" && (eventType === "colors/extracted" || mappedEventType === "colors:extracted")) {
              unifiedEventBus.subscribe(
                mappedEventType,
                system.handleColorExtraction.bind(system),
                `SystemCreation-${context.systemKey}`
              );
            }
          }
          Y3KDebug?.debug?.log(
            "EventDrivenCreationStrategy",
            `Setup event subscriptions for ${context.systemKey}:`,
            eventSubscriptions
          );
        }
        /**
         * Map old event types to new unified event types
         */
        mapEventType(eventType) {
          const eventMap = {
            "colors/extracted": "colors:extracted",
            "colors/harmonized": "colors:harmonized",
            "music/beat": "music:beat",
            "music/energy": "music:energy",
            "music/track-changed": "music:track-changed",
            "performance/mode-changed": "performance:tier-changed",
            "performance/thermal-warning": "performance:frame",
            "settings/changed": "settings:changed"
          };
          return eventMap[eventType] || eventType;
        }
        /**
         * Get events that system will subscribe to
         */
        getEventSubscriptions(systemKey) {
          const eventSubscriptions = {
            ColorHarmonyEngine: ["colors:extracted", "music:track-changed"],
            MusicEmotionAnalyzer: ["music:beat", "music:energy", "music:track-changed"]
          };
          return eventSubscriptions[systemKey] || [];
        }
        /**
         * Register event-driven systems with their configurations
         */
        registerEventDrivenSystems() {
          this.registerSystemConfig({
            systemKey: "ColorHarmonyEngine",
            requiredDependencies: [
              "config",
              "utils",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
          this.registerSystemConfig({
            systemKey: "MusicEmotionAnalyzer",
            requiredDependencies: [
              "config",
              "utils",
              "simplePerformanceCoordinator",
              "settingsManager"
            ],
            optionalDependencies: [],
            constructorMapping: {
              parameterNames: [
                "config",
                "utils",
                "simplePerformanceCoordinator",
                "settingsManager"
              ],
              dependencyMapping: {
                config: "config",
                utils: "utils",
                simplePerformanceCoordinator: "simplePerformanceCoordinator",
                settingsManager: "settingsManager"
              }
            },
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
        }
      };
      __name(_EventDrivenCreationStrategy, "EventDrivenCreationStrategy");
      EventDrivenCreationStrategy = _EventDrivenCreationStrategy;
      _ObjectDependenciesStrategy = class _ObjectDependenciesStrategy extends BaseCreationStrategy {
        constructor() {
          super();
          this.registerObjectDependencySystems();
        }
        getStrategyName() {
          return "ObjectDependencies";
        }
        canCreate(context) {
          return context.systemKey === "MusicSyncService";
        }
        getEstimatedCreationTime(context) {
          return 30;
        }
        async createSystem(SystemClass, context) {
          const startTime = performance.now();
          try {
            const validation = this.validateDependencies(context);
            if (!validation.valid && context.preferences.validateDependencies !== false) {
              throw new DependencyValidationError(
                context.systemKey,
                this.getStrategyName(),
                validation.missing,
                context
              );
            }
            const dependencies = {
              ADVANCED_SYSTEM_CONFIG: context.config,
              ThemeUtilities: context.utils,
              settingsManager: context.dependencies.settingsManager,
              year3000System: context.dependencies.year3000System
              // NOTE: colorHarmonyEngine deliberately omitted - using event-driven pattern instead
            };
            const system = new SystemClass(dependencies);
            const result = this.createBaseResult(system, context, startTime);
            result.warnings = validation.warnings;
            result.metadata.pendingDependencies = [];
            Y3KDebug?.debug?.log(
              "ObjectDependenciesStrategy",
              `Created ${context.systemKey} with event-driven dependencies`
            );
            return result;
          } catch (error) {
            const result = this.createBaseResult(
              null,
              context,
              startTime,
              error
            );
            Y3KDebug?.debug?.error(
              "ObjectDependenciesStrategy",
              `Failed to create ${context.systemKey}:`,
              error
            );
            return result;
          }
        }
        /**
         * Register systems that use object dependencies
         */
        registerObjectDependencySystems() {
          this.registerSystemConfig({
            systemKey: "MusicSyncService",
            requiredDependencies: ["config", "utils"],
            optionalDependencies: ["settingsManager", "year3000System"],
            creationPreferences: {
              useSingleton: false,
              lazyInit: false,
              eventDriven: true,
              builderPattern: false
            }
          });
        }
      };
      __name(_ObjectDependenciesStrategy, "ObjectDependenciesStrategy");
      ObjectDependenciesStrategy = _ObjectDependenciesStrategy;
      _SystemCreationStrategyRegistry = class _SystemCreationStrategyRegistry {
        constructor() {
          this.strategies = /* @__PURE__ */ new Map();
          this.registerDefaultStrategies();
        }
        /**
         * Register a creation strategy
         */
        register(strategy) {
          this.strategies.set(strategy.getStrategyName(), strategy);
          Y3KDebug?.debug?.log(
            "SystemCreationStrategyRegistry",
            `Registered strategy: ${strategy.getStrategyName()}`
          );
        }
        /**
         * Select best strategy for given criteria
         */
        selectStrategy(systemKey, criteria) {
          const candidateStrategies = this.getStrategiesForSystem(systemKey);
          if (candidateStrategies.length === 0) {
            return null;
          }
          let bestStrategy = candidateStrategies[0];
          if (!bestStrategy) {
            return null;
          }
          let bestScore = this.scoreStrategy(bestStrategy, systemKey, criteria);
          for (let i = 1; i < candidateStrategies.length; i++) {
            const strategy = candidateStrategies[i];
            if (!strategy) continue;
            const score = this.scoreStrategy(strategy, systemKey, criteria);
            if (score > bestScore) {
              bestStrategy = strategy;
              bestScore = score;
            }
          }
          return bestStrategy;
        }
        /**
         * Get all registered strategies
         */
        getStrategies() {
          return Array.from(this.strategies.values());
        }
        /**
         * Get strategy by name
         */
        getStrategy(name) {
          return this.strategies.get(name) || null;
        }
        /**
         * Get strategies that can create a specific system
         */
        getStrategiesForSystem(systemKey) {
          const context = {
            systemKey,
            config: {},
            utils: {},
            dependencies: {},
            preferences: {},
            metadata: {
              timestamp: Date.now(),
              reason: "startup",
              priority: "medium"
            }
          };
          return this.getStrategies().filter(
            (strategy) => strategy.canCreate(context)
          );
        }
        /**
         * Score strategy based on selection criteria
         */
        scoreStrategy(strategy, systemKey, criteria) {
          let score = 0;
          score += 10;
          if (criteria.dependencyRequirements === "event-driven") {
            if (strategy.getStrategyName() === "EventDriven") score += 20;
            if (strategy.getStrategyName() === "ObjectDependencies") score += 15;
          } else if (criteria.dependencyRequirements === "basic") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 20;
          }
          if (criteria.performance === "lightweight") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 15;
          } else if (criteria.performance === "optimized") {
            if (strategy.getStrategyName() === "EventDriven") score += 10;
          }
          if (criteria.creationContext === "startup") {
            if (strategy.getStrategyName() === "StandardConstructor") score += 5;
          }
          return score;
        }
        /**
         * Register default strategies
         */
        registerDefaultStrategies() {
          this.register(new StandardConstructorStrategy());
          this.register(new EventDrivenCreationStrategy());
          this.register(new ObjectDependenciesStrategy());
        }
        /**
         * Get registry status
         */
        getStatus() {
          return {
            strategyCount: this.strategies.size,
            strategies: Array.from(this.strategies.keys())
          };
        }
      };
      __name(_SystemCreationStrategyRegistry, "SystemCreationStrategyRegistry");
      SystemCreationStrategyRegistry = _SystemCreationStrategyRegistry;
      globalSystemCreationRegistry = new SystemCreationStrategyRegistry();
    }
  });

  // src-js/core/creation/StrategyBasedFactory.ts
  var _StrategyBasedFactory, StrategyBasedFactory, globalStrategyBasedFactory;
  var init_StrategyBasedFactory = __esm({
    "src-js/core/creation/StrategyBasedFactory.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_systemCreationStrategy();
      init_SystemCreationStrategies();
      _StrategyBasedFactory = class _StrategyBasedFactory {
        constructor(strategyRegistry) {
          this.systemConfigs = /* @__PURE__ */ new Map();
          this.creationMetrics = {
            totalCreations: 0,
            successfulCreations: 0,
            averageCreationTime: 0,
            strategyUsage: {}
          };
          this.strategyRegistry = strategyRegistry || globalSystemCreationRegistry;
          Y3KDebug?.debug?.log(
            "StrategyBasedFactory",
            "Factory initialized with strategy registry"
          );
        }
        /**
         * Create system using best available strategy
         */
        async createSystem(systemKey, SystemClass, context) {
          const startTime = performance.now();
          try {
            this.creationMetrics.totalCreations++;
            const systemConfig = this.getSystemConfig(systemKey);
            const criteria = this.buildSelectionCriteria(
              systemKey,
              systemConfig,
              context
            );
            const strategy = this.strategyRegistry.selectStrategy(
              systemKey,
              criteria
            );
            if (!strategy) {
              throw new StrategySelectionError(systemKey, criteria);
            }
            const strategyName = strategy.getStrategyName();
            this.creationMetrics.strategyUsage[strategyName] = (this.creationMetrics.strategyUsage[strategyName] || 0) + 1;
            const result = await strategy.createSystem(SystemClass, context);
            if (result.success) {
              this.creationMetrics.successfulCreations++;
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            this.updateAverageCreationTime(totalTime);
            Y3KDebug?.debug?.log(
              "StrategyBasedFactory",
              `Created ${systemKey} using ${strategyName}`,
              {
                success: result.success,
                creationTime: result.creationTime,
                totalTime
              }
            );
            return result;
          } catch (error) {
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            Y3KDebug?.debug?.error(
              "StrategyBasedFactory",
              `Failed to create ${systemKey}:`,
              error
            );
            return {
              system: null,
              success: false,
              creationTime: totalTime,
              strategy: "unknown",
              injectedDependencies: [],
              warnings: [],
              error,
              metadata: {
                requiresInitialization: false,
                pendingDependencies: [],
                context
              }
            };
          }
        }
        /**
         * Register system creation configuration
         */
        registerSystemConfig(config) {
          this.systemConfigs.set(config.systemKey, config);
          Y3KDebug?.debug?.log(
            "StrategyBasedFactory",
            `Registered config for ${config.systemKey}`
          );
        }
        /**
         * Get system creation configuration
         */
        getSystemConfig(systemKey) {
          return this.systemConfigs.get(systemKey) || null;
        }
        /**
         * Update creation strategy registry
         */
        setStrategyRegistry(registry2) {
          this.strategyRegistry = registry2;
          Y3KDebug?.debug?.log("StrategyBasedFactory", "Strategy registry updated");
        }
        /**
         * Get factory performance metrics
         */
        getMetrics() {
          return { ...this.creationMetrics };
        }
        /**
         * Reset performance metrics
         */
        resetMetrics() {
          this.creationMetrics = {
            totalCreations: 0,
            successfulCreations: 0,
            averageCreationTime: 0,
            strategyUsage: {}
          };
        }
        // ============================================================================
        // Private Helper Methods
        // ============================================================================
        /**
         * Build selection criteria based on system key and context
         * No longer relies on factory's own systemConfig - strategies manage their own configurations
         */
        buildSelectionCriteria(systemKey, systemConfig, context) {
          let complexity = "medium";
          const simpleSystems = [
            "DeviceCapabilityDetector",
            "PerformanceAnalyzer",
            "UnifiedCSSVariableManager",
            "SettingsManager",
            "TimerConsolidationSystem"
          ];
          const complexSystems = [
            "GlassmorphismManager",
            "Card3DManager",
            "UnifiedCSSVariableManager",
            "EnhancedMasterAnimationCoordinator"
          ];
          if (simpleSystems.includes(systemKey)) {
            complexity = "simple";
          } else if (complexSystems.includes(systemKey)) {
            complexity = "complex";
          }
          let dependencyRequirements = "basic";
          if (systemKey === "MusicSyncService" || systemKey === "ColorHarmonyEngine") {
            dependencyRequirements = "event-driven";
          } else if (simpleSystems.includes(systemKey)) {
            dependencyRequirements = "none";
          }
          let performance2 = "standard";
          if (context.metadata.priority === "critical") {
            performance2 = "optimized";
          } else if (context.preferences.monitorCreation) {
            performance2 = "optimized";
          } else if (complexity === "simple") {
            performance2 = "lightweight";
          }
          return {
            complexity,
            dependencyRequirements,
            performance: performance2,
            resourceConstraints: {
              memoryLimited: context.metadata.resourceConstraints?.maxMemoryMB !== void 0,
              timeLimited: context.metadata.resourceConstraints?.maxInitTimeMs !== void 0,
              cpuLimited: context.metadata.priority === "low"
            },
            creationContext: context.metadata.reason
          };
        }
        /**
         * Update running average creation time
         */
        updateAverageCreationTime(newTime) {
          const totalCreations = this.creationMetrics.totalCreations;
          const currentAverage = this.creationMetrics.averageCreationTime;
          this.creationMetrics.averageCreationTime = (currentAverage * (totalCreations - 1) + newTime) / totalCreations;
        }
        /**
         * Register default system configurations for known systems
         * DEPRECATED: System configurations are now managed by individual strategies
         */
        registerDefaultSystemConfigs() {
        }
      };
      __name(_StrategyBasedFactory, "StrategyBasedFactory");
      StrategyBasedFactory = _StrategyBasedFactory;
      globalStrategyBasedFactory = new StrategyBasedFactory();
    }
  });

  // src-js/core/integration/FacadeAdapter.ts
  var _NonVisualSystemFacadeAdapter, NonVisualSystemFacadeAdapter, globalFacadeAdapter;
  var init_FacadeAdapter = __esm({
    "src-js/core/integration/FacadeAdapter.ts"() {
      "use strict";
      init_StrategyBasedFactory();
      init_UnifiedDebugManager();
      _NonVisualSystemFacadeAdapter = class _NonVisualSystemFacadeAdapter {
        constructor(strategyBasedFactory) {
          this.adapted = false;
          this.originalFacade = null;
          this.migrationProgress = 0;
          this.systemsUsingStrategy = /* @__PURE__ */ new Set();
          this.systemsUsingLegacy = /* @__PURE__ */ new Set();
          this.strategyBasedFactory = strategyBasedFactory || globalStrategyBasedFactory;
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacadeAdapter",
            "Facade adapter initialized"
          );
        }
        /**
         * Adapt facade to use strategy-based creation
         */
        adaptToStrategyPattern(factory) {
          this.strategyBasedFactory = factory;
          this.adapted = true;
          this.migrationProgress = 1;
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacadeAdapter",
            "Facade adapted to strategy pattern"
          );
        }
        /**
         * Get migration status
         */
        getMigrationStatus() {
          return {
            adapted: this.adapted,
            systemsUsingStrategyPattern: Array.from(this.systemsUsingStrategy),
            systemsUsingLegacyPattern: Array.from(this.systemsUsingLegacy),
            migrationProgress: this.migrationProgress
          };
        }
        /**
         * Complete migration to strategy pattern
         */
        async completeMigration() {
          if (!this.adapted) {
            this.adaptToStrategyPattern(this.strategyBasedFactory);
          }
          this.migrationProgress = 1;
          this.systemsUsingLegacy.clear();
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacadeAdapter",
            "Migration to strategy pattern completed"
          );
        }
        /**
         * Create system using strategy-based factory (replaces hardcoded constructor logic)
         */
        async createSystemWithStrategy(systemKey, SystemClass, context) {
          const creationContext = {
            systemKey,
            config: context.config,
            utils: context.utils,
            dependencies: context.dependencies,
            preferences: {
              lazyInit: false,
              validateDependencies: true,
              creationTimeout: 5e3,
              monitorCreation: true
            },
            metadata: {
              timestamp: Date.now(),
              reason: "startup",
              priority: "medium",
              resourceConstraints: {
                maxMemoryMB: 50,
                maxInitTimeMs: 1e3
              }
            }
          };
          try {
            const result = await this.strategyBasedFactory.createSystem(
              systemKey,
              SystemClass,
              creationContext
            );
            if (result.success) {
              this.systemsUsingStrategy.add(systemKey);
              this.systemsUsingLegacy.delete(systemKey);
            } else {
              this.systemsUsingLegacy.add(systemKey);
            }
            this.updateMigrationProgress();
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacadeAdapter",
              `Created ${systemKey} via strategy pattern`,
              {
                strategy: result.strategy,
                success: result.success,
                creationTime: result.creationTime
              }
            );
            return result;
          } catch (error) {
            this.systemsUsingLegacy.add(systemKey);
            this.updateMigrationProgress();
            Y3KDebug?.debug?.error(
              "NonVisualSystemFacadeAdapter",
              `Failed to create ${systemKey} via strategy pattern:`,
              error
            );
            return {
              system: null,
              success: false,
              creationTime: 0,
              strategy: "adapter-fallback",
              injectedDependencies: [],
              warnings: [`Strategy creation failed: ${error}`],
              error,
              metadata: {
                requiresInitialization: false,
                pendingDependencies: [],
                context: creationContext
              }
            };
          }
        }
        /**
         * Legacy compatibility method - creates system using old hardcoded logic
         * This should be gradually phased out as systems migrate to strategy pattern
         */
        createSystemLegacy(systemKey, SystemClass, context) {
          this.systemsUsingLegacy.add(systemKey);
          this.updateMigrationProgress();
          Y3KDebug?.debug?.warn(
            "NonVisualSystemFacadeAdapter",
            `Using legacy creation for ${systemKey} - should migrate to strategy pattern`
          );
          switch (systemKey) {
            case "DeviceCapabilityDetector":
            case "PerformanceAnalyzer":
            case "SettingsManager":
            case "TimerConsolidationSystem":
              return new SystemClass();
            case "SidebarSystemsIntegration":
              return new SystemClass(
                context.dependencies.cssConsciousnessController
              );
            case "OptimizedCSSVariableManager":
              return new SystemClass(
                context.config,
                context.dependencies.performanceCoordinator
              );
            case "ColorHarmonyEngine":
              return new SystemClass(
                context.config,
                context.utils,
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager
              );
            case "EnhancedMasterAnimationCoordinator":
              return new SystemClass(
                context.config,
                context.dependencies.performanceCoordinator
              );
            case "UnifiedPerformanceCoordinator":
              return new SystemClass(
                context.config,
                context.dependencies.performanceAnalyzer
              );
            case "GlassmorphismManager":
              return new SystemClass(
                context.config,
                context.utils,
                context.dependencies.cssConsciousnessController,
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager
              );
            case "Card3DManager":
              return new SystemClass(
                context.dependencies.performanceAnalyzer,
                context.dependencies.settingsManager,
                context.utils
              );
            case "MusicSyncService":
              return new SystemClass({
                ADVANCED_SYSTEM_CONFIG: context.config,
                ThemeUtilities: context.utils,
                settingsManager: context.dependencies.settingsManager,
                year3000System: context.year3000System
                // NOTE: colorHarmonyEngine deliberately omitted - using event-driven pattern
              });
            case "EnhancedDeviceTierDetector":
              return SystemClass;
            case "WebGLSystemsIntegration":
              const deviceCapabilityDetector = context.dependencies.deviceCapabilityDetector;
              if (!deviceCapabilityDetector) {
                throw new Error("WebGLSystemsIntegration requires DeviceCapabilityDetector");
              }
              return new SystemClass(deviceCapabilityDetector);
            case "SimplePerformanceCoordinator":
              const enhancedTierDetector = context.dependencies.enhancedDeviceTierDetector;
              const webglIntegration = context.dependencies.webglSystemsIntegration;
              if (!enhancedTierDetector || !webglIntegration) {
                throw new Error("SimplePerformanceCoordinator requires EnhancedDeviceTierDetector and WebGLSystemsIntegration");
              }
              return new SystemClass(enhancedTierDetector, webglIntegration);
            case "SimpleTierBasedPerformanceSystem":
              const tierDetector = context.dependencies.enhancedDeviceTierDetector;
              if (!tierDetector) {
                throw new Error("SimpleTierBasedPerformanceSystem requires EnhancedDeviceTierDetector");
              }
              return new SystemClass(tierDetector);
            default:
              try {
                return new SystemClass();
              } catch (error) {
                return new SystemClass(
                  context.config,
                  context.utils,
                  context.dependencies.performanceAnalyzer,
                  context.dependencies.settingsManager
                );
              }
          }
        }
        /**
         * Update migration progress based on strategy vs legacy usage
         */
        updateMigrationProgress() {
          const totalSystems = this.systemsUsingStrategy.size + this.systemsUsingLegacy.size;
          if (totalSystems === 0) {
            this.migrationProgress = 0;
          } else {
            this.migrationProgress = this.systemsUsingStrategy.size / totalSystems;
          }
        }
        /**
         * Get adapter performance metrics
         */
        getAdapterMetrics() {
          const totalSystems = this.systemsUsingStrategy.size + this.systemsUsingLegacy.size;
          return {
            totalSystemsAdapted: this.systemsUsingStrategy.size,
            strategySuccessRate: totalSystems > 0 ? this.systemsUsingStrategy.size / totalSystems : 0,
            migrationProgress: this.migrationProgress,
            systemBreakdown: {
              strategy: Array.from(this.systemsUsingStrategy),
              legacy: Array.from(this.systemsUsingLegacy)
            }
          };
        }
        /**
         * Force migration of specific system to strategy pattern
         */
        async migrateSystemToStrategy(systemKey) {
          try {
            this.systemsUsingLegacy.delete(systemKey);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacadeAdapter",
              `Migrated ${systemKey} to strategy pattern`
            );
            return true;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "NonVisualSystemFacadeAdapter",
              `Failed to migrate ${systemKey} to strategy pattern:`,
              error
            );
            return false;
          }
        }
        /**
         * Get recommended migration order for systems
         */
        getRecommendedMigrationOrder() {
          const migrationOrder = [
            // Simple systems (no dependencies)
            "PerformanceAnalyzer",
            "OptimizedCSSVariableManager",
            "DeviceCapabilityDetector",
            "SettingsManager",
            // Event-driven systems
            "ColorHarmonyEngine",
            "MusicSyncService",
            // Complex systems
            "UnifiedPerformanceCoordinator",
            "EnhancedMasterAnimationCoordinator",
            // Integration systems
            "UnifiedSystemIntegration",
            // UI systems
            "GlassmorphismManager",
            "Card3DManager"
          ];
          return migrationOrder.filter(
            (system) => this.systemsUsingLegacy.has(system)
          );
        }
      };
      __name(_NonVisualSystemFacadeAdapter, "NonVisualSystemFacadeAdapter");
      NonVisualSystemFacadeAdapter = _NonVisualSystemFacadeAdapter;
      globalFacadeAdapter = new NonVisualSystemFacadeAdapter();
    }
  });

  // src-js/core/integration/NonVisualSystemFacade.ts
  var _NonVisualSystemFacade, NonVisualSystemFacade;
  var init_NonVisualSystemFacade = __esm({
    "src-js/core/integration/NonVisualSystemFacade.ts"() {
      "use strict";
      init_UnifiedDebugManager();
      init_EnhancedMasterAnimationCoordinator();
      init_OptimizedCSSVariableManager();
      init_TimerConsolidationSystem();
      init_SimplePerformanceCoordinator();
      init_SimpleTierBasedPerformanceSystem();
      init_EnhancedDeviceTierDetector();
      init_WebGLSystemsIntegration();
      init_DeviceCapabilityDetector();
      init_UnifiedPerformanceCoordinator();
      init_PerformanceBudgetManager();
      init_ColorHarmonyEngine();
      init_MusicSyncService();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_LoadingStateService();
      init_VisualEffectsCoordinator();
      init_MusicEmotionAnalyzer();
      init_UnifiedColorProcessingEngine();
      init_Card3DManager();
      init_GlassmorphismManager();
      init_GenreUIBridge();
      init_SidebarSystemsIntegration();
      init_FacadeAdapter();
      _NonVisualSystemFacade = class _NonVisualSystemFacade {
        constructor(config, utils, year3000System) {
          // Reference to main system
          // Core shared dependencies (will be injected from main system)
          this.cssVariableManager = null;
          this.musicSyncService = null;
          this.settingsManager = null;
          this.loadingStateService = null;
          // Phase 8.5: Active loading state management
          // New simplified performance system dependencies
          this.simplePerformanceCoordinator = null;
          this.webglSystemsIntegration = null;
          this.enhancedDeviceTierDetector = null;
          // Legacy performance system dependencies (deprecated, for backward compatibility)
          this.performanceAnalyzer = null;
          this.performanceCoordinator = null;
          this.performanceOrchestrator = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Monitoring intervals
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Event callbacks
          this.onSystemCreated = null;
          this.onSystemFailed = null;
          this.onHealthChange = null;
          // Strategy-based creation adapter
          this.facadeAdapter = globalFacadeAdapter;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System;
          if (year3000System && typeof year3000System === "object" && "performanceAnalyzer" in year3000System) {
            this.performanceAnalyzer = year3000System.performanceAnalyzer || null;
            this.cssVariableManager = year3000System.unifiedCSSConsciousnessController || null;
            this.performanceCoordinator = year3000System.unifiedPerformanceCoordinator || null;
            this.performanceOrchestrator = year3000System.performanceOrchestrator || null;
            this.musicSyncService = year3000System.musicSyncService || null;
            this.settingsManager = year3000System.settingsManager || null;
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Shared dependencies injected from SystemCoordinator",
              {
                performanceAnalyzer: !!this.performanceAnalyzer,
                cssVariableManager: !!this.cssVariableManager,
                performanceOrchestrator: !!this.performanceOrchestrator,
                musicSyncService: !!this.musicSyncService,
                settingsManager: !!this.settingsManager
              }
            );
          }
          this.systemRegistry = /* @__PURE__ */ new Map();
          this.systemCache = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.facadeConfig = {
            mode: "progressive",
            enablePerformanceMonitoring: true,
            enableDependencyInjection: true,
            enableSystemHealthMonitoring: true,
            performanceThresholds: {
              maxInitTime: 5e3,
              // 5 seconds
              maxMemoryMB: 100,
              maxCPUPercent: 15
            },
            systemPreferences: {
              lazyInitialization: true,
              aggressiveCaching: true,
              performanceOptimization: true
            }
          };
          this.currentMetrics = this.createInitialMetrics();
          this.registerNonVisualSystems();
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacade",
            "Non-visual systems facade initialized"
          );
        }
        registerNonVisualSystems() {
          this.systemRegistry.set(
            "EnhancedMasterAnimationCoordinator",
            EnhancedMasterAnimationCoordinator
          );
          this.systemDependencies.set("EnhancedMasterAnimationCoordinator", [
            "performanceAnalyzer",
            "cssVariableManager"
          ]);
          this.systemRegistry.set(
            "TimerConsolidationSystem",
            TimerConsolidationSystem
          );
          this.systemDependencies.set("TimerConsolidationSystem", [
            "performanceAnalyzer"
          ]);
          this.systemRegistry.set(
            "OptimizedCSSVariableManager",
            OptimizedCSSVariableManager
          );
          this.systemDependencies.set("OptimizedCSSVariableManager", [
            "performanceCoordinator"
          ]);
          this.systemRegistry.set(
            "UnifiedCSSVariableManager",
            OptimizedCSSVariableManager
          );
          this.systemDependencies.set("UnifiedCSSVariableManager", [
            "performanceCoordinator"
          ]);
          this.systemRegistry.set(
            "PerformanceAnalyzer",
            PerformanceAnalyzer
          );
          this.systemDependencies.set("PerformanceAnalyzer", []);
          this.systemRegistry.set(
            "DeviceCapabilityDetector",
            DeviceCapabilityDetector
          );
          this.systemDependencies.set("DeviceCapabilityDetector", []);
          this.systemRegistry.set("PerformanceAnalyzer", SimplePerformanceCoordinator);
          this.systemDependencies.set("PerformanceAnalyzer", []);
          this.systemRegistry.set("CSSVariableBatcher", OptimizedCSSVariableManager);
          this.systemDependencies.set("CSSVariableBatcher", []);
          this.systemRegistry.set("SystemHealthMonitor", SimplePerformanceCoordinator);
          this.systemDependencies.set("SystemHealthMonitor", []);
          this.systemRegistry.set("UnifiedSystemIntegration", SidebarSystemsIntegration);
          this.systemDependencies.set("UnifiedSystemIntegration", []);
          this.systemRegistry.set(
            "PerformanceBudgetManager",
            PerformanceBudgetManager
          );
          this.systemDependencies.set("PerformanceBudgetManager", [
            "performanceAnalyzer"
          ]);
          this.systemRegistry.set("SimplePerformanceCoordinator", SimplePerformanceCoordinator);
          this.systemDependencies.set("SimplePerformanceCoordinator", [
            "performanceAnalyzer",
            "performanceCoordinator",
            "deviceCapabilityDetector",
            "performanceBudgetManager"
          ]);
          this.systemRegistry.set("SimplePerformanceCoordinator", SimplePerformanceCoordinator);
          this.systemDependencies.set("SimplePerformanceCoordinator", [
            "enhancedDeviceTierDetector",
            "webglSystemsIntegration"
          ]);
          this.systemRegistry.set("SimpleTierBasedPerformanceSystem", SimpleTierBasedPerformanceSystem);
          this.systemDependencies.set("SimpleTierBasedPerformanceSystem", [
            "enhancedDeviceTierDetector"
          ]);
          this.systemRegistry.set("EnhancedDeviceTierDetector", EnhancedDeviceTierDetector);
          this.systemDependencies.set("EnhancedDeviceTierDetector", []);
          this.systemRegistry.set("WebGLSystemsIntegration", WebGLSystemsIntegration);
          this.systemDependencies.set("WebGLSystemsIntegration", [
            "deviceCapabilityDetector"
            // WebGLSystemsIntegration needs DeviceCapabilityDetector, not EnhancedDeviceTierDetector
          ]);
          this.systemDependencies.set("UnifiedDebugManager", []);
          this.systemRegistry.set("SettingsManager", SettingsManager);
          this.systemDependencies.set("SettingsManager", []);
          this.systemRegistry.set("ColorHarmonyEngine", ColorHarmonyEngine);
          this.systemDependencies.set("ColorHarmonyEngine", ["musicSyncService"]);
          this.systemRegistry.set("MusicSyncService", MusicSyncService);
          this.systemDependencies.set("MusicSyncService", []);
          this.systemRegistry.set("LoadingStateService", LoadingStateService);
          this.systemDependencies.set("LoadingStateService", ["performanceAnalyzer", "settingsManager"]);
          this.systemRegistry.set(
            "UnifiedColorProcessingEngine",
            UnifiedColorProcessingEngine
          );
          this.systemDependencies.set("UnifiedColorProcessingEngine", [
            "settingsManager",
            "performanceAnalyzer"
          ]);
          this.systemDependencies.set("ColorOrchestrator", []);
          this.systemRegistry.set("MusicEmotionAnalyzer", MusicEmotionAnalyzer);
          this.systemDependencies.set("MusicEmotionAnalyzer", [
            "musicSyncService",
            "settingsManager"
          ]);
          this.systemRegistry.set(
            "VisualEffectsCoordinator",
            VisualEffectsCoordinator
          );
          this.systemDependencies.set("VisualEffectsCoordinator", [
            "settingsManager"
          ]);
          this.systemRegistry.set("GlassmorphismManager", GlassmorphismManager);
          this.systemDependencies.set("GlassmorphismManager", [
            "cssVariableManager",
            "performanceAnalyzer",
            "settingsManager"
          ]);
          this.systemRegistry.set("Card3DManager", Card3DManager);
          this.systemDependencies.set("Card3DManager", [
            "performanceAnalyzer",
            "settingsManager"
          ]);
          this.systemRegistry.set("GenreUIBridge", GenreUIBridge);
          this.systemDependencies.set("GenreUIBridge", [
            "GenreProfileManager",
            "MusicSyncService"
          ]);
          this.systemRegistry.set(
            "SidebarSystemsIntegration",
            SidebarSystemsIntegration
          );
          this.systemDependencies.set("SidebarSystemsIntegration", [
            "cssVariableManager"
          ]);
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3KDebug?.debug?.warn("NonVisualSystemFacade", "Already initialized");
            return;
          }
          try {
            const startTime = performance.now();
            this.facadeConfig = { ...this.facadeConfig, ...config };
            await this.initializeSharedDependencies();
            await this.applyConfiguration();
            this.startMonitoring();
            await this.performHealthCheck();
            const endTime = performance.now();
            this.currentMetrics.systemInitializationTime = endTime - startTime;
            this.isInitialized = true;
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Non-visual systems facade fully initialized",
              {
                mode: this.facadeConfig.mode,
                systemsRegistered: this.systemRegistry.size,
                initTime: this.currentMetrics.systemInitializationTime
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "NonVisualSystemFacade",
              "Initialization failed:",
              error
            );
            await this.cleanup();
            throw error;
          }
        }
        async initializeSharedDependencies() {
          const coreSystemsOrder = [
            // Core dependency systems first
            "DeviceCapabilityDetector",
            // Needed by WebGL integration
            "EnhancedDeviceTierDetector",
            // Needed by simplified performance systems
            // New simplified performance systems (primary) - order matters for dependencies
            "WebGLSystemsIntegration",
            // Depends on DeviceCapabilityDetector
            "SimplePerformanceCoordinator",
            // Depends on EnhancedDeviceTierDetector and WebGLSystemsIntegration
            // Legacy performance systems (for backward compatibility)
            "PerformanceAnalyzer",
            "PerformanceAnalyzer",
            "SimplePerformanceCoordinator",
            // Shared systems
            "OptimizedCSSVariableManager",
            "SettingsManager",
            "UnifiedDebugManager",
            "MusicSyncService",
            "LoadingStateService"
            // Phase 8.5: Active loading state management (depends on performanceAnalyzer, settingsManager)
          ];
          for (const systemKey of coreSystemsOrder) {
            try {
              const system = await this.getSystem(systemKey);
              if (system && typeof system.initialize === "function") {
                await system.initialize();
              }
              switch (systemKey) {
                case "DeviceCapabilityDetector":
                  if (this.year3000System) {
                    this.year3000System.deviceCapabilityDetector = system;
                  }
                  break;
                case "EnhancedDeviceTierDetector":
                  this.enhancedDeviceTierDetector = system;
                  break;
                case "WebGLSystemsIntegration":
                  this.webglSystemsIntegration = system;
                  break;
                case "SimplePerformanceCoordinator":
                  this.simplePerformanceCoordinator = system;
                  this.performanceOrchestrator = system;
                  break;
                case "PerformanceAnalyzer":
                  this.performanceAnalyzer = system;
                  this.performanceCoordinator = system;
                  break;
                case "OptimizedCSSVariableManager":
                  this.cssVariableManager = system;
                  break;
                case "SettingsManager":
                  this.settingsManager = system;
                  break;
                case "UnifiedDebugManager":
                  break;
                case "MusicSyncService":
                  this.musicSyncService = system;
                  break;
                case "LoadingStateService":
                  this.loadingStateService = system;
                  break;
              }
            } catch (error) {
              Y3KDebug?.debug?.error(
                "NonVisualSystemFacade",
                `Failed to initialize ${systemKey}:`,
                error
              );
            }
          }
        }
        /**
         * Get system from cache (synchronous) - returns null if not cached
         * Use this for scenarios where the system should already be initialized
         */
        getCachedSystem(key) {
          const cached = this.systemCache.get(key);
          if (cached) {
            return cached;
          }
          if (key === "DeviceCapabilityDetector" && this.year3000System?.deviceCapabilityDetector) {
            const deviceCapabilityDetector = this.year3000System.deviceCapabilityDetector;
            this.systemCache.set(key, deviceCapabilityDetector);
            return deviceCapabilityDetector;
          }
          if (key === "EnhancedDeviceTierDetector" && this.enhancedDeviceTierDetector) {
            this.systemCache.set(key, this.enhancedDeviceTierDetector);
            return this.enhancedDeviceTierDetector;
          }
          if (key === "WebGLSystemsIntegration" && this.webglSystemsIntegration) {
            this.systemCache.set(key, this.webglSystemsIntegration);
            return this.webglSystemsIntegration;
          }
          if (key === "SimplePerformanceCoordinator" && this.simplePerformanceCoordinator) {
            this.systemCache.set(key, this.simplePerformanceCoordinator);
            return this.simplePerformanceCoordinator;
          }
          if (key === "PerformanceAnalyzer" && this.performanceAnalyzer) {
            this.systemCache.set(key, this.performanceAnalyzer);
            return this.performanceAnalyzer;
          }
          if (key === "SimplePerformanceCoordinator" && this.performanceOrchestrator) {
            this.systemCache.set(key, this.performanceOrchestrator);
            return this.performanceOrchestrator;
          }
          if ((key === "OptimizedCSSVariableManager" || key === "UnifiedCSSVariableManager") && this.cssVariableManager) {
            this.systemCache.set(key, this.cssVariableManager);
            return this.cssVariableManager;
          }
          if (key === "MusicSyncService" && this.musicSyncService) {
            this.systemCache.set(key, this.musicSyncService);
            return this.musicSyncService;
          }
          if (key === "SettingsManager" && this.settingsManager) {
            this.systemCache.set(key, this.settingsManager);
            return this.settingsManager;
          }
          if (key === "LoadingStateService" && this.loadingStateService) {
            this.systemCache.set(key, this.loadingStateService);
            return this.loadingStateService;
          }
          return null;
        }
        /**
         * Factory method to create and return non-visual systems
         * This is the main interface for the facade pattern
         */
        async getSystem(key) {
          if (this.systemCache.has(key)) {
            return this.systemCache.get(key);
          }
          if (key === "DeviceCapabilityDetector" && this.year3000System?.deviceCapabilityDetector) {
            const deviceCapabilityDetector = this.year3000System.deviceCapabilityDetector;
            this.systemCache.set(key, deviceCapabilityDetector);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared DeviceCapabilityDetector instance from SystemCoordinator"
            );
            return deviceCapabilityDetector;
          }
          if (key === "EnhancedDeviceTierDetector" && this.enhancedDeviceTierDetector) {
            this.systemCache.set(key, this.enhancedDeviceTierDetector);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared EnhancedDeviceTierDetector instance from SystemCoordinator"
            );
            return this.enhancedDeviceTierDetector;
          }
          if (key === "WebGLSystemsIntegration" && this.webglSystemsIntegration) {
            this.systemCache.set(key, this.webglSystemsIntegration);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared WebGLSystemsIntegration instance from SystemCoordinator"
            );
            return this.webglSystemsIntegration;
          }
          if (key === "SimplePerformanceCoordinator" && this.simplePerformanceCoordinator) {
            this.systemCache.set(key, this.simplePerformanceCoordinator);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared SimplePerformanceCoordinator instance from SystemCoordinator"
            );
            return this.simplePerformanceCoordinator;
          }
          if (key === "PerformanceAnalyzer" && this.performanceAnalyzer) {
            this.systemCache.set(key, this.performanceAnalyzer);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared PerformanceAnalyzer instance from SystemCoordinator"
            );
            return this.performanceAnalyzer;
          }
          if ((key === "OptimizedCSSVariableManager" || key === "UnifiedCSSVariableManager") && this.cssVariableManager) {
            this.systemCache.set(key, this.cssVariableManager);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              `Using shared OptimizedCSSVariableManager instance from SystemCoordinator (requested as ${key})`
            );
            return this.cssVariableManager;
          }
          if (key === "SimplePerformanceCoordinator" && this.performanceOrchestrator) {
            this.systemCache.set(key, this.performanceOrchestrator);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared SimplePerformanceCoordinator instance from SystemCoordinator"
            );
            return this.performanceOrchestrator;
          }
          if (key === "MusicSyncService" && this.musicSyncService) {
            this.systemCache.set(key, this.musicSyncService);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared MusicSyncService instance from SystemCoordinator"
            );
            return this.musicSyncService;
          }
          if (key === "SettingsManager" && this.settingsManager) {
            this.systemCache.set(key, this.settingsManager);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared SettingsManager instance from SystemCoordinator"
            );
            return this.settingsManager;
          }
          if (key === "LoadingStateService" && this.loadingStateService) {
            this.systemCache.set(key, this.loadingStateService);
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              "Using shared LoadingStateService instance"
            );
            return this.loadingStateService;
          }
          const system = await this.createSystem(key);
          this.systemCache.set(key, system);
          this.currentMetrics.activeSystems.push(key);
          this.currentMetrics.initializedSystems++;
          if (this.onSystemCreated) {
            this.onSystemCreated(key, system);
          }
          return system;
        }
        /**
         * Create a new non-visual system instance with strategy-based dependency injection
         */
        async createSystem(key) {
          const startTime = performance.now();
          try {
            if (key === "UnifiedDebugManager") {
              const system2 = UnifiedDebugManager_default.getInstance();
              this.injectDependencies(system2, key);
              this.integratePerformanceMonitoring(system2, key);
              const endTime2 = performance.now();
              this.currentMetrics.dependencyResolutionTime += endTime2 - startTime;
              return system2;
            }
            if (key === "ColorOrchestrator") {
              const system2 = globalUnifiedColorProcessingEngine;
              this.injectDependencies(system2, key);
              this.integratePerformanceMonitoring(system2, key);
              const endTime2 = performance.now();
              this.currentMetrics.dependencyResolutionTime += endTime2 - startTime;
              return system2;
            }
            const SystemClass = this.systemRegistry.get(key);
            if (!SystemClass) {
              throw new Error(`Non-visual system '${key}' not found in registry`);
            }
            const context = {
              systemKey: key,
              config: this.config,
              utils: this.utils,
              dependencies: {
                config: this.config,
                utils: this.utils,
                performanceAnalyzer: this.performanceAnalyzer,
                settingsManager: this.settingsManager,
                musicSyncService: this.musicSyncService,
                year3000System: this.year3000System,
                cssVariableManager: this.cssVariableManager,
                performanceCoordinator: this.performanceCoordinator,
                performanceOrchestrator: this.performanceOrchestrator,
                // New simplified performance system dependencies
                enhancedDeviceTierDetector: this.enhancedDeviceTierDetector,
                webglSystemsIntegration: this.webglSystemsIntegration,
                simplePerformanceCoordinator: this.simplePerformanceCoordinator,
                // Need DeviceCapabilityDetector from SystemCoordinator for WebGL integration
                deviceCapabilityDetector: this.year3000System?.deviceCapabilityDetector || null
              },
              preferences: {
                lazyInit: false,
                validateDependencies: true,
                creationTimeout: 5e3,
                monitorCreation: true
              },
              metadata: {
                timestamp: Date.now(),
                reason: "startup",
                priority: "medium",
                resourceConstraints: {
                  maxMemoryMB: 50,
                  maxInitTimeMs: 1e3
                }
              },
              year3000System: this.year3000System
            };
            const result = await this.facadeAdapter.createSystemWithStrategy(
              key,
              SystemClass,
              context
            );
            if (!result.success) {
              Y3KDebug?.debug?.warn(
                "NonVisualSystemFacade",
                `Strategy creation failed for ${key}, falling back to legacy pattern`
              );
              const system2 = this.facadeAdapter.createSystemLegacy(
                key,
                SystemClass,
                context
              );
              this.injectDependencies(system2, key);
              this.integratePerformanceMonitoring(system2, key);
              const endTime2 = performance.now();
              this.currentMetrics.dependencyResolutionTime += endTime2 - startTime;
              return system2;
            }
            const system = result.system;
            this.injectDependencies(system, key);
            this.integratePerformanceMonitoring(system, key);
            const endTime = performance.now();
            this.currentMetrics.dependencyResolutionTime += endTime - startTime;
            Y3KDebug?.debug?.log(
              "NonVisualSystemFacade",
              `Created ${key} using strategy: ${result.strategy}`,
              {
                creationTime: result.creationTime,
                totalTime: endTime - startTime,
                injectedDependencies: result.injectedDependencies
              }
            );
            return system;
          } catch (error) {
            this.currentMetrics.failedSystems++;
            this.currentMetrics.failedSystemsList.push(key);
            this.currentMetrics.systemErrors++;
            if (this.onSystemFailed) {
              this.onSystemFailed(key, error);
            }
            Y3KDebug?.debug?.error(
              "NonVisualSystemFacade",
              `Failed to create system ${key}:`,
              error
            );
            throw error;
          }
        }
        /**
         * Inject dependencies into non-visual systems
         */
        injectDependencies(system, key) {
          if (!this.facadeConfig.enableDependencyInjection) return;
          const dependencies = this.systemDependencies.get(key) || [];
          if (dependencies.includes("performanceAnalyzer") && this.performanceAnalyzer && system.setPerformanceAnalyzer) {
            system.setPerformanceAnalyzer(this.performanceAnalyzer);
          }
          if (dependencies.includes("cssVariableManager") && this.cssVariableManager && system.setCSSVariableManager) {
            system.setCSSVariableManager(this.cssVariableManager);
          }
          if (dependencies.includes("cssConsciousnessController") && this.cssVariableManager && system.setCSSConsciousnessController) {
            system.setCSSConsciousnessController(this.cssVariableManager);
          }
          if (dependencies.includes("musicSyncService") && this.musicSyncService && system.setMusicSyncService) {
            system.setMusicSyncService(this.musicSyncService);
          }
          if (dependencies.includes("settingsManager") && this.settingsManager && system.setSettingsManager) {
            system.setSettingsManager(this.settingsManager);
          }
          if (dependencies.includes("year3000System") && system.setYear3000System) {
            system.setYear3000System(this.year3000System);
          }
          if (dependencies.includes("performanceOrchestrator") && this.performanceOrchestrator && system.setSimplePerformanceCoordinator) {
            system.setSimplePerformanceCoordinator(this.performanceOrchestrator);
          }
        }
        /**
         * Integrate performance monitoring for non-visual systems
         */
        integratePerformanceMonitoring(system, key) {
          if (!this.facadeConfig.enablePerformanceMonitoring || !this.performanceAnalyzer)
            return;
          const originalInitialize = system.initialize;
          if (typeof originalInitialize === "function") {
            system.initialize = async (...args) => {
              const startTime = performance.now();
              const result = await originalInitialize.call(system, ...args);
              const endTime = performance.now();
              this.performanceAnalyzer?.recordMetric(
                `NonVisual_${key}_Initialize`,
                endTime - startTime
              );
              return result;
            };
          }
          const originalUpdateAnimation = system.updateAnimation;
          if (typeof originalUpdateAnimation === "function") {
            system.updateAnimation = (deltaTime) => {
              const startTime = performance.now();
              originalUpdateAnimation.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer?.recordMetric(
                `NonVisual_${key}_Animation`,
                endTime - startTime
              );
            };
          }
        }
        /**
         * Initialize all cached non-visual systems
         */
        async initializeAllSystems() {
          const initPromises = Array.from(this.systemCache.entries()).map(
            async ([key, system]) => {
              try {
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                }
                Y3KDebug?.debug?.log(
                  "NonVisualSystemFacade",
                  `Initialized system: ${key}`
                );
                return { key, success: true };
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "NonVisualSystemFacade",
                  `Failed to initialize ${key}:`,
                  error
                );
                return { key, success: false, error };
              }
            }
          );
          const results = await Promise.allSettled(initPromises);
          const successCount = results.filter(
            (r) => r.status === "fulfilled" && r.value.success
          ).length;
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacade",
            `Non-visual systems initialized: ${successCount}/${results.length}`
          );
        }
        /**
         * Perform health check on all non-visual systems
         */
        async performHealthCheck() {
          const healthCheck = {
            overall: "good",
            systems: /* @__PURE__ */ new Map(),
            recommendations: [],
            timestamp: performance.now(),
            metrics: { ...this.currentMetrics }
          };
          let healthyCount = 0;
          let totalCount = 0;
          for (const [key, system] of this.systemCache) {
            totalCount++;
            try {
              const systemHealth = system.healthCheck ? await system.healthCheck() : { status: "unknown", message: "No health check available" };
              const isHealthy = systemHealth.status === "healthy" || systemHealth.status === "good";
              if (isHealthy) healthyCount++;
              healthCheck.systems.set(key, {
                ok: isHealthy,
                details: systemHealth.message || systemHealth.details || "System operational"
              });
            } catch (error) {
              healthCheck.systems.set(key, {
                ok: false,
                details: `Health check failed: ${error}`
              });
            }
          }
          const healthPercentage = totalCount > 0 ? healthyCount / totalCount : 1;
          if (healthPercentage >= 0.9) {
            healthCheck.overall = "excellent";
          } else if (healthPercentage >= 0.7) {
            healthCheck.overall = "good";
          } else if (healthPercentage >= 0.5) {
            healthCheck.overall = "degraded";
            healthCheck.recommendations.push(
              "Some non-visual systems are experiencing issues"
            );
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push(
              "Multiple non-visual system failures detected"
            );
          }
          if (this.currentMetrics.systemInitializationTime > 3e3) {
            healthCheck.recommendations.push(
              "High initialization time - consider optimizing system startup"
            );
          }
          if (this.currentMetrics.memoryUsageMB > 80) {
            healthCheck.recommendations.push(
              "High memory usage - consider optimizing system memory usage"
            );
          }
          this.lastHealthCheck = healthCheck;
          this.currentMetrics.lastHealthCheckTime = performance.now();
          if (this.onHealthChange) {
            this.onHealthChange(healthCheck);
          }
          return healthCheck;
        }
        // Utility methods
        createInitialMetrics() {
          return {
            systemCount: this.systemRegistry.size,
            initializedSystems: 0,
            failedSystems: 0,
            totalInitTime: 0,
            averageInitTime: 0,
            memoryUsageMB: 0,
            systemHealth: "good",
            activeSystems: [],
            failedSystemsList: [],
            dependencyInjection: this.facadeConfig.enableDependencyInjection,
            performanceMonitoring: this.facadeConfig.enablePerformanceMonitoring,
            healthMonitoring: this.facadeConfig.enableSystemHealthMonitoring,
            systemInitializationTime: 0,
            dependencyResolutionTime: 0,
            lastHealthCheckTime: 0,
            systemErrors: 0
          };
        }
        async applyConfiguration() {
          switch (this.facadeConfig.mode) {
            case "performance-first":
              this.facadeConfig.systemPreferences.lazyInitialization = true;
              this.facadeConfig.systemPreferences.aggressiveCaching = true;
              break;
            case "quality-first":
              this.facadeConfig.systemPreferences.lazyInitialization = false;
              this.facadeConfig.systemPreferences.performanceOptimization = true;
              break;
            case "battery-optimized":
              this.facadeConfig.performanceThresholds.maxCPUPercent = 5;
              this.facadeConfig.systemPreferences.lazyInitialization = true;
              break;
          }
        }
        startMonitoring() {
          if (this.facadeConfig.enableSystemHealthMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performHealthCheck();
            }, 3e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 5e3);
          }
        }
        updateMetrics() {
          this.currentMetrics.systemCount = this.systemRegistry.size;
          this.currentMetrics.initializedSystems = this.systemCache.size;
          this.currentMetrics.averageInitTime = this.currentMetrics.totalInitTime / Math.max(1, this.currentMetrics.initializedSystems);
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.memoryUsageMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          const failureRate = this.currentMetrics.failedSystems / Math.max(1, this.currentMetrics.systemCount);
          if (failureRate === 0) {
            this.currentMetrics.systemHealth = "excellent";
          } else if (failureRate < 0.1) {
            this.currentMetrics.systemHealth = "good";
          } else if (failureRate < 0.3) {
            this.currentMetrics.systemHealth = "degraded";
          } else {
            this.currentMetrics.systemHealth = "critical";
          }
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          this.cssVariableManager = null;
          this.performanceAnalyzer = null;
          this.performanceOrchestrator = null;
          this.musicSyncService = null;
          this.settingsManager = null;
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.facadeConfig };
        }
        async setConfiguration(config) {
          this.facadeConfig = { ...this.facadeConfig, ...config };
          await this.applyConfiguration();
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        setOnSystemFailed(callback) {
          this.onSystemFailed = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            systemsActive: this.systemCache.size,
            healthy: this.currentMetrics.systemHealth === "excellent" || this.currentMetrics.systemHealth === "good"
          };
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          this.systemCache.clear();
          Y3KDebug?.debug?.log(
            "NonVisualSystemFacade",
            "Non-visual systems facade destroyed"
          );
        }
      };
      __name(_NonVisualSystemFacade, "NonVisualSystemFacade");
      NonVisualSystemFacade = _NonVisualSystemFacade;
    }
  });

  // src-js/types/colorStubs.ts
  var _VisualEffectsManager, VisualEffectsManager, _StubPulsingEngine, StubPulsingEngine, _StubSymbioticCore, StubSymbioticCore;
  var init_colorStubs = __esm({
    "src-js/types/colorStubs.ts"() {
      "use strict";
      _VisualEffectsManager = class _VisualEffectsManager {
        constructor() {
          this.pulsingEngine = new StubPulsingEngine();
          this.symbioticCore = new StubSymbioticCore();
        }
        getConsciousnessState() {
          return {
            intensity: 0.5,
            colorTemperature: 6e3,
            animationScale: 1,
            dominantEmotion: "neutral",
            resonance: 0.5,
            // Legacy compatibility values
            symbioticResonance: 0.5,
            surfaceFluidityIndex: 0.5,
            animationScaleRate: 1,
            emotionalTemperature: 6e3,
            pulsingCycle: 2,
            cinematicIntensity: 0.5
          };
        }
      };
      __name(_VisualEffectsManager, "VisualEffectsManager");
      VisualEffectsManager = _VisualEffectsManager;
      _StubPulsingEngine = class _StubPulsingEngine {
        updatePulsing(intensity) {
        }
        getPulsingPhase() {
          return 0.5;
        }
        initialize() {
        }
        updatePulsingCycle(cycle) {
        }
        calculatePulsingCycle(bpm) {
          return 2;
        }
        adjustPulsingRhythm(intensity) {
        }
        synchronizeWithBeat(beatData) {
        }
      };
      __name(_StubPulsingEngine, "StubPulsingEngine");
      StubPulsingEngine = _StubPulsingEngine;
      _StubSymbioticCore = class _StubSymbioticCore {
        processAudioData(data) {
        }
        getEmotionalState() {
          return { intensity: 0.5, valence: 0.5, arousal: 0.5, energy: 0.5 };
        }
        initialize() {
        }
        updateSymbioticResonance(resonance) {
        }
        calculateResonance(musicData) {
          return 0.5;
        }
        updateSymbioticEffects(effects) {
        }
      };
      __name(_StubSymbioticCore, "StubSymbioticCore");
      StubSymbioticCore = _StubSymbioticCore;
    }
  });

  // src-js/visual/backbone/GradientConductor.ts
  var _BackendSelector, BackendSelector, _GradientConductor, GradientConductor;
  var init_GradientConductor = __esm({
    "src-js/visual/backbone/GradientConductor.ts"() {
      "use strict";
      init_UnifiedEventBus();
      _BackendSelector = class _BackendSelector {
        static selectOptimalBackend(registrations) {
          const sorted = registrations.filter((reg) => reg.backend.isReady && reg.backend.capabilities).sort((a, b) => b.priority - a.priority);
          for (const registration of sorted) {
            const caps = registration.capabilities;
            if (caps.webgl2 && caps.maxTextureSize >= 2048) {
              return registration.backend;
            }
            if (caps.webgl && caps.maxTextureSize >= 1024) {
              return registration.backend;
            }
            if (registration.backend.backendId === "css") {
              return registration.backend;
            }
          }
          return null;
        }
      };
      __name(_BackendSelector, "BackendSelector");
      BackendSelector = _BackendSelector;
      _GradientConductor = class _GradientConductor {
        // Removed: Dimensional Pulsing State (pulsing animations completely removed)
        constructor(eventBus, cssController, colorHarmonyEngine, musicSyncService, performanceAnalyzer2, config = {}) {
          this.initialized = false;
          this.registeredBackends = /* @__PURE__ */ new Map();
          this.activeBackend = null;
          this.rootElement = null;
          this.currentPalette = [];
          this.currentMusicMetrics = null;
          // Performance monitoring
          this.lastFrameTime = 0;
          this.frameCount = 0;
          this.performanceCheckInterval = null;
          this.eventBus = eventBus || unifiedEventBus;
          this.cssController = cssController;
          this.colorHarmonyEngine = colorHarmonyEngine;
          this.musicSyncService = musicSyncService;
          this.performanceAnalyzer = performanceAnalyzer2;
          this.config = {
            enabledBackends: ["webgl", "css"],
            defaultQuality: "high",
            transitionDuration: 500,
            performanceMonitoring: true,
            autoQualityScaling: true,
            ...config
          };
          this.currentConstraints = {
            targetFPS: 60,
            maxMemoryMB: 50,
            cpuBudgetPercent: 10,
            gpuBudgetPercent: 25,
            qualityLevel: this.config.defaultQuality
          };
        }
        /**
         * Initialize the GradientConductor and set up event listeners
         */
        async initialize() {
          try {
            this.setupEventListeners();
            this.setupCSSVariableUpdates();
            if (this.config.performanceMonitoring) {
              this.startPerformanceMonitoring();
            }
            this.updateGlobalStatus();
            this.initialized = true;
            console.log("[GradientConductor] Initialized successfully", {
              enabledBackends: this.config.enabledBackends,
              registeredBackends: Array.from(this.registeredBackends.keys())
            });
          } catch (error) {
            console.error("[GradientConductor] Initialization failed:", error);
            throw error;
          }
        }
        /**
         * Register a visual backend with the conductor
         */
        registerBackend(backend, priority = 0) {
          const registration = {
            backend,
            priority,
            capabilities: backend.capabilities,
            lastHealthCheck: /* @__PURE__ */ new Date(),
            isActive: false
          };
          this.registeredBackends.set(backend.backendId, registration);
          console.log(
            `[GradientConductor] Registered backend: ${backend.backendId}`,
            {
              priority,
              capabilities: backend.capabilities
            }
          );
          this.evaluateActiveBackend();
        }
        /**
         * Unregister a visual backend
         */
        unregisterBackend(backendId) {
          const registration = this.registeredBackends.get(backendId);
          if (registration) {
            registration.backend.setEnabled(false);
            this.registeredBackends.delete(backendId);
            if (this.activeBackend?.backendId === backendId) {
              this.activeBackend = null;
              this.evaluateActiveBackend();
            }
            console.log(`[GradientConductor] Unregistered backend: ${backendId}`);
          }
        }
        /**
         * Initialize all backends with the root element
         */
        async initializeBackends(rootElement) {
          this.rootElement = rootElement;
          const initPromises = Array.from(this.registeredBackends.values()).map(
            async (registration) => {
              try {
                await registration.backend.init(rootElement, this.currentConstraints);
                console.log(
                  `[GradientConductor] Backend ${registration.backend.backendId} initialized`
                );
              } catch (error) {
                console.error(
                  `[GradientConductor] Failed to initialize backend ${registration.backend.backendId}:`,
                  error
                );
              }
            }
          );
          await Promise.allSettled(initPromises);
          this.evaluateActiveBackend();
          if (this.activeBackend) {
            if (this.currentPalette.length > 0) {
              this.activeBackend.setPalette(this.currentPalette);
            }
            if (this.currentMusicMetrics) {
              this.activeBackend.setMusicMetrics(this.currentMusicMetrics);
            }
          }
        }
        /**
         * Update the color palette across all systems
         */
        setPalette(stops, transition = this.config.transitionDuration) {
          this.currentPalette = [...stops];
          this.updateCSSGradientVariables(stops);
          if (this.activeBackend) {
            this.activeBackend.setPalette(stops, transition);
          }
          this.updateGlobalStatus();
          console.log("[GradientConductor] Palette updated", {
            stops: stops.length,
            activeBackend: this.activeBackend?.backendId,
            transition
          });
        }
        /**
         * Update music synchronization metrics
         */
        setMusicMetrics(metrics) {
          this.currentMusicMetrics = metrics;
          this.updateCSSMusicVariables(metrics);
          if (this.activeBackend) {
            this.activeBackend.setMusicMetrics(metrics);
          }
          this.eventBus.emit("music:energy", {
            energy: metrics.energy,
            valence: metrics.valence,
            tempo: metrics.bpm,
            timestamp: Date.now()
          });
        }
        /**
         * Update performance constraints and trigger quality scaling
         */
        setPerformanceConstraints(constraints) {
          this.currentConstraints = { ...constraints };
          for (const registration of this.registeredBackends.values()) {
            registration.backend.setPerformanceConstraints(constraints);
          }
          if (constraints.qualityLevel !== this.currentConstraints.qualityLevel) {
            this.evaluateActiveBackend();
          }
          console.log(
            "[GradientConductor] Performance constraints updated",
            constraints
          );
        }
        /**
         * Get the currently active backend
         */
        getActiveBackend() {
          return this.activeBackend;
        }
        /**
         * Trigger music emotion analysis through ColorHarmonyEngine
         * This completes the Music → Emotion → Color → Visual flow
         */
        async triggerMusicEmotionAnalysis(audioFeatures, audioData) {
          try {
            if (this.colorHarmonyEngine && typeof this.colorHarmonyEngine.analyzeMusicEmotion === "function") {
              const emotion = await this.colorHarmonyEngine.analyzeMusicEmotion(audioFeatures, audioData);
              if (emotion && this.config.performanceMonitoring) {
                console.log(`[GradientConductor] Music emotion analysis triggered: ${emotion.primary} (${emotion.intensity.toFixed(2)} intensity)`);
              }
            } else {
              console.warn("[GradientConductor] ColorHarmonyEngine not available for music emotion analysis");
            }
          } catch (error) {
            console.error("[GradientConductor] Error triggering music emotion analysis:", error);
          }
        }
        /**
         * Get all registered backends
         */
        getRegisteredBackends() {
          return Array.from(this.registeredBackends.values());
        }
        /**
         * Force a specific backend to be active (for testing/debugging)
         */
        setActiveBackend(backendId) {
          const registration = this.registeredBackends.get(backendId);
          if (!registration || !registration.backend.isReady) {
            return false;
          }
          if (this.activeBackend) {
            this.activeBackend.setEnabled(false);
            const currentReg = this.registeredBackends.get(
              this.activeBackend.backendId
            );
            if (currentReg) currentReg.isActive = false;
          }
          this.activeBackend = registration.backend;
          registration.isActive = true;
          registration.backend.setEnabled(true, this.config.transitionDuration);
          this.updateGlobalStatus();
          console.log(`[GradientConductor] Forced backend switch to: ${backendId}`);
          return true;
        }
        /**
         * Perform health checks on all backends
         */
        async healthCheck() {
          const issues = [];
          for (const [backendId, registration] of this.registeredBackends) {
            try {
              const result = await registration.backend.healthCheck();
              registration.lastHealthCheck = /* @__PURE__ */ new Date();
              if (!result.ok) {
                issues.push(
                  `Backend ${backendId}: ${result.details || "Health check failed"}`
                );
              }
            } catch (error) {
              issues.push(`Backend ${backendId}: Health check error - ${error}`);
            }
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: issues.length > 0 ? `${issues.length} backend issues detected` : "All backends healthy",
            issues,
            system: "GradientConductor"
          };
        }
        /**
         * Animation update tick for performance monitoring
         */
        updateAnimation(deltaTime) {
          this.frameCount++;
          this.lastFrameTime = deltaTime;
          if (this.activeBackend) {
            this.activeBackend.updateAnimation(deltaTime);
          }
        }
        // Removed: updateDimensionalPulsing method (pulsing animations completely removed)
        // Removed: applyDimensionalPulsingToCSS method (pulsing animations completely removed)
        // Removed: onBeatDetected method (pulsing animations completely removed)
        // Removed: onEnergyChanged method (pulsing animations completely removed)
        /**
         * Clean up resources and event listeners
         */
        destroy() {
          if (this.performanceCheckInterval) {
            clearInterval(this.performanceCheckInterval);
            this.performanceCheckInterval = null;
          }
          for (const registration of this.registeredBackends.values()) {
            registration.backend.destroy();
          }
          this.registeredBackends.clear();
          this.activeBackend = null;
          this.initialized = false;
          console.log("[GradientConductor] Destroyed");
        }
        // ========================================================================
        // PRIVATE METHODS
        // ========================================================================
        setupEventListeners() {
          this.eventBus.subscribe("colors:harmonized", (data) => {
            if (data && data.processedColors) {
              const stops = Object.entries(data.processedColors).map(([key, value], index, arr) => {
                const color3 = value;
                let r = 128, g = 128, b = 128;
                if (color3.startsWith("#")) {
                  const hex = color3.slice(1);
                  r = parseInt(hex.slice(0, 2), 16);
                  g = parseInt(hex.slice(2, 4), 16);
                  b = parseInt(hex.slice(4, 6), 16);
                }
                return {
                  r,
                  g,
                  b,
                  position: index / (arr.length - 1)
                };
              });
              this.setPalette(stops);
            }
          }, "GradientConductor");
          this.eventBus.subscribe("music:energy", (data) => {
            const metrics = {
              energy: data.energy,
              valence: data.valence,
              bpm: data.tempo,
              beatIntensity: data.energy,
              rhythmPhase: 0,
              pulsingScale: 1 + data.energy * 0.2
            };
            this.setMusicMetrics(metrics);
          }, "GradientConductor");
          this.eventBus.subscribe("music:beat", (data) => {
            const metrics = {
              energy: data.intensity,
              valence: 0.5,
              bpm: data.bpm,
              beatIntensity: data.intensity,
              rhythmPhase: Date.now() / 16.67 % 360,
              // Rough phase calculation
              pulsingScale: 1 + data.intensity * 0.1
            };
            this.setMusicMetrics(metrics);
          }, "GradientConductor");
          this.eventBus.subscribe("performance:tier-changed", (data) => {
            const constraints = {
              targetFPS: 60,
              maxMemoryMB: 50,
              cpuBudgetPercent: 10,
              gpuBudgetPercent: 25,
              qualityLevel: data.tier === "excellent" ? "ultra" : data.tier === "good" ? "high" : data.tier === "degraded" ? "medium" : "low"
            };
            this.setPerformanceConstraints(constraints);
          }, "GradientConductor");
          this.eventBus.subscribe("settings:changed", (data) => {
            if (data.settingKey.includes("accessibility") || data.settingKey.includes("motion")) {
              const preferences = {
                reducedMotion: data.settingKey.includes("motion") && data.newValue === "reduce",
                highContrast: data.settingKey.includes("contrast") && data.newValue === "high",
                prefersTransparency: data.settingKey.includes("transparency") && data.newValue === "reduce"
              };
              for (const registration of this.registeredBackends.values()) {
                registration.backend.applyAccessibilityPreferences?.(preferences);
              }
            }
          }, "GradientConductor");
          this.eventBus.subscribe("music:emotion-analyzed", (emotionData) => {
            this.handleEmotionUpdate(emotionData);
          }, "GradientConductor");
          this.eventBus.subscribe("music:emotional-context-updated", (context) => {
            this.handleEmotionalColorContext(context);
          }, "GradientConductor");
        }
        setupCSSVariableUpdates() {
          const criticalVariables = [
            "--sn.music.beat.pulse.intensity",
            "--sn.music.rhythm.phase",
            "--sn.music.pulsing.scale",
            "--sn.bg.webgl.ready",
            "--sn.bg.active-backend",
            // Year 3000 visual variables (emotion-aware)
            "--sn-emotion-primary",
            "--sn-emotion-intensity",
            "--sn-color-temperature",
            "--sn-visual-effects-level",
            "--sn-smooth-flow",
            "--sn-cinematic-depth"
          ];
          criticalVariables.forEach((variable) => {
            this.cssController.addCriticalVariable(variable);
          });
        }
        /**
         * Handle emotion analysis updates from ColorHarmonyEngine
         * Part of the Year 3000 visual-aware flow
         */
        handleEmotionUpdate(emotionData) {
          try {
            const { emotion, colorTemperature, visualLevel, smoothFlow, cinematicDepth } = emotionData;
            this.cssController.setProperty(
              "--sn-emotion-primary",
              emotion.primary || "neutral"
            );
            this.cssController.setProperty(
              "--sn-emotion-intensity",
              (emotion.intensity || 0.5).toString()
            );
            this.cssController.setProperty(
              "--sn-emotion-confidence",
              (emotion.confidence || 0.5).toString()
            );
            this.cssController.setProperty(
              "--sn-color-temperature",
              (colorTemperature || 6500).toString()
            );
            this.cssController.setProperty(
              "--sn-visual-effects-level",
              (visualLevel || 0.5).toString()
            );
            this.cssController.setProperty(
              "--sn-smooth-flow",
              (smoothFlow || 0.5).toString()
            );
            this.cssController.setProperty(
              "--sn-cinematic-depth",
              (cinematicDepth || 0.5).toString()
            );
            for (const registration of this.registeredBackends.values()) {
              if (registration.backend.setEmotionalState) {
                registration.backend.setEmotionalState(emotion);
              }
            }
            console.log(`[GradientConductor] Emotion updated: ${emotion.primary} (intensity: ${emotion.intensity?.toFixed(2) || "N/A"})`);
          } catch (error) {
            console.error("[GradientConductor] Error handling emotion update:", error);
          }
        }
        /**
         * Handle emotional color context updates
         * Triggers visual-aware color processing across all backends
         */
        handleEmotionalColorContext(context) {
          try {
            const {
              primaryEmotion,
              emotionIntensity,
              colorTemperature,
              valence,
              arousal,
              dominance,
              smoothFlow,
              cinematicDepth,
              visualResonance
            } = context;
            this.cssController.setProperty(
              "--sn-emotion-valence",
              (valence || 0.5).toString()
            );
            this.cssController.setProperty(
              "--sn-emotion-arousal",
              (arousal || 0.5).toString()
            );
            this.cssController.setProperty(
              "--sn-emotion-dominance",
              (dominance || 0.5).toString()
            );
            this.cssController.setProperty(
              "--sn-visual-resonance",
              (visualResonance || 0.5).toString()
            );
            for (const registration of this.registeredBackends.values()) {
              if (registration.backend.setEmotionalContext) {
                registration.backend.setEmotionalContext(context);
              }
            }
            console.log(`[GradientConductor] Emotional context updated: ${primaryEmotion} (temp: ${colorTemperature}K)`);
          } catch (error) {
            console.error("[GradientConductor] Error handling emotional color context:", error);
          }
        }
        updateCSSGradientVariables(stops) {
          if (stops.length === 0) return;
          const primary = stops[0];
          const secondary = stops[Math.floor(stops.length / 2)];
          const accent = stops[stops.length - 1];
          this.cssController.setProperty(
            "--sn.bg.gradient.primary.rgb",
            `${primary.r}, ${primary.g}, ${primary.b}`
          );
          this.cssController.setProperty(
            "--sn.bg.gradient.secondary.rgb",
            `${secondary.r}, ${secondary.g}, ${secondary.b}`
          );
          this.cssController.setProperty(
            "--sn.bg.gradient.accent.rgb",
            `${accent.r}, ${accent.g}, ${accent.b}`
          );
          this.cssController.setProperty(
            "--sn.color.accent.rgb",
            `${accent.r}, ${accent.g}, ${accent.b}`
          );
          this.cssController.setProperty(
            "--sn.color.accent.hex",
            `#${Math.round(accent.r).toString(16).padStart(2, "0")}${Math.round(
              accent.g
            ).toString(16).padStart(2, "0")}${Math.round(accent.b).toString(16).padStart(2, "0")}`
          );
        }
        updateCSSMusicVariables(metrics) {
          if (metrics.beatIntensity !== void 0) {
            this.cssController.setProperty(
              "--sn.music.beat.pulse.intensity",
              metrics.beatIntensity.toString()
            );
          }
          if (metrics.rhythmPhase !== void 0) {
            this.cssController.setProperty(
              "--sn.music.rhythm.phase",
              `${metrics.rhythmPhase}deg`
            );
          }
          if (metrics.pulsingScale !== void 0) {
            this.cssController.setProperty(
              "--sn.music.pulsing.scale",
              metrics.pulsingScale.toString()
            );
          }
          this.cssController.setProperty(
            "--sn.music.energy.level",
            metrics.energy.toString()
          );
          this.cssController.setProperty(
            "--sn.music.valence",
            metrics.valence.toString()
          );
          this.cssController.setProperty(
            "--sn.music.tempo.bpm",
            metrics.bpm.toString()
          );
        }
        updateGlobalStatus() {
          this.cssController.setProperty(
            "--sn.bg.webgl.ready",
            this.registeredBackends.has("webgl") ? "1" : "0"
          );
          this.cssController.setProperty(
            "--sn.bg.active-backend",
            this.activeBackend?.backendId || "none"
          );
          if (typeof window !== "undefined") {
            window.snActiveBackend = this.activeBackend?.backendId || "none";
          }
        }
        evaluateActiveBackend() {
          const optimal = BackendSelector.selectOptimalBackend(
            Array.from(this.registeredBackends.values())
          );
          if (optimal && optimal !== this.activeBackend) {
            if (this.activeBackend) {
              this.activeBackend.setEnabled(false, this.config.transitionDuration);
              const currentReg = this.registeredBackends.get(
                this.activeBackend.backendId
              );
              if (currentReg) currentReg.isActive = false;
            }
            this.activeBackend = optimal;
            const newReg = this.registeredBackends.get(optimal.backendId);
            if (newReg) {
              newReg.isActive = true;
              optimal.setEnabled(true, this.config.transitionDuration);
            }
            this.updateGlobalStatus();
            console.log(
              `[GradientConductor] Switched to backend: ${optimal.backendId}`
            );
            this.eventBus.emit("system:initialized", {
              systemName: `GradientConductor-${optimal.backendId}`,
              timestamp: Date.now(),
              metadata: {
                previousBackend: this.activeBackend?.backendId || "none",
                newBackend: optimal.backendId,
                capabilities: optimal.capabilities.webgl ? "webgl" : "css"
              }
            });
          }
        }
        startPerformanceMonitoring() {
          this.performanceCheckInterval = window.setInterval(() => {
            if (!this.activeBackend) return;
            try {
              const metrics = this.activeBackend.getPerformanceMetrics();
              if (this.config.autoQualityScaling) {
                this.evaluateQualityScaling(metrics);
              }
              this.performanceAnalyzer.recordMetric(
                "gradientConductor.fps",
                metrics.fps
              );
              this.performanceAnalyzer.recordMetric(
                "gradientConductor.memory",
                metrics.memoryUsageMB
              );
            } catch (error) {
              console.warn(
                "[GradientConductor] Performance monitoring error:",
                error
              );
            }
          }, 2e3);
        }
        evaluateQualityScaling(metrics) {
          const constraints = this.currentConstraints;
          if (metrics.fps < constraints.targetFPS * 0.8 || metrics.memoryUsageMB > constraints.maxMemoryMB * 1.2) {
            let newQuality = constraints.qualityLevel;
            switch (constraints.qualityLevel) {
              case "ultra":
                newQuality = "high";
                break;
              case "high":
                newQuality = "medium";
                break;
              case "medium":
                newQuality = "low";
                break;
              case "low":
                this.evaluateActiveBackend();
                return;
            }
            console.log(
              `[GradientConductor] Auto-scaling quality: ${constraints.qualityLevel} \u2192 ${newQuality}`
            );
            this.setPerformanceConstraints({
              ...constraints,
              qualityLevel: newQuality
            });
          }
        }
      };
      __name(_GradientConductor, "GradientConductor");
      GradientConductor = _GradientConductor;
    }
  });

  // src-js/visual/music/MusicSyncVisualEffects.ts
  var _MusicBeatSynchronizer, MusicBeatSynchronizer;
  var init_MusicSyncVisualEffects = __esm({
    "src-js/visual/music/MusicSyncVisualEffects.ts"() {
      "use strict";
      init_UnifiedSystemBase();
      init_ThemeUtilities();
      _MusicBeatSynchronizer = class _MusicBeatSynchronizer extends UnifiedSystemBase {
        constructor(config) {
          super(config);
          // =========================================================================
          // MUSIC SYNCHRONIZATION STATE MANAGEMENT
          // =========================================================================
          // Current synchronization state (real-time values)
          this.musicIntensity = 0;
          // 0-1 current music intensity
          this.scaleMultiplier = 1;
          // Visual scale factor (1.0 = baseline)
          this.animationPhase = 0;
          // Animation phase in radians (0-2π)
          this.colorTemperature = 4e3;
          // Color temperature 1000K-20000K
          this.transitionFluidityLevel = 0.5;
          // Transition smoothness 0-1
          // Target values for smooth LERP interpolation (destination states)
          this.targetMusicIntensity = 0;
          // Target intensity for smooth transitions
          this.targetScaleMultiplier = 1;
          // Target scale for visual effects
          this.targetColorTemperature = 4e3;
          // Target temperature for color shifts
          this.targetTransitionFluidityLevel = 0.5;
          // Target fluidity level
          // LERP smoothing configuration (framerate-independent timing)
          this.lerpHalfLifeValues = {
            intensityAttack: 0.05,
            // Fast attack for immediate beat response (50ms)
            intensityDecay: 0.15,
            // Smooth decay for natural feel (150ms)
            scaleMultiplier: 0.08,
            // Visual scaling response timing (80ms)
            colorTemperature: 0.3,
            // Gradual temperature shifts (300ms)
            transitionFluidity: 0.12
            // Fluid transition timing (120ms)
          };
          // Timing and rhythm tracking
          this.lastBeatTime = 0;
          // Timestamp of last detected beat
          this.currentBPM = 120;
          // Current beats per minute (60-200 range)
          this.animationCycleDuration = 2e3;
          // Animation cycle length in milliseconds
          // Music synchronization service integration
          // External service integration for music analysis
          this.musicSyncService = null;
          // Spicetify audio analysis service
          this.currentMusicalContext = null;
          // Current musical analysis context
          this.lastBeatPhaseUpdate = 0;
          // Last context update timestamp
          // Real-time performance monitoring
          this.performanceMetrics = {
            syncUpdates: 0,
            // Total synchronization updates processed
            scaleEvents: 0,
            // Number of visual scaling events
            animationCycles: 0,
            // Completed animation cycles
            emotionalShifts: 0,
            // Color temperature changes
            averageFrameTime: 0,
            // Rolling average frame processing time (ms)
            memoryUsage: 0
            // Current memory usage (bytes)
          };
          // System configuration for music synchronization
          this.syncConfig = {
            responseSensitivity: 0.7,
            // Beat detection sensitivity (0-1)
            animationIntensity: 0.8,
            // Maximum animation effect strength
            colorTemperatureRange: { min: 1e3, max: 2e4 },
            // Valid temperature range in Kelvin
            transitionFluidityEnabled: true,
            // Enable smooth transitions
            visualParticlesEnabled: true,
            // Enable particle effects
            cinematicEffectsEnabled: true
            // Enable cinematic visual effects
          };
          if (this.config.enableDebug) {
            console.log("[MusicBeatSynchronizer] \u{1F3B5} Music beat synchronizer initializing...");
          }
        }
        /**
         * Inject MusicSyncService for real-time audio analysis integration
         * 
         * @param musicSyncService - Spicetify-based music analysis service
         * @public External dependency injection for music data
         */
        setMusicSyncService(musicSyncService) {
          this.musicSyncService = musicSyncService;
          if (this.config.enableDebug) {
            console.log("[MusicBeatSynchronizer] \u{1F3B5} Music synchronization service activated");
          }
        }
        // =========================================================================
        // SYSTEM LIFECYCLE MANAGEMENT (IManagedSystem Interface)
        // =========================================================================
        /**
         * Handle detected music beat events from audio analysis
         * 
         * @param payload - Beat detection data from MusicSyncService
         * @param payload.intensity - Beat intensity level (0-1)
         * @param payload.bpm - Beats per minute (60-200 typical range)
         * @param payload.energy - Music energy level (0-1)
         * @param payload.timestamp - Beat detection timestamp
         * @private Core music synchronization event handler
         */
        onBeatDetected(payload) {
          const { intensity, bpm, energy, timestamp } = payload;
          this.lastBeatTime = timestamp || Date.now();
          this.currentBPM = bpm || this.currentBPM;
          this.targetMusicIntensity = Math.min(1, intensity * this.syncConfig.responseSensitivity);
          this.targetScaleMultiplier = 1 + (energy || 0.5) * 0.3;
          this.performanceMetrics.scaleEvents++;
          if (this.config.enableDebug) {
            console.log(`[MusicBeatSynchronizer] \u{1F3B5} Beat detected: intensity=${intensity}, energy=${energy}, bpm=${bpm}`);
          }
        }
        /**
         * Handle music energy level changes from audio analysis
         * 
         * @param payload - Energy analysis data
         * @param payload.energy - Music energy level (0-1, low to high intensity)
         * @param payload.valence - Musical valence (0-1, negative to positive emotion)
         * @private Updates visual scaling and transition fluidity based on energy
         */
        onEnergyChanged(payload) {
          const { energy, valence } = payload;
          this.targetScaleMultiplier = 1 + energy * 0.3;
          this.targetTransitionFluidityLevel = 0.3 + valence * 0.4;
          if (this.config.enableDebug) {
            console.log(`[MusicBeatSynchronizer] \u26A1 Energy change: energy=${energy}, valence=${valence}`);
          }
        }
        /**
         * Handle detected music emotion changes for color temperature mapping
         * 
         * @param payload - Emotional analysis data
         * @param payload.valence - Emotional valence (-1 to 1, negative to positive)
         * @param payload.energy - Music energy level (0-1, calm to intense)
         * @private Maps musical emotion to color temperature for visual feedback
         */
        onEmotionDetected(payload) {
          const { valence, energy } = payload;
          const baseTemp = 4e3;
          const energyModulation = (energy - 0.5) * 8e3;
          const valenceModulation = (valence - 0.5) * 6e3;
          this.targetColorTemperature = Math.max(1e3, Math.min(
            2e4,
            baseTemp + energyModulation + valenceModulation
          ));
          this.performanceMetrics.emotionalShifts++;
          if (this.config.enableDebug) {
            console.log(`[MusicBeatSynchronizer] \u{1F308} Emotion detected: ${this.colorTemperature}K temperature`);
          }
        }
        /**
         * Handle music tempo changes for animation timing synchronization
         * 
         * @param payload - Tempo analysis data
         * @param payload.bpm - Base beats per minute detection
         * @param payload.tempo - Tempo classification string
         * @param payload.enhancedBPM - Enhanced BPM with improved accuracy
         * @private Synchronizes animation cycles with musical tempo
         */
        onTempoChanged(payload) {
          const { bpm, tempo, enhancedBPM } = payload;
          this.currentBPM = enhancedBPM || bpm || tempo || 120;
          const bpmFactor = Math.max(0.3, Math.min(3, this.currentBPM / 120));
          this.animationCycleDuration = 2e3 / bpmFactor;
          if (this.config.enableDebug) {
            console.log(`[MusicBeatSynchronizer] \u{1F3B6} Tempo changed: ${this.currentBPM} BPM, ${this.animationCycleDuration.toFixed(0)}ms cycle`);
          }
        }
        /**
         * Initialize the music beat synchronizer system
         * 
         * Sets up event subscriptions, CSS variable groups, and animation coordination
         * for real-time music-visual synchronization.
         * 
         * @returns Promise<void> Resolves when initialization is complete
         * @throws Error if system fails to initialize properly
         * @public IManagedSystem lifecycle method
         */
        async initialize() {
          if (this.config.enableDebug) {
            console.log("[MusicBeatSynchronizer] \u{1F3B5} Initializing music synchronization system...");
          }
          this.registerCSSVariableGroup("music-sync-core", "critical");
          this.registerCSSVariableGroup("visual-scaling", "high");
          this.registerCSSVariableGroup("color-temperature", "normal");
          this.registerCSSVariableGroup("transition-fluidity", "normal");
          this.musicIntensity = 0;
          this.scaleMultiplier = 1;
          this.animationPhase = 0;
          this.colorTemperature = 4e3;
          this.transitionFluidityLevel = 0.5;
          this.subscribeToEvent("music:beat", (payload) => this.onBeatDetected(payload));
          this.subscribeToEvent("music:energy", (payload) => this.onEnergyChanged(payload));
          this.subscribeToEvent("music:emotion", (payload) => this.onEmotionDetected(payload));
          this.subscribeToEvent("music:bpm-change", (payload) => this.onTempoChanged(payload));
          this.registerAnimation(60);
          if (this.config.enableDebug) {
            console.log("[MusicBeatSynchronizer] \u{1F31F} Music synchronization system ready");
          }
        }
        /**
         * Clean up and shut down the music beat synchronizer system
         * 
         * Resets all synchronization state to baseline values and performs cleanup.
         * Called during system shutdown or when switching themes.
         * 
         * @public IManagedSystem lifecycle method
         */
        destroy() {
          if (this.config.enableDebug) {
            console.log("[MusicBeatSynchronizer] \u{1F343} Shutting down music synchronizer...");
          }
          this.musicIntensity = 0;
          this.scaleMultiplier = 1;
          this.animationPhase = 0;
          this.colorTemperature = 4e3;
          this.transitionFluidityLevel = 0.5;
          if (this.config.enableDebug) {
            console.log("[MusicBeatSynchronizer] \u{1F30C} Music synchronizer cleanly shut down");
          }
        }
        /**
         * Process music synchronization for current animation frame
         * 
         * Called by the master animation coordinator at 60fps. Updates all music-synchronized
         * visual properties using LERP interpolation for smooth transitions.
         * 
         * @param deltaTime - Time elapsed since last frame in milliseconds
         * @public IManagedSystem animation interface
         */
        onAnimate(deltaTime) {
          const startTime = performance.now();
          this.updateMusicalContext();
          this.updateMusicSyncState(deltaTime);
          this.processVisualScaling(deltaTime);
          this.updateColorTemperature(deltaTime);
          this.animateTransitionFluidity(deltaTime);
          this.applyMusicSyncCSSVariables();
          const frameTime = performance.now() - startTime;
          this.performanceMetrics.averageFrameTime = this.performanceMetrics.averageFrameTime * 0.9 + frameTime * 0.1;
          this.performanceMetrics.syncUpdates++;
          if (frameTime > 2 && this.config.enableDebug) {
            console.warn(`[MusicBeatSynchronizer] \u{1F40C} Music sync frame took ${frameTime.toFixed(2)}ms (target: <2ms)`);
          }
        }
        /**
         * Perform system health check for music synchronization
         * 
         * Validates EventBus connectivity, performance metrics, synchronization activity,
         * and color temperature ranges for system health monitoring.
         * 
         * @returns Promise<HealthCheckResult> System health status and diagnostic details
         * @public IManagedSystem monitoring interface
         */
        async healthCheck() {
          const issues = [];
          if (!this.eventBus) {
            issues.push("EventBus not connected for music coordination");
          }
          if (this.performanceMetrics.averageFrameTime > 2) {
            issues.push(`Average frame time ${this.performanceMetrics.averageFrameTime.toFixed(2)}ms exceeds 2ms target`);
          }
          if (this.musicIntensity === 0 && Date.now() - this.lastBeatTime > 1e4) {
            issues.push("No music synchronization activity detected in last 10 seconds");
          }
          if (this.colorTemperature < 1e3 || this.colorTemperature > 2e4) {
            issues.push(`Color temperature ${this.colorTemperature}K outside 1000K-20000K range`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Music synchronization health: ${issues.length === 0 ? "optimal" : "needs attention"}`,
            issues,
            system: "MusicBeatSynchronizer"
          };
        }
        // =========================================================================
        // MUSIC SYNCHRONIZATION BEHAVIORS (LEGACY METHODS - TO BE REMOVED)
        // =========================================================================
        // NOTE: These methods are now handled by the main event handlers above
        // They remain for compatibility but should be phased out
        // =========================================================================
        // REMOVED: BREATHING INTEGRATION METHODS
        // =========================================================================
        // =========================================================================
        // ANIMATION UPDATE METHODS
        // =========================================================================
        /**
         * Update music synchronization state using framerate-independent LERP smoothing
         */
        updateMusicSyncState(deltaTime) {
          this.animationPhase += deltaTime / this.animationCycleDuration * 2 * Math.PI;
          if (this.animationPhase > 2 * Math.PI) {
            this.animationPhase -= 2 * Math.PI;
          }
          const deltaTimeSeconds = deltaTime / 1e3;
          const halfLife = this.targetMusicIntensity > this.musicIntensity ? this.lerpHalfLifeValues.intensityAttack : this.lerpHalfLifeValues.intensityDecay;
          this.musicIntensity = lerpSmooth(
            this.musicIntensity,
            this.targetMusicIntensity,
            deltaTimeSeconds,
            halfLife
          );
          const timeSinceLastBeat = Date.now() - this.lastBeatTime;
          if (timeSinceLastBeat > 2e3) {
            this.targetMusicIntensity = lerpSmooth(
              this.targetMusicIntensity,
              0,
              // Decay to zero
              deltaTimeSeconds,
              this.lerpHalfLifeValues.intensityDecay
            );
          }
        }
        /**
         * Process visual scaling using framerate-independent LERP smoothing
         */
        processVisualScaling(deltaTime) {
          const deltaTimeSeconds = deltaTime / 1e3;
          this.scaleMultiplier = lerpSmooth(
            this.scaleMultiplier,
            this.targetScaleMultiplier,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.scaleMultiplier
          );
          this.targetScaleMultiplier = lerpSmooth(
            this.targetScaleMultiplier,
            1,
            // Baseline scale
            deltaTimeSeconds,
            this.lerpHalfLifeValues.scaleMultiplier * 2
            // Slower decay
          );
        }
        /**
         * Update color temperature using framerate-independent LERP smoothing
         */
        updateColorTemperature(deltaTime) {
          const deltaTimeSeconds = deltaTime / 1e3;
          this.colorTemperature = lerpSmooth(
            this.colorTemperature,
            this.targetColorTemperature,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.colorTemperature
          );
          const neutral = 4e3;
          this.targetColorTemperature = lerpSmooth(
            this.targetColorTemperature,
            neutral,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.colorTemperature * 3
            // Slower neutral decay
          );
        }
        /**
         * Animate transition fluidity using framerate-independent LERP smoothing
         */
        animateTransitionFluidity(deltaTime) {
          if (!this.syncConfig.transitionFluidityEnabled) return;
          const deltaTimeSeconds = deltaTime / 1e3;
          this.transitionFluidityLevel = lerpSmooth(
            this.transitionFluidityLevel,
            this.targetTransitionFluidityLevel,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.transitionFluidity
          );
        }
        /**
         * Apply music sync CSS variables
         */
        applyMusicSyncCSSVariables() {
          this.updateCSSVariableGroup("music-sync-core", {
            "--sn-music-intensity": this.musicIntensity.toFixed(3),
            "--sn-music-bpm": this.currentBPM.toString(),
            "--sn-music-animation-phase": this.animationPhase.toFixed(4)
          });
          this.updateCSSVariableGroup("visual-scaling", {
            "--sn-visual-scale": this.scaleMultiplier.toFixed(3),
            "--sn-visual-response-sensitivity": this.syncConfig.responseSensitivity.toFixed(2)
          });
          this.updateCSSVariableGroup("color-temperature", {
            "--sn-color-temperature": `${this.colorTemperature.toFixed(0)}K`,
            "--sn-color-temperature-normalized": ((this.colorTemperature - 1e3) / 19e3).toFixed(3)
          });
          this.updateCSSVariableGroup("transition-fluidity", {
            "--sn-transition-fluidity": this.transitionFluidityLevel.toFixed(3),
            "--sn-transition-fluidity-enabled": this.syncConfig.transitionFluidityEnabled ? "1" : "0"
          });
        }
        // =========================================================================
        // CLEANUP METHODS
        // =========================================================================
        // =========================================================================
        // PUBLIC API METHODS
        // =========================================================================
        /**
         * Get music synchronization metrics
         */
        getMusicSyncMetrics() {
          return { ...this.performanceMetrics };
        }
        /**
         * Update music synchronization configuration
         */
        updateSyncConfig(config) {
          this.syncConfig = { ...this.syncConfig, ...config };
          if (this.config.enableDebug) {
            console.log("[MusicBeatSynchronizer] \u{1F527} Sync configuration updated:", this.syncConfig);
          }
        }
        /**
         * Get current music synchronization state
         */
        getMusicSyncState() {
          return {
            musicIntensity: this.musicIntensity,
            scaleMultiplier: this.scaleMultiplier,
            animationPhase: this.animationPhase,
            colorTemperature: this.colorTemperature,
            transitionFluidityLevel: this.transitionFluidityLevel,
            lastBeatTime: this.lastBeatTime,
            currentBPM: this.currentBPM
          };
        }
        /**
         * Force music synchronization repaint
         */
        forceRepaint(reason) {
          super.forceRepaint(reason);
          this.musicIntensity = 0;
          this.scaleMultiplier = 1;
          this.animationPhase = 0;
          this.applyMusicSyncCSSVariables();
          if (this.config.enableDebug) {
            console.log(`[MusicBeatSynchronizer] \u{1F504} Music synchronization repaint: ${reason}`);
          }
        }
        // =========================================================================
        // MUSICAL CONTEXT INTEGRATION
        // =========================================================================
        /**
         * Update musical context for music-aware LERP calculations
         */
        updateMusicalContext() {
          if (!this.musicSyncService) {
            this.currentMusicalContext = null;
            return;
          }
          const now = Date.now();
          if (now - this.lastBeatPhaseUpdate < 16) {
            return;
          }
          this.lastBeatPhaseUpdate = now;
          const musicState = this.musicSyncService.getCurrentMusicState();
          const processedData = this.musicSyncService.getLatestProcessedData();
          this.currentMusicalContext = {
            tempo: musicState?.beat?.tempo || processedData?.enhancedBPM || 120,
            energy: musicState?.beat?.energy || processedData?.energy || 0.5,
            valence: processedData?.valence || 0.5,
            danceability: processedData?.danceability || 0.5,
            emotionalTemperature: processedData?.adaptedColorTemp || 4e3,
            beatPhase: "sustain",
            // Default beat phase
            beatConfidence: 0.5,
            // Default confidence
            beatInterval: musicState?.beat?.tempo ? 6e4 / musicState.beat.tempo : 500,
            timeSinceLastBeat: now - this.lastBeatTime,
            // Missing ConsolidatedMusicalContext properties - add with defaults
            energyLevel: musicState?.beat?.energy || processedData?.energy || 0.5,
            harmonicContent: processedData?.harmonicContent || 0.5,
            rhythmicStability: processedData?.rhythmicStability || 0.8,
            harmonicComplexity: processedData?.harmonicComplexity || 0.5,
            rhythmicDensity: processedData?.rhythmicDensity || 0.5,
            spectralCentroid: processedData?.spectralCentroid || 2e3,
            bpm: musicState?.beat?.tempo || processedData?.enhancedBPM || 120,
            beat: Math.floor(now / (musicState?.beat?.tempo ? 6e4 / musicState.beat.tempo : 500))
          };
          if (this.config.enableDebug && this.currentMusicalContext) {
            const ctx = this.currentMusicalContext;
            console.log(`[MusicBeatSynchronizer] \u{1F3B5} Musical context: tempo=${ctx.tempo}, energy=${ctx.energy.toFixed(2)}, phase=${ctx.beatPhase}`);
          }
        }
      };
      __name(_MusicBeatSynchronizer, "MusicBeatSynchronizer");
      MusicBeatSynchronizer = _MusicBeatSynchronizer;
    }
  });

  // src-js/visual/music/ui/HolographicUISystem.ts
  var _HolographicUISystem, HolographicUISystem;
  var init_HolographicUISystem = __esm({
    "src-js/visual/music/ui/HolographicUISystem.ts"() {
      "use strict";
      init_MusicSyncService();
      init_UnifiedEventBus();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_OptimizedCSSVariableManager();
      init_GenreProfileManager();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      _HolographicUISystem = class _HolographicUISystem {
        constructor(manager, settingsManager2, musicSyncService) {
          this.holographicElements = /* @__PURE__ */ new Map();
          this.interfaceContainer = null;
          // Removed scanlineOverlay, chromaticCanvas and dataStreamCanvas - converted to CSS-only implementations
          this.isInitialized = false;
          this.isEnabled = true;
          // Performance metrics
          this.performanceMetrics = {
            elementsProcessed: 0,
            effectsApplied: 0,
            averageProcessingTime: 0,
            memoryUsage: 0,
            lastUpdate: 0
          };
          // Animation state
          this.animationState = {
            lastFrameTime: 0,
            flickerPhase: 0,
            scanlinePhase: 0,
            chromaticPhase: 0,
            dataStreamPhase: 0,
            interferencePhase: 0,
            dynamicPhase: 0,
            isAnimating: false
          };
          // Holographic presets
          this.holographicPresets = {
            "star-wars": {
              flickerIntensity: 0.4,
              transparency: 0.8,
              chromatic: 0.3,
              scanlineIntensity: 0.6,
              dataStreamFlow: 0.5,
              interferenceLevel: 0.2,
              energyStability: 0.7,
              projectionDistance: 0.8
            },
            "blade-runner": {
              flickerIntensity: 0.6,
              transparency: 0.7,
              chromatic: 0.5,
              scanlineIntensity: 0.8,
              dataStreamFlow: 0.8,
              interferenceLevel: 0.4,
              energyStability: 0.6,
              projectionDistance: 0.6
            },
            "dynamic-visualEffects": {
              flickerIntensity: 0.3,
              transparency: 0.9,
              chromatic: 0.2,
              scanlineIntensity: 0.4,
              dataStreamFlow: 0.6,
              interferenceLevel: 0.3,
              energyStability: 0.8,
              projectionDistance: 0.9
            }
          };
          this.lastMusicalContext = null;
          this.eventSubscriptionIds = [];
          // User interaction tracking for content-aware effects
          this.lastScrollPosition = 0;
          this.lastMouseMovement = 0;
          this.lastUIClick = 0;
          // Required by IManagedSystem
          this.initialized = false;
          // Quality scaling properties
          this.currentQualityLevel = null;
          this.qualityCapabilities = [
            {
              name: "holographic-effects",
              enabled: true,
              qualityLevel: "medium"
            },
            { name: "scanline-overlay", enabled: true, qualityLevel: "low" },
            {
              name: "chromatic-aberration",
              enabled: true,
              qualityLevel: "low"
            },
            { name: "data-streams", enabled: true, qualityLevel: "medium" },
            {
              name: "interference-patterns",
              enabled: true,
              qualityLevel: "low"
            },
            {
              name: "dynamic-integration",
              enabled: true,
              qualityLevel: "high"
            }
          ];
          this.qualityAdjustments = {};
          this.manager = manager;
          this.settingsManager = settingsManager2 || new SettingsManager();
          this.musicSyncService = musicSyncService || new MusicSyncService();
          this.oklabProcessor = new OKLABColorProcessor(true);
          this.emotionalMapper = new EmotionalTemperatureMapper(true);
          this.genreManager = new GenreProfileManager();
          this.holographicPreset = OKLABColorProcessor.getPreset("COSMIC");
          this.holographicState = {
            flickerIntensity: 0.4,
            transparency: 0.8,
            chromatic: 0.3,
            scanlineIntensity: 0.6,
            dataStreamFlow: 0.5,
            interferenceLevel: 0.2,
            energyStability: 0.7,
            projectionDistance: 0.8
          };
          this.scanlineEffect = {
            frequency: 4,
            opacity: 0.1,
            animation: true,
            speed: 0.5,
            dynamic: false
          };
          this.chromaticAberration = {
            offsetX: 2,
            offsetY: 1,
            redChannel: 0.5,
            greenChannel: 0,
            blueChannel: -0.5,
            intensity: 0.3
          };
          this.dataStream = {
            characters: [
              "0",
              "1",
              "A",
              "B",
              "C",
              "D",
              "E",
              "F",
              "G",
              "H",
              "I",
              "J",
              "K",
              "L",
              "M",
              "N",
              "O",
              "P",
              "Q",
              "R",
              "S",
              "T",
              "U",
              "V",
              "W",
              "X",
              "Y",
              "Z"
            ],
            speed: 0.5,
            density: 0.3,
            dynamic: false,
            musicSync: true,
            musicalSync: true
          };
          this.interferencePattern = {
            frequency: 0.1,
            amplitude: 0.05,
            phase: 0,
            dynamic: false,
            type: "wave"
          };
        }
        // Initialize holographic UI system
        async initialize() {
          if (this.initialized) return;
          try {
            const year3000System = globalThis.year3000System;
            this.cssController = year3000System?.cssController || getGlobalOptimizedCSSController();
            await this.createInterfaceContainer();
            await this.initializeHolographicElements();
            this.setupOKLABEventSubscriptions();
            this.setupUserInteractionTracking();
            this.initialized = true;
            this.isInitialized = true;
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Initialized holographic interface system with OKLAB integration"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to initialize:",
              error
            );
            throw error;
          }
        }
        // Update holographic effects from music
        async updateFromMusic(emotion, beat, palette) {
          if (!this.isInitialized || !this.isEnabled) return;
          const startTime = performance.now();
          try {
            this.updateHolographicState(emotion, beat);
            this.updateHolographicEffects(emotion, beat, palette);
            await this.updateElementAppearances();
            const processingTime = performance.now() - startTime;
            this.updatePerformanceMetrics(processingTime);
          } catch (error) {
            console.error("[HolographicUISystem] Error updating from music:", error);
          }
        }
        // Update holographic state from music
        updateHolographicState(emotion, beat) {
          const targetFlicker = 0.2 + emotion.intensity * 0.5 + beat.strength * 0.3;
          this.holographicState.flickerIntensity = this.smoothTransition(
            this.holographicState.flickerIntensity,
            targetFlicker,
            0.1
          );
          const targetTransparency = 0.6 + emotion.valence * 0.4;
          this.holographicState.transparency = this.smoothTransition(
            this.holographicState.transparency,
            targetTransparency,
            0.05
          );
          const targetChromatic = 0.1 + (emotion.arousal || 0.5) * 0.4;
          this.holographicState.chromatic = this.smoothTransition(
            this.holographicState.chromatic,
            targetChromatic,
            0.08
          );
          const targetScanlines = 0.3 + emotion.intensity * 0.5;
          this.holographicState.scanlineIntensity = this.smoothTransition(
            this.holographicState.scanlineIntensity,
            targetScanlines,
            0.06
          );
          const visualEffectsState = this.manager.getConsciousnessState();
          const targetDataFlow = 0.3 + visualEffectsState.symbioticResonance * 0.7;
          this.holographicState.dataStreamFlow = this.smoothTransition(
            this.holographicState.dataStreamFlow,
            targetDataFlow,
            0.04
          );
          const targetInterference = 0.1 + visualEffectsState.surfaceFluidityIndex * 0.3;
          this.holographicState.interferenceLevel = this.smoothTransition(
            this.holographicState.interferenceLevel,
            targetInterference,
            0.03
          );
          const targetStability = 1 - emotion.intensity * 0.4;
          this.holographicState.energyStability = this.smoothTransition(
            this.holographicState.energyStability,
            targetStability,
            0.02
          );
        }
        // Update holographic effects
        updateHolographicEffects(emotion, beat, palette) {
          this.scanlineEffect.frequency = 2 + this.holographicState.scanlineIntensity * 6;
          this.scanlineEffect.opacity = this.holographicState.scanlineIntensity * 0.15;
          this.scanlineEffect.speed = 0.3 + this.holographicState.dataStreamFlow * 0.7;
          this.scanlineEffect.dynamic = this.holographicState.energyStability > 0.7;
          this.chromaticAberration.intensity = this.holographicState.chromatic;
          this.chromaticAberration.offsetX = this.holographicState.chromatic * 3;
          this.chromaticAberration.offsetY = this.holographicState.chromatic * 2;
          this.dataStream.speed = 0.2 + this.holographicState.dataStreamFlow * 0.8;
          this.dataStream.density = 0.2 + this.holographicState.dataStreamFlow * 0.6;
          this.dataStream.dynamic = this.holographicState.energyStability > 0.6;
          this.interferencePattern.frequency = 0.05 + this.holographicState.interferenceLevel * 0.15;
          this.interferencePattern.amplitude = this.holographicState.interferenceLevel * 0.1;
          this.interferencePattern.dynamic = this.holographicState.energyStability > 0.5;
          if (emotion.type === "ambient") {
            this.interferencePattern.type = "dynamic";
          } else if (emotion.intensity > 0.7) {
            this.interferencePattern.type = "noise";
          } else {
            this.interferencePattern.type = "wave";
          }
        }
        // Update element appearances
        async updateElementAppearances() {
          const updatePromises = [];
          for (const [id, element] of this.holographicElements) {
            if (element.isActive) {
              updatePromises.push(this.updateElementAppearance(element));
            }
          }
          await Promise.allSettled(updatePromises);
        }
        // Update single element appearance
        async updateElementAppearance(holographicElement) {
          const {
            element,
            holographicType,
            intensity,
            visualEffectsLevel,
            smoothIntegration
          } = holographicElement;
          try {
            this.applyHolographicBase(element, intensity);
            switch (holographicType) {
              case "translucent_panel":
                this.applyTranslucentPanel(element, intensity);
                break;
              case "data_stream":
                this.applyDataStream(element, intensity);
                break;
              case "energy_barrier":
                this.applyEnergyBarrier(element, intensity);
                break;
              case "visual_effects_interface":
                this.applyVisualEffectsInterface(
                  element,
                  intensity,
                  visualEffectsLevel
                );
                break;
              case "dynamic_hologram":
                this.applyDynamicHologram(element, intensity, smoothIntegration);
                break;
              case "musical_visualization":
                this.applyMusicalVisualization(element, intensity);
                break;
              case "scanline_overlay":
                this.applyScanlineOverlay(element, intensity);
                break;
              case "chromatic_ghost":
                this.applyChromaticGhost(element, intensity);
                break;
            }
            if (visualEffectsLevel > 0.5) {
              this.applyVisualEffectsModifiers(element, visualEffectsLevel);
            }
            if (smoothIntegration) {
              this.applyDynamicModifiers(element, intensity);
            }
            holographicElement.lastUpdate = performance.now();
          } catch (error) {
            console.warn(
              `[HolographicUISystem] Failed to update element ${holographicElement.id}:`,
              error
            );
          }
        }
        // Apply holographic base effects
        applyHolographicBase(element, intensity) {
          const transparency = this.holographicState.transparency * intensity;
          const flicker = this.holographicState.flickerIntensity * intensity;
          const chromatic = this.holographicState.chromatic * intensity;
          let finalOpacity = transparency;
          if (flicker > 0.3) {
            const flickerAmount = Math.sin(this.animationState.flickerPhase * 10) * flicker * 0.3;
            finalOpacity = Math.max(0.1, transparency + flickerAmount);
          }
          const chromaticOffset = chromatic > 0.2 ? chromatic * 2 : 0;
          const chromaticRedOpacity = chromatic > 0.2 ? 0.5 : 0;
          const chromaticCyanOpacity = chromatic > 0.2 ? 0.5 : 0;
          const glowIntensity = intensity * 0.3;
          const glowSpread = glowIntensity * 20;
          const glowOpacity = glowIntensity;
          const insetGlowSpread = glowIntensity * 10;
          const insetGlowOpacity = glowIntensity * 0.5;
          this.cssController.queueCSSVariableUpdate("--holo-base-opacity", finalOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-chromatic-offset", `${chromaticOffset}px`);
          this.cssController.queueCSSVariableUpdate("--holo-chromatic-red-opacity", chromaticRedOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-chromatic-cyan-opacity", chromaticCyanOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-glow-spread", `${glowSpread}px`);
          this.cssController.queueCSSVariableUpdate("--holo-glow-opacity", glowOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-inset-glow-spread", `${insetGlowSpread}px`);
          this.cssController.queueCSSVariableUpdate("--holo-inset-glow-opacity", insetGlowOpacity.toString());
        }
        // Apply translucent panel effect
        applyTranslucentPanel(element, intensity) {
          const transparency = this.holographicState.transparency * intensity;
          const bgPrimaryOpacity = transparency * 0.1;
          const bgAccentOpacity = transparency * 0.05;
          const borderOpacity = transparency * 0.6;
          const blurAmount = Math.min(intensity * 2, 3);
          this.cssController.queueCSSVariableUpdate("--holo-panel-bg-primary-opacity", bgPrimaryOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-panel-bg-accent-opacity", bgAccentOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-panel-border-opacity", borderOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-panel-blur", `${blurAmount}px`);
        }
        // Apply data stream effect
        applyDataStream(element, intensity) {
          const streamSpeed = this.dataStream.speed * intensity;
          const streamDensity = this.dataStream.density * intensity;
          const animationDuration = 2 / streamSpeed;
          this.cssController.queueCSSVariableUpdate("--holo-stream-speed", streamSpeed.toString());
          this.cssController.queueCSSVariableUpdate("--holo-stream-density", streamDensity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-stream-duration", `${animationDuration}s`);
          if (!document.getElementById("dataStreamAnimation")) {
            const style = document.createElement("style");
            style.id = "dataStreamAnimation";
            style.textContent = `
        @keyframes dataStream {
          0% { background-position: 0 0; }
          100% { background-position: 0 20px; }
        }
      `;
            document.head.appendChild(style);
          }
        }
        // Apply energy barrier effect
        applyEnergyBarrier(element, intensity) {
          const energyStability = this.holographicState.energyStability;
          const interference = this.holographicState.interferenceLevel * intensity;
          const shimmerIntensity = (1 - energyStability) * intensity;
          const shimmerOpacityHigh = shimmerIntensity * 0.3;
          const shimmerOpacityLow = shimmerIntensity * 0.1;
          const animationDuration = 1 / shimmerIntensity;
          this.cssController.queueCSSVariableUpdate("--holo-energy-shimmer-high", shimmerOpacityHigh.toString());
          this.cssController.queueCSSVariableUpdate("--holo-energy-shimmer-low", shimmerOpacityLow.toString());
          this.cssController.queueCSSVariableUpdate("--holo-energy-duration", `${animationDuration}s`);
          if (!document.getElementById("energyBarrierAnimation")) {
            const style = document.createElement("style");
            style.id = "energyBarrierAnimation";
            style.textContent = `
        @keyframes energyBarrier {
          0% { background-position: 0% 0%; }
          50% { background-position: 100% 0%; }
          100% { background-position: 0% 0%; }
        }
      `;
            document.head.appendChild(style);
          }
        }
        // Apply visualEffects interface effect
        applyVisualEffectsInterface(element, intensity, visualEffectsLevel) {
          const visualEffectsState = this.manager.getConsciousnessState();
          const resonance = visualEffectsState.symbioticResonance * visualEffectsLevel;
          const glowIntensity = resonance * intensity * 0.5;
          const glowSpread = glowIntensity * 30;
          const glowOpacity = glowIntensity;
          const insetGlowSpread = glowIntensity * 15;
          const insetGlowOpacity = glowIntensity * 0.3;
          const visualEffectsTransparency = 0.7 + resonance * 0.3;
          const pulseIntensity = resonance > 0.6 ? 1 + Math.sin(this.animationState.dynamicPhase * 2) * resonance * 0.2 : 1;
          this.cssController.queueCSSVariableUpdate("--holo-consciousness-glow-spread", `${glowSpread}px`);
          this.cssController.queueCSSVariableUpdate("--holo-consciousness-glow-opacity", glowOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-consciousness-inset-spread", `${insetGlowSpread}px`);
          this.cssController.queueCSSVariableUpdate("--holo-consciousness-inset-opacity", insetGlowOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-consciousness-opacity", visualEffectsTransparency.toString());
          this.cssController.queueCSSVariableUpdate("--holo-consciousness-pulse-scale", pulseIntensity.toString());
        }
        // Apply dynamic hologram effect
        applyDynamicHologram(element, intensity, dynamicIntegration) {
          if (!dynamicIntegration) return;
          const dynamicPhase = this.animationState.dynamicPhase;
          const dynamicIntensity = this.holographicState.energyStability * intensity;
          const morphX = Math.sin(dynamicPhase * 1.5) * dynamicIntensity * 2;
          const morphY = Math.cos(dynamicPhase * 2) * dynamicIntensity * 1.5;
          const colorPhase = dynamicPhase * 0.5;
          const hueShift = Math.sin(colorPhase) * dynamicIntensity * 30;
          const pulsingPhase = dynamicPhase * 0.8;
          const pulsingScale = 1 + Math.sin(pulsingPhase) * dynamicIntensity * 0.05;
          this.cssController.queueCSSVariableUpdate("--holo-dynamic-translate-x", `${morphX}px`);
          this.cssController.queueCSSVariableUpdate("--holo-dynamic-translate-y", `${morphY}px`);
          this.cssController.queueCSSVariableUpdate("--holo-dynamic-hue-shift", hueShift.toString());
          this.cssController.queueCSSVariableUpdate("--holo-dynamic-scale", pulsingScale.toString());
        }
        // Apply musical visualization effect
        applyMusicalVisualization(element, intensity) {
          const visualEffectsState = this.manager.getConsciousnessState();
          const musicalIntensity = visualEffectsState.symbioticResonance * intensity;
          const visualPhase = this.animationState.dataStreamPhase * 3;
          const visualIntensity = musicalIntensity * 0.8;
          const barHeight = Math.sin(visualPhase) * visualIntensity * 20;
          const bgTopOpacity = visualIntensity * 0.8;
          const bgMidOpacity = visualIntensity * 0.4;
          const barPosition = 50 + barHeight;
          const pulseIntensity = 1 + Math.sin(visualPhase * 2) * musicalIntensity * 0.1;
          this.cssController.queueCSSVariableUpdate("--holo-musical-bg-top-opacity", bgTopOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-musical-bg-mid-opacity", bgMidOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-musical-bar-position", `${barPosition}%`);
          this.cssController.queueCSSVariableUpdate("--holo-musical-pulse-scale", pulseIntensity.toString());
        }
        // Apply scanline overlay effect
        applyScanlineOverlay(element, intensity) {
          const scanlineIntensity = this.holographicState.scanlineIntensity * intensity;
          const scanlineFrequency = this.scanlineEffect.frequency;
          const scanlineOpacity = scanlineIntensity * 0.1;
          this.cssController.queueCSSVariableUpdate("--holo-scanline-frequency", `${scanlineFrequency}px`);
          this.cssController.queueCSSVariableUpdate("--holo-scanline-opacity", scanlineOpacity.toString());
          if (this.scanlineEffect.animation) {
            const animationDuration = 1 / this.scanlineEffect.speed;
            this.cssController.queueCSSVariableUpdate("--holo-scanline-duration", `${animationDuration}s`);
          }
          if (!document.getElementById("scanlineAnimation")) {
            const style = document.createElement("style");
            style.id = "scanlineAnimation";
            style.textContent = `
        @keyframes scanlines {
          0% { background-position: 0 0; }
          100% { background-position: 0 ${scanlineFrequency}px; }
        }
      `;
            document.head.appendChild(style);
          }
        }
        // Apply chromatic ghost effect
        applyChromaticGhost(element, intensity) {
          const chromaticIntensity = this.holographicState.chromatic * intensity;
          const redOffset = chromaticIntensity * 3;
          const greenOffset = chromaticIntensity * 1.5;
          const blueOffset = chromaticIntensity * 2;
          const shadowOpacity = 0.4;
          const chromaticPhase = this.animationState.chromaticPhase;
          const offsetAnimation = Math.sin(chromaticPhase * 5) * chromaticIntensity;
          this.cssController.queueCSSVariableUpdate("--holo-chromatic-red-offset", `${redOffset}px`);
          this.cssController.queueCSSVariableUpdate("--holo-chromatic-green-offset", `-${greenOffset}px`);
          this.cssController.queueCSSVariableUpdate("--holo-chromatic-blue-offset-y", `${blueOffset}px`);
          this.cssController.queueCSSVariableUpdate("--holo-chromatic-shadow-opacity", shadowOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--holo-chromatic-translate", `${offsetAnimation}px`);
        }
        // Apply visualEffects modifiers
        applyVisualEffectsModifiers(element, visualEffectsLevel) {
          const visualEffectsState = this.manager.getConsciousnessState();
          const resonance = visualEffectsState.symbioticResonance * visualEffectsLevel;
          const brightness = 1 + resonance * 0.3;
          const saturation = 1 + resonance * 0.5;
          this.cssController.queueCSSVariableUpdate("--holo-consciousness-brightness", brightness.toString());
          this.cssController.queueCSSVariableUpdate("--holo-consciousness-saturation", saturation.toString());
        }
        // Apply dynamic modifiers
        applyDynamicModifiers(element, intensity) {
          const dynamicPhase = this.animationState.dynamicPhase;
          const dynamicIntensity = this.holographicState.energyStability * intensity;
          const blurPhase = dynamicPhase * 1.2;
          const dynamicBlurAmount = Math.max(0, Math.sin(blurPhase) * dynamicIntensity * 2);
          const opacityPhase = dynamicPhase * 0.7;
          const opacityModifier = 1 + Math.sin(opacityPhase) * dynamicIntensity * 0.2;
          this.cssController.queueCSSVariableUpdate("--holo-dynamic-blur", `${dynamicBlurAmount}px`);
          this.cssController.queueCSSVariableUpdate("--holo-dynamic-opacity-modifier", opacityModifier.toString());
        }
        // Generate data stream gradient
        generateDataStreamGradient(speed, density) {
          const characters = this.dataStream.characters;
          const characterCount = Math.floor(density * 20);
          let gradient = "linear-gradient(90deg, ";
          for (let i = 0; i < characterCount; i++) {
            const position = i / characterCount * 100;
            const character = characters[Math.floor(Math.random() * characters.length)];
            const opacity = 0.1 + Math.random() * 0.3;
            const streamColor = this.getOKLABEnhancedDataStreamColor(
              opacity,
              this.lastMusicalContext
            );
            gradient += `${streamColor} ${position}%, `;
          }
          gradient = gradient.slice(0, -2) + ")";
          return gradient;
        }
        // Create interface container
        async createInterfaceContainer() {
          this.interfaceContainer = document.createElement("div");
          this.interfaceContainer.id = "holographic-interface-container";
          this.interfaceContainer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
      mix-blend-mode: normal;
    `;
          document.body.appendChild(this.interfaceContainer);
        }
        // Scanline overlay removed - effects now applied directly to elements via CSS classes
        // Canvas methods removed - effects now implemented via CSS-only approach for better text clarity
        // Initialize holographic elements
        async initializeHolographicElements() {
          const elementSelectors = [
            { selector: ".main-view-container", type: "translucent_panel" },
            { selector: ".Root__nav-bar", type: "data_stream" },
            { selector: ".Root__now-playing-bar", type: "visualEffects_interface" },
            {
              selector: ".main-view-container__scroll-node",
              type: "dynamic_hologram"
            },
            { selector: ".root-now-playing-view", type: "energy_barrier" },
            {
              selector: ".main-view-container__scroll-node-child",
              type: "scanline_overlay"
            }
          ];
          for (const config of elementSelectors) {
            const elements = document.querySelectorAll(config.selector);
            for (const element of elements) {
              const holographicElement = {
                id: `holographic-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                element,
                originalStyles: getComputedStyle(element),
                holographicType: config.type,
                intensity: 0.7,
                isActive: true,
                lastUpdate: 0,
                animation: null,
                visualEffectsLevel: 0.8,
                smoothIntegration: true
              };
              this.holographicElements.set(holographicElement.id, holographicElement);
            }
          }
        }
        // Update holographic animation
        updateHolographicAnimation(deltaMs) {
          if (!this.isInitialized || !this.isEnabled) return;
          const deltaSeconds = deltaMs / 1e3;
          this.animationState.flickerPhase += deltaSeconds * 2;
          this.animationState.scanlinePhase += deltaSeconds * this.scanlineEffect.speed;
          this.animationState.chromaticPhase += deltaSeconds * 1.5;
          this.animationState.dataStreamPhase += deltaSeconds * this.dataStream.speed;
          this.animationState.interferencePhase += deltaSeconds * this.interferencePattern.frequency;
          this.animationState.dynamicPhase += deltaSeconds * 0.5;
          this.performanceMetrics.lastUpdate = performance.now();
        }
        // Scanline overlay update method removed - effects now applied via CSS classes to individual elements
        // Data stream canvas method removed - now implemented via CSS-only per-element effects
        /**
         * ✅ RAF LOOP REMOVED - Managed by EnhancedMasterAnimationCoordinator
         *
         * Previous implementation: startHolographicAnimation() with independent RAF loop
         * New implementation: updateAnimation() called by coordinator
         *
         * Benefits:
         * - Single RAF loop for all systems (not 5-8 independent loops)
         * - Shared deltaTime calculation (eliminates redundant performance.now() calls)
         * - Coordinated frame budget management
         * - Priority-based execution order
         *
         * Migration: Lines 998-1016 removed, registration added to SystemCoordinator
         * Note: updateHolographicAnimation() is now called from updateAnimation(deltaTime)
         */
        // Utility methods
        smoothTransition(current, target, speed) {
          return current + (target - current) * speed;
        }
        // Update performance metrics
        updatePerformanceMetrics(processingTime) {
          this.performanceMetrics.averageProcessingTime = this.performanceMetrics.averageProcessingTime * 0.9 + processingTime * 0.1;
          this.performanceMetrics.elementsProcessed = this.holographicElements.size;
          this.performanceMetrics.memoryUsage = this.holographicElements.size * 256;
        }
        // Public API methods
        getHolographicState() {
          return { ...this.holographicState };
        }
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        getElementCount() {
          return this.holographicElements.size;
        }
        setEnabled(enabled) {
          this.isEnabled = enabled;
          if (!enabled) {
            this.cssController.queueCSSVariableUpdate("--holo-base-opacity", "1");
            this.cssController.queueCSSVariableUpdate("--holo-chromatic-offset", "0px");
            this.cssController.queueCSSVariableUpdate("--holo-glow-spread", "0px");
            this.cssController.queueCSSVariableUpdate("--holo-dynamic-translate-x", "0px");
            this.cssController.queueCSSVariableUpdate("--holo-dynamic-translate-y", "0px");
            this.cssController.queueCSSVariableUpdate("--holo-dynamic-scale", "1");
          }
        }
        setHolographicPreset(presetName) {
          const preset = this.holographicPresets[presetName];
          if (preset) {
            this.holographicState = { ...preset };
          }
        }
        setFlickerIntensity(intensity) {
          this.holographicState.flickerIntensity = Math.max(
            0,
            Math.min(1, intensity)
          );
        }
        /**
         * Enable volumetric depth effects for 3D holographic visualEffects
         */
        enableVolumetricDepth(depthLevel = 0.8) {
          const perspectiveDepth = 800 + depthLevel * 1200;
          if (this.interfaceContainer) {
            this.interfaceContainer.style.perspective = `${perspectiveDepth}px`;
            this.interfaceContainer.style.transformStyle = "preserve-3d";
          }
          for (const [id, holographicElement] of this.holographicElements) {
            this.applyVolumetricLayers(
              holographicElement.element,
              depthLevel,
              holographicElement.intensity
            );
          }
          console.log(
            `[HolographicUISystem] \u{1F30A} Volumetric depth enabled: ${perspectiveDepth}px perspective`
          );
        }
        /**
         * Update volumetric layers for 3D visualEffects depth
         */
        updateVolumetricLayers(visualEffectsLevel, emotionalTemperature) {
          const depthIntensity = visualEffectsLevel * 0.8;
          const temperatureDepth = (emotionalTemperature - 4e3) / 4e3;
          for (const [id, holographicElement] of this.holographicElements) {
            this.applyVolumetricLayers(
              holographicElement.element,
              depthIntensity,
              holographicElement.intensity,
              temperatureDepth
            );
          }
        }
        /**
         * Apply volumetric 3D layers to holographic element
         */
        applyVolumetricLayers(element, depthLevel, intensity, temperatureDepth = 0.5) {
          const baseDepth = depthLevel * 100;
          const temperatureOffset = temperatureDepth * 50;
          const finalDepth = baseDepth + temperatureOffset;
          const shadowIntensity = Math.abs(finalDepth) / 100 * intensity;
          const shadowBlur = shadowIntensity * 30;
          const shadowOffset = finalDepth > 0 ? shadowIntensity * 5 : -shadowIntensity * 3;
          const shadowOpacity = shadowIntensity * 0.3;
          this.cssController.queueCSSVariableUpdate("--holo-volumetric-depth", `${finalDepth}px`);
          this.cssController.queueCSSVariableUpdate("--holo-volumetric-shadow-blur", `${shadowBlur}px`);
          this.cssController.queueCSSVariableUpdate("--holo-volumetric-shadow-offset", `${shadowOffset}px`);
          this.cssController.queueCSSVariableUpdate("--holo-volumetric-shadow-opacity", shadowOpacity.toString());
          this.applyVolumetricAtmosphere(element, depthLevel, intensity);
        }
        /**
         * Apply volumetric atmosphere effects for depth perception
         */
        applyVolumetricAtmosphere(element, depthLevel, intensity) {
          const atmosphereIntensity = depthLevel * intensity;
          const blurAmount = Math.max(0, (depthLevel - 0.5) * 4);
          const brightnessAdjust = 1 + (depthLevel - 0.5) * 0.3;
          const saturateAdjust = 1 + atmosphereIntensity * 0.2;
          const atmosphericOpacityModifier = Math.max(0.3, 1 - (1 - depthLevel) * 0.3);
          this.cssController.queueCSSVariableUpdate("--holo-atmosphere-blur", `${blurAmount}px`);
          this.cssController.queueCSSVariableUpdate("--holo-atmosphere-brightness", brightnessAdjust.toString());
          this.cssController.queueCSSVariableUpdate("--holo-atmosphere-saturate", saturateAdjust.toString());
          this.cssController.queueCSSVariableUpdate("--holo-atmosphere-opacity-modifier", atmosphericOpacityModifier.toString());
        }
        /**
         * Consciousness data stream functionality converted to CSS-only implementation
         * Data is now integrated into element-native effects for better text clarity
         */
        // Canvas-based visualEffects data stream methods removed - now handled via CSS-only implementations
        /**
         * Dynamic atmospheric effects system
         * Phase 4.2c: Advanced Atmospheric Enhancement - flowing, seamless, dynamic
         * Now updates CSS variables for element-native visual effects
         */
        updateConsciousnessScanlines(visualEffectsLevel, emotionalTemperature, musicalIntensity) {
          const visualEffectsDensity = Math.max(0.2, visualEffectsLevel * 1.5);
          const temperatureFrequency = this.mapTemperatureToFrequency(emotionalTemperature);
          const musicalPulse = Math.sin(performance.now() * 5e-3 * musicalIntensity) * 0.3 + 0.7;
          const visualEffectsScanlineVariables = {
            "--visualEffects-scanline-density": visualEffectsDensity.toString(),
            "--visualEffects-scanline-frequency": `${temperatureFrequency}px`,
            "--visualEffects-scanline-opacity": (visualEffectsLevel * 0.15).toString(),
            "--musical-scanline-pulse": musicalPulse.toString(),
            "--temperature-scanline-color-shift": `${(emotionalTemperature - 5e3) / 3e3 * 30}deg`
          };
          this.cssController.batchSetVariables(
            "HolographicUISystem",
            visualEffectsScanlineVariables,
            "high",
            // High priority for visualEffects scanline effects
            "visualEffects-scanline-update"
          );
        }
        /**
         * Update enhanced aberration system CSS variables based on visualEffects and musical data
         * Phase 4.2g: Enhanced CSS-Only Aberration Integration
         */
        updateAberrationEffects(visualEffectsLevel, emotionalTemperature, musicalIntensity, beatDetected = false) {
          const root = document.documentElement;
          const baseIntensity = Math.min(1, visualEffectsLevel * 1.2);
          const musicalSync = Math.min(1, musicalIntensity * 1.5);
          const colorSeparation = 2 + musicalSync * 3;
          const tempNormalized = Math.max(3e3, Math.min(8e3, emotionalTemperature));
          const tempRatio = (tempNormalized - 5500) / 2500;
          const redShift = 1.5 + tempRatio * 2;
          const blueShift = -1.5 - tempRatio * 2;
          const greenShift = tempRatio * 0.5;
          const musicalPulse = Math.sin(performance.now() * 3e-3 * musicalIntensity) * 0.4 + 0.6;
          const beatBoost = beatDetected ? 1.5 : 1;
          const waveFrequency = 1e3 + visualEffectsLevel * 2e3 + musicalIntensity * 1e3;
          const aberrationEffectVariables = {
            "--aberration-intensity": (baseIntensity * beatBoost).toString(),
            "--aberration-color-separation": `${colorSeparation}px`,
            "--aberration-musical-sync": musicalSync.toString(),
            "--aberration-emotional-temperature": `${emotionalTemperature}K`,
            "--aberration-visualEffects-level": visualEffectsLevel.toString(),
            "--aberration-red-shift": `${redShift}px`,
            "--aberration-green-shift": `${greenShift}px`,
            "--aberration-blue-shift": `${blueShift}px`,
            "--aberration-wave-frequency": `${waveFrequency}ms`,
            "--aberration-pulse-intensity": (musicalPulse * beatBoost).toString()
          };
          this.cssController.batchSetVariables(
            "HolographicUISystem",
            aberrationEffectVariables,
            "high",
            // High priority for aberration effects - affects visual perception
            "aberration-effects-update"
          );
          const readingModeActive = parseFloat(
            root.style.getPropertyValue("--reading-mode-active") || "0"
          );
          const readingModeReduction = Math.min(0.8, readingModeActive * 0.6);
          this.cssController.setVariable(
            "HolographicUISystem",
            "--aberration-reading-mode-reduction",
            readingModeReduction.toString(),
            "critical",
            // Critical priority for reading mode accessibility
            "aberration-reading-mode-update"
          );
        }
        /**
         * Map emotional temperature to scanline frequency
         */
        mapTemperatureToFrequency(temperature) {
          const normalizedTemp = Math.max(3e3, Math.min(8e3, temperature));
          const tempRatio = (normalizedTemp - 3e3) / 5e3;
          return 2 + tempRatio * 10;
        }
        // applySophisticatedScanlines method removed - converted to CSS-only implementation
        /**
         * Update CSS variables for scanline system integration
         */
        updateScanlineCSSVariables(visualEffectsLevel, emotionalTemperature, musicalIntensity) {
          const scanlineCoreVariables = {
            "--visualEffects-scanline-density": visualEffectsLevel.toString(),
            "--visualEffects-scanline-frequency": `${this.scanlineEffect.frequency}px`,
            "--visualEffects-scanline-opacity": this.scanlineEffect.opacity.toString(),
            "--visualEffects-scanline-speed": `${this.scanlineEffect.speed}s`,
            "--temperature-scanline-color-shift": `${(emotionalTemperature - 5e3) / 2e3 * 30}deg`,
            "--musical-scanline-pulse": musicalIntensity.toString()
          };
          this.cssController.batchSetVariables(
            "HolographicUISystem",
            scanlineCoreVariables,
            "high",
            // High priority for scanline visualEffects effects
            "scanline-visualEffects-update"
          );
          const advancedScanlineVariables = {
            "--visualEffects-scanline-interference": visualEffectsLevel > 0.7 ? "visible" : "none",
            "--visualEffects-scanline-complexity": visualEffectsLevel > 0.7 ? Math.min(1, (visualEffectsLevel - 0.7) * 3.33).toString() : "0"
          };
          this.cssController.batchSetVariables(
            "HolographicUISystem",
            advancedScanlineVariables,
            "high",
            // High priority for advanced visualEffects scanline effects
            "scanline-complexity-update"
          );
        }
        /**
         * Detect reading mode based on user activity and content area
         * Updates CSS variables for reading-mode-aware holographic effects
         */
        detectReadingMode() {
          const root = document.documentElement;
          const isTextSelected = (window.getSelection()?.toString() || "").length > 0;
          const isUserScrolling = this.isUserCurrentlyScrolling();
          const isHoveringTextContent = this.isHoveringTextContent();
          let readingModeActive = 0;
          if (isTextSelected) readingModeActive += 0.6;
          if (isUserScrolling) readingModeActive += 0.3;
          if (isHoveringTextContent) readingModeActive += 0.4;
          readingModeActive = Math.min(1, readingModeActive);
          this.cssController.setVariable(
            "HolographicUISystem",
            "--reading-mode-active",
            readingModeActive.toString(),
            "critical",
            // Critical priority for reading mode - affects accessibility
            "reading-mode-detection-update"
          );
        }
        /**
         * Track user interaction patterns for content-aware holographic effects
         */
        trackUserInteraction() {
          const root = document.documentElement;
          const isMouseMoving = this.isMouseCurrentlyMoving();
          const isClickingUI = this.wasRecentUIClick();
          const isFocusedOnInput = this.isFocusedOnInputElement();
          let interactionIntensity = 0;
          if (isMouseMoving) interactionIntensity += 0.4;
          if (isClickingUI) interactionIntensity += 0.5;
          if (isFocusedOnInput) interactionIntensity += 0.6;
          interactionIntensity = Math.min(1, interactionIntensity);
          this.cssController.setVariable(
            "HolographicUISystem",
            "--user-interaction-detected",
            interactionIntensity.toString(),
            "high",
            // High priority for user interaction detection - affects responsiveness
            "user-interaction-update"
          );
        }
        /**
         * Check if user is currently scrolling (used for reading mode detection)
         */
        isUserCurrentlyScrolling() {
          const scrollContainer = document.querySelector(
            ".main-view-container__scroll-node"
          );
          if (!scrollContainer) return false;
          const currentScrollTop = scrollContainer.scrollTop;
          const lastScrollTop = this.lastScrollPosition || 0;
          this.lastScrollPosition = currentScrollTop;
          return Math.abs(currentScrollTop - lastScrollTop) > 5;
        }
        /**
         * Check if user is hovering over text content
         */
        isHoveringTextContent() {
          const hoveredElement = document.querySelector(":hover");
          if (!hoveredElement) return false;
          const textContent = hoveredElement.textContent?.trim() || "";
          return textContent.length > 20;
        }
        /**
         * Check if mouse is currently moving
         */
        isMouseCurrentlyMoving() {
          const now = performance.now();
          const lastMovement = this.lastMouseMovement || 0;
          return now - lastMovement < 2e3;
        }
        /**
         * Check if there was a recent UI click
         */
        wasRecentUIClick() {
          const now = performance.now();
          const lastClick = this.lastUIClick || 0;
          return now - lastClick < 1e3;
        }
        /**
         * Check if user is focused on an input element
         */
        isFocusedOnInputElement() {
          const activeElement = document.activeElement;
          if (!activeElement) return false;
          const inputElements = ["input", "textarea", "select"];
          return inputElements.includes(activeElement.tagName.toLowerCase()) || activeElement.getAttribute("contenteditable") === "true";
        }
        setTransparency(transparency) {
          this.holographicState.transparency = Math.max(0, Math.min(1, transparency));
        }
        setChromaticAberration(chromatic) {
          this.holographicState.chromatic = Math.max(0, Math.min(1, chromatic));
        }
        // Cleanup
        destroy() {
          console.log("[HolographicUISystem] Destroying holographic UI system...");
          for (const [id, element] of this.holographicElements) {
            if (element.animation) {
              element.animation.cancel();
            }
          }
          this.cssController.queueCSSVariableUpdate("--holo-base-opacity", "1");
          this.cssController.queueCSSVariableUpdate("--holo-chromatic-offset", "0px");
          this.cssController.queueCSSVariableUpdate("--holo-glow-spread", "0px");
          this.cssController.queueCSSVariableUpdate("--holo-dynamic-translate-x", "0px");
          this.cssController.queueCSSVariableUpdate("--holo-dynamic-translate-y", "0px");
          this.cssController.queueCSSVariableUpdate("--holo-dynamic-scale", "1");
          this.holographicElements.clear();
          if (this.interfaceContainer && this.interfaceContainer.parentNode) {
            this.interfaceContainer.parentNode.removeChild(this.interfaceContainer);
          }
          const animations = [
            "dataStreamAnimation",
            "energyBarrierAnimation",
            "scanlineAnimation"
          ];
          animations.forEach((animationId) => {
            const style = document.getElementById(animationId);
            if (style) {
              style.remove();
            }
          });
          this.isInitialized = false;
          this.initialized = false;
          this.eventSubscriptionIds.forEach((id) => {
            unifiedEventBus.unsubscribe(id);
          });
          this.eventSubscriptionIds = [];
        }
        // ========================================================================
        // QUALITY SCALING INTERFACE IMPLEMENTATION
        // ========================================================================
        /**
         * Set quality level for holographic effects
         */
        setQualityLevel(level) {
          this.currentQualityLevel = level;
          switch (level) {
            case "low":
              this.holographicState.flickerIntensity = 0.2;
              this.holographicState.transparency = 0.85;
              this.holographicState.chromatic = 0.2;
              this.holographicState.scanlineIntensity = 0.3;
              this.holographicState.dataStreamFlow = 0.3;
              this.holographicState.interferenceLevel = 0.1;
              this.scanlineEffect.animation = true;
              this.scanlineEffect.speed = 0.3;
              break;
            case "medium":
              this.holographicState.flickerIntensity = 0.4;
              this.holographicState.transparency = 0.8;
              this.holographicState.chromatic = 0.3;
              this.holographicState.scanlineIntensity = 0.6;
              this.holographicState.dataStreamFlow = 0.5;
              this.holographicState.interferenceLevel = 0.2;
              this.scanlineEffect.animation = true;
              this.scanlineEffect.speed = 0.5;
              break;
            case "high":
              this.holographicState.flickerIntensity = 0.6;
              this.holographicState.transparency = 0.7;
              this.holographicState.chromatic = 0.5;
              this.holographicState.scanlineIntensity = 0.8;
              this.holographicState.dataStreamFlow = 0.8;
              this.holographicState.interferenceLevel = 0.4;
              this.scanlineEffect.animation = true;
              this.scanlineEffect.speed = 0.8;
              break;
            case "high":
              this.holographicState.flickerIntensity = 0.8;
              this.holographicState.transparency = 0.6;
              this.holographicState.chromatic = 0.7;
              this.holographicState.scanlineIntensity = 1;
              this.holographicState.dataStreamFlow = 1;
              this.holographicState.interferenceLevel = 0.6;
              this.scanlineEffect.animation = true;
              this.scanlineEffect.speed = 1;
              break;
          }
          this.updateQualityCapabilities(level);
        }
        /**
         * Get current performance impact metrics
         */
        getPerformanceImpact() {
          const activeElements = this.holographicElements.size;
          const averageProcessingTime = this.calculateProcessingTime();
          return {
            fps: 60,
            // Holographic effects typically maintain 60fps
            frameTime: averageProcessingTime,
            memoryUsage: this.estimateMemoryUsage(),
            cpuUsage: this.estimateCPUUsage(activeElements)
          };
        }
        /**
         * Reduce quality by specified amount
         */
        reduceQuality(amount) {
          this.qualityAdjustments["flicker-reduction"] = (this.qualityAdjustments["flicker-reduction"] || 0) + amount;
          this.qualityAdjustments["effect-reduction"] = (this.qualityAdjustments["effect-reduction"] || 0) + amount * 0.8;
          this.holographicState.flickerIntensity = Math.max(
            0.1,
            this.holographicState.flickerIntensity * (1 - amount * 0.8)
          );
          this.holographicState.chromatic = Math.max(
            0,
            this.holographicState.chromatic * (1 - amount)
          );
          this.holographicState.scanlineIntensity = Math.max(
            0.1,
            this.holographicState.scanlineIntensity * (1 - amount * 0.6)
          );
          this.holographicState.dataStreamFlow = Math.max(
            0.1,
            this.holographicState.dataStreamFlow * (1 - amount * 0.4)
          );
          this.holographicState.interferenceLevel = Math.max(
            0,
            this.holographicState.interferenceLevel * (1 - amount)
          );
          if (amount > 0.5) {
            this.scanlineEffect.animation = false;
          }
        }
        /**
         * Increase quality by specified amount
         */
        increaseQuality(amount) {
          Object.keys(this.qualityAdjustments).forEach((key) => {
            this.qualityAdjustments[key] = Math.max(
              0,
              (this.qualityAdjustments[key] || 0) - amount
            );
          });
          if (this.currentQualityLevel) {
            const preset = this.getPresetForLevel(this.currentQualityLevel);
            this.holographicState.flickerIntensity = Math.min(
              preset.flickerIntensity,
              this.holographicState.flickerIntensity * (1 + amount * 0.3)
            );
            this.holographicState.chromatic = Math.min(
              preset.chromatic,
              this.holographicState.chromatic * (1 + amount * 0.4)
            );
            this.holographicState.scanlineIntensity = Math.min(
              preset.scanlineIntensity,
              this.holographicState.scanlineIntensity * (1 + amount * 0.2)
            );
            this.holographicState.dataStreamFlow = Math.min(
              preset.dataStreamFlow,
              this.holographicState.dataStreamFlow * (1 + amount * 0.2)
            );
            if (amount > 0.3) {
              this.scanlineEffect.animation = true;
            }
          }
        }
        /**
         * Get quality capabilities for this system
         */
        getQualityCapabilities() {
          return [...this.qualityCapabilities];
        }
        // ========================================================================
        // QUALITY SCALING HELPER METHODS
        // ========================================================================
        updateQualityCapabilities(level) {
          this.qualityCapabilities.forEach((capability) => {
            switch (capability.name) {
              case "holographic-effects":
                capability.enabled = this.holographicState.flickerIntensity > 0.2;
                break;
              case "scanline-overlay":
                capability.enabled = this.holographicState.scanlineIntensity > 0.3;
                break;
              case "chromatic-aberration":
                capability.enabled = this.holographicState.chromatic > 0.2;
                break;
              case "data-streams":
                capability.enabled = this.holographicState.dataStreamFlow > 0.3;
                break;
              case "interference-patterns":
                capability.enabled = this.holographicState.interferenceLevel > 0.1;
                break;
              case "dynamic-integration":
                capability.enabled = level !== "low";
                break;
            }
          });
        }
        getPresetForLevel(level) {
          switch (level) {
            case "low":
              return this.holographicPresets["dynamic-visualEffects"];
            case "medium":
              return this.holographicPresets["star-wars"];
            case "high":
              return this.holographicPresets["blade-runner"];
            default:
              return this.holographicPresets["star-wars"];
          }
        }
        calculateProcessingTime() {
          const activeElements = this.holographicElements.size;
          const complexityFactor = (this.holographicState.flickerIntensity + this.holographicState.chromatic + this.holographicState.scanlineIntensity) / 3;
          return Math.max(2, activeElements * complexityFactor * 0.5);
        }
        estimateMemoryUsage() {
          const activeElements = this.holographicElements.size;
          const baseMemoryPerElement = 0.3;
          const canvasMemory = 0;
          return baseMemoryPerElement * activeElements + canvasMemory;
        }
        estimateCPUUsage(activeElements) {
          const baseUsage = 2;
          const complexityFactor = (this.holographicState.flickerIntensity + this.holographicState.chromatic + this.holographicState.scanlineIntensity) / 3;
          const animationMultiplier = this.scanlineEffect.animation ? 1.5 : 1;
          return Math.min(
            30,
            baseUsage * activeElements * complexityFactor * animationMultiplier
          );
        }
        /**
         * Convert hex color to RGB string for CSS variables
         */
        hexToRgb(hex) {
          try {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (result && result[1] && result[2] && result[3]) {
              return `${parseInt(result[1], 16)}, ${parseInt(
                result[2],
                16
              )}, ${parseInt(result[3], 16)}`;
            }
            return "100, 255, 200";
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "HolographicUISystem",
              "Failed to convert hex to RGB:",
              error
            );
            return "100, 255, 200";
          }
        }
        /**
         * Setup OKLAB event subscriptions for holographic visualEffects
         */
        setupOKLABEventSubscriptions() {
          try {
            const oklabColorId = unifiedEventBus.subscribe(
              "colors:oklab-enhanced",
              this.handleOKLABColorEvent.bind(this),
              "HolographicUISystem"
            );
            this.eventSubscriptionIds.push(oklabColorId);
            const musicalOklabId = unifiedEventBus.subscribe(
              "colors:musical-oklab-coordinated",
              this.handleMusicalOKLABEvent.bind(this),
              "HolographicUISystem"
            );
            this.eventSubscriptionIds.push(musicalOklabId);
            const emotionalTempId = unifiedEventBus.subscribe(
              "colors:emotional-temperature-mapped",
              this.handleEmotionalTemperatureEvent.bind(this),
              "HolographicUISystem"
            );
            this.eventSubscriptionIds.push(emotionalTempId);
            const genreDetectedId = unifiedEventBus.subscribe(
              "audio:genre-detected",
              this.handleGenreDetectionEvent.bind(this),
              "HolographicUISystem"
            );
            this.eventSubscriptionIds.push(genreDetectedId);
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "OKLAB event subscriptions established",
              {
                subscriptionCount: this.eventSubscriptionIds.length
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to setup OKLAB event subscriptions:",
              error
            );
          }
        }
        /**
         * Setup user interaction tracking for content-aware holographic effects
         */
        setupUserInteractionTracking() {
          try {
            document.addEventListener(
              "mousemove",
              () => {
                this.lastMouseMovement = performance.now();
              },
              { passive: true }
            );
            document.addEventListener(
              "click",
              () => {
                this.lastUIClick = performance.now();
              },
              { passive: true }
            );
            setInterval(() => {
              this.detectReadingMode();
              this.trackUserInteraction();
            }, 500);
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "User interaction tracking initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to setup user interaction tracking:",
              error
            );
          }
        }
        /**
         * Handle unified OKLAB color events
         */
        async handleOKLABColorEvent(data) {
          try {
            const { enhancedColors, oklabPreset, rawColors, trackUri } = data;
            if (oklabPreset) {
              this.holographicPreset = oklabPreset;
            }
            if (enhancedColors) {
              await this.updateHolographicColorsFromOKLAB(enhancedColors);
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Updated holographic colors from OKLAB event",
              {
                preset: oklabPreset?.name,
                trackUri,
                colorCount: Object.keys(enhancedColors || {}).length
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to handle OKLAB color event:",
              error
            );
          }
        }
        /**
         * Handle musical OKLAB coordination events
         */
        async handleMusicalOKLABEvent(data) {
          try {
            const {
              coordinatedColors,
              detectedGenre,
              emotionalResult,
              oklabPreset,
              musicInfluenceStrength,
              coordinationStrategy
            } = data;
            this.lastMusicalContext = {
              genre: detectedGenre,
              emotion: emotionalResult?.primaryEmotion,
              preset: oklabPreset,
              influence: musicInfluenceStrength,
              strategy: coordinationStrategy,
              timestamp: Date.now()
            };
            if (oklabPreset) {
              this.holographicPreset = oklabPreset;
            }
            if (coordinatedColors) {
              await this.updateHolographicColorsFromMusicalOKLAB(
                coordinatedColors,
                this.lastMusicalContext
              );
            }
            if (emotionalResult && musicInfluenceStrength !== void 0) {
              const visualEffectsLevel = this.holographicState.flickerIntensity || 0.5;
              const emotionalTemperature = emotionalResult.emotionalTemperature || 6e3;
              const musicalIntensity = musicInfluenceStrength;
              const beatDetected = emotionalResult.beatDetected || false;
              this.updateAberrationEffects(
                visualEffectsLevel,
                emotionalTemperature,
                musicalIntensity,
                beatDetected
              );
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Updated holographic effects from musical OKLAB coordination",
              {
                genre: detectedGenre,
                emotion: emotionalResult?.primaryEmotion,
                preset: oklabPreset?.name,
                influence: musicInfluenceStrength
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to handle musical OKLAB event:",
              error
            );
          }
        }
        /**
         * Handle emotional temperature mapping events
         */
        async handleEmotionalTemperatureEvent(data) {
          try {
            const {
              emotionalTemperature,
              primaryEmotion,
              perceptualColorHex,
              oklabPreset,
              cssVariables
            } = data;
            await this.updateHolographicEmotionalTemperature(
              emotionalTemperature,
              primaryEmotion
            );
            if (perceptualColorHex) {
              await this.updateHolographicColorFromEmotionalOKLAB(
                perceptualColorHex,
                emotionalTemperature
              );
            }
            const visualEffectsLevel = this.holographicState.flickerIntensity || 0.5;
            const musicalIntensity = this.lastMusicalContext?.influence || 0.5;
            this.updateAberrationEffects(
              visualEffectsLevel,
              emotionalTemperature,
              musicalIntensity,
              false
            );
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Updated holographic emotional temperature",
              {
                temperature: emotionalTemperature,
                emotion: primaryEmotion,
                color: perceptualColorHex
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to handle emotional temperature event:",
              error
            );
          }
        }
        /**
         * Handle genre detection events for preset adjustment
         */
        async handleGenreDetectionEvent(data) {
          try {
            const { detectedGenre, confidence, audioFeatures } = data;
            const genrePreset = this.genreManager.getOKLABPresetForGenre(detectedGenre);
            if (genrePreset) {
              this.holographicPreset = genrePreset;
              await this.adjustHolographicEffectsForGenre(
                detectedGenre,
                audioFeatures
              );
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Adjusted holographic effects for detected genre",
              {
                genre: detectedGenre,
                confidence,
                preset: genrePreset?.name
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to handle genre detection event:",
              error
            );
          }
        }
        /**
         * Update holographic colors from OKLAB-enhanced colors
         */
        async updateHolographicColorsFromOKLAB(enhancedColors) {
          try {
            const holographicColorVariables = {};
            Object.entries(enhancedColors).forEach(([key, hexColor]) => {
              if (hexColor && typeof hexColor === "string") {
                const oklabResult = this.oklabProcessor.processColor(
                  hexColor,
                  this.holographicPreset
                );
                if (oklabResult.enhancedHex) {
                  holographicColorVariables[`--holographic-${key.toLowerCase()}`] = oklabResult.enhancedHex;
                  holographicColorVariables[`--holographic-${key.toLowerCase()}-rgb`] = this.hexToRgb(oklabResult.enhancedHex);
                  if (oklabResult.oklabEnhanced) {
                    const { L, a, b } = oklabResult.oklabEnhanced;
                    holographicColorVariables[`--holographic-${key.toLowerCase()}-oklab`] = `${L.toFixed(3)} ${a.toFixed(3)} ${b.toFixed(3)}`;
                  }
                }
              }
            });
            if (enhancedColors["VIBRANT"] || enhancedColors["PRIMARY"]) {
              const primaryColor = enhancedColors["VIBRANT"] || enhancedColors["PRIMARY"];
              if (primaryColor) {
                const oklabResult = this.oklabProcessor.processColor(
                  primaryColor,
                  this.holographicPreset
                );
                if (oklabResult.enhancedHex) {
                  holographicColorVariables["--sn-holographic-rgb"] = this.hexToRgb(oklabResult.enhancedHex);
                  holographicColorVariables["--sn-holographic-primary"] = oklabResult.enhancedHex;
                }
              }
            }
            if (Object.keys(holographicColorVariables).length > 0) {
              this.cssController.batchSetVariables(
                "HolographicUISystem",
                holographicColorVariables,
                "critical",
                // Critical priority for holographic color updates - affects visual perception
                "oklab-holographic-colors-update"
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to update holographic colors from OKLAB:",
              error
            );
          }
        }
        /**
         * Update holographic colors from musical OKLAB coordination
         */
        async updateHolographicColorsFromMusicalOKLAB(coordinatedColors, musicalContext) {
          try {
            await this.updateHolographicColorsFromOKLAB(coordinatedColors);
            if (musicalContext.influence) {
              this.adjustHolographicIntensityFromMusicalInfluence(
                musicalContext.influence
              );
            }
            if (musicalContext.genre) {
              await this.applyGenreSpecificHolographicEffects(
                musicalContext.genre,
                musicalContext.emotion
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to update holographic colors from musical OKLAB:",
              error
            );
          }
        }
        /**
         * Update holographic color from emotional OKLAB mapping
         */
        async updateHolographicColorFromEmotionalOKLAB(perceptualColorHex, emotionalTemperature) {
          try {
            const root = document.documentElement;
            const oklabResult = this.oklabProcessor.processColor(
              perceptualColorHex,
              this.holographicPreset
            );
            if (oklabResult.enhancedHex) {
              const emotionalHolographicVariables = {
                "--holographic-emotional-primary": oklabResult.enhancedHex,
                "--holographic-emotional-rgb": this.hexToRgb(oklabResult.enhancedHex),
                "--holographic-emotional-temperature": `${emotionalTemperature}K`
              };
              this.cssController.batchSetVariables(
                "HolographicUISystem",
                emotionalHolographicVariables,
                "critical",
                // Critical priority for emotional holographic colors - affects visualEffects perception
                "emotional-oklab-holographic-update"
              );
              await this.updateHolographicEmotionalTemperature(
                emotionalTemperature,
                null
              );
            }
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to update holographic color from emotional OKLAB:",
              error
            );
          }
        }
        /**
         * Update holographic emotional temperature responsiveness
         */
        async updateHolographicEmotionalTemperature(temperature, emotion) {
          try {
            const temperatureNormalized = Math.max(3e3, Math.min(8e3, temperature));
            const tempRatio = (temperatureNormalized - 3e3) / 5e3;
            this.holographicState.flickerIntensity = 0.2 + tempRatio * 0.4;
            this.holographicState.chromatic = 0.1 + tempRatio * 0.3;
            this.holographicState.energyStability = 1 - tempRatio * 0.3;
            if (tempRatio < 0.4) {
              this.holographicState.transparency = 0.9 + tempRatio * 0.1;
              this.holographicState.dataStreamFlow = 0.3 + tempRatio * 0.2;
            } else {
              this.holographicState.transparency = 0.8 - (tempRatio - 0.4) * 0.2;
              this.holographicState.interferenceLevel = 0.1 + (tempRatio - 0.4) * 0.3;
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Updated holographic effects from emotional temperature",
              {
                temperature,
                tempRatio,
                flicker: this.holographicState.flickerIntensity,
                chromatic: this.holographicState.chromatic
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to update holographic emotional temperature:",
              error
            );
          }
        }
        /**
         * Adjust holographic effects for detected genre
         */
        async adjustHolographicEffectsForGenre(genre, audioFeatures) {
          try {
            switch (genre.toLowerCase()) {
              case "electronic":
              case "techno":
              case "edm":
                this.holographicState.dataStreamFlow = 0.8;
                this.holographicState.scanlineIntensity = 0.7;
                this.holographicState.interferenceLevel = 0.4;
                this.scanlineEffect.speed = 0.8;
                break;
              case "classical":
              case "orchestral":
                this.holographicState.transparency = 0.9;
                this.holographicState.energyStability = 0.8;
                this.holographicState.flickerIntensity = 0.2;
                this.scanlineEffect.dynamic = true;
                break;
              case "rock":
              case "metal":
                this.holographicState.flickerIntensity = 0.6;
                this.holographicState.chromatic = 0.5;
                this.holographicState.interferenceLevel = 0.5;
                this.scanlineEffect.animation = true;
                break;
              case "ambient":
              case "atmospheric":
                this.holographicState.transparency = 0.95;
                this.holographicState.dataStreamFlow = 0.3;
                this.holographicState.energyStability = 0.9;
                this.scanlineEffect.dynamic = true;
                this.scanlineEffect.speed = 0.2;
                break;
              case "jazz":
              case "blues":
                this.holographicState.flickerIntensity = 0.4;
                this.holographicState.energyStability = 0.6;
                this.interferencePattern.type = "dynamic";
                this.scanlineEffect.dynamic = true;
                break;
              default:
                this.holographicState.flickerIntensity = 0.4;
                this.holographicState.transparency = 0.8;
                this.holographicState.chromatic = 0.3;
                break;
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Adjusted holographic effects for genre",
              {
                genre,
                flicker: this.holographicState.flickerIntensity,
                transparency: this.holographicState.transparency,
                dataFlow: this.holographicState.dataStreamFlow
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to adjust holographic effects for genre:",
              error
            );
          }
        }
        /**
         * Adjust holographic intensity from musical influence strength
         */
        adjustHolographicIntensityFromMusicalInfluence(influenceStrength) {
          try {
            const influenceMultiplier = 0.5 + influenceStrength * 0.5;
            this.holographicState.flickerIntensity *= influenceMultiplier;
            this.holographicState.chromatic *= influenceMultiplier;
            this.holographicState.scanlineIntensity *= influenceMultiplier;
            this.holographicState.dataStreamFlow *= influenceMultiplier;
            this.holographicState.interferenceLevel *= influenceMultiplier;
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Adjusted holographic intensity from musical influence",
              {
                influence: influenceStrength,
                multiplier: influenceMultiplier
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to adjust holographic intensity from musical influence:",
              error
            );
          }
        }
        /**
         * Apply genre-specific holographic effects
         */
        async applyGenreSpecificHolographicEffects(genre, emotion) {
          try {
            const effectKey = `${genre.toLowerCase()}-${emotion || "neutral"}`;
            if (genre === "electronic" && emotion === "energetic") {
              this.setHolographicPreset("blade-runner");
              this.holographicState.dataStreamFlow = 1;
              this.holographicState.interferenceLevel = 0.6;
            } else if (genre === "classical" && emotion === "calm") {
              this.setHolographicPreset("dynamic-visualEffects");
              this.holographicState.transparency = 0.95;
              this.holographicState.energyStability = 0.9;
            } else if (genre === "rock" && emotion === "aggressive") {
              this.setHolographicPreset("star-wars");
              this.holographicState.flickerIntensity = 0.8;
              this.holographicState.chromatic = 0.6;
            }
            Y3KDebug?.debug?.log(
              "HolographicUISystem",
              "Applied genre-specific holographic effects",
              {
                genre,
                emotion,
                effectKey
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "HolographicUISystem",
              "Failed to apply genre-specific holographic effects:",
              error
            );
          }
        }
        /**
         * Update animation with delta time (IManagedSystem interface)
         */
        updateAnimation(deltaTime) {
          this.updateHolographicAnimation(deltaTime);
        }
        /**
         * Health check for holographic system (IManagedSystem interface)
         */
        async healthCheck() {
          try {
            const memoryUsage = this.estimateMemoryUsage();
            const cpuUsage = this.estimateCPUUsage(this.holographicElements.size);
            const activeElements = this.holographicElements.size;
            const isHealthy = this.initialized && memoryUsage < 10 && // Less than 10MB
            cpuUsage < 25 && // Less than 25% CPU
            activeElements < 100;
            return {
              healthy: isHealthy,
              message: isHealthy ? "Holographic UI system operating normally" : "Holographic UI system performance degraded",
              details: {
                initialized: this.initialized,
                activeElements,
                memoryUsageMB: memoryUsage,
                cpuUsagePercent: cpuUsage,
                oklabIntegration: this.eventSubscriptionIds.length > 0,
                lastUpdate: this.performanceMetrics.lastUpdate
              }
            };
          } catch (error) {
            return {
              healthy: false,
              message: `Holographic UI system health check failed: ${error}`,
              details: {
                error: error instanceof Error ? error.message : String(error)
              }
            };
          }
        }
        // ========================================================================
        // OKLAB COLOR HELPER METHODS
        // ========================================================================
        /**
         * Get OKLAB-enhanced glow color for holographic effects
         */
        getOKLABEnhancedGlowColor(intensity) {
          try {
            const currentColor = getComputedStyle(document.documentElement).getPropertyValue("--sn-holographic-primary")?.trim() || "#64ffcc";
            const oklabResult = this.oklabProcessor.processColor(
              currentColor,
              this.holographicPreset
            );
            if (oklabResult.enhancedHex) {
              const rgb = this.hexToRgb(oklabResult.enhancedHex);
              return `rgba(${rgb}, ${intensity})`;
            }
            return `rgba(var(--spice-rgb-holographic-glow, var(--sn-holographic-rgb, 100, 255, 200)), ${intensity})`;
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "HolographicUISystem",
              "Failed to get OKLAB enhanced glow color:",
              error
            );
            return `rgba(var(--spice-rgb-holographic-glow, var(--sn-holographic-rgb, 100, 255, 200)), ${intensity})`;
          }
        }
        /**
         * Get OKLAB-enhanced panel colors for translucent effects
         */
        getOKLABEnhancedPanelColor(transparency) {
          try {
            const currentColor = getComputedStyle(document.documentElement).getPropertyValue("--sn-holographic-primary")?.trim() || "#64ffcc";
            const oklabResult = this.oklabProcessor.processColor(
              currentColor,
              this.holographicPreset
            );
            if (oklabResult.enhancedHex) {
              const rgb = this.hexToRgb(oklabResult.enhancedHex);
              return {
                background: `rgba(${rgb}, ${transparency * 0.1})`,
                gradient: `rgba(${rgb}, ${transparency * 0.05})`,
                border: `rgba(${rgb}, ${transparency * 0.6})`
              };
            }
            return {
              background: `rgba(var(--spice-rgb-holographic-primary, var(--sn-holographic-rgb, 100, 255, 200)), ${transparency * 0.1})`,
              gradient: `rgba(var(--spice-rgb-holographic-accent, var(--sn-holographic-rgb, 100, 255, 200)), ${transparency * 0.05})`,
              border: `rgba(var(--spice-rgb-holographic-glow, var(--sn-holographic-rgb, 100, 255, 200)), ${transparency * 0.6})`
            };
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "HolographicUISystem",
              "Failed to get OKLAB enhanced panel color:",
              error
            );
            return {
              background: `rgba(var(--spice-rgb-holographic-primary, var(--sn-holographic-rgb, 100, 255, 200)), ${transparency * 0.1})`,
              gradient: `rgba(var(--spice-rgb-holographic-accent, var(--sn-holographic-rgb, 100, 255, 200)), ${transparency * 0.05})`,
              border: `rgba(var(--spice-rgb-holographic-glow, var(--sn-holographic-rgb, 100, 255, 200)), ${transparency * 0.6})`
            };
          }
        }
        /**
         * Get OKLAB visualEffects-responsive glow colors
         */
        getOKLABConsciousnessGlow(intensity, resonance) {
          try {
            const accentColor = getComputedStyle(document.documentElement).getPropertyValue("--sn-accent-hex")?.trim() || "#cba6f7";
            const visualEffectsPreset = {
              ...this.holographicPreset,
              chromaBoost: this.holographicPreset.chromaBoost * (1 + resonance * 0.5),
              lightnessBoost: this.holographicPreset.lightnessBoost * (1 + resonance * 0.3)
            };
            const oklabResult = this.oklabProcessor.processColor(
              accentColor,
              visualEffectsPreset
            );
            if (oklabResult.enhancedHex) {
              const rgb = this.hexToRgb(oklabResult.enhancedHex);
              return {
                outer: `rgba(${rgb}, ${intensity})`,
                inner: `rgba(${rgb}, ${intensity * 0.3})`
              };
            }
            return {
              outer: `rgba(var(--sn-accent-rgb, 203, 166, 247), ${intensity})`,
              inner: `rgba(var(--sn-accent-rgb, 203, 166, 247), ${intensity * 0.3})`
            };
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "HolographicUISystem",
              "Failed to get OKLAB visualEffects glow:",
              error
            );
            return {
              outer: `rgba(var(--sn-accent-rgb, 203, 166, 247), ${intensity})`,
              inner: `rgba(var(--sn-accent-rgb, 203, 166, 247), ${intensity * 0.3})`
            };
          }
        }
        /**
         * Get OKLAB-enhanced color for data streams with musical responsiveness
         */
        getOKLABEnhancedDataStreamColor(intensity, musicalContext) {
          try {
            let baseColor = "#64ffcc";
            if (musicalContext?.emotion) {
              const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature({
                energy: 0.5,
                valence: 0.5,
                tempo: 120,
                genre: musicalContext.genre || "default"
              });
              if (emotionalResult.perceptualColorHex) {
                baseColor = emotionalResult.perceptualColorHex;
              }
            }
            const oklabResult = this.oklabProcessor.processColor(
              baseColor,
              this.holographicPreset
            );
            if (oklabResult.enhancedHex) {
              const rgb = this.hexToRgb(oklabResult.enhancedHex);
              return `rgba(${rgb}, ${intensity})`;
            }
            return `rgba(var(--spice-rgb-holographic-primary, var(--sn-holographic-rgb, 100, 255, 200)), ${intensity})`;
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "HolographicUISystem",
              "Failed to get OKLAB enhanced data stream color:",
              error
            );
            return `rgba(var(--spice-rgb-holographic-primary, var(--sn-holographic-rgb, 100, 255, 200)), ${intensity})`;
          }
        }
        /**
         * Adjust quality level for performance optimization (QualityScalingCapable interface)
         */
        adjustQuality(level) {
          switch (level) {
            case "low":
              this.holographicState.energyStability = 0.3;
              this.holographicState.scanlineIntensity = 0.2;
              this.holographicState.interferenceLevel = 0.1;
              break;
            case "medium":
              this.holographicState.energyStability = 0.6;
              this.holographicState.scanlineIntensity = 0.5;
              this.holographicState.interferenceLevel = 0.3;
              break;
            case "high":
            default:
              this.holographicState.energyStability = 1;
              this.holographicState.scanlineIntensity = 0.8;
              this.holographicState.interferenceLevel = 0.6;
              break;
          }
        }
      };
      __name(_HolographicUISystem, "HolographicUISystem");
      HolographicUISystem = _HolographicUISystem;
    }
  });

  // src-js/visual/ui/InteractionTrackingSystem.ts
  var _InteractionTrackingSystem, InteractionTrackingSystem;
  var init_InteractionTrackingSystem = __esm({
    "src-js/visual/ui/InteractionTrackingSystem.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_BaseVisualSystem();
      init_OptimizedCSSVariableManager();
      _InteractionTrackingSystem = class _InteractionTrackingSystem extends BaseVisualSystem {
        constructor(config, utils, performanceMonitor, musicSyncService, settingsManager2, year3000System = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this._scrollContainerElements = [];
          // Stored throttled interaction handler for proper cleanup.
          this._interactionHandler = null;
          this.year3000System = year3000System;
          this.nexusState = {
            currentNavigationScale: 1,
            targetNavigationScale: 1,
            userInfluence: 0,
            lastEnergy: 0.5,
            lastValence: 0.5,
            lastVisualIntensity: 0.5,
            lastMoodIdentifier: "neutral"
          };
          this.biometricState = {
            isMeditating: false,
            lastUserInteractionTime: Date.now(),
            meditationGracePeriod: 5e3,
            interactionCooldown: 1e3,
            lastMeditationUpdateTime: null,
            desaturation: 0,
            slowdown: 1,
            targetDesaturation: 0,
            targetSlowdown: 1
          };
          this.lastHeavyUpdateTime = 0;
          this.heavyUpdateInterval = 1e3 / 10;
          this.lastBiometricCheckTime = 0;
          this.biometricCheckInterval = 1e3;
          this.lastInteractionRecordTime = 0;
          this.interactionRecordInterval = 200;
          this._animationRegistered = false;
          this._performanceMode = "auto";
          this._frameSkipCounter = 0;
          this._maxFrameSkip = 2;
          this.systemIntegrationMetrics = {
            lastSystemsCheck: Date.now(),
            integrationHealth: "healthy",
            crossSystemErrors: 0,
            meditationTransitions: 0,
            navigationScaleUpdates: 0
          };
          const healthMonitor = this.utils.getHealthMonitor();
          if (healthMonitor) {
            healthMonitor.registerSystem("InteractionTrackingSystem", this);
          }
          this.rootElement = this.utils.getRootStyle();
          this.modalObserver = null;
          this._lastScrollTime = null;
          this._lastScrollTop = null;
        }
        /**
         * Frame callback invoked by the MasterAnimationCoordinator.
         * Delegates to the existing `updateAnimation` implementation which
         * contains the system's main per-frame logic (including internal
         * frame-skipping and heavy-update cadence).
         *
         * @param deltaMs  Milliseconds elapsed since the previous animation frame.
         */
        onAnimate(deltaMs) {
          if (!this.initialized) return;
          this.updateAnimation(deltaMs);
        }
        async initialize() {
          await super.initialize();
          const year3000System = globalThis.year3000System;
          this.cssController = year3000System?.cssController || getGlobalOptimizedCSSController();
          this.initializeOptimizedQuantumSpace();
          this.setupModalObserver();
          this.setupOptimizedInteractionListener();
          this._registerWithAnimationCoordinator();
        }
        _registerWithAnimationCoordinator() {
          if (this.year3000System && this.year3000System.registerAnimationSystem) {
            this.year3000System.registerAnimationSystem(
              "InteractionTrackingSystem",
              this,
              "normal",
              30
            );
            this._animationRegistered = true;
          } else {
            this._startFallbackAnimationLoops();
          }
        }
        initializeOptimizedQuantumSpace() {
          const root = this.utils.getRootStyle();
          if (!root) return;
          const initialInteractionVariables = {
            "--sn-nav-item-transform-scale": "1.0",
            "--sn-sidebar-meditation-desaturation": "0",
            "--sn-sidebar-meditation-slowdown": "1"
          };
          this.cssController.batchSetVariables(
            "InteractionTrackingSystem",
            initialInteractionVariables,
            "high",
            // High priority for interaction tracking initialization
            "quantum-space-initialization"
          );
        }
        recordUserInteraction(event) {
          const eventType = event.type;
          if (eventType === "scroll") {
            const target = event.target;
            if (target) {
              const newTop = target.scrollTop;
              const now2 = performance.now();
              const velocity = this._lastScrollTime ? (newTop - (this._lastScrollTop ?? 0)) / (now2 - this._lastScrollTime) : 0;
              const direction = velocity < 0 ? "up" : "down";
              unifiedEventBus.emit("user:scroll", {
                velocity: { x: 0, y: velocity * 1e3 },
                // pixels per second, normalized to x/y format
                direction,
                element: target.tagName || "unknown",
                timestamp: now2
              });
              this._lastScrollTop = newTop;
              this._lastScrollTime = now2;
            }
          }
          const now = performance.now();
          if (now - this.lastInteractionRecordTime < this.interactionRecordInterval) {
            return;
          }
          this.lastInteractionRecordTime = now;
          this.nexusState.userInfluence += 5e-3;
          this.nexusState.userInfluence = Math.min(0.5, this.nexusState.userInfluence);
          this.biometricState.lastUserInteractionTime = Date.now();
          this.biometricState.isMeditating = false;
        }
        setupModalObserver() {
          const modalRoot = document.querySelector(".main-modal-container");
          if (!modalRoot) return;
          const observerCallback = /* @__PURE__ */ __name((mutationsList, observer) => {
            for (const mutation of mutationsList) {
              if (mutation.type === "childList") {
                const hasModal = modalRoot.children.length > 0;
                this.nexusState.targetNavigationScale = hasModal ? 0.95 : 1;
              }
            }
          }, "observerCallback");
          this.modalObserver = new MutationObserver(observerCallback);
          this.modalObserver.observe(modalRoot, { childList: true });
        }
        setupOptimizedInteractionListener() {
          this._interactionHandler = this.utils.throttle(
            (event) => this.recordUserInteraction(event),
            100
          );
          const genericEvents = ["click", "mousemove", "keydown"];
          genericEvents.forEach((eventType) => {
            document.addEventListener(
              eventType,
              this._interactionHandler,
              { passive: true }
            );
          });
          const scrollSelectors = [
            ".main-view-container__scroll-node",
            ".main-view-container__scroll-node-child",
            "section[data-testid='playlist-page']"
          ];
          const foundContainers = [];
          scrollSelectors.forEach((sel) => {
            document.querySelectorAll(sel).forEach((el) => {
              foundContainers.push(el);
            });
          });
          const targets = foundContainers.length ? foundContainers : [document];
          targets.forEach((el) => {
            el.addEventListener("scroll", this._interactionHandler, {
              passive: true
            });
          });
          this._scrollContainerElements = foundContainers;
        }
        updateFromMusicAnalysis(processedMusicData, rawFeatures, trackUri) {
          if (!this.initialized || !this.validateMusicData(processedMusicData)) {
            this.applySafeDefaults();
            return;
          }
          this.updateNexusTargets(processedMusicData);
        }
        updateNexusTargets(processedMusicData) {
          const {
            energy,
            valence,
            visualIntensity,
            moodIdentifier
          } = processedMusicData;
          this.nexusState.lastEnergy = energy;
          this.nexusState.lastValence = valence;
          this.nexusState.lastVisualIntensity = visualIntensity;
          this.nexusState.lastMoodIdentifier = moodIdentifier;
          this.nexusState.targetNavigationScale = this.calculateOptimizedNavigationScale(visualIntensity, moodIdentifier);
        }
        updateDigitalMeditationState(processedMusicData) {
          const now = Date.now();
          if (now - this.lastBiometricCheckTime < this.biometricCheckInterval) {
            return;
          }
          this.lastBiometricCheckTime = now;
          const timeSinceLastInteraction = now - this.biometricState.lastUserInteractionTime;
          if (timeSinceLastInteraction > this.biometricState.meditationGracePeriod && processedMusicData.energy < 0.3 && processedMusicData.valence > 0.6) {
            this.biometricState.isMeditating = true;
            this.biometricState.targetDesaturation = 0.6;
            this.biometricState.targetSlowdown = 0.5;
          } else {
            this.biometricState.isMeditating = false;
            this.biometricState.targetDesaturation = 0;
            this.biometricState.targetSlowdown = 1;
          }
        }
        updateAnimation(deltaTime) {
          if (!this.initialized) return;
          const timestamp = performance.now();
          this._frameSkipCounter++;
          if (this._frameSkipCounter < this._maxFrameSkip) {
            return;
          }
          this._frameSkipCounter = 0;
          this.animateOptimizedNexusFrame(deltaTime);
          if (timestamp - this.lastHeavyUpdateTime > this.heavyUpdateInterval) {
            const latestMusicData = this.musicSyncService?.getLatestProcessedData();
            if (latestMusicData) this.updateDigitalMeditationState(latestMusicData);
            this.updateIntegrationMetrics();
            this.lastHeavyUpdateTime = timestamp;
          }
        }
        onPerformanceModeChange(mode) {
          this._performanceMode = mode;
          if (mode === "performance") {
            this.heavyUpdateInterval = 1e3 / 5;
            this._maxFrameSkip = 3;
            this.interactionRecordInterval = 500;
          } else {
            this.heavyUpdateInterval = 1e3 / 10;
            this._maxFrameSkip = 2;
            this.interactionRecordInterval = 200;
          }
        }
        // ✅ RAF LOOP CONSOLIDATION: Fallback loop removed
        // Animation coordinator registration is now guaranteed via VisualSystemCoordinator
        _startFallbackAnimationLoops() {
          this._animationRegistered = true;
        }
        animateOptimizedNexusFrame(deltaTimeMs) {
          const lerpFactor = Math.min((deltaTimeMs ?? 16.67) / 1e3 * 5, 1);
          this.nexusState.currentNavigationScale = this.utils.lerp(
            this.nexusState.currentNavigationScale,
            this.nexusState.targetNavigationScale,
            lerpFactor
          );
          this.biometricState.desaturation = this.utils.lerp(
            this.biometricState.desaturation,
            this.biometricState.targetDesaturation,
            lerpFactor
          );
          this.biometricState.slowdown = this.utils.lerp(
            this.biometricState.slowdown,
            this.biometricState.targetSlowdown,
            lerpFactor
          );
          this.applyOptimizedStateToCSS();
        }
        applyOptimizedStateToCSS() {
          const interactionStateVariables = {
            "--sn-nav-item-transform-scale": this.nexusState.currentNavigationScale.toFixed(3),
            "--sn-sidebar-meditation-desaturation": this.biometricState.desaturation.toFixed(3),
            "--sn-sidebar-meditation-slowdown": this.biometricState.slowdown.toFixed(3)
          };
          this.cssController.batchSetVariables(
            "InteractionTrackingSystem",
            interactionStateVariables,
            "high",
            // High priority for real-time interaction state updates
            "interaction-state-update"
          );
        }
        validateMusicData(data) {
          return data && typeof data.energy === "number" && typeof data.valence === "number" && typeof data.visualIntensity === "number";
        }
        applySafeDefaults() {
          const safeDefaultVariables = {
            "--sn-nav-item-transform-scale": "1.0",
            "--sn-sidebar-meditation-desaturation": "0",
            "--sn-sidebar-meditation-slowdown": "1"
          };
          this.cssController.batchSetVariables(
            "InteractionTrackingSystem",
            safeDefaultVariables,
            "critical",
            // Critical priority for safe defaults - ensures fallback stability
            "safe-defaults-fallback"
          );
        }
        updateIntegrationMetrics() {
        }
        calculateIntegrationComplexity() {
          let complexity = 0;
          complexity += this.nexusState.userInfluence * 10;
          complexity += this.nexusState.lastVisualIntensity * 5;
          if (this.biometricState.isMeditating) complexity += 5;
          return complexity;
        }
        performCleanup() {
          if (this.nexusState.userInfluence > 0) {
            this.nexusState.userInfluence = Math.max(
              0,
              this.nexusState.userInfluence - 0.01
            );
          }
        }
        calculateOptimizedNavigationScale(visualIntensity = 0.5, moodIdentifier = "neutral") {
          let scale = 1;
          if (visualIntensity > 0.7) scale = 1.02;
          if (moodIdentifier === "energetic") scale *= 1.01;
          return scale;
        }
        getNavigationScalingReport() {
          return {
            target: this.nexusState.targetNavigationScale,
            current: this.nexusState.currentNavigationScale,
            intensity: this.nexusState.lastVisualIntensity,
            mood: this.nexusState.lastMoodIdentifier
          };
        }
        getMeditationReport() {
          return {
            isMeditating: this.biometricState.isMeditating,
            timeSinceInteraction: (Date.now() - this.biometricState.lastUserInteractionTime) / 1e3,
            desaturation: this.biometricState.desaturation,
            slowdown: this.biometricState.slowdown
          };
        }
        destroy() {
          if (this._interactionHandler) {
            ["click", "mousemove", "keydown"].forEach((evt) => {
              document.removeEventListener(
                evt,
                this._interactionHandler
              );
            });
            this._scrollContainerElements.forEach((el) => {
              el.removeEventListener(
                "scroll",
                this._interactionHandler
              );
            });
            this._interactionHandler = null;
          }
          super.destroy();
        }
      };
      __name(_InteractionTrackingSystem, "InteractionTrackingSystem");
      InteractionTrackingSystem = _InteractionTrackingSystem;
    }
  });

  // src-js/visual/ui/SpotifyUIApplicationSystem.ts
  var _SpotifyUIApplicationSystem, SpotifyUIApplicationSystem;
  var init_SpotifyUIApplicationSystem = __esm({
    "src-js/visual/ui/SpotifyUIApplicationSystem.ts"() {
      "use strict";
      init_UnifiedEventBus();
      _SpotifyUIApplicationSystem = class _SpotifyUIApplicationSystem {
        constructor(year3000System) {
          this.year3000System = year3000System;
          this.systemName = "SpotifyUIApplicationSystem";
          this.initialized = false;
          this.effectLayers = [];
          this.observerRegistry = /* @__PURE__ */ new Map();
          // Performance optimization
          this.lastDiscoveryLogTime = 0;
          this.lastRefreshLogTime = 0;
          // Increased debounce time to reduce frequency
          this.debounceRefresh = this.debounce(() => {
            this.refreshUITargets();
          }, 2e3);
          this.targets = this.initializeEmptyTargets();
        }
        /**
         * Required by IManagedSystem - periodic animation updates
         */
        updateAnimation(deltaTime) {
        }
        /**
         * Required by IManagedSystem - health check
         */
        async healthCheck() {
          try {
            const targetStats = this.getTargetStats();
            const totalElements = Object.values(targetStats).reduce(
              (sum, count) => sum + count,
              0
            );
            const isHealthy = this.initialized && totalElements > 0;
            const issues = [];
            if (totalElements === 0) {
              issues.push("No UI elements discovered");
            }
            return {
              healthy: isHealthy,
              ok: isHealthy,
              details: `UI Application System ${this.initialized ? "active" : "inactive"}, ${totalElements} elements enhanced`,
              issues,
              system: "SpotifyUIApplicationSystem"
            };
          } catch (error) {
            return {
              healthy: false,
              ok: false,
              details: "Health check failed",
              issues: [error instanceof Error ? error.message : "Unknown error"],
              system: "SpotifyUIApplicationSystem"
            };
          }
        }
        /**
         * Force repaint - implements optional IManagedSystem method
         * Cascade Coordination - Ensures proper layering of effects
         */
        forceRepaint(reason) {
          console.log(`\u{1F3A8} Force repaint requested: ${reason || "manual trigger"}`);
          this.forceEffectCascade();
        }
        initializeEmptyTargets() {
          return {
            nowPlaying: [],
            sidebar: [],
            mainContent: [],
            buttons: [],
            cards: [],
            headers: [],
            textElements: [],
            iconElements: [],
            playbackControls: [],
            trackRows: []
          };
        }
        async initialize() {
          if (this.initialized) return;
          try {
            await this.discoverUITargets();
            this.setupEffectLayers();
            this.applyUnifiedState();
            this.setupDOMObservers();
            this.registerSystemCallbacks();
            this.initialized = true;
            console.log("\u2728 SpotifyUIApplicationSystem initialized successfully");
          } catch (error) {
            console.error("Failed to initialize SpotifyUIApplicationSystem", error);
            throw error;
          }
        }
        /**
         * DOM Intelligence Layer - Discovers current Spotify UI elements (OPTIMIZED)
         */
        async discoverUITargets() {
          const selectors = {
            nowPlaying: [
              '[data-testid="now-playing-widget"]',
              ".main-nowPlayingWidget-nowPlaying",
              ".Root__now-playing-bar"
            ],
            sidebar: [
              '[data-testid="nav-bar"]',
              ".main-navBar-navBar",
              ".Root__nav-bar"
            ],
            mainContent: [
              '[data-testid="main"]',
              ".main-view-container",
              ".Root__main-view"
            ],
            buttons: [
              'button[class*="Button"]',
              '[role="button"]',
              ".main-playButton-PlayButton"
            ],
            cards: [
              ".sn-card",
              // Phase 2.2: Unified selector (CardDOMWatcher)
              '[data-testid*="card"]',
              ".main-card-card",
              // Legacy selector (kept for transition)
              ".main-entityCard-container"
            ],
            headers: [
              "h1, h2, h3, h4, h5, h6",
              '[data-testid*="header"]',
              ".main-entityHeader-titleText"
            ],
            textElements: [
              '[data-testid="track-name"]',
              '[data-testid="artist-name"]',
              ".main-trackList-trackName",
              ".main-trackList-artistName"
            ],
            iconElements: [
              'svg[class*="Icon"]',
              '[data-testid*="icon"]',
              ".Svg-sc-ytk21e-0"
            ],
            playbackControls: [
              '[data-testid="control-button"]',
              ".main-playPauseButton-button",
              ".player-controls__buttons"
            ],
            trackRows: [
              '[data-testid="tracklist-row"]',
              ".main-trackList-trackListRow",
              ".main-rootlist-rootlistItem"
            ]
          };
          const combinedQueries = {};
          for (const [category, selectorArray] of Object.entries(selectors)) {
            combinedQueries[category] = selectorArray.join(", ");
          }
          const elementMap = /* @__PURE__ */ new Map();
          for (const [category, combinedSelector] of Object.entries(combinedQueries)) {
            try {
              const found = document.querySelectorAll(combinedSelector);
              for (const element of found) {
                if (!elementMap.has(element)) {
                  elementMap.set(element, []);
                }
                elementMap.get(element).push(category);
              }
            } catch (error) {
              continue;
            }
          }
          this.targets = this.initializeEmptyTargets();
          for (const [element, categories] of elementMap) {
            for (const category of categories) {
              this.targets[category].push(element);
            }
          }
          if (performance.now() - this.lastDiscoveryLogTime >= 5e3) {
            console.log("\u{1F3AF} UI targets discovered", {
              nowPlaying: this.targets.nowPlaying.length,
              sidebar: this.targets.sidebar.length,
              mainContent: this.targets.mainContent.length,
              buttons: this.targets.buttons.length,
              cards: this.targets.cards.length,
              headers: this.targets.headers.length,
              textElements: this.targets.textElements.length,
              iconElements: this.targets.iconElements.length,
              playbackControls: this.targets.playbackControls.length,
              trackRows: this.targets.trackRows.length
            });
            this.lastDiscoveryLogTime = performance.now();
          }
        }
        /**
         * Effect Application Pipeline - Sets up cascade layers from background to foreground
         */
        setupEffectLayers() {
          this.effectLayers = [
            // Layer 1: Background & Container Effects
            {
              name: "background-containers",
              elements: [...this.targets.mainContent, ...this.targets.sidebar],
              priority: 10,
              cssVariables: {
                "--sn-bg-primary": "var(--sn-accent-primary)",
                "--sn-bg-secondary": "var(--sn-accent-secondary)",
                "--sn-gradient-start": "var(--sn-gradient-primary-rgb)",
                "--sn-gradient-end": "var(--sn-gradient-secondary-rgb)"
              }
            },
            // Layer 2: Card & Content Effects
            {
              name: "ui-cards",
              elements: this.targets.cards,
              priority: 20,
              cssVariables: {
                "--sn-card-bg": "var(--sn-accent-primary)",
                "--sn-card-border": "var(--sn-accent-secondary)",
                "--sn-card-glow": "var(--sn-accent-tertiary)",
                "--sn-glassmorphism-intensity": "var(--sn-effect-intensity)"
              },
              interactionEffects: true
            },
            // Layer 3: Interactive Elements
            {
              name: "interactive-elements",
              elements: [...this.targets.buttons, ...this.targets.playbackControls],
              priority: 30,
              cssVariables: {
                "--sn-button-bg": "var(--sn-accent-primary)",
                "--sn-button-hover": "var(--sn-accent-secondary)",
                "--sn-button-active": "var(--sn-accent-tertiary)",
                "--sn-beat-sync-intensity": "var(--sn-music-intensity)"
              },
              interactionEffects: true
            },
            // Layer 4: Text & Icon Enhancement
            {
              name: "text-icon-effects",
              elements: [
                ...this.targets.textElements,
                ...this.targets.iconElements,
                ...this.targets.headers
              ],
              priority: 40,
              cssVariables: {
                "--sn-text-primary": "var(--sn-accent-primary)",
                "--sn-text-secondary": "var(--sn-accent-secondary)",
                "--sn-text-glow": "var(--sn-accent-tertiary)",
                "--sn-icon-color": "var(--sn-accent-primary)",
                "--sn-icon-glow": "var(--sn-accent-secondary)"
              }
            },
            // Layer 5: Now Playing Special Effects
            {
              name: "now-playing-effects",
              elements: this.targets.nowPlaying,
              priority: 50,
              cssVariables: {
                "--sn-now-playing-bg": "var(--sn-accent-primary)",
                "--sn-now-playing-glow": "var(--sn-accent-secondary)",
                "--sn-beat-pulse": "var(--sn-music-intensity)",
                "--sn-track-progress": "var(--sn-accent-tertiary)"
              },
              interactionEffects: true
            }
          ];
        }
        /**
         * Applies unified state from existing systems to discovered UI elements
         */
        applyUnifiedState() {
          this.effectLayers.forEach((layer) => {
            layer.elements.forEach((element) => {
              this.applyEffectToElement(element, layer);
            });
          });
        }
        /**
         * Helper method to safely call Year3000System's queueCSSVariableUpdate
         */
        safeQueueCSSVariableUpdate(property, value, element) {
          if (this.year3000System?.queueCSSVariableUpdate) {
            this.year3000System.queueCSSVariableUpdate(property, value, element || null);
          } else {
            const target = element || document.documentElement;
            target.style.setProperty(property, value);
          }
        }
        applyEffectToElement(element, layer) {
          if (!(element instanceof HTMLElement)) return;
          Object.entries(layer.cssVariables).forEach(([property, value]) => {
            this.safeQueueCSSVariableUpdate(property, value, element);
          });
          element.classList.add(`sn-${layer.name}`);
          element.classList.add("sn-ui-enhanced");
          if (layer.interactionEffects) {
            this.addInteractionEffects(element, layer);
          }
          element.setAttribute("data-sn-layer", layer.name);
          element.setAttribute("data-sn-priority", layer.priority.toString());
        }
        addInteractionEffects(element, layer) {
          if (layer.name === "interactive-elements" || layer.name === "now-playing-effects") {
            this.safeQueueCSSVariableUpdate(
              "--sn-beat-response",
              "var(--sn-music-intensity)",
              element
            );
            element.classList.add("sn-beat-responsive");
          }
          element.addEventListener("mouseenter", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-hover-intensity",
              "1",
              element
            );
            element.classList.add("sn-hover-active");
          });
          element.addEventListener("mouseleave", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-hover-intensity",
              "0",
              element
            );
            element.classList.remove("sn-hover-active");
          });
          element.addEventListener("click", () => {
            this.safeQueueCSSVariableUpdate(
              "--sn-click-intensity",
              "1",
              element
            );
            element.classList.add("sn-click-active");
            setTimeout(() => {
              this.safeQueueCSSVariableUpdate(
                "--sn-click-intensity",
                "0",
                element
              );
              element.classList.remove("sn-click-active");
            }, 300);
          });
        }
        /**
         * Sets up DOM mutation observers for dynamic Spotify UI updates (OPTIMIZED)
         */
        setupDOMObservers() {
          const observerConfig = {
            childList: true,
            subtree: false,
            // Reduced to immediate children only
            attributes: false
            // Disabled attribute watching for performance
          };
          const mainObserver = new MutationObserver((mutations) => {
            let significantChange = false;
            mutations.forEach((mutation) => {
              if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
                const hasSignificantNodes = Array.from(mutation.addedNodes).some((node) => {
                  if (node.nodeType === Node.ELEMENT_NODE) {
                    const element = node;
                    return element.matches('[data-testid*="card"], [data-testid*="track"], [data-testid*="header"], [role="button"]') || element.querySelector('[data-testid*="card"], [data-testid*="track"], [data-testid*="header"], [role="button"]');
                  }
                  return false;
                });
                if (hasSignificantNodes) {
                  significantChange = true;
                }
              }
            });
            if (significantChange) {
              this.debounceRefresh();
            }
          });
          const mainElement = document.querySelector('[data-testid="main"]') || document.body;
          mainObserver.observe(mainElement, observerConfig);
          this.observerRegistry.set("main", mainObserver);
        }
        // Increased from 500ms to 2000ms
        debounce(func, wait) {
          let timeout;
          return /* @__PURE__ */ __name(function executedFunction(...args) {
            const later = /* @__PURE__ */ __name(() => {
              clearTimeout(timeout);
              func(...args);
            }, "later");
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          }, "executedFunction");
        }
        async refreshUITargets() {
          try {
            const previousTargetHash = this.calculateTargetHash();
            await this.discoverUITargets();
            const currentTargetHash = this.calculateTargetHash();
            if (previousTargetHash !== currentTargetHash) {
              this.applyUnifiedState();
              if (performance.now() - this.lastRefreshLogTime >= 1e4) {
                console.log("\u{1F504} UI targets refreshed");
                this.lastRefreshLogTime = performance.now();
              }
            }
          } catch (error) {
            console.error("Failed to refresh UI targets", error);
          }
        }
        calculateTargetHash() {
          const counts = Object.values(this.targets).map((arr) => arr.length);
          return counts.join("-");
        }
        /**
         * Registers for updates from unified systems - connects to event-driven architecture
         */
        registerSystemCallbacks() {
          try {
            unifiedEventBus.subscribe("colors:harmonized", (data) => {
              this.handleColorHarmonizedEvent({
                type: "colors/harmonized",
                payload: {
                  processedColors: data.processedColors,
                  accentHex: data.accentHex || "#cba6f7",
                  accentRgb: data.accentRgb || "203,166,247",
                  context: {
                    rawColors: data.processedColors,
                    trackUri: "",
                    timestamp: Date.now()
                  },
                  cssVariables: {},
                  metadata: {
                    strategy: data.strategies[0] || "unknown",
                    accentHex: data.accentHex,
                    processingTime: data.processingTime
                  }
                }
              });
            }, "SpotifyUIApplicationSystem");
            console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Subscribed to colors:harmonized events");
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to subscribe to colors:harmonized events:", error);
            if (this.year3000System.colorHarmonyEngine) {
              const originalApplyColors = this.year3000System.applyColorsToTheme.bind(
                this.year3000System
              );
              this.year3000System.applyColorsToTheme = (extractedColors = {}) => {
                originalApplyColors(extractedColors);
                this.updateColorVariables(extractedColors);
              };
              console.warn("[SpotifyUIApplicationSystem] Using legacy color application hook as fallback");
            }
          }
          if (this.year3000System.musicSyncService) {
            const originalUpdateFromAnalysis = this.year3000System.updateFromMusicAnalysis.bind(this.year3000System);
            this.year3000System.updateFromMusicAnalysis = (processedData, rawFeatures, trackUri) => {
              originalUpdateFromAnalysis(processedData, rawFeatures, trackUri);
              this.updateMusicIntensity(processedData);
            };
          }
          if (this.year3000System.beatSyncVisualSystem) {
            if (this.year3000System.timerConsolidationSystem) {
              this.year3000System.timerConsolidationSystem.registerConsolidatedTimer(
                "SpotifyUIApplicationSystem-beatEffects",
                () => {
                  const intensity = this.getCurrentMusicIntensity();
                  if (intensity > 0.5) {
                    this.triggerBeatEffects({ intensity });
                  }
                },
                200,
                "normal"
              );
            } else {
              setInterval(() => {
                const intensity = this.getCurrentMusicIntensity();
                if (intensity > 0.5) {
                  this.triggerBeatEffects({ intensity });
                }
              }, 200);
            }
          }
        }
        getCurrentMusicIntensity() {
          const root = document.documentElement;
          const intensity = getComputedStyle(root).getPropertyValue("--sn-kinetic-energy").trim();
          return parseFloat(intensity) || 0;
        }
        /**
         * Handle colors/harmonized event from ColorOrchestrator (Event-driven architecture)
         */
        handleColorHarmonizedEvent(event) {
          if (event.type !== "colors/harmonized") return;
          const { processedColors, cssVariables, metadata } = event.payload;
          console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Received harmonized colors via event-driven pattern", {
            strategy: metadata.strategy,
            colorsCount: Object.keys(processedColors).length,
            cssVariablesCount: Object.keys(cssVariables).length
          });
          try {
            this.updateColorVariables(processedColors);
            if (cssVariables && Object.keys(cssVariables).length > 0) {
              this.applyCSSVariablesToSpotifyUI(cssVariables);
            }
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to apply harmonized colors from event:", error);
            this.updateColorVariables(processedColors);
          }
        }
        /**
         * Apply CSS variables directly to Spotify UI elements (optimization for event-driven pattern)
         */
        applyCSSVariablesToSpotifyUI(cssVariables) {
          try {
            const root = document.documentElement;
            const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
            for (const [variable, value] of Object.entries(cssVariables)) {
              if (variable && value) {
                root.style.setProperty(variable, value);
              }
            }
            enhancedElements.forEach((element) => {
              if (element instanceof HTMLElement) {
                for (const [variable, value] of Object.entries(cssVariables)) {
                  if (variable && value) {
                    element.style.setProperty(variable, value);
                  }
                }
              }
            });
            console.log("\u{1F3A8} [SpotifyUIApplicationSystem] Applied CSS variables to Spotify UI", {
              variablesCount: Object.keys(cssVariables).length,
              enhancedElementsCount: enhancedElements.length
            });
          } catch (error) {
            console.error("[SpotifyUIApplicationSystem] Failed to apply CSS variables to Spotify UI:", error);
          }
        }
        updateColorVariables(colorData) {
          const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
          enhancedElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-primary",
                colorData.primary || "var(--spice-accent)",
                element
              );
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-secondary",
                colorData.secondary || "var(--spice-accent)",
                element
              );
              this.safeQueueCSSVariableUpdate(
                "--sn-accent-tertiary",
                colorData.tertiary || "var(--spice-accent)",
                element
              );
            }
          });
        }
        updateMusicIntensity(processedData) {
          const intensity = processedData?.processedEnergy || 0;
          const intensityElements = document.querySelectorAll(".sn-beat-responsive");
          intensityElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-music-intensity",
                intensity.toString(),
                element
              );
            }
          });
        }
        triggerBeatEffects(beatData) {
          const beatElements = document.querySelectorAll(".sn-beat-responsive");
          beatElements.forEach((element) => {
            if (element instanceof HTMLElement) {
              this.safeQueueCSSVariableUpdate(
                "--sn-beat-pulse",
                "1",
                element
              );
              element.classList.add("sn-beat-active");
              setTimeout(() => {
                this.safeQueueCSSVariableUpdate(
                  "--sn-beat-pulse",
                  "0",
                  element
                );
                element.classList.remove("sn-beat-active");
              }, 200);
            }
          });
        }
        /**
         * Cascade Coordination - Ensures proper layering of effects
         */
        forceEffectCascade() {
          this.effectLayers.sort((a, b) => a.priority - b.priority).forEach((layer) => {
            layer.elements.forEach((element) => {
              this.applyEffectToElement(element, layer);
            });
          });
        }
        async destroy() {
          if (this.year3000System?.timerConsolidationSystem) {
            this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer("SpotifyUIApplicationSystem-beatEffects");
          }
          this.observerRegistry.forEach((observer) => {
            observer.disconnect();
          });
          this.observerRegistry.clear();
          const enhancedElements = document.querySelectorAll(".sn-ui-enhanced");
          enhancedElements.forEach((element) => {
            element.classList.remove("sn-ui-enhanced");
            element.removeAttribute("data-sn-layer");
            element.removeAttribute("data-sn-priority");
          });
          this.initialized = false;
        }
        // Debug utility
        getTargetStats() {
          return Object.fromEntries(
            Object.entries(this.targets).map(([key, elements]) => [
              key,
              elements.length
            ])
          );
        }
      };
      __name(_SpotifyUIApplicationSystem, "SpotifyUIApplicationSystem");
      SpotifyUIApplicationSystem = _SpotifyUIApplicationSystem;
    }
  });

  // src-js/visual/effects/HighEnergyEffectsController.ts
  var _RedEnergyBurstSystem, RedEnergyBurstSystem;
  var init_HighEnergyEffectsController = __esm({
    "src-js/visual/effects/HighEnergyEffectsController.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_EmotionalTemperatureMapper();
      init_OKLABColorProcessor();
      _RedEnergyBurstSystem = class _RedEnergyBurstSystem {
        constructor(layeredSystem, cssVisualEffectsController, musicSyncService) {
          this.initialized = false;
          this.cinematicElements = /* @__PURE__ */ new Map();
          /** @deprecated Use cinematicElements instead */
          this.dramaticElements = this.cinematicElements;
          // Real-time performance monitoring and metrics
          this.performanceMetrics = {
            energyBurstCount: 0,
            // Total energy bursts generated
            averageProcessingTime: 0,
            // Rolling average processing time (ms)
            lastUpdateTime: 0,
            // Last update timestamp
            cpuUsage: 0
            // Current CPU usage percentage
          };
          // Animation timing and phase tracking
          this.animationState = {
            energyPhase: 0,
            // Current energy burst phase (0-2π)
            dramaticPhase: 0,
            // Musical tension phase for effects
            interferencePhase: 0,
            // CRT interference pattern phase
            lastFrameTime: 0,
            // Previous frame timestamp
            isAnimating: false
            // Animation loop active status
          };
          // Cinematic color presets
          this.cinematicPalettes = {
            "blade-runner": {
              primaryRed: { r: 255, g: 50, b: 50 },
              amberGlow: { r: 255, g: 140, b: 0 },
              deepBlue: { r: 0, g: 100, b: 200 },
              neonCyan: { r: 0, g: 255, b: 255 }
            },
            cyberpunk: {
              primaryRed: { r: 255, g: 0, b: 100 },
              amberGlow: { r: 255, g: 180, b: 0 },
              deepBlue: { r: 50, g: 50, b: 255 },
              neonCyan: { r: 100, g: 255, b: 255 }
            },
            "dramatic-noir": {
              primaryRed: { r: 200, g: 0, b: 0 },
              amberGlow: { r: 255, g: 120, b: 0 },
              deepBlue: { r: 0, g: 50, b: 150 },
              neonCyan: { r: 0, g: 200, b: 255 }
            }
          };
          this.layeredSystem = layeredSystem;
          this.holographicSystem = layeredSystem;
          this.cssController = cssVisualEffectsController;
          this.musicSyncService = musicSyncService;
          this.oklabProcessor = new OKLABColorProcessor(true);
          this.emotionalMapper = new EmotionalTemperatureMapper(true);
          this.cinematicPreset = OKLABColorProcessor.getPreset("COSMIC");
          this.energyBurstState = {
            burstIntensity: 0,
            burstFrequency: 0.5,
            colorTemperature: 2500,
            // Red-amber temperature
            interferenceLevel: 0,
            scanlineVelocity: 1,
            layeredDepth: 0,
            holographicDepth: 0,
            // Legacy compatibility
            musicTension: 0,
            energyStability: 1
          };
          this.cinematicConfig = {
            energyActivationThreshold: 0.7,
            // Activate on high intensity
            maxLayeredIntensity: 0.9,
            // Maximum effect strength
            maxHolographicIntensity: 0.9,
            // Legacy compatibility
            crtFilteringStrength: 0.8,
            // Strong CRT simulation
            bladeRunnerMode: true,
            // Authentic aesthetic
            energyBurstDuration: 1500,
            // 1.5 second bursts
            baseScanlineFrequency: 120
            // 120Hz base scanlines
          };
        }
        /**
         * Initialize the Cinematic Drama Engine
         */
        async initialize() {
          if (this.initialized) return;
          try {
            console.log(
              "[RedEnergyBurstSystem] Initializing red energy burst system..."
            );
            this.subscribeToColorVisualEffects();
            this.subscribeToOKLABColorEvents();
            await this.initializeCinematicElements();
            this.setupCinematicCSSVariables();
            this.initialized = true;
            console.log(
              "[RedEnergyBurstSystem] \u2705 Ready for dramatic visual effects moments"
            );
          } catch (error) {
            console.error("[RedEnergyBurstSystem] Failed to initialize:", error);
            throw error;
          }
        }
        /**
         * Update animation frame for cinematic effects
         */
        updateAnimation(deltaTime) {
          if (!this.initialized) return;
          const deltaSeconds = deltaTime / 1e3;
          this.animationState.energyPhase += deltaSeconds * this.energyBurstState.burstFrequency * 2;
          this.animationState.dramaticPhase += deltaSeconds * 0.8;
          this.animationState.interferencePhase += deltaSeconds * 3;
          if (this.energyBurstState.burstIntensity > 0.05) {
            const decayRate = 0.05;
            this.energyBurstState.burstIntensity *= 1 - decayRate;
            this.energyBurstState.layeredDepth *= 1 - decayRate * 0.8;
            this.energyBurstState.holographicDepth = this.energyBurstState.layeredDepth;
            this.energyBurstState.interferenceLevel *= 1 - decayRate * 0.6;
          } else if (this.energyBurstState.burstIntensity > 0) {
            this.energyBurstState.burstIntensity = 0;
            this.energyBurstState.layeredDepth = 0;
            this.energyBurstState.holographicDepth = 0;
            this.energyBurstState.interferenceLevel = 0;
          }
          this.updateEnergyBurstFromMusic();
          this.updateLayeredMapping();
          this.updateCinematicElements();
          this.updatePerformanceMetrics(deltaTime);
        }
        /**
         * Health check for cinematic drama system
         */
        async healthCheck() {
          const isHealthy = this.initialized && this.energyBurstState.burstIntensity >= 0 && this.performanceMetrics.averageProcessingTime < 5;
          return {
            system: "RedEnergyBurstSystem",
            healthy: isHealthy,
            metrics: {
              energyBurstCount: this.performanceMetrics.energyBurstCount,
              processingTime: this.performanceMetrics.averageProcessingTime,
              cinematicElementCount: this.cinematicElements.size,
              cpuUsage: this.performanceMetrics.cpuUsage
            },
            issues: isHealthy ? [] : ["Performance degradation detected"]
          };
        }
        /**
         * Subscribe to ColorVisualEffectsOrchestrator events
         */
        subscribeToColorVisualEffects() {
          unifiedEventBus.subscribe("music:emotional-context-updated", (event) => {
            this.onColorVisualEffectsUpdate(event);
          }, "RedEnergyBurstSystem");
          unifiedEventBus.subscribe("music:emotion-analyzed", (event) => {
            this.onMusicIntensitySpike(event);
          }, "RedEnergyBurstSystem");
          unifiedEventBus.subscribe("music:emotion-analyzed", (event) => {
            this.onDramaticMoment(event);
          }, "RedEnergyBurstSystem");
        }
        /**
         * Subscribe to unified OKLAB color events
         */
        subscribeToOKLABColorEvents() {
          unifiedEventBus.subscribe(
            "colors:harmonized",
            (event) => {
              this.onOKLABColorsHarmonized(event);
            },
            "RedEnergyBurstSystem"
          );
          unifiedEventBus.subscribe(
            "colors:extracted",
            (event) => {
              this.onColorsExtracted(event);
            },
            "RedEnergyBurstSystem"
          );
        }
        /**
         * Handle color visual effects updates
         */
        onColorVisualEffectsUpdate(event) {
          const { palette, visualEffectsLevel, emotionalTemperature } = event;
          this.energyBurstState.musicTension = visualEffectsLevel * 0.8;
          if (emotionalTemperature < 3e3) {
            this.energyBurstState.colorTemperature = 2200;
          } else if (emotionalTemperature > 6e3) {
            this.energyBurstState.colorTemperature = 2800;
          } else {
            this.energyBurstState.colorTemperature = 2500;
          }
          const dominantColor = this.extractDominantRedColor(palette);
          this.updateHolographicColors(dominantColor);
        }
        /**
         * Handle music intensity spikes
         */
        onMusicIntensitySpike(event) {
          const { intensity, beat } = event;
          if (intensity > this.cinematicConfig.energyActivationThreshold) {
            this.triggerEnergyBurst(intensity, beat);
          }
        }
        /**
         * Handle dramatic musical moments
         */
        onDramaticMoment(event) {
          const { type, intensity } = event;
          this.energyBurstState.musicTension = Math.min(1, intensity * 1.2);
          this.energyBurstState.interferenceLevel = intensity * 0.6;
          this.energyBurstState.energyStability = Math.max(
            0.3,
            1 - intensity * 0.7
          );
        }
        /**
         * Handle OKLAB harmonized colors for cinematic enhancement
         */
        onOKLABColorsHarmonized(event) {
          const { processedColors, coordinationMetrics } = event;
          const cinematicColors = this.extractCinematicOKLABColors(processedColors);
          this.updateCinematicPaletteWithOKLAB(cinematicColors);
          if (coordinationMetrics?.detectedGenre || coordinationMetrics?.emotionalState) {
            this.adjustCinematicPresetForContext(coordinationMetrics);
          }
        }
        /**
         * Handle color extraction for immediate cinematic response
         */
        onColorsExtracted(event) {
          const { rawColors, musicData } = event;
          if (musicData) {
            const emotionalResult = this.emotionalMapper.mapMusicToEmotionalTemperature(musicData);
            this.adjustCinematicEffectsForEmotion(emotionalResult);
            if (emotionalResult.intensity > 0.7) {
              this.cinematicPreset = OKLABColorProcessor.getPreset("COSMIC");
            } else if (emotionalResult.intensity > 0.4) {
              this.cinematicPreset = OKLABColorProcessor.getPreset("VIBRANT");
            } else {
              this.cinematicPreset = OKLABColorProcessor.getPreset("STANDARD");
            }
          }
        }
        /**
         * Trigger red energy burst effect
         */
        triggerEnergyBurst(intensity, beat) {
          const startTime = performance.now();
          this.energyBurstState.burstIntensity = Math.min(1, intensity * 1.1);
          this.energyBurstState.burstFrequency = 1 + intensity * 2;
          this.energyBurstState.layeredDepth = intensity * 0.8;
          this.energyBurstState.holographicDepth = intensity * 0.8;
          this.energyBurstState.scanlineVelocity = 1 + beat.strength * 2;
          setTimeout(() => {
            this.decayEnergyBurst();
          }, this.cinematicConfig.energyBurstDuration);
          this.performanceMetrics.energyBurstCount++;
          this.performanceMetrics.lastUpdateTime = performance.now() - startTime;
          console.log(
            `[RedEnergyBurstSystem] \u{1F525} Red energy burst triggered! Intensity: ${intensity.toFixed(
              2
            )}`
          );
        }
        /**
         * Decay energy burst over time
         * MIGRATION NOTE: This now relies on updateAnimation() being called by coordinator.
         * Decay is handled frame-by-frame in updateAnimation() instead of standalone RAF loop.
         */
        decayEnergyBurst() {
        }
        /**
         * Update energy burst from current music state
         */
        updateEnergyBurstFromMusic() {
          const musicState = this.musicSyncService.getCurrentMusicState();
          if (!musicState) return;
          const { emotion, beat, intensity } = musicState;
          if (beat && beat.tempo) {
            const tempoMultiplier = Math.max(0.5, Math.min(2, beat.tempo / 120));
            this.energyBurstState.burstFrequency = this.energyBurstState.burstFrequency * tempoMultiplier;
          }
          if (emotion && emotion.arousal > 0.7) {
            this.energyBurstState.interferenceLevel = Math.max(
              this.energyBurstState.interferenceLevel,
              emotion.arousal * 0.5
            );
          }
        }
        /**
         * Update layered color mapping for cinematic effects
         */
        updateLayeredMapping() {
          const palette = this.cinematicPalettes["blade-runner"];
          const mapping = {
            primaryColor: this.blendRedColors(
              palette.primaryRed,
              palette.amberGlow,
              this.energyBurstState.colorTemperature / 3e3
            ),
            glowIntensity: this.energyBurstState.burstIntensity * this.cinematicConfig.maxLayeredIntensity,
            flickerRate: this.energyBurstState.burstFrequency * 2,
            scanlineColor: palette.amberGlow,
            atmosphericDepth: this.energyBurstState.layeredDepth,
            interferencePattern: this.getInterferencePattern()
          };
          this.updateCinematicCSSVariables(mapping);
        }
        /**
         * @deprecated Use updateLayeredMapping instead
         * Update holographic color mapping for cinematic effects
         */
        updateHolographicMapping() {
          this.updateLayeredMapping();
        }
        /**
         * Blend red colors based on temperature using OKLAB for perceptual accuracy
         */
        blendRedColors(red, amber, blendFactor) {
          const factor = Math.max(0, Math.min(1, blendFactor));
          try {
            const redHex = `#${red.r.toString(16).padStart(2, "0")}${red.g.toString(16).padStart(2, "0")}${red.b.toString(16).padStart(2, "0")}`;
            const amberHex = `#${amber.r.toString(16).padStart(2, "0")}${amber.g.toString(16).padStart(2, "0")}${amber.b.toString(16).padStart(2, "0")}`;
            const blendedResult = this.oklabProcessor.interpolateOKLAB(
              redHex,
              amberHex,
              factor,
              this.cinematicPreset
            );
            return blendedResult.enhancedRgb;
          } catch (error) {
            return {
              r: Math.round(red.r * (1 - factor) + amber.r * factor),
              g: Math.round(red.g * (1 - factor) + amber.g * factor),
              b: Math.round(red.b * (1 - factor) + amber.b * factor)
            };
          }
        }
        /**
         * Get interference pattern based on current state
         */
        getInterferencePattern() {
          if (this.energyBurstState.energyStability < 0.4) {
            return "chaotic";
          } else if (this.energyBurstState.musicTension > 0.7) {
            return "intense";
          } else if (this.energyBurstState.interferenceLevel > 0.5) {
            return "noise";
          } else {
            return "wave";
          }
        }
        /**
         * Extract dominant red color from palette
         */
        extractDominantRedColor(palette) {
          let redColor = { r: 255, g: 50, b: 50 };
          if (palette && palette.length > 0) {
            const reds = palette.filter(
              (color3) => color3.r > color3.g && color3.r > color3.b
            );
            if (reds.length > 0) {
              redColor = reds[0];
            }
          }
          return redColor;
        }
        /**
         * Extract cinematic colors from OKLAB-processed palette
         */
        extractCinematicOKLABColors(processedColors) {
          const defaultColors = this.cinematicPalettes["blade-runner"];
          const enhancedColors = { ...defaultColors };
          if (processedColors.VIBRANT) {
            const vibrantResult = this.oklabProcessor.processColor(
              processedColors.VIBRANT,
              this.cinematicPreset
            );
            enhancedColors.primaryRed = vibrantResult.enhancedRgb;
          }
          if (processedColors.PROMINENT) {
            const prominentResult = this.oklabProcessor.processColor(
              processedColors.PROMINENT,
              this.cinematicPreset
            );
            enhancedColors.amberGlow = prominentResult.enhancedRgb;
          }
          if (processedColors.DARK_VIBRANT) {
            const darkResult = this.oklabProcessor.processColor(
              processedColors.DARK_VIBRANT,
              this.cinematicPreset
            );
            enhancedColors.deepBlue = darkResult.enhancedRgb;
          }
          return enhancedColors;
        }
        /**
         * Update cinematic palette with OKLAB-enhanced colors
         */
        updateCinematicPaletteWithOKLAB(cinematicColors) {
          this.cinematicPalettes["blade-runner"] = cinematicColors;
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-red-r",
            cinematicColors.primaryRed.r.toString()
          );
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-red-g",
            cinematicColors.primaryRed.g.toString()
          );
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-red-b",
            cinematicColors.primaryRed.b.toString()
          );
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-amber-r",
            cinematicColors.amberGlow.r.toString()
          );
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-amber-g",
            cinematicColors.amberGlow.g.toString()
          );
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-amber-b",
            cinematicColors.amberGlow.b.toString()
          );
        }
        /**
         * Adjust cinematic preset based on detected genre/emotion context
         */
        adjustCinematicPresetForContext(coordinationMetrics) {
          const { detectedGenre, emotionalState, oklabPreset } = coordinationMetrics;
          if (detectedGenre) {
            switch (detectedGenre) {
              case "electronic":
              case "dance":
              case "techno":
                this.cinematicPreset = OKLABColorProcessor.getPreset("COSMIC");
                this.cinematicConfig.bladeRunnerMode = true;
                break;
              case "rock":
              case "metal":
                this.cinematicPreset = OKLABColorProcessor.getPreset("VIBRANT");
                this.cinematicConfig.energyActivationThreshold = 0.6;
                break;
              case "ambient":
              case "classical":
                this.cinematicPreset = OKLABColorProcessor.getPreset("SUBTLE");
                this.cinematicConfig.energyActivationThreshold = 0.8;
                break;
              default:
                this.cinematicPreset = OKLABColorProcessor.getPreset("STANDARD");
            }
          }
          if (emotionalState) {
            switch (emotionalState) {
              case "aggressive":
              case "energetic":
                this.energyBurstState.burstFrequency *= 1.5;
                this.energyBurstState.interferenceLevel = Math.min(
                  1,
                  this.energyBurstState.interferenceLevel + 0.3
                );
                break;
              case "calm":
              case "ambient":
                this.energyBurstState.burstFrequency *= 0.7;
                this.energyBurstState.energyStability = Math.min(
                  1,
                  this.energyBurstState.energyStability + 0.2
                );
                break;
              case "mysterious":
                this.cinematicConfig.bladeRunnerMode = true;
                this.energyBurstState.interferenceLevel = Math.min(
                  1,
                  this.energyBurstState.interferenceLevel + 0.2
                );
                break;
            }
          }
        }
        /**
         * Adjust cinematic effects based on emotional temperature result
         */
        adjustCinematicEffectsForEmotion(emotionalResult) {
          const { primaryEmotion, intensity, temperature } = emotionalResult;
          this.energyBurstState.musicTension = intensity * 0.9;
          if (temperature < 3e3) {
            this.energyBurstState.colorTemperature = 2200;
          } else if (temperature > 6e3) {
            this.energyBurstState.colorTemperature = 2800;
          } else {
            this.energyBurstState.colorTemperature = 2500;
          }
          switch (primaryEmotion) {
            case "aggressive":
              this.energyBurstState.interferenceLevel = Math.min(
                1,
                intensity * 0.8
              );
              this.energyBurstState.energyStability = Math.max(0.2, 1 - intensity);
              break;
            case "calm":
              this.energyBurstState.energyStability = Math.min(
                1,
                0.8 + intensity * 0.2
              );
              this.energyBurstState.interferenceLevel *= 0.5;
              break;
            case "mysterious":
              this.energyBurstState.interferenceLevel = intensity * 0.6;
              this.cinematicConfig.bladeRunnerMode = true;
              break;
            case "energetic":
              this.energyBurstState.burstFrequency = Math.min(3, 1 + intensity * 2);
              break;
          }
        }
        /**
         * Update holographic colors
         */
        updateHolographicColors(dominantColor) {
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-red-r",
            dominantColor.r.toString()
          );
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-red-g",
            dominantColor.g.toString()
          );
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-red-b",
            dominantColor.b.toString()
          );
        }
        /**
         * Initialize cinematic UI elements
         */
        async initializeCinematicElements() {
          return this.initializeDramaticElements();
        }
        /**
         * @deprecated Use initializeCinematicElements instead
         * Initialize dramatic UI elements
         */
        async initializeDramaticElements() {
          const dramaticSelectors = [
            { selector: ".Root__now-playing-bar", type: "energy_barrier" },
            { selector: ".main-view-container", type: "cinematic_overlay" },
            { selector: ".Root__nav-bar", type: "data_stream_red" },
            { selector: ".player-controls", type: "dramatic_interface" }
          ];
          for (const config of dramaticSelectors) {
            const elements = document.querySelectorAll(config.selector);
            for (const element of elements) {
              const dramaticElement = {
                id: `dramatic-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                element,
                originalStyles: getComputedStyle(element),
                holographicType: config.type,
                intensity: 0.8,
                isActive: true,
                lastUpdate: 0,
                animation: null,
                visualEffectsLevel: 0.9,
                smoothIntegration: true
              };
              this.cinematicElements.set(dramaticElement.id, dramaticElement);
            }
          }
        }
        /**
         * Setup CSS variables for cinematic effects
         */
        setupCinematicCSSVariables() {
          const baseVariables = {
            "--cinematic-red-r": "255",
            "--cinematic-red-g": "50",
            "--cinematic-red-b": "50",
            "--cinematic-amber-r": "255",
            "--cinematic-amber-g": "140",
            "--cinematic-amber-b": "0",
            "--cinematic-glow-intensity": "0",
            "--cinematic-flicker-rate": "0.5",
            "--cinematic-scanline-speed": "1.0",
            "--cinematic-interference": "0",
            "--cinematic-depth": "0"
          };
          for (const [variable, value] of Object.entries(baseVariables)) {
            this.cssController.queueCSSVariableUpdate(variable, value);
          }
        }
        /**
         * Update cinematic CSS variables
         */
        updateCinematicCSSVariables(mapping) {
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-glow-intensity",
            mapping.glowIntensity.toString()
          );
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-flicker-rate",
            mapping.flickerRate.toString()
          );
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-scanline-speed",
            this.energyBurstState.scanlineVelocity.toString()
          );
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-interference",
            this.energyBurstState.interferenceLevel.toString()
          );
          this.cssController.queueCSSVariableUpdate(
            "--cinematic-depth",
            mapping.atmosphericDepth.toString()
          );
        }
        /**
         * Update cinematic elements
         */
        updateCinematicElements() {
          for (const [id, element] of this.cinematicElements) {
            if (element.isActive) {
              this.updateCinematicElement(element);
            }
          }
        }
        /**
         * @deprecated Use updateCinematicElements instead
         * Update dramatic elements
         */
        updateDramaticElements() {
          for (const [id, element] of this.cinematicElements) {
            if (element.isActive) {
              this.updateDramaticElement(element);
            }
          }
        }
        /**
         * Update single cinematic element
         */
        updateCinematicElement(element) {
          const { element: htmlElement, intensity } = element;
          if (this.energyBurstState.burstIntensity > 0.1) {
            this.applyRedEnergyBurst(htmlElement, intensity);
          }
          if (this.energyBurstState.interferenceLevel > 0.1) {
            this.applyCRTInterference(htmlElement, intensity);
          }
          this.applyCinematicScanlines(htmlElement, intensity);
        }
        /**
         * @deprecated Use updateCinematicElement instead
         * Update single dramatic element
         */
        updateDramaticElement(element) {
          const { element: htmlElement, intensity } = element;
          if (this.energyBurstState.burstIntensity > 0.1) {
            this.applyRedEnergyBurst(htmlElement, intensity);
          }
          if (this.energyBurstState.interferenceLevel > 0.1) {
            this.applyCRTInterference(htmlElement, intensity);
          }
          this.applyCinematicScanlines(htmlElement, intensity);
        }
        /**
         * Apply red energy burst effect to element
         * PERFORMANCE FIX: Use CSS variables instead of direct DOM manipulation
         */
        applyRedEnergyBurst(element, intensity) {
          const burstIntensity = this.energyBurstState.burstIntensity * intensity;
          const dramaticPulse = Math.sin(this.animationState.energyPhase * 3) * 0.5 + 0.5;
          const glowIntensity = burstIntensity * dramaticPulse * 0.8;
          const glowSpread = glowIntensity * 40;
          const insetSpread = glowIntensity * 20;
          const insetOpacity = glowIntensity * 0.5;
          this.cssController.queueCSSVariableUpdate("--energy-glow-spread", `${glowSpread}px`);
          this.cssController.queueCSSVariableUpdate("--energy-glow-opacity", glowIntensity.toString());
          this.cssController.queueCSSVariableUpdate("--energy-inset-spread", `${insetSpread}px`);
          this.cssController.queueCSSVariableUpdate("--energy-inset-opacity", insetOpacity.toString());
          if (burstIntensity > 0.3) {
            this.cssController.queueCSSVariableUpdate("--energy-border-opacity", burstIntensity.toString());
          } else {
            this.cssController.queueCSSVariableUpdate("--energy-border-opacity", "0");
          }
        }
        /**
         * Apply CRT interference effect
         * PERFORMANCE FIX: Use CSS variables instead of direct DOM manipulation
         * CRITICAL: Removed CSS filter (drop-shadow) - use pre-computed effects instead
         */
        applyCRTInterference(element, intensity) {
          const interferenceIntensity = this.energyBurstState.interferenceLevel * intensity;
          const interferencePhase = this.animationState.interferencePhase;
          const chromaticOffset = interferenceIntensity * 3;
          const redOffset = Math.sin(interferencePhase * 2) * chromaticOffset;
          const blueOffset = Math.cos(interferencePhase * 2.5) * chromaticOffset;
          const redOpacity = interferenceIntensity * 0.6;
          const blueOpacity = interferenceIntensity * 0.4;
          this.cssController.queueCSSVariableUpdate("--crt-red-offset", `${redOffset}px`);
          this.cssController.queueCSSVariableUpdate("--crt-blue-offset", `${blueOffset}px`);
          this.cssController.queueCSSVariableUpdate("--crt-red-opacity", redOpacity.toString());
          this.cssController.queueCSSVariableUpdate("--crt-blue-opacity", blueOpacity.toString());
          if (interferenceIntensity > 0.5) {
            const noiseOffset = Math.sin(interferencePhase * 10) * interferenceIntensity * 2;
            this.cssController.queueCSSVariableUpdate("--crt-noise-offset", `${noiseOffset}px`);
          } else {
            this.cssController.queueCSSVariableUpdate("--crt-noise-offset", "0px");
          }
        }
        /**
         * Apply cinematic scanlines
         * PERFORMANCE FIX: Use CSS variables instead of direct background manipulation
         */
        applyCinematicScanlines(element, intensity) {
          const scanlineIntensity = this.energyBurstState.burstIntensity * intensity * 0.6;
          if (scanlineIntensity > 0.1) {
            const scanlineFrequency = this.cinematicConfig.baseScanlineFrequency / 30;
            const scanlineOpacity = scanlineIntensity * 0.15;
            this.cssController.queueCSSVariableUpdate("--scanline-frequency", `${scanlineFrequency}px`);
            this.cssController.queueCSSVariableUpdate("--scanline-opacity", scanlineOpacity.toString());
            this.cssController.queueCSSVariableUpdate("--scanline-active", "1");
          } else {
            this.cssController.queueCSSVariableUpdate("--scanline-active", "0");
          }
        }
        /**
         * @deprecated Use applyCinematicScanlines instead
         * Apply dramatic scanlines
         * PERFORMANCE FIX: Use CSS variables instead of direct background manipulation
         */
        applyDramaticScanlines(element, intensity) {
          this.applyCinematicScanlines(element, intensity);
        }
        /**
         * ✅ RAF LOOP REMOVED - Managed by EnhancedMasterAnimationCoordinator
         *
         * Previous implementation: startCinematicAnimation() with independent RAF loop
         * New implementation: updateAnimation() called by coordinator
         *
         * Benefits:
         * - Single RAF loop for all systems (not 5-8 independent loops)
         * - Shared deltaTime calculation (eliminates redundant performance.now() calls)
         * - Coordinated frame budget management
         * - Priority-based execution order
         *
         * Migration: Lines 1084-1102 removed, registration added to SystemCoordinator
         */
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics(deltaTime) {
          this.performanceMetrics.averageProcessingTime = this.performanceMetrics.averageProcessingTime * 0.9 + deltaTime * 0.1;
          this.performanceMetrics.cpuUsage = Math.min(100, deltaTime / 16.67 * 100);
        }
        /**
         * Force repaint for immediate visual updates
         */
        forceRepaint(reason) {
          console.log(
            `[RedEnergyBurstSystem] Force repaint triggered: ${reason || "Unknown"}`
          );
          this.updateCinematicElements();
          this.cssController.flushCSSVariableBatch();
        }
        /**
         * Cleanup and destroy the engine
         */
        destroy() {
          console.log("[RedEnergyBurstSystem] Destroying cinematic drama engine...");
          this.cinematicElements.clear();
          this.energyBurstState = {
            burstIntensity: 0,
            burstFrequency: 0.5,
            colorTemperature: 2500,
            interferenceLevel: 0,
            scanlineVelocity: 1,
            layeredDepth: 0,
            holographicDepth: 0,
            // Legacy compatibility
            musicTension: 0,
            energyStability: 1
          };
          this.initialized = false;
        }
        // Public API methods
        getEnergyBurstState() {
          return { ...this.energyBurstState };
        }
        getCinematicConfig() {
          return { ...this.cinematicConfig };
        }
        getPerformanceMetrics() {
          return { ...this.performanceMetrics };
        }
        setRedEnergyThreshold(threshold) {
          this.cinematicConfig.energyActivationThreshold = Math.max(
            0,
            Math.min(1, threshold)
          );
        }
        setBladeRunnerMode(enabled) {
          this.cinematicConfig.bladeRunnerMode = enabled;
          if (enabled) {
            console.log("[RedEnergyBurstSystem] \u{1F3AC} Blade Runner mode activated");
          }
        }
      };
      __name(_RedEnergyBurstSystem, "RedEnergyBurstSystem");
      RedEnergyBurstSystem = _RedEnergyBurstSystem;
    }
  });

  // src-js/visual/effects/GlowEffectsController.ts
  var _MusicGlowEffectsManager, MusicGlowEffectsManager;
  var init_GlowEffectsController = __esm({
    "src-js/visual/effects/GlowEffectsController.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_ThemeUtilities();
      _MusicGlowEffectsManager = class _MusicGlowEffectsManager {
        constructor(holographicSystem, cssVisualEffectsController, musicSyncService) {
          this.initialized = false;
          this.subtleElements = /* @__PURE__ */ new Map();
          // Performance tracking
          this.performanceMetrics = {
            responsiveMomentCount: 0,
            averageProcessingTime: 0,
            lastUpdateTime: 0,
            smoothTransitionCount: 0,
            // Legacy compatibility
            get emotionalMomentCount() {
              return this.responsiveMomentCount;
            },
            set emotionalMomentCount(value) {
              this.responsiveMomentCount = value;
            },
            get gentleTransitionCount() {
              return this.smoothTransitionCount;
            },
            set gentleTransitionCount(value) {
              this.smoothTransitionCount = value;
            }
          };
          // Animation state
          this.animationState = {
            ambientPhase: 0,
            smoothPhase: 0,
            flowingPhase: 0,
            // Legacy compatibility
            get mysticalPhase() {
              return this.ambientPhase;
            },
            set mysticalPhase(value) {
              this.ambientPhase = value;
            },
            get dreamyPhase() {
              return this.smoothPhase;
            },
            set dreamyPhase(value) {
              this.smoothPhase = value;
            },
            responsivePulsePhase: 0,
            // Legacy compatibility continued
            get emotionalPulsePhase() {
              return this.responsivePulsePhase;
            },
            set emotionalPulsePhase(value) {
              this.responsivePulsePhase = value;
            },
            lastFrameTime: 0,
            isAnimating: false
          };
          // LERP smoothing half-life values (in seconds) for framerate-independent decay
          this.lerpHalfLifeValues = {
            glowIntensity: 0.25,
            // Fast emotional response
            effectLevel: 0.35,
            // Moderate beauty transitions
            shimmerEffect: 0.2
            // Quick shimmer response
          };
          // Subtle color palettes
          this.subtlePalettes = {
            "smooth-pastels": {
              primaryGlow: { r: 203, g: 166, b: 247 },
              // Catppuccin mauve (soft)
              shimmerColor: { r: 148, g: 226, b: 213 },
              // Catppuccin teal (ambient)
              mistBackground: { r: 245, g: 224, b: 220 },
              // Catppuccin rosewater
              coreColor: { r: 249, g: 226, b: 175 },
              // Catppuccin yellow (warm)
              accentColor: { r: 180, g: 190, b: 254 }
              // Catppuccin lavender
            },
            "ambient-moonlight": {
              primaryGlow: { r: 137, g: 180, b: 250 },
              // Catppuccin blue (soft)
              shimmerColor: { r: 166, g: 227, b: 161 },
              // Catppuccin green (ambient)
              mistBackground: { r: 205, g: 214, b: 244 },
              // Catppuccin text (muted)
              coreColor: { r: 243, g: 139, b: 168 },
              // Catppuccin pink (warm)
              accentColor: { r: 137, g: 220, b: 235 }
              // Catppuccin sky
            },
            "smooth-aurora": {
              primaryGlow: { r: 166, g: 227, b: 161 },
              // Catppuccin green (soft)
              shimmerColor: { r: 137, g: 220, b: 235 },
              // Catppuccin sky (ambient)
              mistBackground: { r: 186, g: 194, b: 222 },
              // Catppuccin subtext1
              coreColor: { r: 250, g: 179, b: 135 },
              // Catppuccin peach (warm)
              accentColor: { r: 203, g: 166, b: 247 }
              // Catppuccin mauve
            }
          };
          this.holographicSystem = holographicSystem;
          this.cssVisualEffectsController = cssVisualEffectsController;
          this.musicSyncService = musicSyncService;
          this.glowState = {
            glowIntensity: 0,
            effectLevel: 0,
            softness: 0.8,
            // High softness by default
            shimmerEffect: 0,
            transparency: 0.9,
            // High transparency for dreamy effect
            gradientPhase: 0,
            musicResponse: 0,
            smoothnessFactor: 1,
            // Initialize target values to current values (no animation initially)
            targetGlowIntensity: 0,
            targetEffectLevel: 0,
            targetShimmerEffect: 0
          };
          this.glowConfig = {
            musicThreshold: 0.6,
            // Activate on positive valence
            maxGlowIntensity: 0.8,
            // Gentle maximum intensity
            transitionDuration: 2e3,
            // 2 second transitions
            particleCount: 15,
            // Subtle particle count
            blurRadius: 8,
            // Soft blur radius
            gradientSpeed: 0.3
            // Slow, flowing animations
          };
        }
        // Legacy compatibility
        get etherealElements() {
          return this.subtleElements;
        }
        // Legacy compatibility
        get etherealPalettes() {
          return this.subtlePalettes;
        }
        /**
         * Initialize the Ethereal Beauty Engine
         */
        async initialize() {
          if (this.initialized) return;
          try {
            console.log("[SoftGlowEffectsManager] Initializing subtle visual effects...");
            this.subscribeToEmotionalVisualEffects();
            await this.initializeGlowElements();
            this.setupGlowCSSVariables();
            this.initialized = true;
            console.log("[SoftGlowEffectsManager] \u2728 Ready for ambient responsive moments");
          } catch (error) {
            console.error("[SoftGlowEffectsManager] Failed to initialize:", error);
            throw error;
          }
        }
        /**
         * Update animation frame for ethereal effects
         */
        updateAnimation(deltaTime) {
          if (!this.initialized) return;
          const deltaSeconds = deltaTime / 1e3;
          this.animationState.ambientPhase += deltaSeconds * 0.5;
          this.animationState.smoothPhase += deltaSeconds * 0.3;
          this.animationState.flowingPhase += deltaSeconds * this.glowConfig.gradientSpeed;
          this.animationState.responsivePulsePhase += deltaSeconds * 0.8;
          this.updateSubtleFromMusic();
          this.updateSubtleStateWithLERP(deltaSeconds);
          this.updateAmbientEffects();
          this.updateGlowElements();
          this.updatePerformanceMetrics(deltaTime);
        }
        /**
         * Health check for ethereal beauty system
         */
        async healthCheck() {
          const isHealthy = this.initialized && this.glowState.effectLevel >= 0 && this.performanceMetrics.averageProcessingTime < 8;
          return {
            system: "SoftGlowEffectsManager",
            healthy: isHealthy,
            metrics: {
              emotionalMomentCount: this.performanceMetrics.emotionalMomentCount,
              processingTime: this.performanceMetrics.averageProcessingTime,
              etherealElementCount: this.etherealElements.size,
              gentleTransitionCount: this.performanceMetrics.gentleTransitionCount
            },
            issues: isHealthy ? [] : ["Performance degradation detected"]
          };
        }
        /**
         * Subscribe to emotional visual effects events
         */
        subscribeToEmotionalVisualEffects() {
          unifiedEventBus.subscribe("music:emotional-context-updated", (event) => {
            this.onColorVisualEffectsUpdate(event);
          });
          unifiedEventBus.subscribe("music:emotion-analyzed", (event) => {
            this.onEmotionalMoment(event);
          });
          unifiedEventBus.subscribe("settings:visual-guide-changed", (event) => {
            this.onGentleTransition(event);
          });
        }
        /**
         * Handle color visual effects updates
         */
        onColorVisualEffectsUpdate(event) {
          const { palette, visualEffectsLevel, emotionalTemperature } = event;
          this.glowState.musicResponse = visualEffectsLevel * 0.9;
          if (emotionalTemperature > 5e3) {
            this.glowState.effectLevel = Math.min(0.8, visualEffectsLevel * 1.2);
          } else {
            this.glowState.shimmerEffect = visualEffectsLevel * 0.7;
          }
          const glowColors = this.generateGlowColors(palette, emotionalTemperature);
          this.updateGlowColors(glowColors);
        }
        /**
         * Handle emotional musical moments
         */
        onEmotionalMoment(event) {
          const { type, intensity, valence } = event;
          if (valence > this.glowConfig.musicThreshold) {
            this.triggerSubtleEffect(intensity, valence);
          }
        }
        /**
         * Handle gentle transitions
         */
        onGentleTransition(event) {
          const { fromState, toState, duration } = event;
          this.createGentleTransition(fromState, toState, duration);
          this.performanceMetrics.gentleTransitionCount++;
        }
        /**
         * Trigger subtle effect
         */
        triggerSubtleEffect(intensity, valence) {
          const startTime = performance.now();
          this.glowState.transparency = 0.8 + valence * 0.2;
          this.glowState.targetGlowIntensity = Math.max(
            this.glowState.targetGlowIntensity,
            intensity * 0.8
          );
          this.glowState.targetEffectLevel = Math.max(
            this.glowState.targetEffectLevel,
            valence * 0.9
          );
          this.glowState.targetShimmerEffect = Math.max(
            this.glowState.targetShimmerEffect,
            valence * 0.6
          );
          this.performanceMetrics.emotionalMomentCount++;
          this.performanceMetrics.lastUpdateTime = performance.now() - startTime;
          console.log(`[SoftGlowEffectsManager] \u2728 Ethereal beauty awakened! Intensity: ${intensity.toFixed(2)}, Valence: ${valence.toFixed(2)}`);
        }
        /**
         * Update subtle state with LERP smoothing towards target values
         * This replaces the old frame-rate dependent decay system
         */
        updateSubtleStateWithLERP(deltaTimeSeconds) {
          this.glowState.glowIntensity = lerpSmooth(
            this.glowState.glowIntensity,
            this.glowState.targetGlowIntensity,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.glowIntensity
          );
          this.glowState.effectLevel = lerpSmooth(
            this.glowState.effectLevel,
            this.glowState.targetEffectLevel,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.effectLevel
          );
          this.glowState.shimmerEffect = lerpSmooth(
            this.glowState.shimmerEffect,
            this.glowState.targetShimmerEffect,
            deltaTimeSeconds,
            this.lerpHalfLifeValues.shimmerEffect
          );
          const autoDecayHalfLife = 1.5;
          this.glowState.targetGlowIntensity = lerpSmooth(
            this.glowState.targetGlowIntensity,
            0,
            // Decay towards zero
            deltaTimeSeconds,
            autoDecayHalfLife
          );
          this.glowState.targetEffectLevel = lerpSmooth(
            this.glowState.targetEffectLevel,
            0,
            // Decay towards zero
            deltaTimeSeconds,
            autoDecayHalfLife * 1.2
            // Slower decay for beauty
          );
          this.glowState.targetShimmerEffect = lerpSmooth(
            this.glowState.targetShimmerEffect,
            0,
            // Decay towards zero
            deltaTimeSeconds,
            autoDecayHalfLife * 0.8
            // Faster decay for shimmer
          );
        }
        /**
         * Update subtle state from current music
         */
        updateSubtleFromMusic() {
          const musicState = this.musicSyncService.getCurrentMusicState();
          if (!musicState) return;
          const { emotion, beat, intensity } = musicState;
          if (emotion && emotion.valence > 0.5) {
            this.glowState.shimmerEffect = Math.max(
              this.glowState.shimmerEffect,
              emotion.valence * intensity * 0.5
            );
            if (beat && beat.tempo) {
              const tempoMultiplier = Math.min(1.5, beat.tempo / 100);
              this.glowConfig.gradientSpeed = 0.3 * tempoMultiplier;
            }
          }
        }
        /**
         * Update ambient effects
         */
        updateAmbientEffects() {
          const palette = this.etherealPalettes["smooth-pastels"];
          const mapping = {
            primaryGlow: this.blendSoftColors(
              palette.primaryGlow,
              palette.shimmerColor,
              this.glowState.shimmerEffect
            ),
            shimmerColor: palette.shimmerColor,
            mistBackground: palette.mistBackground,
            coreColor: palette.coreColor,
            accentColor: palette.accentColor,
            transparency: this.glowState.transparency
          };
          this.updateGlowCSSVariables(mapping);
        }
        /**
         * Blend soft colors for ethereal effects
         */
        blendSoftColors(soft, ambient, blendFactor) {
          const factor = Math.max(0, Math.min(1, blendFactor));
          return {
            r: Math.round(soft.r * (1 - factor) + ambient.r * factor),
            g: Math.round(soft.g * (1 - factor) + ambient.g * factor),
            b: Math.round(soft.b * (1 - factor) + ambient.b * factor)
          };
        }
        /**
         * Generate ethereal colors from visual effects palette
         */
        generateGlowColors(palette, emotionalTemperature) {
          let selectedPalette = this.etherealPalettes["smooth-pastels"];
          if (emotionalTemperature < 4e3) {
            selectedPalette = this.etherealPalettes["ambient-moonlight"];
          } else if (emotionalTemperature > 7e3) {
            selectedPalette = this.etherealPalettes["smooth-aurora"];
          }
          return {
            primaryGlow: selectedPalette.primaryGlow,
            shimmerColor: selectedPalette.shimmerColor,
            mistBackground: selectedPalette.mistBackground,
            coreColor: selectedPalette.coreColor,
            accentColor: selectedPalette.accentColor,
            transparency: this.glowState.transparency
          };
        }
        /**
         * Update ethereal colors in CSS
         */
        updateGlowColors(mapping) {
          this.cssVisualEffectsController.queueCSSVariableUpdate(
            "--subtle-soft-r",
            mapping.primaryGlow.r.toString()
          );
          this.cssVisualEffectsController.queueCSSVariableUpdate(
            "--subtle-soft-g",
            mapping.primaryGlow.g.toString()
          );
          this.cssVisualEffectsController.queueCSSVariableUpdate(
            "--subtle-soft-b",
            mapping.primaryGlow.b.toString()
          );
          this.cssVisualEffectsController.queueCSSVariableUpdate(
            "--subtle-ambient-r",
            mapping.shimmerColor.r.toString()
          );
          this.cssVisualEffectsController.queueCSSVariableUpdate(
            "--subtle-ambient-g",
            mapping.shimmerColor.g.toString()
          );
          this.cssVisualEffectsController.queueCSSVariableUpdate(
            "--subtle-ambient-b",
            mapping.shimmerColor.b.toString()
          );
        }
        /**
         * Initialize ethereal UI elements
         */
        async initializeGlowElements() {
          const etherealSelectors = [
            ".main-view-container",
            ".Root__now-playing-bar",
            ".main-trackInfo-container",
            ".cover-art",
            ".player-controls"
          ];
          for (const selector of etherealSelectors) {
            const elements = document.querySelectorAll(selector);
            for (const element of elements) {
              const id = `ethereal-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
              this.etherealElements.set(id, element);
            }
          }
        }
        /**
         * Setup CSS variables for ethereal effects
         */
        setupGlowCSSVariables() {
          const baseVariables = {
            "--subtle-soft-r": "203",
            "--subtle-soft-g": "166",
            "--subtle-soft-b": "247",
            "--subtle-ambient-r": "148",
            "--subtle-ambient-g": "226",
            "--subtle-ambient-b": "213",
            "--subtle-smooth-r": "245",
            "--subtle-smooth-g": "224",
            "--subtle-smooth-b": "220",
            "--subtle-effect-level": "0",
            "--subtle-ambient-shimmer": "0",
            "--subtle-smooth-transparency": "0.9",
            "--subtle-flowing-phase": "0",
            "--subtle-responsive-pulse": "0"
          };
          for (const [variable, value] of Object.entries(baseVariables)) {
            this.cssVisualEffectsController.queueCSSVariableUpdate(variable, value);
          }
        }
        /**
         * Update ethereal CSS variables
         */
        updateGlowCSSVariables(mapping) {
          this.cssVisualEffectsController.queueCSSVariableUpdate(
            "--subtle-effect-level",
            this.glowState.effectLevel.toString()
          );
          this.cssVisualEffectsController.queueCSSVariableUpdate(
            "--subtle-ambient-shimmer",
            this.glowState.shimmerEffect.toString()
          );
          this.cssVisualEffectsController.queueCSSVariableUpdate(
            "--subtle-smooth-transparency",
            mapping.transparency.toString()
          );
          this.cssVisualEffectsController.queueCSSVariableUpdate(
            "--subtle-flowing-phase",
            this.animationState.flowingPhase.toString()
          );
          this.cssVisualEffectsController.queueCSSVariableUpdate(
            "--subtle-responsive-pulse",
            Math.sin(this.animationState.responsivePulsePhase).toString()
          );
        }
        /**
         * Update ethereal elements
         */
        updateGlowElements() {
          for (const [id, element] of this.etherealElements) {
            this.updateEtherealElement(element);
          }
        }
        /**
         * Update single ethereal element
         */
        updateEtherealElement(element) {
          if (this.glowState.effectLevel > 0.1) {
            this.applySubtleEffect(element);
          }
          if (this.glowState.shimmerEffect > 0.1) {
            this.applyAmbientShimmer(element);
          }
          this.applyFlowingGradients(element);
        }
        /**
         * Apply subtle effect to element
         * PERFORMANCE FIX: Use CSS variables instead of direct DOM manipulation
         */
        applySubtleEffect(element) {
          const effectIntensity = this.glowState.effectLevel;
          const responsivePulse = Math.sin(this.animationState.responsivePulsePhase) * 0.5 + 0.5;
          const glowIntensity = effectIntensity * responsivePulse * 0.6;
          const glowSpread = glowIntensity * 30;
          const glowOpacity = glowIntensity * 0.6;
          const insetSpread = glowIntensity * 20;
          const insetOpacity = glowIntensity * 0.3;
          const transparency = 0.9 + effectIntensity * 0.1;
          this.cssVisualEffectsController.queueCSSVariableUpdate("--subtle-glow-spread", `${glowSpread}px`);
          this.cssVisualEffectsController.queueCSSVariableUpdate("--subtle-glow-opacity", glowOpacity.toString());
          this.cssVisualEffectsController.queueCSSVariableUpdate("--subtle-inset-spread", `${insetSpread}px`);
          this.cssVisualEffectsController.queueCSSVariableUpdate("--subtle-inset-opacity", insetOpacity.toString());
          this.cssVisualEffectsController.queueCSSVariableUpdate("--subtle-transparency", transparency.toString());
        }
        /**
         * Apply ambient shimmer effect
         * 🎨 PHASE 2 OPTIMIZATION: Use pre-computed color variations instead of runtime filters
         *
         * Performance improvement: ~8-12ms per frame by eliminating hue-rotate and saturate filters
         * ColorHarmonyEngine pre-computes 16 shimmer variants on track change covering:
         * - Hue range: -15° to +15°
         * - Saturation range: 0.7x to 1.3x
         */
        applyAmbientShimmer(element) {
          const shimmerIntensity = this.glowState.shimmerEffect;
          const ambientPhase = this.animationState.ambientPhase;
          const shimmerOffset = Math.sin(ambientPhase * 2) * shimmerIntensity * 2;
          const shimmerScale = 1 + Math.cos(ambientPhase * 1.5) * shimmerIntensity * 0.05;
          const phaseNormalized = ambientPhase * 0.8 / (Math.PI * 2);
          const variantIndex = Math.floor((phaseNormalized % 1 + 1) % 1 * 16);
          this.cssVisualEffectsController.queueCSSVariableUpdate("--shimmer-translate-x", `${shimmerOffset}px`);
          this.cssVisualEffectsController.queueCSSVariableUpdate("--shimmer-scale", shimmerScale.toString());
          const variantColorVar = `var(--sn-shimmer-variant-${variantIndex}-rgb)`;
          this.cssVisualEffectsController.queueCSSVariableUpdate("--shimmer-color-rgb", variantColorVar);
        }
        /**
         * Apply flowing gradients
         * PERFORMANCE FIX: Set inline styles using CSS variables for efficient updates
         */
        applyFlowingGradients(element) {
          const flowingPhase = this.animationState.flowingPhase;
          const flowIntensity = this.glowState.effectLevel * 0.8;
          if (flowIntensity > 0.1) {
            const gradientPosition = (Math.sin(flowingPhase) + 1) * 50;
            this.cssVisualEffectsController.queueCSSVariableUpdate(
              "--flowing-gradient-position",
              `${gradientPosition}deg`
            );
            this.cssVisualEffectsController.queueCSSVariableUpdate(
              "--flowing-gradient-intensity",
              flowIntensity.toString()
            );
            if (!element.dataset.flowingGradientInit) {
              const currentBg = element.style.background || "";
              element.style.background = `
          ${currentBg},
          linear-gradient(
            var(--flowing-gradient-position, 0deg),
            rgba(var(--subtle-soft-r), var(--subtle-soft-g), var(--subtle-soft-b), calc(var(--flowing-gradient-intensity, 0) * 0.1)) 0%,
            rgba(var(--subtle-ambient-r), var(--subtle-ambient-g), var(--subtle-ambient-b), calc(var(--flowing-gradient-intensity, 0) * 0.15)) 50%,
            rgba(var(--subtle-smooth-r), var(--subtle-smooth-g), var(--subtle-smooth-b), calc(var(--flowing-gradient-intensity, 0) * 0.05)) 100%
          )
        `;
              element.dataset.flowingGradientInit = "true";
            }
          }
        }
        /**
         * Create gentle transition between states
         */
        createGentleTransition(fromState, toState, duration) {
          const startTime = performance.now();
          const transition = /* @__PURE__ */ __name((currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(1, elapsed / duration);
            const eased = 1 - Math.pow(1 - progress, 3);
            this.glowState.effectLevel = fromState.beauty + (toState.beauty - fromState.beauty) * eased;
            this.glowState.shimmerEffect = fromState.shimmer + (toState.shimmer - fromState.shimmer) * eased;
            if (progress < 1) {
              requestAnimationFrame(transition);
            }
          }, "transition");
          requestAnimationFrame(transition);
        }
        /**
         * ✅ RAF LOOP REMOVED - Managed by EnhancedMasterAnimationCoordinator
         *
         * Previous implementation: startEtherealAnimation() with independent RAF loop
         * New implementation: updateAnimation() called by coordinator
         *
         * Benefits:
         * - Single RAF loop for all systems (not 5-8 independent loops)
         * - Shared deltaTime calculation (eliminates redundant performance.now() calls)
         * - Coordinated frame budget management
         * - Priority-based execution order
         *
         * Migration: Lines 725-743 removed, registration added to SystemCoordinator
         */
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics(deltaTime) {
          this.performanceMetrics.averageProcessingTime = this.performanceMetrics.averageProcessingTime * 0.9 + deltaTime * 0.1;
        }
        /**
         * Force repaint for immediate visual updates
         */
        forceRepaint(reason) {
          console.log(`[SoftGlowEffectsManager] Force repaint triggered: ${reason || "Unknown"}`);
          this.updateGlowElements();
          this.cssVisualEffectsController.flushCSSVariableBatch();
        }
        /**
         * Cleanup and destroy the engine
         */
        destroy() {
          console.log("[SoftGlowEffectsManager] Dissolving ethereal beauty...");
          this.etherealElements.clear();
          this.glowState = {
            glowIntensity: 0,
            effectLevel: 0,
            softness: 0.8,
            shimmerEffect: 0,
            transparency: 0.9,
            gradientPhase: 0,
            musicResponse: 0,
            smoothnessFactor: 1,
            // Reset target values too
            targetGlowIntensity: 0,
            targetEffectLevel: 0,
            targetShimmerEffect: 0
          };
          this.initialized = false;
        }
        // Public API methods
        getGlowState() {
          return { ...this.glowState };
        }
        getGlowConfig() {
          return { ...this.glowConfig };
        }
        getPerformanceMetrics() {
          return {
            ...this.performanceMetrics,
            etherealElementCount: this.etherealElements.size
          };
        }
        setEmotionalThreshold(threshold) {
          this.glowConfig.musicThreshold = Math.max(0, Math.min(1, threshold));
        }
        setMaxBeautyIntensity(intensity) {
          this.glowConfig.maxGlowIntensity = Math.max(0, Math.min(1, intensity));
        }
        setGentleness(softness) {
          this.glowState.softness = Math.max(0, Math.min(1, softness));
        }
      };
      __name(_MusicGlowEffectsManager, "MusicGlowEffectsManager");
      MusicGlowEffectsManager = _MusicGlowEffectsManager;
    }
  });

  // src-js/visual/effects/AnimationEffectsController.ts
  var _AnimationEffectsController, AnimationEffectsController;
  var init_AnimationEffectsController = __esm({
    "src-js/visual/effects/AnimationEffectsController.ts"() {
      "use strict";
      init_UnifiedEventBus();
      _AnimationEffectsController = class _AnimationEffectsController {
        constructor(holographicSystem, cssController, musicSyncService) {
          this.initialized = false;
          this.naturalElements = /* @__PURE__ */ new Map();
          // Performance tracking
          this.performanceMetrics = {
            peacefulMomentCount: 0,
            averageProcessingTime: 0,
            lastUpdateTime: 0,
            animationCycleCount: 0
          };
          // Animation phase state
          this.animationPhases = {
            animationPhase: 0,
            // Main animation cycle phase
            seasonalPhase: 0,
            // Seasonal transition phase
            variationPhase: 0,
            // Animation variation phase
            harmonyPhase: 0
            // Natural harmony phase
          };
          // Natural color palettes for different seasons/moods
          this.naturalPalettes = {
            "spring-awakening": {
              earthyWarm: { r: 166, g: 227, b: 161 },
              // Catppuccin green (spring)
              forestGreen: { r: 64, g: 160, b: 43 },
              // Deep forest green
              skyBlue: { r: 137, g: 220, b: 235 },
              // Catppuccin sky
              sunsetGlow: { r: 250, g: 179, b: 135 },
              // Catppuccin peach
              stoneGray: { r: 108, g: 112, b: 134 }
              // Catppuccin overlay0
            },
            "summer-warmth": {
              earthyWarm: { r: 249, g: 226, b: 175 },
              // Catppuccin yellow (warm)
              forestGreen: { r: 166, g: 227, b: 161 },
              // Catppuccin green
              skyBlue: { r: 116, g: 199, b: 236 },
              // Catppuccin sapphire
              sunsetGlow: { r: 250, g: 179, b: 135 },
              // Catppuccin peach
              stoneGray: { r: 147, g: 153, b: 178 }
              // Catppuccin overlay2
            },
            "autumn-grounding": {
              earthyWarm: { r: 250, g: 179, b: 135 },
              // Catppuccin peach (autumn)
              forestGreen: { r: 148, g: 226, b: 213 },
              // Catppuccin teal
              skyBlue: { r: 137, g: 180, b: 250 },
              // Catppuccin blue
              sunsetGlow: { r: 235, g: 160, b: 172 },
              // Catppuccin flamingo
              stoneGray: { r: 127, g: 132, b: 156 }
              // Catppuccin overlay1
            },
            "winter-peace": {
              earthyWarm: { r: 186, g: 194, b: 222 },
              // Catppuccin subtext1 (cool)
              forestGreen: { r: 148, g: 226, b: 213 },
              // Catppuccin teal
              skyBlue: { r: 137, g: 220, b: 235 },
              // Catppuccin sky
              sunsetGlow: { r: 203, g: 166, b: 247 },
              // Catppuccin mauve
              stoneGray: { r: 88, g: 91, b: 112 }
              // Catppuccin surface2
            }
          };
          this.holographicSystem = holographicSystem;
          this.cssController = cssController;
          this.musicSyncService = musicSyncService;
          this.effectState = {
            animationIntensity: 0,
            animationFrequency: 0.4,
            // Natural resting frequency (0.4Hz = 24 breaths/min)
            animationDepth: 0.8,
            // Deep, natural animation
            grounding: 0,
            warmth: 0.7,
            // Warm, grounded feeling
            ambientLevel: 0,
            colorShift: 0,
            harmonyLevel: 0
          };
          this.harmonyConfig = {
            calmThreshold: 0.3,
            // Activate on low intensity (peaceful music)
            maxBreathingDepth: 0.9,
            // Deep natural animation
            frequencyRange: [0.2, 0.8],
            // 0.2Hz (12 bpm) to 0.8Hz (48 bpm)
            colorStrength: 0.6,
            // Moderate color influence
            transitionDuration: 3e3,
            // 3-second transitions
            cycleSpeed: 0.1
            // Slow animation cycles
          };
        }
        // =============================================================================
        // SERVICE INJECTION INTERFACE
        // =============================================================================
        injectServices(services) {
          this.services = services;
        }
        getRequiredServices() {
          return [];
        }
        getOptionalServices() {
          return ["cssVariables", "events", "performance"];
        }
        /**
         * Initialize the animation effects system
         * 
         * Sets up event subscriptions, animation elements detection, CSS variables,
         * and starts the animation loop for animation effects.
         * 
         * @returns Promise<void> Resolves when initialization completes
         * @throws Error if system fails to initialize
         * @public IManagedSystem lifecycle method
         */
        async initialize() {
          if (this.initialized) return;
          try {
            console.log("[AnimationEffectsController] Initializing animation effects...");
            this.subscribeToColorEvents();
            await this.initializeBreathingElements();
            this.setupBreathingCSSVariables();
            this.initialized = true;
            console.log("[AnimationEffectsController] \u{1F33F} Breathing effects system ready");
          } catch (error) {
            console.error("[AnimationEffectsController] Failed to initialize:", error);
            throw error;
          }
        }
        /**
         * Update animation effects for current animation frame
         * 
         * Processes animation animation phases, updates visual state from music analysis,
         * and applies animation effects to DOM elements.
         * 
         * @param deltaTime - Time elapsed since last frame in milliseconds  
         * @public IManagedSystem animation interface
         */
        updateAnimation(deltaTime) {
          if (!this.initialized) return;
          const deltaSeconds = deltaTime / 1e3;
          this.animationPhases.animationPhase += deltaSeconds * this.effectState.animationFrequency * 2 * Math.PI;
          this.animationPhases.seasonalPhase += deltaSeconds * this.harmonyConfig.cycleSpeed;
          this.animationPhases.variationPhase += deltaSeconds * 0.4;
          this.animationPhases.harmonyPhase += deltaSeconds * 0.6;
          this.updateNaturalFromMusic();
          this.updateBreathingVisuals();
          this.updateBreathingElements();
          this.updatePerformanceMetrics(deltaTime);
        }
        /**
         * Perform system health check for animation effects
         * 
         * Validates initialization status, animation intensity levels, and performance metrics
         * to ensure the animation effects system is operating within acceptable parameters.
         * 
         * @returns Promise<HealthCheckResult> System health status and metrics
         * @public IManagedSystem monitoring interface
         */
        async healthCheck() {
          const isHealthy = this.initialized && this.effectState.animationIntensity >= 0 && this.performanceMetrics.averageProcessingTime < 10;
          return {
            system: "NaturalHarmonyEngine",
            healthy: isHealthy,
            metrics: {
              peacefulMomentCount: this.performanceMetrics.peacefulMomentCount,
              processingTime: this.performanceMetrics.averageProcessingTime,
              naturalElementCount: this.naturalElements.size,
              animationCycleCount: this.performanceMetrics.animationCycleCount
            },
            issues: isHealthy ? [] : ["Performance degradation detected"]
          };
        }
        /**
         * Subscribe to color coordination events
         */
        subscribeToColorEvents() {
          if (this.services?.events) {
            this.services.events.subscribe(
              "AnimationEffectsController",
              "music:emotional-context-updated",
              this.onColorUpdate.bind(this)
            );
            this.services.events.subscribe(
              "AnimationEffectsController",
              "music:emotion-analyzed",
              this.onPeacefulMoment.bind(this)
            );
            this.services.events.subscribe(
              "AnimationEffectsController",
              "settings:visual-guide-changed",
              this.onVisualTransition.bind(this)
            );
          } else {
            unifiedEventBus.subscribe("music:emotional-context-updated", (event) => {
              this.onColorUpdate(event);
            });
            unifiedEventBus.subscribe("music:emotion-analyzed", (event) => {
              this.onPeacefulMoment(event);
            });
            unifiedEventBus.subscribe("settings:visual-guide-changed", (event) => {
              this.onVisualTransition(event);
            });
          }
        }
        /**
         * Handle color coordination updates
         */
        onColorUpdate(event) {
          const { palette, effectsLevel, emotionalTemperature } = event;
          this.effectState.harmonyLevel = effectsLevel * 0.8;
          if (emotionalTemperature < 5e3) {
            this.effectState.grounding = effectsLevel * 0.6;
            this.effectState.ambientLevel = effectsLevel * 0.4;
          } else {
            this.effectState.warmth = effectsLevel * 0.8;
            this.effectState.colorShift = effectsLevel * 0.5;
          }
          const naturalColors = this.generateBreathingColors(palette, emotionalTemperature);
          this.updateNaturalColors(naturalColors);
        }
        /**
         * Handle peaceful musical moments
         */
        onPeacefulMoment(event) {
          const { type, intensity, serenity } = event;
          this.triggerNaturalBreathing(intensity, serenity);
        }
        /**
         * Handle visual transitions
         */
        onVisualTransition(event) {
          const { fromSeason, toSeason, duration } = event;
          this.createSeasonalTransition(fromSeason, toSeason, duration);
          this.performanceMetrics.animationCycleCount++;
        }
        /**
         * Trigger natural harmony animation effect
         */
        triggerNaturalBreathing(intensity, serenity) {
          const performTrackedOperation = this.services?.performance ? (name, operation) => this.services.performance.trackOperation("AnimationEffectsController", name, operation) : (name, operation) => operation();
          performTrackedOperation("triggerNaturalBreathing", () => {
            this.effectState.animationIntensity = serenity;
            this.effectState.grounding = serenity * 0.7;
            this.effectState.ambientLevel = serenity * 0.6;
            this.effectState.warmth = 0.6 + serenity * 0.3;
            const naturalFreq = this.harmonyConfig.frequencyRange;
            this.effectState.animationFrequency = naturalFreq[0] + serenity * (naturalFreq[1] - naturalFreq[0]);
            setTimeout(() => {
              this.gentleDecayNaturalBreathing();
            }, this.harmonyConfig.transitionDuration);
            this.performanceMetrics.peacefulMomentCount++;
            console.log(`[AnimationEffectsController] \u{1F33F} Breathing effects activated! Serenity: ${serenity.toFixed(2)}, Frequency: ${this.effectState.animationFrequency.toFixed(2)}Hz`);
          });
        }
        /**
         * Gentle decay of natural animation over time
         */
        gentleDecayNaturalBreathing() {
          const decayRate = 0.015;
          const decay = /* @__PURE__ */ __name(() => {
            this.effectState.animationIntensity *= 1 - decayRate;
            this.effectState.grounding *= 1 - decayRate * 0.8;
            this.effectState.ambientLevel *= 1 - decayRate * 0.6;
            if (this.effectState.animationIntensity > 0.05) {
              requestAnimationFrame(decay);
            } else {
              this.effectState.animationIntensity = 0;
              this.effectState.grounding = 0;
              this.effectState.ambientLevel = 0;
            }
          }, "decay");
          requestAnimationFrame(decay);
        }
        /**
         * Update natural state from current music
         */
        updateNaturalFromMusic() {
          const musicState = this.musicSyncService.getCurrentMusicState();
          if (!musicState) return;
          const { emotion, beat, intensity } = musicState;
          if (emotion && intensity < this.harmonyConfig.calmThreshold) {
            this.effectState.ambientLevel = Math.max(
              this.effectState.ambientLevel,
              (1 - intensity) * 0.6
              // Higher atmosphere for lower intensity
            );
            if (beat && beat.tempo) {
              const tempoMultiplier = Math.max(0.5, Math.min(1.2, 60 / beat.tempo));
              this.effectState.animationFrequency = 0.4 * tempoMultiplier;
            }
          }
        }
        /**
         * Update animation visual effects
         */
        updateBreathingVisuals() {
          const currentSeason = this.getCurrentSeason();
          const palette = this.naturalPalettes[currentSeason];
          const mapping = {
            warmTone: this.blendBreathingColors(
              palette.earthyWarm,
              palette.sunsetGlow,
              this.effectState.warmth
            ),
            coolTone: palette.forestGreen,
            accentBlue: palette.skyBlue,
            highlightGlow: palette.sunsetGlow,
            neutralGray: palette.stoneGray,
            transparency: 0.85 + this.effectState.animationIntensity * 0.15
          };
          this.updateNaturalCSSVariables(mapping);
        }
        /**
         * Get current season based on seasonal phase
         */
        getCurrentSeason() {
          const seasonPhase = this.animationPhases.seasonalPhase % (2 * Math.PI);
          const normalizedPhase = seasonPhase / (2 * Math.PI);
          if (normalizedPhase < 0.25) return "spring-awakening";
          if (normalizedPhase < 0.5) return "summer-warmth";
          if (normalizedPhase < 0.75) return "autumn-grounding";
          return "winter-peace";
        }
        /**
         * Blend natural colors for animation effects
         */
        blendBreathingColors(natural, warm, blendFactor) {
          const factor = Math.max(0, Math.min(1, blendFactor));
          return {
            r: Math.round(natural.r * (1 - factor) + warm.r * factor),
            g: Math.round(natural.g * (1 - factor) + warm.g * factor),
            b: Math.round(natural.b * (1 - factor) + warm.b * factor)
          };
        }
        /**
         * Generate natural colors from coordination palette
         */
        generateBreathingColors(palette, emotionalTemperature) {
          let selectedPalette = this.naturalPalettes["spring-awakening"];
          if (emotionalTemperature < 4e3) {
            selectedPalette = this.naturalPalettes["winter-peace"];
          } else if (emotionalTemperature > 7e3) {
            selectedPalette = this.naturalPalettes["summer-warmth"];
          } else if (emotionalTemperature > 5500) {
            selectedPalette = this.naturalPalettes["autumn-grounding"];
          }
          return {
            warmTone: selectedPalette.earthyWarm,
            coolTone: selectedPalette.forestGreen,
            accentBlue: selectedPalette.skyBlue,
            highlightGlow: selectedPalette.sunsetGlow,
            neutralGray: selectedPalette.stoneGray,
            transparency: this.effectState.harmonyLevel
          };
        }
        /**
         * Update natural colors in CSS
         */
        updateNaturalColors(mapping) {
          if (this.services?.cssVariables) {
            this.services.cssVariables.queueBatchUpdate({
              "--sn-animation-warm-r": mapping.warmTone.r.toString(),
              "--sn-animation-warm-g": mapping.warmTone.g.toString(),
              "--sn-animation-warm-b": mapping.warmTone.b.toString(),
              "--sn-animation-cool-r": mapping.coolTone.r.toString(),
              "--sn-animation-cool-g": mapping.coolTone.g.toString(),
              "--sn-animation-cool-b": mapping.coolTone.b.toString()
            });
          } else {
            this.cssController.queueCSSVariableUpdate(
              "--sn-animation-warm-r",
              mapping.warmTone.r.toString()
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-animation-warm-g",
              mapping.warmTone.g.toString()
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-animation-warm-b",
              mapping.warmTone.b.toString()
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-animation-cool-r",
              mapping.coolTone.r.toString()
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-animation-cool-g",
              mapping.coolTone.g.toString()
            );
            this.cssController.queueCSSVariableUpdate(
              "--sn-animation-cool-b",
              mapping.coolTone.b.toString()
            );
          }
        }
        /**
         * Initialize animation effect elements
         */
        async initializeBreathingElements() {
          const naturalSelectors = [
            ".main-view-container",
            ".Root__now-playing-bar",
            ".main-trackInfo-container",
            ".progress-bar",
            ".Root__nav-bar"
          ];
          for (const selector of naturalSelectors) {
            const elements = document.querySelectorAll(selector);
            for (const element of elements) {
              const id = `natural-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
              this.naturalElements.set(id, element);
            }
          }
        }
        /**
         * Setup CSS variables for animation effects
         */
        setupBreathingCSSVariables() {
          const baseVariables = {
            "--sn-animation-earthy-r": "166",
            "--sn-animation-earthy-g": "227",
            "--sn-animation-earthy-b": "161",
            "--sn-animation-forest-r": "64",
            "--sn-animation-forest-g": "160",
            "--sn-animation-forest-b": "43",
            "--sn-animation-sky-r": "137",
            "--sn-animation-sky-g": "220",
            "--sn-animation-sky-b": "235",
            "--sn-animation-serenity-level": "0",
            "--sn-animation-animation-frequency": "0.4",
            "--sn-animation-earth-connection": "0",
            "--sn-animation-animation-depth": "0.8",
            "--sn-animation-seasonal-shift": "0"
          };
          if (this.services?.cssVariables) {
            this.services.cssVariables.queueBatchUpdate(baseVariables);
          } else {
            for (const [variable, value] of Object.entries(baseVariables)) {
              this.cssController.queueCSSVariableUpdate(variable, value);
            }
          }
        }
        /**
         * Update natural CSS variables
         */
        updateNaturalCSSVariables(mapping) {
          const animationValue = Math.sin(this.animationPhases.animationPhase) * this.effectState.animationDepth;
          const cssUpdates = {
            "--sn-animation-animation-intensity": this.effectState.animationIntensity.toString(),
            "--sn-animation-animation-frequency": this.effectState.animationFrequency.toString(),
            "--sn-animation-grounding": this.effectState.grounding.toString(),
            "--sn-animation-animation-depth": this.effectState.animationDepth.toString(),
            "--sn-animation-color-shift": this.effectState.colorShift.toString(),
            "--sn-animation-animation-phase": animationValue.toString()
          };
          if (this.services?.cssVariables) {
            this.services.cssVariables.queueBatchUpdate(cssUpdates);
          } else {
            Object.entries(cssUpdates).forEach(([variable, value]) => {
              this.cssController.queueCSSVariableUpdate(variable, value);
            });
          }
        }
        /**
         * Update natural elements
         */
        updateBreathingElements() {
          for (const [id, element] of this.naturalElements) {
            this.updateNaturalElement(element);
          }
        }
        /**
         * Update single natural element
         */
        updateNaturalElement(element) {
          if (this.effectState.animationIntensity > 0.1) {
            this.applyNaturalBreathing(element);
          }
          if (this.effectState.grounding > 0.1) {
            this.applyEarthConnection(element);
          }
          if (this.effectState.ambientLevel > 0.1) {
            this.applyForestAtmosphere(element);
          }
        }
        /**
         * Apply natural animation effect to element
         * PERFORMANCE FIX: Use CSS variables instead of direct DOM manipulation
         */
        applyNaturalBreathing(element) {
          const animationIntensity = this.effectState.animationIntensity;
          const animationPhase = Math.sin(this.animationPhases.animationPhase);
          const animationScale = 1 + animationPhase * animationIntensity * 0.02;
          const animationOpacity = 0.9 + animationPhase * animationIntensity * 0.1;
          const glowIntensity = animationIntensity * (animationPhase * 0.5 + 0.5) * 0.3;
          const glowSpread = glowIntensity * 20;
          const glowOpacity = glowIntensity * 0.5;
          const insetGlowSpread = glowIntensity * 10;
          const insetGlowOpacity = glowIntensity * 0.3;
          const breathingVars = {
            "--sn-breathing-scale": animationScale.toString(),
            "--sn-breathing-opacity": animationOpacity.toString(),
            "--sn-breathing-glow-spread": `${glowSpread}px`,
            "--sn-breathing-glow-opacity": glowOpacity.toString(),
            "--sn-breathing-inset-spread": `${insetGlowSpread}px`,
            "--sn-breathing-inset-opacity": insetGlowOpacity.toString()
          };
          if (this.services?.cssVariables) {
            this.services.cssVariables.queueBatchUpdate(breathingVars);
          } else {
            Object.entries(breathingVars).forEach(([key, value]) => {
              this.cssController.queueCSSVariableUpdate(key, value);
            });
          }
        }
        /**
         * Apply earth connection effect
         * PERFORMANCE FIX: Use CSS variables instead of direct DOM manipulation
         */
        applyEarthConnection(element) {
          const connectionIntensity = this.effectState.grounding;
          const borderOpacity = connectionIntensity * 0.4;
          const bgTopOpacity = connectionIntensity * 0.05;
          const bgBottomOpacity = connectionIntensity * 0.08;
          const earthVars = {
            "--sn-earth-border-opacity": borderOpacity.toString(),
            "--sn-earth-bg-top-opacity": bgTopOpacity.toString(),
            "--sn-earth-bg-bottom-opacity": bgBottomOpacity.toString()
          };
          if (this.services?.cssVariables) {
            this.services.cssVariables.queueBatchUpdate(earthVars);
          } else {
            Object.entries(earthVars).forEach(([key, value]) => {
              this.cssController.queueCSSVariableUpdate(key, value);
            });
          }
        }
        /**
         * Apply forest atmosphere effect
         * 🎨 PHASE 2 OPTIMIZATION: Use pre-computed color variations instead of runtime filters
         *
         * Performance improvement: ~7-10ms per frame by eliminating hue-rotate and saturate filters
         * ColorHarmonyEngine pre-computes 8 atmosphere variants on track change covering:
         * - Hue range: -5° to +5° (subtle variations)
         * - Saturation: 0.85x (slightly desaturated for atmosphere)
         */
        applyForestAtmosphere(element) {
          const atmosphereIntensity = this.effectState.ambientLevel;
          const variationPhase = this.animationPhases.variationPhase;
          const animationOffset = Math.sin(variationPhase * 0.8) * atmosphereIntensity * 1;
          const phaseNormalized = variationPhase * 0.5 / (Math.PI * 2);
          const variantIndex = Math.floor((phaseNormalized % 1 + 1) % 1 * 8);
          const atmosphereVars = {
            "--sn-atmosphere-translate-y": `${animationOffset}px`,
            // ✅ NEW: Apply pre-computed color variant from ColorHarmonyEngine cache
            // This replaces runtime hue-rotate and saturate filters with direct RGB values
            "--sn-atmosphere-color-rgb": `var(--sn-atmosphere-variant-${variantIndex}-rgb)`
          };
          if (this.services?.cssVariables) {
            this.services.cssVariables.queueBatchUpdate(atmosphereVars);
          } else {
            Object.entries(atmosphereVars).forEach(([key, value]) => {
              this.cssController.queueCSSVariableUpdate(key, value);
            });
          }
        }
        /**
         * Create seasonal transition between natural states
         */
        createSeasonalTransition(fromSeason, toSeason, duration) {
          const startTime = performance.now();
          const transition = /* @__PURE__ */ __name((currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(1, elapsed / duration);
            const eased = 0.5 * (1 - Math.cos(progress * Math.PI));
            this.effectState.colorShift = eased;
            if (progress < 1) {
              requestAnimationFrame(transition);
            }
          }, "transition");
          requestAnimationFrame(transition);
        }
        /**
         * ✅ RAF LOOP REMOVED - Managed by EnhancedMasterAnimationCoordinator
         *
         * Previous implementation: startBreathingAnimation() with independent RAF loop
         * New implementation: updateAnimation() called by coordinator
         *
         * Benefits:
         * - Single RAF loop for all systems (not 5-8 independent loops)
         * - Shared deltaTime calculation (eliminates redundant performance.now() calls)
         * - Coordinated frame budget management
         * - Priority-based execution order
         *
         * Migration: Lines 829-847 removed, registration added to SystemCoordinator
         */
        /**
         * Update performance metrics
         */
        updatePerformanceMetrics(deltaTime) {
          this.performanceMetrics.averageProcessingTime = this.performanceMetrics.averageProcessingTime * 0.9 + deltaTime * 0.1;
        }
        /**
         * Force repaint for immediate visual updates
         */
        forceRepaint(reason) {
          console.log(`[AnimationEffectsController] Force repaint triggered: ${reason || "Unknown"}`);
          this.updateBreathingElements();
          if (this.services?.cssVariables) {
            this.services.cssVariables.flushUpdates();
          } else {
            this.cssController.flushCSSVariableBatch();
          }
        }
        /**
         * Cleanup and destroy the engine
         */
        destroy() {
          console.log("[AnimationEffectsController] Shutting down animation effects system...");
          if (this.services?.events) {
            this.services.events.cleanupSystem("AnimationEffectsController");
          }
          this.naturalElements.clear();
          this.effectState = {
            animationIntensity: 0,
            animationFrequency: 0.4,
            animationDepth: 0.8,
            grounding: 0,
            warmth: 0.7,
            ambientLevel: 0,
            colorShift: 0,
            harmonyLevel: 0
          };
          this.initialized = false;
        }
        // Public API methods
        getBreathingState() {
          return { ...this.effectState };
        }
        getAnimationConfig() {
          return { ...this.harmonyConfig };
        }
        getPerformanceMetrics() {
          return {
            ...this.performanceMetrics,
            naturalElementCount: this.naturalElements.size
          };
        }
        setCalmThreshold(threshold) {
          this.harmonyConfig.calmThreshold = Math.max(0, Math.min(1, threshold));
        }
        setBreathingDepth(depth) {
          this.effectState.animationDepth = Math.max(0, Math.min(1, depth));
        }
        setColorStrength(strength) {
          this.harmonyConfig.colorStrength = Math.max(0, Math.min(1, strength));
        }
      };
      __name(_AnimationEffectsController, "AnimationEffectsController");
      AnimationEffectsController = _AnimationEffectsController;
    }
  });

  // src-js/visual/coordination/VisualSystemCoordinator.ts
  var _VisualSystemCoordinator, VisualSystemCoordinator;
  var init_VisualSystemCoordinator = __esm({
    "src-js/visual/coordination/VisualSystemCoordinator.ts"() {
      "use strict";
      init_DeviceCapabilityDetector();
      init_UnifiedDebugManager();
      init_colorStubs();
      init_WebGLRenderer();
      init_UIVisualEffectsController();
      init_HeaderVisualEffectsController();
      init_SidebarVisualEffectsSystem();
      init_GradientConductor();
      init_MusicSyncVisualEffects();
      init_HolographicUISystem();
      init_InteractionTrackingSystem();
      init_SpotifyUIApplicationSystem();
      init_HighEnergyEffectsController();
      init_GlowEffectsController();
      init_AnimationEffectsController();
      _VisualSystemCoordinator = class _VisualSystemCoordinator {
        constructor(config, utils, year3000System, cssVariableController, performanceAnalyzer2, musicSyncService, settingsManager2, colorHarmonyEngine, eventBus, animationCoordinator) {
          this.systemName = "VisualSystemCoordinator";
          this.initialized = false;
          this.colorHarmonyEngine = null;
          this.eventBus = null;
          // EventBus when available
          this.animationCoordinator = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Event handlers
          this.boundAdaptationHandler = null;
          this.boundSettingsHandler = null;
          // Monitoring intervals
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Performance tracking
          this.fpsHistory = [];
          // Event callbacks
          this.onSystemAdaptation = null;
          this.onHealthChange = null;
          this.onSystemCreated = null;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System;
          this.cssVariableController = cssVariableController;
          this.performanceAnalyzer = performanceAnalyzer2;
          this.musicSyncService = musicSyncService;
          this.settingsManager = settingsManager2;
          this.colorHarmonyEngine = colorHarmonyEngine || null;
          this.eventBus = eventBus || null;
          this.animationCoordinator = animationCoordinator || null;
          this.deviceDetector = new DeviceCapabilityDetector();
          this.systemRegistry = /* @__PURE__ */ new Map();
          this.systemCache = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.bridgeConfig = {
            mode: "progressive",
            enablePerformanceMonitoring: true,
            enableAdaptiveQuality: true,
            enableEventCoordination: true,
            performanceThresholds: {
              minFPS: 45,
              maxMemoryMB: 50,
              thermalLimit: 70
            },
            qualityPreferences: {
              preferHighQuality: true,
              allowDynamicScaling: true,
              batteryConservation: false
            }
          };
          this.currentMetrics = this.createInitialMetrics();
          this.boundAdaptationHandler = this.handleAdaptationEvent.bind(this);
          this.boundSettingsHandler = this.handleSettingsChange.bind(this);
          this.registerVisualSystems();
          Y3KDebug?.debug?.log(
            "VisualSystemFacade",
            "Factory facade initialized with visual systems"
          );
        }
        registerVisualSystems() {
          this.systemRegistry.set(
            "SidebarVisualEffects",
            SidebarVisualEffectsSystem
          );
          this.systemDependencies.set("SidebarVisualEffects", [
            "eventBus",
            "musicSyncService"
          ]);
          this.systemRegistry.set(
            "UIVisualEffects",
            UIEffectsController
          );
          this.systemDependencies.set("UIVisualEffects", [
            "eventBus",
            "musicSyncService",
            "cssVariableController"
          ]);
          this.systemRegistry.set(
            "HeaderVisualEffects",
            HeaderVisualEffectsController
          );
          this.systemDependencies.set("HeaderVisualEffects", [
            "eventBus",
            "musicSyncService",
            "colorHarmonyEngine"
          ]);
          this.systemRegistry.set("WebGLBackground", WebGLGradientBackgroundSystem);
          this.systemDependencies.set("WebGLBackground", [
            "performanceAnalyzer",
            "eventBus"
          ]);
          this.systemRegistry.set("MusicBeatSync", MusicBeatSynchronizer);
          this.systemDependencies.set("MusicBeatSync", [
            "performanceAnalyzer",
            "cssVariableController",
            "eventBus",
            "musicSyncService",
            "colorHarmonyEngine"
          ]);
          this.systemRegistry.set("InteractionTracking", InteractionTrackingSystem);
          this.systemDependencies.set("InteractionTracking", [
            "performanceAnalyzer",
            "cssVariableController"
          ]);
          this.systemRegistry.set("SpotifyUIApplication", SpotifyUIApplicationSystem);
          this.systemDependencies.set("SpotifyUIApplication", ["year3000System"]);
          this.systemRegistry.set("CinematicDrama", RedEnergyBurstSystem);
          this.systemDependencies.set("CinematicDrama", [
            "performanceAnalyzer",
            "cssVariableController",
            "musicSyncService",
            "colorHarmonyEngine",
            "eventBus"
          ]);
          this.systemRegistry.set("EtherealBeauty", MusicGlowEffectsManager);
          this.systemDependencies.set("EtherealBeauty", [
            "performanceAnalyzer",
            "cssVariableController",
            "musicSyncService",
            "colorHarmonyEngine",
            "eventBus"
          ]);
          this.systemRegistry.set("NaturalHarmony", AnimationEffectsController);
          this.systemDependencies.set("NaturalHarmony", [
            "performanceAnalyzer",
            "cssVariableController",
            "musicSyncService",
            "colorHarmonyEngine",
            "eventBus"
          ]);
          this.systemRegistry.set("GradientConductor", GradientConductor);
          this.systemDependencies.set("GradientConductor", [
            "cssVariableController",
            "colorHarmonyEngine",
            "musicSyncService",
            "performanceAnalyzer",
            "eventBus"
          ]);
          this.systemRegistry.set("GlowEffects", MusicGlowEffectsManager);
          this.systemDependencies.set("GlowEffects", [
            "performanceAnalyzer",
            "cssVariableController",
            "musicSyncService",
            "colorHarmonyEngine",
            "eventBus"
          ]);
          this.systemRegistry.set("UnifiedParticle", SidebarVisualEffectsSystem);
          this.systemDependencies.set("UnifiedParticle", [
            "eventBus",
            "musicSyncService"
          ]);
          this.systemRegistry.set("DepthLayeredGradient", GradientConductor);
          this.systemDependencies.set("DepthLayeredGradient", [
            "cssVariableController",
            "colorHarmonyEngine",
            "musicSyncService",
            "performanceAnalyzer",
            "eventBus"
          ]);
          this.systemRegistry.set("FluidGradientBackground", WebGLGradientBackgroundSystem);
          this.systemDependencies.set("FluidGradientBackground", [
            "performanceAnalyzer",
            "eventBus"
          ]);
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3KDebug?.debug?.warn("VisualSystemFacade", "Already initialized");
            return;
          }
          try {
            this.bridgeConfig = { ...this.bridgeConfig, ...config };
            await this.deviceDetector.initialize();
            await this.applyConfiguration();
            this.subscribeToEvents();
            this.startMonitoring();
            await this.performVisualHealthCheck();
            this.isInitialized = true;
            this.initialized = true;
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-visual-bridge-active",
              "1"
            );
            this.cssVariableController.queueCSSVariableUpdate(
              "--sn-visual-bridge-mode",
              this.bridgeConfig.mode
            );
            Y3KDebug?.debug?.log("VisualSystemFacade", "Facade fully initialized", {
              mode: this.bridgeConfig.mode,
              systemsRegistered: this.systemRegistry.size,
              performanceMonitoring: this.bridgeConfig.enablePerformanceMonitoring
            });
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualSystemFacade",
              "Initialization failed:",
              error
            );
            await this.cleanup();
            throw error;
          }
        }
        /**
         * Factory method to create and return visual systems
         * This is the main interface for the facade pattern
         */
        getVisualSystem(key) {
          if (this.systemCache.has(key)) {
            return this.systemCache.get(key);
          }
          const system = this.createVisualSystem(key);
          this.systemCache.set(key, system);
          this.currentMetrics.activeVisualSystems.push(key);
          if (this.onSystemCreated) {
            this.onSystemCreated(key, system);
          }
          return system;
        }
        /**
         * Create a new visual system instance with proper dependency injection
         */
        createVisualSystem(key) {
          const SystemClass = this.systemRegistry.get(key);
          if (!SystemClass) {
            throw new Error(`Visual system '${key}' not found in registry`);
          }
          const testInstance = new SystemClass(this.config);
          if (typeof testInstance._baseInitialize === "function") {
            const system2 = testInstance;
            this.injectUnifiedSystemDependencies(system2, key);
            return system2;
          }
          if (key === "SpotifyUIApplication") {
            const system2 = new SystemClass(this.year3000System);
            this.injectDependencies(system2, key);
            return system2;
          }
          if (key === "GradientConductor") {
            const system2 = new SystemClass(
              this.eventBus,
              this.cssVariableController,
              this.colorHarmonyEngine,
              this.musicSyncService,
              this.performanceAnalyzer,
              {}
              // Default config
            );
            this.injectDependencies(system2, key);
            return system2;
          }
          if (key === "CinematicDrama" || key === "EtherealBeauty" || key === "NaturalHarmony") {
            const biologicalManager = new VisualEffectsManager();
            const holographicSystem = new HolographicUISystem(
              biologicalManager,
              this.settingsManager,
              this.musicSyncService
            );
            const system2 = new SystemClass(
              holographicSystem,
              this.cssVariableController,
              this.musicSyncService
            );
            this.injectDependencies(system2, key);
            return system2;
          }
          const system = new SystemClass(
            this.config,
            this.utils,
            this.performanceAnalyzer,
            this.musicSyncService,
            this.settingsManager,
            this.year3000System
          );
          this.injectDependencies(system, key);
          return system;
        }
        /**
         * Inject dependencies into visual systems
         */
        injectDependencies(system, key) {
          const dependencies = this.systemDependencies.get(key) || [];
          if (dependencies.includes("performanceAnalyzer") && system.setPerformanceAnalyzer) {
            system.setPerformanceAnalyzer(this.performanceAnalyzer);
          }
          if (dependencies.includes("cssVariableController") && system.setOptimizedCSSVariableManager) {
            system.setOptimizedCSSVariableManager(
              this.cssVariableController
            );
          }
          if (dependencies.includes("eventBus") && this.eventBus && system.setEventBus) {
            system.setEventBus(this.eventBus);
          }
          if (this.colorHarmonyEngine && system.setColorHarmonyEngine) {
            system.setColorHarmonyEngine(this.colorHarmonyEngine);
          }
          if (dependencies.includes("musicSyncService") && system.setMusicSyncService) {
            system.setMusicSyncService(this.musicSyncService);
          }
          if (dependencies.includes("animationCoordinator") && this.animationCoordinator && system.setAnimationCoordinator) {
            system.setAnimationCoordinator(this.animationCoordinator);
          }
          this.integratePerformanceMonitoring(system, key);
        }
        /**
         * Inject dependencies into UnifiedSystemBase-derived systems
         */
        injectUnifiedSystemDependencies(system, key) {
          if (this.cssVariableController) {
            system.cssVariableController = this.cssVariableController;
          }
          if (this.performanceAnalyzer) {
            system.performanceAnalyzer = this.performanceAnalyzer;
          }
          if (this.year3000System) {
            globalThis.year3000System = this.year3000System;
          }
          this.integratePerformanceMonitoring(system, key);
        }
        /**
         * Integrate performance monitoring for visual systems
         */
        integratePerformanceMonitoring(system, key) {
          if (!this.bridgeConfig.enablePerformanceMonitoring) return;
          const originalUpdateAnimation = system.updateAnimation;
          if (typeof originalUpdateAnimation === "function") {
            system.updateAnimation = (deltaTime) => {
              const startTime = performance.now();
              originalUpdateAnimation.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer.recordMetric(
                `Visual_${key}`,
                endTime - startTime
              );
            };
          }
          const originalOnAnimate = system.onAnimate;
          if (typeof originalOnAnimate === "function") {
            system.onAnimate = (deltaTime) => {
              const startTime = performance.now();
              originalOnAnimate.call(system, deltaTime);
              const endTime = performance.now();
              this.performanceAnalyzer.recordMetric(
                `Visual_${key}_Animate`,
                endTime - startTime
              );
            };
          }
        }
        /**
         * Apply adaptive quality control to visual systems
         */
        adaptiveQualityControl(system, key) {
          if (!this.eventBus) return;
          this.eventBus.subscribe("performance:degradation", (event) => {
            if (system.reduceQuality) {
              system.reduceQuality(event.reductionLevel);
            }
          });
          this.eventBus.subscribe("performance:improvement", (event) => {
            if (system.increaseQuality) {
              system.increaseQuality(event.improvementLevel);
            }
          });
        }
        /**
         * Handle adaptation events from the performance system
         */
        handleAdaptationEvent(event) {
          Y3KDebug?.debug?.log(
            "VisualSystemFacade",
            `Adaptation event: ${event.type}`,
            event.reason
          );
          this.currentMetrics.currentQuality = event.newSettings;
          this.systemCache.forEach((system, key) => {
            if (system.handleAdaptationEvent) {
              system.handleAdaptationEvent(event);
            }
          });
          if (this.onSystemAdaptation) {
            this.onSystemAdaptation(this.currentMetrics);
          }
          this.cssVariableController.queueCSSVariableUpdate(
            "--sn-adaptive-quality",
            (event.newSettings.gradientComplexity || 0).toString()
          );
          this.cssVariableController.queueCSSVariableUpdate(
            "--sn-adaptive-fps",
            (event.newSettings.animationFPS || 60).toString()
          );
        }
        /**
         * Propagate visual events to all systems
         */
        propagateVisualEvent(event) {
          if (!this.bridgeConfig.enableEventCoordination) return;
          this.systemCache.forEach((system, key) => {
            if (system.handleVisualEvent) {
              try {
                system.handleVisualEvent(event);
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "VisualSystemFacade",
                  `Error propagating event to ${key}:`,
                  error
                );
              }
            }
          });
          this.currentMetrics.eventCount++;
          this.currentMetrics.lastEventTime = performance.now();
        }
        /**
         * Initialize all visual systems at once
         */
        async initializeVisualSystems() {
          const initPromises = Array.from(this.systemCache.entries()).map(
            async ([key, system]) => {
              try {
                if (typeof system._baseInitialize === "function") {
                  await system._baseInitialize();
                } else {
                  await system.initialize();
                }
                Y3KDebug?.debug?.log(
                  "VisualSystemFacade",
                  `Initialized visual system: ${key}`
                );
                return { key, success: true };
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "VisualSystemFacade",
                  `Failed to initialize ${key}:`,
                  error
                );
                return { key, success: false, error };
              }
            }
          );
          const results = await Promise.allSettled(initPromises);
          const successCount = results.filter(
            (r) => r.status === "fulfilled" && r.value.success
          ).length;
          Y3KDebug?.debug?.log(
            "VisualSystemFacade",
            `Visual systems initialized: ${successCount}/${results.length}`
          );
          if (this.animationCoordinator) {
            this.registerAnimationSystems();
          }
          await this.registerQualityScalingSystems();
        }
        /**
         * Register QualityScalingCapable systems with SimplePerformanceCoordinator
         */
        async registerQualityScalingSystems() {
          try {
            const performanceOrchestrator = this.year3000System?.getCachedNonVisualSystem?.(
              "SimplePerformanceCoordinator"
            );
            const qualityScalingManager = this.year3000System?.getCachedNonVisualSystem?.(
              "QualityScalingManager"
            );
            if (!performanceOrchestrator) {
              Y3KDebug?.debug?.warn(
                "VisualSystemFacade",
                "SimplePerformanceCoordinator not available for quality scaling registration"
              );
              return;
            }
            if (!qualityScalingManager) {
              Y3KDebug?.debug?.warn(
                "VisualSystemFacade",
                "QualityScalingManager not available for quality scaling registration"
              );
              return;
            }
            for (const [key, system] of this.systemCache.entries()) {
              try {
                const qualityScalingSystem = system;
                if (typeof qualityScalingSystem.setQualityLevel === "function" && typeof qualityScalingSystem.getPerformanceImpact === "function" && typeof qualityScalingSystem.getQualityCapabilities === "function") {
                  performanceOrchestrator.registerSystem(key, qualityScalingSystem);
                  qualityScalingManager.registerSystem(key, qualityScalingSystem);
                  Y3KDebug?.debug?.log(
                    "VisualSystemFacade",
                    `Registered ${key} for quality scaling and performance coordination`
                  );
                }
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "VisualSystemFacade",
                  `Failed to register ${key} for quality scaling:`,
                  error
                );
              }
            }
            await this.initializeConsciousnessAwareAdaptation(qualityScalingManager);
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualSystemFacade",
              "Failed to register quality scaling systems:",
              error
            );
          }
        }
        /**
         * ✅ RAF LOOP CONSOLIDATION: Register animation-capable systems with master coordinator
         * Systems with updateAnimation(deltaTime) method are registered to receive frame callbacks
         */
        registerAnimationSystems() {
          if (!this.animationCoordinator) {
            return;
          }
          const systemPriorities = {
            "AnimationEffectsController": "critical",
            // Core breathing/glow effects
            "WebGLRenderer": "critical",
            // Hardware-accelerated visuals
            "DepthLayeredGradientSystem": "normal",
            // Background gradients
            "GlowEffectsController": "normal",
            // Music-reactive glow
            "HighEnergyEffectsController": "normal",
            // High-energy bursts
            "HolographicUISystem": "normal",
            // UI effects
            "InteractionTracking": "background",
            // User interaction tracking
            "Year3000FluidMorphing": "background",
            // Decorative morphing
            "ParticleSystemController": "background",
            // Particle effects
            "MusicVisualizationController": "normal"
            // Music visualization
          };
          for (const [key, system] of this.systemCache.entries()) {
            try {
              if (typeof system.updateAnimation === "function") {
                const priority = systemPriorities[key] || "normal";
                const registered = this.animationCoordinator.registerAnimationSystem(
                  key,
                  system,
                  priority,
                  60
                  // Target 60 FPS
                );
                if (registered) {
                  Y3KDebug?.debug?.log(
                    "VisualSystemFacade",
                    `Registered ${key} with animation coordinator (priority: ${priority})`
                  );
                }
              }
            } catch (error) {
              Y3KDebug?.debug?.error(
                "VisualSystemFacade",
                `Failed to register ${key} with animation coordinator:`,
                error
              );
            }
          }
        }
        /**
         * Initialize music-aware quality adaptation with music sync integration
         */
        async initializeConsciousnessAwareAdaptation(qualityScalingManager) {
          try {
            const musicSyncService = this.year3000System?.getCachedNonVisualSystem?.("MusicSyncService");
            if (!musicSyncService) {
              Y3KDebug?.debug?.warn(
                "VisualSystemFacade",
                "MusicSyncService not available for music-aware adaptation"
              );
              return;
            }
            const adaptationInterval = setInterval(() => {
              try {
                const musicIntensity = musicSyncService.getOverallIntensity?.() || 0.5;
                const musicEnergy = musicSyncService.getBeatStrength?.() || 0.5;
                qualityScalingManager.adaptToMusicIntensity(
                  musicIntensity,
                  musicEnergy
                );
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "VisualSystemFacade",
                  "Error in music-aware adaptation:",
                  error
                );
              }
            }, 2e3);
            this._musicAdaptationInterval = adaptationInterval;
            Y3KDebug?.debug?.log(
              "VisualSystemFacade",
              "Consciousness-aware quality adaptation initialized"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "VisualSystemFacade",
              "Failed to initialize music-aware adaptation:",
              error
            );
          }
        }
        /**
         * Perform health check on all visual systems
         */
        async performVisualHealthCheck() {
          const healthCheck = {
            overall: "good",
            systems: /* @__PURE__ */ new Map(),
            recommendations: [],
            timestamp: performance.now()
          };
          let healthyCount = 0;
          let totalCount = 0;
          for (const [key, system] of this.systemCache) {
            totalCount++;
            try {
              const systemHealth = system.healthCheck ? await system.healthCheck() : { status: "unknown", message: "No health check available" };
              const isHealthy = systemHealth.status === "healthy" || systemHealth.status === "good";
              if (isHealthy) healthyCount++;
              healthCheck.systems.set(key, {
                ok: isHealthy,
                details: systemHealth.message || systemHealth.details || "System operational"
              });
            } catch (error) {
              healthCheck.systems.set(key, {
                ok: false,
                details: `Health check failed: ${error}`
              });
            }
          }
          const healthPercentage = totalCount > 0 ? healthyCount / totalCount : 1;
          if (healthPercentage >= 0.9) {
            healthCheck.overall = "excellent";
          } else if (healthPercentage >= 0.7) {
            healthCheck.overall = "good";
          } else if (healthPercentage >= 0.5) {
            healthCheck.overall = "degraded";
            healthCheck.recommendations.push(
              "Some visual systems are experiencing issues"
            );
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push(
              "Multiple visual system failures detected"
            );
          }
          if (this.currentMetrics.currentFPS < 30) {
            healthCheck.recommendations.push(
              "Low FPS detected - consider reducing visual quality"
            );
          }
          if (this.currentMetrics.memoryUsageMB > 40) {
            healthCheck.recommendations.push(
              "High memory usage - consider optimizing visual systems"
            );
          }
          this.lastHealthCheck = healthCheck;
          this.cssVariableController.queueCSSVariableUpdate(
            "--sn-visual-health",
            healthCheck.overall
          );
          return healthCheck;
        }
        // Utility methods
        async applyConfiguration() {
        }
        subscribeToEvents() {
          if (this.settingsManager && this.boundSettingsHandler) {
            document.addEventListener(
              "year3000SystemSettingsChanged",
              this.boundSettingsHandler
            );
          }
        }
        startMonitoring() {
          if (this.bridgeConfig.enablePerformanceMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performVisualHealthCheck();
            }, 1e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 1e3);
          }
        }
        /**
         * Create initial metrics with enhanced performance monitoring
         */
        createInitialMetrics() {
          return {
            currentFPS: 60,
            averageFPS: 60,
            frameTime: 16.67,
            memoryUsageMB: 0,
            systemHealth: "excellent",
            activeVisualSystems: [],
            currentQuality: {
              level: "medium",
              gradientComplexity: 0.7,
              particleDensity: 100,
              animationFPS: 60,
              postProcessing: true,
              bloomEnabled: true,
              antiAliasing: "fxaa",
              shadowQuality: "medium",
              shaderPrecision: "medium"
            },
            adaptiveScaling: true,
            performanceMonitoring: true,
            eventCoordination: true,
            lastEventTime: 0,
            eventCount: 0
          };
        }
        /**
         * Enhanced metrics update with comprehensive performance monitoring
         */
        updateMetrics() {
          const startTime = performance.now();
          const currentFPS = this.performanceAnalyzer.getMedianFPS() || 0;
          this.currentMetrics.currentFPS = currentFPS;
          if (!this.fpsHistory) {
            this.fpsHistory = [];
          }
          this.fpsHistory.push(currentFPS);
          if (this.fpsHistory.length > 10) {
            this.fpsHistory.shift();
          }
          this.currentMetrics.averageFPS = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;
          this.currentMetrics.frameTime = this.currentMetrics.currentFPS > 0 ? 1e3 / this.currentMetrics.currentFPS : 1e3;
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.memoryUsageMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          this.currentMetrics.activeVisualSystems = Array.from(this.systemCache.keys()).filter((key) => {
            const system = this.systemCache.get(key);
            return system && system.initialized;
          });
          this.currentMetrics.systemHealth = this.calculateSystemHealth();
          if (this.bridgeConfig.enableAdaptiveQuality) {
            this.checkAdaptiveQualityTriggers();
          }
          const updateTime = performance.now() - startTime;
          if (updateTime > 5) {
            Y3KDebug?.debug?.warn(
              "VisualSystemCoordinator",
              `Metrics update took ${updateTime.toFixed(2)}ms - performance concern`
            );
          }
          if (this.onSystemAdaptation) {
            this.onSystemAdaptation(this.currentMetrics);
          }
        }
        /**
         * Calculate comprehensive system health based on multiple factors
         */
        calculateSystemHealth() {
          const { currentFPS, averageFPS, memoryUsageMB } = this.currentMetrics;
          let healthScore = 100;
          if (currentFPS < 20) healthScore -= 40;
          else if (currentFPS < 30) healthScore -= 25;
          else if (currentFPS < 45) healthScore -= 10;
          if (Math.abs(currentFPS - averageFPS) > 10) healthScore -= 15;
          if (memoryUsageMB > this.bridgeConfig.performanceThresholds.maxMemoryMB) {
            healthScore -= 20;
          } else if (memoryUsageMB > this.bridgeConfig.performanceThresholds.maxMemoryMB * 0.8) {
            healthScore -= 10;
          }
          if (this.currentMetrics.activeVisualSystems.length > 8) {
            healthScore -= 10;
          }
          if (healthScore >= 90) return "excellent";
          if (healthScore >= 70) return "good";
          if (healthScore >= 50) return "degraded";
          return "critical";
        }
        /**
         * Check if adaptive quality adjustments should be triggered
         */
        checkAdaptiveQualityTriggers() {
          const { systemHealth, currentFPS, memoryUsageMB } = this.currentMetrics;
          if (systemHealth === "critical" || currentFPS < this.bridgeConfig.performanceThresholds.minFPS) {
            this.triggerQualityReduction();
          } else if (systemHealth === "excellent" && currentFPS > 58 && memoryUsageMB < this.bridgeConfig.performanceThresholds.maxMemoryMB * 0.5) {
            this.triggerQualityImprovement();
          }
        }
        /**
         * Trigger quality reduction for better performance
         */
        triggerQualityReduction() {
          if (this.currentMetrics.currentQuality.level === "minimal") return;
          const newLevel = this.currentMetrics.currentQuality.level === "high" ? "medium" : "minimal";
          this.updateQualitySettings(newLevel);
          Y3KDebug?.debug?.log(
            "VisualSystemCoordinator",
            `Adaptive quality reduced to ${newLevel} due to performance constraints`
          );
        }
        /**
         * Trigger quality improvement when performance allows
         */
        triggerQualityImprovement() {
          if (this.currentMetrics.currentQuality.level === "high") return;
          const newLevel = this.currentMetrics.currentQuality.level === "minimal" ? "medium" : "high";
          this.updateQualitySettings(newLevel);
          Y3KDebug?.debug?.log(
            "VisualSystemCoordinator",
            `Adaptive quality improved to ${newLevel} due to excellent performance`
          );
        }
        /**
         * Update quality settings across all visual systems
         */
        updateQualitySettings(level) {
          const qualityMap = {
            minimal: { gradientComplexity: 0.3, particleDensity: 25, animationFPS: 30, postProcessing: false, bloomEnabled: false, antiAliasing: "none", shadowQuality: "off" },
            low: { gradientComplexity: 0.4, particleDensity: 40, animationFPS: 45, postProcessing: false, bloomEnabled: false, antiAliasing: "fxaa", shadowQuality: "medium" },
            medium: { gradientComplexity: 0.6, particleDensity: 60, animationFPS: 60, postProcessing: true, bloomEnabled: true, antiAliasing: "fxaa", shadowQuality: "medium" },
            high: { gradientComplexity: 1, particleDensity: 100, animationFPS: 60, postProcessing: true, bloomEnabled: true, antiAliasing: "msaa4x", shadowQuality: "high" },
            ultra: { gradientComplexity: 1.2, particleDensity: 150, animationFPS: 60, postProcessing: true, bloomEnabled: true, antiAliasing: "msaa4x", shadowQuality: "high" }
          };
          if (level && qualityMap[level]) {
            this.currentMetrics.currentQuality = {
              level,
              ...qualityMap[level]
            };
          }
          for (const [key, system] of this.systemCache.entries()) {
            if (system && system.initialized && typeof system.updateQuality === "function") {
              try {
                system.updateQuality(this.currentMetrics.currentQuality);
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "VisualSystemCoordinator",
                  `Failed to update quality for ${key}:`,
                  error
                );
              }
            }
          }
        }
        handleSettingsChange(event) {
          const customEvent = event;
          const { key, value } = customEvent.detail;
          if (key.startsWith("sn-visual-")) {
            this.updateConfigurationFromSettings(key, value);
          }
        }
        updateConfigurationFromSettings(key, value) {
          switch (key) {
            case "sn-visual-quality":
              this.bridgeConfig.qualityPreferences.preferHighQuality = value === "high";
              break;
            case "sn-visual-performance":
              this.bridgeConfig.enableAdaptiveQuality = value === "adaptive";
              break;
          }
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          if (this._musicAdaptationInterval) {
            clearInterval(this._musicAdaptationInterval);
            this._musicAdaptationInterval = null;
          }
          if (this.boundSettingsHandler) {
            document.removeEventListener(
              "year3000SystemSettingsChanged",
              this.boundSettingsHandler
            );
          }
          this.cssVariableController.queueCSSVariableUpdate(
            "--sn-visual-bridge-active",
            "0"
          );
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.bridgeConfig };
        }
        async setConfiguration(config) {
          this.bridgeConfig = { ...this.bridgeConfig, ...config };
          await this.applyConfiguration();
        }
        setOnSystemAdaptation(callback) {
          this.onSystemAdaptation = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            systemsActive: this.systemCache.size,
            healthy: this.currentMetrics.systemHealth === "excellent" || this.currentMetrics.systemHealth === "good"
          };
        }
        /**
         * IManagedSystem - Update animation loop (delegates to all systems)
         */
        updateAnimation(deltaTime) {
          if (!this.initialized) return;
          this.systemCache.forEach((system, key) => {
            try {
              if (typeof system.updateAnimation === "function") {
                system.updateAnimation(deltaTime);
              } else if (typeof system.onAnimate === "function") {
                system.onAnimate(deltaTime);
              }
            } catch (error) {
              Y3KDebug?.debug?.error(
                "VisualSystemCoordinator",
                `Error updating ${key}:`,
                error
              );
            }
          });
        }
        /**
         * IManagedSystem - Health check for all systems
         */
        async healthCheck() {
          try {
            const healthCheckResult = await this.performVisualHealthCheck();
            let status;
            switch (healthCheckResult.overall) {
              case "excellent":
              case "good":
                status = "healthy";
                break;
              case "degraded":
                status = "degraded";
                break;
              case "critical":
                status = "critical";
                break;
              default:
                status = "healthy";
            }
            return {
              healthy: status === "healthy",
              ok: status !== "critical",
              details: `Visual system coordinator health: ${healthCheckResult.overall} (${healthCheckResult.systems.size} systems)`,
              system: "VisualSystemCoordinator",
              issues: healthCheckResult.recommendations,
              metrics: {
                overall: healthCheckResult.overall,
                systemCount: healthCheckResult.systems.size,
                recommendations: healthCheckResult.recommendations,
                currentMetrics: this.currentMetrics,
                status
              }
            };
          } catch (error) {
            return {
              healthy: false,
              ok: false,
              details: `Health check failed: ${error}`,
              system: "VisualSystemCoordinator",
              issues: ["Health check exception"],
              metrics: { error: String(error) }
            };
          }
        }
        /**
         * IManagedSystem - Force repaint for all systems
         */
        forceRepaint(reason) {
          Y3KDebug?.debug?.log(
            "VisualSystemCoordinator",
            `Force repaint requested${reason ? `: ${reason}` : ""}`
          );
          this.systemCache.forEach((system, key) => {
            try {
              if (typeof system.forceRepaint === "function") {
                system.forceRepaint(reason);
              } else if (typeof system.refresh === "function") {
                system.refresh();
              }
            } catch (error) {
              Y3KDebug?.debug?.warn(
                "VisualSystemCoordinator",
                `Error force repainting ${key}:`,
                error
              );
            }
          });
          if (this.cssVariableController && "flushPendingUpdates" in this.cssVariableController) {
            this.cssVariableController.flushPendingUpdates();
          }
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          this.initialized = false;
          this.systemCache.clear();
          Y3KDebug?.debug?.log("VisualSystemCoordinator", "Facade destroyed");
        }
      };
      __name(_VisualSystemCoordinator, "VisualSystemCoordinator");
      VisualSystemCoordinator = _VisualSystemCoordinator;
    }
  });

  // src-js/core/integration/SystemCoordinator.ts
  var _SystemCoordinator, SystemCoordinator;
  var init_SystemCoordinator = __esm({
    "src-js/core/integration/SystemCoordinator.ts"() {
      "use strict";
      init_ColorHarmonyEngine();
      init_MusicSyncService();
      init_OptimizedCSSVariableManager();
      init_NonVisualSystemFacade();
      init_SimplePerformanceCoordinator();
      init_EnhancedDeviceTierDetector();
      init_WebGLSystemsIntegration();
      init_DeviceCapabilityDetector();
      init_PerformanceBudgetManager();
      init_UnifiedDebugManager();
      init_SettingsManager();
      init_SemanticColorManager();
      init_VisualSystemCoordinator();
      _SystemCoordinator = class _SystemCoordinator {
        constructor(config, utils, year3000System) {
          // Facade instances
          this.visualBridge = null;
          this.nonVisualFacade = null;
          // Shared dependencies (centrally managed)
          this.sharedUnifiedCSSVariableManager = null;
          // New simplified performance system
          this.sharedSimplePerformanceCoordinator = null;
          this.sharedWebGLSystemsIntegration = null;
          this.sharedEnhancedDeviceTierDetector = null;
          // Legacy systems (deprecated, maintained for compatibility during migration)
          // REMOVED: private sharedPerformanceAnalyzer: SimplePerformanceCoordinator | null = null; // Replaced with SimplePerformanceCoordinator
          this.sharedDeviceCapabilityDetector = null;
          this.sharedPerformanceBudgetManager = null;
          this.sharedMusicSyncService = null;
          this.sharedSettingsManager = null;
          this.sharedColorHarmonyEngine = null;
          this.sharedSemanticColorManager = null;
          // State management
          this.isInitialized = false;
          this.lastHealthCheck = null;
          // Color system coordination
          this.colorDependentSystems = /* @__PURE__ */ new Set();
          this.colorSystemRefreshCallbacks = /* @__PURE__ */ new Map();
          // Orchestration state
          this.currentPhase = "core";
          this.systemStates = /* @__PURE__ */ new Map();
          this.phaseCompletionPromises = /* @__PURE__ */ new Map();
          this.systemDependencies = /* @__PURE__ */ new Map();
          this.initializationOrder = /* @__PURE__ */ new Map();
          // Event coordination
          this.eventBus = null;
          this.crossFacadeEventListeners = /* @__PURE__ */ new Map();
          // Monitoring
          this.healthCheckInterval = null;
          this.metricsUpdateInterval = null;
          // Event callbacks
          this.onSystemCreated = null;
          this.onHealthChange = null;
          this.onPerformanceChange = null;
          this.config = config;
          this.utils = utils;
          this.year3000System = year3000System;
          this.coordinationConfig = {
            mode: "unified",
            enableSharedDependencies: true,
            enableCrossFacadeCommunication: true,
            enableUnifiedPerformanceMonitoring: true,
            enableResourceOptimization: true,
            coordination: {
              enforceSequentialInitialization: true,
              dependencyValidation: true,
              enableInitializationGates: true,
              systemReadinessTimeout: 5e3,
              phaseTransitionTimeout: 1e4
            },
            performanceThresholds: {
              maxTotalMemoryMB: 150,
              maxTotalInitTime: 8e3,
              maxCrossCommLatency: 10
            },
            coordinationPreferences: {
              preferSharedResources: true,
              enableEventPropagation: true,
              enableHealthCoordination: true
            }
          };
          this.setupCoordinationPhases();
          this.currentMetrics = this.createInitialMetrics();
          Y3KDebug?.debug?.log("SystemCoordinator", "System coordinator initialized");
        }
        async initialize(config) {
          if (this.isInitialized) {
            Y3KDebug?.debug?.warn("SystemCoordinator", "Already initialized");
            return;
          }
          try {
            const startTime = performance.now();
            this.coordinationConfig = { ...this.coordinationConfig, ...config };
            if (this.coordinationConfig.coordination.enforceSequentialInitialization) {
              Y3KDebug?.debug?.log(
                "SystemCoordinator",
                "Starting coordinated initialization"
              );
              await this.executeCoordinatedInitialization();
            } else {
              Y3KDebug?.debug?.log(
                "SystemCoordinator",
                "Starting legacy initialization"
              );
              await this.executeLegacyInitialization();
            }
            const endTime = performance.now();
            this.currentMetrics.totalInitTime = endTime - startTime;
            this.isInitialized = true;
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "System coordination fully initialized",
              {
                mode: this.coordinationConfig.mode,
                coordinationEnabled: this.coordinationConfig.coordination.enforceSequentialInitialization,
                currentPhase: this.currentPhase,
                visualSystems: this.currentMetrics.visualSystems,
                nonVisualSystems: this.currentMetrics.nonVisualSystems,
                initTime: this.currentMetrics.totalInitTime
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Initialization failed:",
              error
            );
            await this.cleanup();
            throw error;
          }
        }
        async initializeSharedDependencies() {
          if (!this.coordinationConfig.enableSharedDependencies) return;
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "Initializing simplified shared dependencies"
          );
          try {
            this.sharedDeviceCapabilityDetector = new DeviceCapabilityDetector({
              enableDebug: true,
              // Enable debug for troubleshooting
              spicetifyContext: true
            });
            await this.sharedDeviceCapabilityDetector.initialize();
            this.sharedEnhancedDeviceTierDetector = new EnhancedDeviceTierDetector();
            this.sharedWebGLSystemsIntegration = new WebGLSystemsIntegration(
              this.sharedDeviceCapabilityDetector
            );
            await this.sharedWebGLSystemsIntegration.initialize();
            this.sharedDeviceCapabilityDetector = new DeviceCapabilityDetector({
              enableDebug: this.config.enableDebug || false,
              runStressTests: false
            });
            await this.sharedDeviceCapabilityDetector.initialize();
            this.sharedPerformanceBudgetManager = new PerformanceBudgetManager({
              budgets: {
                animationFrame: 16,
                cssVariableUpdate: 2,
                domObservation: 1,
                audioAnalysis: 5,
                visualEffects: 8,
                userInteraction: 100
              },
              autoOptimize: {
                enabled: true,
                violationThreshold: 3,
                recoveryThreshold: 0.8
              },
              enableDebug: this.config.enableDebug || false
            }, this.sharedSimplePerformanceCoordinator);
            this.sharedSimplePerformanceCoordinator = new SimplePerformanceCoordinator(
              this.sharedEnhancedDeviceTierDetector,
              this.sharedWebGLSystemsIntegration
            );
            await this.sharedSimplePerformanceCoordinator.initialize();
            try {
              const performanceCoordinatorCompat = this.sharedSimplePerformanceCoordinator;
              this.sharedUnifiedCSSVariableManager = new OptimizedCSSVariableManager(
                this.config,
                performanceCoordinatorCompat,
                {
                  enableAdaptiveThrottling: true,
                  batchIntervalMs: 16,
                  maxBatchSize: 50,
                  priorityMappings: {
                    critical: [
                      "--sn-rs-glow-alpha",
                      "--sn-rs-beat-intensity",
                      "--sn-rs-hue-shift",
                      "--sn-enhanced-base-hex",
                      "--sn-enhanced-accent-hex"
                    ],
                    high: [
                      "--sn-gradient-primary",
                      "--sn-gradient-secondary",
                      "--sn-gradient-accent",
                      "--sn-color-base-hex",
                      "--sn-color-accent-hex"
                    ],
                    normal: ["--sn-gradient-", "--sn-rs-", "--sn-color-"],
                    low: ["--sn-debug-", "--sn-dev-", "--sn-meta-"]
                  },
                  thresholds: {
                    excellentFPS: 55,
                    goodFPS: 45,
                    poorFPS: 30
                  }
                }
              );
              setGlobalOptimizedCSSController(this.sharedUnifiedCSSVariableManager);
              await this.sharedUnifiedCSSVariableManager.initialize();
            } catch (error) {
              Y3KDebug?.debug?.warn(
                "SystemCoordinator",
                "Failed to initialize OptimizedCSSVariableManager:",
                error
              );
              this.sharedUnifiedCSSVariableManager = null;
            }
            this.sharedSettingsManager = new SettingsManager();
            await this.sharedSettingsManager.initialize();
            this.sharedMusicSyncService = new MusicSyncService();
            await this.sharedMusicSyncService.initialize();
            this.sharedColorHarmonyEngine = new ColorHarmonyEngine(
              this.config,
              this.utils,
              this.sharedSimplePerformanceCoordinator,
              this.sharedSettingsManager
            );
            await this.sharedColorHarmonyEngine.initialize();
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "Shared dependencies initialized successfully"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Failed to initialize shared dependencies:",
              error
            );
            throw error;
          }
        }
        async initializeFacades() {
          Y3KDebug?.debug?.log("SystemCoordinator", "Initializing facades");
          try {
            const animationCoordinator = this.nonVisualFacade?.getCachedSystem("EnhancedMasterAnimationCoordinator") || null;
            this.visualBridge = new VisualSystemCoordinator(
              this.config,
              this.utils,
              this.year3000System,
              this.sharedUnifiedCSSVariableManager,
              this.sharedSimplePerformanceCoordinator,
              this.sharedMusicSyncService,
              this.sharedSettingsManager,
              this.sharedColorHarmonyEngine,
              this.eventBus,
              animationCoordinator
            );
            await this.visualBridge.initialize({
              mode: this.coordinationConfig.mode === "performance-optimized" ? "performance-first" : "progressive",
              enablePerformanceMonitoring: this.coordinationConfig.enableUnifiedPerformanceMonitoring,
              enableEventCoordination: this.coordinationConfig.enableCrossFacadeCommunication
            });
            this.visualBridge.setOnSystemCreated((key, system) => {
              this.handleSystemCreated("visual", key, system);
            });
            this.nonVisualFacade = new NonVisualSystemFacade(
              this.config,
              this.utils,
              this.year3000System
            );
            await this.nonVisualFacade.initialize({
              mode: this.coordinationConfig.mode === "performance-optimized" ? "performance-first" : "progressive",
              enablePerformanceMonitoring: this.coordinationConfig.enableUnifiedPerformanceMonitoring,
              enableDependencyInjection: this.coordinationConfig.enableSharedDependencies
            });
            this.nonVisualFacade.setOnSystemCreated((key, system) => {
              this.handleSystemCreated("non-visual", key, system);
            });
            this.injectSharedDependencies();
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "Facades initialized successfully"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Failed to initialize facades:",
              error
            );
            throw error;
          }
        }
        injectSharedDependencies() {
          if (!this.coordinationConfig.enableSharedDependencies || !this.nonVisualFacade)
            return;
          if (this.sharedSimplePerformanceCoordinator) {
            this.nonVisualFacade.simplePerformanceCoordinator = this.sharedSimplePerformanceCoordinator;
          }
          if (this.sharedWebGLSystemsIntegration) {
            this.nonVisualFacade.webglSystemsIntegration = this.sharedWebGLSystemsIntegration;
          }
          if (this.sharedEnhancedDeviceTierDetector) {
            this.nonVisualFacade.enhancedDeviceTierDetector = this.sharedEnhancedDeviceTierDetector;
          }
          if (this.sharedSimplePerformanceCoordinator) {
            this.nonVisualFacade.performanceAnalyzer = this.sharedSimplePerformanceCoordinator;
          }
          if (this.sharedUnifiedCSSVariableManager) {
            this.nonVisualFacade.cssVariableController = this.sharedUnifiedCSSVariableManager;
          }
          if (this.sharedMusicSyncService) {
            this.nonVisualFacade.musicSyncService = this.sharedMusicSyncService;
          }
          if (this.sharedSettingsManager) {
            this.nonVisualFacade.settingsManager = this.sharedSettingsManager;
          }
          if (this.sharedColorHarmonyEngine) {
            this.nonVisualFacade.colorHarmonyEngine = this.sharedColorHarmonyEngine;
          }
          if (this.sharedSemanticColorManager) {
            this.nonVisualFacade.semanticColorManager = this.sharedSemanticColorManager;
          }
        }
        setupCrossFacadeCommunication() {
          if (!this.coordinationConfig.enableCrossFacadeCommunication) return;
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "Setting up cross-facade communication"
          );
          this.addEventListener("visual-event", (event) => {
            if (this.visualBridge) {
              this.visualBridge.propagateVisualEvent(event);
            }
          });
          this.addEventListener("performance-event", (event) => {
            if (this.visualBridge) {
              this.visualBridge.handleAdaptationEvent(event);
            }
          });
          if (this.coordinationConfig.coordinationPreferences.enableHealthCoordination) {
            this.addEventListener("health-degradation", (event) => {
              this.handleHealthDegradation(event);
            });
          }
        }
        handleSystemCreated(type, key, system) {
          if (type === "visual") {
            this.currentMetrics.visualSystems++;
          } else {
            this.currentMetrics.nonVisualSystems++;
          }
          this.currentMetrics.activeSystems++;
          if (type === "visual" && system && typeof system.updateAnimation === "function") {
            const animationCoordinator = this.nonVisualFacade?.getCachedSystem("EnhancedMasterAnimationCoordinator");
            if (animationCoordinator) {
              let priority = "normal";
              if (key === "WebGLGradientBackground" || key.includes("WebGL")) {
                priority = "critical";
              } else if (key.includes("Interaction") || key.includes("Tracking")) {
                priority = "background";
              }
              try {
                animationCoordinator.registerAnimation(
                  key,
                  system,
                  priority
                );
                Y3KDebug?.debug?.log(
                  "SystemCoordinator",
                  `Registered ${key} with EnhancedMasterAnimationCoordinator (priority: ${priority})`
                );
              } catch (error) {
                Y3KDebug?.debug?.warn(
                  "SystemCoordinator",
                  `Failed to register ${key} with animation coordinator:`,
                  error
                );
              }
            } else {
              Y3KDebug?.debug?.warn(
                "SystemCoordinator",
                `Animation coordinator not available for ${key} registration`
              );
            }
          }
          if (this.onSystemCreated) {
            this.onSystemCreated(type, key, system);
          }
          Y3KDebug?.debug?.log("SystemCoordinator", `System created: ${type}/${key}`);
        }
        handleHealthDegradation(event) {
          Y3KDebug?.debug?.warn(
            "SystemCoordinator",
            "Health degradation detected:",
            event
          );
          if (this.coordinationConfig.mode === "performance-optimized") {
            this.optimizeForPerformance();
          }
        }
        optimizeForPerformance() {
          if (this.visualBridge) {
            this.visualBridge.setConfiguration({
              mode: "performance-first",
              enableAdaptiveQuality: true,
              qualityPreferences: {
                preferHighQuality: false,
                allowDynamicScaling: true,
                batteryConservation: true
              }
            });
          }
          if (this.nonVisualFacade) {
            this.nonVisualFacade.setConfiguration({
              mode: "performance-first",
              systemPreferences: {
                lazyInitialization: true,
                aggressiveCaching: true,
                performanceOptimization: true
              }
            });
          }
        }
        // Public API for facade access
        getVisualSystem(key) {
          if (!this.visualBridge) return null;
          return this.visualBridge.getVisualSystem(key);
        }
        getCachedNonVisualSystem(key) {
          if (!this.nonVisualFacade) return null;
          return this.nonVisualFacade.getCachedSystem(key);
        }
        async getNonVisualSystem(key) {
          if (!this.nonVisualFacade) return null;
          return await this.nonVisualFacade.getSystem(key);
        }
        async getSystem(key) {
          if (this.visualBridge) {
            try {
              return this.visualBridge.getVisualSystem(key);
            } catch (error) {
            }
          }
          if (this.nonVisualFacade) {
            try {
              return await this.nonVisualFacade.getSystem(
                key
              );
            } catch (error) {
            }
          }
          return null;
        }
        // Cross-facade event system
        addEventListener(eventType, listener) {
          if (!this.crossFacadeEventListeners.has(eventType)) {
            this.crossFacadeEventListeners.set(eventType, []);
          }
          this.crossFacadeEventListeners.get(eventType).push(listener);
        }
        removeEventListener(eventType, listener) {
          const listeners = this.crossFacadeEventListeners.get(eventType);
          if (listeners) {
            const index = listeners.indexOf(listener);
            if (index !== -1) {
              listeners.splice(index, 1);
            }
          }
        }
        emitEvent(eventType, event) {
          const listeners = this.crossFacadeEventListeners.get(eventType);
          if (listeners) {
            listeners.forEach((listener) => {
              try {
                listener(event);
              } catch (error) {
                Y3KDebug?.debug?.error(
                  "SystemCoordinator",
                  `Error in event listener for ${eventType}:`,
                  error
                );
              }
            });
          }
          this.currentMetrics.crossFacadeEvents++;
        }
        // Health monitoring
        async performHealthCheck() {
          const healthCheck = {
            overall: "good",
            facades: {
              visual: {
                ok: true,
                details: "Visual systems operational",
                systemCount: 0
              },
              nonVisual: {
                ok: true,
                details: "Non-visual systems operational",
                systemCount: 0
              }
            },
            sharedResources: {
              simplePerformanceCoordinator: {
                ok: true,
                details: "Simple performance coordinator operational"
              },
              cssVariableController: {
                ok: true,
                details: "CSS variable batcher operational"
              },
              musicSyncService: {
                ok: true,
                details: "Music sync service operational"
              },
              // Legacy systems (optional for backward compatibility)
              performanceAnalyzer: {
                ok: true,
                details: "Legacy performance analyzer operational"
              }
            },
            recommendations: [],
            timestamp: performance.now()
          };
          if (this.visualBridge) {
            try {
              const visualHealth = await this.visualBridge.performVisualHealthCheck();
              healthCheck.facades.visual.ok = visualHealth.overall === "excellent" || visualHealth.overall === "good";
              healthCheck.facades.visual.details = `Visual systems: ${visualHealth.overall}`;
              healthCheck.facades.visual.systemCount = visualHealth.systems.size;
            } catch (error) {
              healthCheck.facades.visual.ok = false;
              healthCheck.facades.visual.details = `Visual facade error: ${error}`;
            }
          }
          if (this.nonVisualFacade) {
            try {
              const nonVisualHealth = await this.nonVisualFacade.performHealthCheck();
              healthCheck.facades.nonVisual.ok = nonVisualHealth.overall === "excellent" || nonVisualHealth.overall === "good";
              healthCheck.facades.nonVisual.details = `Non-visual systems: ${nonVisualHealth.overall}`;
              healthCheck.facades.nonVisual.systemCount = nonVisualHealth.systems.size;
            } catch (error) {
              healthCheck.facades.nonVisual.ok = false;
              healthCheck.facades.nonVisual.details = `Non-visual facade error: ${error}`;
            }
          }
          if (this.sharedSimplePerformanceCoordinator) {
            try {
              const performanceHealth = await this.sharedSimplePerformanceCoordinator.healthCheck();
              healthCheck.sharedResources.simplePerformanceCoordinator.ok = performanceHealth.healthy;
              healthCheck.sharedResources.simplePerformanceCoordinator.details = performanceHealth.details || "Simple performance coordinator operational";
            } catch (error) {
              healthCheck.sharedResources.simplePerformanceCoordinator.ok = false;
              healthCheck.sharedResources.simplePerformanceCoordinator.details = `Simple performance coordinator error: ${error}`;
            }
          }
          if (this.sharedSimplePerformanceCoordinator) {
            try {
              const performanceHealth = await this.sharedSimplePerformanceCoordinator.healthCheck();
              healthCheck.sharedResources.performanceAnalyzer = {
                ok: performanceHealth.healthy,
                details: performanceHealth.details || "Simple performance coordinator operational"
              };
            } catch (error) {
              healthCheck.sharedResources.performanceAnalyzer = {
                ok: false,
                details: `Simple performance coordinator error: ${error}`
              };
            }
          }
          if (this.sharedUnifiedCSSVariableManager) {
            try {
              const cssHealth = await this.sharedUnifiedCSSVariableManager.healthCheck();
              healthCheck.sharedResources.cssVariableController.ok = cssHealth.healthy || cssHealth.ok || false;
              healthCheck.sharedResources.cssVariableController.details = cssHealth.details || "CSS variable controller operational";
            } catch (error) {
              healthCheck.sharedResources.cssVariableController.ok = false;
              healthCheck.sharedResources.cssVariableController.details = `CSS variable controller error: ${error}`;
            }
          }
          if (this.sharedMusicSyncService) {
            try {
              const musicHealth = await this.sharedMusicSyncService.healthCheck();
              healthCheck.sharedResources.musicSyncService.ok = musicHealth.status === "healthy";
              healthCheck.sharedResources.musicSyncService.details = musicHealth.message || "Music sync service operational";
            } catch (error) {
              healthCheck.sharedResources.musicSyncService.ok = false;
              healthCheck.sharedResources.musicSyncService.details = `Music sync service error: ${error}`;
            }
          }
          if (this.sharedSemanticColorManager) {
            try {
              const semanticColorHealth = await this.sharedSemanticColorManager.healthCheck();
              const semanticColorOk = semanticColorHealth.healthy;
              healthCheck.sharedResources.semanticColorManager = {
                ok: semanticColorOk,
                details: semanticColorHealth.details || "Semantic color manager operational"
              };
            } catch (error) {
              healthCheck.sharedResources.semanticColorManager = {
                ok: false,
                details: `Semantic color manager error: ${error}`
              };
            }
          }
          const facadeHealthy = healthCheck.facades.visual.ok && healthCheck.facades.nonVisual.ok;
          const resourcesHealthy = healthCheck.sharedResources.simplePerformanceCoordinator.ok && healthCheck.sharedResources.cssVariableController.ok && healthCheck.sharedResources.musicSyncService.ok && healthCheck.sharedResources.semanticColorManager?.ok !== false && healthCheck.sharedResources.performanceAnalyzer?.ok !== false;
          if (facadeHealthy && resourcesHealthy) {
            healthCheck.overall = "excellent";
          } else if (facadeHealthy || resourcesHealthy) {
            healthCheck.overall = "good";
          } else {
            healthCheck.overall = "critical";
            healthCheck.recommendations.push(
              "Multiple system failures detected - consider system restart"
            );
          }
          if (this.currentMetrics.totalMemoryMB > 120) {
            healthCheck.recommendations.push(
              "High memory usage - consider optimizing system memory"
            );
          }
          if (this.currentMetrics.totalInitTime > 6e3) {
            healthCheck.recommendations.push(
              "High initialization time - consider optimizing system startup"
            );
          }
          this.lastHealthCheck = healthCheck;
          if (this.onHealthChange) {
            this.onHealthChange(healthCheck);
          }
          return healthCheck;
        }
        // Utility methods
        createInitialMetrics() {
          return {
            totalSystems: 0,
            visualSystems: 0,
            nonVisualSystems: 0,
            activeSystems: 0,
            failedSystems: 0,
            totalMemoryMB: 0,
            totalInitTime: 0,
            averageSystemInitTime: 0,
            crossFacadeLatency: 0,
            overallHealth: "good",
            visualHealth: "good",
            nonVisualHealth: "good",
            sharedDependencies: 6,
            // Number of shared dependencies
            crossFacadeEvents: 0,
            resourceOptimization: 0
          };
        }
        startMonitoring() {
          if (this.coordinationConfig.enableUnifiedPerformanceMonitoring) {
            this.healthCheckInterval = window.setInterval(async () => {
              await this.performHealthCheck();
            }, 2e4);
            this.metricsUpdateInterval = window.setInterval(() => {
              this.updateMetrics();
            }, 2e3);
          }
        }
        updateMetrics() {
          if (this.visualBridge) {
            const visualMetrics = this.visualBridge.getMetrics();
            this.currentMetrics.visualHealth = visualMetrics.systemHealth;
          }
          if (this.nonVisualFacade) {
            const nonVisualMetrics = this.nonVisualFacade.getMetrics();
            this.currentMetrics.nonVisualHealth = nonVisualMetrics.systemHealth;
          }
          const memoryInfo = performance.memory;
          if (memoryInfo) {
            this.currentMetrics.totalMemoryMB = memoryInfo.usedJSHeapSize / (1024 * 1024);
          }
          if (this.currentMetrics.visualHealth === "excellent" && this.currentMetrics.nonVisualHealth === "excellent") {
            this.currentMetrics.overallHealth = "excellent";
          } else if (this.currentMetrics.visualHealth === "critical" || this.currentMetrics.nonVisualHealth === "critical") {
            this.currentMetrics.overallHealth = "critical";
          } else if (this.currentMetrics.visualHealth === "degraded" || this.currentMetrics.nonVisualHealth === "degraded") {
            this.currentMetrics.overallHealth = "degraded";
          } else {
            this.currentMetrics.overallHealth = "good";
          }
          if (this.onPerformanceChange) {
            this.onPerformanceChange(this.currentMetrics);
          }
        }
        // ============================================================================
        // Orchestration Methods - Enhanced Coordination Logic
        // ============================================================================
        setupCoordinationPhases() {
          this.systemDependencies.set("MusicSyncService", []);
          this.systemDependencies.set("ColorHarmonyEngine", [
            "MusicSyncService",
            "SemanticColorManager"
          ]);
          this.systemDependencies.set("PerformanceAnalyzer", []);
          this.systemDependencies.set("UnifiedCSSVariableManager", [
            "PerformanceAnalyzer"
          ]);
          this.systemDependencies.set("SettingsManager", []);
          this.systemDependencies.set("SemanticColorManager", [
            "UnifiedCSSVariableManager"
          ]);
          this.initializationOrder.set("core", [
            "PerformanceAnalyzer",
            "UnifiedCSSVariableManager"
          ]);
          this.initializationOrder.set("services", [
            "SettingsManager",
            "MusicSyncService",
            "SemanticColorManager"
          ]);
          this.initializationOrder.set("visual-systems", ["ColorHarmonyEngine"]);
          this.initializationOrder.set("integration", [
            "VisualSystemCoordinator",
            "NonVisualSystemFacade"
          ]);
          for (const [phase, systems] of this.initializationOrder.entries()) {
            for (const system of systems) {
              this.systemStates.set(system, "uninitialized");
            }
          }
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "Coordination phases configured",
            {
              phases: Array.from(this.initializationOrder.keys()),
              totalSystems: this.systemStates.size,
              dependencies: Object.fromEntries(this.systemDependencies)
            }
          );
        }
        async executeCoordinatedInitialization() {
          const phases = [
            "core",
            "services",
            "visual-systems",
            "integration"
          ];
          for (const phase of phases) {
            Y3KDebug?.debug?.log("SystemCoordinator", `Starting phase: ${phase}`);
            this.currentPhase = phase;
            try {
              await this.executePhase(phase);
              Y3KDebug?.debug?.log(
                "SystemCoordinator",
                `Phase ${phase} completed successfully`
              );
            } catch (error) {
              Y3KDebug?.debug?.error(
                "SystemCoordinator",
                `Phase ${phase} failed:`,
                error
              );
              throw new Error(`Orchestration failed at phase ${phase}: ${error}`);
            }
          }
          this.currentPhase = "completed";
          this.setupCrossFacadeCommunication();
          await this.setupGradientSystemCoordination();
          this.setupDefaultColorDependentSystems();
          this.startMonitoring();
          await this.performHealthCheck();
        }
        async executePhase(phase) {
          const systems = this.initializationOrder.get(phase);
          if (!systems) {
            throw new Error(`Unknown phase: ${phase}`);
          }
          const initPromises = [];
          for (const systemName of systems) {
            initPromises.push(this.initializeSystemWithDependencies(systemName));
          }
          await Promise.all(initPromises);
          for (const systemName of systems) {
            const state = this.systemStates.get(systemName);
            if (state !== "ready") {
              throw new Error(
                `System ${systemName} not ready after phase ${phase} (state: ${state})`
              );
            }
          }
        }
        async initializeSystemWithDependencies(systemName) {
          if (this.systemStates.get(systemName) === "ready") {
            return;
          }
          this.systemStates.set(systemName, "initializing");
          try {
            const dependencies = this.systemDependencies.get(systemName) || [];
            for (const dependency of dependencies) {
              await this.waitForSystemReady(dependency);
            }
            switch (systemName) {
              case "PerformanceAnalyzer":
                await this.initializePerformanceAnalyzer();
                break;
              case "UnifiedCSSVariableManager":
                await this.initializeUnifiedCSSController();
                break;
              case "SettingsManager":
                await this.initializeSettingsManager();
                break;
              case "MusicSyncService":
                await this.initializeMusicSyncService();
                break;
              case "ColorHarmonyEngine":
                await this.initializeColorHarmonyEngine();
                break;
              case "SemanticColorManager":
                await this.initializeSemanticColorManager();
                break;
              case "VisualSystemCoordinator":
                await this.initializeVisualFacade();
                break;
              case "NonVisualSystemFacade":
                await this.initializeNonVisualFacade();
                break;
              default:
                throw new Error(`Unknown system: ${systemName}`);
            }
            this.systemStates.set(systemName, "ready");
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              `System ${systemName} initialized successfully`
            );
          } catch (error) {
            this.systemStates.set(systemName, "failed");
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              `System ${systemName} initialization failed:`,
              error
            );
            throw error;
          }
        }
        async waitForSystemReady(systemName) {
          const timeout = this.coordinationConfig.coordination.systemReadinessTimeout;
          const startTime = Date.now();
          while (Date.now() - startTime < timeout) {
            const state = this.systemStates.get(systemName);
            if (state === "ready") {
              return;
            }
            if (state === "failed") {
              throw new Error(`Dependency ${systemName} failed to initialize`);
            }
            await new Promise((resolve) => setTimeout(resolve, 50));
          }
          throw new Error(`Timeout waiting for dependency ${systemName} to be ready`);
        }
        // Individual system initialization methods
        async initializePerformanceAnalyzer() {
          if (!this.sharedDeviceCapabilityDetector) {
            this.sharedDeviceCapabilityDetector = new DeviceCapabilityDetector({
              enableDebug: true,
              // Enable debug for troubleshooting
              spicetifyContext: true
            });
            await this.sharedDeviceCapabilityDetector.initialize();
          }
          this.sharedEnhancedDeviceTierDetector = new EnhancedDeviceTierDetector();
          this.sharedWebGLSystemsIntegration = new WebGLSystemsIntegration(
            this.sharedDeviceCapabilityDetector
          );
          await this.sharedWebGLSystemsIntegration.initialize();
          this.sharedSimplePerformanceCoordinator = new SimplePerformanceCoordinator(
            this.sharedEnhancedDeviceTierDetector,
            this.sharedWebGLSystemsIntegration
          );
          await this.sharedSimplePerformanceCoordinator.initialize();
        }
        async initializeUnifiedCSSController() {
          if (!this.sharedSimplePerformanceCoordinator) {
            throw new Error("SimplePerformanceCoordinator dependency not available");
          }
          try {
            this.sharedDeviceCapabilityDetector = new DeviceCapabilityDetector({
              enableDebug: this.config.enableDebug || false,
              runStressTests: false
            });
            await this.sharedDeviceCapabilityDetector.initialize();
            this.sharedPerformanceBudgetManager = new PerformanceBudgetManager({
              budgets: {
                animationFrame: 16,
                cssVariableUpdate: 2,
                domObservation: 1,
                audioAnalysis: 5,
                visualEffects: 8,
                userInteraction: 100
              },
              autoOptimize: {
                enabled: true,
                violationThreshold: 3,
                recoveryThreshold: 0.8
              },
              enableDebug: this.config.enableDebug || false
            }, this.sharedSimplePerformanceCoordinator);
            const deviceCapabilities = this.sharedDeviceCapabilityDetector.getCapabilities();
            const minimalPerformanceCoordinator = {
              getCurrentPerformanceMode: /* @__PURE__ */ __name(() => ({
                name: "balanced",
                qualityLevel: 0.8,
                animationQuality: 0.8,
                effectQuality: 0.8,
                blurQuality: 0.8,
                shadowQuality: 0.8,
                frameRate: 60,
                optimizationLevel: 1
              }), "getCurrentPerformanceMode"),
              getDeviceCapabilities: /* @__PURE__ */ __name(() => deviceCapabilities || {
                performanceTier: "mid",
                memoryGB: 8,
                isMobile: false,
                gpuAcceleration: true
              }, "getDeviceCapabilities"),
              getBatteryState: /* @__PURE__ */ __name(() => ({ level: 1, charging: false }), "getBatteryState"),
              getThermalState: /* @__PURE__ */ __name(() => ({ temperature: "normal" }), "getThermalState")
            };
            this.sharedUnifiedCSSVariableManager = new OptimizedCSSVariableManager(
              this.config,
              minimalPerformanceCoordinator,
              {
                enableAdaptiveThrottling: true,
                batchIntervalMs: 16,
                maxBatchSize: 50,
                priorityMappings: {
                  critical: [
                    "--sn-rs-glow-alpha",
                    "--sn-rs-beat-intensity",
                    "--sn-rs-hue-shift",
                    "--sn-enhanced-base-hex",
                    "--sn-enhanced-accent-hex"
                  ],
                  high: [
                    "--sn-gradient-primary",
                    "--sn-gradient-secondary",
                    "--sn-gradient-accent",
                    "--sn-color-base-hex",
                    "--sn-color-accent-hex"
                  ],
                  normal: ["--sn-gradient-", "--sn-rs-", "--sn-color-"],
                  low: ["--sn-debug-", "--sn-dev-", "--sn-meta-"]
                },
                thresholds: {
                  excellentFPS: 55,
                  goodFPS: 45,
                  poorFPS: 30
                }
              }
            );
            setGlobalOptimizedCSSController(this.sharedUnifiedCSSVariableManager);
            await this.sharedUnifiedCSSVariableManager.initialize();
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "SystemCoordinator",
              "Failed to initialize OptimizedCSSVariableManager:",
              error
            );
            this.sharedUnifiedCSSVariableManager = null;
          }
        }
        async initializeSettingsManager() {
          this.sharedSettingsManager = new SettingsManager();
          await this.sharedSettingsManager.initialize();
        }
        async initializeMusicSyncService() {
          this.sharedMusicSyncService = new MusicSyncService({
            ADVANCED_SYSTEM_CONFIG: this.config,
            ThemeUtilities: this.utils,
            performanceMonitor: this.sharedSimplePerformanceCoordinator,
            settingsManager: this.sharedSettingsManager || void 0,
            year3000System: this.year3000System
          });
          await this.sharedMusicSyncService.initialize();
        }
        async initializeSemanticColorManager() {
          if (!this.sharedUnifiedCSSVariableManager) {
            throw new Error(
              "OptimizedCSSVariableManager dependency not available"
            );
          }
          this.sharedSemanticColorManager = new SemanticColorManager({
            enableDebug: this.config.enableDebug || false,
            fallbackToSpiceColors: true,
            cacheDuration: 5e3
          });
          await this.sharedSemanticColorManager.initialize(
            this.sharedUnifiedCSSVariableManager
          );
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "SemanticColorManager initialized successfully",
            {
              systemMetrics: this.sharedSemanticColorManager.getSystemMetrics()
            }
          );
        }
        async initializeColorHarmonyEngine() {
          if (!this.sharedMusicSyncService) {
            throw new Error("MusicSyncService dependency not available");
          }
          if (!this.sharedSemanticColorManager) {
            throw new Error("SemanticColorManager dependency not available");
          }
          this.sharedColorHarmonyEngine = new ColorHarmonyEngine(
            this.config,
            this.utils,
            this.sharedSimplePerformanceCoordinator || void 0,
            this.sharedSettingsManager || void 0
          );
          await this.sharedColorHarmonyEngine.initialize();
        }
        async initializeVisualFacade() {
          this.visualBridge = new VisualSystemCoordinator(
            this.config,
            this.utils,
            this,
            // year3000System
            this.sharedUnifiedCSSVariableManager,
            // cssVariableController
            this.sharedSimplePerformanceCoordinator,
            this.sharedMusicSyncService,
            this.sharedSettingsManager,
            this.sharedColorHarmonyEngine || void 0,
            // optional
            this.eventBus
            // optional
          );
          await this.visualBridge.initialize();
        }
        async initializeNonVisualFacade() {
          this.nonVisualFacade = new NonVisualSystemFacade(this.config, this.utils, {
            performanceAnalyzer: this.sharedSimplePerformanceCoordinator,
            unifiedCSSConsciousnessController: this.sharedUnifiedCSSVariableManager,
            musicSyncService: this.sharedMusicSyncService,
            settingsManager: this.sharedSettingsManager,
            colorHarmonyEngine: this.sharedColorHarmonyEngine,
            performanceOrchestrator: this.sharedSimplePerformanceCoordinator,
            semanticColorManager: this.sharedSemanticColorManager
          });
          await this.nonVisualFacade.initialize();
        }
        async executeLegacyInitialization() {
          await this.initializeSharedDependencies();
          await this.initializeFacades();
          this.setupCrossFacadeCommunication();
          await this.setupGradientSystemCoordination();
          this.setupDefaultColorDependentSystems();
          this.startMonitoring();
          await this.performHealthCheck();
        }
        // Public coordination API
        getCurrentPhase() {
          return this.currentPhase;
        }
        getSystemState(systemName) {
          return this.systemStates.get(systemName);
        }
        getAllSystemStates() {
          return new Map(this.systemStates);
        }
        isOrchestrationEnabled() {
          return this.coordinationConfig.coordination.enforceSequentialInitialization;
        }
        async cleanup() {
          if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
          }
          if (this.metricsUpdateInterval) {
            clearInterval(this.metricsUpdateInterval);
            this.metricsUpdateInterval = null;
          }
          if (this.visualBridge) {
            await this.visualBridge.destroy();
            this.visualBridge = null;
          }
          if (this.nonVisualFacade) {
            await this.nonVisualFacade.destroy();
            this.nonVisualFacade = null;
          }
          if (this.sharedSimplePerformanceCoordinator) {
            this.sharedSimplePerformanceCoordinator.destroy();
            this.sharedSimplePerformanceCoordinator = null;
          }
          if (this.sharedWebGLSystemsIntegration) {
            this.sharedWebGLSystemsIntegration.destroy();
            this.sharedWebGLSystemsIntegration = null;
          }
          if (this.sharedEnhancedDeviceTierDetector) {
            this.sharedEnhancedDeviceTierDetector = null;
          }
          if (this.sharedSemanticColorManager) {
            this.sharedSemanticColorManager.destroy();
            this.sharedSemanticColorManager = null;
          }
          if (this.sharedColorHarmonyEngine) {
            this.sharedColorHarmonyEngine.destroy();
            this.sharedColorHarmonyEngine = null;
          }
          if (this.sharedMusicSyncService) {
            this.sharedMusicSyncService.destroy();
            this.sharedMusicSyncService = null;
          }
          if (this.sharedSettingsManager) {
            this.sharedSettingsManager.destroy();
            this.sharedSettingsManager = null;
          }
          if (this.sharedUnifiedCSSVariableManager) {
            this.sharedUnifiedCSSVariableManager.destroy();
            this.sharedUnifiedCSSVariableManager = null;
          }
          if (this.sharedSimplePerformanceCoordinator) {
            this.sharedSimplePerformanceCoordinator.destroy();
            this.sharedSimplePerformanceCoordinator = null;
          }
          if (this.sharedPerformanceBudgetManager) {
            this.sharedPerformanceBudgetManager.destroy();
            this.sharedPerformanceBudgetManager = null;
          }
          if (this.sharedDeviceCapabilityDetector) {
            this.sharedDeviceCapabilityDetector.destroy();
            this.sharedDeviceCapabilityDetector = null;
          }
          this.crossFacadeEventListeners.clear();
        }
        // Public API
        getMetrics() {
          return { ...this.currentMetrics };
        }
        getLastHealthCheck() {
          return this.lastHealthCheck;
        }
        getConfiguration() {
          return { ...this.coordinationConfig };
        }
        async setConfiguration(config) {
          this.coordinationConfig = { ...this.coordinationConfig, ...config };
        }
        setOnSystemCreated(callback) {
          this.onSystemCreated = callback;
        }
        setOnHealthChange(callback) {
          this.onHealthChange = callback;
        }
        setOnPerformanceChange(callback) {
          this.onPerformanceChange = callback;
        }
        getSystemStatus() {
          return {
            initialized: this.isInitialized,
            visualSystems: this.visualBridge?.getSystemStatus()?.systemsActive || 0,
            nonVisualSystems: this.nonVisualFacade?.getSystemStatus()?.systemsActive || 0,
            healthy: this.currentMetrics.overallHealth === "excellent" || this.currentMetrics.overallHealth === "good"
          };
        }
        // ============================================================================
        // Gradient System Coordination Methods
        // ============================================================================
        /**
         * Setup comprehensive gradient system coordination
         * This method coordinates all gradient-related systems after facades are initialized
         */
        async setupGradientSystemCoordination() {
          if (!this.visualBridge) {
            Y3KDebug?.debug?.warn(
              "SystemCoordinator",
              "VisualSystemCoordinator not available - skipping gradient system coordination"
            );
            return;
          }
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "Setting up gradient system coordination"
          );
          const gradientCoordinationStartTime = performance.now();
          let coordinatedSystems = 0;
          try {
            await this.coordinateGradientConductor();
            coordinatedSystems++;
            await this.coordinateWebGLGradientSystem();
            coordinatedSystems++;
            this.setupGradientSystemRefreshCallbacks();
            this.setupGradientSystemCommunication();
            const coordinationDuration = performance.now() - gradientCoordinationStartTime;
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "Gradient system coordination completed",
              {
                coordinatedSystems,
                duration: `${coordinationDuration.toFixed(2)}ms`,
                systems: [
                  "GradientConductor",
                  "WebGLGradientBackgroundSystem",
                  "GradientTransitionOrchestrator"
                ]
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Failed to setup gradient system coordination:",
              error
            );
            throw error;
          }
        }
        /**
         * Coordinate GradientConductor system through VisualSystemCoordinator
         */
        async coordinateGradientConductor() {
          try {
            const gradientConductor = this.visualBridge.getVisualSystem("GradientConductor");
            if (!gradientConductor) {
              Y3KDebug?.debug?.warn(
                "SystemCoordinator",
                "GradientConductor not available via VisualSystemCoordinator"
              );
              return;
            }
            this.addEventListener("gradient-conductor-event", (event) => {
              if (gradientConductor && typeof gradientConductor.handleSystemEvent === "function") {
                gradientConductor.handleSystemEvent(event);
              }
            });
            this.registerColorDependentSystem(
              "GradientConductor",
              async (trigger) => {
                if (gradientConductor && typeof gradientConductor.refreshColorState === "function") {
                  await gradientConductor.refreshColorState(trigger);
                } else if (gradientConductor && typeof gradientConductor.setPalette === "function") {
                  const colorHarmonyEngine = this.sharedColorHarmonyEngine;
                  if (colorHarmonyEngine) {
                    try {
                      const currentGradient = await colorHarmonyEngine.getCurrentGradient();
                      if (currentGradient) {
                        gradientConductor.setPalette(currentGradient);
                      }
                    } catch (error) {
                      Y3KDebug?.debug?.warn(
                        "SystemCoordinator",
                        "Failed to refresh GradientConductor colors:",
                        error
                      );
                    }
                  }
                }
              }
            );
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "GradientConductor coordination established"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Failed to coordinate GradientConductor:",
              error
            );
          }
        }
        /**
         * Coordinate WebGL gradient background system
         */
        async coordinateWebGLGradientSystem() {
          try {
            const webglSystem = this.visualBridge.getVisualSystem("WebGLBackground");
            if (!webglSystem) {
              Y3KDebug?.debug?.warn(
                "SystemCoordinator",
                "WebGLGradientBackgroundSystem not available via VisualSystemCoordinator"
              );
              return;
            }
            this.addEventListener("webgl-gradient-event", (event) => {
              if (webglSystem && typeof webglSystem.handleSystemEvent === "function") {
                webglSystem.handleSystemEvent(event);
              }
            });
            this.registerColorDependentSystem(
              "WebGLGradientBackgroundSystem",
              async (trigger) => {
                if (webglSystem && typeof webglSystem.refreshColorState === "function") {
                  await webglSystem.refreshColorState(trigger);
                } else if (webglSystem && typeof webglSystem.updateGradientTexture === "function") {
                  await webglSystem.updateGradientTexture();
                }
              }
            );
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "WebGLGradientBackgroundSystem coordination established"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "SystemCoordinator",
              "Failed to coordinate WebGLGradientBackgroundSystem:",
              error
            );
          }
        }
        /**
         * Setup refresh callbacks for all gradient systems
         */
        setupGradientSystemRefreshCallbacks() {
          try {
            this.registerColorDependentSystem("GradientTransitionOrchestrator");
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "GradientTransitionOrchestrator registered for color updates"
            );
          } catch (error) {
            Y3KDebug?.debug?.warn(
              "SystemCoordinator",
              "Failed to register GradientTransitionOrchestrator:",
              error
            );
          }
        }
        /**
         * Setup communication between gradient systems
         */
        setupGradientSystemCommunication() {
          this.addEventListener("color-harmony-updated", async (event) => {
            try {
              await this.refreshColorDependentSystems("color-harmony-update");
              this.emitEvent("gradient-systems-updated", {
                trigger: "color-harmony-update",
                timestamp: Date.now(),
                systems: [
                  "GradientConductor",
                  "WebGLGradientBackgroundSystem",
                  "GradientTransitionOrchestrator"
                ]
              });
            } catch (error) {
              Y3KDebug?.debug?.error(
                "SystemCoordinator",
                "Failed to propagate color harmony update to gradient systems:",
                error
              );
            }
          });
          this.addEventListener("performance-event", (event) => {
            try {
              this.emitEvent("gradient-performance-event", {
                ...event,
                timestamp: Date.now()
              });
            } catch (error) {
              Y3KDebug?.debug?.error(
                "SystemCoordinator",
                "Failed to propagate performance event to gradient systems:",
                error
              );
            }
          });
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            "Gradient system communication established"
          );
        }
        /**
         * Get gradient system coordination status
         */
        getGradientSystemStatus() {
          const gradientSystems = [
            "GradientConductor",
            "WebGLGradientBackgroundSystem",
            "GradientTransitionOrchestrator"
          ];
          const colorDependentGradientSystems = gradientSystems.filter(
            (system) => this.colorDependentSystems.has(system)
          );
          return {
            coordinatedSystems: gradientSystems,
            colorDependentGradientSystems,
            communicationActive: this.crossFacadeEventListeners.size > 0
          };
        }
        // ============================================================================
        // Color System Coordination Methods
        // ============================================================================
        /**
         * Register a system as color-dependent for targeted updates
         */
        registerColorDependentSystem(systemKey, refreshCallback) {
          this.colorDependentSystems.add(systemKey);
          if (refreshCallback) {
            this.colorSystemRefreshCallbacks.set(systemKey, refreshCallback);
          }
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            `Registered color-dependent system: ${systemKey}`
          );
        }
        /**
         * Unregister a color-dependent system
         */
        unregisterColorDependentSystem(systemKey) {
          this.colorDependentSystems.delete(systemKey);
          this.colorSystemRefreshCallbacks.delete(systemKey);
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            `Unregistered color-dependent system: ${systemKey}`
          );
        }
        /**
         * Get list of color-dependent systems
         */
        getColorDependentSystems() {
          return Array.from(this.colorDependentSystems);
        }
        /**
         * Refresh only color-dependent systems efficiently
         */
        async refreshColorDependentSystems(trigger) {
          if (this.colorDependentSystems.size === 0) {
            Y3KDebug?.debug?.log(
              "SystemCoordinator",
              "No color-dependent systems to refresh"
            );
            return;
          }
          const startTime = performance.now();
          const refreshPromises = [];
          let successCount = 0;
          let failureCount = 0;
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            `Refreshing ${this.colorDependentSystems.size} color-dependent systems for trigger: ${trigger}`
          );
          for (const systemKey of this.colorDependentSystems) {
            const refreshCallback = this.colorSystemRefreshCallbacks.get(systemKey);
            if (refreshCallback) {
              refreshPromises.push(
                refreshCallback(trigger).then(() => {
                  successCount++;
                  Y3KDebug?.debug?.log(
                    "SystemCoordinator",
                    `Successfully refreshed color system: ${systemKey}`
                  );
                }).catch((error) => {
                  failureCount++;
                  Y3KDebug?.debug?.warn(
                    "SystemCoordinator",
                    `Failed to refresh color system ${systemKey}:`,
                    error
                  );
                })
              );
            } else {
              refreshPromises.push(
                this.getSystemAndRefresh(systemKey, trigger).then(() => {
                  successCount++;
                }).catch((error) => {
                  failureCount++;
                  Y3KDebug?.debug?.warn(
                    "SystemCoordinator",
                    `Failed to refresh color system ${systemKey}:`,
                    error
                  );
                })
              );
            }
          }
          await Promise.all(refreshPromises);
          const endTime = performance.now();
          const duration = endTime - startTime;
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            `Color system refresh completed`,
            {
              trigger,
              duration: `${duration.toFixed(2)}ms`,
              success: successCount,
              failures: failureCount,
              totalSystems: this.colorDependentSystems.size
            }
          );
          this.emitEvent("color-systems-refreshed", {
            trigger,
            duration,
            successCount,
            failureCount,
            totalSystems: this.colorDependentSystems.size,
            timestamp: Date.now()
          });
        }
        /**
         * Helper method to get system and call refresh method
         */
        async getSystemAndRefresh(systemKey, trigger) {
          if (this.visualBridge) {
            try {
              const system = this.visualBridge.getVisualSystem(systemKey);
              if (system && typeof system.refreshColorState === "function") {
                await system.refreshColorState(trigger);
                return;
              }
            } catch (error) {
            }
          }
          if (this.nonVisualFacade) {
            try {
              const system = await this.nonVisualFacade.getSystem(systemKey);
              if (system && typeof system.refreshColorState === "function") {
                await system.refreshColorState(trigger);
                return;
              }
            } catch (error) {
            }
          }
          Y3KDebug?.debug?.warn(
            "SystemCoordinator",
            `System ${systemKey} not found or doesn't support color refresh`
          );
        }
        /**
         * Auto-register common color-dependent systems
         */
        setupDefaultColorDependentSystems() {
          const defaultColorSystems = [
            "CinematicDrama",
            "EtherealBeauty",
            "NaturalHarmony",
            "FluidGradientBackgroundSystem",
            "WebGLGradientBackgroundSystem",
            "IridescentShimmerEffectsSystem",
            "ColorHarmonyEngine",
            "GradientTransitionOrchestrator",
            "GradientConductor",
            "SemanticColorManager",
            // UI Managers with system integration
            "Card3DManager",
            "GlassmorphismManager"
          ];
          for (const systemKey of defaultColorSystems) {
            this.registerColorDependentSystem(systemKey);
          }
          Y3KDebug?.debug?.log(
            "SystemCoordinator",
            `Auto-registered ${defaultColorSystems.length} default color-dependent systems`
          );
        }
        async destroy() {
          await this.cleanup();
          this.isInitialized = false;
          Y3KDebug?.debug?.log("SystemCoordinator", "System coordinator destroyed");
        }
        // Shared service getter methods for testing and integration
        getSharedMusicSyncService() {
          return this.sharedMusicSyncService || void 0;
        }
        getSharedColorHarmonyEngine() {
          return this.sharedColorHarmonyEngine || void 0;
        }
        getSharedSettingsManager() {
          return this.sharedSettingsManager || void 0;
        }
        getSharedSemanticColorManager() {
          return this.sharedSemanticColorManager || void 0;
        }
        // New simplified performance system getter methods
        getSharedSimplePerformanceCoordinator() {
          return this.sharedSimplePerformanceCoordinator || void 0;
        }
        getSharedWebGLSystemsIntegration() {
          return this.sharedWebGLSystemsIntegration || void 0;
        }
        getSharedEnhancedDeviceTierDetector() {
          return this.sharedEnhancedDeviceTierDetector || void 0;
        }
        // Legacy performance system getter methods (deprecated, for backward compatibility)
        /** @deprecated Use getSharedSimplePerformanceCoordinator() instead */
        getSharedPerformanceAnalyzer() {
          return this.sharedSimplePerformanceCoordinator || void 0;
        }
        /** @deprecated Use getSharedSimplePerformanceCoordinator() instead */
        getSharedPerformanceOrchestrator() {
          return this.sharedSimplePerformanceCoordinator || void 0;
        }
      };
      __name(_SystemCoordinator, "SystemCoordinator");
      SystemCoordinator = _SystemCoordinator;
    }
  });

  // src-js/core/css/ColorStateManager.ts
  var _ColorStateManager, ColorStateManager, globalColorStateManager;
  var init_ColorStateManager = __esm({
    "src-js/core/css/ColorStateManager.ts"() {
      "use strict";
      init_UnifiedEventBus();
      init_OptimizedCSSVariableManager();
      init_PaletteSystemManager();
      _ColorStateManager = class _ColorStateManager {
        constructor(settingsManager2) {
          this.initialized = false;
          this.settingsManager = null;
          this.currentState = null;
          this.isUpdating = false;
          // Performance tracking
          this.updateCount = 0;
          this.lastUpdateTime = 0;
          this.settingsManager = settingsManager2 || null;
        }
        async initialize() {
          if (this.initialized) return;
          const year3000System = globalThis.year3000System;
          this.cssController = year3000System?.cssController || getGlobalOptimizedCSSController();
          unifiedEventBus.subscribe("settings:changed", this.handleSettingsChange.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("colors:harmonized", this.handleProcessedColors.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("colors:extracted", this.handleExtractedColors.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("visual-effects:state-updated", this.handleVisualEffectsUpdate.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("music:energy", this.handleMusicEnergyUpdate.bind(this), "ColorStateManager");
          unifiedEventBus.subscribe("system:css-variables", this.handleSystemCSSVariables.bind(this), "ColorStateManager");
          if (!this.settingsManager) {
            this.settingsManager = globalThis.__SN_settingsManager || globalThis.Y3K?.system?.settingsManager;
          }
          if (this.settingsManager) {
            await this.applyInitialColorState();
          }
          this.initialized = true;
          console.log("\u{1F3A8} [ColorStateManager] Initialized successfully");
        }
        async healthCheck() {
          const issues = [];
          if (!this.settingsManager) {
            issues.push("SettingsManager not available");
          }
          if (!this.currentState) {
            issues.push("No current color state");
          }
          if (this.updateCount === 0) {
            issues.push("No color updates performed yet");
          }
          const timeSinceLastUpdate = Date.now() - this.lastUpdateTime;
          if (timeSinceLastUpdate > 3e5) {
            issues.push(`Last update was ${Math.round(timeSinceLastUpdate / 1e3)}s ago`);
          }
          return {
            healthy: issues.length === 0,
            ok: issues.length === 0,
            details: `Color state manager - ${this.updateCount} updates performed`,
            issues,
            system: "ColorStateManager"
          };
        }
        updateAnimation(deltaTime) {
        }
        destroy() {
          unifiedEventBus.unsubscribeAll("ColorStateManager");
          this.currentState = null;
          this.initialized = false;
        }
        /**
         * Get current color state configuration from settings
         */
        getCurrentConfig() {
          if (!this.settingsManager) {
            const defaultFlavor = paletteSystemManager.getCurrentDefaultFlavor();
            return {
              paletteSystemFlavor: defaultFlavor,
              brightnessMode: "balanced",
              // Balanced default provides natural color experience
              accentColor: "mauve",
              preserveAlbumArt: true,
              enableTransitions: true
            };
          }
          const settingsFlavor = this.settingsManager.get("catppuccin-flavor");
          const currentFlavor = settingsFlavor || paletteSystemManager.getCurrentDefaultFlavor();
          return {
            paletteSystemFlavor: currentFlavor,
            brightnessMode: this.settingsManager.get("sn-brightness-mode"),
            accentColor: this.settingsManager.get("catppuccin-accentColor"),
            preserveAlbumArt: true,
            // TODO: Add setting for this
            enableTransitions: true
          };
        }
        /**
         * Calculate the effective color state based on current configuration
         */
        calculateColorState(config) {
          const { paletteSystemFlavor, brightnessMode, accentColor, dynamicAlbumColors } = config;
          const baseColor = getBrightnessAdjustedBaseColor3(paletteSystemFlavor, brightnessMode);
          const surfaceColor = getBrightnessAdjustedSurfaceColor3(paletteSystemFlavor, brightnessMode);
          let effectiveAccentColor;
          if (accentColor === "dynamic" && dynamicAlbumColors) {
            effectiveAccentColor = dynamicAlbumColors.accent;
          } else if (accentColor === "dynamic") {
            effectiveAccentColor = getDefaultAccentColor3(paletteSystemFlavor);
          } else {
            effectiveAccentColor = getAccentColor(accentColor, paletteSystemFlavor);
          }
          const currentPalette = paletteSystemManager.getCurrentPalette();
          const flavorPalette = currentPalette[paletteSystemFlavor];
          if (!flavorPalette) {
            throw new Error(`Flavor '${paletteSystemFlavor}' not found in current palette system`);
          }
          const textColor = flavorPalette["text"];
          return {
            baseColor,
            surfaceColor,
            accentColor: effectiveAccentColor,
            textColor,
            effectiveConfig: config,
            timestamp: Date.now()
          };
        }
        /**
         * 🔧 PHASE 2: Enhanced CSS application with batching and priority support
         * Apply color state to CSS variables with batching optimization
         */
        async applyColorStateToCSSVariables(state) {
          const startTime = performance.now();
          const cssUpdates = {
            // === CRITICAL PRIORITY: Core color variables ===
            "--sn-cosmic-base-hex": state.baseColor.hex,
            "--sn-cosmic-accent-hex": state.accentColor.hex,
            "--spice-accent": state.accentColor.hex,
            "--spice-base": state.baseColor.hex,
            // === HIGH PRIORITY: Primary gradients and surfaces ===
            "--sn-color-base-hex": state.baseColor.hex,
            "--sn-color-base-rgb": state.baseColor.rgb,
            "--sn-color-surface-hex": state.surfaceColor.hex,
            "--sn-color-surface-rgb": state.surfaceColor.rgb,
            "--sn-color-accent-hex": state.accentColor.hex,
            "--sn-color-accent-rgb": state.accentColor.rgb,
            "--sn-dynamic-accent-hex": state.accentColor.hex,
            "--sn-dynamic-accent-rgb": state.accentColor.rgb,
            // === NORMAL PRIORITY: Extended color systems ===
            "--sn-cosmic-base-rgb": state.baseColor.rgb,
            "--sn-cosmic-surface-hex": state.surfaceColor.hex,
            "--sn-cosmic-surface-rgb": state.surfaceColor.rgb,
            "--sn-cosmic-accent-rgb": state.accentColor.rgb,
            "--sn-color-text-hex": state.textColor.hex,
            "--sn-color-text-rgb": state.textColor.rgb,
            "--sn-cosmic-text-hex": state.textColor.hex,
            "--sn-cosmic-text-rgb": state.textColor.rgb,
            // === NORMAL PRIORITY: Spicetify compatibility ===
            "--spice-surface1": state.surfaceColor.hex,
            "--spice-text": state.textColor.hex,
            "--spice-rgb-base": state.baseColor.rgb,
            "--spice-rgb-surface1": state.surfaceColor.rgb,
            "--spice-rgb-accent": state.accentColor.rgb,
            "--spice-rgb-text": state.textColor.rgb,
            // === NORMAL PRIORITY: Gradient system integration ===
            "--sn-bg-gradient-primary-rgb": state.accentColor.rgb,
            "--sn-bg-gradient-secondary-rgb": state.surfaceColor.rgb,
            "--sn-bg-gradient-accent-rgb": state.accentColor.rgb,
            // === HIGH PRIORITY: Brightness mode application ===
            "--sn-brightness-mode": `"${state.effectiveConfig.brightnessMode}"`,
            "--sn-brightness-data-attr": state.effectiveConfig.brightnessMode,
            // === LOW PRIORITY: Meta information for debugging ===
            "--sn-color-state-flavor": `"${state.effectiveConfig.paletteSystemFlavor}"`,
            "--sn-color-state-brightness": `"${state.effectiveConfig.brightnessMode}"`,
            "--sn-color-state-accent": `"${state.effectiveConfig.accentColor}"`,
            "--sn-color-state-palette-system": `"${paletteSystemManager.getCurrentPaletteSystem()}"`,
            "--sn-color-state-timestamp": state.timestamp.toString()
          };
          await this.applyColorVariablesWithPriorities(cssUpdates);
          const endTime = performance.now();
          const updateDuration = endTime - startTime;
          console.log(`\u{1F3A8} [ColorStateManager] Applied ${Object.keys(cssUpdates).length} CSS variables in ${updateDuration.toFixed(2)}ms (via OptimizedCSSVariableManager)`);
        }
        /**
         * Apply color variables through OptimizedCSSVariableManager with intelligent priority grouping
         */
        async applyColorVariablesWithPriorities(cssUpdates) {
          const criticalVars = ["--sn-cosmic-base-hex", "--sn-cosmic-accent-hex", "--spice-accent", "--spice-base"];
          const highPriorityVars = ["--sn-color-", "--sn-dynamic-accent-", "--sn-brightness-mode", "--sn-brightness-data-attr"];
          const criticalUpdates = {};
          const highPriorityUpdates = {};
          const normalUpdates = {};
          const lowPriorityUpdates = {};
          Object.entries(cssUpdates).forEach(([property, value]) => {
            if (criticalVars.some((prefix) => property.includes(prefix))) {
              criticalUpdates[property] = value;
            } else if (highPriorityVars.some((prefix) => property.includes(prefix))) {
              highPriorityUpdates[property] = value;
            } else if (property.includes("state-") || property.includes("timestamp")) {
              lowPriorityUpdates[property] = value;
            } else {
              normalUpdates[property] = value;
            }
          });
          if (Object.keys(criticalUpdates).length > 0) {
            this.cssController.batchSetVariables(
              "ColorStateManager",
              criticalUpdates,
              "critical",
              "color-state-critical"
            );
          }
          if (Object.keys(highPriorityUpdates).length > 0) {
            this.cssController.batchSetVariables(
              "ColorStateManager",
              highPriorityUpdates,
              "high",
              "color-state-high"
            );
          }
          if (Object.keys(normalUpdates).length > 0) {
            this.cssController.batchSetVariables(
              "ColorStateManager",
              normalUpdates,
              "normal",
              "color-state-normal"
            );
          }
          if (Object.keys(lowPriorityUpdates).length > 0) {
            this.cssController.batchSetVariables(
              "ColorStateManager",
              lowPriorityUpdates,
              "low",
              "color-state-meta"
            );
          }
        }
        /**
         * 🔧 PHASE 2: Generic method for other systems to queue CSS updates through ColorStateManager using coordination
         * This makes ColorStateManager the single CSS authority for all color-related variables
         */
        queueCSSVariableUpdate(property, value, priority = "normal") {
          const mappedPriority = priority === "critical" ? "critical" : priority === "high" ? "high" : priority === "low" ? "low" : "normal";
          this.cssController.setVariable(
            "ColorStateManager",
            property,
            value,
            mappedPriority,
            "color-state-queue"
          );
        }
        // All CSS variable updates now handled directly through OptimizedCSSVariableManager
        /**
         * Verify that critical CSS variables were actually applied to the DOM
         */
        async verifyCSSVariablesApplied(cssUpdates) {
          const criticalVars = [
            "--sn-cosmic-base-hex",
            "--sn-cosmic-accent-hex",
            "--spice-base"
          ];
          for (const varName of criticalVars) {
            if (cssUpdates[varName]) {
              const computedValue = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
              const expectedValue = cssUpdates[varName];
              if (computedValue !== expectedValue) {
                console.warn(`\u{1F3A8} [ColorStateManager] Variable verification failed: ${varName} = "${computedValue}" (expected "${expectedValue}")`);
                return false;
              }
            }
          }
          return true;
        }
        /**
         * Update color state with change detection
         */
        async updateColorState(trigger = "settings") {
          if (this.isUpdating) return;
          this.isUpdating = true;
          try {
            const config = this.getCurrentConfig();
            const newState = this.calculateColorState(config);
            const hasChanged = !this.currentState || this.currentState.baseColor.hex !== newState.baseColor.hex || this.currentState.surfaceColor.hex !== newState.surfaceColor.hex || this.currentState.accentColor.hex !== newState.accentColor.hex || this.currentState.effectiveConfig.paletteSystemFlavor !== newState.effectiveConfig.paletteSystemFlavor || this.currentState.effectiveConfig.brightnessMode !== newState.effectiveConfig.brightnessMode;
            if (hasChanged) {
              const oldState = this.currentState;
              await this.applyColorStateToCSSVariables(newState);
              await this.applyBrightnessModeOverrides(newState.effectiveConfig.brightnessMode);
              this.currentState = newState;
              this.updateCount++;
              this.lastUpdateTime = Date.now();
              unifiedEventBus.emit("colors:applied", {
                oldState,
                newState,
                trigger,
                cssVariables: {
                  "--sn-cosmic-base-hex": newState.baseColor.hex,
                  "--sn-cosmic-accent-hex": newState.accentColor.hex
                },
                accentHex: newState.accentColor.hex,
                accentRgb: newState.accentColor.rgb,
                appliedAt: Date.now()
              });
              console.log(`\u{1F3A8} [ColorStateManager] Color state updated (${trigger}):`, {
                flavor: newState.effectiveConfig.paletteSystemFlavor,
                brightness: newState.effectiveConfig.brightnessMode,
                accent: newState.effectiveConfig.accentColor,
                paletteSystem: paletteSystemManager.getCurrentPaletteSystem(),
                base: newState.baseColor.hex,
                surface: newState.surfaceColor.hex,
                accentHex: newState.accentColor.hex
              });
            }
          } finally {
            this.isUpdating = false;
          }
        }
        /**
         * Apply brightness mode specific CSS variables that take precedence over base colors
         */
        async applyBrightnessModeOverrides(brightnessMode) {
          const config = this.getCurrentConfig();
          const defaultAccent = getDefaultAccentColor3(config.paletteSystemFlavor);
          let adjustedAccentColor = defaultAccent;
          if (brightnessMode === "dark") {
            const rgbValues = defaultAccent.rgb.split(", ").map(Number);
            if (rgbValues.length === 3 && rgbValues.every((val) => !isNaN(val) && val !== void 0)) {
              const r = rgbValues[0];
              const g = rgbValues[1];
              const b = rgbValues[2];
              const darkR = Math.floor(r * 0.85);
              const darkG = Math.floor(g * 0.85);
              const darkB = Math.floor(b * 0.85);
              adjustedAccentColor = {
                ...defaultAccent,
                rgb: `${darkR}, ${darkG}, ${darkB}`,
                hex: `#${darkR.toString(16).padStart(2, "0")}${darkG.toString(16).padStart(2, "0")}${darkB.toString(16).padStart(2, "0")}`
              };
            }
          } else if (brightnessMode === "bright") {
            const rgbValues = defaultAccent.rgb.split(", ").map(Number);
            if (rgbValues.length === 3 && rgbValues.every((val) => !isNaN(val) && val !== void 0)) {
              const r = rgbValues[0];
              const g = rgbValues[1];
              const b = rgbValues[2];
              const brightR = Math.min(255, Math.floor(r * 1.1));
              const brightG = Math.min(255, Math.floor(g * 1.1));
              const brightB = Math.min(255, Math.floor(b * 1.1));
              adjustedAccentColor = {
                ...defaultAccent,
                rgb: `${brightR}, ${brightG}, ${brightB}`,
                hex: `#${brightR.toString(16).padStart(2, "0")}${brightG.toString(16).padStart(2, "0")}${brightB.toString(16).padStart(2, "0")}`
              };
            }
          }
          const brightnessOverrides = {
            // Core brightness mode state (highest priority)
            "--sn-brightness-mode": `"${brightnessMode}"`,
            "--sn-brightness-data-attr": brightnessMode,
            // Brightness-adjusted accent color (critical for proper color hierarchy)
            "--sn-brightness-adjusted-accent-hex": adjustedAccentColor.hex,
            "--sn-brightness-adjusted-accent-rgb": adjustedAccentColor.rgb,
            // CSS gradient adjustments based on brightness mode
            "--sn-bg-gradient-saturation": `var(--sn-brightness-${brightnessMode}-saturation)`,
            "--sn-bg-gradient-brightness": `var(--sn-brightness-${brightnessMode}-brightness)`,
            "--sn-bg-gradient-contrast": `var(--sn-brightness-${brightnessMode}-contrast)`,
            "--sn-bg-gradient-opacity": `var(--sn-brightness-${brightnessMode}-opacity)`
          };
          this.cssController.batchSetVariables(
            "ColorStateManager",
            brightnessOverrides,
            "critical",
            "brightness-mode-overrides"
          );
          console.log(`\u{1F3A8} [ColorStateManager] Applied brightness mode overrides: ${brightnessMode}`);
        }
        /**
         * Apply initial color state during system initialization
         */
        async applyInitialColorState() {
          await this.updateColorState("initialization");
        }
        /**
         * Handle settings changes
         */
        async handleSettingsChange(event) {
          const { settingKey, newValue, oldValue } = event;
          if (["catppuccin-flavor", "sn-brightness-mode", "catppuccin-accentColor"].includes(settingKey)) {
            let trigger = "settings";
            if (settingKey === "catppuccin-flavor") trigger = "flavor";
            else if (settingKey === "sn-brightness-mode") trigger = "brightness";
            else if (settingKey === "catppuccin-accentColor") trigger = "accent";
            unifiedEventBus.emit(`colorState:${trigger}Changed`, {
              settingKey,
              newValue,
              oldValue,
              timestamp: Date.now()
            });
            await this.updateColorState(trigger);
          }
        }
        /**
         * 🔧 PHASE 2: Handle processed color events from unified color processing
         * This replaces individual CSS application in ColorHarmonyEngine and orchestrators
         */
        async handleProcessedColors(event) {
          const { processedColors, accentHex, accentRgb, strategies, coordinationMetrics } = event;
          const colorVariables = {};
          Object.entries(processedColors).forEach(([key, value]) => {
            if (value) {
              const cssVar = key.startsWith("--") ? key : `--sn-${key.toLowerCase().replace(/_/g, "-")}`;
              colorVariables[cssVar] = value;
            }
          });
          if (accentHex) {
            colorVariables["--sn-accent-hex"] = accentHex;
            colorVariables["--sn-processed-accent-hex"] = accentHex;
          }
          if (accentRgb) {
            colorVariables["--sn-accent-rgb"] = accentRgb;
            colorVariables["--sn-processed-accent-rgb"] = accentRgb;
          }
          if (coordinationMetrics) {
            if (coordinationMetrics.emotionalState) {
              colorVariables["--sn-emotional-state"] = `"${coordinationMetrics.emotionalState}"`;
            }
            if (coordinationMetrics.musicInfluenceStrength !== void 0) {
              colorVariables["--sn-music-influence"] = coordinationMetrics.musicInfluenceStrength.toFixed(3);
            }
          }
          Object.entries(colorVariables).forEach(([property, value]) => {
            let priority = "normal";
            if (property.includes("accent-hex") || property.includes("accent-rgb")) {
              priority = "high";
            } else if (property.includes("debug") || property.includes("state") || property.includes("influence")) {
              priority = "low";
            }
            this.queueCSSVariableUpdate(property, value, priority);
          });
          console.log(`\u{1F3A8} [ColorStateManager] Applied ${Object.keys(colorVariables).length} processed color variables`);
        }
        /**
         * 🔧 PHASE 2: Handle extracted colors from album art
         */
        async handleExtractedColors(event) {
          const { rawColors, trackUri, musicData } = event;
          const extractedVariables = {};
          Object.entries(rawColors).forEach(([key, value]) => {
            if (value) {
              extractedVariables[`--sn-extracted-${key.toLowerCase()}`] = value;
            }
          });
          if (trackUri) {
            extractedVariables["--sn-current-track-id"] = `"${trackUri}"`;
          }
          Object.entries(extractedVariables).forEach(([property, value]) => {
            this.queueCSSVariableUpdate(property, value, "low");
          });
        }
        /**
         * 🔧 PHASE 2: Handle visual-effects updates and apply visual-effects CSS variables
         */
        async handleVisualEffectsUpdate(event) {
          const { payload } = event;
          if (!payload) return;
          const visualEffectsVariables = {
            "--sn-visual-effects-level": (payload.visualEffectsLevel || 0).toFixed(3),
            "--sn-emotional-temperature": (payload.emotionalTemperature || 6500).toString(),
            "--sn-transcendence-level": (payload.transcendenceLevel || 0).toFixed(3),
            "--sn-volumetric-depth": (payload.volumetricDepth || 0).toFixed(3),
            "--sn-data-stream-intensity": (payload.dataStreamIntensity || 0).toFixed(3),
            "--sn-cosmic-resonance": (payload.cosmicResonance || 0).toFixed(3)
          };
          Object.entries(visualEffectsVariables).forEach(([property, value]) => {
            this.queueCSSVariableUpdate(property, value, "normal");
          });
        }
        /**
         * 🔧 PHASE 2: Handle music energy updates for dynamic CSS variables
         */
        async handleMusicEnergyUpdate(event) {
          const { energy, valence, tempo } = event;
          const musicVariables = {};
          if (energy !== void 0) {
            musicVariables["--sn-music-energy"] = energy.toFixed(3);
          }
          if (valence !== void 0) {
            musicVariables["--sn-music-valence"] = valence.toFixed(3);
          }
          if (tempo !== void 0) {
            musicVariables["--sn-music-tempo"] = tempo.toString();
          }
          Object.entries(musicVariables).forEach(([property, value]) => {
            this.queueCSSVariableUpdate(property, value, "high");
          });
        }
        /**
         * 🔧 PHASE 2: Handle CSS variable events from other systems (ColorHarmonyEngine, etc.)
         * This makes ColorStateManager the single CSS authority for all systems
         */
        async handleSystemCSSVariables(event) {
          const { source, variables, timestamp } = event;
          if (!variables || typeof variables !== "object") return;
          Object.entries(variables).forEach(([property, value]) => {
            let priority = "normal";
            if (property.includes("harmony") || property.includes("glow") || property.includes("pulse")) {
              priority = "high";
            } else if (property.includes("debug") || property.includes("animation")) {
              priority = "low";
            }
            this.queueCSSVariableUpdate(property, value, priority);
          });
          console.log(`\u{1F3A8} [ColorStateManager] Applied ${Object.keys(variables).length} CSS variables from ${source}`);
        }
        /**
         * Get current color state (read-only)
         */
        getCurrentState() {
          return this.currentState ? { ...this.currentState } : null;
        }
        /**
         * Force refresh of color state
         */
        async refresh() {
          await this.updateColorState("settings");
        }
      };
      __name(_ColorStateManager, "ColorStateManager");
      ColorStateManager = _ColorStateManager;
      globalColorStateManager = new ColorStateManager();
    }
  });

  // src-js/utils/dom/NowPlayingDomWatcher.ts
  function startNowPlayingWatcher(onChange, enableDebug = false) {
    const bar = document.querySelector(
      MODERN_SELECTORS["nowPlayingBar"]
    );
    if (!bar) {
      if (enableDebug) {
        console.warn(
          "\u{1F3B5} [NowPlayingDomWatcher] nowPlayingBar element not found \u2013 watcher inactive"
        );
      }
      return () => {
      };
    }
    const mObserver = new MutationObserver(() => {
      onChange();
      if (enableDebug)
        console.log(
          "\u{1F3B5} [NowPlayingDomWatcher] DOM mutation detected \u2192 onChange dispatched"
        );
    });
    mObserver.observe(bar, { childList: true, subtree: true });
    if (enableDebug) console.log("\u{1F3B5} [NowPlayingDomWatcher] watcher active");
    return () => {
      mObserver.disconnect();
      if (enableDebug) console.log("\u{1F3B5} [NowPlayingDomWatcher] watcher disposed");
    };
  }
  var init_NowPlayingDomWatcher = __esm({
    "src-js/utils/dom/NowPlayingDomWatcher.ts"() {
      "use strict";
      init_SpotifyDOMSelectors();
      __name(startNowPlayingWatcher, "startNowPlayingWatcher");
    }
  });

  // src-js/visual/base/starryNightEffects.ts
  function injectStarContainer() {
    const existingContainer = document.querySelector(
      ".sn-stars-container"
    );
    if (existingContainer) {
      return existingContainer;
    }
    const starContainer = document.createElement("div");
    starContainer.className = "sn-stars-container";
    for (let i = 1; i <= 10; i++) {
      const star = document.createElement("div");
      star.className = "star";
      if (Math.random() > 0.7) star.classList.add("twinkle");
      starContainer.appendChild(star);
    }
    document.body.appendChild(starContainer);
    return starContainer;
  }
  function applyStarryNightSettings(effectIntensity, _legacyStarDensity) {
    if (ADVANCED_SYSTEM_CONFIG.enableDebug) {
      console.log("[StarryNightEffects] Applying consolidated effect settings:", {
        effectIntensity
      });
    }
    const body = document.body;
    const gradientClasses = [
      "sn-gradient-disabled",
      "sn-gradient-minimal",
      "sn-gradient-balanced",
      "sn-gradient-intense"
    ];
    const starClasses = [
      "sn-stars-disabled",
      "sn-stars-minimal",
      "sn-stars-balanced",
      "sn-stars-intense"
    ];
    body.classList.remove(...gradientClasses, ...starClasses);
    if (effectIntensity !== "balanced") {
      body.classList.add(`sn-gradient-${effectIntensity}`);
      body.classList.add(`sn-stars-${effectIntensity}`);
    }
    const existingContainer = document.querySelector(".sn-stars-container");
    if (effectIntensity === "disabled") {
      existingContainer?.remove();
    } else {
      if (!existingContainer) {
        injectStarContainer();
      }
    }
  }
  var init_starryNightEffects = __esm({
    "src-js/visual/base/starryNightEffects.ts"() {
      "use strict";
      init_SettingsManager();
      init_globalConfig();
      __name(injectStarContainer, "injectStarContainer");
      __name(applyStarryNightSettings, "applyStarryNightSettings");
    }
  });

  // src-js/core/lifecycle/AdvancedThemeSystem.ts
  var _AdvancedThemeSystem, AdvancedThemeSystem, advancedThemeSystem, AdvancedThemeSystem_default;
  var init_AdvancedThemeSystem = __esm({
    "src-js/core/lifecycle/AdvancedThemeSystem.ts"() {
      "use strict";
      init_SystemCoordinator();
      init_ColorStateManager();
      init_UnifiedColorProcessingEngine();
      init_UnifiedEventBus();
      init_globalConfig();
      init_ThemeUtilities();
      init_NowPlayingDomWatcher();
      init_starryNightEffects();
      _AdvancedThemeSystem = class _AdvancedThemeSystem {
        constructor(config = ADVANCED_SYSTEM_CONFIG) {
          this.healthCheckInterval = null;
          // Phase 4: Facade Coordination System (replaces direct system properties)
          this.facadeCoordinator = null;
          // Color State Management System
          this.colorStateManager = null;
          // Private initialization results storage
          this._initializationResults = null;
          // Private storage for dynamicCatppuccinBridge to allow setter
          this._dynamicCatppuccinBridge = null;
          // Phase 1: Loop Prevention System - Processing State Tracking
          this.processingState = {
            isProcessingSongChange: false,
            lastProcessedTrackUri: null,
            lastProcessingTime: 0,
            processingChain: [],
            eventLoopDetected: false
          };
          this.colorEventState = {
            processedEvents: /* @__PURE__ */ new Map(),
            isProcessingColorEvent: false,
            eventTimeout: null
          };
          this.PROCESSING_TIMEOUT = 5e3;
          // 5 second safety timeout
          this.MAX_CHAIN_LENGTH = 10;
          // Prevent infinite chains
          this.COLOR_EVENT_CACHE_TTL = 2e3;
          // API availability tracking
          this.availableAPIs = null;
          this._songChangeHandler = null;
          // Stats
          this._lastInitializationTime = null;
          this._initializationRetryHistory = [];
          this._systemStartTime = null;
          this._disposeNowPlayingWatcher = null;
          /**
           * Indicates whether automatic harmonic evolution is permitted. This mirrors the
           * `sn-harmonic-evolution` setting and `ADVANCED_SYSTEM_CONFIG.colorHarmonyEvolution`.
           * Sub-systems can read this flag instead of accessing the config directly so
           * that future scheduling logic (e.g. TimerConsolidationSystem) can rely on a
           * guaranteed field.
           */
          this.allowHarmonicEvolution = true;
          /** Global switch other systems can read to know guardrails are active */
          this.performanceGuardActive = false;
          this.ADVANCED_SYSTEM_CONFIG = this._deepCloneConfig(config);
          if (typeof this.ADVANCED_SYSTEM_CONFIG.init === "function") {
            this.ADVANCED_SYSTEM_CONFIG.init();
          }
          this.utils = ThemeUtilities_exports;
          this.initialized = false;
          this._systemStartTime = Date.now();
          this._initializationResults = null;
          if (this.ADVANCED_SYSTEM_CONFIG?.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Constructor: Instance created with Enhanced Master Animation Coordinator"
            );
          }
          this._boundExternalSettingsHandler = this._handleExternalSettingsChange.bind(this);
          document.addEventListener(
            "year3000SystemSettingsChanged",
            this._boundExternalSettingsHandler
          );
          this._boundArtisticModeHandler = this._onArtisticModeChanged.bind(this);
          document.addEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          this._boundVisibilityChangeHandler = this._handleVisibilityChange.bind(this);
          document.addEventListener(
            "visibilitychange",
            this._boundVisibilityChangeHandler
          );
          this._disposeNowPlayingWatcher = startNowPlayingWatcher(() => {
            const timestamp = Date.now().toString();
            this.queueCSSVariableUpdate("--sn-force-refresh", timestamp);
            unifiedEventBus.emit("music:track-changed", {
              timestamp: parseInt(timestamp),
              trackUri: "unknown",
              artist: "unknown",
              title: "unknown"
            });
          }, this.ADVANCED_SYSTEM_CONFIG.enableDebug);
          this.allowHarmonicEvolution = this.ADVANCED_SYSTEM_CONFIG.colorHarmonyEvolution ?? true;
          setTimeout(() => {
            this._applyPerformanceProfile();
          }, 0);
        }
        // 2 second cache
        // Phase 4: Pure Facade Access Property Getters
        // Performance Systems
        get enhancedMasterAnimationCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "EnhancedMasterAnimationCoordinator"
          ) || null;
        }
        get timerConsolidationSystem() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "TimerConsolidationSystem"
          ) || null;
        }
        get cssVariableController() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "OptimizedCSSVariableManager"
          ) || null;
        }
        // New simplified performance system getters (primary)
        get simplePerformanceCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "SimplePerformanceCoordinator"
          ) || null;
        }
        get simpleTierBasedPerformanceSystem() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "SimpleTierBasedPerformanceSystem"
          ) || null;
        }
        get enhancedDeviceTierDetector() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "EnhancedDeviceTierDetector"
          ) || null;
        }
        get webglSystemsIntegration() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "WebGLSystemsIntegration"
          ) || null;
        }
        // Legacy compatibility getters
        get unifiedCSSManager() {
          return this.cssVariableController || null;
        }
        /** @deprecated Use simplePerformanceCoordinator instead - legacy complex performance system */
        get performanceCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "UnifiedPerformanceCoordinator"
          ) || null;
        }
        /** @deprecated Use enhancedDeviceTierDetector instead - legacy device detection system */
        get deviceCapabilityDetector() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "DeviceCapabilityDetector"
          ) || null;
        }
        /** @deprecated Use simplePerformanceCoordinator instead - legacy complex performance system */
        get performanceAnalyzer() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("SimplePerformanceCoordinator") || null;
        }
        /** @deprecated Use simplePerformanceCoordinator instead - legacy complex performance system */
        get unifiedPerformanceCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "UnifiedPerformanceCoordinator"
          ) || null;
        }
        get performanceCSSIntegration() {
          return this.cssVariableController || null;
        }
        get performanceOrchestrator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "SimplePerformanceCoordinator"
          ) || null;
        }
        get performanceBudgetManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "PerformanceBudgetManager"
          ) || null;
        }
        // Managers and Services
        get systemHealthMonitor() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("UnifiedDebugManager") || null;
        }
        get settingsManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("SettingsManager") || null;
        }
        get colorHarmonyEngine() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("ColorHarmonyEngine") || null;
        }
        // 🔧 PHASE 3: Unified Color Processing Access
        get unifiedColorProcessingEngine() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "UnifiedColorProcessingEngine"
          ) || null;
        }
        get musicColorIntegrationBridge() {
          return null;
        }
        // 🔧 PHASE 3: Legacy Compatibility - Delegate to Unified Systems
        get colorEventOrchestrator() {
          const unified = this.unifiedColorProcessingEngine;
          return unified ? unified : null;
        }
        get colorOrchestrator() {
          const unified = this.unifiedColorProcessingEngine;
          return unified ? unified : null;
        }
        get enhancedColorOrchestrator() {
          const unified = this.unifiedColorProcessingEngine;
          return unified ? unified : null;
        }
        get colorEffectsState() {
          return this.visualEffectsCoordinator || null;
        }
        get musicSyncService() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("MusicSyncService") || null;
        }
        get glassmorphismManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "GlassmorphismManager"
          ) || null;
        }
        get card3DManager() {
          return this.facadeCoordinator?.getCachedNonVisualSystem("Card3DManager") || null;
        }
        // Consciousness Systems
        // GenreGradientEvolution removed - functionality consolidated into GenreProfileManager
        // Access genre functionality via ColorHarmonyEngine or DepthLayeredGradientSystem
        get musicEmotionAnalyzer() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "MusicEmotionAnalyzer"
          ) || null;
        }
        // 🔧 PHASE 4: Unified Visual Effects Coordination
        get visualEffectsCoordinator() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "VisualEffectsCoordinator"
          ) || null;
        }
        // 🔧 PHASE 4: Backward compatibility delegation for consolidated visual effects systems
        get colorEffectsManager() {
          return this.visualEffectsCoordinator || null;
        }
        get dynamicCatppuccinBridge() {
          return this._dynamicCatppuccinBridge || this.visualEffectsCoordinator || null;
        }
        set dynamicCatppuccinBridge(bridge) {
          this._dynamicCatppuccinBridge = bridge;
        }
        // Visual Systems
        get particleVisualEffectsModule() {
          return this.facadeCoordinator?.getVisualSystem("Particle") || null;
        }
        get sidebarVisualEffectsController() {
          return this.facadeCoordinator?.getVisualSystem("SidebarVisualEffects") || null;
        }
        get uiVisualEffectsController() {
          return this.facadeCoordinator?.getVisualSystem("UIVisualEffects") || null;
        }
        get headerVisualEffectsController() {
          return this.facadeCoordinator?.getVisualSystem("HeaderVisualEffects") || null;
        }
        // Legacy compatibility getters
        get lightweightParticleSystem() {
          return this.facadeCoordinator?.getVisualSystem("Particle") || null;
        }
        // UI Effects systems now consolidated into UIVisualEffectsController
        get iridescentShimmerEffectsSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIVisualEffects") || null;
        }
        get interactionTrackingSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIVisualEffects") || null;
        }
        get whiteLayerDiagnosticSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIVisualEffects") || null;
        }
        get audioVisualController() {
          return this.facadeCoordinator?.getVisualSystem("UIVisualEffects") || null;
        }
        get prismaticScrollSheenSystem() {
          return this.facadeCoordinator?.getVisualSystem("UIVisualEffects") || null;
        }
        get beatSyncVisualSystem() {
          return this.facadeCoordinator?.getVisualSystem("MusicBeatSync") || null;
        }
        get webGLGradientBackgroundSystem() {
          return this.facadeCoordinator?.getVisualSystem("WebGLBackground") || null;
        }
        // Legacy compatibility - particleFieldSystem consolidated into particleVisualEffectsModule
        get particleFieldSystem() {
          return this.facadeCoordinator?.getVisualSystem("Particle") || null;
        }
        get animationCoordinator() {
          return this.enhancedMasterAnimationCoordinator || null;
        }
        /** @deprecated Use animationCoordinator instead */
        get emergentChoreographyEngine() {
          return this.animationCoordinator;
        }
        get spotifyUIApplicationSystem() {
          return this.facadeCoordinator?.getVisualSystem("SpotifyUIApplication") || null;
        }
        // Music Beat Synchronization System
        get musicBeatSyncVisualEffects() {
          return this.facadeCoordinator?.getVisualSystem("MusicBeatSync") || this.beatSyncVisualSystem;
        }
        // Integration Systems Getters
        get sidebarSystemsIntegration() {
          return this.facadeCoordinator?.getCachedNonVisualSystem(
            "SidebarSystemsIntegration"
          ) || null;
        }
        _deepCloneConfig(config) {
          return config;
        }
        updateConfiguration(key, value) {
          if (!this.ADVANCED_SYSTEM_CONFIG) {
            console.warn(
              "[Year3000System] Cannot update configuration - config not initialized"
            );
            return;
          }
          const keyPath = key.split(".").filter(Boolean);
          if (!keyPath.length) {
            return;
          }
          let current = this.ADVANCED_SYSTEM_CONFIG;
          const finalKey = keyPath.pop();
          if (!finalKey) {
            return;
          }
          for (const pathKey of keyPath) {
            if (typeof current[pathKey] !== "object" || current[pathKey] === null) {
              current[pathKey] = {};
            }
            current = current[pathKey];
          }
          const oldValue = current[finalKey];
          current[finalKey] = value;
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              `[Year3000System] Configuration updated: ${key} = ${value} (was: ${oldValue})`
            );
          }
          this._notifyConfigurationChange(key, value, oldValue);
        }
        _notifyConfigurationChange(key, newValue, oldValue) {
        }
        async initializeAllSystems() {
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              "\u{1F30C} [Year3000System] initializeAllSystems(): Starting full system initialization..."
            );
          }
          this._systemStartTime = Date.now();
          const startTime = performance.now();
          const initializationResults = {
            success: [],
            failed: [],
            skipped: []
          };
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              "\u{1F30C} [Year3000System] Initializing Facade Coordination System..."
            );
          }
          try {
            this.facadeCoordinator = new SystemCoordinator(
              this.ADVANCED_SYSTEM_CONFIG,
              this.utils,
              this
            );
            await this.facadeCoordinator.initialize({
              mode: "unified",
              enableSharedDependencies: true,
              enableCrossFacadeCommunication: true,
              enableUnifiedPerformanceMonitoring: true,
              enableResourceOptimization: true,
              coordination: {
                enforceSequentialInitialization: true,
                dependencyValidation: true,
                enableInitializationGates: true,
                systemReadinessTimeout: 5e3,
                phaseTransitionTimeout: 1e4
              },
              performanceThresholds: {
                maxTotalMemoryMB: 100,
                maxTotalInitTime: 5e3,
                maxCrossCommLatency: 50
              },
              coordinationPreferences: {
                preferSharedResources: true,
                enableEventPropagation: true,
                enableHealthCoordination: true
              }
            });
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log(
                "\u{1F30C} [Year3000System] Facade Coordination System initialized successfully"
              );
            }
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing ColorStateManager...");
            }
            try {
              this.colorStateManager = globalColorStateManager;
              if (!this.colorStateManager.initialized) {
                await this.colorStateManager.initialize();
              }
              initializationResults.success.push("ColorStateManager");
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log(
                  "\u{1F30C} [Year3000System] ColorStateManager initialized successfully"
                );
              }
            } catch (error) {
              console.error(
                "\u{1F30C} [Year3000System] Failed to initialize ColorStateManager:",
                error
              );
              initializationResults.failed.push("ColorStateManager");
            }
            await this._initializeFacadeSystems();
          } catch (error) {
            console.error(
              "\u{1F30C} [Year3000System] Failed to initialize Facade Coordination System:",
              error
            );
            throw error;
          }
          initializationResults.success.push("FacadeCoordinationSystem");
          if (this.performanceAnalyzer) {
            this.performanceAnalyzer.startMonitoring();
            this.performanceGuardActive = true;
          }
          if (this.enhancedMasterAnimationCoordinator) {
            await this._registerEnhancedAnimationSystems();
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log(
                "\u{1F3AC} [Year3000System] Enhanced animation system registration phase complete"
              );
            }
          } else {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for enhanced registration phase"
            );
          }
          this._initializationResults = initializationResults;
          this.initialized = true;
          const endTime = performance.now();
          this._lastInitializationTime = endTime - startTime;
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              `[Year3000System] System initialization complete in ${this._lastInitializationTime.toFixed(
                2
              )}ms.`
            );
            console.log(
              `[Year3000System] Results: ${initializationResults.success.length} success, ${initializationResults.failed.length} failed.`
            );
            if (initializationResults.failed.length > 0) {
              console.warn(
                `[Year3000System] Failed systems: ${initializationResults.failed.join(
                  ", "
                )}`
              );
            }
            if (initializationResults.skipped && initializationResults.skipped.length > 0) {
              console.info(
                `[Year3000System] Skipped systems: ${initializationResults.skipped.join(
                  ", "
                )}`
              );
            }
            if (initializationResults.success.length > 0) {
              console.info(
                `[Year3000System] Successful systems: ${initializationResults.success.join(
                  ", "
                )}`
              );
            }
            if (this.systemHealthMonitor) {
              this.systemHealthMonitor.logHealthReport();
            }
          }
        }
        /**
         * Initialize essential systems for degraded mode (no Spicetify APIs)
         * Phase 4: Essential system initialization for degraded mode
         */
        async _initializeEssentialFacadeSystems() {
          if (!this.facadeCoordinator) {
            throw new Error(
              "Facade coordinator not available for essential system initialization"
            );
          }
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              "\u{1F30C} [Year3000System] Initializing essential systems for degraded mode..."
            );
          }
          try {
            const essentialSystems = [
              "SimplePerformanceCoordinator",
              "UnifiedCSSVariableManager",
              "UnifiedDebugManager",
              "DeviceCapabilityDetector",
              "TimerConsolidationSystem"
            ];
            for (const systemKey of essentialSystems) {
              try {
                const system = await this.facadeCoordinator.getNonVisualSystem(
                  systemKey
                );
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                    console.log(
                      `\u{1F30C} [Year3000System] Essential: Initialized ${systemKey} via facade`
                    );
                  }
                }
              } catch (error) {
                console.error(
                  `\u{1F30C} [Year3000System] Failed to initialize essential ${systemKey}:`,
                  error
                );
              }
            }
            if (this.performanceAnalyzer) {
              this.performanceAnalyzer.startMonitoring();
              this.performanceGuardActive = true;
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log(
                  "\u{1F30C} [Year3000System] Essential: Performance monitoring started"
                );
              }
            }
          } catch (error) {
            console.error(
              "\u{1F30C} [Year3000System] Essential facade system initialization failed:",
              error
            );
            throw error;
          }
        }
        /**
         * Initialize essential systems through facade pattern
         * Phase 4: Core system initialization via facades
         */
        async _initializeFacadeSystems() {
          if (!this.facadeCoordinator) {
            throw new Error(
              "Facade coordinator not available for system initialization"
            );
          }
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              "\u{1F30C} [Year3000System] Initializing essential systems through facades..."
            );
          }
          try {
            const foundationSystems = [
              "SimplePerformanceCoordinator",
              "UnifiedDebugManager",
              "SettingsManager",
              "DeviceCapabilityDetector",
              "TimerConsolidationSystem"
            ];
            const dependentSystems = [
              "UnifiedCSSVariableManager",
              // Depends on SimplePerformanceCoordinator
              "UnifiedPerformanceCoordinator"
              // Depends on SimplePerformanceCoordinator
            ];
            const eventDrivenSystems = [
              "MusicSyncService",
              "ColorHarmonyEngine",
              // 🎵 Now includes GenreProfileManager integration
              "MusicEmotionAnalyzer"
              // 🎭 Emotional intelligence for music analysis
            ];
            const uiSystems = [
              "GlassmorphismManager",
              // 🌊 Essential glassmorphism effects
              "Card3DManager"
              // 🎴 Essential 3D card transformations
            ];
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing foundation systems in parallel...");
            }
            const foundationPromises = foundationSystems.map(async (systemKey) => {
              try {
                if (!this.facadeCoordinator) {
                  throw new Error("Facade coordinator not available");
                }
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] \u2713 ${systemKey} initialized`);
                  }
                  return { systemKey, success: true };
                }
                return { systemKey, success: false, reason: "No initialize method" };
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] \u2717 Failed to initialize ${systemKey}:`, error);
                return { systemKey, success: false, error };
              }
            });
            await Promise.all(foundationPromises);
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing dependent systems in parallel...");
            }
            const dependentPromises = dependentSystems.map(async (systemKey) => {
              try {
                if (!this.facadeCoordinator) {
                  throw new Error("Facade coordinator not available");
                }
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] \u2713 ${systemKey} initialized`);
                  }
                  return { systemKey, success: true };
                }
                return { systemKey, success: false, reason: "No initialize method" };
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] \u2717 Failed to initialize ${systemKey}:`, error);
                return { systemKey, success: false, error };
              }
            });
            await Promise.all(dependentPromises);
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing event-driven systems in parallel...");
            }
            const eventDrivenPromises = eventDrivenSystems.map(async (systemKey) => {
              try {
                if (!this.facadeCoordinator) {
                  throw new Error("Facade coordinator not available");
                }
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] \u2713 ${systemKey} initialized`);
                  }
                  return { systemKey, success: true };
                }
                return { systemKey, success: false, reason: "No initialize method" };
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] \u2717 Failed to initialize ${systemKey}:`, error);
                return { systemKey, success: false, error };
              }
            });
            await Promise.all(eventDrivenPromises);
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing UI systems in parallel...");
            }
            const uiPromises = uiSystems.map(async (systemKey) => {
              try {
                if (!this.facadeCoordinator) {
                  throw new Error("Facade coordinator not available");
                }
                const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] \u2713 ${systemKey} initialized`);
                  }
                  return { systemKey, success: true };
                }
                return { systemKey, success: false, reason: "No initialize method" };
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] \u2717 Failed to initialize ${systemKey}:`, error);
                return { systemKey, success: false, error };
              }
            });
            await Promise.all(uiPromises);
            try {
              await globalUnifiedColorProcessingEngine.initialize();
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log(
                  "\u{1F3A8} [Year3000System] ColorOrchestrator initialized for strategy pattern coordination"
                );
              }
            } catch (error) {
              console.error(
                "\u{1F3A8} [Year3000System] Failed to initialize ColorOrchestrator:",
                error
              );
            }
            if (this.performanceAnalyzer) {
              this.performanceAnalyzer.startMonitoring();
              this.performanceGuardActive = true;
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log("\u{1F30C} [Year3000System] Performance monitoring started");
              }
            }
            const essentialVisualSystems = [
              "Particle",
              // ParticleField consolidated into Particle (ParticleVisualEffectsModule)
              "WebGLBackground",
              // 🌌 Enable WebGL gradient backgrounds
              "SpotifyUIApplication",
              // 🎨 Core UI color application
              "OrganicBeatSync",
              "HeaderVisualEffects",
              // 🎭 Music-responsive header visual effects animations
              "InteractionTracking"
              // EmergentChoreography integrated into EnhancedMasterAnimationCoordinator
            ];
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log("\u{1F30C} [Year3000System] Initializing visual systems in parallel...");
            }
            const visualPromises = essentialVisualSystems.map(async (systemKey) => {
              try {
                if (!this.facadeCoordinator) {
                  throw new Error("Facade coordinator not available");
                }
                const system = this.facadeCoordinator.getVisualSystem(systemKey);
                if (system && typeof system.initialize === "function") {
                  await system.initialize();
                  if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                    console.log(`\u{1F30C} [Year3000System] \u2713 Visual ${systemKey} initialized`);
                  }
                  return { systemKey, success: true };
                }
                return { systemKey, success: false, reason: "No initialize method" };
              } catch (error) {
                console.error(`\u{1F30C} [Year3000System] \u2717 Failed to initialize visual ${systemKey}:`, error);
                return { systemKey, success: false, error };
              }
            });
            await Promise.all(visualPromises);
            await this._linkSystemDependencies();
            await this._validateFacadeIntegration();
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log(
                "\u{1F30C} [Year3000System] Facade system initialization complete"
              );
            }
          } catch (error) {
            console.error(
              "\u{1F30C} [Year3000System] Facade system initialization failed:",
              error
            );
            throw error;
          }
        }
        /**
         * Phase 4: Facade Integration Validation
         * Validates that all facade integration fixes are working correctly
         */
        async _validateFacadeIntegration() {
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log("\u{1F50D} [Year3000System] Performing facade integration validation...");
          }
          const validationResults = {
            cssControllerAlias: false,
            strategyPatternSystems: false,
            parallelInitialization: false,
            facadeHealthCheck: false,
            errors: []
          };
          try {
            if (this.facadeCoordinator) {
              try {
                const cssController = await this.facadeCoordinator.getNonVisualSystem(
                  "UnifiedCSSVariableManager"
                );
                const optimizedController = await this.facadeCoordinator.getNonVisualSystem(
                  "OptimizedCSSVariableManager"
                );
                if (cssController && optimizedController) {
                  validationResults.cssControllerAlias = true;
                  if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                    console.log("\u2713 [Validation] CSS Controller alias registration working");
                  }
                } else {
                  validationResults.errors.push("CSS Controller alias registration failed");
                }
              } catch (error) {
                validationResults.errors.push(`CSS Controller validation error: ${error}`);
              }
              const strategyPatternSystems = ["ColorHarmonyEngine", "MusicEmotionAnalyzer"];
              let strategySystemsFound = 0;
              for (const systemKey of strategyPatternSystems) {
                try {
                  const system = await this.facadeCoordinator.getNonVisualSystem(systemKey);
                  if (system) {
                    strategySystemsFound++;
                  }
                } catch (error) {
                  validationResults.errors.push(`Strategy system ${systemKey} not found: ${error}`);
                }
              }
              validationResults.strategyPatternSystems = strategySystemsFound === strategyPatternSystems.length;
              if (validationResults.strategyPatternSystems && this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log("\u2713 [Validation] Strategy pattern systems registration working");
              }
              const initStartTime = performance.now();
              try {
                const testSystem = await this.facadeCoordinator.getNonVisualSystem("PerformanceAnalyzer");
                const initEndTime = performance.now();
                const initTime = initEndTime - initStartTime;
                validationResults.parallelInitialization = initTime < 100;
                if (validationResults.parallelInitialization && this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                  console.log(`\u2713 [Validation] Parallel initialization optimization working (${initTime.toFixed(2)}ms)`);
                } else if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                  console.warn(`\u26A0 [Validation] Initialization may be slow (${initTime.toFixed(2)}ms)`);
                }
              } catch (error) {
                validationResults.errors.push(`Parallel initialization test failed: ${error}`);
              }
              try {
                const healthCheck = await this.facadeCoordinator.performHealthCheck();
                validationResults.facadeHealthCheck = healthCheck.overall === "excellent" || healthCheck.overall === "good";
                if (validationResults.facadeHealthCheck && this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                  console.log(`\u2713 [Validation] Facade health check passed (${healthCheck.overall})`);
                } else {
                  validationResults.errors.push(`Facade health check failed: ${healthCheck.overall}`);
                  if (healthCheck.recommendations?.length > 0) {
                    console.warn("\u{1F527} [Validation] Health recommendations:", healthCheck.recommendations);
                  }
                }
              } catch (error) {
                validationResults.errors.push(`Facade health check error: ${error}`);
              }
            } else {
              validationResults.errors.push("Facade coordinator not available for validation");
            }
            const totalTests = 4;
            const passedTests = [
              validationResults.cssControllerAlias,
              validationResults.strategyPatternSystems,
              validationResults.parallelInitialization,
              validationResults.facadeHealthCheck
            ].filter(Boolean).length;
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log(`\u{1F50D} [Year3000System] Facade validation complete: ${passedTests}/${totalTests} tests passed`);
              if (validationResults.errors.length > 0) {
                console.warn("\u26A0 [Year3000System] Validation errors:", validationResults.errors);
              }
              if (passedTests === totalTests) {
                console.log("\u{1F389} [Year3000System] All facade integration fixes validated successfully!");
              }
            }
            window.Y3K_FACADE_VALIDATION = validationResults;
          } catch (error) {
            console.error("\u{1F50D} [Year3000System] Facade validation failed:", error);
            validationResults.errors.push(`Validation process error: ${error}`);
          }
        }
        /**
         * Link system dependencies after facade initialization
         * Phase 4: Connect systems that need cross-references
         */
        async _linkSystemDependencies() {
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log("\u{1F30C} [Year3000System] Linking system dependencies...");
          }
          try {
            if (this.musicSyncService && this.colorHarmonyEngine) {
              this.musicSyncService.setColorHarmonyEngine(this.colorHarmonyEngine);
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log(
                  "\u{1F30C} [Year3000System] ColorHarmonyEngine linked to MusicSyncService"
                );
              }
            }
            if (this.colorHarmonyEngine && this.enhancedMasterAnimationCoordinator) {
              this.colorHarmonyEngine.setEmergentEngine(
                this.enhancedMasterAnimationCoordinator
              );
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log(
                  "\u{1F30C} [Year3000System] EnhancedMasterAnimationCoordinator (with adaptive functionality) linked to ColorHarmonyEngine"
                );
              }
            }
            if (this.systemHealthMonitor) {
              const systemsToRegister = [
                { name: "MusicSyncService", system: this.musicSyncService },
                { name: "ColorHarmonyEngine", system: this.colorHarmonyEngine },
                { name: "SettingsManager", system: this.settingsManager }
              ];
              for (const { name, system } of systemsToRegister) {
                if (system) {
                  this.systemHealthMonitor.registerSystem(name, system);
                }
              }
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log(
                  "\u{1F30C} [Year3000System] Systems registered with health monitor"
                );
              }
            }
          } catch (error) {
            console.error(
              "\u{1F30C} [Year3000System] Failed to link system dependencies:",
              error
            );
          }
        }
        /**
         * Legacy function - removed prediction systems entirely for performance optimization
         */
        _shouldSkipPredictionSystem(systemName) {
          return false;
        }
        async _initializeVisualSystems(results) {
          if (!this.performanceAnalyzer || !this.musicSyncService || !this.settingsManager) {
            console.error(
              "[Year3000System] Cannot initialize visual systems due to missing core dependencies (SimplePerformanceCoordinator, MusicSyncService, or SettingsManager)."
            );
            const visualSystems = [
              "InteractionTrackingSystem",
              "BeatSyncVisualSystem",
              "SidebarSystemsIntegration"
              // "EmergentChoreographyEngine", // Consolidated into EnhancedMasterAnimationCoordinator
            ];
            visualSystems.forEach((s) => results.skipped.push(s));
            return;
          }
          if (this.colorHarmonyEngine && this.enhancedMasterAnimationCoordinator) {
            this.colorHarmonyEngine.setEmergentEngine(
              this.enhancedMasterAnimationCoordinator
            );
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log(
                "\u{1F517} [Year3000System] EnhancedMasterAnimationCoordinator (adaptive functionality) linked to ColorHarmonyEngine."
              );
            }
          }
        }
        async destroyAllSystems() {
          if (this.facadeCoordinator) {
            await this.facadeCoordinator.destroy();
            this.facadeCoordinator = null;
          }
          this._initializationResults = null;
          if (Spicetify.Player && this._songChangeHandler) {
            Spicetify.Player.removeEventListener(
              "songchange",
              this._songChangeHandler
            );
          }
          this.initialized = false;
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log("\u{1F525} [Year3000System] All systems have been destroyed.");
          }
          document.removeEventListener(
            "year3000SystemSettingsChanged",
            this._boundExternalSettingsHandler
          );
          document.removeEventListener(
            "year3000ArtisticModeChanged",
            this._boundArtisticModeHandler
          );
          document.removeEventListener(
            "visibilitychange",
            this._boundVisibilityChangeHandler
          );
          if (this._disposeNowPlayingWatcher) {
            this._disposeNowPlayingWatcher();
            this._disposeNowPlayingWatcher = null;
          }
        }
        async applyInitialSettings(trigger) {
          if (!this.settingsManager) {
            console.warn(
              "[Year3000System] SettingsManager not ready, cannot apply initial settings."
            );
            return;
          }
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              `\u{1F3A8} [Year3000System] Inside applyInitialSettings. Trigger: ${trigger || "full"}, SettingsManager valid:`,
              !!this.settingsManager
            );
          }
          try {
            if (trigger === "flavor" || trigger === "brightness" || trigger === "accent") {
              console.log(
                `\u{1F3A8} [Year3000System] Selective update for trigger: ${trigger}`
              );
              await this.updateColorStateOnly(trigger);
              await this.refreshColorDependentSystems(trigger);
              return;
            }
            console.log(
              "\u{1F3A8} [Year3000System] applyInitialSettings: Getting initial settings..."
            );
            if (this.colorStateManager && !this.colorStateManager.initialized) {
              console.log("\u{1F3A8} [Year3000System] Initializing ColorStateManager...");
              await this.colorStateManager.initialize();
            }
            if (this.colorStateManager?.initialized) {
              console.log(
                "\u{1F3A8} [Year3000System] Applying initial color state via ColorStateManager..."
              );
              await this.colorStateManager.applyInitialColorState();
            } else {
              console.warn(
                "\u{1F3A8} [Year3000System] ColorStateManager not available, using legacy color application"
              );
              const accent = this.settingsManager.get("catppuccin-accentColor");
              if (accent !== "dynamic") {
                await this._applyCatppuccinAccent(accent);
              }
            }
            const gradient = this.settingsManager.get("sn-gradient-intensity");
            const stars = gradient;
            const intensityRaw = this.settingsManager.get("sn-harmonic-intensity");
            const evolutionRaw = this.settingsManager.get("sn-harmonic-evolution");
            const harmonicModeKey = this.settingsManager.get(
              "sn-current-harmonic-mode"
            );
            if (harmonicModeKey) {
              this.ADVANCED_SYSTEM_CONFIG.currentColorHarmonyMode = String(harmonicModeKey);
            }
            console.log(
              `\u{1F3A8} [Year3000System] applyInitialSettings: Gradient=${gradient}, Stars=${stars}, ColorState=${!!this.colorStateManager?.initialized}`
            );
            await this._applyStarryNightSettings(
              gradient,
              stars
            );
            const intensity = parseFloat(intensityRaw);
            if (!Number.isNaN(intensity)) {
              if (this.colorHarmonyEngine) {
                this.colorHarmonyEngine.setIntensity?.(intensity);
              }
              this.ADVANCED_SYSTEM_CONFIG.colorHarmonyIntensity = intensity;
            }
            const evolutionEnabled = evolutionRaw === "true";
            this.allowHarmonicEvolution = evolutionEnabled;
            this.ADVANCED_SYSTEM_CONFIG.colorHarmonyEvolution = evolutionEnabled;
            console.log(
              "\u{1F3A8} [Year3000System] applyInitialSettings: Successfully applied initial settings."
            );
          } catch (error) {
            console.error("[Year3000System] Error applying initial settings:", error);
          }
        }
        /**
         * Update only color state without full settings reload
         */
        async updateColorStateOnly(trigger) {
          if (!this.colorStateManager?.initialized) {
            console.warn(
              `\u{1F3A8} [Year3000System] ColorStateManager not available for ${trigger} update`
            );
            return;
          }
          console.log(
            `\u{1F3A8} [Year3000System] Updating color state for trigger: ${trigger}`
          );
          await this.colorStateManager.updateColorState(trigger);
        }
        /**
         * Refresh only color-dependent systems efficiently
         */
        async refreshColorDependentSystems(trigger) {
          if (!this.facadeCoordinator) {
            console.warn(
              `\u{1F3A8} [Year3000System] No facade coordinator available for ${trigger} refresh`
            );
            return;
          }
          console.log(
            `\u{1F3A8} [Year3000System] Refreshing color-dependent systems for trigger: ${trigger}`
          );
          await this.facadeCoordinator.refreshColorDependentSystems(trigger);
        }
        async _applyCatppuccinAccent(selectedAccent) {
          if (selectedAccent === "dynamic") {
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log(
                "\u{1F3A8} [Year3000System] _applyCatppuccinAccent: 'dynamic' accent selected \u2013 skipping static accent overrides."
              );
            }
            return;
          }
          console.log(
            `\u{1F3A8} [Year3000System] _applyCatppuccinAccent: Applying accent color '${selectedAccent}'`
          );
          const accent = selectedAccent === "none" ? "text" : selectedAccent;
          const colorScheme = Spicetify.Config.color_scheme || "mocha";
          const equalizerUrl = document.querySelector(
            "body > script.marketplaceScript"
          ) ? `url('https://github.com/catppuccin/spicetify/blob/main/catppuccin/assets/${colorScheme}/equalizer-animated-${accent}.gif?raw=true')` : `url('${colorScheme}/equalizer-animated-${accent}.gif')`;
          this.cssVariableController?.queueCSSVariableUpdate(
            "--spice-text",
            `var(--spice-${accent})`
          );
          this.cssVariableController?.queueCSSVariableUpdate(
            "--spice-button-active",
            `var(--spice-${accent})`
          );
          this.cssVariableController?.queueCSSVariableUpdate(
            "--spice-equalizer",
            equalizerUrl
          );
          this.cssVariableController?.flushCSSVariableBatch();
          console.log(
            `\u{1F3A8} [Year3000System] _applyCatppuccinAccent: Flushed CSS variables for accent color.`
          );
        }
        async _applyStarryNightSettings(gradientIntensity, starDensity) {
          try {
            applyStarryNightSettings(gradientIntensity, starDensity);
          } catch (error) {
            console.error("[Year3000System] Failed to apply starry night settings");
          }
        }
        applyColorsToTheme(extractedColors = {}) {
          let harmonizedColors = extractedColors;
          if (this.colorHarmonyEngine) {
            try {
              harmonizedColors = this.colorHarmonyEngine.blendWithCatppuccin(extractedColors);
            } catch (error) {
              console.error(
                "[Year3000System] ColorHarmonyEngine blend failed:",
                error
              );
            }
          }
          const accentHex = harmonizedColors.accentHex || harmonizedColors.VIBRANT || harmonizedColors.PROMINENT || Object.values(harmonizedColors)[0] || "#37416b";
          const accentRgb = harmonizedColors.accentRgb || (() => {
            const rgb = this.utils.hexToRgb(accentHex);
            return rgb ? `${rgb.r},${rgb.g},${rgb.b}` : "166,173,200";
          })();
          this._applyColorsViaFacadeSystem(
            harmonizedColors,
            accentHex,
            accentRgb
          );
        }
        /**
         * Handle colors:harmonized event from ColorHarmonyEngine (Event-driven architecture)
         * 🔧 PHASE 1: Enhanced with loop prevention and recursion protection
         */
        handleColorHarmonizedEvent(data) {
          if (this.colorEventState.isProcessingColorEvent) {
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.warn(
                "\u{1F504} [Year3000System] Already processing color event - skipping to prevent recursion"
              );
            }
            return;
          }
          const eventContext = JSON.stringify(data).substring(0, 100);
          const eventHash = this._generateEventHash(eventContext);
          const now = Date.now();
          if (this.colorEventState.processedEvents.has(eventHash)) {
            const lastProcessed = this.colorEventState.processedEvents.get(eventHash);
            if (now - lastProcessed < this.COLOR_EVENT_CACHE_TTL) {
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.warn(
                  "\u{1F504} [Year3000System] Event recently processed - skipping duplicate"
                );
              }
              return;
            }
          }
          this.colorEventState.isProcessingColorEvent = true;
          this.colorEventState.processedEvents.set(eventHash, now);
          this.colorEventState.eventTimeout = window.setTimeout(() => {
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.warn(
                "\u{1F504} [Year3000System] Color event processing timeout - resetting state"
              );
            }
            this._resetColorEventState();
          }, this.PROCESSING_TIMEOUT);
          try {
            this.processingState.processingChain.push("handleColorHarmonizedEvent");
            if (this.processingState.processingChain.length > this.MAX_CHAIN_LENGTH) {
              this.processingState.eventLoopDetected = true;
              console.error(
                "\u{1F504} [Year3000System] CRITICAL: Event loop detected - chain length exceeded",
                this.processingState.processingChain
              );
              this._resetProcessingState();
              return;
            }
            let processedColors;
            let accentHex;
            let accentRgb;
            let strategies;
            let processingTime;
            if (data.processedColors && data.accentHex && data.accentRgb) {
              processedColors = data.processedColors;
              accentHex = data.accentHex;
              accentRgb = data.accentRgb;
              strategies = data.strategies || ["ColorHarmonyEngine"];
              processingTime = data.processingTime || 0;
            } else if (data.payload && data.payload.processedColors) {
              processedColors = data.payload.processedColors;
              accentHex = data.payload.accentHex || Object.values(processedColors)[0] || "#a6adc8";
              accentRgb = this.utils.hexToRgb(accentHex)?.r + "," + this.utils.hexToRgb(accentHex)?.g + "," + this.utils.hexToRgb(accentHex)?.b || "166,173,200";
              strategies = [data.payload.metadata?.strategy || "Unknown"];
              processingTime = data.payload.metadata?.processingTime || 0;
            } else if (data.type === "colors/harmonized") {
              return;
            } else {
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.warn(
                  "\u{1F3A8} [Year3000System] Unrecognized colors:harmonized event format:",
                  data
                );
              }
              return;
            }
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Processing colors:harmonized event:", {
                strategies,
                processingTime,
                colorsCount: Object.keys(processedColors).length,
                accentHex,
                accentRgb,
                chainLength: this.processingState.processingChain.length
              });
            }
            this._applyColorsViaFacadeSystem(processedColors, accentHex, accentRgb);
          } catch (error) {
            console.error(
              "[Year3000System] Failed to handle colors:harmonized event:",
              error
            );
          } finally {
            this._resetColorEventState();
            const chainIndex = this.processingState.processingChain.indexOf(
              "handleColorHarmonizedEvent"
            );
            if (chainIndex > -1) {
              this.processingState.processingChain.splice(chainIndex, 1);
            }
          }
        }
        /**
         * Phase 1: Helper method to generate simple hash for event caching
         */
        _generateEventHash(context) {
          let hash = 0;
          for (let i = 0; i < context.length; i++) {
            const char = context.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
          }
          return hash.toString();
        }
        /**
         * Phase 1: Reset color event processing state
         */
        _resetColorEventState() {
          this.colorEventState.isProcessingColorEvent = false;
          if (this.colorEventState.eventTimeout) {
            clearTimeout(this.colorEventState.eventTimeout);
            this.colorEventState.eventTimeout = null;
          }
          const now = Date.now();
          for (const [
            hash,
            timestamp
          ] of this.colorEventState.processedEvents.entries()) {
            if (now - timestamp > this.COLOR_EVENT_CACHE_TTL) {
              this.colorEventState.processedEvents.delete(hash);
            }
          }
        }
        /**
         * Phase 1: Reset processing state after loop detection or timeout
         */
        _resetProcessingState() {
          this.processingState.isProcessingSongChange = false;
          this.processingState.processingChain = [];
          this.processingState.eventLoopDetected = false;
          this.processingState.lastProcessingTime = Date.now();
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log("\u{1F504} [Year3000System] Processing state reset");
          }
        }
        /**
         * Apply colors via delegation to CSS authority systems
         * Delegates Spicetify variables to ColorStateManager and DynamicCatppuccinBridge
         */
        _applyColorsViaFacadeSystem(processedColors, accentHex, accentRgb) {
          try {
            const cssVariables = {};
            Object.entries(processedColors).forEach(([key, value]) => {
              if (this.utils.isValidHexColor(value)) {
                const rgb = this.utils.hexToRgb(value);
                if (rgb) {
                  cssVariables[`--sn-processed-${key.toLowerCase()}-hex`] = value;
                  cssVariables[`--sn-processed-${key.toLowerCase()}-rgb`] = `${rgb.r},${rgb.g},${rgb.b}`;
                }
              } else if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.debug(
                  `[Year3000System] Skipping non-hex processedColor: ${key}=${value}`
                );
              }
            });
            const musicalHarmonyMapping = {
              // Musical harmony RGB variables for OKLAB color science integration
              "--sn-musical-harmony-primary-rgb": processedColors.VIBRANT || processedColors.PRIMARY || accentRgb,
              "--sn-musical-harmony-secondary-rgb": processedColors.DARK_VIBRANT || processedColors.SECONDARY || accentRgb,
              "--sn-musical-harmony-tertiary-rgb": processedColors.VIBRANT_NON_ALARMING || processedColors.LIGHT_VIBRANT || accentRgb,
              "--sn-musical-harmony-quaternary-rgb": processedColors.DESATURATED || processedColors.EMOTIONAL_BLEND || accentRgb,
              // Musical harmony hex variables for gradient systems
              "--sn-musical-harmony-primary-hex": processedColors.VIBRANT || processedColors.PRIMARY || accentHex,
              "--sn-musical-harmony-secondary-hex": processedColors.DARK_VIBRANT || processedColors.SECONDARY || accentHex,
              "--sn-musical-harmony-tertiary-hex": processedColors.VIBRANT_NON_ALARMING || processedColors.LIGHT_VIBRANT || accentHex,
              "--sn-musical-harmony-quaternary-hex": processedColors.DESATURATED || processedColors.EMOTIONAL_BLEND || accentHex,
              // OKLAB processing results for color science systems
              "--sn-musical-oklab-primary-rgb": processedColors.VIBRANT || processedColors.PRIMARY || processedColors.PROMINENT || accentRgb,
              "--sn-musical-oklab-accent-rgb": processedColors.DARK_VIBRANT || processedColors.DESATURATED || accentRgb,
              "--sn-musical-oklab-highlight-rgb": processedColors.VIBRANT_NON_ALARMING || processedColors.LIGHT_VIBRANT || accentRgb,
              "--sn-musical-oklab-shadow-rgb": processedColors.DARK_VIBRANT || processedColors.DESATURATED || accentRgb,
              "--sn-musical-oklab-complementary-rgb": processedColors.SECONDARY || processedColors.EMOTIONAL_BLEND || accentRgb,
              "--sn-musical-oklab-triadic-rgb": processedColors.LIGHT_VIBRANT || processedColors.VIBRANT_NON_ALARMING || accentRgb
            };
            Object.entries(musicalHarmonyMapping).forEach(([cssVar, colorValue]) => {
              if (!colorValue || typeof colorValue !== "string") return;
              if (cssVar.includes("-hex")) {
                cssVariables[cssVar] = colorValue;
              } else if (cssVar.includes("-rgb")) {
                if (this.utils.isValidHexColor(colorValue)) {
                  const rgb = this.utils.hexToRgb(colorValue);
                  if (rgb) {
                    cssVariables[cssVar] = `${rgb.r},${rgb.g},${rgb.b}`;
                  }
                } else if (colorValue.includes(",")) {
                  cssVariables[cssVar] = colorValue;
                }
              }
            });
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Musical Harmony Color Processing:", {
                // ColorHarmonyEngine output
                colorHarmonyKeys: Object.keys(processedColors),
                colorHarmonyValues: processedColors,
                // Musical harmony bridge variables (specialized for OKLAB)
                musicalHarmonyVariables: musicalHarmonyMapping,
                // CSS variable chain status
                expectedCSSChain: [
                  "--sn-musical-oklab-primary-rgb",
                  "--sn-musical-harmony-primary-rgb",
                  "--sn-gradient-primary-rgb"
                ],
                // Note: Spicetify variables handled by CSS authority systems
                totalVariablesSet: Object.keys(cssVariables).length,
                cssAuthorityDelegation: "ColorStateManager + DynamicCatppuccinBridge"
              });
            }
            if (this.cssVariableController && typeof this.cssVariableController.batchSetVariables === "function") {
              this.cssVariableController.batchSetVariables(
                "Year3000System-ColorHarmonized",
                cssVariables,
                "high",
                "color-harmony-event-application"
              );
            } else {
              this._applyCSSVariables(cssVariables);
            }
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log("\u{1F527} [Year3000System] Applied musical harmony variables via CSS coordination:", {
                totalVariables: Object.keys(cssVariables).length,
                accentColor: accentHex,
                cssControllerUsed: !!this.cssVariableController,
                spicetifyDelegation: "ColorStateManager + DynamicCatppuccinBridge handle --spice-* variables"
              });
            }
          } catch (error) {
            console.error(
              "[Year3000System] Failed to apply musical harmony variables:",
              error
            );
            const fallbackVariables = {
              "--sn-musical-harmony-primary-hex": accentHex,
              "--sn-musical-harmony-primary-rgb": accentRgb
            };
            this._applyCSSVariables(fallbackVariables);
          }
        }
        /**
         * Apply CSS variables directly (optimization for event-driven pattern)
         */
        _applyCSSVariables(cssVariables) {
          try {
            const root = document.documentElement;
            for (const [variable, value] of Object.entries(cssVariables)) {
              if (variable && value) {
                root.style.setProperty(variable, value);
              }
            }
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log("\u{1F3A8} [Year3000System] Applied CSS variables directly", {
                variablesCount: Object.keys(cssVariables).length,
                variables: Object.keys(cssVariables)
              });
            }
          } catch (error) {
            console.error("[Year3000System] Failed to apply CSS variables:", error);
          }
        }
        // =============================================
        // 🎨 LEGACY METHOD REMOVED: _applyHarmonizedColorsToCss()
        // Replaced by comprehensive OKLAB-enabled _applyColorsViaFacadeSystem()
        // =============================================
        // =============================================
        // 🆕 PUBLIC WRAPPER – UNIFIED CSS VARIABLE BATCH API
        // =============================================
        /**
         * Queue a CSS variable update through the shared UnifiedCSSVariableManager. Falls
         * back to an immediate style mutation when the batcher is unavailable
         * (degraded mode or very early boot).
         *
         * @param property  The CSS custom property name (e.g. "--sn-nav-intensity")
         * @param value     The value to assign (raw string, keep units if needed)
         * @param element   Optional specific HTMLElement target. When omitted the
         *                  root <html> element is used so variables cascade.
         */
        queueCSSVariableUpdate(property, value, element = null) {
          if (this.unifiedCSSManager) {
            this.unifiedCSSManager.queueUpdate(
              property,
              value,
              "normal",
              "Year3000System"
            );
          } else if (this.cssVariableController) {
            this.cssVariableController.queueCSSVariableUpdate(
              property,
              value,
              element || void 0
            );
          } else {
            const target = element || document.documentElement;
            target.style.setProperty(property, value);
          }
        }
        setGradientParameters() {
          if (this.colorHarmonyEngine) {
          }
        }
        async updateColorsFromCurrentTrack() {
          if (this.musicSyncService) {
            await this.musicSyncService.processSongUpdate();
          }
        }
        evolveHarmonicSignature(selectedModeKey, baseSourceHex) {
          if (this.colorHarmonyEngine) {
            const rgb = this.utils.hexToRgb(baseSourceHex);
            if (rgb) {
              const variations = this.colorHarmonyEngine.generateHarmonicVariations(rgb);
              return {
                derivedDarkVibrantHex: variations.darkVibrantHex,
                derivedLightVibrantHex: variations.lightVibrantHex
              };
            }
          }
          return null;
        }
        async waitForTrackData(maxRetries = 10, delayMs = 100) {
          for (let i = 0; i < maxRetries; i++) {
            if (Spicetify.Player.data?.track?.uri) {
              return Spicetify.Player.data;
            }
            await this.utils.sleep(delayMs);
          }
          return null;
        }
        updateHarmonicBaseColor(hexColor) {
          if (this.colorHarmonyEngine && this.cssVariableController) {
            const rgb = this.utils.hexToRgb(hexColor);
            if (rgb) {
              const variations = this.colorHarmonyEngine.generateHarmonicVariations(rgb);
              this.cssVariableController.queueCSSVariableUpdate(
                "--sn-harmonic-base-dark-vibrant",
                variations.darkVibrantHex
              );
              this.cssVariableController.queueCSSVariableUpdate(
                "--sn-harmonic-base-light-vibrant",
                variations.lightVibrantHex
              );
              this.cssVariableController.flushCSSVariableBatch();
            }
          }
        }
        /**
         * Process colors through the existing facade pattern architecture
         * Phase 1: Integration with SystemCoordinator and ColorOrchestrator
         */
        async processColorsViaFacade(context) {
          try {
            const colorOrchestrator = await this.facadeCoordinator?.getNonVisualSystem("ColorOrchestrator");
            if (colorOrchestrator && typeof colorOrchestrator.handleColorExtraction === "function") {
              await colorOrchestrator.handleColorExtraction(context);
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log(
                  "\u{1F3A8} [Year3000System] Color processing routed through facade pattern - ColorOrchestrator",
                  {
                    context: context?.trackUri || "unknown",
                    rawColorsCount: context?.rawColors ? Object.keys(context.rawColors).length : 0
                  }
                );
              }
            } else {
              if (this.colorHarmonyEngine && typeof this.colorHarmonyEngine.processColors === "function") {
                await this.colorHarmonyEngine.processColors(context);
                if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                  console.log(
                    "\u{1F3A8} [Year3000System] Color processing fallback to direct ColorHarmonyEngine"
                  );
                }
              } else {
                console.warn(
                  "[Year3000System] No color processing system available via facade pattern"
                );
              }
            }
          } catch (error) {
            console.error(
              "[Year3000System] Failed to process colors via facade pattern:",
              error
            );
            if (context?.rawColors) {
              this.applyColorsToTheme(context.rawColors);
            }
          }
        }
        setupMusicAnalysisAndColorExtraction() {
          console.log(
            "\u{1F3B5} [Year3000System] setupMusicAnalysisAndColorExtraction called"
          );
          if (!this.musicSyncService) {
            console.error(
              "[Year3000System] MusicSyncService is not available to set up song change handler."
            );
            return;
          }
          console.log(
            "\u{1F3B5} [Year3000System] MusicSyncService available, checking Spicetify Player..."
          );
          if (!window.Spicetify?.Player) {
            console.warn(
              "[Year3000System] Spicetify.Player not available - music analysis disabled"
            );
            return;
          }
          try {
            unifiedEventBus.subscribe(
              "colors:harmonized",
              (data) => {
                this.handleColorHarmonizedEvent(data);
              },
              "Year3000System"
            );
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log(
                "\u{1F3A8} [Year3000System] Subscribed to colors:harmonized events for event-driven color application"
              );
            }
          } catch (error) {
            console.error(
              "[Year3000System] Failed to subscribe to colors:harmonized events:",
              error
            );
          }
          const processSongUpdate = /* @__PURE__ */ __name(async () => {
            console.log(
              "\u{1F3B5} [Year3000System] processSongUpdate triggered - checking MusicSyncService..."
            );
            if (this.musicSyncService) {
              console.log(
                "\u{1F3B5} [Year3000System] Calling musicSyncService.processSongUpdate()"
              );
              await this.musicSyncService.processSongUpdate();
              console.log(
                "\u2705 [Year3000System] musicSyncService.processSongUpdate() completed"
              );
            } else {
              console.error(
                "\u274C [Year3000System] MusicSyncService not available in processSongUpdate"
              );
            }
          }, "processSongUpdate");
          this._songChangeHandler = processSongUpdate;
          try {
            console.log("\u{1F3B5} [Year3000System] Adding songchange event listener...");
            window.Spicetify.Player.addEventListener(
              "songchange",
              this._songChangeHandler
            );
            console.log(
              "\u2705 [Year3000System] Music analysis and color extraction set up successfully - song change listener active"
            );
            console.log("\u{1F3B5} [Year3000System] Triggering initial song processing...");
            setTimeout(processSongUpdate, 1e3);
          } catch (error) {
            console.error("[Year3000System] Failed to set up music analysis:", error);
            this._songChangeHandler = null;
          }
        }
        updateFromMusicAnalysis(processedData, rawFeatures, trackUri) {
          if (!processedData) return;
          this._updateGlobalKinetics(processedData);
        }
        _updateGlobalKinetics(data) {
          const root = this.utils.getRootStyle();
          if (!root) return;
          const safe = /* @__PURE__ */ __name((value, fallback = 0) => Number.isFinite(value) ? value : fallback, "safe");
          const processedEnergy = safe(data.processedEnergy);
          const valence = safe(data.valence);
          const enhancedBPM = safe(data.enhancedBPM);
          const beatInterval = safe(data.beatInterval);
          const animationSpeed = safe(data.animationSpeedFactor, 1);
          root.style.setProperty("--sn-kinetic-energy", processedEnergy.toFixed(3));
          root.style.setProperty("--sn-kinetic-valence", valence.toFixed(3));
          root.style.setProperty("--sn-kinetic-bpm", enhancedBPM.toFixed(2));
          root.style.setProperty(
            "--sn-kinetic-beat-interval",
            `${beatInterval.toFixed(0)}ms`
          );
          root.style.setProperty(
            "--sn-kinetic-animation-speed",
            animationSpeed.toFixed(3)
          );
        }
        // Animation System Registration Methods
        registerAnimationSystem(name, system, priority = "normal", targetFPS = 60) {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              `[Year3000System] Cannot register ${name} - EnhancedMasterAnimationCoordinator not ready`
            );
            return false;
          }
          this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
            name,
            system,
            priority,
            targetFPS
          );
          return true;
        }
        unregisterAnimationSystem(name) {
          if (!this.enhancedMasterAnimationCoordinator) {
            return false;
          }
          this.enhancedMasterAnimationCoordinator.unregisterAnimationSystem(name);
          return true;
        }
        /**
         * Public accessor that returns a subsystem instance by its constructor name or
         * by the conventional camel-cased property key. This is primarily used for
         * loose coupling between visual systems (e.g. BehaviouralPredictionEngine ⇆
         * PredictiveMaterializationSystem). Returns `null` when the requested system
         * is not available or not yet initialised.
         */
        getSystem(name) {
          if (!name) return null;
          if (this.facadeCoordinator) {
            const visualSystem2 = this.facadeCoordinator.getVisualSystem(name);
            if (visualSystem2) return visualSystem2;
            const nonVisualSystem = this.facadeCoordinator.getCachedNonVisualSystem(
              name
            );
            if (nonVisualSystem) return nonVisualSystem;
          }
          const camel = name.charAt(0).toLowerCase() + name.slice(1);
          if (this[camel]) return this[camel];
          for (const key of Object.keys(this)) {
            const maybeInstance = this[key];
            if (maybeInstance && maybeInstance.constructor?.name === name) {
              return maybeInstance;
            }
          }
          return null;
        }
        /**
         * Get health status of all facade systems
         */
        async getFacadeSystemHealthStatus() {
          if (!this.facadeCoordinator) return null;
          return await this.facadeCoordinator.performHealthCheck();
        }
        async _registerAnimationSystems() {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for visual system registration"
            );
            return;
          }
          const visualSystems = [
            {
              name: "BeatSyncVisualSystem",
              system: this.beatSyncVisualSystem,
              priority: "critical"
            },
            // EmergentChoreographyEngine consolidated into EnhancedMasterAnimationCoordinator
            {
              name: "SidebarSystemsIntegration",
              system: this.sidebarSystemsIntegration,
              priority: "normal"
            },
            {
              name: "ParticleConsciousnessModule",
              system: this.particleVisualEffectsModule,
              priority: "background"
            },
            {
              name: "InteractionTrackingSystem",
              system: this.interactionTrackingSystem,
              priority: "background"
            },
            {
              name: "SpotifyUIApplicationSystem",
              system: this.spotifyUIApplicationSystem,
              priority: "normal"
            }
          ];
          for (const { name, system, priority } of visualSystems) {
            if (system && (typeof system.onAnimate === "function" || typeof system.updateAnimation === "function")) {
              let optimizedPriority = priority;
              let targetFPS = 60;
              const currentProfile = system.currentPerformanceProfile;
              if (currentProfile?.frameRate) {
                targetFPS = currentProfile.frameRate;
              } else if (currentProfile?.quality) {
                const quality = currentProfile.quality;
                targetFPS = quality === "high" ? 60 : quality === "low" ? 30 : 45;
              }
              if (name.includes("BeatSync")) {
                optimizedPriority = "critical";
              } else if (name.includes("Particle") || name.includes("DataGlyph")) {
                optimizedPriority = "background";
                targetFPS = Math.min(targetFPS, 30);
              }
              this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
                name,
                system,
                optimizedPriority,
                targetFPS
              );
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log(
                  `\u{1F3AC} [Year3000System] Registered ${name} with Enhanced Master Animation Coordinator (${optimizedPriority} priority, ${targetFPS}fps) - using ${typeof system.onAnimate === "function" ? "onAnimate" : "updateAnimation"} hook`
                );
              }
            }
          }
        }
        /**
         * Register visual systems with the EnhancedMasterAnimationCoordinator
         * Phase 4: Animation System Consolidation
         */
        async _registerEnhancedAnimationSystems() {
          if (!this.enhancedMasterAnimationCoordinator) {
            console.warn(
              "[Year3000System] EnhancedMasterAnimationCoordinator not available for enhanced visual system registration"
            );
            return;
          }
          const enhancedVisualSystems = [
            {
              name: "BeatSyncVisualSystem",
              system: this.beatSyncVisualSystem,
              priority: "critical",
              type: "animation"
            },
            // EmergentChoreographyEngine consolidated into EnhancedMasterAnimationCoordinator
            {
              name: "SidebarSystemsIntegration",
              system: this.sidebarSystemsIntegration,
              priority: "normal",
              type: "animation"
            },
            {
              name: "ParticleConsciousnessModule",
              system: this.particleVisualEffectsModule,
              priority: "background",
              type: "animation"
            },
            {
              name: "InteractionTrackingSystem",
              system: this.interactionTrackingSystem,
              priority: "background",
              type: "animation"
            },
            {
              name: "SpotifyUIApplicationSystem",
              system: this.spotifyUIApplicationSystem,
              priority: "normal",
              type: "animation"
            }
          ];
          for (const { name, system, priority, type } of enhancedVisualSystems) {
            if (system) {
              try {
                let registered = false;
                if (type === "animation" && (typeof system.onAnimate === "function" || typeof system.updateAnimation === "function")) {
                  registered = this.enhancedMasterAnimationCoordinator.registerAnimationSystem(
                    name,
                    system,
                    priority,
                    60
                    // Default 60fps
                  );
                }
                if (registered && this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                  console.log(
                    `\u{1F3AC} [Year3000System] Enhanced registration: ${name} (${priority} priority, ${type} type)`
                  );
                } else if (!registered) {
                  console.warn(
                    `[Year3000System] Failed to register ${name} with EnhancedMasterAnimationCoordinator`
                  );
                }
              } catch (error) {
                console.error(
                  `[Year3000System] Error registering ${name} with EnhancedMasterAnimationCoordinator:`,
                  error
                );
              }
            }
          }
        }
        // Progressive Loading Methods for Extension Support
        async initializeWithAvailableAPIs(availableAPIs) {
          this.availableAPIs = availableAPIs;
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              `\u{1F31F} [Year3000System] Progressive initialization mode: ${availableAPIs.degradedMode ? "DEGRADED" : "FULL"}`
            );
            console.log(`\u{1F31F} [Year3000System] Available APIs:`, {
              player: !!availableAPIs.player,
              platform: !!availableAPIs.platform,
              config: !!availableAPIs.config
            });
          }
          if (availableAPIs.degradedMode) {
            console.log(
              "\u{1F31F} [Year3000System] Initializing in degraded mode (visual-only systems)"
            );
            await this.initializeVisualOnlySystems();
          } else {
            console.log(
              "\u{1F31F} [Year3000System] Initializing in full mode (all systems)"
            );
            await this.initializeAllSystems();
          }
          if (availableAPIs.degradedMode) {
            this.setupProgressiveEnhancement();
          }
        }
        async initializeVisualOnlySystems() {
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Starting visual-only system initialization..."
            );
          }
          const startTime = performance.now();
          const initializationResults = {
            success: [],
            failed: [],
            skipped: []
          };
          try {
            this.facadeCoordinator = new SystemCoordinator(
              this.ADVANCED_SYSTEM_CONFIG,
              this.utils,
              this
            );
            await this.facadeCoordinator.initialize({
              mode: "performance-optimized",
              enableSharedDependencies: true,
              enableCrossFacadeCommunication: false,
              enableUnifiedPerformanceMonitoring: true,
              enableResourceOptimization: true,
              performanceThresholds: {
                maxTotalMemoryMB: 50,
                maxTotalInitTime: 3e3,
                maxCrossCommLatency: 100
              },
              coordinationPreferences: {
                preferSharedResources: true,
                enableEventPropagation: false,
                enableHealthCoordination: true
              }
            });
            await this._initializeEssentialFacadeSystems();
            initializationResults.success.push("FacadeCoordinationSystem");
          } catch (error) {
            console.error(
              "\u{1F30C} [Year3000System] Failed to initialize degraded facade system:",
              error
            );
            initializationResults.failed.push("FacadeCoordinationSystem");
          }
          const skippedSystems = [
            "SettingsManager",
            "MusicSyncService",
            "ColorHarmonyEngine",
            "GlassmorphismManager",
            "Card3DManager",
            "All Visual Systems"
          ];
          initializationResults.skipped.push(...skippedSystems);
          this._initializationResults = initializationResults;
          this.initialized = true;
          const endTime = performance.now();
          const initTime = endTime - startTime;
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              `\u{1F31F} [Year3000System] Visual-only initialization complete in ${initTime.toFixed(
                2
              )}ms`
            );
            console.log(
              `\u{1F31F} [Year3000System] Results: ${initializationResults.success.length} success, ${initializationResults.failed.length} failed, ${initializationResults.skipped.length} skipped`
            );
          }
        }
        setupProgressiveEnhancement() {
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Setting up progressive enhancement monitoring..."
            );
          }
          let enhancementAttempts = 0;
          const maxEnhancementAttempts = 30;
          const enhancementInterval = setInterval(() => {
            enhancementAttempts++;
            const playerAvailable = !!window.Spicetify?.Player;
            const platformAvailable = !!window.Spicetify?.Platform;
            if (playerAvailable && platformAvailable && this.availableAPIs?.degradedMode) {
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log(
                  "\u{1F31F} [Year3000System] APIs now available! Triggering upgrade to full mode..."
                );
              }
              clearInterval(enhancementInterval);
              this.upgradeToFullMode().catch((error) => {
                console.error("[Year3000System] Upgrade to full mode failed:", error);
              });
            }
            if (enhancementAttempts >= maxEnhancementAttempts) {
              if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log(
                  "\u{1F31F} [Year3000System] Progressive enhancement monitoring stopped (timeout)"
                );
              }
              clearInterval(enhancementInterval);
            }
          }, 2e3);
        }
        async upgradeToFullMode() {
          if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
            console.log(
              "\u{1F31F} [Year3000System] Upgrading from degraded mode to full mode..."
            );
          }
          this.availableAPIs = {
            player: window.Spicetify?.Player,
            platform: window.Spicetify?.Platform,
            config: window.Spicetify?.Config,
            degradedMode: false
          };
          try {
            const upgradeResults = {
              success: [],
              failed: [],
              skipped: []
            };
            try {
              if (this.systemHealthMonitor) {
                this.systemHealthMonitor.registerSystem(
                  "SettingsManager",
                  this.settingsManager
                );
              }
              upgradeResults.success.push("SettingsManager");
            } catch (error) {
              upgradeResults.failed.push("SettingsManager");
              console.error(
                `[Year3000System] Failed to upgrade SettingsManager:`,
                error
              );
            }
            if (this.settingsManager) {
              try {
              } catch (error) {
              }
            }
            if (this.performanceAnalyzer && this.settingsManager) {
              try {
              } catch (error) {
              }
              if (this.enhancedMasterAnimationCoordinator) {
                await this._registerAnimationSystems();
              }
            }
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log(
                "[Year3000System] Checking music analysis setup conditions:",
                {
                  musicSyncService: !!this.musicSyncService,
                  playerAPI: !!this.availableAPIs.player,
                  musicSyncInitialized: this.musicSyncService?.initialized
                }
              );
            }
            if (this.musicSyncService && this.availableAPIs.player) {
              console.log(
                "\u{1F3B5} [Year3000System] Setting up music analysis and color extraction..."
              );
              this.setupMusicAnalysisAndColorExtraction();
            } else {
              console.warn(
                "\u26A0\uFE0F [Year3000System] Music analysis setup skipped - missing dependencies:",
                {
                  musicSyncService: !!this.musicSyncService,
                  playerAPI: !!this.availableAPIs.player
                }
              );
            }
            if (this.settingsManager) {
              await this.applyInitialSettings();
            }
            if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log(
                `\u{1F31F} [Year3000System] Upgrade complete: ${upgradeResults.success.length} success, ${upgradeResults.failed.length} failed`
              );
              if (upgradeResults.failed.length > 0) {
                console.warn(
                  `\u{1F31F} [Year3000System] Upgrade failed systems: ${upgradeResults.failed.join(
                    ", "
                  )}`
                );
              }
              if (upgradeResults.skipped && upgradeResults.skipped.length > 0) {
                console.info(
                  `\u{1F31F} [Year3000System] Upgrade skipped systems: ${upgradeResults.skipped.join(
                    ", "
                  )}`
                );
              }
              if (upgradeResults.success.length > 0) {
                console.info(
                  `\u{1F31F} [Year3000System] Upgrade successful systems: ${upgradeResults.success.join(
                    ", "
                  )}`
                );
              }
            }
          } catch (error) {
            console.error(
              "[Year3000System] Error during upgrade to full mode:",
              error
            );
          }
        }
        _handleExternalSettingsChange(event) {
          const { key, value } = event.detail || {};
          if (!key) return;
          switch (key) {
            case "artisticMode": {
              try {
                if (typeof this.ADVANCED_SYSTEM_CONFIG.safeSetArtisticMode === "function") {
                  this.ADVANCED_SYSTEM_CONFIG.safeSetArtisticMode(value);
                }
              } catch (e) {
                console.warn("[Year3000System] Failed to apply artistic mode", e);
              }
              break;
            }
            case "harmonicIntensity": {
              const num = parseFloat(value);
              if (!Number.isNaN(num)) {
                this.ADVANCED_SYSTEM_CONFIG.colorHarmonyIntensity = num;
                if (this.colorHarmonyEngine) {
                  this.colorHarmonyEngine.setIntensity?.(num);
                  this.updateColorsFromCurrentTrack?.();
                }
              }
              break;
            }
            case "harmonicEvolution": {
              const enabled = value === "true" || value === true;
              this.allowHarmonicEvolution = enabled;
              this.ADVANCED_SYSTEM_CONFIG.colorHarmonyEvolution = enabled;
              break;
            }
            case "manualBaseColor": {
              if (typeof value === "string" && value.trim() !== "" && value.startsWith("#")) {
                this.updateHarmonicBaseColor(value);
                if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                  console.log(
                    "\u{1F3A8} [Year3000System] Manual base color applied:",
                    value
                  );
                }
              } else if (this.ADVANCED_SYSTEM_CONFIG.enableDebug) {
                console.log(
                  "\u{1F3A8} [Year3000System] Manual base color cleared - using album art colors"
                );
              }
              break;
            }
            case "harmonicMode": {
              if (value !== null && value !== void 0) {
                this.ADVANCED_SYSTEM_CONFIG.currentColorHarmonyMode = String(value);
                this.updateColorsFromCurrentTrack?.();
              }
              break;
            }
            default:
              break;
          }
          this._broadcastSettingChange(key, value);
          this._refreshConditionalSystems();
        }
        /**
         * Notify all subsystems that implement applyUpdatedSettings so they can
         * adjust behaviour immediately after a SettingsManager change.
         */
        _broadcastSettingChange(key, value) {
          const systems = [
            this.colorHarmonyEngine,
            this.glassmorphismManager,
            this.card3DManager,
            this.lightweightParticleSystem,
            this.interactionTrackingSystem,
            this.beatSyncVisualSystem,
            this.sidebarSystemsIntegration,
            this.particleFieldSystem
            // contextMenuSystem removed
          ];
          systems.forEach((sys) => {
            if (sys && typeof sys.applyUpdatedSettings === "function") {
              try {
                sys.applyUpdatedSettings(key, value);
              } catch (err) {
                console.warn(
                  `[Year3000System] ${sys.systemName || sys.constructor?.name || "UnknownSystem"} failed to applyUpdatedSettings`,
                  err
                );
              }
            }
          });
        }
        // ---------------------------------------------------------------------------
        // 🔧  Placeholder implementations restored after merge conflict
        // ---------------------------------------------------------------------------
        /**
         * Apply the current performance profile to subsystems.
         * NOTE: Full implementation was lost in a previous edit; this stub preserves
         *        compile-time integrity until the original logic is reinstated.
         */
        _applyPerformanceProfile() {
        }
        /**
         * Refresh conditional visual systems (WebGL, ParticleField, etc.) depending
         * on capability and artistic mode settings.
         */
        _refreshConditionalSystems() {
        }
        /**
         * Handle artistic-mode changes by triggering a colour refresh.
         */
        _onArtisticModeChanged() {
          try {
            this.updateColorsFromCurrentTrack?.();
          } catch (e) {
            console.warn("[Year3000System] _onArtisticModeChanged stub error", e);
          }
        }
        _handleVisibilityChange() {
          if (document.visibilityState !== "hidden") return;
          try {
            this.cssVariableController?.flushCSSVariableBatch?.();
            try {
            } catch {
            }
            if (this.ADVANCED_SYSTEM_CONFIG?.enableDebug) {
              console.log(
                "\u{1F31F} [Year3000System] Visibility hidden \u2192 forced flush of pending style updates"
              );
            }
          } catch (e) {
            if (this.ADVANCED_SYSTEM_CONFIG?.enableDebug) {
              console.warn("[Year3000System] VisibilityChange flush error", e);
            }
          }
        }
        /**
         * Destroy method for proper cleanup during testing
         */
        async destroy() {
          try {
            await this.destroyAllSystems();
            document.removeEventListener(
              "visibilitychange",
              this._handleVisibilityChange.bind(this)
            );
            this.initialized = false;
            console.log("\u{1F31F} [AdvancedThemeSystem] System destroyed successfully");
          } catch (error) {
            console.error("\u274C [AdvancedThemeSystem] Error during destroy:", error);
          }
        }
      };
      __name(_AdvancedThemeSystem, "AdvancedThemeSystem");
      AdvancedThemeSystem = _AdvancedThemeSystem;
      advancedThemeSystem = new AdvancedThemeSystem();
      if (typeof window !== "undefined") {
        window.advancedThemeSystem = advancedThemeSystem;
        window.year3000System = advancedThemeSystem;
      }
      AdvancedThemeSystem_default = advancedThemeSystem;
    }
  });

  // src-js/debug/DragCartographer.ts
  var DragCartographer_exports = {};
  __export(DragCartographer_exports, {
    enableDragCartography: () => enableDragCartography,
    getDragMap: () => getDragMap
  });
  function enableDragCartography() {
    const g = globalThis;
    if (g.__SN_dragCartographer) return;
    g.__SN_dragCartographer = new DragCartographer();
    console.info("\u{1F6F0}\uFE0F  DragCartographer enabled \u2013 logging dragstart events");
  }
  function getDragMap() {
    return DragCartographer.getDragMap();
  }
  var _DragCartographer, DragCartographer;
  var init_DragCartographer = __esm({
    "src-js/debug/DragCartographer.ts"() {
      "use strict";
      _DragCartographer = class _DragCartographer {
        constructor() {
          this.seen = /* @__PURE__ */ new WeakSet();
          this.handleDragStart = /* @__PURE__ */ __name((event) => {
            const target = event.target;
            if (!target) return;
            if (this.seen.has(target)) return;
            this.seen.add(target);
            const selector = _DragCartographer.buildSelectorPath(target);
            const detail = {
              time: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
              selector
            };
            try {
              const dt = event.dataTransfer;
              if (dt) {
                const uris = dt.getData("text/spotify") || dt.getData("text/uri-list");
                if (uris) {
                  detail.uris = uris.split(/\n|,/).filter(Boolean);
                }
                const label = dt.getData("text/plain");
                if (label) detail.label = label;
              }
            } catch {
            }
            const agg = _DragCartographer.aggregate;
            const entry = agg.get(selector);
            if (entry) {
              entry.count += 1;
              if (entry.samples.length < 3) entry.samples.push(detail);
            } else {
              agg.set(selector, { selector, count: 1, samples: [detail] });
            }
            console.groupCollapsed(
              `%c[DragCartographer] dragstart \u2192 ${selector}`,
              "color:#7dd3fc;font-weight:600"
            );
            console.table(detail);
            console.log("Event:", event);
            console.log("Target element snapshot:", target);
            console.groupEnd();
          }, "handleDragStart");
          document.addEventListener("dragstart", this.handleDragStart, true);
        }
        static buildSelectorPath(el) {
          const path = [];
          let current = el;
          let depth = 0;
          while (current && depth < _DragCartographer.MAX_PATH_DEPTH) {
            const tag = current.tagName.toLowerCase();
            const id = current.id ? `#${current.id}` : "";
            const cls = current.className && typeof current.className === "string" ? "." + current.className.split(/\s+/).slice(0, 2).join(".") : "";
            path.push(`${tag}${id}${cls}`);
            current = current.parentElement;
            depth += 1;
          }
          return path.join(" > ");
        }
        // Public helper to fetch map
        static getDragMap() {
          return Array.from(_DragCartographer.aggregate.values()).sort(
            (a, b) => b.count - a.count
          );
        }
      };
      __name(_DragCartographer, "DragCartographer");
      _DragCartographer.MAX_PATH_DEPTH = 4;
      _DragCartographer.aggregate = /* @__PURE__ */ new Map();
      DragCartographer = _DragCartographer;
      __name(enableDragCartography, "enableDragCartography");
      __name(getDragMap, "getDragMap");
    }
  });

  // src-js/utils/graphics/CanvasGhostBuilder.ts
  function buildDragGhostCanvas(label, imgSrc, opts = {}) {
    const key = `${label}|${imgSrc}|${opts.size}|${opts.dpr}`;
    const cached = cache.get(key);
    if (cached) return cached;
    const size = opts.size ?? 72;
    const dpr = opts.dpr ?? (window.devicePixelRatio || 1);
    const borderRadius = opts.borderRadius ?? 8;
    const canvas = document.createElement("canvas");
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    const ctx = canvas.getContext("2d");
    ctx.scale(dpr, dpr);
    ctx.fillStyle = "rgba(32,32,35,0.9)";
    ctx.roundRect(0, 0, size, size, borderRadius);
    ctx.fill();
    if (opts.shadow !== false) {
      ctx.shadowColor = "rgba(0,0,0,0.4)";
      ctx.shadowBlur = 6;
    }
    const inner = size - 16;
    if (imgSrc) {
      const img = new Image();
      img.src = imgSrc;
      const drawImage = /* @__PURE__ */ __name(() => {
        ctx.save();
        ctx.beginPath();
        ctx.roundRect(8, 8, inner, inner, borderRadius - 2);
        ctx.clip();
        ctx.drawImage(img, 8, 8, inner, inner);
        ctx.restore();
        drawLabel();
      }, "drawImage");
      if (img.complete) {
        drawImage();
      } else {
        img.onload = drawImage;
        img.onerror = drawLabel;
      }
    } else {
      drawLabel();
    }
    function drawLabel() {
      ctx.fillStyle = "#fff";
      ctx.font = `500 12px Inter, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const maxWidth = size - 10;
      let text = label;
      while (ctx.measureText(text).width > maxWidth && text.length > 4) {
        text = text.slice(0, -2);
      }
      if (text !== label) text = text.slice(0, -1) + "\u2026";
      ctx.fillText(text, size / 2, size - 10);
    }
    __name(drawLabel, "drawLabel");
    cache.set(key, canvas);
    return canvas;
  }
  var cache;
  var init_CanvasGhostBuilder = __esm({
    "src-js/utils/graphics/CanvasGhostBuilder.ts"() {
      "use strict";
      cache = /* @__PURE__ */ new Map();
      __name(buildDragGhostCanvas, "buildDragGhostCanvas");
    }
  });

  // src-js/ui/interactions/DragPreviewManager.ts
  var DragPreviewManager_exports = {};
  __export(DragPreviewManager_exports, {
    enableEnhancedDragPreview: () => enableEnhancedDragPreview
  });
  function createGhost(label, imgSrc) {
    try {
      return buildDragGhostCanvas(label, imgSrc);
    } catch {
      const div = document.createElement("div");
      div.textContent = label;
      div.style.padding = "4px 6px";
      div.style.fontSize = "12px";
      div.style.background = "rgba(32,32,35,0.9)";
      div.style.color = "#fff";
      return div;
    }
  }
  function extractImageSrc(el) {
    const img = el.querySelector("img[src]");
    if (img?.src) return img.src;
    const bg = getComputedStyle(el).backgroundImage;
    const match = bg && /url\("?([^\"]+)"?\)/.exec(bg);
    return match ? match[1] : void 0;
  }
  function findFallbackLabel(el) {
    const attrLabel = el.getAttribute("aria-label") || el.getAttribute("title");
    if (attrLabel) return attrLabel;
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
      acceptNode(node) {
        const text = node.textContent?.trim();
        return text ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    const n = walker.nextNode();
    return (n?.textContent?.trim() || "").slice(0, 60);
  }
  function getPreviewData(target) {
    if (cache2.has(target)) return cache2.get(target);
    const label = findFallbackLabel(target);
    if (!label) return null;
    const img = extractImageSrc(target);
    const data = img ? { label, img } : { label };
    cache2.set(target, data);
    return data;
  }
  function onDragStart(event) {
    try {
      if (!event.dataTransfer || typeof event.dataTransfer.setDragImage !== "function")
        return;
      const target = event.target;
      if (!target) return;
      let label = event.dataTransfer.getData("text/plain");
      let imgSrc;
      if (!label) {
        const data = getPreviewData(target);
        if (!data) return;
        label = data.label;
        imgSrc = data.img;
      } else {
        imgSrc = extractImageSrc(target);
      }
      const ghostEl = createGhost(label, imgSrc);
      document.body.appendChild(ghostEl);
      const offset = ghostEl.offsetWidth / 2;
      event.dataTransfer.setDragImage(ghostEl, offset, offset);
      const cleanup = /* @__PURE__ */ __name(() => {
        ghostEl.remove();
        window.removeEventListener("dragend", cleanup, true);
      }, "cleanup");
      window.addEventListener("dragend", cleanup, true);
    } catch (err) {
      console.debug("[StarryNight] DragPreviewManager failed:", err);
    }
  }
  function enableEnhancedDragPreview(opts = {}) {
    const g = globalThis;
    if (g.__SN_enhancedDragPreview) return;
    g.__SN_enhancedDragPreview = true;
    Object.assign(DEFAULT_OPTS, opts);
    document.addEventListener("dragstart", onDragStart, true);
    console.info("\u{1F320} Enhanced drag preview enabled");
  }
  var DEFAULT_OPTS, cache2;
  var init_DragPreviewManager = __esm({
    "src-js/ui/interactions/DragPreviewManager.ts"() {
      "use strict";
      init_CanvasGhostBuilder();
      DEFAULT_OPTS = {
        size: 72,
        borderRadius: 8,
        fontSize: 12
      };
      cache2 = /* @__PURE__ */ new WeakMap();
      __name(createGhost, "createGhost");
      __name(extractImageSrc, "extractImageSrc");
      __name(findFallbackLabel, "findFallbackLabel");
      __name(getPreviewData, "getPreviewData");
      __name(onDragStart, "onDragStart");
      __name(enableEnhancedDragPreview, "enableEnhancedDragPreview");
    }
  });

  // src-js/utils/animation/flipSpring.ts
  function spring(config) {
    const k = config.stiffness ?? 260;
    const d = config.damping ?? 24;
    const m = config.mass ?? 1;
    let current = {};
    let velocity = {};
    let target = {};
    let animId = null;
    function step() {
      let done = true;
      const dt = 1 / 60;
      for (const key in target) {
        const x = current[key] ?? 0;
        const v = velocity[key] ?? 0;
        const goal = target[key] ?? 0;
        const Fspring = -k * (x - goal);
        const Fdamp = -d * v;
        const a = (Fspring + Fdamp) / m;
        const newV = v + a * dt;
        const newX = x + newV * dt;
        velocity[key] = newV;
        current[key] = newX;
        if (Math.abs(newV) > 0.1 || Math.abs(newX - goal) > 0.1) done = false;
      }
      config.onUpdate(current);
      if (!done) animId = requestAnimationFrame(step);
    }
    __name(step, "step");
    return {
      to(newTarget) {
        target = newTarget;
        if (!animId) animId = requestAnimationFrame(step);
      }
    };
  }
  var init_flipSpring = __esm({
    "src-js/utils/animation/flipSpring.ts"() {
      "use strict";
      __name(spring, "spring");
      window.snFlipSpringLoaded = true;
    }
  });

  // src-js/utils/dom/sidebarDetector.ts
  function querySidebar() {
    const node = document.querySelector(SIDEBAR_SELECTOR);
    if (!node) return null;
    const rect = node.getBoundingClientRect();
    return { node, rect };
  }
  function isSidebarCloneCapable() {
    const hasSidebar = !!querySidebar();
    const canClone = typeof Element.prototype.cloneNode === "function";
    const springReady = !!window.snFlipSpringLoaded;
    return hasSidebar && canClone && springReady;
  }
  var SIDEBAR_SELECTOR;
  var init_sidebarDetector = __esm({
    "src-js/utils/dom/sidebarDetector.ts"() {
      "use strict";
      SIDEBAR_SELECTOR = '[data-testid="rootlist-container"]';
      __name(querySidebar, "querySidebar");
      __name(isSidebarCloneCapable, "isSidebarCloneCapable");
    }
  });

  // src-js/ui/interactions/SidebarCloneOverlay.ts
  var SidebarCloneOverlay_exports = {};
  __export(SidebarCloneOverlay_exports, {
    destroySidebarClone: () => destroySidebarClone,
    launchSidebarClone: () => launchSidebarClone
  });
  function launchSidebarClone(context) {
    if (animationAbortController) {
      animationAbortController.abort();
      animationAbortController = null;
    }
    if (activeClone) {
      destroySidebarClone();
    }
    animationAbortController = new AbortController();
    const { signal } = animationAbortController;
    if (activeClone) return;
    const sidebar = querySidebar();
    if (!sidebar) return;
    const clone = sidebar.node.cloneNode(true);
    clone.id = "";
    clone.setAttribute("aria-hidden", "true");
    clone.classList.add("sn-clone-overlay");
    clone.style.position = "fixed";
    clone.style.top = `${sidebar.rect.top}px`;
    clone.style.left = `${sidebar.rect.left}px`;
    clone.style.width = `${sidebar.rect.width}px`;
    clone.style.height = `${sidebar.rect.height}px`;
    clone.style.zIndex = "9999";
    clone.style.willChange = "transform, opacity";
    clone.style.contain = "paint";
    (/* @__PURE__ */ __name(function stripCloneArtefacts(root) {
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
      while (walker.nextNode()) {
        const el = walker.currentNode;
        if (el.hasAttribute("aria-label")) el.removeAttribute("aria-label");
        if (el.tabIndex >= 0) el.tabIndex = -1;
      }
    }, "stripCloneArtefacts"))(clone);
    document.body.appendChild(clone);
    activeClone = clone;
    const firstX = 0;
    const firstY = 0;
    const firstS = 1;
    const lastX = context.cursorX - sidebar.rect.left - sidebar.rect.width * 0.2;
    const lastY = context.cursorY - sidebar.rect.top - sidebar.rect.height * 0.2;
    const lastS = 0.6;
    const prefersReduced = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    if (prefersReduced) {
      clone.style.transform = `translate(${lastX}px, ${lastY}px) scale(${lastS})`;
      pruneCloneItems(clone, context);
      return;
    }
    const anim = spring({
      stiffness: 220,
      damping: 20,
      onUpdate: /* @__PURE__ */ __name((v) => {
        if (signal.aborted) return;
        clone.style.transform = `translate(${v.x}px, ${v.y}px) scale(${v.s})`;
      }, "onUpdate")
    });
    clone.style.transformOrigin = "top left";
    clone.style.transform = `translate(${firstX}px, ${firstY}px) scale(${firstS})`;
    requestAnimationFrame(() => anim.to({ x: lastX, y: lastY, s: lastS }));
    const pruneTimeout = setTimeout(() => {
      if (!signal.aborted && activeClone) pruneCloneItems(activeClone, context);
    }, 400);
    signal.addEventListener("abort", () => clearTimeout(pruneTimeout));
    signal.addEventListener("abort", () => destroySidebarClone());
  }
  function destroySidebarClone() {
    cleanupFns.forEach((fn) => fn());
    cleanupFns.length = 0;
    if (activeClone) {
      activeClone.remove();
      activeClone = null;
    }
    if (animationAbortController) {
      animationAbortController.abort();
      animationAbortController = null;
    }
  }
  function addTracksToPlaylist(uri, trackUris) {
    try {
      const Cosmos = window.Spicetify?.CosmosAsync;
      if (!Cosmos) return;
      const endpoint = `/v1/playlists/${uri.split(":").pop()}/tracks`;
      Cosmos.post(endpoint, { uris: trackUris });
    } catch {
    }
  }
  function pruneCloneItems(root, context) {
    const all = Array.from(
      root.querySelectorAll('[data-uri^="spotify:playlist:"]')
    );
    if (!all.length) return;
    const keep = all.slice(0, 5);
    all.slice(5).forEach((el) => {
      el.classList.add("sn-prune-out");
      setTimeout(() => el.remove(), 180);
    });
    keep.forEach((el, idx) => {
      el.setAttribute("data-index", String(idx + 1));
      el.setAttribute("role", "button");
      el.tabIndex = 0;
      el.style.setProperty("--sn-glow-level", "0");
      el.style.backgroundImage = "paint(sn-aura)";
      el.addEventListener(
        "mouseenter",
        () => el.style.setProperty("--sn-glow-level", "1")
      );
      el.addEventListener(
        "mouseleave",
        () => el.style.setProperty("--sn-glow-level", "0")
      );
      const uriVal = el.getAttribute("data-uri");
      if (!uriVal) {
        return;
      }
      const trackUris = context.uris;
      const clickHandler = /* @__PURE__ */ __name((ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        const img = el.querySelector("img");
        pushRecentPlaylist(
          uriVal,
          img?.src || "",
          el.textContent?.trim() || "Playlist"
        );
        addTracksToPlaylist(uriVal, trackUris);
        announce("Track added to " + (el.textContent?.trim() || "playlist"));
        destroySidebarClone();
      }, "clickHandler");
      el.addEventListener("click", clickHandler);
      el.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          clickHandler(e);
        }
      });
    });
    const keyListener = /* @__PURE__ */ __name((e) => {
      const n = parseInt(e.key, 10);
      if (n >= 1 && n <= keep.length) {
        keep[n - 1]?.click();
      }
    }, "keyListener");
    window.addEventListener("keydown", keyListener, { capture: true });
    cleanupFns.push(
      () => window.removeEventListener("keydown", keyListener, { capture: true })
    );
  }
  function pushRecentPlaylist(uri, image, name) {
    try {
      const raw = localStorage.getItem(MRU_KEY);
      const list = raw ? JSON.parse(raw) : [];
      const existing = list.findIndex((p) => p.uri === uri);
      if (existing !== -1) list.splice(existing, 1);
      list.unshift({ uri, image, name });
      localStorage.setItem(MRU_KEY, JSON.stringify(list.slice(0, 10)));
    } catch {
    }
  }
  function announce(message) {
    const live = document.getElementById("sn-live");
    if (live) live.textContent = message;
  }
  var activeClone, cleanupFns, animationAbortController, MRU_KEY;
  var init_SidebarCloneOverlay = __esm({
    "src-js/ui/interactions/SidebarCloneOverlay.ts"() {
      "use strict";
      init_flipSpring();
      init_sidebarDetector();
      activeClone = null;
      cleanupFns = [];
      animationAbortController = null;
      MRU_KEY = "sn-recent-playlists";
      __name(launchSidebarClone, "launchSidebarClone");
      __name(destroySidebarClone, "destroySidebarClone");
      __name(addTracksToPlaylist, "addTracksToPlaylist");
      __name(pruneCloneItems, "pruneCloneItems");
      __name(pushRecentPlaylist, "pushRecentPlaylist");
      __name(announce, "announce");
    }
  });

  // src-js/ui/interactions/PlaylistQuickAddMenu.ts
  var PlaylistQuickAddMenu_exports = {};
  __export(PlaylistQuickAddMenu_exports, {
    enableQuickAddRadialMenu: () => enableQuickAddRadialMenu
  });
  function ensureLiveRegion() {
    let live = document.getElementById(LIVE_ID);
    if (!live) {
      live = document.createElement("div");
      live.id = LIVE_ID;
      live.setAttribute("aria-live", "polite");
      live.style.position = "absolute";
      live.style.width = "1px";
      live.style.height = "1px";
      live.style.overflow = "hidden";
      live.style.clipPath = "inset(100%)";
      live.style.clip = "rect(1px,1px,1px,1px)";
      live.style.whiteSpace = "nowrap";
      document.body.appendChild(live);
    }
    return live;
  }
  function distance(x1, y1, x2, y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function fetchRecentPlaylists() {
    try {
      const raw = localStorage.getItem("sn-recent-playlists");
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr.slice(0, MAX_PLAYLISTS_SHOWN) : [];
    } catch {
      return [];
    }
  }
  function addTracksToPlaylist2(playlistUri, trackUris) {
    try {
      const endpoint = `/v1/playlists/${playlistUri.split(":").pop()}/tracks`;
      window.Spicetify?.CosmosAsync.post(endpoint, {
        uris: trackUris
      });
    } catch (e) {
      console.warn("[StarryNight] QuickAddRadial failed to add tracks:", e);
    }
  }
  function pushRecentPlaylist2(pl) {
    try {
      const list = fetchRecentPlaylists();
      const existingIdx = list.findIndex((p) => p.uri === pl.uri);
      if (existingIdx !== -1) list.splice(existingIdx, 1);
      list.unshift(pl);
      const trimmed = list.slice(0, 10);
      localStorage.setItem("sn-recent-playlists", JSON.stringify(trimmed));
    } catch {
    }
  }
  function createOverlay(x, y, playlists) {
    if (!playlists.length) return;
    destroyOverlay();
    overlayEl = document.createElement("div");
    overlayEl.className = "sn-quick-add-overlay";
    overlayEl.style.position = "fixed";
    overlayEl.style.inset = "0";
    overlayEl.style.pointerEvents = "none";
    overlayEl.style.zIndex = "9999";
    const center = document.createElement("div");
    center.className = "sn-quick-add-center";
    center.style.position = "absolute";
    center.style.left = `${x}px`;
    center.style.top = `${y}px`;
    center.style.width = "0";
    center.style.height = "0";
    overlayEl.appendChild(center);
    document.body.appendChild(overlayEl);
    const radius = 90;
    const angleStep = Math.PI * 2 / playlists.length;
    playlists.forEach((pl, idx) => {
      const angle = angleStep * idx - Math.PI / 2;
      const btn = document.createElement("button");
      btn.className = "sn-quick-add-btn";
      btn.style.position = "absolute";
      btn.style.width = "64px";
      btn.style.height = "64px";
      btn.style.borderRadius = "50%";
      btn.style.border = "2px solid rgba(255,255,255,0.4)";
      btn.style.background = `url('${pl.image}') center/cover no-repeat`;
      btn.style.cursor = "pointer";
      btn.style.pointerEvents = "auto";
      const cx = radius * Math.cos(angle);
      const cy = radius * Math.sin(angle);
      btn.style.transform = `translate(${cx - 32}px, ${cy - 32}px)`;
      btn.style.transformOrigin = "center center";
      const firstX = 0;
      const firstY = 0;
      btn.style.transform = `translate(${firstX}px, ${firstY}px) scale(0.1)`;
      requestAnimationFrame(() => {
        const animator = spring({
          stiffness: 220,
          damping: 20,
          onUpdate: /* @__PURE__ */ __name((v) => {
            btn.style.transform = `translate(${v.x}px, ${v.y}px) scale(${v.s})`;
          }, "onUpdate")
        });
        animator.to({ x: cx - 32, y: cy - 32, s: 1 });
      });
      btn.title = `Add to ${pl.name}`;
      btn.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        if (currentDragDataUris) addTracksToPlaylist2(pl.uri, currentDragDataUris);
        pushRecentPlaylist2(pl);
        destroyOverlay();
      });
      center.appendChild(btn);
    });
    const live = ensureLiveRegion();
    live.textContent = "Quick-add menu open. Press number keys 1 to 5 to pick a playlist or continue dragging.";
  }
  function destroyOverlay() {
    overlayEl?.remove();
    overlayEl = null;
    const live = document.getElementById(LIVE_ID);
    if (live) live.textContent = "";
  }
  function clearHoldTimer() {
    if (holdTimer) {
      clearTimeout(holdTimer);
      holdTimer = null;
    }
  }
  function onDragStart2(e) {
    startX = e.clientX;
    startY = e.clientY;
    currentDragDataUris = (e.dataTransfer?.getData("text/spotify") || "").split(/[\n,]/).filter(Boolean);
    const cloneCapable = isSidebarCloneCapable();
    clearHoldTimer();
    holdTimer = window.setTimeout(async () => {
      if (cloneCapable) {
        const overlay = await Promise.resolve().then(() => (init_SidebarCloneOverlay(), SidebarCloneOverlay_exports));
        overlay.launchSidebarClone({
          cursorX: currentPointer.x,
          cursorY: currentPointer.y,
          uris: currentDragDataUris ?? []
        });
      } else {
        const playlists = await getRadialPlaylists();
        createOverlay(startX, startY, playlists);
      }
    }, HOLD_MS);
  }
  function onDragEnd() {
    clearHoldTimer();
    destroyOverlay();
    currentDragDataUris = null;
  }
  function onPointerMove(e) {
    currentPointer = { x: e.clientX, y: e.clientY };
    if (!holdTimer) return;
    if (distance(startX, startY, e.clientX, e.clientY) > MOVE_THRESHOLD) {
      clearHoldTimer();
    }
  }
  async function fetchPlaylistsFromAPI() {
    try {
      const Cosmos = window.Spicetify?.CosmosAsync;
      if (!Cosmos) return [];
      const resp = await Cosmos.get(
        "https://api.spotify.com/v1/me/playlists?limit=10"
      );
      if (!resp?.items) return [];
      return resp.items.slice(0, MAX_PLAYLISTS_SHOWN).map((pl) => ({
        uri: pl.uri,
        name: pl.name,
        image: pl.images?.[0]?.url || ""
      }));
    } catch {
      return [];
    }
  }
  function scrapeSidebarPlaylists() {
    try {
      const items = Array.from(
        document.querySelectorAll('[data-testid="rootlist-card"]')
      );
      const res = [];
      for (const el of items) {
        const uri = el.getAttribute("data-uri") || el.querySelector("a")?.getAttribute("href")?.replace("/playlist/", "spotify:playlist:");
        if (!uri) continue;
        const img = el.querySelector("img");
        const image = img?.src || "";
        const name = img?.alt || el.textContent?.trim() || "Playlist";
        res.push({ uri, image, name });
        if (res.length >= MAX_PLAYLISTS_SHOWN) break;
      }
      return res;
    } catch {
      return [];
    }
  }
  async function getRadialPlaylists() {
    const local = fetchRecentPlaylists();
    if (local.length) return local;
    const sidebar = scrapeSidebarPlaylists();
    if (sidebar.length) return sidebar;
    const api = await fetchPlaylistsFromAPI();
    return api;
  }
  function enableQuickAddRadialMenu() {
    const g = globalThis;
    if (g.__SN_quickAddRadial) return;
    g.__SN_quickAddRadial = true;
    window.addEventListener("dragstart", onDragStart2, true);
    window.addEventListener("dragend", onDragEnd, true);
    window.addEventListener("pointermove", onPointerMove, true);
    console.info("\u{1F30C} Quick-Add radial menu enabled");
    console.info(
      `[StarryNight] Sidebar clone capability: ${isSidebarCloneCapable()}`
    );
  }
  var HOLD_MS, MOVE_THRESHOLD, MAX_PLAYLISTS_SHOWN, holdTimer, startX, startY, overlayEl, currentDragDataUris, currentPointer, LIVE_ID;
  var init_PlaylistQuickAddMenu = __esm({
    "src-js/ui/interactions/PlaylistQuickAddMenu.ts"() {
      "use strict";
      init_flipSpring();
      init_sidebarDetector();
      HOLD_MS = 250;
      MOVE_THRESHOLD = 8;
      MAX_PLAYLISTS_SHOWN = 5;
      holdTimer = null;
      startX = 0;
      startY = 0;
      overlayEl = null;
      currentDragDataUris = null;
      currentPointer = { x: 0, y: 0 };
      LIVE_ID = "sn-live";
      __name(ensureLiveRegion, "ensureLiveRegion");
      __name(distance, "distance");
      __name(fetchRecentPlaylists, "fetchRecentPlaylists");
      __name(addTracksToPlaylist2, "addTracksToPlaylist");
      __name(pushRecentPlaylist2, "pushRecentPlaylist");
      __name(createOverlay, "createOverlay");
      __name(destroyOverlay, "destroyOverlay");
      __name(clearHoldTimer, "clearHoldTimer");
      __name(onDragStart2, "onDragStart");
      __name(onDragEnd, "onDragEnd");
      __name(onPointerMove, "onPointerMove");
      document.addEventListener("keydown", (e) => {
        if (!overlayEl) return;
        const num = parseInt(e.key, 10);
        if (num >= 1 && num <= MAX_PLAYLISTS_SHOWN) {
          const btn = overlayEl.querySelectorAll(".sn-quick-add-btn")[num - 1];
          btn?.click();
        }
      });
      __name(fetchPlaylistsFromAPI, "fetchPlaylistsFromAPI");
      __name(scrapeSidebarPlaylists, "scrapeSidebarPlaylists");
      __name(getRadialPlaylists, "getRadialPlaylists");
      __name(enableQuickAddRadialMenu, "enableQuickAddRadialMenu");
    }
  });

  // src-js/visual/ui/prismaticScrollSheen.ts
  var prismaticScrollSheen_exports = {};
  __export(prismaticScrollSheen_exports, {
    PrismaticScrollSheenSystem: () => PrismaticScrollSheenSystem,
    initializePrismaticScrollSheen: () => initializePrismaticScrollSheen
  });
  function initializePrismaticScrollSheen() {
    try {
      const sys = new PrismaticScrollSheenSystem();
      AdvancedThemeSystem_default?.registerVisualSystem?.(sys, "background");
    } catch (err) {
      console.error("[PrismaticScrollSheen] Failed to init:", err);
    }
  }
  var DEFAULT_CYCLE_PX, _PrismaticScrollSheenSystem, PrismaticScrollSheenSystem;
  var init_prismaticScrollSheen = __esm({
    "src-js/visual/ui/prismaticScrollSheen.ts"() {
      "use strict";
      init_AdvancedThemeSystem();
      init_OptimizedCSSVariableManager();
      DEFAULT_CYCLE_PX = 6e3;
      _PrismaticScrollSheenSystem = class _PrismaticScrollSheenSystem {
        constructor(cyclePx = DEFAULT_CYCLE_PX) {
          this.cyclePx = cyclePx;
          this.systemName = "PrismaticScrollSheen";
          this._lastRatio = -1;
          const year3000System = globalThis.year3000System;
          this.cssController = year3000System?.cssController || getGlobalOptimizedCSSController();
          this.cssController.setVariable(
            "PrismaticScrollSheenSystem",
            "--sn-scroll-cycle-px",
            String(cyclePx),
            "normal",
            // Normal priority for scroll cycle setup
            "scroll-cycle-init"
          );
        }
        /**
         * Called each animation frame by VisualSystemRegistry.
         */
        onAnimate(_delta, context) {
          const ratio = context.scrollRatio ?? 0;
          if (Math.abs(ratio - this._lastRatio) < 1e-3) return;
          this._lastRatio = ratio;
          const scrollRatioVariables = {
            "--sn-cdf-scroll-ratio": ratio.toFixed(4),
            "--sn-scroll-ratio": ratio.toFixed(4)
          };
          this.cssController.batchSetVariables(
            "PrismaticScrollSheenSystem",
            scrollRatioVariables,
            "high",
            // High priority for scroll ratio updates - affects visual responsiveness
            "scroll-ratio-update"
          );
        }
        onPerformanceModeChange() {
        }
        destroy() {
        }
      };
      __name(_PrismaticScrollSheenSystem, "PrismaticScrollSheenSystem");
      PrismaticScrollSheenSystem = _PrismaticScrollSheenSystem;
      __name(initializePrismaticScrollSheen, "initializePrismaticScrollSheen");
      if (window.Y3K?.system?.registerVisualSystem) {
        initializePrismaticScrollSheen();
      }
    }
  });

  // src-js/ui/components/SettingsSection.tsx
  var import_react, import_react_dom, _SettingsSection, SettingsSection;
  var init_SettingsSection = __esm({
    "src-js/ui/components/SettingsSection.tsx"() {
      "use strict";
      import_react = __toESM(__require("react"));
      import_react_dom = __toESM(__require("react-dom"));
      _SettingsSection = class _SettingsSection {
        constructor(name, settingsId, initialSettingsFields = {}) {
          this.name = name;
          this.settingsId = settingsId;
          this.initialSettingsFields = initialSettingsFields;
          this.settingsFields = this.initialSettingsFields;
          this.setRerender = null;
          /** Mounts the section when the user visits the Spotify settings route */
          this.pushSettings = /* @__PURE__ */ __name(async () => {
            Object.entries(this.settingsFields).forEach(([nameId, field]) => {
              if (field.type !== "button" && this.getFieldValue(nameId) === void 0) {
                this.setFieldValue(nameId, field.defaultValue);
              }
            });
            while (!window.Spicetify?.Platform?.History?.listen) {
              await new Promise((r) => setTimeout(r, 100));
            }
            if (this.stopHistoryListener) this.stopHistoryListener();
            this.stopHistoryListener = window.Spicetify.Platform.History.listen((e) => {
              if (e.pathname === "/preferences") this.render();
            });
            if (window.Spicetify.Platform.History.location.pathname === "/preferences") {
              await this.render();
            }
          }, "pushSettings");
          this.rerender = /* @__PURE__ */ __name(() => {
            this.setRerender?.(Math.random());
          }, "rerender");
          /* ----------------------- field creators ---------------------------- */
          this.addDropDown = /* @__PURE__ */ __name((nameId, description, options, defaultIndex, _onSelect, events) => {
            this.settingsFields[nameId] = {
              type: "dropdown",
              description,
              defaultValue: options[defaultIndex],
              options,
              events
            };
          }, "addDropDown");
          /** Toggle (checkbox) */
          this.addToggle = /* @__PURE__ */ __name((nameId, description, defaultValue, events) => {
            this.settingsFields[nameId] = {
              type: "toggle",
              description,
              defaultValue,
              events
            };
          }, "addToggle");
          /** Text / number / color input */
          this.addInput = /* @__PURE__ */ __name((nameId, description, defaultValue, inputType = "text", events) => {
            this.settingsFields[nameId] = {
              type: "input",
              description,
              defaultValue,
              inputType,
              events
            };
          }, "addInput");
          /* ----- generic storage helpers (use Spicetify.LocalStorage) -------- */
          this.getFieldValue = /* @__PURE__ */ __name((nameId) => {
            const value = window.Spicetify?.LocalStorage.get(nameId);
            if (value === null || value === void 0) {
              const legacyKey = `${this.settingsId}.${nameId}`;
              const legacyValue = window.Spicetify?.LocalStorage.get(legacyKey);
              if (legacyValue) {
                try {
                  const parsed = JSON.parse(legacyValue);
                  const extractedValue = parsed?.value ?? legacyValue;
                  window.Spicetify?.LocalStorage.set(nameId, extractedValue);
                  window.Spicetify?.LocalStorage.remove(legacyKey);
                  return extractedValue;
                } catch {
                  return legacyValue;
                }
              }
              return void 0;
            }
            return value;
          }, "getFieldValue");
          /* ---------------------- React wrappers ----------------------------- */
          this.FieldsContainer = /* @__PURE__ */ __name(() => {
            const [nonce, setNonce] = (0, import_react.useState)(0);
            this.setRerender = setNonce;
            return /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-section", key: nonce }, /* @__PURE__ */ import_react.default.createElement("h2", { className: "TypeElement-cello-textBase-type" }, this.name), Object.entries(this.settingsFields).map(([nameId, field]) => /* @__PURE__ */ import_react.default.createElement(this.Field, { key: nameId, nameId, field })));
          }, "FieldsContainer");
          this.Field = /* @__PURE__ */ __name(({
            nameId,
            field
          }) => {
            const id = `${this.settingsId}.${nameId}`;
            const initial = field.type === "button" ? field.value : this.getFieldValue(nameId) ?? field.defaultValue;
            const [value, setVal] = (0, import_react.useState)(initial);
            const setValue = /* @__PURE__ */ __name((v) => {
              setVal(v);
              this.setFieldValue(nameId, v);
              try {
                const customEvent = new CustomEvent("year3000SystemSettingsChanged", {
                  detail: { key: nameId, value: v }
                });
                document.dispatchEvent(customEvent);
              } catch (error) {
                console.warn(`[SettingsSection] Failed to emit settings change event for ${nameId}:`, error);
              }
            }, "setValue");
            if (field.type === "hidden") return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null);
            const Label = /* @__PURE__ */ import_react.default.createElement("label", { className: "TypeElement-viola-textSubdued-type", htmlFor: id }, field.description || "");
            let Control = null;
            switch (field.type) {
              case "dropdown":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "select",
                  {
                    className: "main-dropDown-dropDown",
                    id,
                    ...field.events,
                    onChange: (e) => {
                      const idx = e.currentTarget.selectedIndex;
                      const newVal = field.options[idx];
                      setValue(newVal);
                      field.events?.onChange?.(e);
                    }
                  },
                  field.options.map((opt, i) => /* @__PURE__ */ import_react.default.createElement("option", { key: opt, value: opt, selected: opt === value }, opt))
                );
                break;
              case "toggle":
                Control = /* @__PURE__ */ import_react.default.createElement("label", { className: "x-settings-secondColumn x-toggle-wrapper" }, /* @__PURE__ */ import_react.default.createElement(
                  "input",
                  {
                    id,
                    className: "x-toggle-input",
                    type: "checkbox",
                    checked: !!value,
                    ...field.events,
                    onClick: (e) => {
                      const checked = e.currentTarget.checked;
                      setValue(checked);
                      field.events?.onClick?.(e);
                    }
                  }
                ), /* @__PURE__ */ import_react.default.createElement("span", { className: "x-toggle-indicatorWrapper" }, /* @__PURE__ */ import_react.default.createElement("span", { className: "x-toggle-indicator" })));
                break;
              case "input":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "input",
                  {
                    className: "x-settings-input",
                    id,
                    dir: "ltr",
                    value,
                    type: field.inputType || "text",
                    ...field.events,
                    onChange: (e) => {
                      setValue(e.currentTarget.value);
                      field.events?.onChange?.(e);
                    }
                  }
                );
                break;
              case "button":
                Control = /* @__PURE__ */ import_react.default.createElement(
                  "button",
                  {
                    id,
                    className: "Button-sc-y0gtbx-0 Button-small-buttonSecondary-useBrowserDefaultFocusStyle x-settings-button",
                    ...field.events,
                    onClick: (e) => {
                      field.events?.onClick?.(e);
                    },
                    type: "button"
                  },
                  value
                );
                break;
              default:
                Control = null;
            }
            return /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-row" }, /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-firstColumn" }, Label), /* @__PURE__ */ import_react.default.createElement("div", { className: "x-settings-secondColumn" }, Control));
          }, "Field");
        }
        /* --------------------- internal render helpers --------------------- */
        async render() {
          while (!document.getElementById("desktop.settings.selectLanguage")) {
            if (window.Spicetify.Platform.History.location.pathname !== "/preferences")
              return;
            await new Promise((r) => setTimeout(r, 100));
          }
          const container = document.querySelector(
            ".main-view-container__scroll-node-child main div"
          );
          if (!container)
            return console.error("[StarryNight] settings container not found");
          let host = Array.from(container.children).find(
            (c) => c.id === this.settingsId
          );
          if (!host) {
            host = document.createElement("div");
            host.id = this.settingsId;
            container.appendChild(host);
          }
          import_react_dom.default.render(/* @__PURE__ */ import_react.default.createElement(this.FieldsContainer, null), host);
        }
        setFieldValue(nameId, newValue) {
          window.Spicetify?.LocalStorage.set(nameId, newValue);
        }
      };
      __name(_SettingsSection, "SettingsSection");
      SettingsSection = _SettingsSection;
    }
  });

  // src-js/ui/components/StarryNightSettings.ts
  var StarryNightSettings_exports = {};
  __export(StarryNightSettings_exports, {
    initializeStarryNightSettings: () => initializeStarryNightSettings
  });
  function getCSSController2() {
    const year3000System = globalThis.year3000System;
    return year3000System?.cssController || getGlobalOptimizedCSSController();
  }
  async function initializeStarryNightSettings() {
    const section = new SettingsSection(
      "StarryNight Theme",
      "starrynight-settings"
    );
    const accentOptions = [
      "dynamic",
      // 🎨 Album-based accent (Year 3000)
      "rosewater",
      "flamingo",
      "pink",
      "mauve",
      "red",
      "maroon",
      "peach",
      "yellow",
      "green",
      "teal",
      "sky",
      "sapphire",
      "blue",
      "lavender"
    ];
    function getSettingsManager() {
      const existing = window.Y3K?.system?.settingsManager;
      if (existing) return existing;
      const cached = globalThis.__SN_settingsManager;
      if (cached) return cached;
      const manager = new SettingsManager();
      globalThis.__SN_settingsManager = manager;
      return manager;
    }
    __name(getSettingsManager, "getSettingsManager");
    const settingsManager2 = getSettingsManager();
    const currentAccent = settingsManager2.get("catppuccin-accentColor");
    section.addDropDown(
      "catppuccin-accentColor",
      // settings key (nameId)
      "Accent colour (primary theme color)",
      // user-visible label
      accentOptions,
      // option list
      Math.max(0, accentOptions.indexOf(currentAccent)),
      // default index
      void 0,
      // onSelect (unused – we use onChange)
      {
        onChange: /* @__PURE__ */ __name((e) => {
          try {
            const idx = e?.currentTarget?.selectedIndex ?? 0;
            const newAccent = accentOptions[idx] ?? "mauve";
            settingsManager2.set("catppuccin-accentColor", newAccent);
            const grad = settingsManager2.get("sn-gradient-intensity");
            applyStarryNightSettings(grad, grad);
            try {
              globalThis.Y3K?.system?.applyInitialSettings?.("accent");
            } catch (applyErr) {
              console.warn(
                "[StarryNight] Unable to trigger Year3000System colour refresh",
                applyErr
              );
            }
          } catch (err) {
            console.error("[StarryNight] Failed to update accent colour", err);
          }
        }, "onChange")
      }
    );
    const intensityOptions = [
      "disabled",
      "minimal",
      "balanced",
      "intense"
    ];
    const currentGradient = settingsManager2.get("sn-gradient-intensity");
    section.addDropDown(
      "sn-gradient-intensity",
      "Background effects intensity (stars, nebula, flow gradients)",
      intensityOptions,
      Math.max(0, intensityOptions.indexOf(currentGradient)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const newGrad = intensityOptions[idx] ?? "balanced";
          settingsManager2.set("sn-gradient-intensity", newGrad);
          applyStarryNightSettings(newGrad, newGrad);
        }, "onChange")
      }
    );
    const brightnessOptions = ["bright", "balanced", "dark"];
    const currentBrightness = settingsManager2.get("sn-brightness-mode") || "balanced";
    section.addDropDown(
      "sn-brightness-mode",
      "Brightness mode",
      brightnessOptions,
      Math.max(0, brightnessOptions.indexOf(currentBrightness)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const newBrightness = brightnessOptions[idx] ?? "bright";
          settingsManager2.set("sn-brightness-mode", newBrightness);
          const cssController2 = getCSSController2();
          const brightnessVariables = {
            "--sn-brightness-mode": `"${newBrightness}"`,
            "--sn-brightness-data-attr": newBrightness
          };
          cssController2.batchSetVariables(
            "StarryNightSettings",
            brightnessVariables,
            "high",
            // High priority for brightness mode changes
            "brightness-mode-change"
          );
          document.documentElement.setAttribute(
            "data-sn-brightness",
            newBrightness
          );
          try {
            globalThis.Y3K?.system?.applyInitialSettings?.("brightness");
            console.log(
              `[StarryNight] Brightness mode changed to: ${newBrightness}`
            );
          } catch (applyErr) {
            console.warn(
              "[StarryNight] Unable to trigger Year3000System brightness refresh",
              applyErr
            );
          }
        }, "onChange")
      }
    );
    const flavourOptions = ["latte", "frappe", "macchiato", "mocha"];
    const currentFlavor = settingsManager2.get("catppuccin-flavor");
    section.addDropDown(
      "catppuccin-flavor",
      "Catppuccin flavour (light/dark theme base)",
      flavourOptions,
      Math.max(0, flavourOptions.indexOf(currentFlavor)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager2.set("catppuccin-flavor", flavourOptions[idx]);
          try {
            globalThis.Y3K?.system?.applyInitialSettings?.("flavor");
          } catch (applyErr) {
            console.warn(
              "[StarryNight] Unable to trigger flavor refresh",
              applyErr
            );
          }
        }, "onChange")
      }
    );
    const paletteOptions = ["catppuccin", "year3000"];
    const paletteLabels = ["Catppuccin Classic", "Year 3000 Cinematic"];
    const currentPalette = settingsManager2.get("sn-palette-system");
    section.addDropDown(
      "sn-palette-system",
      "Palette system (color foundation vs enhancement)",
      paletteLabels,
      Math.max(0, paletteOptions.indexOf(currentPalette)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager2.set("sn-palette-system", paletteOptions[idx]);
          try {
            globalThis.Y3K?.system?.applyInitialSettings?.("palette");
          } catch (applyErr) {
            console.warn(
              "[StarryNight] Unable to trigger palette system refresh",
              applyErr
            );
          }
        }, "onChange")
      }
    );
    const glassOptions = ["disabled", "minimal", "moderate", "intense"];
    const currentGlass = settingsManager2.get("sn-glassmorphism-level");
    section.addDropDown(
      "sn-glassmorphism-level",
      "Glassmorphism",
      glassOptions,
      Math.max(0, glassOptions.indexOf(currentGlass)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          settingsManager2.set("sn-glassmorphism-level", glassOptions[idx]);
        }, "onChange")
      }
    );
    const artisticOptions = [
      "corporate-safe",
      "artist-vision",
      "cosmic-maximum"
    ];
    const currentArtistic = settingsManager2.get("sn-artistic-mode");
    section.addDropDown(
      "sn-artistic-mode",
      "Artistic mode",
      artisticOptions,
      Math.max(0, artisticOptions.indexOf(currentArtistic)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const mode = artisticOptions[idx];
          settingsManager2.set("sn-artistic-mode", mode);
          globalThis.year3000System?.ADVANCED_SYSTEM_CONFIG?.safeSetArtisticMode?.(mode);
        }, "onChange")
      }
    );
    const harmonicModes = Object.keys(HARMONIC_MODES2);
    const currentHarmMode = settingsManager2.get("sn-current-harmonic-mode");
    if (harmonicModes.length) {
      section.addDropDown(
        "sn-current-harmonic-mode",
        "Harmonic colour mode",
        harmonicModes,
        Math.max(0, harmonicModes.indexOf(currentHarmMode)),
        void 0,
        {
          onChange: /* @__PURE__ */ __name((e) => {
            const idx = e?.currentTarget?.selectedIndex ?? 0;
            const modeKey = harmonicModes[idx];
            settingsManager2.set("sn-current-harmonic-mode", modeKey);
            globalThis.Y3K?.system?.evolveHarmonicSignature?.(modeKey);
          }, "onChange")
        }
      );
    }
    const currentHarmInt = settingsManager2.get("sn-harmonic-intensity") || "0.7";
    section.addInput(
      "sn-harmonic-intensity",
      "Harmonic intensity (music-color sync strength 0-1)",
      currentHarmInt,
      "number",
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const val = e.currentTarget.value;
          settingsManager2.set("sn-harmonic-intensity", val);
        }, "onChange")
      }
    );
    const currentEvolution = settingsManager2.get("sn-harmonic-evolution") === "true";
    section.addToggle(
      "sn-harmonic-evolution",
      "Allow harmonic evolution",
      currentEvolution,
      {
        onClick: /* @__PURE__ */ __name((e) => {
          const checked = e.currentTarget.checked;
          settingsManager2.set(
            "sn-harmonic-evolution",
            checked ? "true" : "false"
          );
        }, "onClick")
      }
    );
    const enableWebGL = settingsManager2.get("sn-webgl-enabled") === "true";
    section.addToggle(
      "sn-webgl-enabled",
      "WebGL effects (master toggle for all WebGL backgrounds)",
      enableWebGL,
      {
        onClick: /* @__PURE__ */ __name((e) => {
          const checked = e.currentTarget.checked;
          settingsManager2.set(
            "sn-webgl-enabled",
            checked ? "true" : "false"
          );
        }, "onClick")
      }
    );
    const webglQualityOptions = ["low", "medium", "high"];
    const currentWebGLQ = settingsManager2.get("sn-webgl-quality") || "medium";
    section.addDropDown(
      "sn-webgl-quality",
      "WebGL quality (performance vs visual quality)",
      webglQualityOptions,
      Math.max(0, webglQualityOptions.indexOf(currentWebGLQ)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 1;
          const val = webglQualityOptions[idx] ?? "medium";
          settingsManager2.set("sn-webgl-quality", val);
        }, "onChange")
      }
    );
    const animQualityOptions = ["auto", "low", "high"];
    const currentAnimQ = settingsManager2.get("sn-animation-quality") || "auto";
    section.addDropDown(
      "sn-animation-quality",
      "Animation quality (auto/low/high performance)",
      animQualityOptions,
      Math.max(0, animQualityOptions.indexOf(currentAnimQ)),
      void 0,
      {
        onChange: /* @__PURE__ */ __name((e) => {
          const idx = e?.currentTarget?.selectedIndex ?? 0;
          const val = animQualityOptions[idx] ?? "auto";
          settingsManager2.set("sn-animation-quality", val);
        }, "onChange")
      }
    );
    await section.pushSettings();
    console.log("\u2728 [StarryNight] spcr-settings panel initialised");
    const initialBrightness = settingsManager2.get("sn-brightness-mode") || "balanced";
    const cssController = getCSSController2();
    const initialBrightnessVariables = {
      "--sn-brightness-mode": `"${initialBrightness}"`,
      "--sn-brightness-data-attr": initialBrightness
    };
    cssController.batchSetVariables(
      "StarryNightSettings",
      initialBrightnessVariables,
      "high",
      // High priority for initial brightness setup
      "brightness-mode-init"
    );
    document.documentElement.setAttribute(
      "data-sn-brightness",
      initialBrightness
    );
    console.log(
      `[StarryNight] Initial brightness mode set to: ${initialBrightness}`
    );
    const rerender = /* @__PURE__ */ __name(() => section.rerender(), "rerender");
    const history = globalThis.Spicetify?.Platform?.History;
    try {
      if (history?.listen) {
        history.listen(({ location }) => {
          if (location?.pathname === "/settings") {
            setTimeout(rerender, 100);
          }
        });
      }
    } catch (err) {
      console.warn("[StarryNight] Could not hook navigation for settings", err);
    }
    if (window.location.pathname === "/settings") {
      setTimeout(rerender, 300);
    }
  }
  var init_StarryNightSettings = __esm({
    "src-js/ui/components/StarryNightSettings.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_SettingsSection();
      init_SettingsManager();
      init_starryNightEffects();
      __name(getCSSController2, "getCSSController");
      __name(initializeStarryNightSettings, "initializeStarryNightSettings");
    }
  });

  // src-js/visual/effects/DepthLayerController.ts
  var DepthLayerController_exports = {};
  __export(DepthLayerController_exports, {
    DepthVisualEffectsController: () => DepthVisualEffectsController
  });
  var _DepthVisualEffectsController, DepthVisualEffectsController;
  var init_DepthLayerController = __esm({
    "src-js/visual/effects/DepthLayerController.ts"() {
      "use strict";
      init_globalConfig();
      init_OptimizedCSSVariableManager();
      init_UnifiedDebugManager();
      init_ThemeUtilities();
      init_BaseVisualSystem();
      _DepthVisualEffectsController = class _DepthVisualEffectsController extends BaseVisualSystem {
        // Track time spent in areas
        constructor(config = ADVANCED_SYSTEM_CONFIG, utils = ThemeUtilities_exports, performanceMonitor = null, musicSyncService = null, settingsManager2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this.contentAreas = /* @__PURE__ */ new Map();
          this.chromeAreas = /* @__PURE__ */ new Set();
          this.userState = {
            isScrolling: false,
            isHovering: false,
            lastInteractionTime: 0,
            readingModeActive: false,
            interactionTarget: null,
            // Enhanced interaction awareness defaults
            currentMode: "browsing",
            focusDepth: 0.3,
            scrollVelocity: 0,
            dwellTime: 0,
            interactionPattern: "casual",
            contentEngagement: 0.5
          };
          this.musicalState = {
            energy: 0.5,
            valence: 0.5,
            instrumental: false,
            tempo: 120,
            // Enhanced musical visualEffects defaults
            emotionalTemperature: 0.5,
            musicSyncStrength: 0.7,
            genreVisualEffectsProfile: {
              ambientLevel: 0.5,
              energyResponse: 0.6,
              visualComplexity: 0.5
            },
            musicalMemoryPatterns: 0.4
          };
          this.readingModeTimer = 0;
          this.interactionTimer = 0;
          this.visualEffectsUpdateInterval = 0;
          // Performance optimization and visualEffects timing
          this.lastUpdate = 0;
          this.updateThreshold = 100;
          // Max 10fps for visualEffects updates
          this.visualEffectsIntensity = 0.7;
          // Overall visualEffects system intensity
          this.adaptiveProtectionMap = /* @__PURE__ */ new Map();
          // Dynamic protection levels
          this.scrollVelocityHistory = [];
          // Track scroll patterns
          this.dwellTimeTracker = /* @__PURE__ */ new Map();
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            const year3000System = globalThis.year3000System;
            this.cssController = year3000System?.cssVisualEffectsController || getGlobalOptimizedCSSController();
            this.detectContentAndChromeAreas();
            this.setupInteractionListeners();
            this.initializeVisualEffectsVariables();
            this.startVisualEffectsUpdate();
            Y3KDebug?.debug?.log(
              "DepthVisualEffectsController",
              "VisualEffects system awakened"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DepthVisualEffectsController",
              "Failed to initialize visualEffects:",
              error
            );
          }
        }
        /**
         * Enhanced content detection with advanced awareness patterns
         */
        detectContentAndChromeAreas() {
          const contentSelectors = {
            text: [
              ".main-view-container__scroll-node",
              ".main-trackList-trackListRow",
              '[data-testid*="tracklist"]',
              '[data-testid*="playlist"]',
              ".main-entityHeader-titleText",
              ".main-entityHeader-subtitle",
              ".main-trackList-rowTitle",
              ".main-trackList-rowSubTitle",
              "h1, h2, h3, h4, h5, h6",
              "p",
              ".lyrics-lyricsContainer-container",
              ".main-cardSubHeader-root",
              ".main-trackList-indexNumber",
              ".main-trackInfo-name",
              ".main-trackInfo-artists"
            ],
            interactive: [
              "button",
              "a[role='button']",
              "[tabindex='0']",
              ".main-playButton-button",
              ".main-addButton-button",
              ".main-moreButton-button",
              ".main-trackList-rowPlayPause",
              ".control-button",
              "input",
              "select"
            ],
            visual: [
              ".main-image-container",
              ".main-entityHeader-image",
              ".cover-art",
              ".main-coverSlot-container",
              ".main-image-image"
            ],
            media: [
              "video",
              "audio",
              ".main-nowPlayingWidget-trackInfo",
              ".main-coverSlot-container",
              ".main-nowPlayingView-coverArt"
            ],
            navigation: [
              ".main-navBar-navBarLink",
              ".main-rootlist-rootlistItem",
              ".main-collectionLinkText-text"
            ]
          };
          const chromeSelectors = [
            ".Root__nav-bar",
            ".Root__top-bar",
            ".Root__now-playing-bar",
            ".main-topBar-container",
            ".main-navBar-navBar",
            ".main-entityHeader-container",
            ".main-actionBar-container",
            ".main-view-container",
            ".Root__main-view",
            ".main-rootlist-wrapper"
          ];
          Object.entries(contentSelectors).forEach(([type, selectors]) => {
            selectors.forEach((selector) => {
              document.querySelectorAll(selector).forEach((element) => {
                const contentArea = {
                  element,
                  type,
                  protectionLevel: this.calculateAdvancedProtectionLevel(element, type),
                  lastInteraction: 0,
                  visualEffectsLevel: this.calculateVisualEffectsLevel(element),
                  readingIntensity: 0,
                  contextualImportance: this.calculateContextualImportance(element),
                  adaptiveProtection: this.calculateProtectionLevel(element)
                };
                this.contentAreas.set(element, contentArea);
                element.classList.add("content-sanctuary");
                element.classList.add(`content-${type}`);
                element.setAttribute("data-visualEffects-protected", "true");
                element.setAttribute("data-content-type", contentArea.type);
                element.setAttribute("data-visualEffects-level", contentArea.visualEffectsLevel.toString());
                element.setAttribute("data-contextual-importance", contentArea.contextualImportance.toString());
                this.adaptiveProtectionMap.set(element, contentArea.adaptiveProtection);
                this.dwellTimeTracker.set(element, 0);
              });
            });
          });
          chromeSelectors.forEach((selector) => {
            document.querySelectorAll(selector).forEach((element) => {
              this.chromeAreas.add(element);
              element.classList.add("ui-chrome-area");
              element.setAttribute("data-visualEffects-enhanced", "true");
            });
          });
          const contentStats = this.analyzeContentDistribution();
          Y3KDebug?.debug?.log(
            "DepthVisualEffectsController",
            `Enhanced detection: ${this.contentAreas.size} content areas, ${this.chromeAreas.size} chrome areas`,
            contentStats
          );
        }
        /**
         * Determine content type for appropriate protection level
         */
        determineContentType(element) {
          if (element.matches("h1, h2, h3, h4, h5, h6, .main-entityHeader-titleText")) {
            return "text";
          }
          if (element.matches('button, a, [role="button"], [tabindex], input, select')) {
            return "interactive";
          }
          if (element.matches(
            ".main-image-container, .main-entityHeader-image, .cover-art"
          )) {
            return "visual";
          }
          if (element.matches(".Root__nav-bar, .Root__top-bar, .main-topBar-container")) {
            return "chrome";
          }
          return "text";
        }
        /**
         * Calculate protection level based on content type and context
         */
        calculateProtectionLevel(element) {
          const contentType = this.determineContentType(element);
          switch (contentType) {
            case "text":
              return 0.95;
            case "interactive":
              return 0.9;
            case "visual":
              return 0.6;
            case "chrome":
              return 0.3;
            case "media":
              return 0.5;
            case "navigation":
              return 0.7;
            default:
              return 0.85;
          }
        }
        /**
         * Advanced protection level calculation with visualEffects awareness
         */
        calculateAdvancedProtectionLevel(element, type) {
          const baseProtection = this.calculateProtectionLevel(element);
          let adjustment = 0;
          if (type === "text" && element.textContent && element.textContent.length > 50) {
            adjustment += 0.05;
          }
          const rect = element.getBoundingClientRect();
          const isInViewport = rect.top >= 0 && rect.left >= 0 && rect.bottom <= window.innerHeight && rect.right <= window.innerWidth;
          if (isInViewport) {
            adjustment += 0.02;
          }
          if (element.matches('h1, h2, .main-entityHeader-titleText, [data-testid*="title"]')) {
            adjustment += 0.03;
          }
          return Math.min(baseProtection + adjustment, 0.98);
        }
        /**
         * Calculate visualEffects level - how much visualEffects effects should be applied
         */
        calculateVisualEffectsLevel(element) {
          const rect = element.getBoundingClientRect();
          const elementArea = rect.width * rect.height;
          const viewportArea = window.innerWidth * window.innerHeight;
          const elementVisibilityRatio = elementArea / viewportArea;
          let visualEffectsLevel = Math.min(elementVisibilityRatio * 2, 0.8);
          if (element.matches(".Root__main-view, .main-view-container")) {
            visualEffectsLevel += 0.3;
          }
          if (element.matches(".main-nowPlayingBar-container")) {
            visualEffectsLevel += 0.4;
          }
          return Math.min(visualEffectsLevel, 1);
        }
        /**
         * Calculate contextual importance based on user behavior and content significance
         */
        calculateContextualImportance(element) {
          let importance = 0.5;
          if (element.matches('button, a, [role="button"], [tabindex="0"]')) {
            importance += 0.2;
          }
          if (element.matches(".main-view-container, .main-entityHeader, .main-trackList")) {
            importance += 0.3;
          }
          if (element.matches(".main-nowPlayingWidget, .main-nowPlayingBar")) {
            importance += 0.4;
          }
          if (element.matches(":focus, :focus-within, :hover")) {
            importance += 0.2;
          }
          return Math.min(importance, 1);
        }
        /**
         * Analyze content distribution for visualEffects optimization
         */
        analyzeContentDistribution() {
          const stats = {
            totalAreas: this.contentAreas.size,
            textAreas: 0,
            interactiveAreas: 0,
            visualAreas: 0,
            mediaAreas: 0,
            navigationAreas: 0,
            chromeAreas: this.chromeAreas.size,
            averageProtection: 0,
            highProtectionAreas: 0
          };
          let totalProtection = 0;
          this.contentAreas.forEach((area) => {
            switch (area.type) {
              case "text":
                stats.textAreas++;
                break;
              case "interactive":
                stats.interactiveAreas++;
                break;
              case "visual":
                stats.visualAreas++;
                break;
              case "media":
                stats.mediaAreas++;
                break;
              case "navigation":
                stats.navigationAreas++;
                break;
            }
            totalProtection += area.protectionLevel;
            if (area.protectionLevel > 0.8) {
              stats.highProtectionAreas++;
            }
          });
          stats.averageProtection = totalProtection / this.contentAreas.size || 0;
          return stats;
        }
        /**
         * Analyze scrolling behavior patterns for visualEffects adaptation
         */
        analyzeScrollingBehavior() {
          if (this.scrollVelocityHistory.length < 3) return;
          const avgVelocity = this.scrollVelocityHistory.reduce((a, b) => a + b, 0) / this.scrollVelocityHistory.length;
          const velocityVariance = this.scrollVelocityHistory.reduce((variance, velocity) => {
            return variance + Math.pow(velocity - avgVelocity, 2);
          }, 0) / this.scrollVelocityHistory.length;
          if (velocityVariance < 100 && avgVelocity < 300) {
            this.userState.contentEngagement = Math.min(this.userState.contentEngagement + 0.05, 1);
            this.userState.interactionPattern = "contemplative";
          } else if (avgVelocity > 1500 && velocityVariance > 500) {
            this.userState.contentEngagement = Math.max(this.userState.contentEngagement - 0.1, 0.1);
            this.userState.interactionPattern = "rapid";
          } else {
            this.userState.interactionPattern = "casual";
          }
          if (this.userState.contentEngagement > 0.7) {
            this.visualEffectsIntensity = Math.min(this.visualEffectsIntensity + 0.05, 0.9);
          } else if (this.userState.contentEngagement < 0.3) {
            this.visualEffectsIntensity = Math.max(this.visualEffectsIntensity - 0.1, 0.3);
          }
        }
        /**
         * Calculate interaction modifier for visualEffects intensity
         */
        calculateInteractionModifier() {
          let modifier = 0;
          if (this.userState.readingModeActive) {
            modifier -= 0.6;
          }
          if (this.userState.isHovering) {
            const contentArea = this.contentAreas.get(this.userState.interactionTarget);
            if (contentArea) {
              const reductionFactor = contentArea.type === "text" ? 0.4 : contentArea.type === "interactive" ? 0.3 : contentArea.type === "chrome" ? 0.1 : 0.2;
              modifier -= reductionFactor;
            }
          }
          if (this.userState.scrollVelocity > 1e3) {
            modifier -= 0.2;
          }
          if (this.userState.focusDepth > 0.7 && !this.userState.readingModeActive) {
            modifier += 0.2;
          }
          return modifier;
        }
        /**
         * Calculate contextual modifier based on current application context
         */
        calculateContextualModifier() {
          let modifier = 0;
          if (this.userState.interactionTarget?.matches(".main-nowPlayingBar, .main-nowPlayingWidget")) {
            modifier += 0.3;
          }
          if (this.userState.interactionTarget?.matches(".main-trackList, .main-entityHeader-subtitle")) {
            modifier -= this.userState.currentMode === "exploring" ? 0.1 : 0.3;
          }
          if (this.userState.currentMode === "ambient") {
            modifier += 0.4;
          }
          if (this.userState.currentMode === "navigating") {
            modifier -= 0.2;
          }
          return modifier;
        }
        /**
         * Convert interaction mode to numeric value for CSS
         */
        getModeNumericValue(mode) {
          const modes = { "reading": 0, "browsing": 1, "exploring": 2, "navigating": 3, "ambient": 4 };
          return modes[mode] / 4;
        }
        /**
         * Convert interaction pattern to numeric value for CSS
         */
        getPatternNumericValue(pattern) {
          const patterns = { "contemplative": 0, "casual": 1, "deliberate": 2, "rapid": 3 };
          return patterns[pattern] / 3;
        }
        /**
         * Calculate surface fluidity index based on user behavior and music
         */
        calculateSurfaceFluidityIndex() {
          let fluidity = 0.5;
          fluidity += this.musicalState.energy * 0.3;
          fluidity += this.userState.contentEngagement * 0.2;
          fluidity += this.musicalState.emotionalTemperature * 0.2;
          if (this.userState.interactionPattern === "contemplative") {
            fluidity -= 0.2;
          } else if (this.userState.interactionPattern === "rapid") {
            fluidity += 0.3;
          }
          return Math.max(0.1, Math.min(1, fluidity));
        }
        /**
         * Calculate genre-specific visualEffects shifts
         */
        calculateGenreVisualEffectsShift() {
          if (!this.musicalState.genre) return 0.5;
          const genreShifts = {
            "ambient": 0.8,
            // High visualEffects for ambient music
            "electronic": 0.7,
            // Moderate-high for electronic
            "classical": 0.6,
            // Moderate for classical
            "jazz": 0.5,
            // Balanced for jazz
            "rock": 0.4,
            // Moderate-low for rock
            "pop": 0.3,
            // Lower for pop
            "hip-hop": 0.2
            // Low for hip-hop (focus on lyrics)
          };
          const baseShift = genreShifts[this.musicalState.genre.toLowerCase()] || 0.5;
          let adjustment = 0;
          if (this.musicalState.valence > 0.7) adjustment += 0.1;
          if (this.musicalState.energy > 0.8) adjustment += 0.1;
          return Math.max(0.1, Math.min(1, baseShift + adjustment));
        }
        /**
         * Enhanced interaction listeners with advanced visualEffects awareness
         */
        setupInteractionListeners() {
          let scrollTimer;
          let lastScrollY = window.scrollY;
          let lastScrollTime = Date.now();
          document.addEventListener(
            "scroll",
            () => {
              const now = Date.now();
              const currentScrollY = window.scrollY;
              const timeDelta = now - lastScrollTime;
              const scrollDelta = Math.abs(currentScrollY - lastScrollY);
              this.userState.scrollVelocity = timeDelta > 0 ? scrollDelta / timeDelta * 1e3 : 0;
              this.scrollVelocityHistory.push(this.userState.scrollVelocity);
              if (this.scrollVelocityHistory.length > 10) {
                this.scrollVelocityHistory.shift();
              }
              const avgVelocity = this.scrollVelocityHistory.reduce((a, b) => a + b, 0) / this.scrollVelocityHistory.length;
              if (avgVelocity > 2e3) {
                this.userState.interactionPattern = "rapid";
                this.userState.currentMode = "browsing";
              } else if (avgVelocity > 500) {
                this.userState.interactionPattern = "deliberate";
                this.userState.currentMode = "exploring";
              } else {
                this.userState.interactionPattern = "contemplative";
              }
              this.userState.isScrolling = true;
              this.userState.lastInteractionTime = now;
              lastScrollY = currentScrollY;
              lastScrollTime = now;
              clearTimeout(scrollTimer);
              scrollTimer = window.setTimeout(() => {
                this.userState.isScrolling = false;
                this.analyzeScrollingBehavior();
              }, 150);
              this.updateUserInteractionState();
            },
            { passive: true }
          );
          this.contentAreas.forEach((contentArea, element) => {
            let enterTime = 0;
            element.addEventListener("mouseenter", () => {
              enterTime = Date.now();
              this.userState.isHovering = true;
              this.userState.interactionTarget = element;
              this.userState.lastInteractionTime = enterTime;
              contentArea.lastInteraction = enterTime;
              this.dwellTimeTracker.set(element, enterTime);
              this.userState.focusDepth = Math.min(this.userState.focusDepth + 0.1, 1);
              if (contentArea.type === "text") {
                this.userState.focusDepth = Math.min(this.userState.focusDepth + 0.2, 1);
              }
              this.updateUserInteractionState();
            });
            element.addEventListener("mouseleave", () => {
              const leaveTime = Date.now();
              const dwellTime = leaveTime - enterTime;
              this.userState.dwellTime = dwellTime;
              contentArea.readingIntensity = Math.min(dwellTime / 5e3, 1);
              if (contentArea.type === "text" && dwellTime > 1e3) {
                this.userState.contentEngagement = Math.min(this.userState.contentEngagement + 0.1, 1);
                contentArea.contextualImportance = Math.min(contentArea.contextualImportance + 0.05, 1);
              }
              if (dwellTime > 3e3) {
                const currentProtection = this.adaptiveProtectionMap.get(element) || contentArea.protectionLevel;
                this.adaptiveProtectionMap.set(element, Math.min(currentProtection + 0.05, 0.98));
              }
              this.userState.isHovering = false;
              this.userState.interactionTarget = null;
              this.userState.focusDepth = Math.max(this.userState.focusDepth - 0.05, 0.1);
              this.updateUserInteractionState();
            });
          });
          document.addEventListener("mousemove", () => {
            clearTimeout(this.readingModeTimer);
            this.userState.readingModeActive = false;
            if (this.userState.focusDepth > 0.7) {
              this.userState.currentMode = "reading";
            } else if (this.userState.scrollVelocity > 1e3) {
              this.userState.currentMode = "browsing";
            } else {
              this.userState.currentMode = "exploring";
            }
            const detectionTime = this.userState.currentMode === "reading" ? 1500 : 2e3;
            this.readingModeTimer = window.setTimeout(() => {
              if (this.userState.interactionTarget && this.contentAreas.has(this.userState.interactionTarget)) {
                this.userState.readingModeActive = true;
                this.userState.currentMode = "reading";
                this.userState.focusDepth = Math.min(this.userState.focusDepth + 0.3, 1);
                const contentArea = this.contentAreas.get(this.userState.interactionTarget);
                if (contentArea && contentArea.type === "text") {
                  const currentProtection = this.adaptiveProtectionMap.get(this.userState.interactionTarget) || contentArea.protectionLevel;
                  this.adaptiveProtectionMap.set(this.userState.interactionTarget, Math.min(currentProtection + 0.1, 0.98));
                }
                this.updateUserInteractionState();
              }
            }, detectionTime);
          });
          let ambientTimer;
          const resetAmbientTimer = /* @__PURE__ */ __name(() => {
            clearTimeout(ambientTimer);
            ambientTimer = window.setTimeout(() => {
              this.userState.currentMode = "ambient";
              this.userState.focusDepth = Math.max(this.userState.focusDepth - 0.5, 0.1);
              this.updateUserInteractionState();
            }, 3e4);
          }, "resetAmbientTimer");
          ["mousedown", "mousemove", "keydown", "scroll", "touchstart"].forEach((eventType) => {
            document.addEventListener(eventType, resetAmbientTimer, { passive: true });
          });
          resetAmbientTimer();
          document.addEventListener("music-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.syncWithMusic(customEvent.detail);
            }
          });
          document.addEventListener("beat-detected", () => {
            this.handleBeatPulse();
          });
        }
        /**
         * Initialize CSS visualEffects variables
         */
        initializeVisualEffectsVariables() {
          const initialVariables = {
            "--sn-visual-effects-system-active": "1",
            "--sn-visual-effects-content-protection-level": "0.95",
            "--sn-visual-effects-chrome-enhancement-level": "2.0",
            "--sn-visual-effects-field-animation-rate": "4s",
            "--sn-music-energy-level": "0.5",
            "--sn-feature-reading-mode-active": "0",
            "--sn-visual-effects-user-interaction-detected": "0"
          };
          this.cssController.batchSetVariables(
            "DepthVisualEffectsController",
            initialVariables,
            "normal",
            "visualEffects-initialization"
          );
        }
        /**
         * Start visualEffects update loop
         */
        startVisualEffectsUpdate() {
          const updateVisualEffects = /* @__PURE__ */ __name(() => {
            if (!this.isActive) return;
            const now = performance.now();
            if (now - this.lastUpdate >= this.updateThreshold) {
              this.updateVisualEffectsState();
              this.lastUpdate = now;
            }
            requestAnimationFrame(updateVisualEffects);
          }, "updateVisualEffects");
          updateVisualEffects();
        }
        /**
         * Enhanced visualEffects state update with advanced awareness patterns
         */
        updateVisualEffectsState() {
          const root = document.documentElement;
          const baseIntensity = this.visualEffectsIntensity;
          const musicalModifier = this.musicalState.energy * this.musicalState.musicSyncStrength * 0.3;
          const interactionModifier = this.calculateInteractionModifier();
          const contextualModifier = this.calculateContextualModifier();
          const emotionalModifier = this.musicalState.emotionalTemperature * 0.2;
          const finalVisualEffectsIntensity = Math.max(
            0.05,
            Math.min(1, baseIntensity + musicalModifier + interactionModifier + contextualModifier + emotionalModifier)
          );
          const visualEffectsVariables = {
            "--sn-visual-effects-field-intensity": finalVisualEffectsIntensity.toString(),
            "--sn-visual-effects-level": this.visualEffectsIntensity.toString(),
            "--sn-visual-effects-awareness-level": this.userState.focusDepth.toString(),
            "--sn-music-energy-level": this.musicalState.energy.toString(),
            "--sn-visual-effects-music-sync-strength": this.musicalState.musicSyncStrength.toString(),
            "--sn-color-shift-temperature": this.musicalState.emotionalTemperature.toString(),
            "--sn-feature-reading-mode-active": this.userState.readingModeActive ? "1" : "0",
            "--sn-visual-effects-user-interaction-detected": this.userState.isScrolling || this.userState.isHovering ? "1" : "0",
            "--sn-visual-effects-interaction-mode": this.getModeNumericValue(this.userState.currentMode).toString(),
            "--sn-visual-effects-focus-depth": this.userState.focusDepth.toString(),
            "--sn-visual-effects-content-engagement": this.userState.contentEngagement.toString(),
            "--sn-visual-effects-scroll-velocity": Math.min(this.userState.scrollVelocity / 2e3, 1).toString(),
            "--sn-visual-effects-dwell-time-factor": Math.min(this.userState.dwellTime / 5e3, 1).toString(),
            "--sn-visual-effects-interaction-pattern": this.getPatternNumericValue(this.userState.interactionPattern).toString(),
            "--sn-visual-effects-temporal-flow-direction-x": (Math.sin(Date.now() * 1e-4) * 0.5 + 0.5).toString(),
            "--sn-visual-effects-temporal-flow-direction-y": (Math.cos(Date.now() * 1e-4) * 0.5 + 0.5).toString(),
            "--sn-visual-effects-memory-intensity": this.musicalState.musicalMemoryPatterns.toString(),
            "--sn-visual-effects-fluidity-index": this.calculateSurfaceFluidityIndex().toString(),
            "--sn-visual-effects-genre-shift": this.calculateGenreVisualEffectsShift().toString()
          };
          this.cssController.batchSetVariables(
            "DepthVisualEffectsController",
            visualEffectsVariables,
            "normal",
            "visualEffects-state-update"
          );
          root.classList.remove("music-energy-high", "music-energy-calm");
          if (this.musicalState.energy > 0.7) {
            root.classList.add("music-energy-high");
          } else if (this.musicalState.energy < 0.3) {
            root.classList.add("music-energy-calm");
          }
          root.setAttribute(
            "data-user-interacting",
            (this.userState.isScrolling || this.userState.isHovering).toString()
          );
          root.setAttribute(
            "data-reading-mode",
            this.userState.readingModeActive.toString()
          );
        }
        /**
         * Update user interaction state
         */
        updateUserInteractionState() {
          this.updateVisualEffectsState();
        }
        /**
         * Sync visualEffects with musical state
         */
        syncWithMusic(musicState) {
          Object.assign(this.musicalState, musicState);
          if (musicState.tempo) {
            const breathRate = Math.max(
              2,
              Math.min(8, 60 / (musicState.tempo / 60) * 4)
            );
            this.cssController.setVariable(
              "DepthVisualEffectsController",
              "--sn-visual-effects-field-animation-rate",
              `${breathRate}s`,
              "high",
              // High priority for musical sync
              "musical-tempo-sync"
            );
          }
          this.updateVisualEffectsState();
          Y3KDebug?.debug?.log(
            "DepthVisualEffectsController",
            `Musical visualEffects sync: energy=${musicState.energy}, tempo=${musicState.tempo}`
          );
        }
        /**
         * Handle beat pulse for visualEffects effects
         */
        handleBeatPulse() {
          if (this.userState.readingModeActive) return;
          const root = document.documentElement;
          const currentIntensity = parseFloat(
            root.style.getPropertyValue("--sn-visual-effects-field-intensity") || "0.5"
          );
          const pulseIntensity = Math.min(1, currentIntensity + 0.1);
          this.cssController.setVariable(
            "DepthVisualEffectsController",
            "--sn-visual-effects-field-intensity",
            pulseIntensity.toString(),
            "high",
            "beat-pulse"
          );
          setTimeout(() => {
            if (this.isActive) {
              this.updateVisualEffectsState();
            }
          }, 100);
        }
        /**
         * Dynamically add content protection to new elements
         */
        protectNewContent(element) {
          if (this.contentAreas.has(element)) return;
          const contentArea = {
            element,
            type: this.determineContentType(element),
            protectionLevel: this.calculateProtectionLevel(element),
            lastInteraction: 0,
            visualEffectsLevel: 0.5,
            // Initial visualEffects adaptation level
            readingIntensity: 0,
            // No reading detected initially
            contextualImportance: this.calculateProtectionLevel(element),
            // Use protection level as initial importance
            adaptiveProtection: 0.5
            // Start with moderate adaptive protection
          };
          this.contentAreas.set(element, contentArea);
          element.classList.add("content-sanctuary");
          element.setAttribute("data-visualEffects-protected", "true");
          element.setAttribute("data-content-type", contentArea.type);
          Y3KDebug?.debug?.log(
            "DepthVisualEffectsController",
            `Protected new content element: ${element.tagName}.${element.className}`
          );
        }
        /**
         * Enhanced chrome area
         */
        enhanceNewChrome(element) {
          if (this.chromeAreas.has(element)) return;
          this.chromeAreas.add(element);
          element.classList.add("ui-chrome-area");
          element.setAttribute("data-visualEffects-enhanced", "true");
          Y3KDebug?.debug?.log(
            "DepthVisualEffectsController",
            `Enhanced new chrome element: ${element.tagName}.${element.className}`
          );
        }
        /**
         * Force reading mode for accessibility
         */
        forceReadingMode(active) {
          this.userState.readingModeActive = active;
          this.updateUserInteractionState();
          Y3KDebug?.debug?.log(
            "DepthVisualEffectsController",
            `Reading mode ${active ? "activated" : "deactivated"}`
          );
        }
        /**
         * Get visualEffects metrics for monitoring
         */
        getVisualEffectsMetrics() {
          return {
            contentAreas: this.contentAreas.size,
            chromeAreas: this.chromeAreas.size,
            visualEffectsIntensity: parseFloat(
              document.documentElement.style.getPropertyValue(
                "--sn-visual-effects-field-intensity"
              ) || "0.5"
            ),
            readingModeActive: this.userState.readingModeActive,
            userInteracting: this.userState.isScrolling || this.userState.isHovering,
            musicalEnergy: this.musicalState.energy
          };
        }
        async healthCheck() {
          const metrics = this.getVisualEffectsMetrics();
          const isHealthy = metrics.contentAreas > 0 && metrics.chromeAreas > 0;
          return {
            healthy: isHealthy,
            issues: isHealthy ? [] : ["VisualEffects system not properly initialized"],
            metrics: {
              visualEffectsLevel: metrics.contentAreas > 0 ? 1 : 0,
              protectedAreas: metrics.contentAreas,
              enhancedAreas: metrics.chromeAreas,
              musicalEnergy: metrics.musicalEnergy
            }
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          clearTimeout(this.readingModeTimer);
          clearTimeout(this.interactionTimer);
          this.contentAreas.forEach((_, element) => {
            element.classList.remove("content-sanctuary");
            element.removeAttribute("data-visualEffects-protected");
            element.removeAttribute("data-content-type");
          });
          this.chromeAreas.forEach((element) => {
            element.classList.remove("ui-chrome-area");
            element.removeAttribute("data-visualEffects-enhanced");
          });
          const resetVariables = {
            "--sn-visual-effects-system-active": "",
            "--sn-visual-effects-field-intensity": "",
            "--sn-feature-reading-mode-active": "",
            "--sn-visual-effects-user-interaction-detected": "",
            "--sn-visual-effects-field-animation-rate": "",
            "--sn-music-energy-level": "",
            "--sn-visual-effects-content-protection-level": "",
            "--sn-visual-effects-chrome-enhancement-level": ""
          };
          this.cssController.batchSetVariables(
            "DepthVisualEffectsController",
            resetVariables,
            "critical",
            // Critical priority for cleanup
            "system-cleanup"
          );
          const root = document.documentElement;
          root.classList.remove("music-energy-high", "music-energy-calm");
          root.removeAttribute("data-user-interacting");
          root.removeAttribute("data-reading-mode");
          Y3KDebug?.debug?.log(
            "DepthVisualEffectsController",
            "VisualEffects system deactivated"
          );
        }
      };
      __name(_DepthVisualEffectsController, "DepthVisualEffectsController");
      DepthVisualEffectsController = _DepthVisualEffectsController;
    }
  });

  // src-js/visual/atmospheric/AtmosphericCrystalsSystem.ts
  var AtmosphericCrystalsSystem_exports = {};
  __export(AtmosphericCrystalsSystem_exports, {
    AtmosphericCrystalsSystem: () => AtmosphericCrystalsSystem
  });
  var _AtmosphericCrystalsSystem, AtmosphericCrystalsSystem;
  var init_AtmosphericCrystalsSystem = __esm({
    "src-js/visual/atmospheric/AtmosphericCrystalsSystem.ts"() {
      "use strict";
      _AtmosphericCrystalsSystem = class _AtmosphericCrystalsSystem {
        constructor() {
          this.initialized = false;
          this.overlayContainer = null;
          this.crystalElements = [];
          this.reducedMotion = false;
        }
        async initialize() {
          if (this.initialized) return;
          this.reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
          this.overlayContainer = document.createElement("div");
          this.overlayContainer.className = "sn-crystalline-overlay";
          const crystalVariants = ["a", "b", "c"];
          for (const variant of crystalVariants) {
            const crystal = document.createElement("div");
            crystal.className = `sn-atmospheric-crystal sn-atmospheric-crystal--${variant}`;
            if (this.reducedMotion) {
              crystal.style.animation = "none";
            }
            this.overlayContainer.appendChild(crystal);
            this.crystalElements.push(crystal);
          }
          document.body.appendChild(this.overlayContainer);
          this.initialized = true;
        }
        updateAnimation(_deltaTime) {
        }
        async healthCheck() {
          if (!this.initialized) {
            return {
              healthy: false,
              details: "AtmosphericCrystalsSystem not initialized"
            };
          }
          const overlayInDOM = document.body.contains(this.overlayContainer);
          const crystalsIntact = this.crystalElements.length === 3 && this.crystalElements.every((el) => this.overlayContainer?.contains(el));
          if (!overlayInDOM || !crystalsIntact) {
            return {
              healthy: false,
              details: `Crystal elements missing (overlay: ${overlayInDOM}, crystals: ${crystalsIntact})`
            };
          }
          return {
            healthy: true,
            details: "AtmosphericCrystalsSystem operational - 3 crystals rendering"
          };
        }
        destroy() {
          if (this.overlayContainer && document.body.contains(this.overlayContainer)) {
            document.body.removeChild(this.overlayContainer);
          }
          this.crystalElements = [];
          this.overlayContainer = null;
          this.initialized = false;
        }
        forceRepaint() {
        }
      };
      __name(_AtmosphericCrystalsSystem, "AtmosphericCrystalsSystem");
      AtmosphericCrystalsSystem = _AtmosphericCrystalsSystem;
    }
  });

  // src-js/visual/effects/DynamicCatppuccinBridge.ts
  var DynamicCatppuccinBridge_exports = {};
  __export(DynamicCatppuccinBridge_exports, {
    DynamicCatppuccinBridge: () => DynamicCatppuccinBridge
  });
  var _DynamicCatppuccinBridge, DynamicCatppuccinBridge;
  var init_DynamicCatppuccinBridge = __esm({
    "src-js/visual/effects/DynamicCatppuccinBridge.ts"() {
      "use strict";
      init_globalConfig();
      init_UnifiedEventBus();
      init_OptimizedCSSVariableManager();
      init_UnifiedDebugManager();
      init_ThemeUtilities();
      init_BaseVisualSystem();
      _DynamicCatppuccinBridge = class _DynamicCatppuccinBridge extends BaseVisualSystem {
        constructor(config = ADVANCED_SYSTEM_CONFIG, utils = ThemeUtilities_exports, performanceMonitor = null, musicSyncService = null, settingsManager2 = null) {
          super(config, utils, performanceMonitor, musicSyncService, settingsManager2);
          this.colorHarmonyEngine = null;
          this.depthVisualController = null;
          this.dynamicColorState = {
            currentAccentHex: "#675c8f",
            // Default Catppuccin Mocha mauve (proper fallback)
            currentAccentRgb: "203,166,247",
            baseBackgroundHex: "#0d1117",
            // Default StarryNight deep space black
            baseBackgroundRgb: "13,17,23",
            lastUpdateTime: 0,
            musicEnergy: 0.5,
            transitionInProgress: false
          };
          this.integrationConfig = {
            accentUpdateEnabled: true,
            baseTransformationEnabled: true,
            visualIntegrationEnabled: true,
            smoothTransitionDuration: 800,
            // 0.8s smooth transitions
            energyResponseMultiplier: 1.2
          };
          // Transition management - now handled by coordinator updateAnimation() loop
          this.transitionTimer = 0;
          this.lastTransitionStartTime = 0;
          this.transitionFromAccent = "";
          this.transitionToAccent = "";
          this.transitionElapsedTime = 0;
        }
        async _performSystemSpecificInitialization() {
          await super._performSystemSpecificInitialization();
          try {
            const year3000System = globalThis.year3000System;
            this.cssController = year3000System?.cssController || getGlobalOptimizedCSSController();
            this.setupColorExtractionListeners();
            this.setupSettingsListeners();
            this.initializeCurrentState();
            const isEnabled = this.checkDynamicAccentEnabled();
            this.integrationConfig.accentUpdateEnabled = isEnabled;
            if (isEnabled) {
              Y3KDebug?.debug?.log(
                "DynamicCatppuccinBridge",
                "Dynamic accent enabled - bridge active"
              );
            } else {
              Y3KDebug?.debug?.log(
                "DynamicCatppuccinBridge",
                "Dynamic accent disabled - bridge standby (will activate when enabled)"
              );
            }
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              "Color Extension Facade initialized successfully"
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinBridge",
              "Failed to initialize facade:",
              error
            );
          }
        }
        /**
         * Check if dynamic accent is enabled in settings
         */
        checkDynamicAccentEnabled() {
          try {
            if (!this.settingsManager) return false;
            const accentSetting = this.settingsManager.get("catppuccin-accentColor");
            const isDynamic = String(accentSetting) === "dynamic";
            if (this.config.enableDebug) {
              Y3KDebug?.debug?.log(
                "DynamicCatppuccinBridge",
                `Accent setting: ${accentSetting}, Dynamic: ${isDynamic}`
              );
            }
            return isDynamic;
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinBridge",
              "Error checking dynamic accent setting:",
              error
            );
            return false;
          }
        }
        /**
         * Setup listeners for color extraction events
         * 🔧 CRITICAL FIX: Enhanced with UnifiedEventBus integration
         */
        setupColorExtractionListeners() {
          unifiedEventBus.subscribe(
            "colors:extracted",
            (data) => {
              if (data.rawColors) {
                this.handleExtractedColors(data.rawColors);
              }
            },
            "DynamicCatppuccinBridge"
          );
          unifiedEventBus.subscribe(
            "colors:harmonized",
            (data) => {
              if (data.processedColors) {
                this.handleHarmonizedColors(data.processedColors);
              }
            },
            "DynamicCatppuccinBridge"
          );
          unifiedEventBus.subscribe(
            "colors:applied",
            (data) => {
              if (data.cssVariables && this.integrationConfig.accentUpdateEnabled) {
                this.handleCSSVariablesApplied(
                  data.cssVariables,
                  data.accentHex,
                  data.accentRgb
                );
              }
            },
            "DynamicCatppuccinBridge"
          );
          document.addEventListener("colors-extracted", (event) => {
            const customEvent = event;
            if (customEvent.detail && customEvent.detail.extractedColors) {
              this.handleExtractedColors(customEvent.detail.extractedColors);
            }
          });
          document.addEventListener("colors-harmonized", (event) => {
            const customEvent = event;
            if (customEvent.detail && customEvent.detail.harmonizedColors) {
              this.handleHarmonizedColors(customEvent.detail.harmonizedColors);
            }
          });
          document.addEventListener("music-state-change", (event) => {
            const customEvent = event;
            if (customEvent.detail) {
              this.handleMusicStateChange(customEvent.detail);
            }
          });
          document.addEventListener("spice-colors/update-request", (event) => {
            const customEvent = event;
            if (customEvent.detail && this.integrationConfig.accentUpdateEnabled) {
              this.handleSpiceColorUpdateRequest(customEvent.detail);
            }
          });
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Enhanced color extraction and coordination listeners setup complete (UnifiedEventBus + DOM)"
          );
        }
        /**
         * Handle requests from other systems to update spice colors
         */
        handleSpiceColorUpdateRequest(colorData) {
          const { accentHex, primaryHex, secondaryHex, source } = colorData;
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              `Received spice color update request from ${source}:`,
              {
                accent: accentHex,
                primary: primaryHex,
                secondary: secondaryHex
              }
            );
          }
          if (accentHex && accentHex !== this.dynamicColorState.currentAccentHex) {
            this.scheduleSmoothAccentTransition(accentHex);
          }
          if (primaryHex) {
            this.updateLivingBaseBackground(primaryHex);
          }
          document.dispatchEvent(
            new CustomEvent("spice-colors/updated", {
              detail: {
                source: "DynamicCatppuccinBridge",
                applied: {
                  accent: accentHex,
                  primary: primaryHex,
                  secondary: secondaryHex
                },
                timestamp: Date.now()
              }
            })
          );
        }
        /**
         * Setup settings change listeners
         */
        setupSettingsListeners() {
          document.addEventListener(
            "year3000SystemSettingsChanged",
            (event) => {
              const customEvent = event;
              const { key, value } = customEvent.detail || {};
              if (key === "catppuccin-accentColor") {
                const isDynamic = String(value) === "dynamic";
                this.integrationConfig.accentUpdateEnabled = isDynamic;
                if (isDynamic && !this.isActive) {
                  this.initialize();
                } else if (!isDynamic && this.isActive) {
                  this.destroy();
                }
                Y3KDebug?.debug?.log(
                  "DynamicCatppuccinBridge",
                  `Accent setting changed to: ${value}, Bridge active: ${this.isActive}`
                );
              }
            }
          );
        }
        /**
         * Initialize current state from existing CSS variables
         * Prioritizes ColorHarmonyEngine variables, then falls back to Catppuccin defaults
         */
        initializeCurrentState() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          const currentAccent = computedStyle.getPropertyValue("--sn-accent-hex").trim() || computedStyle.getPropertyValue("--sn-musical-harmony-primary-hex").trim() || computedStyle.getPropertyValue("--sn-dynamic-accent-hex").trim() || computedStyle.getPropertyValue("--sn-cosmic-accent-hex").trim() || computedStyle.getPropertyValue("--spice-accent").trim();
          if (currentAccent) {
            this.dynamicColorState.currentAccentHex = currentAccent;
            const rgb = this.utils.hexToRgb(currentAccent);
            if (rgb) {
              this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
            }
          }
          const currentBase = computedStyle.getPropertyValue("--sn-cosmic-base-hex").trim() || computedStyle.getPropertyValue("--spice-base").trim() || "#0d1117";
          this.dynamicColorState.baseBackgroundHex = currentBase;
          const baseRgb = this.utils.hexToRgb(currentBase);
          if (baseRgb) {
            this.dynamicColorState.baseBackgroundRgb = `${baseRgb.r},${baseRgb.g},${baseRgb.b}`;
          }
          this.dynamicColorState.lastUpdateTime = Date.now();
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Current state initialized:",
            {
              accent: this.dynamicColorState.currentAccentHex,
              base: this.dynamicColorState.baseBackgroundHex
            }
          );
        }
        /**
         * Handle extracted colors from ColorHarmonyEngine
         */
        handleExtractedColors(extractedColors) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            const newAccentHex = this.selectBestAccentColor(extractedColors);
            if (newAccentHex && newAccentHex !== this.dynamicColorState.currentAccentHex) {
              this.scheduleSmoothAccentTransition(newAccentHex);
            }
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              "Processed extracted colors:",
              {
                input: Object.keys(extractedColors),
                selectedAccent: newAccentHex
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinBridge",
              "Error handling extracted colors:",
              error
            );
          }
        }
        /**
         * Handle harmonized colors (post-processing)
         * Extract accent color from ColorHarmonyEngine and apply it immediately
         */
        handleHarmonizedColors(harmonizedColors) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            const newAccentHex = harmonizedColors["VIBRANT"] || harmonizedColors["PROMINENT"] || harmonizedColors["VIBRANT_NON_ALARMING"] || harmonizedColors["LIGHT_VIBRANT"] || harmonizedColors["PRIMARY"] || Object.values(harmonizedColors)[0];
            if (newAccentHex && newAccentHex !== this.dynamicColorState.currentAccentHex) {
              if (this.config.enableDebug) {
                console.log(
                  "\u{1F3A8} [DynamicCatppuccinBridge] Applying harmonized accent color:",
                  {
                    from: this.dynamicColorState.currentAccentHex,
                    to: newAccentHex,
                    source: "ColorHarmonyEngine harmonized colors"
                  }
                );
              }
              this.scheduleSmoothAccentTransition(newAccentHex);
            }
            this.applyHarmonizedColorsToDynamicSystem(harmonizedColors);
          } catch (error) {
            console.error(
              "\u{1F3A8} [DynamicCatppuccinBridge] Error handling harmonized colors:",
              error
            );
          }
        }
        /**
         * Handle CSS variables applied event from ColorHarmonyEngine
         * 🔧 CRITICAL FIX: New handler for colors:applied events
         */
        handleCSSVariablesApplied(cssVariables, accentHex, accentRgb) {
          if (!this.integrationConfig.accentUpdateEnabled) return;
          try {
            if (accentHex && accentHex !== this.dynamicColorState.currentAccentHex) {
              this.dynamicColorState.currentAccentHex = accentHex;
              this.dynamicColorState.currentAccentRgb = accentRgb;
              this.dynamicColorState.lastUpdateTime = Date.now();
            }
            const enhancedVariables = {};
            const accent = cssVariables["--sn-accent-hex"] || cssVariables["--spice-accent"] || accentHex;
            const accentRgbVar = cssVariables["--sn-accent-rgb"] || cssVariables["--spice-rgb-accent"] || accentRgb;
            if (accent && accentRgbVar) {
              enhancedVariables["--sn-dynamic-accent-hex"] = accent;
              enhancedVariables["--sn-dynamic-accent-rgb"] = accentRgbVar;
              enhancedVariables["--sn-dynamic-primary-hex"] = accent;
              enhancedVariables["--sn-dynamic-primary-rgb"] = accentRgbVar;
              if (Object.keys(enhancedVariables).length > 0) {
                this.cssController.batchSetVariables(
                  "DynamicCatppuccinBridge",
                  enhancedVariables,
                  "critical",
                  // Critical priority for dynamic accent coordination
                  "css-variables-applied-enhancement"
                );
              }
            }
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              "Processed colors:applied event:",
              {
                accentHex: accent,
                accentRgb: accentRgbVar,
                variablesProcessed: Object.keys(cssVariables).length,
                enhancedVariables: Object.keys(enhancedVariables).length
              }
            );
          } catch (error) {
            Y3KDebug?.debug?.error(
              "DynamicCatppuccinBridge",
              "Error handling CSS variables applied:",
              error
            );
          }
        }
        /**
         * Handle music state changes for energy-responsive effects
         */
        handleMusicStateChange(musicState) {
          if (musicState.energy !== void 0) {
            this.dynamicColorState.musicEnergy = musicState.energy;
            if (this.integrationConfig.visualIntegrationEnabled) {
              this.updateVisualWithMusicEnergy(musicState.energy);
            }
          }
        }
        /**
         * Select best accent color from extracted colors
         */
        selectBestAccentColor(colors) {
          const priorities = [
            "VIBRANT_NON_ALARMING",
            // Best for UI - vibrant but not overwhelming
            "VIBRANT",
            // Strong and lively
            "LIGHT_VIBRANT",
            // Lighter variant
            "PROMINENT",
            // Most noticeable color
            "PRIMARY",
            // Primary extracted color
            "DARK_VIBRANT"
            // Darker variant as fallback
          ];
          for (const key of priorities) {
            const color3 = colors[key];
            if (color3 && this.utils.hexToRgb(color3)) {
              return color3;
            }
          }
          return null;
        }
        /**
         * Schedule smooth transition between accent colors
         */
        scheduleSmoothAccentTransition(newAccentHex) {
          if (this.dynamicColorState.transitionInProgress) {
            this.transitionToAccent = newAccentHex;
            return;
          }
          this.transitionFromAccent = this.dynamicColorState.currentAccentHex;
          this.transitionToAccent = newAccentHex;
          this.dynamicColorState.transitionInProgress = true;
          this.lastTransitionStartTime = Date.now();
          this.animateAccentTransition();
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            `Accent transition scheduled: ${this.transitionFromAccent} \u2192 ${newAccentHex}`
          );
        }
        /**
         * Animate smooth accent color transitions
         * MIGRATION NOTE: This method previously used standalone RAF loop.
         * Now transitions are driven by EnhancedMasterAnimationCoordinator via updateAnimation().
         * The coordinator will call updateAnimation(deltaTime) which handles all transition logic.
         */
        animateAccentTransition() {
        }
        /**
         * Interpolate between two hex colors
         */
        interpolateColors(fromHex, toHex, progress) {
          const fromRgb = this.utils.hexToRgb(fromHex);
          const toRgb = this.utils.hexToRgb(toHex);
          if (!fromRgb || !toRgb) return null;
          const r = Math.round(fromRgb.r + (toRgb.r - fromRgb.r) * progress);
          const g = Math.round(fromRgb.g + (toRgb.g - fromRgb.g) * progress);
          const b = Math.round(fromRgb.b + (toRgb.b - fromRgb.b) * progress);
          return this.utils.rgbToHex(r, g, b);
        }
        /**
         * Apply dynamic accent using Color Extension Facade
         * Updates both core Spicetify variables AND visualEffects extensions
         */
        applyDynamicAccent(accentHex) {
          console.log("\u{1F3A8} [DynamicCatppuccinBridge] Applying dynamic accent color:", {
            accentHex,
            previousAccent: this.dynamicColorState.currentAccentHex,
            timestamp: Date.now()
          });
          const root = document.documentElement;
          const rgb = this.utils.hexToRgb(accentHex);
          if (!rgb) {
            console.error(
              "\u{1F3A8} [DynamicCatppuccinBridge] Failed to convert accent hex to RGB:",
              accentHex
            );
            return;
          }
          const rgbString = `${rgb.r},${rgb.g},${rgb.b}`;
          const variablesToSet = {
            "--sn-dynamic-accent-hex": accentHex,
            "--sn-dynamic-accent-rgb": rgbString,
            "--sn-dynamic-primary-hex": accentHex,
            "--sn-dynamic-primary-rgb": rgbString,
            "--spice-accent": accentHex,
            "--spice-button": accentHex,
            "--spice-button-active": accentHex,
            "--spice-rgb-accent": rgbString,
            "--spice-rgb-button": rgbString,
            "--sn-color-extracted-primary-rgb": rgbString,
            "--sn-color-extracted-vibrant-rgb": rgbString,
            "--sn-color-extracted-dominant-rgb": rgbString
          };
          console.log(
            "\u{1F3A8} [DynamicCatppuccinBridge] Setting CSS variables:",
            variablesToSet
          );
          this.cssController.batchSetVariables(
            "DynamicCatppuccinBridge",
            variablesToSet,
            "critical",
            // Critical priority for dynamic accent system - highest priority in cascade
            "dynamic-accent-application"
          );
          if (this.integrationConfig.visualIntegrationEnabled) {
            this.updateVisualWithAccent(accentHex, rgbString);
          }
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              `Applied gradient colors: --sn-bg-gradient-primary=${accentHex}, --sn-bg-gradient-primary-rgb=${rgbString}`
            );
          }
        }
        /**
         * Apply harmonized colors to the dynamic system
         */
        applyHarmonizedColorsToDynamicSystem(harmonizedColors) {
          const primaryHex = harmonizedColors.VIBRANT || harmonizedColors.PRIMARY;
          if (primaryHex) {
            if (this.integrationConfig.baseTransformationEnabled) {
              this.updateLivingBaseBackground(primaryHex);
            }
          }
        }
        /**
         * Update visual system with new accent awareness
         */
        updateVisualWithAccent(accentHex, accentRgb) {
          const root = document.documentElement;
          const visualAccentVariables = {
            "--sn-holographic-rgb": accentRgb,
            "--holographic-scanline-rgb": accentRgb,
            "--visual-intensity": `calc(0.5 + var(--musical-sync-intensity) * ${this.integrationConfig.energyResponseMultiplier}),`
          };
          this.cssController.batchSetVariables(
            "DynamicCatppuccinBridge",
            visualAccentVariables,
            "high",
            // High priority for visual accent integration
            "visual-accent-update"
          );
          if (this.depthVisualController) {
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              "Notifying depth visual controller of accent change"
            );
          }
        }
        /**
         * Update visual system with music energy
         */
        updateVisualWithMusicEnergy(energy) {
          const root = document.documentElement;
          const adjustedEnergy = energy * this.integrationConfig.energyResponseMultiplier;
          const musicalEnergyVariables = {
            "--musical-sync-intensity": adjustedEnergy.toString(),
            "--holographic-music-flicker-intensity": adjustedEnergy.toString()
          };
          this.cssController.batchSetVariables(
            "DynamicCatppuccinBridge",
            musicalEnergyVariables,
            "high",
            // High priority for musical energy synchronization
            "musical-energy-update"
          );
          const baseIntensity = 0.5;
          const visualIntensity = Math.max(
            0.1,
            Math.min(1, baseIntensity + adjustedEnergy * 0.3)
          );
          this.cssController.setVariable(
            "DynamicCatppuccinBridge",
            "--visual-intensity",
            visualIntensity.toString(),
            "high",
            // High priority for visual intensity - affects visual levels
            "visual-intensity-update"
          );
        }
        /**
         * Update living base background using Color Extension Facade
         * Preserves Spicetify base while adding visual layers
         */
        updateLivingBaseBackground(primaryHex) {
          const root = document.documentElement;
          const primaryRgb = this.utils.hexToRgb(primaryHex);
          if (!primaryRgb) return;
          const primaryRgbString = `${primaryRgb.r},${primaryRgb.g},${primaryRgb.b}`;
          const secondaryColorVariables = {
            "--sn-dynamic-secondary-hex": primaryHex,
            "--sn-dynamic-secondary-rgb": primaryRgbString,
            "--sn-color-extracted-secondary-rgb": primaryRgbString,
            "--sn-color-harmony-complementary-rgb": primaryRgbString
          };
          this.cssController.batchSetVariables(
            "DynamicCatppuccinBridge",
            secondaryColorVariables,
            "high",
            // High priority for secondary color system
            "secondary-color-update"
          );
          const visualGradient = `
      linear-gradient(135deg,
        var(--spice-base) 0%,
        rgba(${primaryRgbString}, 0.08) 30%,
        var(--spice-base) 70%
      ),
      var(--spice-base)
    `;
          const livingGradientVariables = {
            "--living-base-gradient": visualGradient,
            "--visual-base-gradient": visualGradient
          };
          this.cssController.batchSetVariables(
            "DynamicCatppuccinBridge",
            livingGradientVariables,
            "normal",
            // Normal priority for living gradient background effects
            "living-gradient-update"
          );
          if (this.config.enableDebug) {
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              `Living base updated: --sn-bg-gradient-secondary=${primaryHex}, --sn-bg-gradient-secondary-rgb=${primaryRgbString}`
            );
          }
        }
        /**
         * Link with other visual systems
         */
        linkWithColorHarmonyEngine(engine) {
          this.colorHarmonyEngine = engine;
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Linked with ColorHarmonyEngine"
          );
        }
        linkWithDepthVisual(controller) {
          this.depthVisualController = controller;
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Linked with DepthLayerController"
          );
        }
        /**
         * updateAnimation() - Called by EnhancedMasterAnimationCoordinator at 60fps
         * Handles color transition animations that were previously in standalone RAF loop
         */
        updateAnimation(deltaTime) {
          if (!this.dynamicColorState.transitionInProgress) return;
          this.transitionElapsedTime += deltaTime;
          const progress = Math.min(
            this.transitionElapsedTime / this.integrationConfig.smoothTransitionDuration,
            1
          );
          const easeProgress = 1 - Math.pow(1 - progress, 3);
          const currentColor = this.interpolateColors(
            this.transitionFromAccent,
            this.transitionToAccent,
            easeProgress
          );
          if (currentColor) {
            this.applyDynamicAccent(currentColor);
          }
          if (progress >= 1) {
            this.dynamicColorState.transitionInProgress = false;
            this.dynamicColorState.currentAccentHex = this.transitionToAccent;
            this.dynamicColorState.lastUpdateTime = Date.now();
            this.transitionElapsedTime = 0;
            const rgb = this.utils.hexToRgb(this.transitionToAccent);
            if (rgb) {
              this.dynamicColorState.currentAccentRgb = `${rgb.r},${rgb.g},${rgb.b}`;
            }
            Y3KDebug?.debug?.log(
              "DynamicCatppuccinBridge",
              `Accent transition complete: ${this.transitionToAccent}`
            );
          }
        }
        /**
         * Get current dynamic color state for debugging
         */
        getDynamicColorState() {
          return { ...this.dynamicColorState };
        }
        /**
         * Debug utility: Get current facade variable values
         */
        getFacadeVariableStatus() {
          const root = document.documentElement;
          const computedStyle = getComputedStyle(root);
          return {
            // Core Spicetify Variables
            spicetifyVars: {
              accent: computedStyle.getPropertyValue("--spice-accent").trim(),
              button: computedStyle.getPropertyValue("--spice-button").trim(),
              rgbAccent: computedStyle.getPropertyValue("--spice-rgb-accent").trim(),
              base: computedStyle.getPropertyValue("--spice-base").trim()
            },
            // Visual Extensions
            visualVars: {
              gradientPrimary: computedStyle.getPropertyValue("--sn-bg-gradient-primary-rgb").trim(),
              accentHex: computedStyle.getPropertyValue("--sn-color-accent-hex").trim(),
              accentRgb: computedStyle.getPropertyValue("--sn-color-accent-rgb").trim(),
              extractedPrimary: computedStyle.getPropertyValue("--sn-color-extracted-primary-rgb").trim(),
              livingBaseGradient: computedStyle.getPropertyValue("--living-base-gradient").trim()
            },
            // Configuration Status
            config: {
              dynamicAccentEnabled: this.checkDynamicAccentEnabled(),
              accentUpdateEnabled: this.integrationConfig.accentUpdateEnabled,
              visualEnabled: this.integrationConfig.visualIntegrationEnabled,
              isActive: this.isActive
            }
          };
        }
        /**
         * Update integration configuration
         */
        updateConfig(newConfig) {
          this.integrationConfig = { ...this.integrationConfig, ...newConfig };
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Configuration updated:",
            newConfig
          );
        }
        async healthCheck() {
          const isDynamicEnabled = this.checkDynamicAccentEnabled();
          const hasRecentUpdate = Date.now() - this.dynamicColorState.lastUpdateTime < 3e4;
          return {
            healthy: this.isActive && isDynamicEnabled,
            issues: this.isActive && !isDynamicEnabled ? ["Dynamic accent not enabled in settings"] : [],
            metrics: {
              dynamicAccentEnabled: isDynamicEnabled,
              currentAccent: this.dynamicColorState.currentAccentHex,
              lastUpdateAge: Date.now() - this.dynamicColorState.lastUpdateTime,
              hasRecentUpdate,
              transitionInProgress: this.dynamicColorState.transitionInProgress,
              musicEnergy: this.dynamicColorState.musicEnergy
            }
          };
        }
        _performSystemSpecificCleanup() {
          super._performSystemSpecificCleanup();
          if (this.transitionTimer) {
            clearTimeout(this.transitionTimer);
            this.transitionTimer = 0;
          }
          this.dynamicColorState.transitionInProgress = false;
          unifiedEventBus.unsubscribeAll("DynamicCatppuccinBridge");
          Y3KDebug?.debug?.log(
            "DynamicCatppuccinBridge",
            "Dynamic Catppuccin bridge cleaned up (including UnifiedEventBus subscriptions)"
          );
        }
      };
      __name(_DynamicCatppuccinBridge, "DynamicCatppuccinBridge");
      DynamicCatppuccinBridge = _DynamicCatppuccinBridge;
    }
  });

  // src-js/core/performance/CDFVariableBridge.ts
  var CDFVariableBridge_exports = {};
  __export(CDFVariableBridge_exports, {
    CDFVariableBridge: () => CDFVariableBridge
  });
  var _CDFVariableBridge, CDFVariableBridge;
  var init_CDFVariableBridge = __esm({
    "src-js/core/performance/CDFVariableBridge.ts"() {
      "use strict";
      init_UnifiedEventBus();
      _CDFVariableBridge = class _CDFVariableBridge {
        constructor(batcher) {
          this.batcher = batcher;
          this.reduceMotionMQ = null;
          this._mqHandler = null;
          const subscriptionId = unifiedEventBus.subscribe(
            "performance:frame",
            (data) => {
              const ctx = {
                deltaMs: data.deltaTime || 16.67,
                timestamp: data.timestamp || Date.now(),
                performanceMode: "performance",
                frameBudget: 16.67
              };
              this._handleFrame(ctx);
            },
            "CDFVariableBridge"
          );
          this.unsubscribe = () => unifiedEventBus.unsubscribe(subscriptionId);
          if (typeof window !== "undefined" && window.matchMedia) {
            this.reduceMotionMQ = window.matchMedia(
              "(prefers-reduced-motion: reduce)"
            );
            this._syncReducedMotion(this.reduceMotionMQ.matches);
            this._mqHandler = (e) => {
              this._syncReducedMotion(e.matches);
            };
            try {
              this.reduceMotionMQ.addEventListener("change", this._mqHandler);
            } catch {
              this.reduceMotionMQ.addListener(this._mqHandler);
            }
          }
        }
        destroy() {
          this.unsubscribe?.();
          if (this.reduceMotionMQ && this._mqHandler) {
            try {
              this.reduceMotionMQ.removeEventListener("change", this._mqHandler);
            } catch {
              this.reduceMotionMQ.removeListener(this._mqHandler);
            }
          }
        }
        // -------------------------------------------------------------------------
        // Internal helpers
        // -------------------------------------------------------------------------
        _handleFrame(ctx) {
          if (typeof ctx.scrollRatio === "number") {
            this.batcher.queueCSSVariableUpdate(
              "--sn-cdf-scroll-ratio",
              ctx.scrollRatio.toFixed(3)
            );
            this.batcher.queueCSSVariableUpdate(
              "--sn-scroll-ratio",
              ctx.scrollRatio.toFixed(3)
            );
          }
          if (typeof ctx.beatIntensity === "number") {
            const val = ctx.beatIntensity.toFixed(3);
            this.batcher.queueCSSVariableUpdate("--sn-cdf-energy", val);
            this.batcher.queueCSSVariableUpdate("--sn-beat-intensity", val);
          }
        }
        _syncReducedMotion(reduce) {
          this.batcher.queueCSSVariableUpdate("--sn-cdf-enabled", reduce ? "0" : "1");
        }
      };
      __name(_CDFVariableBridge, "CDFVariableBridge");
      CDFVariableBridge = _CDFVariableBridge;
    }
  });

  // src-js/theme.entry.ts
  init_globalConfig();
  init_AdvancedThemeSystem();
  init_UnifiedDebugManager();
  init_ThemeUtilities();

  // src-js/utils/platform/spicetifyReady.ts
  async function waitForSpicetifyReady(timeout = 1e4, checkInterval = 100) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      const spicetify = window.Spicetify;
      if (spicetify?.showNotification && spicetify?.Platform) {
        return true;
      }
      await new Promise((res) => setTimeout(res, checkInterval));
    }
    return false;
  }
  __name(waitForSpicetifyReady, "waitForSpicetifyReady");

  // src-js/visual/ui/Aberration/AberrationManager.ts
  init_OptimizedCSSVariableManager();

  // src-js/visual/ui/Aberration/AberrationCanvas.ts
  var _AberrationCanvas = class _AberrationCanvas {
    constructor(parent, y3k = null) {
      this.parent = parent;
      this.y3k = y3k;
      this.gl = null;
      this.program = null;
      this.tex = null;
      this.strength = 0.4;
      // default; overridden via CSS var
      this.rafId = null;
      this.frameStart = 0;
      this._defaultSize = 256;
      // Bound handlers so we can remove them in destroy()
      this._boundContextLost = /* @__PURE__ */ __name((e) => this._handleContextLost(e), "_boundContextLost");
      this._boundContextRestored = /* @__PURE__ */ __name(() => this._handleContextRestored(), "_boundContextRestored");
      this.canvas = document.createElement("canvas");
      this.canvas.width = this._defaultSize;
      this.canvas.height = this._defaultSize;
      this.canvas.style.width = "100%";
      this.canvas.style.height = "100%";
      Object.assign(this.canvas.style, {
        position: "absolute",
        inset: "0",
        pointerEvents: "none",
        mixBlendMode: "overlay",
        // Changed from "screen" to prevent white bleeding
        zIndex: "-1",
        opacity: "0.6"
        // Reduced opacity to prevent harsh effects
      });
      this.parent.appendChild(this.canvas);
      this.perf = y3k?.performanceAnalyzer ?? null;
      this.canvas.addEventListener(
        "webglcontextlost",
        this._boundContextLost,
        false
      );
      this.canvas.addEventListener(
        "webglcontextrestored",
        this._boundContextRestored,
        false
      );
      this._initGL();
    }
    _initGL() {
      const gl = this.canvas.getContext("webgl", {
        premultipliedAlpha: false,
        alpha: true,
        antialias: false
      });
      if (!gl) {
        console.warn("[AberrationCanvas] WebGL not available \u2013 effect disabled");
        return;
      }
      this.gl = gl;
      const vsSource = `attribute vec2 aPos; varying vec2 vUv; void main(){ vUv = (aPos+1.0)*0.5; gl_Position = vec4(aPos,0.0,1.0); }`;
      const fsSource = `precision mediump float; uniform sampler2D uTex; uniform float uStrength; uniform float uTime; varying vec2 vUv; void main(){ float freq = 8.0; vec2 offset = vec2(sin(vUv.y*freq+uTime)*uStrength, 0.0); vec4 c; c.r = texture2D(uTex, vUv + offset).r; c.g = texture2D(uTex, vUv).g; c.b = texture2D(uTex, vUv - offset).b; c.a = clamp(uStrength * 1.5, 0.0, 0.6); gl_FragColor = c; }`;
      const compile = /* @__PURE__ */ __name((type, src) => {
        const sh = gl.createShader(type);
        gl.shaderSource(sh, src);
        gl.compileShader(sh);
        return sh;
      }, "compile");
      const vs = compile(gl.VERTEX_SHADER, vsSource);
      const fs = compile(gl.FRAGMENT_SHADER, fsSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error("[AberrationCanvas] Shader link failed");
        return;
      }
      this.program = prog;
      gl.useProgram(prog);
      const verts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
      const loc = gl.getAttribLocation(prog, "aPos");
      gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        1,
        1,
        0,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        new Uint8Array([0, 0, 0, 0])
        // Changed from white [255,255,255,255] to transparent [0,0,0,0]
      );
      this.tex = tex;
    }
    /** Public API: update strength via CSS variable (0–1) */
    setStrength(value) {
      this.strength = value;
    }
    /** Uploads a bitmap (e.g., gradient snapshot) into the shader texture. */
    updateSourceBitmap(bmp) {
      if (!this.gl || !this.tex) return;
      const gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, this.tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bmp);
    }
    /**
     * Public render hook – called by AberrationVisualSystem.onAnimate().
     * All original rendering logic from the private _render loop lives here so
     * that the effect can be orchestrated by MasterAnimationCoordinator.
     */
    render(time) {
      if (!this.gl || !this.program) return;
      const gl = this.gl;
      if (this.perf) this.frameStart = performance.now();
      gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.useProgram(this.program);
      const uTexLoc = gl.getUniformLocation(this.program, "uTex");
      const uStrLoc = gl.getUniformLocation(this.program, "uStrength");
      const uTimeLoc = gl.getUniformLocation(this.program, "uTime");
      gl.uniform1i(uTexLoc, 0);
      gl.uniform1f(uStrLoc, this.strength);
      gl.uniform1f(uTimeLoc, time * 1e-3);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      if (this.perf) {
        const dur = performance.now() - this.frameStart;
        if (dur > 0.5) {
          console.warn(
            `[AberrationCanvas] Frame ${dur.toFixed(2)} ms exceeds 0.5 ms budget`
          );
        }
      }
    }
    destroy() {
      if (this.rafId) cancelAnimationFrame(this.rafId);
      if (this.gl) {
        const lose = this.gl.getExtension("WEBGL_lose_context");
        lose?.loseContext();
      }
      this.canvas.removeEventListener("webglcontextlost", this._boundContextLost);
      this.canvas.removeEventListener(
        "webglcontextrestored",
        this._boundContextRestored
      );
      this.canvas.remove();
    }
    /**
     * Dynamically adjusts the off-screen buffer resolution. Caller should use
     * powers of two (64–256) to keep GPU happy. Safe to call every time
     * performance mode toggles – texture & buffers are reused.
     */
    setPixelSize(size) {
      if (size === this.canvas.width) return;
      this.canvas.width = size;
      this.canvas.height = size;
    }
    // ────────────────────────────────────────────────────────────────
    // Context-loss life-cycle helpers (Phase-5)
    // ────────────────────────────────────────────────────────────────
    _handleContextLost(e) {
      e.preventDefault();
      console.warn("[AberrationCanvas] WebGL context lost \u2013 waiting for restore");
      this.gl = null;
      this.program = null;
    }
    _handleContextRestored() {
      console.info(
        "[AberrationCanvas] WebGL context restored \u2013 re-initializing GL"
      );
      this._initGL();
    }
  };
  __name(_AberrationCanvas, "AberrationCanvas");
  var AberrationCanvas = _AberrationCanvas;

  // src-js/visual/ui/Aberration/AberrationVisualSystem.ts
  var _AberrationVisualSystem = class _AberrationVisualSystem {
    constructor(canvas, perf) {
      this.systemName = "AberrationCanvas";
      this._elapsed = 0;
      this._canvas = canvas;
      this._perf = perf;
    }
    /* --------------------------------------------------------------- */
    /* MasterAnimationCoordinator hooks                                */
    /* --------------------------------------------------------------- */
    /**
     * Called by the coordinator every frame (subject to frame budgeting).
     * @param deltaMs Time in milliseconds since last call.
     * @param _context Shared FrameContext from VisualSystemRegistry (unused for now).
     */
    onAnimate(deltaMs, _context) {
      this._elapsed += deltaMs;
      let start = 0;
      if (this._perf) start = this._perf.startTiming("AberrationVisualSystem");
      this._canvas.render(this._elapsed);
      if (this._perf && start) {
        this._perf.endTiming("AberrationVisualSystem", start);
      }
    }
    /**
     * Optional hook – will be invoked when MAC toggles performance modes.
     * We keep it for future Phase-2 improvements (dynamic resolution scaling).
     */
    onPerformanceModeChange(mode) {
      if (mode === "performance") {
        this._canvas.setPixelSize(128);
        this._canvas.setStrength(0.25);
      } else {
        this._canvas.setPixelSize(256);
        this._canvas.setStrength(0.4);
      }
    }
    /* --------------------------------------------------------------- */
    /* Lifecycle helpers                                               */
    /* --------------------------------------------------------------- */
    destroy() {
      this._canvas.destroy();
    }
  };
  __name(_AberrationVisualSystem, "AberrationVisualSystem");
  var AberrationVisualSystem = _AberrationVisualSystem;

  // src-js/utils/dom/getScrollNode.ts
  var SCROLL_NODE_SELECTORS = [
    ".main-view-container__scroll-node",
    // 2023-era builds
    ".main-viewContainer-scrollNode",
    // 2024 dash variant
    ".main-viewContainer__scrollNode"
    // 2024 double-underscore variant
  ].join(", ");
  function getScrollNode() {
    return document.querySelector(SCROLL_NODE_SELECTORS);
  }
  __name(getScrollNode, "getScrollNode");

  // src-js/visual/ui/Aberration/AberrationManager.ts
  var instance = null;
  var visualSystem = null;
  function getCSSController(y3k) {
    const year3000System = y3k || globalThis.year3000System;
    return year3000System?.cssController || getGlobalOptimizedCSSController();
  }
  __name(getCSSController, "getCSSController");
  function isAberrationEnabled() {
    return false;
  }
  __name(isAberrationEnabled, "isAberrationEnabled");
  function attach(y3k) {
    if (!isAberrationEnabled()) {
      setNebulaNoiseEnabled(false, y3k);
      setCSSAberrationEnabled(false, y3k);
      return;
    }
    const node = getScrollNode();
    if (!node) return;
    if (instance && instance.parent === node) return;
    instance?.destroy();
    instance = new AberrationCanvas(node, y3k);
    if (window.__SN_DEBUG_ABERRATION) {
      console.log("[AberrationManager] canvas attached", node);
    }
    setNebulaNoiseEnabled(true, y3k);
    setCSSAberrationEnabled(true, y3k);
    if (y3k && instance) {
      visualSystem = new AberrationVisualSystem(
        instance,
        y3k.performanceAnalyzer || void 0
      );
      y3k?.registerVisualSystem?.(visualSystem, "critical");
      console.log("[AberrationManager] AberrationCanvas attached");
    }
  }
  __name(attach, "attach");
  function setNebulaNoiseEnabled(enabled, y3k) {
    const cssController = getCSSController(y3k);
    cssController.setVariable(
      "AberrationManager",
      "--sn-nebula-noise-opacity",
      enabled ? "0.03" : "0",
      "normal",
      // Normal priority for nebula noise overlay
      "nebula-noise-toggle"
    );
  }
  __name(setNebulaNoiseEnabled, "setNebulaNoiseEnabled");
  function setCSSAberrationEnabled(enabled, y3k) {
    const variables = {
      "--aberration-webgl-active": enabled ? "1" : "0",
      "--aberration-css-enabled": enabled ? "1" : "0",
      "--aberration-hybrid-mode": enabled ? "1" : "0"
    };
    const cssController = getCSSController(y3k);
    cssController.batchSetVariables(
      "AberrationManager",
      variables,
      "normal",
      // Normal priority for CSS aberration effects
      "css-aberration-toggle"
    );
  }
  __name(setCSSAberrationEnabled, "setCSSAberrationEnabled");
  function initializeAberrationManager(y3k = null) {
    attach(y3k);
    if (!instance) {
      setNebulaNoiseEnabled(false, y3k);
      setCSSAberrationEnabled(false, y3k);
    }
    const history = window.Spicetify?.Platform?.History;
    if (history?.listen) {
      history.listen(() => setTimeout(() => attach(y3k), 0));
    }
    document.addEventListener("spicetify:appchange", () => attach(y3k));
    const observer = new MutationObserver(() => {
      if (!instance) {
        attach(y3k);
        if (!instance) {
          setNebulaNoiseEnabled(false, y3k);
          setCSSAberrationEnabled(false, y3k);
        }
      } else {
        observer.disconnect();
      }
    });
    observer.observe(document.documentElement, {
      childList: true,
      subtree: true
    });
    document.addEventListener("year3000SystemSettingsChanged", (e) => {
      const { key, value } = e.detail || {};
      if (key === "sn-enable-aberration") {
        const enable = value === "true";
        if (enable && !instance) {
          attach(y3k);
        } else if (!enable && instance) {
          instance.destroy();
          instance = null;
          y3k?.unregisterAnimationSystem("AberrationCanvas");
          visualSystem?.destroy();
          visualSystem = null;
          console.log("[AberrationManager] AberrationCanvas detached");
        }
        setNebulaNoiseEnabled(enable && !!instance, y3k);
        setCSSAberrationEnabled(enable && !!instance, y3k);
      }
      if (key === "sn-nebula-aberration-strength") {
        const num = parseFloat(value);
        if (!Number.isNaN(num) && instance) {
          instance.setStrength(num);
        }
        const cssController = getCSSController(y3k);
        cssController.setVariable(
          "AberrationManager",
          "--sn-nebula-aberration-strength",
          String(value),
          "normal",
          // Normal priority for strength settings
          "aberration-strength-update"
        );
      }
    });
  }
  __name(initializeAberrationManager, "initializeAberrationManager");

  // src-js/visual/ui/AudioVisualController.ts
  init_OptimizedCSSVariableManager();
  init_UnifiedEventBus();

  // src-js/utils/platform/UserHistory.ts
  var LS_KEY = "sn_seen_genres_v1";
  var _UserGenreHistory = class _UserGenreHistory {
    constructor() {
      const raw = typeof localStorage !== "undefined" ? localStorage.getItem(LS_KEY) : null;
      this.seen = new Set(raw ? JSON.parse(raw) : []);
    }
    hasSeen(genre) {
      return this.seen.has(genre.toLowerCase());
    }
    markSeen(genre) {
      const key = genre.toLowerCase();
      if (!this.seen.has(key)) {
        this.seen.add(key);
        this._persist();
      }
    }
    _persist() {
      try {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(LS_KEY, JSON.stringify([...this.seen]));
        }
      } catch (_e) {
      }
    }
  };
  __name(_UserGenreHistory, "UserGenreHistory");
  var UserGenreHistory = _UserGenreHistory;

  // src-js/visual/ui/AudioVisualController.ts
  function median(values) {
    if (!values.length) return 0;
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 !== 0) {
      return sorted[mid] ?? 0;
    }
    const lower = sorted[mid - 1] ?? 0;
    const upper = sorted[mid] ?? 0;
    return (lower + upper) / 2;
  }
  __name(median, "median");
  var _AudioVisualController = class _AudioVisualController {
    constructor(y3k = null, cssController, perf) {
      // Core systems
      this.perf = null;
      // Event management
      this.unsubscribers = [];
      // Performance tracking
      this.frameDurations = [];
      // rolling window for medians
      // Configuration
      this.enabled = true;
      this.intensitySetting = "balanced";
      this.intensityFactor = 1;
      // State management
      this.genreHistory = new UserGenreHistory();
      this.activeGlowTimeout = null;
      this.interactionOffHandler = null;
      this.year3000System = y3k;
      this.cssController = cssController ?? y3k?.cssVariableController ?? getGlobalOptimizedCSSController();
      this.perf = perf ? perf : y3k?.performanceAnalyzer ?? null;
      const prefersReducedMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;
      const capabilityOverall = y3k?.deviceCapabilityDetector?.deviceCapabilities?.overall;
      const settings2 = y3k?.settingsManager;
      if (settings2) {
        this.intensitySetting = settings2.get("sn-gradient-intensity") ?? "balanced";
      }
      switch (this.intensitySetting) {
        case "disabled":
          this.enabled = false;
          break;
        case "minimal":
          this.intensityFactor = 0.6;
          break;
        case "balanced":
          this.intensityFactor = 1;
          break;
        case "intense":
          this.intensityFactor = 1.4;
          break;
      }
      if (prefersReducedMotion || capabilityOverall === "low") {
        this.enabled = false;
      }
      if (this.enabled) {
        this._subscribe();
      } else {
        this.cssController.setVariable(
          "AudioVisualController",
          "--sn-nebula-beat-intensity",
          "0",
          "low",
          "disabled-initialization"
        );
      }
    }
    _subscribe() {
      const subscriptionIds = [
        unifiedEventBus.subscribe("music:beat", (data) => {
          this._handleBeat({
            energy: data.intensity,
            bpm: data.bpm
          });
        }, "AudioVisualController"),
        unifiedEventBus.subscribe("music:track-changed", (data) => {
          this._handleGenreChange({
            genre: "unknown"
            // Could be enhanced with actual genre detection
          });
        }, "AudioVisualController"),
        unifiedEventBus.subscribe("user:scroll", (data) => {
          this._handleScroll({
            velocity: data.velocity?.x || data.velocity?.y || 0,
            direction: data.direction === "up" ? "up" : "down"
          });
        }, "AudioVisualController")
      ];
      this.unsubscribers = subscriptionIds.map((id) => () => unifiedEventBus.unsubscribe(id));
    }
    // ---------------------------------------------------------------------------
    // Event Handlers – all lightweight calculations to stay under 2 ms median.
    // ---------------------------------------------------------------------------
    _handleBeat(payload) {
      const t0 = performance.now();
      const safeEnergy = typeof payload.energy === "number" ? payload.energy : 0.5;
      const intensity = (0.8 + Math.min(Math.max(safeEnergy, 0), 1) * 0.6) * this.intensityFactor;
      this._queueVar(
        "--sn-nebula-beat-intensity",
        intensity.toFixed(3),
        "high",
        "beat-sync"
      );
      const aberrationStrength = (safeEnergy * 0.6).toFixed(3);
      this._queueVar(
        "--sn-nebula-aberration-strength",
        aberrationStrength,
        "normal",
        "beat-aberration"
      );
      this._recordDuration(t0);
    }
    _handleGenreChange(payload) {
      const t0 = performance.now();
      if (this.genreHistory.hasSeen(payload.genre)) {
        return;
      }
      this.genreHistory.markSeen(payload.genre);
      const cueOpacity = 0.18 * this.intensityFactor;
      this._queueVar(
        "--sn-nebula-layer-0-opacity",
        cueOpacity.toFixed(3),
        "high",
        "genre-discovery"
      );
      const clearCue = /* @__PURE__ */ __name(() => {
        if (this.year3000System?.timerConsolidationSystem) {
          this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer(
            "AudioVisualController-glowTimeout"
          );
        } else if (this.activeGlowTimeout) {
          clearTimeout(this.activeGlowTimeout);
          this.activeGlowTimeout = null;
        }
        this._queueVar(
          "--sn-nebula-layer-0-opacity",
          "0.05",
          "normal",
          "genre-clear"
        );
        if (this.interactionOffHandler) {
          document.removeEventListener("pointerdown", this.interactionOffHandler);
          document.removeEventListener("keydown", this.interactionOffHandler);
          this.interactionOffHandler = null;
        }
      }, "clearCue");
      if (this.year3000System?.timerConsolidationSystem) {
        this.year3000System.timerConsolidationSystem.registerConsolidatedTimer(
          "AudioVisualController-glowTimeout",
          clearCue,
          4e3,
          "normal"
        );
        this.activeGlowTimeout = null;
      } else {
        this.activeGlowTimeout = setTimeout(clearCue, 4e3);
      }
      this.interactionOffHandler = () => clearCue();
      document.addEventListener("pointerdown", this.interactionOffHandler, {
        once: true
      });
      document.addEventListener("keydown", this.interactionOffHandler, {
        once: true
      });
      this._queueVar(
        "--sn-nebula-ease-t",
        "1",
        "normal",
        "ease-trigger"
      );
      this._recordDuration(t0);
    }
    _handleScroll(payload) {
      const t0 = performance.now();
      const safeVel = typeof payload.velocity === "number" ? payload.velocity : 0;
      const vel = Math.min(Math.abs(safeVel), 50);
      const blurBoost = vel / 50 * 2 * this.intensityFactor;
      this._queueVar(
        "--sn-nebula-layer-3-blur",
        `calc(var(--sn-depth-layer-3-blur) + ${blurBoost.toFixed(2)}px)`,
        "normal",
        "scroll-blur"
      );
      const baseScaleY = 150;
      let clampedVel = Math.max(Math.min(payload.velocity ?? 0, 50), -50);
      const deltaScale = clampedVel / 50 * 50;
      const noiseScale = Math.max(140, Math.min(200, baseScaleY + deltaScale));
      this._queueVar(
        "--sn-nebula-noise-scale-y",
        `${noiseScale.toFixed(1)}%`,
        "normal",
        "scroll-noise"
      );
      this._recordDuration(t0);
    }
    // ---------------------------------------------------------------------------
    // Helpers
    // ---------------------------------------------------------------------------
    _queueVar(prop, value, priority = "normal", source = "audio-visual") {
      if (!this.enabled) return;
      this.cssController.setVariable(
        "AudioVisualController",
        prop,
        value,
        priority,
        source
      );
    }
    _recordDuration(start) {
      const duration = performance.now() - start;
      this.frameDurations.push(duration);
      if (this.frameDurations.length > _AudioVisualController.FRAME_HISTORY) {
        this.frameDurations.shift();
      }
      if (this.frameDurations.length === _AudioVisualController.FRAME_HISTORY) {
        const med = median(this.frameDurations);
        if (med > 2) {
          console.warn(
            `[AudioVisualController] Median scripting cost ${med.toFixed(
              2
            )} ms exceeds 2 ms budget.`
          );
          this._queueVar(
            "--sn-nebula-blend-mode",
            "screen",
            "critical",
            "performance-fallback"
          );
        }
      }
    }
    destroy() {
      if (this.year3000System?.timerConsolidationSystem) {
        this.year3000System.timerConsolidationSystem.unregisterConsolidatedTimer(
          "AudioVisualController-glowTimeout"
        );
      }
      if (this.activeGlowTimeout) {
        clearTimeout(this.activeGlowTimeout);
        this.activeGlowTimeout = null;
      }
      if (this.interactionOffHandler) {
        document.removeEventListener("pointerdown", this.interactionOffHandler);
        document.removeEventListener("keydown", this.interactionOffHandler);
        this.interactionOffHandler = null;
      }
      this.unsubscribers.forEach((u) => u());
      this.unsubscribers = [];
    }
  };
  __name(_AudioVisualController, "AudioVisualController");
  _AudioVisualController.FRAME_HISTORY = 120;
  var AudioVisualController = _AudioVisualController;
  function initializeAudioVisualController(y3k = null) {
    const g = globalThis;
    if (g.__SN_audioVisualController)
      return g.__SN_audioVisualController;
    const instance2 = new AudioVisualController(y3k);
    g.__SN_audioVisualController = instance2;
    return instance2;
  }
  __name(initializeAudioVisualController, "initializeAudioVisualController");

  // src-js/utils/dom/CardDOMWatcher.ts
  var CARD_SELECTORS = [
    ".main-card-card",
    ".main-card-cardContainer",
    '.Card[class*="card"]'
    // Catch-all for future variants
  ];
  function startCardDOMWatcher(options = {}) {
    const {
      enableDebug = false,
      unifiedClass = "sn-card",
      onCardDiscovered
    } = options;
    normalizeExistingCards(unifiedClass, enableDebug, onCardDiscovered);
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node instanceof Element) {
            normalizeCard(node, unifiedClass, enableDebug, onCardDiscovered);
          }
        });
      });
    });
    const mainContent = document.querySelector(".main-view-container") || document.body;
    observer.observe(mainContent, {
      childList: true,
      subtree: true
    });
    if (enableDebug) {
      console.log("[CardDOMWatcher] Started watching for card elements");
    }
    return () => {
      observer.disconnect();
      if (enableDebug) {
        console.log("[CardDOMWatcher] Stopped watching");
      }
    };
  }
  __name(startCardDOMWatcher, "startCardDOMWatcher");
  function normalizeExistingCards(unifiedClass, enableDebug, onCardDiscovered) {
    let normalizedCount = 0;
    CARD_SELECTORS.forEach((selector) => {
      document.querySelectorAll(selector).forEach((card) => {
        if (!card.classList.contains(unifiedClass)) {
          card.classList.add(unifiedClass);
          normalizedCount++;
          onCardDiscovered?.(card);
        }
      });
    });
    if (enableDebug && normalizedCount > 0) {
      console.log(`[CardDOMWatcher] Normalized ${normalizedCount} existing cards`);
    }
  }
  __name(normalizeExistingCards, "normalizeExistingCards");
  function normalizeCard(element, unifiedClass, enableDebug, onCardDiscovered) {
    const isCard = CARD_SELECTORS.some((selector) => element.matches(selector));
    if (isCard && !element.classList.contains(unifiedClass)) {
      element.classList.add(unifiedClass);
      onCardDiscovered?.(element);
      if (enableDebug) {
        console.log("[CardDOMWatcher] Normalized new card:", element.className);
      }
    }
    CARD_SELECTORS.forEach((selector) => {
      element.querySelectorAll(selector).forEach((card) => {
        if (!card.classList.contains(unifiedClass)) {
          card.classList.add(unifiedClass);
          onCardDiscovered?.(card);
          if (enableDebug) {
            console.log("[CardDOMWatcher] Normalized child card:", card.className);
          }
        }
      });
    });
  }
  __name(normalizeCard, "normalizeCard");

  // src-js/theme.entry.ts
  async function waitForAPI(apiPath, timeout = 5e3) {
    const start = Date.now();
    let lastError = null;
    let attemptCount = 0;
    while (Date.now() - start < timeout) {
      attemptCount++;
      try {
        const api = apiPath.split(".").reduce((obj, prop) => obj?.[prop], window);
        if (api) {
          console.log(
            `\u2705 [StarryNight] API ${apiPath} available after ${attemptCount} attempts (${Date.now() - start}ms)`
          );
          return api;
        }
      } catch (e) {
        lastError = e;
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    console.warn(
      `\u274C [StarryNight] API ${apiPath} timeout after ${timeout}ms (${attemptCount} attempts)`
    );
    if (lastError) {
      console.warn(
        `\u274C [StarryNight] Last error for ${apiPath}:`,
        lastError.message
      );
    }
    const pathParts = apiPath.split(".");
    let currentObj = window;
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      if (!part || !currentObj || typeof currentObj !== "object" || currentObj[part] === void 0) {
        console.warn(
          `\u274C [StarryNight] API path ${apiPath} breaks at '${part}' (step ${i + 1}/${pathParts.length})`
        );
        break;
      }
      currentObj = currentObj[part];
    }
    return null;
  }
  __name(waitForAPI, "waitForAPI");
  async function waitForDOMElement(selector, timeout = 5e3) {
    const start = Date.now();
    let attemptCount = 0;
    while (Date.now() - start < timeout) {
      attemptCount++;
      try {
        const element = document.querySelector(selector);
        if (element) {
          console.log(
            `\u2705 [StarryNight] DOM element '${selector}' found after ${attemptCount} attempts (${Date.now() - start}ms)`
          );
          return element;
        }
      } catch (e) {
        console.warn(`\u274C [StarryNight] DOM query error for '${selector}':`, e);
      }
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
    console.warn(
      `\u274C [StarryNight] DOM element '${selector}' not found after ${timeout}ms (${attemptCount} attempts)`
    );
    return null;
  }
  __name(waitForDOMElement, "waitForDOMElement");
  async function waitForCatppuccinTheme(timeout = 5e3) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      try {
        const rootStyle = getComputedStyle(document.documentElement);
        const baseColor = rootStyle.getPropertyValue("--spice-base").trim();
        const accentColor = rootStyle.getPropertyValue("--spice-accent").trim();
        const textColor = rootStyle.getPropertyValue("--spice-text").trim();
        const isValidColor = /* @__PURE__ */ __name((color3) => {
          const normalized = color3.toLowerCase();
          return color3 && !normalized.includes("#ffffff") && !normalized.includes("#fff") && !normalized.includes("white") && normalized.match(/^#[0-9a-f]{6}$/i);
        }, "isValidColor");
        if (isValidColor(baseColor) && isValidColor(accentColor) && isValidColor(textColor)) {
          console.log(
            `\u{1F3A8} [StarryNight] Catppuccin theme loaded: base=${baseColor}, accent=${accentColor}, text=${textColor}`
          );
          return true;
        }
        console.log(
          `\u{1F3A8} [StarryNight] Waiting for Catppuccin theme... (base=${baseColor}, accent=${accentColor})`
        );
      } catch (e) {
      }
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
    console.warn(
      `\u{1F3A8} [StarryNight] Catppuccin theme not fully loaded after ${timeout}ms - proceeding with fallbacks`
    );
    return false;
  }
  __name(waitForCatppuccinTheme, "waitForCatppuccinTheme");
  function patchReactRequire() {
    const g = globalThis;
    if (g.__STARLIGHT_REACT_SHIM__) return;
    const shim = /* @__PURE__ */ __name((name) => {
      if (name === "react") return g.Spicetify?.React;
      if (name === "react-dom") return g.Spicetify?.ReactDOM;
      throw new Error(`[StarryNight shim] Module '${name}' not available`);
    }, "shim");
    if (typeof g.require === "function") {
      const original = g.require.bind(g);
      g.require = (name) => {
        if (name === "react" || name === "react-dom") return shim(name);
        return original(name);
      };
    } else {
      g.require = shim;
    }
    g.__STARLIGHT_REACT_SHIM__ = true;
  }
  __name(patchReactRequire, "patchReactRequire");
  patchReactRequire();
  (/* @__PURE__ */ __name(async function catppuccinStarryNight() {
    const startTime = Date.now();
    console.log("\u{1F31F} [Catppuccin StarryNight] Theme entry point starting...");
    const spicetifyReady = await waitForSpicetifyReady(1e4);
    if (!spicetifyReady) {
      console.error(
        "\u274C [StarryNight] CRITICAL: Spicetify not fully ready after 10s \u2013 proceeding with degraded visual-only mode."
      );
      console.error("\u274C [StarryNight] Available Spicetify objects:", {
        Spicetify: !!window.Spicetify,
        showNotification: !!window.Spicetify?.showNotification,
        Platform: !!window.Spicetify?.Platform
      });
    } else {
      console.log("\u2705 [StarryNight] Spicetify platform fully ready");
    }
    const themeReady = await waitForCatppuccinTheme(8e3);
    if (!themeReady) {
      console.error(
        "\u274C [StarryNight] CRITICAL: Catppuccin theme not fully loaded after 8s \u2013 may experience color issues"
      );
      const rootStyle = getComputedStyle(document.documentElement);
      console.error("\u274C [StarryNight] Current CSS variables:", {
        base: rootStyle.getPropertyValue("--spice-base").trim(),
        accent: rootStyle.getPropertyValue("--spice-accent").trim(),
        text: rootStyle.getPropertyValue("--spice-text").trim()
      });
    } else {
      console.log("\u2705 [StarryNight] Catppuccin theme fully loaded");
    }
    const requiredAPIs = {
      player: await waitForAPI("Spicetify.Player", 3e3),
      platform: await waitForAPI("Spicetify.Platform", 3e3),
      menu: await waitForAPI("Spicetify.Menu", 2e3),
      react: await waitForAPI("Spicetify.React", 2e3),
      reactDOM: await waitForAPI("Spicetify.ReactDOM", 2e3)
    };
    const mainContainerSelectors = [
      ".main-viewContainer-scrollNode",
      ".main-view-container__scroll-node-child",
      ".main-view-container",
      ".main-container",
      "#main",
      "[data-testid='main-container']"
    ];
    let mainContainer = null;
    for (const selector of mainContainerSelectors) {
      mainContainer = await waitForDOMElement(selector, 1e3);
      if (mainContainer) {
        console.log(
          `\u2705 [StarryNight] Found main container using selector: ${selector}`
        );
        break;
      }
    }
    if (mainContainer) {
      console.log(
        "\u2705 [StarryNight] Enhanced UI features initialized with DOM container"
      );
    } else {
      console.warn(
        "\u26A0\uFE0F [StarryNight] No suitable main container found - enhanced UI features disabled"
      );
      console.warn(
        "\u26A0\uFE0F [StarryNight] Tried selectors:",
        mainContainerSelectors.join(", ")
      );
      console.warn(
        "\u26A0\uFE0F [StarryNight] Core functionality (music sync, color extraction) will still work"
      );
    }
    const hasRequiredAPIs = requiredAPIs.player && requiredAPIs.platform;
    const degradedMode = !hasRequiredAPIs;
    if (degradedMode) {
      console.error(
        "\u274C [StarryNight] DEGRADED MODE: Initializing with limited functionality due to missing APIs"
      );
      console.error("\u274C [StarryNight] API availability status:", {
        player: !!requiredAPIs.player,
        platform: !!requiredAPIs.platform,
        menu: !!requiredAPIs.menu,
        react: !!requiredAPIs.react,
        reactDOM: !!requiredAPIs.reactDOM,
        mainContainer: !!mainContainer + " (optional)"
      });
      console.error("\u274C [StarryNight] DEGRADED MODE limitations:");
      console.error("  - Music synchronization disabled");
      console.error("  - Advanced visual effects may not function");
      console.error("  - UI integration features disabled");
      console.error("  - Color extraction from album art disabled");
    } else {
      console.log(
        "\u2705 [StarryNight] FULL MODE: All required APIs available - initializing complete functionality"
      );
    }
    const ENABLE_GLOBAL_DEBUGGING = true;
    if (ENABLE_GLOBAL_DEBUGGING) {
      ADVANCED_SYSTEM_CONFIG.enableDebug = true;
      Promise.resolve().then(() => (init_DragCartographer(), DragCartographer_exports)).then((m) => {
        m.enableDragCartography?.();
        window.getDragMap = m.getDragMap;
      });
    }
    const year3000System = new AdvancedThemeSystem(ADVANCED_SYSTEM_CONFIG);
    try {
      if (degradedMode) {
        await year3000System.initializeWithAvailableAPIs({
          player: requiredAPIs.player,
          platform: requiredAPIs.platform,
          config: window.Spicetify?.Config,
          degradedMode: true
        });
        console.log(
          "\u{1F31F} [StarryNight] Initialized in degraded mode - visual systems only"
        );
        setupProgressiveEnhancement(year3000System, requiredAPIs);
      } else {
        await year3000System.initializeAllSystems();
        year3000System.setupMusicAnalysisAndColorExtraction();
        console.log("\u{1F31F} [StarryNight] Full initialization complete");
        document.body.setAttribute("data-layout", "navigation");
        console.log("\u{1F30C} [StarryNight] Stellar Navigation Mode activated - grid breathing enabled");
        const disposeCardWatcher = startCardDOMWatcher({
          enableDebug: ADVANCED_SYSTEM_CONFIG.enableDebug,
          onCardDiscovered: /* @__PURE__ */ __name((card) => {
            if (ADVANCED_SYSTEM_CONFIG.enableDebug) {
              console.log("[CardDOMWatcher] New card discovered and normalized:", card.className);
            }
          }, "onCardDiscovered")
        });
        year3000System.disposeCardWatcher = disposeCardWatcher;
        console.log("\u{1F0CF} [StarryNight] CardDOMWatcher active - normalizing Spotify card variants");
        try {
          initializeAudioVisualController(year3000System);
          initializeAberrationManager(year3000System);
          Promise.resolve().then(() => (init_DragPreviewManager(), DragPreviewManager_exports)).then(
            (m) => m.enableEnhancedDragPreview?.()
          );
          Promise.resolve().then(() => (init_PlaylistQuickAddMenu(), PlaylistQuickAddMenu_exports)).then(
            (m) => m.enableQuickAddRadialMenu?.()
          );
          if (mainContainer) {
            Promise.resolve().then(() => (init_prismaticScrollSheen(), prismaticScrollSheen_exports)).then(
              (m) => m.initializePrismaticScrollSheen?.()
            );
          }
          console.log("\u{1F31F} [StarryNight] UI controllers initialized successfully");
        } catch (uiError) {
          console.error("[StarryNight] UI controller initialization failed:", uiError);
        }
      }
    } catch (error) {
      console.error("[StarryNight] System initialization failed:", error);
    }
    try {
      if (requiredAPIs.react && requiredAPIs.reactDOM) {
        const settingsUiModule = await Promise.resolve().then(() => (init_StarryNightSettings(), StarryNightSettings_exports));
        await settingsUiModule.initializeStarryNightSettings?.();
        console.log(
          "\u{1F31F} [StarryNight] Spicetify native settings with Year3000System integration initialized"
        );
      } else {
        console.warn(
          "\u{1F31F} [StarryNight] React APIs not available - continuing with CSS-only theme"
        );
      }
    } catch (e) {
      console.error("[StarryNight] Failed to initialize native settings:", e);
      console.warn(
        "\u{1F31F} [StarryNight] Continuing with CSS-only theme (no settings UI)"
      );
    }
    if (ADVANCED_SYSTEM_CONFIG.enableDebug) {
      window.Y3K = {
        system: year3000System,
        // Expose internal modules for easier debugging
        music: year3000System.musicSyncService,
        settings: year3000System.settingsManager,
        // Expose the superior, specialized debug tools directly
        debug: Y3KDebug.debug,
        health: year3000System.systemHealthMonitor,
        // Add degraded mode info
        mode: degradedMode ? "degraded" : "full",
        availableAPIs: requiredAPIs
      };
    }
    try {
      const { SidebarVisualEffectsSystem: SidebarVisualEffectsSystem2 } = await Promise.resolve().then(() => (init_SidebarVisualEffectsSystem(), SidebarVisualEffectsSystem_exports));
      const { SidebarPerformanceCoordinator: SidebarPerformanceCoordinator2 } = await Promise.resolve().then(() => (init_SidebarPerformanceCoordinator(), SidebarPerformanceCoordinator_exports));
      if (year3000System.performanceAnalyzer) {
        const coordinator = SidebarPerformanceCoordinator2.getInstance({
          enableDebug: ADVANCED_SYSTEM_CONFIG.enableDebug,
          performanceAnalyzer: year3000System.performanceAnalyzer,
          onFlushComplete: /* @__PURE__ */ __name(() => {
            year3000System.performanceAnalyzer?.emitTrace?.(
              "[SidebarPerformanceCoordinator] Flush completed"
            );
          }, "onFlushComplete")
        });
        const sidebarSystem = new SidebarVisualEffectsSystem2(
          ADVANCED_SYSTEM_CONFIG,
          ThemeUtilities_exports,
          year3000System.performanceAnalyzer,
          year3000System.musicSyncService,
          year3000System.settingsManager,
          year3000System
        );
        await sidebarSystem.initialize();
        year3000System.sidebarVisualEffectsSystem = sidebarSystem;
        year3000System.sidebarCoordinator = coordinator;
      }
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize Consolidated Sidebar System",
        err
      );
    }
    try {
      const { DepthVisualEffectsController: DepthVisualEffectsController2 } = await Promise.resolve().then(() => (init_DepthLayerController(), DepthLayerController_exports));
      const depthController = new DepthVisualEffectsController2(
        ADVANCED_SYSTEM_CONFIG,
        ThemeUtilities_exports,
        year3000System.performanceAnalyzer,
        year3000System.musicSyncService,
        year3000System.settingsManager
      );
      await depthController.initialize();
      year3000System.depthController = depthController;
      year3000System.depthConsciousnessController = depthController;
      console.log("\u{1F30A} [StarryNight] Depth Visual Effects Controller initialized");
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize DepthVisualEffectsController",
        err
      );
    }
    try {
      const { AtmosphericCrystalsSystem: AtmosphericCrystalsSystem2 } = await Promise.resolve().then(() => (init_AtmosphericCrystalsSystem(), AtmosphericCrystalsSystem_exports));
      const atmosphericCrystals = new AtmosphericCrystalsSystem2();
      await atmosphericCrystals.initialize();
      year3000System.atmosphericCrystals = atmosphericCrystals;
      console.log("\u{1F48E} [StarryNight] Atmospheric Crystals System activated - Year3000 depth rendering");
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize AtmosphericCrystalsSystem",
        err
      );
    }
    try {
      const { DynamicCatppuccinBridge: DynamicCatppuccinBridge2 } = await Promise.resolve().then(() => (init_DynamicCatppuccinBridge(), DynamicCatppuccinBridge_exports));
      const dynamicBridge = new DynamicCatppuccinBridge2(
        ADVANCED_SYSTEM_CONFIG,
        ThemeUtilities_exports,
        year3000System.performanceAnalyzer,
        year3000System.musicSyncService,
        year3000System.settingsManager
      );
      await dynamicBridge.initialize();
      if (year3000System.colorHarmonyEngine) {
        dynamicBridge.linkWithColorHarmonyEngine(
          year3000System.colorHarmonyEngine
        );
      }
      if (year3000System.depthController) {
        dynamicBridge.linkWithDepthVisual(
          year3000System.depthController
        );
      }
      year3000System.dynamicCatppuccinBridge = dynamicBridge;
      console.log("\u{1F3A8} [StarryNight] Dynamic Catppuccin Bridge connected");
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize DynamicCatppuccinBridge",
        err
      );
    }
    try {
      const { DynamicGradientStrategy: DynamicGradientStrategy2 } = await Promise.resolve().then(() => (init_DynamicGradientStrategy(), DynamicGradientStrategy_exports));
      const dynamicGradientSystem = new DynamicGradientStrategy2(
        ADVANCED_SYSTEM_CONFIG,
        ThemeUtilities_exports,
        year3000System.performanceAnalyzer,
        year3000System.musicSyncService,
        year3000System.settingsManager
      );
      await dynamicGradientSystem.initialize();
      if (year3000System.dynamicCatppuccinBridge) {
        console.log(
          "\u{1F30A} [StarryNight] Consolidated Dynamic Gradient System linked with Dynamic Catppuccin Bridge"
        );
      }
      if (year3000System.depthController) {
        console.log(
          "\u{1F30A} [StarryNight] Consolidated Dynamic Gradient System linked with Depth Controller"
        );
      }
      year3000System.dynamicGradientSystem = dynamicGradientSystem;
      year3000System.livingGradientStrategy = dynamicGradientSystem;
      console.log(
        "\u{1F30A} [StarryNight] Consolidated Dynamic Gradient Strategy System awakened - unified color processing and visual system lifecycle with performance optimizations"
      );
    } catch (err) {
      console.error(
        "[StarryNight] Failed to initialize Consolidated Dynamic Gradient Strategy System",
        err
      );
    }
    try {
      const { CDFVariableBridge: CDFVariableBridge2 } = await Promise.resolve().then(() => (init_CDFVariableBridge(), CDFVariableBridge_exports));
      if (year3000System.cssVariableController) {
        new CDFVariableBridge2(year3000System.cssVariableController);
      }
    } catch (err) {
      console.error("[StarryNight] Failed to initialize CDFVariableBridge", err);
    }
    const initTime = Date.now() - startTime;
    console.log(
      `\u{1F30C} Catppuccin StarryNight Theme initialized in ${initTime}ms (${degradedMode ? "degraded" : "full"} mode). Welcome to the future of sound!`
    );
  }, "catppuccinStarryNight"))();
  function setupProgressiveEnhancement(year3000System, requiredAPIs) {
    console.log(
      "\u{1F504} [StarryNight] Setting up progressive enhancement monitoring..."
    );
    let upgradeAttempts = 0;
    const maxUpgradeAttempts = 30;
    const upgradeCheckInterval = 1e4;
    const checkForUpgrade = /* @__PURE__ */ __name(() => {
      upgradeAttempts++;
      const currentAPIs = {
        player: window.Spicetify?.Player,
        platform: window.Spicetify?.Platform,
        menu: window.Spicetify?.Menu,
        react: window.Spicetify?.React,
        reactDOM: window.Spicetify?.ReactDOM
      };
      const hasRequiredAPIs = currentAPIs.player && currentAPIs.platform;
      if (hasRequiredAPIs) {
        console.log(
          "\u2705 [StarryNight] Required APIs now available - upgrading to full mode!"
        );
        clearInterval(upgradeInterval);
        upgradeToFullMode(year3000System, currentAPIs).then(() => {
          console.log(
            "\u{1F31F} [StarryNight] Successfully upgraded from degraded mode to full mode!"
          );
          if (window.Y3K) {
            window.Y3K.mode = "full";
            window.Y3K.availableAPIs = currentAPIs;
          }
        }).catch((error) => {
          console.error(
            "\u274C [StarryNight] Failed to upgrade to full mode:",
            error
          );
        });
        return;
      }
      if (upgradeAttempts >= maxUpgradeAttempts) {
        console.log(
          `\u23F0 [StarryNight] Progressive enhancement monitoring ended after ${upgradeAttempts} attempts (${upgradeAttempts * upgradeCheckInterval / 1e3}s)`
        );
        clearInterval(upgradeInterval);
        return;
      }
      if (upgradeAttempts % 5 === 0) {
        console.log(
          `\u{1F504} [StarryNight] Still monitoring for API availability... (attempt ${upgradeAttempts}/${maxUpgradeAttempts})`
        );
        console.log("\u{1F504} [StarryNight] Current API status:", {
          player: !!currentAPIs.player,
          platform: !!currentAPIs.platform,
          menu: !!currentAPIs.menu,
          react: !!currentAPIs.react,
          reactDOM: !!currentAPIs.reactDOM
        });
      }
    }, "checkForUpgrade");
    const upgradeInterval = setInterval(checkForUpgrade, upgradeCheckInterval);
    const spicetifyReadyHandler = /* @__PURE__ */ __name(() => {
      console.log(
        "\u{1F3B5} [StarryNight] Spicetify ready event detected - checking for upgrade..."
      );
      checkForUpgrade();
    }, "spicetifyReadyHandler");
    if (window.Spicetify) {
      if (window.Spicetify.Player) {
        window.Spicetify.Player.addEventListener?.(
          "songchange",
          spicetifyReadyHandler
        );
      }
    }
    setTimeout(() => {
      if (window.Spicetify?.Player) {
        window.Spicetify.Player.removeEventListener?.(
          "songchange",
          spicetifyReadyHandler
        );
      }
    }, maxUpgradeAttempts * upgradeCheckInterval);
  }
  __name(setupProgressiveEnhancement, "setupProgressiveEnhancement");
  async function upgradeToFullMode(year3000System, availableAPIs) {
    try {
      console.log("\u{1F680} [StarryNight] Beginning upgrade to full mode...");
      if (!year3000System) {
        throw new Error("Year3000System instance not available");
      }
      if (typeof year3000System.upgradeToFullMode === "function") {
        console.log("\u{1F527} [StarryNight] Using system's built-in upgrade method...");
        await year3000System.upgradeToFullMode({
          player: availableAPIs.player,
          platform: availableAPIs.platform,
          config: window.Spicetify?.Config,
          degradedMode: false
        });
      } else {
        console.log(
          "\u{1F527} [StarryNight] System upgrade method not available - attempting manual initialization..."
        );
        if (year3000System.setupMusicAnalysisAndColorExtraction) {
          console.log(
            "\u{1F3B5} [StarryNight] Setting up music analysis and color extraction..."
          );
          await year3000System.setupMusicAnalysisAndColorExtraction();
        }
        if (availableAPIs.react && availableAPIs.reactDOM) {
          try {
            console.log("\u2699\uFE0F [StarryNight] Initializing settings UI...");
            const settingsUiModule = await Promise.resolve().then(() => (init_StarryNightSettings(), StarryNightSettings_exports));
            await settingsUiModule.initializeStarryNightSettings?.();
            console.log("\u2705 [StarryNight] Settings UI initialized successfully");
          } catch (error) {
            console.warn(
              "\u26A0\uFE0F [StarryNight] Failed to initialize settings UI during upgrade:",
              error
            );
          }
        }
      }
      if (year3000System.eventBus?.emitSync) {
        year3000System.eventBus.emitSync("system:upgraded-to-full-mode", {
          timestamp: Date.now(),
          availableAPIs: {
            player: !!availableAPIs.player,
            platform: !!availableAPIs.platform,
            menu: !!availableAPIs.menu,
            react: !!availableAPIs.react,
            reactDOM: !!availableAPIs.reactDOM
          }
        });
      }
      console.log(
        "\u{1F31F} [StarryNight] Upgrade to full mode completed successfully!"
      );
    } catch (error) {
      console.error("\u274C [StarryNight] Upgrade to full mode failed:", error);
      throw error;
    }
  }
  __name(upgradeToFullMode, "upgradeToFullMode");
})();
//# sourceMappingURL=theme.js.map
